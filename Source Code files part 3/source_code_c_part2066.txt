)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineComp_VTrackInsBefore_Proxy( 
    IAMTimelineComp * This,
    IAMTimelineObj *pVirtualTrack,
    long Priority);


void __RPC_STUB IAMTimelineComp_VTrackInsBefore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineComp_VTrackSwapPriorities_Proxy( 
    IAMTimelineComp * This,
    long VirtualTrackA,
    long VirtualTrackB);


void __RPC_STUB IAMTimelineComp_VTrackSwapPriorities_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineComp_VTrackGetCount_Proxy( 
    IAMTimelineComp * This,
    long *pVal);


void __RPC_STUB IAMTimelineComp_VTrackGetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineComp_GetVTrack_Proxy( 
    IAMTimelineComp * This,
    /* [out] */ IAMTimelineObj **ppVirtualTrack,
    long Which);


void __RPC_STUB IAMTimelineComp_GetVTrack_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineComp_GetCountOfType_Proxy( 
    IAMTimelineComp * This,
    long *pVal,
    long *pValWithComps,
    TIMELINE_MAJOR_TYPE MajorType);


void __RPC_STUB IAMTimelineComp_GetCountOfType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineComp_GetRecursiveLayerOfType_Proxy( 
    IAMTimelineComp * This,
    /* [out] */ IAMTimelineObj **ppVirtualTrack,
    long WhichLayer,
    TIMELINE_MAJOR_TYPE Type);


void __RPC_STUB IAMTimelineComp_GetRecursiveLayerOfType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineComp_GetRecursiveLayerOfTypeI_Proxy( 
    IAMTimelineComp * This,
    /* [out] */ IAMTimelineObj **ppVirtualTrack,
    /* [out][in] */ long *pWhichLayer,
    TIMELINE_MAJOR_TYPE Type);


void __RPC_STUB IAMTimelineComp_GetRecursiveLayerOfTypeI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimelineComp_GetNextVTrack_Proxy( 
    IAMTimelineComp * This,
    IAMTimelineObj *pVirtualTrack,
    /* [out] */ IAMTimelineObj **ppNextVirtualTrack);


void __RPC_STUB IAMTimelineComp_GetNextVTrack_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMTimelineComp_INTERFACE_DEFINED__ */


#ifndef __IAMTimelineGroup_INTERFACE_DEFINED__
#define __IAMTimelineGroup_INTERFACE_DEFINED__

/* interface IAMTimelineGroup */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IAMTimelineGroup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9EED4F00-B8A6-11d2-8023-00C0DF10D434")
    IAMTimelineGroup : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetTimeline( 
            IAMTimeline *pTimeline) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetTimeline( 
            /* [out] */ IAMTimeline **ppTimeline) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPriority( 
            long *pPriority) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetMediaType( 
            /* [out] */ AM_MEDIA_TYPE *__MIDL_0043) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetMediaType( 
            /* [in] */ AM_MEDIA_TYPE *__MIDL_0044) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetOutputFPS( 
            double FPS) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetOutputFPS( 
            double *pFPS) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetGroupName( 
            BSTR pGroupName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetGroupName( 
            /* [retval][out] */ BSTR *pGroupName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetPreviewMode( 
            BOOL fPreview) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPreviewMode( 
            BOOL *pfPreview) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetMediaTypeForVB( 
            /* [in] */ long Val) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetOutputBuffering( 
            /* [out] */ int *pnBuffer) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetOutputBuffering( 
            /* [in] */ int nBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSmartRecompressFormat( 
            long *pFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSmartRecompressFormat( 
            long **ppFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsSmartRecompressFormatSet( 
            BOOL *pVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsRecompressFormatDirty( 
            BOOL *pVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearRecompressFormatDirty( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRecompFormatFromSource( 
            IAMTimelineSrc *pSource) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMTimelineGroupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMTimelineGroup * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMTimelineGroup * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMTimelineGroup * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetTimeline )( 
            IAMTimelineGroup * This,
            IAMTimeline *pTimeline);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetTimeline )( 
            IAMTimelineGroup * This,
            /* [out] */ IAMTimeline **ppTimeline);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPriority )( 
            IAMTimelineGroup * This,
            long *pPriority);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetMediaType )( 
            IAMTimelineGroup * This,
            /* [out] */ AM_MEDIA_TYPE *__MIDL_0043);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetMediaType )( 
            IAMTimelineGroup * This,
            /* [in] */ AM_MEDIA_TYPE *__MIDL_0044);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetOutputFPS )( 
            IAMTimelineGroup * This,
            double FPS);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetOutputFPS )( 
            IAMTimelineGroup * This,
            double *pFPS);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetGroupName )( 
            IAMTimelineGroup * This,
            BSTR pGroupName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetGroupName )( 
            IAMTimelineGroup * This,
            /* [retval][out] */ BSTR *pGroupName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetPreviewMode )( 
            IAMTimelineGroup * This,
            BOOL fPreview);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPreviewMode )( 
            IAMTimelineGroup * This,
            BOOL *pfPreview);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetMediaTypeForVB )( 
            IAMTimelineGroup * This,
            /* [in] */ long Val);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetOutputBuffering )( 
            IAMTimelineGroup * This,
            /* [out] */ int *pnBuffer);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetOutputBuffering )( 
            IAMTimelineGroup * This,
            /* [in] */ int nBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *SetSmartRecompressFormat )( 
            IAMTimelineGroup * This,
            long *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE *GetSmartRecompressFormat )( 
            IAMTimelineGroup * This,
            long **ppFormat);
        
        HRESULT ( STDMETHODCALLTYPE *IsSmartRecompressFormatSet )( 
            IAMTimelineGroup * This,
            BOOL *pVal);
        
        HRESULT ( STDMETHODCALLTYPE *IsRecompressFormatDirty )( 
            IAMTimelineGroup * This,
            BOOL *pVal);
        
        HRESULT ( STDMETHODCALLTYPE *ClearRecompressFormatDirty )( 
            IAMTimelineGroup * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetRecompFormatFromSource )( 
            IAMTimelineGroup * This,
            IAMTimelineSrc *pSource);
        
        END_INTERFACE
    } IAMTimelineGroupVtbl;

    interface IAMTimelineGroup
    {
        CONST_VTBL struct IAMTimelineGroupVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMTimelineGroup_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMTimelineGroup_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMTimelineGroup_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMTimelineGroup_SetTimeline(This,pTimeline)	\
    (This)->lpVtbl -> SetTimeline(This,pTimeline)

#define IAMTimelineGroup_GetTimeline(This,ppTimeline)	\
    (This)->lpVtbl -> GetTimeline(This,ppTimeline)

#define IAMTimelineGroup_GetPriority(This,pPriority)	\
    (This)->lpVtbl -> GetPriority(This,pPriority)

#define IAMTimelineGroup_GetMediaType(This,__MIDL_0043)	\
    (This)->lpVtbl -> GetMediaType(This,__MIDL_0043)

#define IAMTimelineGroup_SetMediaType(This,__MIDL_0044)	\
    (This)->lpVtbl -> SetMediaType(This,__MIDL_0044)

#define IAMTimelineGroup_SetOutputFPS(This,FPS)	\
    (This)->lpVtbl -> SetOutputFPS(This,FPS)

#define IAMTimelineGroup_GetOutputFPS(This,pFPS)	\
    (This)->lpVtbl -> GetOutputFPS(This,pFPS)

#define IAMTimelineGroup_SetGroupName(This,pGroupName)	\
    (This)->lpVtbl -> SetGroupName(This,pGroupName)

#define IAMTimelineGroup_GetGroupName(This,pGroupName)	\
    (This)->lpVtbl -> GetGroupName(This,pGroupName)

#define IAMTimelineGroup_SetPreviewMode(This,fPreview)	\
    (This)->lpVtbl -> SetPreviewMode(This,fPreview)

#define IAMTimelineGroup_GetPreviewMode(This,pfPreview)	\
    (This)->lpVtbl -> GetPreviewMode(This,pfPreview)

#define IAMTimelineGroup_SetMediaTypeForVB(This,Val)	\
    (This)->lpVtbl -> SetMediaTypeForVB(This,Val)

#define IAMTimelineGroup_GetOutputBuffering(This,pnBuffer)	\
    (This)->lpVtbl -> GetOutputBuffering(This,pnBuffer)

#define IAMTimelineGroup_SetOutputBuffering(This,nBuffer)	\
    (This)->lpVtbl -> SetOutputBuffering(This,nBuffer)

#define IAMTimelineGroup_SetSmartRecompressFormat(This,pFormat)	\
    (This)->lpVtbl -> SetSmartRecompressFormat(This,pFormat)

#define IAMTimelineGroup_GetSmartRecompressFormat(This,ppFormat)	\
    (This)->lpVtbl -> GetSmartRecompressFormat(This,ppFormat)

#define IAMTimelineGroup_IsSmartRecompressFormatSet(This,pVal)	\
    (This)->lpVtbl -> IsSmartRecompressFormatSet(This,pVal)

#define IAMTimelineGroup_IsRecompressFormatDirty(This,pVal)	\
    (This)->lpVtbl -> IsRecompressFormatDirty(This,pVal)

#define IAMTimelineGroup_ClearRecompressFormatDirty(This)	\
    (This)->lpVtbl -> ClearRecompressFormatDirty(This)

#define IAMTimelineGroup_SetRecompFormatFromSource(This,pSource)	\
    (This)->lpVtbl -> SetRecompFormatFromSource(This,pSource)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineGroup_SetTimeline_Proxy( 
    IAMTimelineGroup * This,
    IAMTimeline *pTimeline);


void __RPC_STUB IAMTimelineGroup_SetTimeline_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineGroup_GetTimeline_Proxy( 
    IAMTimelineGroup * This,
    /* [out] */ IAMTimeline **ppTimeline);


void __RPC_STUB IAMTimelineGroup_GetTimeline_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineGroup_GetPriority_Proxy( 
    IAMTimelineGroup * This,
    long *pPriority);


void __RPC_STUB IAMTimelineGroup_GetPriority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineGroup_GetMediaType_Proxy( 
    IAMTimelineGroup * This,
    /* [out] */ AM_MEDIA_TYPE *__MIDL_0043);


void __RPC_STUB IAMTimelineGroup_GetMediaType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineGroup_SetMediaType_Proxy( 
    IAMTimelineGroup * This,
    /* [in] */ AM_MEDIA_TYPE *__MIDL_0044);


void __RPC_STUB IAMTimelineGroup_SetMediaType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineGroup_SetOutputFPS_Proxy( 
    IAMTimelineGroup * This,
    double FPS);


void __RPC_STUB IAMTimelineGroup_SetOutputFPS_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineGroup_GetOutputFPS_Proxy( 
    IAMTimelineGroup * This,
    double *pFPS);


void __RPC_STUB IAMTimelineGroup_GetOutputFPS_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineGroup_SetGroupName_Proxy( 
    IAMTimelineGroup * This,
    BSTR pGroupName);


void __RPC_STUB IAMTimelineGroup_SetGroupName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineGroup_GetGroupName_Proxy( 
    IAMTimelineGroup * This,
    /* [retval][out] */ BSTR *pGroupName);


void __RPC_STUB IAMTimelineGroup_GetGroupName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineGroup_SetPreviewMode_Proxy( 
    IAMTimelineGroup * This,
    BOOL fPreview);


void __RPC_STUB IAMTimelineGroup_SetPreviewMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineGroup_GetPreviewMode_Proxy( 
    IAMTimelineGroup * This,
    BOOL *pfPreview);


void __RPC_STUB IAMTimelineGroup_GetPreviewMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineGroup_SetMediaTypeForVB_Proxy( 
    IAMTimelineGroup * This,
    /* [in] */ long Val);


void __RPC_STUB IAMTimelineGroup_SetMediaTypeForVB_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineGroup_GetOutputBuffering_Proxy( 
    IAMTimelineGroup * This,
    /* [out] */ int *pnBuffer);


void __RPC_STUB IAMTimelineGroup_GetOutputBuffering_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimelineGroup_SetOutputBuffering_Proxy( 
    IAMTimelineGroup * This,
    /* [in] */ int nBuffer);


void __RPC_STUB IAMTimelineGroup_SetOutputBuffering_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimelineGroup_SetSmartRecompressFormat_Proxy( 
    IAMTimelineGroup * This,
    long *pFormat);


void __RPC_STUB IAMTimelineGroup_SetSmartRecompressFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimelineGroup_GetSmartRecompressFormat_Proxy( 
    IAMTimelineGroup * This,
    long **ppFormat);


void __RPC_STUB IAMTimelineGroup_GetSmartRecompressFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimelineGroup_IsSmartRecompressFormatSet_Proxy( 
    IAMTimelineGroup * This,
    BOOL *pVal);


void __RPC_STUB IAMTimelineGroup_IsSmartRecompressFormatSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimelineGroup_IsRecompressFormatDirty_Proxy( 
    IAMTimelineGroup * This,
    BOOL *pVal);


void __RPC_STUB IAMTimelineGroup_IsRecompressFormatDirty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimelineGroup_ClearRecompressFormatDirty_Proxy( 
    IAMTimelineGroup * This);


void __RPC_STUB IAMTimelineGroup_ClearRecompressFormatDirty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimelineGroup_SetRecompFormatFromSource_Proxy( 
    IAMTimelineGroup * This,
    IAMTimelineSrc *pSource);


void __RPC_STUB IAMTimelineGroup_SetRecompFormatFromSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMTimelineGroup_INTERFACE_DEFINED__ */


#ifndef __IAMTimeline_INTERFACE_DEFINED__
#define __IAMTimeline_INTERFACE_DEFINED__

/* interface IAMTimeline */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IAMTimeline;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("78530B74-61F9-11D2-8CAD-00A024580902")
    IAMTimeline : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateEmptyNode( 
            /* [out] */ IAMTimelineObj **ppObj,
            TIMELINE_MAJOR_TYPE Type) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddGroup( 
            IAMTimelineObj *pGroup) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemGroupFromList( 
            IAMTimelineObj *pGroup) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGroup( 
            /* [out] */ IAMTimelineObj **ppGroup,
            long WhichGroup) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGroupCount( 
            long *pCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearAllGroups( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInsertMode( 
            long *pMode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetInsertMode( 
            long Mode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnableTransitions( 
            BOOL fEnabled) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE TransitionsEnabled( 
            BOOL *pfEnabled) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnableEffects( 
            BOOL fEnabled) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EffectsEnabled( 
            BOOL *pfEnabled) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetInterestRange( 
            REFERENCE_TIME Start,
            REFERENCE_TIME Stop) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDuration( 
            REFERENCE_TIME *pDuration) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDuration2( 
            double *pDuration) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetDefaultFPS( 
            double FPS) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDefaultFPS( 
            double *pFPS) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE IsDirty( 
            BOOL *pDirty) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDirtyRange( 
            REFERENCE_TIME *pStart,
            REFERENCE_TIME *pStop) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCountOfType( 
            long Group,
            long *pVal,
            long *pValWithComps,
            TIMELINE_MAJOR_TYPE MajorType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ValidateSourceNames( 
            long ValidateFlags,
            IMediaLocator *pOverride,
            LONG_PTR NotifyEventHandle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDefaultTransition( 
            GUID *pGuid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultTransition( 
            GUID *pGuid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDefaultEffect( 
            GUID *pGuid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultEffect( 
            GUID *pGuid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDefaultTransitionB( 
            BSTR pGuid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultTransitionB( 
            /* [retval][out] */ BSTR *pGuid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDefaultEffectB( 
            BSTR pGuid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultEffectB( 
            /* [retval][out] */ BSTR *pGuid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMTimelineVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMTimeline * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMTimeline * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMTimeline * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateEmptyNode )( 
            IAMTimeline * This,
            /* [out] */ IAMTimelineObj **ppObj,
            TIMELINE_MAJOR_TYPE Type);
        
        HRESULT ( STDMETHODCALLTYPE *AddGroup )( 
            IAMTimeline * This,
            IAMTimelineObj *pGroup);
        
        HRESULT ( STDMETHODCALLTYPE *RemGroupFromList )( 
            IAMTimeline * This,
            IAMTimelineObj *pGroup);
        
        HRESULT ( STDMETHODCALLTYPE *GetGroup )( 
            IAMTimeline * This,
            /* [out] */ IAMTimelineObj **ppGroup,
            long WhichGroup);
        
        HRESULT ( STDMETHODCALLTYPE *GetGroupCount )( 
            IAMTimeline * This,
            long *pCount);
        
        HRESULT ( STDMETHODCALLTYPE *ClearAllGroups )( 
            IAMTimeline * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetInsertMode )( 
            IAMTimeline * This,
            long *pMode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetInsertMode )( 
            IAMTimeline * This,
            long Mode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnableTransitions )( 
            IAMTimeline * This,
            BOOL fEnabled);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *TransitionsEnabled )( 
            IAMTimeline * This,
            BOOL *pfEnabled);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnableEffects )( 
            IAMTimeline * This,
            BOOL fEnabled);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EffectsEnabled )( 
            IAMTimeline * This,
            BOOL *pfEnabled);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetInterestRange )( 
            IAMTimeline * This,
            REFERENCE_TIME Start,
            REFERENCE_TIME Stop);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDuration )( 
            IAMTimeline * This,
            REFERENCE_TIME *pDuration);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDuration2 )( 
            IAMTimeline * This,
            double *pDuration);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetDefaultFPS )( 
            IAMTimeline * This,
            double FPS);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDefaultFPS )( 
            IAMTimeline * This,
            double *pFPS);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *IsDirty )( 
            IAMTimeline * This,
            BOOL *pDirty);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDirtyRange )( 
            IAMTimeline * This,
            REFERENCE_TIME *pStart,
            REFERENCE_TIME *pStop);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCountOfType )( 
            IAMTimeline * This,
            long Group,
            long *pVal,
            long *pValWithComps,
            TIMELINE_MAJOR_TYPE MajorType);
        
        HRESULT ( STDMETHODCALLTYPE *ValidateSourceNames )( 
            IAMTimeline * This,
            long ValidateFlags,
            IMediaLocator *pOverride,
            LONG_PTR NotifyEventHandle);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultTransition )( 
            IAMTimeline * This,
            GUID *pGuid);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultTransition )( 
            IAMTimeline * This,
            GUID *pGuid);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultEffect )( 
            IAMTimeline * This,
            GUID *pGuid);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultEffect )( 
            IAMTimeline * This,
            GUID *pGuid);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultTransitionB )( 
            IAMTimeline * This,
            BSTR pGuid);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultTransitionB )( 
            IAMTimeline * This,
            /* [retval][out] */ BSTR *pGuid);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultEffectB )( 
            IAMTimeline * This,
            BSTR pGuid);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultEffectB )( 
            IAMTimeline * This,
            /* [retval][out] */ BSTR *pGuid);
        
        END_INTERFACE
    } IAMTimelineVtbl;

    interface IAMTimeline
    {
        CONST_VTBL struct IAMTimelineVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMTimeline_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMTimeline_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMTimeline_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMTimeline_CreateEmptyNode(This,ppObj,Type)	\
    (This)->lpVtbl -> CreateEmptyNode(This,ppObj,Type)

#define IAMTimeline_AddGroup(This,pGroup)	\
    (This)->lpVtbl -> AddGroup(This,pGroup)

#define IAMTimeline_RemGroupFromList(This,pGroup)	\
    (This)->lpVtbl -> RemGroupFromList(This,pGroup)

#define IAMTimeline_GetGroup(This,ppGroup,WhichGroup)	\
    (This)->lpVtbl -> GetGroup(This,ppGroup,WhichGroup)

#define IAMTimeline_GetGroupCount(This,pCount)	\
    (This)->lpVtbl -> GetGroupCount(This,pCount)

#define IAMTimeline_ClearAllGroups(This)	\
    (This)->lpVtbl -> ClearAllGroups(This)

#define IAMTimeline_GetInsertMode(This,pMode)	\
    (This)->lpVtbl -> GetInsertMode(This,pMode)

#define IAMTimeline_SetInsertMode(This,Mode)	\
    (This)->lpVtbl -> SetInsertMode(This,Mode)

#define IAMTimeline_EnableTransitions(This,fEnabled)	\
    (This)->lpVtbl -> EnableTransitions(This,fEnabled)

#define IAMTimeline_TransitionsEnabled(This,pfEnabled)	\
    (This)->lpVtbl -> TransitionsEnabled(This,pfEnabled)

#define IAMTimeline_EnableEffects(This,fEnabled)	\
    (This)->lpVtbl -> EnableEffects(This,fEnabled)

#define IAMTimeline_EffectsEnabled(This,pfEnabled)	\
    (This)->lpVtbl -> EffectsEnabled(This,pfEnabled)

#define IAMTimeline_SetInterestRange(This,Start,Stop)	\
    (This)->lpVtbl -> SetInterestRange(This,Start,Stop)

#define IAMTimeline_GetDuration(This,pDuration)	\
    (This)->lpVtbl -> GetDuration(This,pDuration)

#define IAMTimeline_GetDuration2(This,pDuration)	\
    (This)->lpVtbl -> GetDuration2(This,pDuration)

#define IAMTimeline_SetDefaultFPS(This,FPS)	\
    (This)->lpVtbl -> SetDefaultFPS(This,FPS)

#define IAMTimeline_GetDefaultFPS(This,pFPS)	\
    (This)->lpVtbl -> GetDefaultFPS(This,pFPS)

#define IAMTimeline_IsDirty(This,pDirty)	\
    (This)->lpVtbl -> IsDirty(This,pDirty)

#define IAMTimeline_GetDirtyRange(This,pStart,pStop)	\
    (This)->lpVtbl -> GetDirtyRange(This,pStart,pStop)

#define IAMTimeline_GetCountOfType(This,Group,pVal,pValWithComps,MajorType)	\
    (This)->lpVtbl -> GetCountOfType(This,Group,pVal,pValWithComps,MajorType)

#define IAMTimeline_ValidateSourceNames(This,ValidateFlags,pOverride,NotifyEventHandle)	\
    (This)->lpVtbl -> ValidateSourceNames(This,ValidateFlags,pOverride,NotifyEventHandle)

#define IAMTimeline_SetDefaultTransition(This,pGuid)	\
    (This)->lpVtbl -> SetDefaultTransition(This,pGuid)

#define IAMTimeline_GetDefaultTransition(This,pGuid)	\
    (This)->lpVtbl -> GetDefaultTransition(This,pGuid)

#define IAMTimeline_SetDefaultEffect(This,pGuid)	\
    (This)->lpVtbl -> SetDefaultEffect(This,pGuid)

#define IAMTimeline_GetDefaultEffect(This,pGuid)	\
    (This)->lpVtbl -> GetDefaultEffect(This,pGuid)

#define IAMTimeline_SetDefaultTransitionB(This,pGuid)	\
    (This)->lpVtbl -> SetDefaultTransitionB(This,pGuid)

#define IAMTimeline_GetDefaultTransitionB(This,pGuid)	\
    (This)->lpVtbl -> GetDefaultTransitionB(This,pGuid)

#define IAMTimeline_SetDefaultEffectB(This,pGuid)	\
    (This)->lpVtbl -> SetDefaultEffectB(This,pGuid)

#define IAMTimeline_GetDefaultEffectB(This,pGuid)	\
    (This)->lpVtbl -> GetDefaultEffectB(This,pGuid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimeline_CreateEmptyNode_Proxy( 
    IAMTimeline * This,
    /* [out] */ IAMTimelineObj **ppObj,
    TIMELINE_MAJOR_TYPE Type);


void __RPC_STUB IAMTimeline_CreateEmptyNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimeline_AddGroup_Proxy( 
    IAMTimeline * This,
    IAMTimelineObj *pGroup);


void __RPC_STUB IAMTimeline_AddGroup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimeline_RemGroupFromList_Proxy( 
    IAMTimeline * This,
    IAMTimelineObj *pGroup);


void __RPC_STUB IAMTimeline_RemGroupFromList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimeline_GetGroup_Proxy( 
    IAMTimeline * This,
    /* [out] */ IAMTimelineObj **ppGroup,
    long WhichGroup);


void __RPC_STUB IAMTimeline_GetGroup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimeline_GetGroupCount_Proxy( 
    IAMTimeline * This,
    long *pCount);


void __RPC_STUB IAMTimeline_GetGroupCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimeline_ClearAllGroups_Proxy( 
    IAMTimeline * This);


void __RPC_STUB IAMTimeline_ClearAllGroups_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimeline_GetInsertMode_Proxy( 
    IAMTimeline * This,
    long *pMode);


void __RPC_STUB IAMTimeline_GetInsertMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimeline_SetInsertMode_Proxy( 
    IAMTimeline * This,
    long Mode);


void __RPC_STUB IAMTimeline_SetInsertMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimeline_EnableTransitions_Proxy( 
    IAMTimeline * This,
    BOOL fEnabled);


void __RPC_STUB IAMTimeline_EnableTransitions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimeline_TransitionsEnabled_Proxy( 
    IAMTimeline * This,
    BOOL *pfEnabled);


void __RPC_STUB IAMTimeline_TransitionsEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimeline_EnableEffects_Proxy( 
    IAMTimeline * This,
    BOOL fEnabled);


void __RPC_STUB IAMTimeline_EnableEffects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimeline_EffectsEnabled_Proxy( 
    IAMTimeline * This,
    BOOL *pfEnabled);


void __RPC_STUB IAMTimeline_EffectsEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimeline_SetInterestRange_Proxy( 
    IAMTimeline * This,
    REFERENCE_TIME Start,
    REFERENCE_TIME Stop);


void __RPC_STUB IAMTimeline_SetInterestRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimeline_GetDuration_Proxy( 
    IAMTimeline * This,
    REFERENCE_TIME *pDuration);


void __RPC_STUB IAMTimeline_GetDuration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimeline_GetDuration2_Proxy( 
    IAMTimeline * This,
    double *pDuration);


void __RPC_STUB IAMTimeline_GetDuration2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimeline_SetDefaultFPS_Proxy( 
    IAMTimeline * This,
    double FPS);


void __RPC_STUB IAMTimeline_SetDefaultFPS_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimeline_GetDefaultFPS_Proxy( 
    IAMTimeline * This,
    double *pFPS);


void __RPC_STUB IAMTimeline_GetDefaultFPS_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimeline_IsDirty_Proxy( 
    IAMTimeline * This,
    BOOL *pDirty);


void __RPC_STUB IAMTimeline_IsDirty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimeline_GetDirtyRange_Proxy( 
    IAMTimeline * This,
    REFERENCE_TIME *pStart,
    REFERENCE_TIME *pStop);


void __RPC_STUB IAMTimeline_GetDirtyRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMTimeline_GetCountOfType_Proxy( 
    IAMTimeline * This,
    long Group,
    long *pVal,
    long *pValWithComps,
    TIMELINE_MAJOR_TYPE MajorType);


void __RPC_STUB IAMTimeline_GetCountOfType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimeline_ValidateSourceNames_Proxy( 
    IAMTimeline * This,
    long ValidateFlags,
    IMediaLocator *pOverride,
    LONG_PTR NotifyEventHandle);


void __RPC_STUB IAMTimeline_ValidateSourceNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimeline_SetDefaultTransition_Proxy( 
    IAMTimeline * This,
    GUID *pGuid);


void __RPC_STUB IAMTimeline_SetDefaultTransition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimeline_GetDefaultTransition_Proxy( 
    IAMTimeline * This,
    GUID *pGuid);


void __RPC_STUB IAMTimeline_GetDefaultTransition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimeline_SetDefaultEffect_Proxy( 
    IAMTimeline * This,
    GUID *pGuid);


void __RPC_STUB IAMTimeline_SetDefaultEffect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimeline_GetDefaultEffect_Proxy( 
    IAMTimeline * This,
    GUID *pGuid);


void __RPC_STUB IAMTimeline_GetDefaultEffect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimeline_SetDefaultTransitionB_Proxy( 
    IAMTimeline * This,
    BSTR pGuid);


void __RPC_STUB IAMTimeline_SetDefaultTransitionB_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimeline_GetDefaultTransitionB_Proxy( 
    IAMTimeline * This,
    /* [retval][out] */ BSTR *pGuid);


void __RPC_STUB IAMTimeline_GetDefaultTransitionB_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimeline_SetDefaultEffectB_Proxy( 
    IAMTimeline * This,
    BSTR pGuid);


void __RPC_STUB IAMTimeline_SetDefaultEffectB_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimeline_GetDefaultEffectB_Proxy( 
    IAMTimeline * This,
    /* [retval][out] */ BSTR *pGuid);


void __RPC_STUB IAMTimeline_GetDefaultEffectB_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMTimeline_INTERFACE_DEFINED__ */


#ifndef __IXml2Dex_INTERFACE_DEFINED__
#define __IXml2Dex_INTERFACE_DEFINED__

/* interface IXml2Dex */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IXml2Dex;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("18C628ED-962A-11D2-8D08-00A0C9441E20")
    IXml2Dex : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateGraphFromFile( 
            /* [out] */ IUnknown **ppGraph,
            IUnknown *pTimeline,
            BSTR Filename) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE WriteGrfFile( 
            IUnknown *pGraph,
            BSTR FileName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE WriteXMLFile( 
            IUnknown *pTimeline,
            BSTR FileName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ReadXMLFile( 
            IUnknown *pTimeline,
            BSTR XMLName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Delete( 
            IUnknown *pTimeline,
            double dStart,
            double dEnd) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE WriteXMLPart( 
            IUnknown *pTimeline,
            double dStart,
            double dEnd,
            BSTR FileName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PasteXMLFile( 
            IUnknown *pTimeline,
            double dStart,
            BSTR FileName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CopyXML( 
            IUnknown *pTimeline,
            double dStart,
            double dEnd) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PasteXML( 
            IUnknown *pTimeline,
            double dStart) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ReadXML( 
            IUnknown *pTimeline,
            IUnknown *pXML) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE WriteXML( 
            IUnknown *pTimeline,
            BSTR *pbstrXML) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXml2DexVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXml2Dex * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXml2Dex * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXml2Dex * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXml2Dex * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXml2Dex * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXml2Dex * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXml2Dex * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateGraphFromFile )( 
            IXml2Dex * This,
            /* [out] */ IUnknown **ppGraph,
            IUnknown *pTimeline,
            BSTR Filename);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *WriteGrfFile )( 
            IXml2Dex * This,
            IUnknown *pGraph,
            BSTR FileName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *WriteXMLFile )( 
            IXml2Dex * This,
            IUnknown *pTimeline,
            BSTR FileName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ReadXMLFile )( 
            IXml2Dex * This,
            IUnknown *pTimeline,
            BSTR XMLName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Delete )( 
            IXml2Dex * This,
            IUnknown *pTimeline,
            double dStart,
            double dEnd);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *WriteXMLPart )( 
            IXml2Dex * This,
            IUnknown *pTimeline,
            double dStart,
            double dEnd,
            BSTR FileName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *PasteXMLFile )( 
            IXml2Dex * This,
            IUnknown *pTimeline,
            double dStart,
            BSTR FileName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CopyXML )( 
            IXml2Dex * This,
            IUnknown *pTimeline,
            double dStart,
            double dEnd);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *PasteXML )( 
            IXml2Dex * This,
            IUnknown *pTimeline,
            double dStart);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IXml2Dex * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ReadXML )( 
            IXml2Dex * This,
            IUnknown *pTimeline,
            IUnknown *pXML);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *WriteXML )( 
            IXml2Dex * This,
            IUnknown *pTimeline,
            BSTR *pbstrXML);
        
        END_INTERFACE
    } IXml2DexVtbl;

    interface IXml2Dex
    {
        CONST_VTBL struct IXml2DexVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXml2Dex_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXml2Dex_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXml2Dex_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXml2Dex_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXml2Dex_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXml2Dex_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXml2Dex_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXml2Dex_CreateGraphFromFile(This,ppGraph,pTimeline,Filename)	\
    (This)->lpVtbl -> CreateGraphFromFile(This,ppGraph,pTimeline,Filename)

#define IXml2Dex_WriteGrfFile(This,pGraph,FileName)	\
    (This)->lpVtbl -> WriteGrfFile(This,pGraph,FileName)

#define IXml2Dex_WriteXMLFile(This,pTimeline,FileName)	\
    (This)->lpVtbl -> WriteXMLFile(This,pTimeline,FileName)

#define IXml2Dex_ReadXMLFile(This,pTimeline,XMLName)	\
    (This)->lpVtbl -> ReadXMLFile(This,pTimeline,XMLName)

#define IXml2Dex_Delete(This,pTimeline,dStart,dEnd)	\
    (This)->lpVtbl -> Delete(This,pTimeline,dStart,dEnd)

#define IXml2Dex_WriteXMLPart(This,pTimeline,dStart,dEnd,FileName)	\
    (This)->lpVtbl -> WriteXMLPart(This,pTimeline,dStart,dEnd,FileName)

#define IXml2Dex_PasteXMLFile(This,pTimeline,dStart,FileName)	\
    (This)->lpVtbl -> PasteXMLFile(This,pTimeline,dStart,FileName)

#define IXml2Dex_CopyXML(This,pTimeline,dStart,dEnd)	\
    (This)->lpVtbl -> CopyXML(This,pTimeline,dStart,dEnd)

#define IXml2Dex_PasteXML(This,pTimeline,dStart)	\
    (This)->lpVtbl -> PasteXML(This,pTimeline,dStart)

#define IXml2Dex_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IXml2Dex_ReadXML(This,pTimeline,pXML)	\
    (This)->lpVtbl -> ReadXML(This,pTimeline,pXML)

#define IXml2Dex_WriteXML(This,pTimeline,pbstrXML)	\
    (This)->lpVtbl -> WriteXML(This,pTimeline,pbstrXML)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXml2Dex_CreateGraphFromFile_Proxy( 
    IXml2Dex * This,
    /* [out] */ IUnknown **ppGraph,
    IUnknown *pTimeline,
    BSTR Filename);


void __RPC_STUB IXml2Dex_CreateGraphFromFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXml2Dex_WriteGrfFile_Proxy( 
    IXml2Dex * This,
    IUnknown *pGraph,
    BSTR FileName);


void __RPC_STUB IXml2Dex_WriteGrfFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXml2Dex_WriteXMLFile_Proxy( 
    IXml2Dex * This,
    IUnknown *pTimeline,
    BSTR FileName);


void __RPC_STUB IXml2Dex_WriteXMLFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXml2Dex_ReadXMLFile_Proxy( 
    IXml2Dex * This,
    IUnknown *pTimeline,
    BSTR XMLName);


void __RPC_STUB IXml2Dex_ReadXMLFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXml2Dex_Delete_Proxy( 
    IXml2Dex * This,
    IUnknown *pTimeline,
    double dStart,
    double dEnd);


void __RPC_STUB IXml2Dex_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXml2Dex_WriteXMLPart_Proxy( 
    IXml2Dex * This,
    IUnknown *pTimeline,
    double dStart,
    double dEnd,
    BSTR FileName);


void __RPC_STUB IXml2Dex_WriteXMLPart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXml2Dex_PasteXMLFile_Proxy( 
    IXml2Dex * This,
    IUnknown *pTimeline,
    double dStart,
    BSTR FileName);


void __RPC_STUB IXml2Dex_PasteXMLFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXml2Dex_CopyXML_Proxy( 
    IXml2Dex * This,
    IUnknown *pTimeline,
    double dStart,
    double dEnd);


void __RPC_STUB IXml2Dex_CopyXML_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXml2Dex_PasteXML_Proxy( 
    IXml2Dex * This,
    IUnknown *pTimeline,
    double dStart);


void __RPC_STUB IXml2Dex_PasteXML_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXml2Dex_Reset_Proxy( 
    IXml2Dex * This);


void __RPC_STUB IXml2Dex_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXml2Dex_ReadXML_Proxy( 
    IXml2Dex * This,
    IUnknown *pTimeline,
    IUnknown *pXML);


void __RPC_STUB IXml2Dex_ReadXML_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXml2Dex_WriteXML_Proxy( 
    IXml2Dex * This,
    IUnknown *pTimeline,
    BSTR *pbstrXML);


void __RPC_STUB IXml2Dex_WriteXML_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXml2Dex_INTERFACE_DEFINED__ */


#ifndef __IAMErrorLog_INTERFACE_DEFINED__
#define __IAMErrorLog_INTERFACE_DEFINED__

/* interface IAMErrorLog */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IAMErrorLog;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E43E73A2-0EFA-11d3-9601-00A0C9441E20")
    IAMErrorLog : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE LogError( 
            long Severity,
            BSTR pErrorString,
            long ErrorCode,
            long hresult,
            /* [in] */ VARIANT *pExtraInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMErrorLogVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMErrorLog * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMErrorLog * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMErrorLog * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *LogError )( 
            IAMErrorLog * This,
            long Severity,
            BSTR pErrorString,
            long ErrorCode,
            long hresult,
            /* [in] */ VARIANT *pExtraInfo);
        
        END_INTERFACE
    } IAMErrorLogVtbl;

    interface IAMErrorLog
    {
        CONST_VTBL struct IAMErrorLogVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMErrorLog_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMErrorLog_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMErrorLog_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMErrorLog_LogError(This,Severity,pErrorString,ErrorCode,hresult,pExtraInfo)	\
    (This)->lpVtbl -> LogError(This,Severity,pErrorString,ErrorCode,hresult,pExtraInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAMErrorLog_LogError_Proxy( 
    IAMErrorLog * This,
    long Severity,
    BSTR pErrorString,
    long ErrorCode,
    long hresult,
    /* [in] */ VARIANT *pExtraInfo);


void __RPC_STUB IAMErrorLog_LogError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMErrorLog_INTERFACE_DEFINED__ */


#ifndef __IAMSetErrorLog_INTERFACE_DEFINED__
#define __IAMSetErrorLog_INTERFACE_DEFINED__

/* interface IAMSetErrorLog */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IAMSetErrorLog;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("963566DA-BE21-4eaf-88E9-35704F8F52A1")
    IAMSetErrorLog : public IUnknown
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ErrorLog( 
            /* [retval][out] */ IAMErrorLog **pVal) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_ErrorLog( 
            /* [in] */ IAMErrorLog *newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMSetErrorLogVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMSetErrorLog * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMSetErrorLog * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMSetErrorLog * This);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ErrorLog )( 
            IAMSetErrorLog * This,
            /* [retval][out] */ IAMErrorLog **pVal);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ErrorLog )( 
            IAMSetErrorLog * This,
            /* [in] */ IAMErrorLog *newVal);
        
        END_INTERFACE
    } IAMSetErrorLogVtbl;

    interface IAMSetErrorLog
    {
        CONST_VTBL struct IAMSetErrorLogVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMSetErrorLog_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMSetErrorLog_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMSetErrorLog_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMSetErrorLog_get_ErrorLog(This,pVal)	\
    (This)->lpVtbl -> get_ErrorLog(This,pVal)

#define IAMSetErrorLog_put_ErrorLog(This,newVal)	\
    (This)->lpVtbl -> put_ErrorLog(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAMSetErrorLog_get_ErrorLog_Proxy( 
    IAMSetErrorLog * This,
    /* [retval][out] */ IAMErrorLog **pVal);


void __RPC_STUB IAMSetErrorLog_get_ErrorLog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAMSetErrorLog_put_ErrorLog_Proxy( 
    IAMSetErrorLog * This,
    /* [in] */ IAMErrorLog *newVal);


void __RPC_STUB IAMSetErrorLog_put_ErrorLog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMSetErrorLog_INTERFACE_DEFINED__ */


#ifndef __ISampleGrabberCB_INTERFACE_DEFINED__
#define __ISampleGrabberCB_INTERFACE_DEFINED__

/* interface ISampleGrabberCB */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_ISampleGrabberCB;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0579154A-2B53-4994-B0D0-E773148EFF85")
    ISampleGrabberCB : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SampleCB( 
            double SampleTime,
            IMediaSample *pSample) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BufferCB( 
            double SampleTime,
            BYTE *pBuffer,
            long BufferLen) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISampleGrabberCBVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISampleGrabberCB * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISampleGrabberCB * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISampleGrabberCB * This);
        
        HRESULT ( STDMETHODCALLTYPE *SampleCB )( 
            ISampleGrabberCB * This,
            double SampleTime,
            IMediaSample *pSample);
        
        HRESULT ( STDMETHODCALLTYPE *BufferCB )( 
            ISampleGrabberCB * This,
            double SampleTime,
            BYTE *pBuffer,
            long BufferLen);
        
        END_INTERFACE
    } ISampleGrabberCBVtbl;

    interface ISampleGrabberCB
    {
        CONST_VTBL struct ISampleGrabberCBVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISampleGrabberCB_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISampleGrabberCB_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISampleGrabberCB_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISampleGrabberCB_SampleCB(This,SampleTime,pSample)	\
    (This)->lpVtbl -> SampleCB(This,SampleTime,pSample)

#define ISampleGrabberCB_BufferCB(This,SampleTime,pBuffer,BufferLen)	\
    (This)->lpVtbl -> BufferCB(This,SampleTime,pBuffer,BufferLen)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISampleGrabberCB_SampleCB_Proxy( 
    ISampleGrabberCB * This,
    double SampleTime,
    IMediaSample *pSample);


void __RPC_STUB ISampleGrabberCB_SampleCB_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISampleGrabberCB_BufferCB_Proxy( 
    ISampleGrabberCB * This,
    double SampleTime,
    BYTE *pBuffer,
    long BufferLen);


void __RPC_STUB ISampleGrabberCB_BufferCB_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISampleGrabberCB_INTERFACE_DEFINED__ */


#ifndef __ISampleGrabber_INTERFACE_DEFINED__
#define __ISampleGrabber_INTERFACE_DEFINED__

/* interface ISampleGrabber */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_ISampleGrabber;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6B652FFF-11FE-4fce-92AD-0266B5D7C78F")
    ISampleGrabber : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetOneShot( 
            BOOL OneShot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMediaType( 
            const AM_MEDIA_TYPE *pType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConnectedMediaType( 
            AM_MEDIA_TYPE *pType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBufferSamples( 
            BOOL BufferThem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentBuffer( 
            /* [out][in] */ long *pBufferSize,
            /* [out] */ long *pBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentSample( 
            /* [retval][out] */ IMediaSample **ppSample) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCallback( 
            ISampleGrabberCB *pCallback,
            long WhichMethodToCallback) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISampleGrabberVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISampleGrabber * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISampleGrabber * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISampleGrabber * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetOneShot )( 
            ISampleGrabber * This,
            BOOL OneShot);
        
        HRESULT ( STDMETHODCALLTYPE *SetMediaType )( 
            ISampleGrabber * This,
            const AM_MEDIA_TYPE *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetConnectedMediaType )( 
            ISampleGrabber * This,
            AM_MEDIA_TYPE *pType);
        
        HRESULT ( STDMETHODCALLTYPE *SetBufferSamples )( 
            ISampleGrabber * This,
            BOOL BufferThem);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentBuffer )( 
            ISampleGrabber * This,
            /* [out][in] */ long *pBufferSize,
            /* [out] */ long *pBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentSample )( 
            ISampleGrabber * This,
            /* [retval][out] */ IMediaSample **ppSample);
        
        HRESULT ( STDMETHODCALLTYPE *SetCallback )( 
            ISampleGrabber * This,
            ISampleGrabberCB *pCallback,
            long WhichMethodToCallback);
        
        END_INTERFACE
    } ISampleGrabberVtbl;

    interface ISampleGrabber
    {
        CONST_VTBL struct ISampleGrabberVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISampleGrabber_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISampleGrabber_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISampleGrabber_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISampleGrabber_SetOneShot(This,OneShot)	\
    (This)->lpVtbl -> SetOneShot(This,OneShot)

#define ISampleGrabber_SetMediaType(This,pType)	\
    (This)->lpVtbl -> SetMediaType(This,pType)

#define ISampleGrabber_GetConnectedMediaType(This,pType)	\
    (This)->lpVtbl -> GetConnectedMediaType(This,pType)

#define ISampleGrabber_SetBufferSamples(This,BufferThem)	\
    (This)->lpVtbl -> SetBufferSamples(This,BufferThem)

#define ISampleGrabber_GetCurrentBuffer(This,pBufferSize,pBuffer)	\
    (This)->lpVtbl -> GetCurrentBuffer(This,pBufferSize,pBuffer)

#define ISampleGrabber_GetCurrentSample(This,ppSample)	\
    (This)->lpVtbl -> GetCurrentSample(This,ppSample)

#define ISampleGrabber_SetCallback(This,pCallback,WhichMethodToCallback)	\
    (This)->lpVtbl -> SetCallback(This,pCallback,WhichMethodToCallback)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISampleGrabber_SetOneShot_Proxy( 
    ISampleGrabber * This,
    BOOL OneShot);


void __RPC_STUB ISampleGrabber_SetOneShot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISampleGrabber_SetMediaType_Proxy( 
    ISampleGrabber * This,
    const AM_MEDIA_TYPE *pType);


void __RPC_STUB ISampleGrabber_SetMediaType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISampleGrabber_GetConnectedMediaType_Proxy( 
    ISampleGrabber * This,
    AM_MEDIA_TYPE *pType);


void __RPC_STUB ISampleGrabber_GetConnectedMediaType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISampleGrabber_SetBufferSamples_Proxy( 
    ISampleGrabber * This,
    BOOL BufferThem);


void __RPC_STUB ISampleGrabber_SetBufferSamples_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISampleGrabber_GetCurrentBuffer_Proxy( 
    ISampleGrabber * This,
    /* [out][in] */ long *pBufferSize,
    /* [out] */ long *pBuffer);


void __RPC_STUB ISampleGrabber_GetCurrentBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISampleGrabber_GetCurrentSample_Proxy( 
    ISampleGrabber * This,
    /* [retval][out] */ IMediaSample **ppSample);


void __RPC_STUB ISampleGrabber_GetCurrentSample_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISampleGrabber_SetCallback_Proxy( 
    ISampleGrabber * This,
    ISampleGrabberCB *pCallback,
    long WhichMethodToCallback);


void __RPC_STUB ISampleGrabber_SetCallback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISampleGrabber_INTERFACE_DEFINED__ */



#ifndef __DexterLib_LIBRARY_DEFINED__
#define __DexterLib_LIBRARY_DEFINED__

/* library DexterLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_DexterLib;

#ifndef __IResize_INTERFACE_DEFINED__
#define __IResize_INTERFACE_DEFINED__

/* interface IResize */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IResize;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4ada63a0-72d5-11d2-952a-0060081840bc")
    IResize : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE get_Size( 
            /* [out] */ int *piHeight,
            /* [out] */ int *piWidth,
            /* [out] */ long *pFlag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_InputSize( 
            /* [out] */ int *piHeight,
            /* [out] */ int *piWidth) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_Size( 
            /* [in] */ int Height,
            /* [in] */ int Width,
            /* [in] */ long Flag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_MediaType( 
            /* [out] */ AM_MEDIA_TYPE *pmt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_MediaType( 
            /* [in] */ const AM_MEDIA_TYPE *pmt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IResizeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IResize * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IResize * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IResize * This);
        
        HRESULT ( STDMETHODCALLTYPE *get_Size )( 
            IResize * This,
            /* [out] */ int *piHeight,
            /* [out] */ int *piWidth,
            /* [out] */ long *pFlag);
        
        HRESULT ( STDMETHODCALLTYPE *get_InputSize )( 
            IResize * This,
            /* [out] */ int *piHeight,
            /* [out] */ int *piWidth);
        
        HRESULT ( STDMETHODCALLTYPE *put_Size )( 
            IResize * This,
            /* [in] */ int Height,
            /* [in] */ int Width,
            /* [in] */ long Flag);
        
        HRESULT ( STDMETHODCALLTYPE *get_MediaType )( 
            IResize * This,
            /* [out] */ AM_MEDIA_TYPE *pmt);
        
        HRESULT ( STDMETHODCALLTYPE *put_MediaType )( 
            IResize * This,
            /* [in] */ const AM_MEDIA_TYPE *pmt);
        
        END_INTERFACE
    } IResizeVtbl;

    interface IResize
    {
        CONST_VTBL struct IResizeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IResize_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IResize_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IResize_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IResize_get_Size(This,piHeight,piWidth,pFlag)	\
    (This)->lpVtbl -> get_Size(This,piHeight,piWidth,pFlag)

#define IResize_get_InputSize(This,piHeight,piWidth)	\
    (This)->lpVtbl -> get_InputSize(This,piHeight,piWidth)

#define IResize_put_Size(This,Height,Width,Flag)	\
    (This)->lpVtbl -> put_Size(This,Height,Width,Flag)

#define IResize_get_MediaType(This,pmt)	\
    (This)->lpVtbl -> get_MediaType(This,pmt)

#define IResize_put_MediaType(This,pmt)	\
    (This)->lpVtbl -> put_MediaType(This,pmt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IResize_get_Size_Proxy( 
    IResize * This,
    /* [out] */ int *piHeight,
    /* [out] */ int *piWidth,
    /* [out] */ long *pFlag);


void __RPC_STUB IResize_get_Size_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IResize_get_InputSize_Proxy( 
    IResize * This,
    /* [out] */ int *piHeight,
    /* [out] */ int *piWidth);


void __RPC_STUB IResize_get_InputSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IResize_put_Size_Proxy( 
    IResize * This,
    /* [in] */ int Height,
    /* [in] */ int Width,
    /* [in] */ long Flag);


void __RPC_STUB IResize_put_Size_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IResize_get_MediaType_Proxy( 
    IResize * This,
    /* [out] */ AM_MEDIA_TYPE *pmt);


void __RPC_STUB IResize_get_MediaType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IResize_put_MediaType_Proxy( 
    IResize * This,
    /* [in] */ const AM_MEDIA_TYPE *pmt);


void __RPC_STUB IResize_put_MediaType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IResize_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_AMTimeline;

#ifdef __cplusplus

class DECLSPEC_UUID("78530B75-61F9-11D2-8CAD-00A024580902")
AMTimeline;
#endif

EXTERN_C const CLSID CLSID_AMTimelineObj;

#ifdef __cplusplus

class DECLSPEC_UUID("78530B78-61F9-11D2-8CAD-00A024580902")
AMTimelineObj;
#endif

EXTERN_C const CLSID CLSID_AMTimelineSrc;

#ifdef __cplusplus

class DECLSPEC_UUID("78530B7A-61F9-11D2-8CAD-00A024580902")
AMTimelineSrc;
#endif

EXTERN_C const CLSID CLSID_AMTimelineTrack;

#ifdef __cplusplus

class DECLSPEC_UUID("8F6C3C50-897B-11d2-8CFB-00A0C9441E20")
AMTimelineTrack;
#endif

EXTERN_C const CLSID CLSID_AMTimelineComp;

#ifdef __cplusplus

class DECLSPEC_UUID("74D2EC80-6233-11d2-8CAD-00A024580902")
AMTimelineComp;
#endif

EXTERN_C const CLSID CLSID_AMTimelineGroup;

#ifdef __cplusplus

class DECLSPEC_UUID("F6D371E1-B8A6-11d2-8023-00C0DF10D434")
AMTimelineGroup;
#endif

EXTERN_C const CLSID CLSID_AMTimelineTrans;

#ifdef __cplusplus

class DECLSPEC_UUID("74D2EC81-6233-11d2-8CAD-00A024580902")
AMTimelineTrans;
#endif

EXTERN_C const CLSID CLSID_AMTimelineEffect;

#ifdef __cplusplus

class DECLSPEC_UUID("74D2EC82-6233-11d2-8CAD-00A024580902")
AMTimelineEffect;
#endif

EXTERN_C const CLSID CLSID_RenderEngine;

#ifdef __cplusplus

class DECLSPEC_UUID("64D8A8E0-80A2-11d2-8CF3-00A0C9441E20")
RenderEngine;
#endif

EXTERN_C const CLSID CLSID_SmartRenderEngine;

#ifdef __cplusplus

class DECLSPEC_UUID("498B0949-BBE9-4072-98BE-6CCAEB79DC6F")
SmartRenderEngine;
#endif

EXTERN_C const CLSID CLSID_AudMixer;

#ifdef __cplusplus

class DECLSPEC_UUID("036A9790-C153-11d2-9EF7-006008039E37")
AudMixer;
#endif

EXTERN_C const CLSID CLSID_Xml2Dex;

#ifdef __cplusplus

class DECLSPEC_UUID("18C628EE-962A-11D2-8D08-00A0C9441E20")
Xml2Dex;
#endif

EXTERN_C const CLSID CLSID_MediaLocator;

#ifdef __cplusplus

class DECLSPEC_UUID("CC1101F2-79DC-11D2-8CE6-00A0C9441E20")
MediaLocator;
#endif

EXTERN_C const CLSID CLSID_PropertySetter;

#ifdef __cplusplus

class DECLSPEC_UUID("ADF95821-DED7-11d2-ACBE-0080C75E246E")
PropertySetter;
#endif

EXTERN_C const CLSID CLSID_MediaDet;

#ifdef __cplusplus

class DECLSPEC_UUID("65BD0711-24D2-4ff7-9324-ED2E5D3ABAFA")
MediaDet;
#endif

EXTERN_C const CLSID CLSID_SampleGrabber;

#ifdef __cplusplus

class DECLSPEC_UUID("C1F400A0-3F08-11d3-9F0B-006008039E37")
SampleGrabber;
#endif

EXTERN_C const CLSID CLSID_NullRenderer;

#ifdef __cplusplus

class DECLSPEC_UUID("C1F400A4-3F08-11d3-9F0B-006008039E37")
NullRenderer;
#endif

EXTERN_C const CLSID CLSID_DxtCompositor;

#ifdef __cplusplus

class DECLSPEC_UUID("BB44391D-6ABD-422f-9E2E-385C9DFF51FC")
DxtCompositor;
#endif

EXTERN_C const CLSID CLSID_DxtAlphaSetter;

#ifdef __cplusplus

class DECLSPEC_UUID("506D89AE-909A-44f7-9444-ABD575896E35")
DxtAlphaSetter;
#endif

EXTERN_C const CLSID CLSID_DxtJpeg;

#ifdef __cplusplus

class DECLSPEC_UUID("DE75D012-7A65-11D2-8CEA-00A0C9441E20")
DxtJpeg;
#endif

EXTERN_C const CLSID CLSID_ColorSource;

#ifdef __cplusplus

class DECLSPEC_UUID("0cfdd070-581a-11d2-9ee6-006008039e37")
ColorSource;
#endif

EXTERN_C const CLSID CLSID_DxtKey;

#ifdef __cplusplus

class DECLSPEC_UUID("C5B19592-145E-11d3-9F04-006008039E37")
DxtKey;
#endif
#endif /* __DexterLib_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_qedit_0484 */
/* [local] */ 


enum __MIDL___MIDL_itf_qedit_0484_0001
    {	E_NOTINTREE	= 0x80040400,
	E_RENDER_ENGINE_IS_BROKEN	= 0x80040401,
	E_MUST_INIT_RENDERER	= 0x80040402,
	E_NOTDETERMINED	= 0x80040403,
	E_NO_TIMELINE	= 0x80040404,
	S_WARN_OUTPUTRESET	= 40404
    } ;
#define DEX_IDS_BAD_SOURCE_NAME    1400
#define DEX_IDS_BAD_SOURCE_NAME2    1401
#define DEX_IDS_MISSING_SOURCE_NAME    1402
#define DEX_IDS_UNKNOWN_SOURCE    1403
#define DEX_IDS_INSTALL_PROBLEM    1404
#define DEX_IDS_NO_SOURCE_NAMES    1405
#define DEX_IDS_BAD_MEDIATYPE    1406
#define DEX_IDS_STREAM_NUMBER    1407
#define DEX_IDS_OUTOFMEMORY        1408
#define DEX_IDS_DIBSEQ_NOTALLSAME    1409
#define DEX_IDS_CLIPTOOSHORT        1410
#define DEX_IDS_INVALID_DXT        1411
#define DEX_IDS_INVALID_DEFAULT_DXT    1412
#define DEX_IDS_NO_3D        1413
#define DEX_IDS_BROKEN_DXT        1414
#define DEX_IDS_NO_SUCH_PROPERTY    1415
#define DEX_IDS_ILLEGAL_PROPERTY_VAL    1416
#define DEX_IDS_INVALID_XML        1417
#define DEX_IDS_CANT_FIND_FILTER    1418
#define DEX_IDS_DISK_WRITE_ERROR    1419
#define DEX_IDS_INVALID_AUDIO_FX    1420
#define DEX_IDS_CANT_FIND_COMPRESSOR 1421
#define DEX_IDS_TIMELINE_PARSE    1426
#define DEX_IDS_GRAPH_ERROR        1427
#define DEX_IDS_GRID_ERROR        1428
#define DEX_IDS_INTERFACE_ERROR    1429
EXTERN_GUID(CLSID_VideoEffects1Category, 0xcc7bfb42, 0xf175, 0x11d1, 0xa3, 0x92, 0x0, 0xe0, 0x29, 0x1f, 0x39, 0x59);
EXTERN_GUID(CLSID_VideoEffects2Category, 0xcc7bfb43, 0xf175, 0x11d1, 0xa3, 0x92, 0x0, 0xe0, 0x29, 0x1f, 0x39, 0x59);
EXTERN_GUID(CLSID_AudioEffects1Category, 0xcc7bfb44, 0xf175, 0x11d1, 0xa3, 0x92, 0x0, 0xe0, 0x29, 0x1f, 0x39, 0x59);
EXTERN_GUID(CLSID_AudioEffects2Category, 0xcc7bfb45, 0xf175, 0x11d1, 0xa3, 0x92, 0x0, 0xe0, 0x29, 0x1f, 0x39, 0x59);


extern RPC_IF_HANDLE __MIDL_itf_qedit_0484_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_qedit_0484_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DirectX\9c\Include\rmxfguid.h ===
/***************************************************************************
 *
 *  Copyright (C) 1998-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       rmxfguid.h
 *
 *  Content:    Defines GUIDs of D3DRM's templates.
 *
 ***************************************************************************/

#ifndef __RMXFGUID_H_
#define __RMXFGUID_H_

/* {2B957100-9E9A-11cf-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMInfo,
0x2b957100, 0x9e9a, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {3D82AB44-62DA-11cf-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMMesh,
0x3d82ab44, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {3D82AB5E-62DA-11cf-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMVector,
0x3d82ab5e, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {3D82AB5F-62DA-11cf-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMMeshFace,
0x3d82ab5f, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {3D82AB4D-62DA-11cf-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMMaterial,
0x3d82ab4d, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {35FF44E1-6C7C-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMaterialArray,
0x35ff44e1, 0x6c7c, 0x11cf, 0x8F, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {3D82AB46-62DA-11cf-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMFrame,
0x3d82ab46, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {F6F23F41-7686-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMFrameTransformMatrix,
0xf6f23f41, 0x7686, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {F6F23F42-7686-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMeshMaterialList,
0xf6f23f42, 0x7686, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {F6F23F40-7686-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMeshTextureCoords,
0xf6f23f40, 0x7686, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {F6F23F43-7686-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMeshNormals,
0xf6f23f43, 0x7686, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {F6F23F44-7686-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMCoords2d,
0xf6f23f44, 0x7686, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {F6F23F45-7686-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMatrix4x4,
0xf6f23f45, 0x7686, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {3D82AB4F-62DA-11cf-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMAnimation,
0x3d82ab4f, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {3D82AB50-62DA-11cf-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMAnimationSet,
0x3d82ab50, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {10DD46A8-775B-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMAnimationKey,
0x10dd46a8, 0x775b, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xA3);

/* {10DD46A9-775B-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMFloatKeys,
0x10dd46a9, 0x775b, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xA3);

/* {01411840-7786-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMaterialAmbientColor,
0x01411840, 0x7786, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xA3);

/* {01411841-7786-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMaterialDiffuseColor,
0x01411841, 0x7786, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xA3);

/* {01411842-7786-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMaterialSpecularColor,
0x01411842, 0x7786, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xA3);

/* {D3E16E80-7835-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMaterialEmissiveColor,
0xd3e16e80, 0x7835, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {01411843-7786-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMaterialPower,
0x01411843, 0x7786, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xA3);

/* {35FF44E0-6C7C-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMColorRGBA,
0x35ff44e0, 0x6c7c, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xA3);

/* {D3E16E81-7835-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMColorRGB,
0xd3e16e81, 0x7835, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {A42790E0-7810-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMGuid,
0xa42790e0, 0x7810, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {A42790E1-7810-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMTextureFilename,
0xa42790e1, 0x7810, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {A42790E2-7810-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMTextureReference,
0xa42790e2, 0x7810, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {1630B820-7842-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMIndexedColor,
0x1630b820, 0x7842, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {1630B821-7842-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMeshVertexColors,
0x1630b821, 0x7842, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {4885AE60-78E8-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMaterialWrap,
0x4885ae60, 0x78e8, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {537DA6A0-CA37-11d0-941C-0080C80CFA7B} */
DEFINE_GUID(TID_D3DRMBoolean,
0x537da6a0, 0xca37, 0x11d0, 0x94, 0x1c, 0x0, 0x80, 0xc8, 0xc, 0xfa, 0x7b);

/* {ED1EC5C0-C0A8-11d0-941C-0080C80CFA7B} */
DEFINE_GUID(TID_D3DRMMeshFaceWraps,
0xed1ec5c0, 0xc0a8, 0x11d0, 0x94, 0x1c, 0x0, 0x80, 0xc8, 0xc, 0xfa, 0x7b);

/* {4885AE63-78E8-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMBoolean2d,
0x4885ae63, 0x78e8, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {F406B180-7B3B-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMTimedFloatKeys,
0xf406b180, 0x7b3b, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {E2BF56C0-840F-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMAnimationOptions,
0xe2bf56c0, 0x840f, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {E2BF56C1-840F-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMFramePosition,
0xe2bf56c1, 0x840f, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {E2BF56C2-840F-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMFrameVelocity,
0xe2bf56c2, 0x840f, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {E2BF56C3-840F-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMFrameRotation,
0xe2bf56c3, 0x840f, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {3D82AB4A-62DA-11cf-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMLight,
0x3d82ab4a, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {3D82AB51-62DA-11cf-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMCamera,
0x3d82ab51, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {E5745280-B24F-11cf-9DD5-00AA00A71A2F} */
DEFINE_GUID(TID_D3DRMAppData,
0xe5745280, 0xb24f, 0x11cf, 0x9d, 0xd5, 0x0, 0xaa, 0x0, 0xa7, 0x1a, 0x2f);

/* {AED22740-B31F-11cf-9DD5-00AA00A71A2F} */
DEFINE_GUID(TID_D3DRMLightUmbra,
0xaed22740, 0xb31f, 0x11cf, 0x9d, 0xd5, 0x0, 0xaa, 0x0, 0xa7, 0x1a, 0x2f);

/* {AED22742-B31F-11cf-9DD5-00AA00A71A2F} */
DEFINE_GUID(TID_D3DRMLightRange,
0xaed22742, 0xb31f, 0x11cf, 0x9d, 0xd5, 0x0, 0xaa, 0x0, 0xa7, 0x1a, 0x2f);

/* {AED22741-B31F-11cf-9DD5-00AA00A71A2F} */
DEFINE_GUID(TID_D3DRMLightPenumbra,
0xaed22741, 0xb31f, 0x11cf, 0x9d, 0xd5, 0x0, 0xaa, 0x0, 0xa7, 0x1a, 0x2f);

/* {A8A98BA0-C5E5-11cf-B941-0080C80CFA7B} */
DEFINE_GUID(TID_D3DRMLightAttenuation,
0xa8a98ba0, 0xc5e5, 0x11cf, 0xb9, 0x41, 0x0, 0x80, 0xc8, 0xc, 0xfa, 0x7b);

/* {3A23EEA0-94B1-11d0-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMInlineData,
0x3a23eea0, 0x94b1, 0x11d0, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {3A23EEA1-94B1-11d0-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMUrl,
0x3a23eea1, 0x94b1, 0x11d0, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {8A63C360-997D-11d0-941C-0080C80CFA7B} */
DEFINE_GUID(TID_D3DRMProgressiveMesh,
0x8A63C360, 0x997D, 0x11d0, 0x94, 0x1C, 0x0, 0x80, 0xC8, 0x0C, 0xFA, 0x7B);

/* {98116AA0-BDBA-11d1-82C0-00A0C9697271} */
DEFINE_GUID(TID_D3DRMExternalVisual,
0x98116AA0, 0xBDBA, 0x11d1, 0x82, 0xC0, 0x00, 0xA0, 0xC9, 0x69, 0x72, 0x71);

/* {7F0F21E0-BFE1-11d1-82C0-00A0C9697271} */
DEFINE_GUID(TID_D3DRMStringProperty, 
0x7f0f21e0, 0xbfe1, 0x11d1, 0x82, 0xc0, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x71);

/* {7F0F21E1-BFE1-11d1-82C0-00A0C9697271} */
DEFINE_GUID(TID_D3DRMPropertyBag, 
0x7f0f21e1, 0xbfe1, 0x11d1, 0x82, 0xc0, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x71);

// {7F5D5EA0-D53A-11d1-82C0-00A0C9697271}
DEFINE_GUID(TID_D3DRMRightHanded, 
0x7f5d5ea0, 0xd53a, 0x11d1, 0x82, 0xc0, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x71);

#endif /* __RMXFGUID_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DirectX\9c\Include\qnetwork.h ===
//------------------------------------------------------------------------------
// File: qnetwork.h
//
// Desc: This header file machine-generated by mktyplib.exe.
//       Interface to type library: QuartzNetTypeLib
//
// Copyright (c) 1997-2001, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef _QuartzNetTypeLib_H_
#define _QuartzNetTypeLib_H_

DEFINE_GUID(LIBID_QuartzNetTypeLib,0x56A868B1L,0x0AD4,0x11CE,0xB0,0x3A,0x00,0x20,0xAF,0x0B,0xA7,0x70);
#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

DEFINE_GUID(IID_IAMNetShowConfig,0xFA2AA8F1L,0x8B62,0x11D0,0xA5,0x20,0x00,0x00,0x00,0x00,0x00,0x00);

/* Definition of interface: IAMNetShowConfig */
#undef INTERFACE
#define INTERFACE IAMNetShowConfig

DECLARE_INTERFACE_(IAMNetShowConfig, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IAMNetShowConfig methods */
    STDMETHOD(get_BufferingTime)(THIS_ double FAR* pBufferingTime) PURE;
    STDMETHOD(put_BufferingTime)(THIS_ double BufferingTime) PURE;
    STDMETHOD(get_UseFixedUDPPort)(THIS_ VARIANT_BOOL FAR* pUseFixedUDPPort) PURE;
    STDMETHOD(put_UseFixedUDPPort)(THIS_ VARIANT_BOOL UseFixedUDPPort) PURE;
    STDMETHOD(get_FixedUDPPort)(THIS_ long FAR* pFixedUDPPort) PURE;
    STDMETHOD(put_FixedUDPPort)(THIS_ long FixedUDPPort) PURE;
    STDMETHOD(get_UseHTTPProxy)(THIS_ VARIANT_BOOL FAR* pUseHTTPProxy) PURE;
    STDMETHOD(put_UseHTTPProxy)(THIS_ VARIANT_BOOL UseHTTPProxy) PURE;
    STDMETHOD(get_EnableAutoProxy)(THIS_ VARIANT_BOOL FAR* pEnableAutoProxy) PURE;
    STDMETHOD(put_EnableAutoProxy)(THIS_ VARIANT_BOOL EnableAutoProxy) PURE;
    STDMETHOD(get_HTTPProxyHost)(THIS_ BSTR FAR* pbstrHTTPProxyHost) PURE;
    STDMETHOD(put_HTTPProxyHost)(THIS_ BSTR bstrHTTPProxyHost) PURE;
    STDMETHOD(get_HTTPProxyPort)(THIS_ long FAR* pHTTPProxyPort) PURE;
    STDMETHOD(put_HTTPProxyPort)(THIS_ long HTTPProxyPort) PURE;
    STDMETHOD(get_EnableMulticast)(THIS_ VARIANT_BOOL FAR* pEnableMulticast) PURE;
    STDMETHOD(put_EnableMulticast)(THIS_ VARIANT_BOOL EnableMulticast) PURE;
    STDMETHOD(get_EnableUDP)(THIS_ VARIANT_BOOL FAR* pEnableUDP) PURE;
    STDMETHOD(put_EnableUDP)(THIS_ VARIANT_BOOL EnableUDP) PURE;
    STDMETHOD(get_EnableTCP)(THIS_ VARIANT_BOOL FAR* pEnableTCP) PURE;
    STDMETHOD(put_EnableTCP)(THIS_ VARIANT_BOOL EnableTCP) PURE;
    STDMETHOD(get_EnableHTTP)(THIS_ VARIANT_BOOL FAR* pEnableHTTP) PURE;
    STDMETHOD(put_EnableHTTP)(THIS_ VARIANT_BOOL EnableHTTP) PURE;
};

DEFINE_GUID(IID_IAMChannelInfo,0xFA2AA8F2L,0x8B62,0x11D0,0xA5,0x20,0x00,0x00,0x00,0x00,0x00,0x00);

/* Definition of interface: IAMChannelInfo */
#undef INTERFACE
#define INTERFACE IAMChannelInfo

DECLARE_INTERFACE_(IAMChannelInfo, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IAMChannelInfo methods */
    STDMETHOD(get_ChannelName)(THIS_ BSTR FAR* pbstrChannelName) PURE;
    STDMETHOD(get_ChannelDescription)(THIS_ BSTR FAR* pbstrChannelDescription) PURE;
    STDMETHOD(get_ChannelURL)(THIS_ BSTR FAR* pbstrChannelURL) PURE;
    STDMETHOD(get_ContactAddress)(THIS_ BSTR FAR* pbstrContactAddress) PURE;
    STDMETHOD(get_ContactPhone)(THIS_ BSTR FAR* pbstrContactPhone) PURE;
    STDMETHOD(get_ContactEmail)(THIS_ BSTR FAR* pbstrContactEmail) PURE;
};

DEFINE_GUID(IID_IAMNetworkStatus,0xFA2AA8F3L,0x8B62,0x11D0,0xA5,0x20,0x00,0x00,0x00,0x00,0x00,0x00);

/* Definition of interface: IAMNetworkStatus */
#undef INTERFACE
#define INTERFACE IAMNetworkStatus

DECLARE_INTERFACE_(IAMNetworkStatus, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IAMNetworkStatus methods */
    STDMETHOD(get_ReceivedPackets)(THIS_ long FAR* pReceivedPackets) PURE;
    STDMETHOD(get_RecoveredPackets)(THIS_ long FAR* pRecoveredPackets) PURE;
    STDMETHOD(get_LostPackets)(THIS_ long FAR* pLostPackets) PURE;
    STDMETHOD(get_ReceptionQuality)(THIS_ long FAR* pReceptionQuality) PURE;
    STDMETHOD(get_BufferingCount)(THIS_ long FAR* pBufferingCount) PURE;
    STDMETHOD(get_IsBroadcast)(THIS_ VARIANT_BOOL FAR* pIsBroadcast) PURE;
    STDMETHOD(get_BufferingProgress)(THIS_ long FAR* pBufferingProgress) PURE;
};

typedef enum {
    AM_EXSEEK_CANSEEK = 1,
    AM_EXSEEK_CANSCAN = 2,
    AM_EXSEEK_MARKERSEEK = 4,
    AM_EXSEEK_SCANWITHOUTCLOCK = 8,
    AM_EXSEEK_NOSTANDARDREPAINT = 16,
    AM_EXSEEK_BUFFERING = 32,
    AM_EXSEEK_SENDS_VIDEOFRAMEREADY = 64
} AMExtendedSeekingCapabilities;

DEFINE_GUID(IID_IAMExtendedSeeking,0xFA2AA8F9L,0x8B62,0x11D0,0xA5,0x20,0x00,0x00,0x00,0x00,0x00,0x00);

/* Definition of interface: IAMExtendedSeeking */
#undef INTERFACE
#define INTERFACE IAMExtendedSeeking

DECLARE_INTERFACE_(IAMExtendedSeeking, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IAMExtendedSeeking methods */
    STDMETHOD(get_ExSeekCapabilities)(THIS_ long FAR* pExCapabilities) PURE;
    STDMETHOD(get_MarkerCount)(THIS_ long FAR* pMarkerCount) PURE;
    STDMETHOD(get_CurrentMarker)(THIS_ long FAR* pCurrentMarker) PURE;
    STDMETHOD(GetMarkerTime)(THIS_ long MarkerNum, double FAR* pMarkerTime) PURE;
    STDMETHOD(GetMarkerName)(THIS_ long MarkerNum, BSTR FAR* pbstrMarkerName) PURE;
    STDMETHOD(put_PlaybackSpeed)(THIS_ double Speed) PURE;
    STDMETHOD(get_PlaybackSpeed)(THIS_ double FAR* pSpeed) PURE;
};

DEFINE_GUID(IID_IAMNetShowExProps,0xFA2AA8F5L,0x8B62,0x11D0,0xA5,0x20,0x00,0x00,0x00,0x00,0x00,0x00);

/* Definition of interface: IAMNetShowExProps */
#undef INTERFACE
#define INTERFACE IAMNetShowExProps

DECLARE_INTERFACE_(IAMNetShowExProps, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IAMNetShowExProps methods */
    STDMETHOD(get_SourceProtocol)(THIS_ long FAR* pSourceProtocol) PURE;
    STDMETHOD(get_Bandwidth)(THIS_ long FAR* pBandwidth) PURE;
    STDMETHOD(get_ErrorCorrection)(THIS_ BSTR FAR* pbstrErrorCorrection) PURE;
    STDMETHOD(get_CodecCount)(THIS_ long FAR* pCodecCount) PURE;
    STDMETHOD(GetCodecInstalled)(THIS_ long CodecNum, VARIANT_BOOL FAR* pCodecInstalled) PURE;
    STDMETHOD(GetCodecDescription)(THIS_ long CodecNum, BSTR FAR* pbstrCodecDescription) PURE;
    STDMETHOD(GetCodecURL)(THIS_ long CodecNum, BSTR FAR* pbstrCodecURL) PURE;
    STDMETHOD(get_CreationDate)(THIS_ DATE FAR* pCreationDate) PURE;
    STDMETHOD(get_SourceLink)(THIS_ BSTR FAR* pbstrSourceLink) PURE;
};

DEFINE_GUID(IID_IAMExtendedErrorInfo,0xFA2AA8F6L,0x8B62,0x11D0,0xA5,0x20,0x00,0x00,0x00,0x00,0x00,0x00);

/* Definition of interface: IAMExtendedErrorInfo */
#undef INTERFACE
#define INTERFACE IAMExtendedErrorInfo

DECLARE_INTERFACE_(IAMExtendedErrorInfo, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IAMExtendedErrorInfo methods */
    STDMETHOD(get_HasError)(THIS_ VARIANT_BOOL FAR* pHasError) PURE;
    STDMETHOD(get_ErrorDescription)(THIS_ BSTR FAR* pbstrErrorDescription) PURE;
    STDMETHOD(get_ErrorCode)(THIS_ long FAR* pErrorCode) PURE;
};

DEFINE_GUID(IID_IAMMediaContent,0xFA2AA8F4L,0x8B62,0x11D0,0xA5,0x20,0x00,0x00,0x00,0x00,0x00,0x00);

/* Definition of interface: IAMMediaContent */
#undef INTERFACE
#define INTERFACE IAMMediaContent

DECLARE_INTERFACE_(IAMMediaContent, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IAMMediaContent methods */
    STDMETHOD(get_AuthorName)(THIS_ BSTR FAR* pbstrAuthorName) PURE;
    STDMETHOD(get_Title)(THIS_ BSTR FAR* pbstrTitle) PURE;
    STDMETHOD(get_Rating)(THIS_ BSTR FAR* pbstrRating) PURE;
    STDMETHOD(get_Description)(THIS_ BSTR FAR* pbstrDescription) PURE;
    STDMETHOD(get_Copyright)(THIS_ BSTR FAR* pbstrCopyright) PURE;
    STDMETHOD(get_BaseURL)(THIS_ BSTR FAR* pbstrBaseURL) PURE;
    STDMETHOD(get_LogoURL)(THIS_ BSTR FAR* pbstrLogoURL) PURE;
    STDMETHOD(get_LogoIconURL)(THIS_ BSTR FAR* pbstrLogoURL) PURE;
    STDMETHOD(get_WatermarkURL)(THIS_ BSTR FAR* pbstrWatermarkURL) PURE;
    STDMETHOD(get_MoreInfoURL)(THIS_ BSTR FAR* pbstrMoreInfoURL) PURE;
    STDMETHOD(get_MoreInfoBannerImage)(THIS_ BSTR FAR* pbstrMoreInfoBannerImage) PURE;
    STDMETHOD(get_MoreInfoBannerURL)(THIS_ BSTR FAR* pbstrMoreInfoBannerURL) PURE;
    STDMETHOD(get_MoreInfoText)(THIS_ BSTR FAR* pbstrMoreInfoText) PURE;
};

DEFINE_GUID(IID_IAMMediaContent2,0xCE8F78C1L,0x74D9,0x11D2,0xB0,0x9D,0x00,0xA0,0xC9,0xA8,0x11,0x17);

/* Definition of interface: IAMMediaContent2 */
#undef INTERFACE
#define INTERFACE IAMMediaContent2

DECLARE_INTERFACE_(IAMMediaContent2, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IAMMediaContent2 methods */
    STDMETHOD(get_MediaParameter)(THIS_ long EntryNum, BSTR bstrName, BSTR FAR* pbstrValue) PURE;
    STDMETHOD(get_MediaParameterName)(THIS_ long EntryNum, long Index, BSTR FAR* pbstrName) PURE;
    STDMETHOD(get_PlaylistCount)(THIS_ long FAR* pNumberEntries) PURE;
};

DEFINE_GUID(IID_IAMNetShowPreroll,0xAAE7E4E2L,0x6388,0x11D1,0x8D,0x93,0x00,0x60,0x97,0xC9,0xA2,0xB2);

/* Definition of interface: IAMNetShowPreroll */
#undef INTERFACE
#define INTERFACE IAMNetShowPreroll

DECLARE_INTERFACE_(IAMNetShowPreroll, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IAMNetShowPreroll methods */
    STDMETHOD(put_Preroll)(THIS_ VARIANT_BOOL fPreroll) PURE;
    STDMETHOD(get_Preroll)(THIS_ VARIANT_BOOL FAR* pfPreroll) PURE;
};

DEFINE_GUID(IID_IDShowPlugin,0x4746B7C8L,0x700E,0x11D1,0xBE,0xCC,0x00,0xC0,0x4F,0xB6,0xE9,0x37);

/* Definition of interface: IDShowPlugin */
#undef INTERFACE
#define INTERFACE IDShowPlugin

DECLARE_INTERFACE_(IDShowPlugin, IUnknown)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;
#endif

    /* IDShowPlugin methods */
    STDMETHOD(get_URL)(THIS_ BSTR FAR* pURL) PURE;
    STDMETHOD(get_UserAgent)(THIS_ BSTR FAR* pUserAgent) PURE;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DirectX\9c\Include\rmxftmpl.h ===
/* D3DRM XFile templates in binary form */

#ifndef _RMXFTMPL_H_
#define _RMXFTMPL_H_

unsigned char D3DRM_XTEMPLATES[] = {
	0x78, 0x6f, 0x66, 0x20, 0x30, 0x33, 0x30, 0x32, 0x62, 
	0x69, 0x6e, 0x20, 0x30, 0x30, 0x36, 0x34, 0x1f, 0, 0x1, 
	0, 0x6, 0, 0, 0, 0x48, 0x65, 0x61, 0x64, 0x65, 
	0x72, 0xa, 0, 0x5, 0, 0x43, 0xab, 0x82, 0x3d, 0xda, 
	0x62, 0xcf, 0x11, 0xab, 0x39, 0, 0x20, 0xaf, 0x71, 0xe4, 
	0x33, 0x28, 0, 0x1, 0, 0x5, 0, 0, 0, 0x6d, 
	0x61, 0x6a, 0x6f, 0x72, 0x14, 0, 0x28, 0, 0x1, 0, 
	0x5, 0, 0, 0, 0x6d, 0x69, 0x6e, 0x6f, 0x72, 0x14, 
	0, 0x29, 0, 0x1, 0, 0x5, 0, 0, 0, 0x66, 
	0x6c, 0x61, 0x67, 0x73, 0x14, 0, 0xb, 0, 0x1f, 0, 
	0x1, 0, 0x6, 0, 0, 0, 0x56, 0x65, 0x63, 0x74, 
	0x6f, 0x72, 0xa, 0, 0x5, 0, 0x5e, 0xab, 0x82, 0x3d, 
	0xda, 0x62, 0xcf, 0x11, 0xab, 0x39, 0, 0x20, 0xaf, 0x71, 
	0xe4, 0x33, 0x2a, 0, 0x1, 0, 0x1, 0, 0, 0, 
	0x78, 0x14, 0, 0x2a, 0, 0x1, 0, 0x1, 0, 0, 
	0, 0x79, 0x14, 0, 0x2a, 0, 0x1, 0, 0x1, 0, 
	0, 0, 0x7a, 0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 
	0, 0x8, 0, 0, 0, 0x43, 0x6f, 0x6f, 0x72, 0x64, 
	0x73, 0x32, 0x64, 0xa, 0, 0x5, 0, 0x44, 0x3f, 0xf2, 
	0xf6, 0x86, 0x76, 0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 0x33, 
	0x35, 0x94, 0xa3, 0x2a, 0, 0x1, 0, 0x1, 0, 0, 
	0, 0x75, 0x14, 0, 0x2a, 0, 0x1, 0, 0x1, 0, 
	0, 0, 0x76, 0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 
	0, 0x9, 0, 0, 0, 0x4d, 0x61, 0x74, 0x72, 0x69, 
	0x78, 0x34, 0x78, 0x34, 0xa, 0, 0x5, 0, 0x45, 0x3f, 
	0xf2, 0xf6, 0x86, 0x76, 0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 
	0x33, 0x35, 0x94, 0xa3, 0x34, 0, 0x2a, 0, 0x1, 0, 
	0x6, 0, 0, 0, 0x6d, 0x61, 0x74, 0x72, 0x69, 0x78, 
	0xe, 0, 0x3, 0, 0x10, 0, 0, 0, 0xf, 0, 
	0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 0, 0x9, 0, 
	0, 0, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x52, 0x47, 0x42, 
	0x41, 0xa, 0, 0x5, 0, 0xe0, 0x44, 0xff, 0x35, 0x7c, 
	0x6c, 0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 0x33, 0x35, 0x94, 
	0xa3, 0x2a, 0, 0x1, 0, 0x3, 0, 0, 0, 0x72, 
	0x65, 0x64, 0x14, 0, 0x2a, 0, 0x1, 0, 0x5, 0, 
	0, 0, 0x67, 0x72, 0x65, 0x65, 0x6e, 0x14, 0, 0x2a, 
	0, 0x1, 0, 0x4, 0, 0, 0, 0x62, 0x6c, 0x75, 
	0x65, 0x14, 0, 0x2a, 0, 0x1, 0, 0x5, 0, 0, 
	0, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x14, 0, 0xb, 0, 
	0x1f, 0, 0x1, 0, 0x8, 0, 0, 0, 0x43, 0x6f, 
	0x6c, 0x6f, 0x72, 0x52, 0x47, 0x42, 0xa, 0, 0x5, 0, 
	0x81, 0x6e, 0xe1, 0xd3, 0x35, 0x78, 0xcf, 0x11, 0x8f, 0x52, 
	0, 0x40, 0x33, 0x35, 0x94, 0xa3, 0x2a, 0, 0x1, 0, 
	0x3, 0, 0, 0, 0x72, 0x65, 0x64, 0x14, 0, 0x2a, 
	0, 0x1, 0, 0x5, 0, 0, 0, 0x67, 0x72, 0x65, 
	0x65, 0x6e, 0x14, 0, 0x2a, 0, 0x1, 0, 0x4, 0, 
	0, 0, 0x62, 0x6c, 0x75, 0x65, 0x14, 0, 0xb, 0, 
	0x1f, 0, 0x1, 0, 0xc, 0, 0, 0, 0x49, 0x6e, 
	0x64, 0x65, 0x78, 0x65, 0x64, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 
	0xa, 0, 0x5, 0, 0x20, 0xb8, 0x30, 0x16, 0x42, 0x78, 
	0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 0x33, 0x35, 0x94, 0xa3, 
	0x29, 0, 0x1, 0, 0x5, 0, 0, 0, 0x69, 0x6e, 
	0x64, 0x65, 0x78, 0x14, 0, 0x1, 0, 0x9, 0, 0, 
	0, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x52, 0x47, 0x42, 0x41, 
	0x1, 0, 0xa, 0, 0, 0, 0x69, 0x6e, 0x64, 0x65, 
	0x78, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x14, 0, 0xb, 0, 
	0x1f, 0, 0x1, 0, 0x7, 0, 0, 0, 0x42, 0x6f, 
	0x6f, 0x6c, 0x65, 0x61, 0x6e, 0xa, 0, 0x5, 0, 0xa0, 
	0xa6, 0x7d, 0x53, 0x37, 0xca, 0xd0, 0x11, 0x94, 0x1c, 0, 
	0x80, 0xc8, 0xc, 0xfa, 0x7b, 0x29, 0, 0x1, 0, 0x9, 
	0, 0, 0, 0x74, 0x72, 0x75, 0x65, 0x66, 0x61, 0x6c, 
	0x73, 0x65, 0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 0, 
	0x9, 0, 0, 0, 0x42, 0x6f, 0x6f, 0x6c, 0x65, 0x61, 
	0x6e, 0x32, 0x64, 0xa, 0, 0x5, 0, 0x63, 0xae, 0x85, 
	0x48, 0xe8, 0x78, 0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 0x33, 
	0x35, 0x94, 0xa3, 0x1, 0, 0x7, 0, 0, 0, 0x42, 
	0x6f, 0x6f, 0x6c, 0x65, 0x61, 0x6e, 0x1, 0, 0x1, 0, 
	0, 0, 0x75, 0x14, 0, 0x1, 0, 0x7, 0, 0, 
	0, 0x42, 0x6f, 0x6f, 0x6c, 0x65, 0x61, 0x6e, 0x1, 0, 
	0x1, 0, 0, 0, 0x76, 0x14, 0, 0xb, 0, 0x1f, 
	0, 0x1, 0, 0xc, 0, 0, 0, 0x4d, 0x61, 0x74, 
	0x65, 0x72, 0x69, 0x61, 0x6c, 0x57, 0x72, 0x61, 0x70, 0xa, 
	0, 0x5, 0, 0x60, 0xae, 0x85, 0x48, 0xe8, 0x78, 0xcf, 
	0x11, 0x8f, 0x52, 0, 0x40, 0x33, 0x35, 0x94, 0xa3, 0x1, 
	0, 0x7, 0, 0, 0, 0x42, 0x6f, 0x6f, 0x6c, 0x65, 
	0x61, 0x6e, 0x1, 0, 0x1, 0, 0, 0, 0x75, 0x14, 
	0, 0x1, 0, 0x7, 0, 0, 0, 0x42, 0x6f, 0x6f, 
	0x6c, 0x65, 0x61, 0x6e, 0x1, 0, 0x1, 0, 0, 0, 
	0x76, 0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 0, 0xf, 
	0, 0, 0, 0x54, 0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 
	0x46, 0x69, 0x6c, 0x65, 0x6e, 0x61, 0x6d, 0x65, 0xa, 0, 
	0x5, 0, 0xe1, 0x90, 0x27, 0xa4, 0x10, 0x78, 0xcf, 0x11, 
	0x8f, 0x52, 0, 0x40, 0x33, 0x35, 0x94, 0xa3, 0x31, 0, 
	0x1, 0, 0x8, 0, 0, 0, 0x66, 0x69, 0x6c, 0x65, 
	0x6e, 0x61, 0x6d, 0x65, 0x14, 0, 0xb, 0, 0x1f, 0, 
	0x1, 0, 0x8, 0, 0, 0, 0x4d, 0x61, 0x74, 0x65, 
	0x72, 0x69, 0x61, 0x6c, 0xa, 0, 0x5, 0, 0x4d, 0xab, 
	0x82, 0x3d, 0xda, 0x62, 0xcf, 0x11, 0xab, 0x39, 0, 0x20, 
	0xaf, 0x71, 0xe4, 0x33, 0x1, 0, 0x9, 0, 0, 0, 
	0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x52, 0x47, 0x42, 0x41, 0x1, 
	0, 0x9, 0, 0, 0, 0x66, 0x61, 0x63, 0x65, 0x43, 
	0x6f, 0x6c, 0x6f, 0x72, 0x14, 0, 0x2a, 0, 0x1, 0, 
	0x5, 0, 0, 0, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x14, 
	0, 0x1, 0, 0x8, 0, 0, 0, 0x43, 0x6f, 0x6c, 
	0x6f, 0x72, 0x52, 0x47, 0x42, 0x1, 0, 0xd, 0, 0, 
	0, 0x73, 0x70, 0x65, 0x63, 0x75, 0x6c, 0x61, 0x72, 0x43, 
	0x6f, 0x6c, 0x6f, 0x72, 0x14, 0, 0x1, 0, 0x8, 0, 
	0, 0, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x52, 0x47, 0x42, 
	0x1, 0, 0xd, 0, 0, 0, 0x65, 0x6d, 0x69, 0x73, 
	0x73, 0x69, 0x76, 0x65, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x14, 
	0, 0xe, 0, 0x12, 0, 0x12, 0, 0x12, 0, 0xf, 
	0, 0xb, 0, 0x1f, 0, 0x1, 0, 0x8, 0, 0, 
	0, 0x4d, 0x65, 0x73, 0x68, 0x46, 0x61, 0x63, 0x65, 0xa, 
	0, 0x5, 0, 0x5f, 0xab, 0x82, 0x3d, 0xda, 0x62, 0xcf, 
	0x11, 0xab, 0x39, 0, 0x20, 0xaf, 0x71, 0xe4, 0x33, 0x29, 
	0, 0x1, 0, 0x12, 0, 0, 0, 0x6e, 0x46, 0x61, 
	0x63, 0x65, 0x56, 0x65, 0x72, 0x74, 0x65, 0x78, 0x49, 0x6e, 
	0x64, 0x69, 0x63, 0x65, 0x73, 0x14, 0, 0x34, 0, 0x29, 
	0, 0x1, 0, 0x11, 0, 0, 0, 0x66, 0x61, 0x63, 
	0x65, 0x56, 0x65, 0x72, 0x74, 0x65, 0x78, 0x49, 0x6e, 0x64, 
	0x69, 0x63, 0x65, 0x73, 0xe, 0, 0x1, 0, 0x12, 0, 
	0, 0, 0x6e, 0x46, 0x61, 0x63, 0x65, 0x56, 0x65, 0x72, 
	0x74, 0x65, 0x78, 0x49, 0x6e, 0x64, 0x69, 0x63, 0x65, 0x73, 
	0xf, 0, 0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 0, 
	0xd, 0, 0, 0, 0x4d, 0x65, 0x73, 0x68, 0x46, 0x61, 
	0x63, 0x65, 0x57, 0x72, 0x61, 0x70, 0x73, 0xa, 0, 0x5, 
	0, 0xc0, 0xc5, 0x1e, 0xed, 0xa8, 0xc0, 0xd0, 0x11, 0x94, 
	0x1c, 0, 0x80, 0xc8, 0xc, 0xfa, 0x7b, 0x29, 0, 0x1, 
	0, 0xf, 0, 0, 0, 0x6e, 0x46, 0x61, 0x63, 0x65, 
	0x57, 0x72, 0x61, 0x70, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73, 
	0x14, 0, 0x34, 0, 0x1, 0, 0x9, 0, 0, 0, 
	0x42, 0x6f, 0x6f, 0x6c, 0x65, 0x61, 0x6e, 0x32, 0x64, 0x1, 
	0, 0xe, 0, 0, 0, 0x66, 0x61, 0x63, 0x65, 0x57, 
	0x72, 0x61, 0x70, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73, 0xe, 
	0, 0x1, 0, 0xf, 0, 0, 0, 0x6e, 0x46, 0x61, 
	0x63, 0x65, 0x57, 0x72, 0x61, 0x70, 0x56, 0x61, 0x6c, 0x75, 
	0x65, 0x73, 0xf, 0, 0x14, 0, 0xb, 0, 0x1f, 0, 
	0x1, 0, 0x11, 0, 0, 0, 0x4d, 0x65, 0x73, 0x68, 
	0x54, 0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 0x43, 0x6f, 0x6f, 
	0x72, 0x64, 0x73, 0xa, 0, 0x5, 0, 0x40, 0x3f, 0xf2, 
	0xf6, 0x86, 0x76, 0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 0x33, 
	0x35, 0x94, 0xa3, 0x29, 0, 0x1, 0, 0xe, 0, 0, 
	0, 0x6e, 0x54, 0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 0x43, 
	0x6f, 0x6f, 0x72, 0x64, 0x73, 0x14, 0, 0x34, 0, 0x1, 
	0, 0x8, 0, 0, 0, 0x43, 0x6f, 0x6f, 0x72, 0x64, 
	0x73, 0x32, 0x64, 0x1, 0, 0xd, 0, 0, 0, 0x74, 
	0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 0x43, 0x6f, 0x6f, 0x72, 
	0x64, 0x73, 0xe, 0, 0x1, 0, 0xe, 0, 0, 0, 
	0x6e, 0x54, 0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 0x43, 0x6f, 
	0x6f, 0x72, 0x64, 0x73, 0xf, 0, 0x14, 0, 0xb, 0, 
	0x1f, 0, 0x1, 0, 0x10, 0, 0, 0, 0x4d, 0x65, 
	0x73, 0x68, 0x4d, 0x61, 0x74, 0x65, 0x72, 0x69, 0x61, 0x6c, 
	0x4c, 0x69, 0x73, 0x74, 0xa, 0, 0x5, 0, 0x42, 0x3f, 
	0xf2, 0xf6, 0x86, 0x76, 0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 
	0x33, 0x35, 0x94, 0xa3, 0x29, 0, 0x1, 0, 0xa, 0, 
	0, 0, 0x6e, 0x4d, 0x61, 0x74, 0x65, 0x72, 0x69, 0x61, 
	0x6c, 0x73, 0x14, 0, 0x29, 0, 0x1, 0, 0xc, 0, 
	0, 0, 0x6e, 0x46, 0x61, 0x63, 0x65, 0x49, 0x6e, 0x64, 
	0x65, 0x78, 0x65, 0x73, 0x14, 0, 0x34, 0, 0x29, 0, 
	0x1, 0, 0xb, 0, 0, 0, 0x66, 0x61, 0x63, 0x65, 
	0x49, 0x6e, 0x64, 0x65, 0x78, 0x65, 0x73, 0xe, 0, 0x1, 
	0, 0xc, 0, 0, 0, 0x6e, 0x46, 0x61, 0x63, 0x65, 
	0x49, 0x6e, 0x64, 0x65, 0x78, 0x65, 0x73, 0xf, 0, 0x14, 
	0, 0xe, 0, 0x1, 0, 0x8, 0, 0, 0, 0x4d, 
	0x61, 0x74, 0x65, 0x72, 0x69, 0x61, 0x6c, 0xf, 0, 0xb, 
	0, 0x1f, 0, 0x1, 0, 0xb, 0, 0, 0, 0x4d, 
	0x65, 0x73, 0x68, 0x4e, 0x6f, 0x72, 0x6d, 0x61, 0x6c, 0x73, 
	0xa, 0, 0x5, 0, 0x43, 0x3f, 0xf2, 0xf6, 0x86, 0x76, 
	0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 0x33, 0x35, 0x94, 0xa3, 
	0x29, 0, 0x1, 0, 0x8, 0, 0, 0, 0x6e, 0x4e, 
	0x6f, 0x72, 0x6d, 0x61, 0x6c, 0x73, 0x14, 0, 0x34, 0, 
	0x1, 0, 0x6, 0, 0, 0, 0x56, 0x65, 0x63, 0x74, 
	0x6f, 0x72, 0x1, 0, 0x7, 0, 0, 0, 0x6e, 0x6f, 
	0x72, 0x6d, 0x61, 0x6c, 0x73, 0xe, 0, 0x1, 0, 0x8, 
	0, 0, 0, 0x6e, 0x4e, 0x6f, 0x72, 0x6d, 0x61, 0x6c, 
	0x73, 0xf, 0, 0x14, 0, 0x29, 0, 0x1, 0, 0xc, 
	0, 0, 0, 0x6e, 0x46, 0x61, 0x63, 0x65, 0x4e, 0x6f, 
	0x72, 0x6d, 0x61, 0x6c, 0x73, 0x14, 0, 0x34, 0, 0x1, 
	0, 0x8, 0, 0, 0, 0x4d, 0x65, 0x73, 0x68, 0x46, 
	0x61, 0x63, 0x65, 0x1, 0, 0xb, 0, 0, 0, 0x66, 
	0x61, 0x63, 0x65, 0x4e, 0x6f, 0x72, 0x6d, 0x61, 0x6c, 0x73, 
	0xe, 0, 0x1, 0, 0xc, 0, 0, 0, 0x6e, 0x46, 
	0x61, 0x63, 0x65, 0x4e, 0x6f, 0x72, 0x6d, 0x61, 0x6c, 0x73, 
	0xf, 0, 0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 0, 
	0x10, 0, 0, 0, 0x4d, 0x65, 0x73, 0x68, 0x56, 0x65, 
	0x72, 0x74, 0x65, 0x78, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x73, 
	0xa, 0, 0x5, 0, 0x21, 0xb8, 0x30, 0x16, 0x42, 0x78, 
	0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 0x33, 0x35, 0x94, 0xa3, 
	0x29, 0, 0x1, 0, 0xd, 0, 0, 0, 0x6e, 0x56, 
	0x65, 0x72, 0x74, 0x65, 0x78, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 
	0x73, 0x14, 0, 0x34, 0, 0x1, 0, 0xc, 0, 0, 
	0, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x65, 0x64, 0x43, 0x6f, 
	0x6c, 0x6f, 0x72, 0x1, 0, 0xc, 0, 0, 0, 0x76, 
	0x65, 0x72, 0x74, 0x65, 0x78, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 
	0x73, 0xe, 0, 0x1, 0, 0xd, 0, 0, 0, 0x6e, 
	0x56, 0x65, 0x72, 0x74, 0x65, 0x78, 0x43, 0x6f, 0x6c, 0x6f, 
	0x72, 0x73, 0xf, 0, 0x14, 0, 0xb, 0, 0x1f, 0, 
	0x1, 0, 0x4, 0, 0, 0, 0x4d, 0x65, 0x73, 0x68, 
	0xa, 0, 0x5, 0, 0x44, 0xab, 0x82, 0x3d, 0xda, 0x62, 
	0xcf, 0x11, 0xab, 0x39, 0, 0x20, 0xaf, 0x71, 0xe4, 0x33, 
	0x29, 0, 0x1, 0, 0x9, 0, 0, 0, 0x6e, 0x56, 
	0x65, 0x72, 0x74, 0x69, 0x63, 0x65, 0x73, 0x14, 0, 0x34, 
	0, 0x1, 0, 0x6, 0, 0, 0, 0x56, 0x65, 0x63, 
	0x74, 0x6f, 0x72, 0x1, 0, 0x8, 0, 0, 0, 0x76, 
	0x65, 0x72, 0x74, 0x69, 0x63, 0x65, 0x73, 0xe, 0, 0x1, 
	0, 0x9, 0, 0, 0, 0x6e, 0x56, 0x65, 0x72, 0x74, 
	0x69, 0x63, 0x65, 0x73, 0xf, 0, 0x14, 0, 0x29, 0, 
	0x1, 0, 0x6, 0, 0, 0, 0x6e, 0x46, 0x61, 0x63, 
	0x65, 0x73, 0x14, 0, 0x34, 0, 0x1, 0, 0x8, 0, 
	0, 0, 0x4d, 0x65, 0x73, 0x68, 0x46, 0x61, 0x63, 0x65, 
	0x1, 0, 0x5, 0, 0, 0, 0x66, 0x61, 0x63, 0x65, 
	0x73, 0xe, 0, 0x1, 0, 0x6, 0, 0, 0, 0x6e, 
	0x46, 0x61, 0x63, 0x65, 0x73, 0xf, 0, 0x14, 0, 0xe, 
	0, 0x12, 0, 0x12, 0, 0x12, 0, 0xf, 0, 0xb, 
	0, 0x1f, 0, 0x1, 0, 0x14, 0, 0, 0, 0x46, 
	0x72, 0x61, 0x6d, 0x65, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 
	0x6f, 0x72, 0x6d, 0x4d, 0x61, 0x74, 0x72, 0x69, 0x78, 0xa, 
	0, 0x5, 0, 0x41, 0x3f, 0xf2, 0xf6, 0x86, 0x76, 0xcf, 
	0x11, 0x8f, 0x52, 0, 0x40, 0x33, 0x35, 0x94, 0xa3, 0x1, 
	0, 0x9, 0, 0, 0, 0x4d, 0x61, 0x74, 0x72, 0x69, 
	0x78, 0x34, 0x78, 0x34, 0x1, 0, 0xb, 0, 0, 0, 
	0x66, 0x72, 0x61, 0x6d, 0x65, 0x4d, 0x61, 0x74, 0x72, 0x69, 
	0x78, 0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 0, 0x5, 
	0, 0, 0, 0x46, 0x72, 0x61, 0x6d, 0x65, 0xa, 0, 
	0x5, 0, 0x46, 0xab, 0x82, 0x3d, 0xda, 0x62, 0xcf, 0x11, 
	0xab, 0x39, 0, 0x20, 0xaf, 0x71, 0xe4, 0x33, 0xe, 0, 
	0x12, 0, 0x12, 0, 0x12, 0, 0xf, 0, 0xb, 0, 
	0x1f, 0, 0x1, 0, 0x9, 0, 0, 0, 0x46, 0x6c, 
	0x6f, 0x61, 0x74, 0x4b, 0x65, 0x79, 0x73, 0xa, 0, 0x5, 
	0, 0xa9, 0x46, 0xdd, 0x10, 0x5b, 0x77, 0xcf, 0x11, 0x8f, 
	0x52, 0, 0x40, 0x33, 0x35, 0x94, 0xa3, 0x29, 0, 0x1, 
	0, 0x7, 0, 0, 0, 0x6e, 0x56, 0x61, 0x6c, 0x75, 
	0x65, 0x73, 0x14, 0, 0x34, 0, 0x2a, 0, 0x1, 0, 
	0x6, 0, 0, 0, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73, 
	0xe, 0, 0x1, 0, 0x7, 0, 0, 0, 0x6e, 0x56, 
	0x61, 0x6c, 0x75, 0x65, 0x73, 0xf, 0, 0x14, 0, 0xb, 
	0, 0x1f, 0, 0x1, 0, 0xe, 0, 0, 0, 0x54, 
	0x69, 0x6d, 0x65, 0x64, 0x46, 0x6c, 0x6f, 0x61, 0x74, 0x4b, 
	0x65, 0x79, 0x73, 0xa, 0, 0x5, 0, 0x80, 0xb1, 0x6, 
	0xf4, 0x3b, 0x7b, 0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 0x33, 
	0x35, 0x94, 0xa3, 0x29, 0, 0x1, 0, 0x4, 0, 0, 
	0, 0x74, 0x69, 0x6d, 0x65, 0x14, 0, 0x1, 0, 0x9, 
	0, 0, 0, 0x46, 0x6c, 0x6f, 0x61, 0x74, 0x4b, 0x65, 
	0x79, 0x73, 0x1, 0, 0x6, 0, 0, 0, 0x74, 0x66, 
	0x6b, 0x65, 0x79, 0x73, 0x14, 0, 0xb, 0, 0x1f, 0, 
	0x1, 0, 0xc, 0, 0, 0, 0x41, 0x6e, 0x69, 0x6d, 
	0x61, 0x74, 0x69, 0x6f, 0x6e, 0x4b, 0x65, 0x79, 0xa, 0, 
	0x5, 0, 0xa8, 0x46, 0xdd, 0x10, 0x5b, 0x77, 0xcf, 0x11, 
	0x8f, 0x52, 0, 0x40, 0x33, 0x35, 0x94, 0xa3, 0x29, 0, 
	0x1, 0, 0x7, 0, 0, 0, 0x6b, 0x65, 0x79, 0x54, 
	0x79, 0x70, 0x65, 0x14, 0, 0x29, 0, 0x1, 0, 0x5, 
	0, 0, 0, 0x6e, 0x4b, 0x65, 0x79, 0x73, 0x14, 0, 
	0x34, 0, 0x1, 0, 0xe, 0, 0, 0, 0x54, 0x69, 
	0x6d, 0x65, 0x64, 0x46, 0x6c, 0x6f, 0x61, 0x74, 0x4b, 0x65, 
	0x79, 0x73, 0x1, 0, 0x4, 0, 0, 0, 0x6b, 0x65, 
	0x79, 0x73, 0xe, 0, 0x1, 0, 0x5, 0, 0, 0, 
	0x6e, 0x4b, 0x65, 0x79, 0x73, 0xf, 0, 0x14, 0, 0xb, 
	0, 0x1f, 0, 0x1, 0, 0x10, 0, 0, 0, 0x41, 
	0x6e, 0x69, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x4f, 0x70, 
	0x74, 0x69, 0x6f, 0x6e, 0x73, 0xa, 0, 0x5, 0, 0xc0, 
	0x56, 0xbf, 0xe2, 0xf, 0x84, 0xcf, 0x11, 0x8f, 0x52, 0, 
	0x40, 0x33, 0x35, 0x94, 0xa3, 0x29, 0, 0x1, 0, 0xa, 
	0, 0, 0, 0x6f, 0x70, 0x65, 0x6e, 0x63, 0x6c, 0x6f, 
	0x73, 0x65, 0x64, 0x14, 0, 0x29, 0, 0x1, 0, 0xf, 
	0, 0, 0, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 
	0x6e, 0x71, 0x75, 0x61, 0x6c, 0x69, 0x74, 0x79, 0x14, 0, 
	0xb, 0, 0x1f, 0, 0x1, 0, 0x9, 0, 0, 0, 
	0x41, 0x6e, 0x69, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0xa, 
	0, 0x5, 0, 0x4f, 0xab, 0x82, 0x3d, 0xda, 0x62, 0xcf, 
	0x11, 0xab, 0x39, 0, 0x20, 0xaf, 0x71, 0xe4, 0x33, 0xe, 
	0, 0x12, 0, 0x12, 0, 0x12, 0, 0xf, 0, 0xb, 
	0, 0x1f, 0, 0x1, 0, 0xc, 0, 0, 0, 0x41, 
	0x6e, 0x69, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x65, 
	0x74, 0xa, 0, 0x5, 0, 0x50, 0xab, 0x82, 0x3d, 0xda, 
	0x62, 0xcf, 0x11, 0xab, 0x39, 0, 0x20, 0xaf, 0x71, 0xe4, 
	0x33, 0xe, 0, 0x1, 0, 0x9, 0, 0, 0, 0x41, 
	0x6e, 0x69, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0xf, 0, 
	0xb, 0, 0x1f, 0, 0x1, 0, 0xa, 0, 0, 0, 
	0x49, 0x6e, 0x6c, 0x69, 0x6e, 0x65, 0x44, 0x61, 0x74, 0x61, 
	0xa, 0, 0x5, 0, 0xa0, 0xee, 0x23, 0x3a, 0xb1, 0x94, 
	0xd0, 0x11, 0xab, 0x39, 0, 0x20, 0xaf, 0x71, 0xe4, 0x33, 
	0xe, 0, 0x1, 0, 0x6, 0, 0, 0, 0x42, 0x49, 
	0x4e, 0x41, 0x52, 0x59, 0xf, 0, 0xb, 0, 0x1f, 0, 
	0x1, 0, 0x3, 0, 0, 0, 0x55, 0x72, 0x6c, 0xa, 
	0, 0x5, 0, 0xa1, 0xee, 0x23, 0x3a, 0xb1, 0x94, 0xd0, 
	0x11, 0xab, 0x39, 0, 0x20, 0xaf, 0x71, 0xe4, 0x33, 0x29, 
	0, 0x1, 0, 0x5, 0, 0, 0, 0x6e, 0x55, 0x72, 
	0x6c, 0x73, 0x14, 0, 0x34, 0, 0x31, 0, 0x1, 0, 
	0x4, 0, 0, 0, 0x75, 0x72, 0x6c, 0x73, 0xe, 0, 
	0x1, 0, 0x5, 0, 0, 0, 0x6e, 0x55, 0x72, 0x6c, 
	0x73, 0xf, 0, 0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 
	0, 0xf, 0, 0, 0, 0x50, 0x72, 0x6f, 0x67, 0x72, 
	0x65, 0x73, 0x73, 0x69, 0x76, 0x65, 0x4d, 0x65, 0x73, 0x68, 
	0xa, 0, 0x5, 0, 0x60, 0xc3, 0x63, 0x8a, 0x7d, 0x99, 
	0xd0, 0x11, 0x94, 0x1c, 0, 0x80, 0xc8, 0xc, 0xfa, 0x7b, 
	0xe, 0, 0x1, 0, 0x3, 0, 0, 0, 0x55, 0x72, 
	0x6c, 0x13, 0, 0x1, 0, 0xa, 0, 0, 0, 0x49, 
	0x6e, 0x6c, 0x69, 0x6e, 0x65, 0x44, 0x61, 0x74, 0x61, 0xf, 
	0, 0xb, 0, 0x1f, 0, 0x1, 0, 0x4, 0, 0, 
	0, 0x47, 0x75, 0x69, 0x64, 0xa, 0, 0x5, 0, 0xe0, 
	0x90, 0x27, 0xa4, 0x10, 0x78, 0xcf, 0x11, 0x8f, 0x52, 0, 
	0x40, 0x33, 0x35, 0x94, 0xa3, 0x29, 0, 0x1, 0, 0x5, 
	0, 0, 0, 0x64, 0x61, 0x74, 0x61, 0x31, 0x14, 0, 
	0x28, 0, 0x1, 0, 0x5, 0, 0, 0, 0x64, 0x61, 
	0x74, 0x61, 0x32, 0x14, 0, 0x28, 0, 0x1, 0, 0x5, 
	0, 0, 0, 0x64, 0x61, 0x74, 0x61, 0x33, 0x14, 0, 
	0x34, 0, 0x2d, 0, 0x1, 0, 0x5, 0, 0, 0, 
	0x64, 0x61, 0x74, 0x61, 0x34, 0xe, 0, 0x3, 0, 0x8, 
	0, 0, 0, 0xf, 0, 0x14, 0, 0xb, 0, 0x1f, 
	0, 0x1, 0, 0xe, 0, 0, 0, 0x53, 0x74, 0x72, 
	0x69, 0x6e, 0x67, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 
	0x79, 0xa, 0, 0x5, 0, 0xe0, 0x21, 0xf, 0x7f, 0xe1, 
	0xbf, 0xd1, 0x11, 0x82, 0xc0, 0, 0xa0, 0xc9, 0x69, 0x72, 
	0x71, 0x31, 0, 0x1, 0, 0x3, 0, 0, 0, 0x6b, 
	0x65, 0x79, 0x14, 0, 0x31, 0, 0x1, 0, 0x5, 0, 
	0, 0, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x14, 0, 0xb, 
	0, 0x1f, 0, 0x1, 0, 0xb, 0, 0, 0, 0x50, 
	0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x79, 0x42, 0x61, 0x67, 
	0xa, 0, 0x5, 0, 0xe1, 0x21, 0xf, 0x7f, 0xe1, 0xbf, 
	0xd1, 0x11, 0x82, 0xc0, 0, 0xa0, 0xc9, 0x69, 0x72, 0x71, 
	0xe, 0, 0x1, 0, 0xe, 0, 0, 0, 0x53, 0x74, 
	0x72, 0x69, 0x6e, 0x67, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 
	0x74, 0x79, 0xf, 0, 0xb, 0, 0x1f, 0, 0x1, 0, 
	0xe, 0, 0, 0, 0x45, 0x78, 0x74, 0x65, 0x72, 0x6e, 
	0x61, 0x6c, 0x56, 0x69, 0x73, 0x75, 0x61, 0x6c, 0xa, 0, 
	0x5, 0, 0xa0, 0x6a, 0x11, 0x98, 0xba, 0xbd, 0xd1, 0x11, 
	0x82, 0xc0, 0, 0xa0, 0xc9, 0x69, 0x72, 0x71, 0x1, 0, 
	0x4, 0, 0, 0, 0x47, 0x75, 0x69, 0x64, 0x1, 0, 
	0x12, 0, 0, 0, 0x67, 0x75, 0x69, 0x64, 0x45, 0x78, 
	0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x56, 0x69, 0x73, 0x75, 
	0x61, 0x6c, 0x14, 0, 0xe, 0, 0x12, 0, 0x12, 0, 
	0x12, 0, 0xf, 0, 0xb, 0, 0x1f, 0, 0x1, 0, 
	0xb, 0, 0, 0, 0x52, 0x69, 0x67, 0x68, 0x74, 0x48, 
	0x61, 0x6e, 0x64, 0x65, 0x64, 0xa, 0, 0x5, 0, 0xa0, 
	0x5e, 0x5d, 0x7f, 0x3a, 0xd5, 0xd1, 0x11, 0x82, 0xc0, 0, 
	0xa0, 0xc9, 0x69, 0x72, 0x71, 0x29, 0, 0x1, 0, 0xc, 
	0, 0, 0, 0x62, 0x52, 0x69, 0x67, 0x68, 0x74, 0x48, 
	0x61, 0x6e, 0x64, 0x65, 0x64, 0x14, 0, 0xb, 0
};

#define D3DRM_XTEMPLATE_BYTES 3278

#endif /* _RMXFTMPL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DirectX\9c\Include\Segment.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0357 */
/* Compiler settings for segment.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __segment_h__
#define __segment_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IMSVidRect_FWD_DEFINED__
#define __IMSVidRect_FWD_DEFINED__
typedef interface IMSVidRect IMSVidRect;
#endif 	/* __IMSVidRect_FWD_DEFINED__ */


#ifndef __IMSVidGraphSegmentContainer_FWD_DEFINED__
#define __IMSVidGraphSegmentContainer_FWD_DEFINED__
typedef interface IMSVidGraphSegmentContainer IMSVidGraphSegmentContainer;
#endif 	/* __IMSVidGraphSegmentContainer_FWD_DEFINED__ */


#ifndef __IMSVidGraphSegment_FWD_DEFINED__
#define __IMSVidGraphSegment_FWD_DEFINED__
typedef interface IMSVidGraphSegment IMSVidGraphSegment;
#endif 	/* __IMSVidGraphSegment_FWD_DEFINED__ */


#ifndef __IMSVidGraphSegmentUserInput_FWD_DEFINED__
#define __IMSVidGraphSegmentUserInput_FWD_DEFINED__
typedef interface IMSVidGraphSegmentUserInput IMSVidGraphSegmentUserInput;
#endif 	/* __IMSVidGraphSegmentUserInput_FWD_DEFINED__ */


#ifndef __IMSVidCompositionSegment_FWD_DEFINED__
#define __IMSVidCompositionSegment_FWD_DEFINED__
typedef interface IMSVidCompositionSegment IMSVidCompositionSegment;
#endif 	/* __IMSVidCompositionSegment_FWD_DEFINED__ */


#ifndef __IEnumMSVidGraphSegment_FWD_DEFINED__
#define __IEnumMSVidGraphSegment_FWD_DEFINED__
typedef interface IEnumMSVidGraphSegment IEnumMSVidGraphSegment;
#endif 	/* __IEnumMSVidGraphSegment_FWD_DEFINED__ */


#ifndef __IMSVidVRGraphSegment_FWD_DEFINED__
#define __IMSVidVRGraphSegment_FWD_DEFINED__
typedef interface IMSVidVRGraphSegment IMSVidVRGraphSegment;
#endif 	/* __IMSVidVRGraphSegment_FWD_DEFINED__ */


#ifndef __IMSVidDevice_FWD_DEFINED__
#define __IMSVidDevice_FWD_DEFINED__
typedef interface IMSVidDevice IMSVidDevice;
#endif 	/* __IMSVidDevice_FWD_DEFINED__ */


#ifndef __IMSVidInputDevice_FWD_DEFINED__
#define __IMSVidInputDevice_FWD_DEFINED__
typedef interface IMSVidInputDevice IMSVidInputDevice;
#endif 	/* __IMSVidInputDevice_FWD_DEFINED__ */


#ifndef __IMSVidDeviceEvent_FWD_DEFINED__
#define __IMSVidDeviceEvent_FWD_DEFINED__
typedef interface IMSVidDeviceEvent IMSVidDeviceEvent;
#endif 	/* __IMSVidDeviceEvent_FWD_DEFINED__ */


#ifndef __IMSVidInputDeviceEvent_FWD_DEFINED__
#define __IMSVidInputDeviceEvent_FWD_DEFINED__
typedef interface IMSVidInputDeviceEvent IMSVidInputDeviceEvent;
#endif 	/* __IMSVidInputDeviceEvent_FWD_DEFINED__ */


#ifndef __IMSVidVideoInputDevice_FWD_DEFINED__
#define __IMSVidVideoInputDevice_FWD_DEFINED__
typedef interface IMSVidVideoInputDevice IMSVidVideoInputDevice;
#endif 	/* __IMSVidVideoInputDevice_FWD_DEFINED__ */


#ifndef __IMSVidPlayback_FWD_DEFINED__
#define __IMSVidPlayback_FWD_DEFINED__
typedef interface IMSVidPlayback IMSVidPlayback;
#endif 	/* __IMSVidPlayback_FWD_DEFINED__ */


#ifndef __IMSVidPlaybackEvent_FWD_DEFINED__
#define __IMSVidPlaybackEvent_FWD_DEFINED__
typedef interface IMSVidPlaybackEvent IMSVidPlaybackEvent;
#endif 	/* __IMSVidPlaybackEvent_FWD_DEFINED__ */


#ifndef __IMSVidTuner_FWD_DEFINED__
#define __IMSVidTuner_FWD_DEFINED__
typedef interface IMSVidTuner IMSVidTuner;
#endif 	/* __IMSVidTuner_FWD_DEFINED__ */


#ifndef __IMSVidTunerEvent_FWD_DEFINED__
#define __IMSVidTunerEvent_FWD_DEFINED__
typedef interface IMSVidTunerEvent IMSVidTunerEvent;
#endif 	/* __IMSVidTunerEvent_FWD_DEFINED__ */


#ifndef __IMSVidAnalogTuner_FWD_DEFINED__
#define __IMSVidAnalogTuner_FWD_DEFINED__
typedef interface IMSVidAnalogTuner IMSVidAnalogTuner;
#endif 	/* __IMSVidAnalogTuner_FWD_DEFINED__ */


#ifndef __IMSVidAnalogTunerEvent_FWD_DEFINED__
#define __IMSVidAnalogTunerEvent_FWD_DEFINED__
typedef interface IMSVidAnalogTunerEvent IMSVidAnalogTunerEvent;
#endif 	/* __IMSVidAnalogTunerEvent_FWD_DEFINED__ */


#ifndef __IMSVidFilePlayback_FWD_DEFINED__
#define __IMSVidFilePlayback_FWD_DEFINED__
typedef interface IMSVidFilePlayback IMSVidFilePlayback;
#endif 	/* __IMSVidFilePlayback_FWD_DEFINED__ */


#ifndef __IMSVidFilePlaybackEvent_FWD_DEFINED__
#define __IMSVidFilePlaybackEvent_FWD_DEFINED__
typedef interface IMSVidFilePlaybackEvent IMSVidFilePlaybackEvent;
#endif 	/* __IMSVidFilePlaybackEvent_FWD_DEFINED__ */


#ifndef __IMSVidWebDVD_FWD_DEFINED__
#define __IMSVidWebDVD_FWD_DEFINED__
typedef interface IMSVidWebDVD IMSVidWebDVD;
#endif 	/* __IMSVidWebDVD_FWD_DEFINED__ */


#ifndef __IMSVidWebDVDEvent_FWD_DEFINED__
#define __IMSVidWebDVDEvent_FWD_DEFINED__
typedef interface IMSVidWebDVDEvent IMSVidWebDVDEvent;
#endif 	/* __IMSVidWebDVDEvent_FWD_DEFINED__ */


#ifndef __IMSVidWebDVDAdm_FWD_DEFINED__
#define __IMSVidWebDVDAdm_FWD_DEFINED__
typedef interface IMSVidWebDVDAdm IMSVidWebDVDAdm;
#endif 	/* __IMSVidWebDVDAdm_FWD_DEFINED__ */


#ifndef __IMSVidOutputDevice_FWD_DEFINED__
#define __IMSVidOutputDevice_FWD_DEFINED__
typedef interface IMSVidOutputDevice IMSVidOutputDevice;
#endif 	/* __IMSVidOutputDevice_FWD_DEFINED__ */


#ifndef __IMSVidOutputDeviceEvent_FWD_DEFINED__
#define __IMSVidOutputDeviceEvent_FWD_DEFINED__
typedef interface IMSVidOutputDeviceEvent IMSVidOutputDeviceEvent;
#endif 	/* __IMSVidOutputDeviceEvent_FWD_DEFINED__ */


#ifndef __IMSVidFeature_FWD_DEFINED__
#define __IMSVidFeature_FWD_DEFINED__
typedef interface IMSVidFeature IMSVidFeature;
#endif 	/* __IMSVidFeature_FWD_DEFINED__ */


#ifndef __IMSVidFeatureEvent_FWD_DEFINED__
#define __IMSVidFeatureEvent_FWD_DEFINED__
typedef interface IMSVidFeatureEvent IMSVidFeatureEvent;
#endif 	/* __IMSVidFeatureEvent_FWD_DEFINED__ */


#ifndef __IMSVidEncoder_FWD_DEFINED__
#define __IMSVidEncoder_FWD_DEFINED__
typedef interface IMSVidEncoder IMSVidEncoder;
#endif 	/* __IMSVidEncoder_FWD_DEFINED__ */


#ifndef __IMSVidXDS_FWD_DEFINED__
#define __IMSVidXDS_FWD_DEFINED__
typedef interface IMSVidXDS IMSVidXDS;
#endif 	/* __IMSVidXDS_FWD_DEFINED__ */


#ifndef __IMSVidDataServices_FWD_DEFINED__
#define __IMSVidDataServices_FWD_DEFINED__
typedef interface IMSVidDataServices IMSVidDataServices;
#endif 	/* __IMSVidDataServices_FWD_DEFINED__ */


#ifndef __IMSVidDataServicesEvent_FWD_DEFINED__
#define __IMSVidDataServicesEvent_FWD_DEFINED__
typedef interface IMSVidDataServicesEvent IMSVidDataServicesEvent;
#endif 	/* __IMSVidDataServicesEvent_FWD_DEFINED__ */


#ifndef __IMSVidClosedCaptioning_FWD_DEFINED__
#define __IMSVidClosedCaptioning_FWD_DEFINED__
typedef interface IMSVidClosedCaptioning IMSVidClosedCaptioning;
#endif 	/* __IMSVidClosedCaptioning_FWD_DEFINED__ */


#ifndef __IMSVidClosedCaptioning2_FWD_DEFINED__
#define __IMSVidClosedCaptioning2_FWD_DEFINED__
typedef interface IMSVidClosedCaptioning2 IMSVidClosedCaptioning2;
#endif 	/* __IMSVidClosedCaptioning2_FWD_DEFINED__ */


#ifndef __IMSVidVideoRenderer_FWD_DEFINED__
#define __IMSVidVideoRenderer_FWD_DEFINED__
typedef interface IMSVidVideoRenderer IMSVidVideoRenderer;
#endif 	/* __IMSVidVideoRenderer_FWD_DEFINED__ */


#ifndef __IMSVidVideoRendererEvent_FWD_DEFINED__
#define __IMSVidVideoRendererEvent_FWD_DEFINED__
typedef interface IMSVidVideoRendererEvent IMSVidVideoRendererEvent;
#endif 	/* __IMSVidVideoRendererEvent_FWD_DEFINED__ */


#ifndef __IMSVidStreamBufferRecordingControl_FWD_DEFINED__
#define __IMSVidStreamBufferRecordingControl_FWD_DEFINED__
typedef interface IMSVidStreamBufferRecordingControl IMSVidStreamBufferRecordingControl;
#endif 	/* __IMSVidStreamBufferRecordingControl_FWD_DEFINED__ */


#ifndef __IMSVidStreamBufferSink_FWD_DEFINED__
#define __IMSVidStreamBufferSink_FWD_DEFINED__
typedef interface IMSVidStreamBufferSink IMSVidStreamBufferSink;
#endif 	/* __IMSVidStreamBufferSink_FWD_DEFINED__ */


#ifndef __IMSVidStreamBufferSinkEvent_FWD_DEFINED__
#define __IMSVidStreamBufferSinkEvent_FWD_DEFINED__
typedef interface IMSVidStreamBufferSinkEvent IMSVidStreamBufferSinkEvent;
#endif 	/* __IMSVidStreamBufferSinkEvent_FWD_DEFINED__ */


#ifndef __IMSVidStreamBufferSource_FWD_DEFINED__
#define __IMSVidStreamBufferSource_FWD_DEFINED__
typedef interface IMSVidStreamBufferSource IMSVidStreamBufferSource;
#endif 	/* __IMSVidStreamBufferSource_FWD_DEFINED__ */


#ifndef __IMSVidStreamBufferSourceEvent_FWD_DEFINED__
#define __IMSVidStreamBufferSourceEvent_FWD_DEFINED__
typedef interface IMSVidStreamBufferSourceEvent IMSVidStreamBufferSourceEvent;
#endif 	/* __IMSVidStreamBufferSourceEvent_FWD_DEFINED__ */


#ifndef __IMSVidVideoRenderer2_FWD_DEFINED__
#define __IMSVidVideoRenderer2_FWD_DEFINED__
typedef interface IMSVidVideoRenderer2 IMSVidVideoRenderer2;
#endif 	/* __IMSVidVideoRenderer2_FWD_DEFINED__ */


#ifndef __IMSVidVideoRendererEvent2_FWD_DEFINED__
#define __IMSVidVideoRendererEvent2_FWD_DEFINED__
typedef interface IMSVidVideoRendererEvent2 IMSVidVideoRendererEvent2;
#endif 	/* __IMSVidVideoRendererEvent2_FWD_DEFINED__ */


#ifndef __IMSVidAudioRenderer_FWD_DEFINED__
#define __IMSVidAudioRenderer_FWD_DEFINED__
typedef interface IMSVidAudioRenderer IMSVidAudioRenderer;
#endif 	/* __IMSVidAudioRenderer_FWD_DEFINED__ */


#ifndef __IMSVidAudioRendererEvent_FWD_DEFINED__
#define __IMSVidAudioRendererEvent_FWD_DEFINED__
typedef interface IMSVidAudioRendererEvent IMSVidAudioRendererEvent;
#endif 	/* __IMSVidAudioRendererEvent_FWD_DEFINED__ */


#ifndef __IMSVidInputDevices_FWD_DEFINED__
#define __IMSVidInputDevices_FWD_DEFINED__
typedef interface IMSVidInputDevices IMSVidInputDevices;
#endif 	/* __IMSVidInputDevices_FWD_DEFINED__ */


#ifndef __IMSVidOutputDevices_FWD_DEFINED__
#define __IMSVidOutputDevices_FWD_DEFINED__
typedef interface IMSVidOutputDevices IMSVidOutputDevices;
#endif 	/* __IMSVidOutputDevices_FWD_DEFINED__ */


#ifndef __IMSVidVideoRendererDevices_FWD_DEFINED__
#define __IMSVidVideoRendererDevices_FWD_DEFINED__
typedef interface IMSVidVideoRendererDevices IMSVidVideoRendererDevices;
#endif 	/* __IMSVidVideoRendererDevices_FWD_DEFINED__ */


#ifndef __IMSVidAudioRendererDevices_FWD_DEFINED__
#define __IMSVidAudioRendererDevices_FWD_DEFINED__
typedef interface IMSVidAudioRendererDevices IMSVidAudioRendererDevices;
#endif 	/* __IMSVidAudioRendererDevices_FWD_DEFINED__ */


#ifndef __IMSVidFeatures_FWD_DEFINED__
#define __IMSVidFeatures_FWD_DEFINED__
typedef interface IMSVidFeatures IMSVidFeatures;
#endif 	/* __IMSVidFeatures_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "strmif.h"
#include "tuner.h"
#include "tvratings.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_segment_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999-2000.
//
//--------------------------------------------------------------------------
#pragma once
#include <olectl.h>
typedef /* [public] */ 
enum __MIDL___MIDL_itf_segment_0000_0001
    {	dispidName	= 0,
	dispidStatus	= dispidName + 1,
	dispidDevImageSourceWidth	= dispidStatus + 1,
	dispidDevImageSourceHeight	= dispidDevImageSourceWidth + 1,
	dispidDevCountryCode	= dispidDevImageSourceHeight + 1,
	dispidDevOverScan	= dispidDevCountryCode + 1,
	dispidSegment	= dispidDevOverScan + 1,
	dispidDevVolume	= dispidSegment + 1,
	dispidDevBalance	= dispidDevVolume + 1,
	dispidDevPower	= dispidDevBalance + 1,
	dispidTuneChan	= dispidDevPower + 1,
	dispidDevVideoSubchannel	= dispidTuneChan + 1,
	dispidDevAudioSubchannel	= dispidDevVideoSubchannel + 1,
	dispidChannelAvailable	= dispidDevAudioSubchannel + 1,
	dispidDevVideoFrequency	= dispidChannelAvailable + 1,
	dispidDevAudioFrequency	= dispidDevVideoFrequency + 1,
	dispidCount	= dispidDevAudioFrequency + 1,
	dispidDevFileName	= dispidCount + 1,
	dispidVisible	= dispidDevFileName + 1,
	dispidOwner	= dispidVisible + 1,
	dispidMessageDrain	= dispidOwner + 1,
	dispidViewable	= dispidMessageDrain + 1,
	dispidDevView	= dispidViewable + 1,
	dispidKSCat	= dispidDevView + 1,
	dispidCLSID	= dispidKSCat + 1,
	dispid_KSCat	= dispidCLSID + 1,
	dispid_CLSID	= dispid_KSCat + 1,
	dispidTune	= dispid_CLSID + 1,
	dispidTS	= dispidTune + 1,
	dispidDevSAP	= dispidTS + 1,
	dispidClip	= dispidDevSAP + 1,
	dispidRequestedClipRect	= dispidClip + 1,
	dispidClippedSourceRect	= dispidRequestedClipRect + 1,
	dispidAvailableSourceRect	= dispidClippedSourceRect + 1,
	dispidMediaPosition	= dispidAvailableSourceRect + 1,
	dispidDevRun	= dispidMediaPosition + 1,
	dispidDevPause	= dispidDevRun + 1,
	dispidDevStop	= dispidDevPause + 1,
	dispidCCEnable	= dispidDevStop + 1,
	dispidDevStep	= dispidCCEnable + 1,
	dispidDevCanStep	= dispidDevStep + 1,
	dispidSourceSize	= dispidDevCanStep + 1,
	dispid_playtitle	= dispidSourceSize + 1,
	dispid_playchapterintitle	= dispid_playtitle + 1,
	dispid_playchapter	= dispid_playchapterintitle + 1,
	dispid_playchaptersautostop	= dispid_playchapter + 1,
	dispid_playattime	= dispid_playchaptersautostop + 1,
	dispid_playattimeintitle	= dispid_playattime + 1,
	dispid_playperiodintitleautostop	= dispid_playattimeintitle + 1,
	dispid_replaychapter	= dispid_playperiodintitleautostop + 1,
	dispid_playprevchapter	= dispid_replaychapter + 1,
	dispid_playnextchapter	= dispid_playprevchapter + 1,
	dispid_playforwards	= dispid_playnextchapter + 1,
	dispid_playbackwards	= dispid_playforwards + 1,
	dispid_stilloff	= dispid_playbackwards + 1,
	dispid_audiolanguage	= dispid_stilloff + 1,
	dispid_showmenu	= dispid_audiolanguage + 1,
	dispid_resume	= dispid_showmenu + 1,
	dispid_returnfromsubmenu	= dispid_resume + 1,
	dispid_buttonsavailable	= dispid_returnfromsubmenu + 1,
	dispid_currentbutton	= dispid_buttonsavailable + 1,
	dispid_SelectAndActivateButton	= dispid_currentbutton + 1,
	dispid_ActivateButton	= dispid_SelectAndActivateButton + 1,
	dispid_SelectRightButton	= dispid_ActivateButton + 1,
	dispid_SelectLeftButton	= dispid_SelectRightButton + 1,
	dispid_SelectLowerButton	= dispid_SelectLeftButton + 1,
	dispid_SelectUpperButton	= dispid_SelectLowerButton + 1,
	dispid_ActivateAtPosition	= dispid_SelectUpperButton + 1,
	dispid_SelectAtPosition	= dispid_ActivateAtPosition + 1,
	dispid_ButtonAtPosition	= dispid_SelectAtPosition + 1,
	dispid_NumberOfChapters	= dispid_ButtonAtPosition + 1,
	dispid_TotalTitleTime	= dispid_NumberOfChapters + 1,
	dispid_TitlesAvailable	= dispid_TotalTitleTime + 1,
	dispid_VolumesAvailable	= dispid_TitlesAvailable + 1,
	dispid_CurrentVolume	= dispid_VolumesAvailable + 1,
	dispid_CurrentDiscSide	= dispid_CurrentVolume + 1,
	dispid_CurrentDomain	= dispid_CurrentDiscSide + 1,
	dispid_CurrentChapter	= dispid_CurrentDomain + 1,
	dispid_CurrentTitle	= dispid_CurrentChapter + 1,
	dispid_CurrentTime	= dispid_CurrentTitle + 1,
	dispid_FramesPerSecond	= dispid_CurrentTime + 1,
	dispid_DVDTimeCode2bstr	= dispid_FramesPerSecond + 1,
	dispid_DVDDirectory	= dispid_DVDTimeCode2bstr + 1,
	dispid_IsSubpictureStreamEnabled	= dispid_DVDDirectory + 1,
	dispid_IsAudioStreamEnabled	= dispid_IsSubpictureStreamEnabled + 1,
	dispid_CurrentSubpictureStream	= dispid_IsAudioStreamEnabled + 1,
	dispid_SubpictureLanguage	= dispid_CurrentSubpictureStream + 1,
	dispid_CurrentAudioStream	= dispid_SubpictureLanguage + 1,
	dispid_AudioStreamsAvailable	= dispid_CurrentAudioStream + 1,
	dispid_AnglesAvailable	= dispid_AudioStreamsAvailable + 1,
	dispid_CurrentAngle	= dispid_AnglesAvailable + 1,
	dispid_CCActive	= dispid_CurrentAngle + 1,
	dispid_CurrentCCService	= dispid_CCActive + 1,
	dispid_SubpictureStreamsAvailable	= dispid_CurrentCCService + 1,
	dispid_SubpictureOn	= dispid_SubpictureStreamsAvailable + 1,
	dispid_DVDUniqueID	= dispid_SubpictureOn + 1,
	dispid_EnableResetOnStop	= dispid_DVDUniqueID + 1,
	dispid_AcceptParentalLevelChange	= dispid_EnableResetOnStop + 1,
	dispid_NotifyParentalLevelChange	= dispid_AcceptParentalLevelChange + 1,
	dispid_SelectParentalCountry	= dispid_NotifyParentalLevelChange + 1,
	dispid_SelectParentalLevel	= dispid_SelectParentalCountry + 1,
	dispid_TitleParentalLevels	= dispid_SelectParentalLevel + 1,
	dispid_PlayerParentalCountry	= dispid_TitleParentalLevels + 1,
	dispid_PlayerParentalLevel	= dispid_PlayerParentalCountry + 1,
	dispid_Eject	= dispid_PlayerParentalLevel + 1,
	dispid_UOPValid	= dispid_Eject + 1,
	dispid_SPRM	= dispid_UOPValid + 1,
	dispid_GPRM	= dispid_SPRM + 1,
	dispid_DVDTextStringType	= dispid_GPRM + 1,
	dispid_DVDTextString	= dispid_DVDTextStringType + 1,
	dispid_DVDTextNumberOfStrings	= dispid_DVDTextString + 1,
	dispid_DVDTextNumberOfLanguages	= dispid_DVDTextNumberOfStrings + 1,
	dispid_DVDTextLanguageLCID	= dispid_DVDTextNumberOfLanguages + 1,
	dispid_RegionChange	= dispid_DVDTextLanguageLCID + 1,
	dispid_DVDAdm	= dispid_RegionChange + 1,
	dispid_DeleteBookmark	= dispid_DVDAdm + 1,
	dispid_RestoreBookmark	= dispid_DeleteBookmark + 1,
	dispid_SaveBookmark	= dispid_RestoreBookmark + 1,
	dispid_SelectDefaultAudioLanguage	= dispid_SaveBookmark + 1,
	dispid_SelectDefaultSubpictureLanguage	= dispid_SelectDefaultAudioLanguage + 1,
	dispid_PreferredSubpictureStream	= dispid_SelectDefaultSubpictureLanguage + 1,
	dispid_DefaultMenuLanguage	= dispid_PreferredSubpictureStream + 1,
	dispid_DefaultSubpictureLanguage	= dispid_DefaultMenuLanguage + 1,
	dispid_DefaultAudioLanguage	= dispid_DefaultSubpictureLanguage + 1,
	dispid_DefaultSubpictureLanguageExt	= dispid_DefaultAudioLanguage + 1,
	dispid_DefaultAudioLanguageExt	= dispid_DefaultSubpictureLanguageExt + 1,
	dispid_LanguageFromLCID	= dispid_DefaultAudioLanguageExt + 1,
	dispid_KaraokeAudioPresentationMode	= dispid_LanguageFromLCID + 1,
	dispid_KaraokeChannelContent	= dispid_KaraokeAudioPresentationMode + 1,
	dispid_KaraokeChannelAssignment	= dispid_KaraokeChannelContent + 1,
	dispid_RestorePreferredSettings	= dispid_KaraokeChannelAssignment + 1,
	dispid_ButtonRect	= dispid_RestorePreferredSettings + 1,
	dispid_DVDScreenInMouseCoordinates	= dispid_ButtonRect + 1,
	dispid_CustomCompositorClass	= dispid_DVDScreenInMouseCoordinates + 1,
	dispidCustomCompositorClass	= dispid_CustomCompositorClass + 1,
	dispid_CustomCompositor	= dispidCustomCompositorClass + 1,
	dispidMixerBitmap	= dispid_CustomCompositor + 1,
	dispid_MixerBitmap	= dispidMixerBitmap + 1,
	dispidMixerBitmapOpacity	= dispid_MixerBitmap + 1,
	dispidMixerBitmapRect	= dispidMixerBitmapOpacity + 1,
	dispidSetupMixerBitmap	= dispidMixerBitmapRect + 1,
	dispidUsingOverlay	= dispidSetupMixerBitmap + 1,
	dispidDisplayChange	= dispidUsingOverlay + 1,
	dispidRePaint	= dispidDisplayChange + 1,
	dispid_IsEqualDevice	= dispidRePaint + 1,
	dispidrate	= dispid_IsEqualDevice + 1,
	dispidposition	= dispidrate + 1,
	dispidpositionmode	= dispidposition + 1,
	dispidlength	= dispidpositionmode + 1,
	dispidChangePassword	= dispidlength + 1,
	dispidSaveParentalLevel	= dispidChangePassword + 1,
	dispidSaveParentalCountry	= dispidSaveParentalLevel + 1,
	dispidConfirmPassword	= dispidSaveParentalCountry + 1,
	dispidGetParentalLevel	= dispidConfirmPassword + 1,
	dispidGetParentalCountry	= dispidGetParentalLevel + 1,
	dispidDefaultAudioLCID	= dispidGetParentalCountry + 1,
	dispidDefaultSubpictureLCID	= dispidDefaultAudioLCID + 1,
	dispidDefaultMenuLCID	= dispidDefaultSubpictureLCID + 1,
	dispidBookmarkOnStop	= dispidDefaultMenuLCID + 1,
	dispidMaxVidRect	= dispidBookmarkOnStop + 1,
	dispidMinVidRect	= dispidMaxVidRect + 1,
	dispidCapture	= dispidMinVidRect + 1,
	dispid_DecimateInput	= dispidCapture + 1,
	dispidAlloctor	= dispid_DecimateInput + 1,
	dispid_Allocator	= dispidAlloctor + 1,
	dispidAllocPresentID	= dispid_Allocator + 1,
	dispidSetAllocator	= dispidAllocPresentID + 1,
	dispid_SetAllocator	= dispidSetAllocator + 1,
	dispidStreamBufferSinkName	= dispid_SetAllocator + 1,
	dispidStreamBufferSourceName	= dispidStreamBufferSinkName + 1,
	dispidStreamBufferContentRecording	= dispidStreamBufferSourceName + 1,
	dispidStreamBufferReferenceRecording	= dispidStreamBufferContentRecording + 1,
	dispidstarttime	= dispidStreamBufferReferenceRecording + 1,
	dispidstoptime	= dispidstarttime + 1,
	dispidrecordingstopped	= dispidstoptime + 1,
	dispidrecordingstarted	= dispidrecordingstopped + 1,
	dispidNameSetLock	= dispidrecordingstarted + 1,
	dispidrecordingtype	= dispidNameSetLock + 1,
	dispidstart	= dispidrecordingtype + 1,
	dispidRecordingAttribute	= dispidstart + 1,
	dispid_RecordingAttribute	= dispidRecordingAttribute + 1,
	dispidSBEConfigure	= dispid_RecordingAttribute + 1,
	dispid_CurrentRatings	= dispidSBEConfigure + 1,
	dispid_MaxRatingsLevel	= dispid_CurrentRatings + 1,
	dispid_audioencoderint	= dispid_MaxRatingsLevel + 1,
	dispid_videoencoderint	= dispid_audioencoderint + 1,
	dispidService	= dispid_videoencoderint + 1,
	dispid_BlockUnrated	= dispidService + 1,
	dispid_UnratedDelay	= dispid_BlockUnrated + 1,
	dispid_SuppressEffects	= dispid_UnratedDelay + 1,
	dispidsbesource	= dispid_SuppressEffects + 1,
	LastReservedDeviceDispid	= 0x3fff
    } 	SegDispidList;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_segment_0000_0002
    {	eventidStateChange	= 0,
	eventidOnTuneChanged	= eventidStateChange + 1,
	eventidEndOfMedia	= eventidOnTuneChanged + 1,
	eventidDVDNotify	= eventidEndOfMedia + 1,
	eventidPlayForwards	= eventidDVDNotify + 1,
	eventidPlayBackwards	= eventidPlayForwards + 1,
	eventidShowMenu	= eventidPlayBackwards + 1,
	eventidResume	= eventidShowMenu + 1,
	eventidSelectOrActivateButton	= eventidResume + 1,
	eventidStillOff	= eventidSelectOrActivateButton + 1,
	eventidPauseOn	= eventidStillOff + 1,
	eventidChangeCurrentAudioStream	= eventidPauseOn + 1,
	eventidChangeCurrentSubpictureStream	= eventidChangeCurrentAudioStream + 1,
	eventidChangeCurrentAngle	= eventidChangeCurrentSubpictureStream + 1,
	eventidPlayAtTimeInTitle	= eventidChangeCurrentAngle + 1,
	eventidPlayAtTime	= eventidPlayAtTimeInTitle + 1,
	eventidPlayChapterInTitle	= eventidPlayAtTime + 1,
	eventidPlayChapter	= eventidPlayChapterInTitle + 1,
	eventidReplayChapter	= eventidPlayChapter + 1,
	eventidPlayNextChapter	= eventidReplayChapter + 1,
	eventidStop	= eventidPlayNextChapter + 1,
	eventidReturnFromSubmenu	= eventidStop + 1,
	eventidPlayTitle	= eventidReturnFromSubmenu + 1,
	eventidPlayPrevChapter	= eventidPlayTitle + 1,
	eventidChangeKaraokePresMode	= eventidPlayPrevChapter + 1,
	eventidChangeVideoPresMode	= eventidChangeKaraokePresMode + 1,
	eventidOverlayUnavailable	= eventidChangeVideoPresMode + 1,
	eventidSinkCertificateFailure	= eventidOverlayUnavailable + 1,
	eventidSinkCertificateSuccess	= eventidSinkCertificateFailure + 1,
	eventidSourceCertificateFailure	= eventidSinkCertificateSuccess + 1,
	eventidSourceCertificateSuccess	= eventidSourceCertificateFailure + 1,
	eventidRatingsBlocked	= eventidSourceCertificateSuccess + 1,
	eventidRatingsUnlocked	= eventidRatingsBlocked + 1,
	eventidRatingsChanged	= eventidRatingsUnlocked + 1,
	eventidWriteFailure	= eventidRatingsChanged + 1,
	eventidTimeHole	= eventidWriteFailure + 1,
	eventidStaleDataRead	= eventidTimeHole + 1,
	eventidContentBecomingStale	= eventidStaleDataRead + 1,
	eventidStaleFileDeleted	= eventidContentBecomingStale + 1,
	LastReservedDeviceEvent	= 0x3fff
    } 	SegEventidList;

typedef /* [public][public][public] */ 
enum __MIDL___MIDL_itf_segment_0000_0003
    {	FrameMode	= 0,
	TenthsSecondsMode	= FrameMode + 1
    } 	PositionModeList;

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_segment_0000_0004
    {	CONTENT	= 0,
	REFERENCE	= CONTENT + 1
    } 	RecordingType;

typedef /* [public][public][public] */ 
enum __MIDL___MIDL_itf_segment_0000_0005
    {	None	= 0,
	Caption1	= None + 1,
	Caption2	= Caption1 + 1,
	Text1	= Caption2 + 1,
	Text2	= Text1 + 1,
	XDS	= Text2 + 1
    } 	MSVidCCService;




extern RPC_IF_HANDLE __MIDL_itf_segment_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_segment_0000_v0_0_s_ifspec;

#ifndef __IMSVidRect_INTERFACE_DEFINED__
#define __IMSVidRect_INTERFACE_DEFINED__

/* interface IMSVidRect */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IMSVidRect;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7F5000A6-A440-47ca-8ACC-C0E75531A2C2")
    IMSVidRect : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Top( 
            /* [retval][out] */ LONG *TopVal) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Top( 
            /* [in] */ LONG TopVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Left( 
            /* [retval][out] */ LONG *LeftVal) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Left( 
            /* [in] */ LONG LeftVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Width( 
            /* [retval][out] */ LONG *WidthVal) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Width( 
            /* [in] */ LONG WidthVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Height( 
            /* [retval][out] */ LONG *HeightVal) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Height( 
            /* [in] */ LONG HeightVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_HWnd( 
            /* [retval][out] */ HWND *HWndVal) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_HWnd( 
            /* [in] */ HWND HWndVal) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Rect( 
            /* [in] */ IMSVidRect *RectVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSVidRectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSVidRect * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSVidRect * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSVidRect * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSVidRect * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSVidRect * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSVidRect * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSVidRect * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Top )( 
            IMSVidRect * This,
            /* [retval][out] */ LONG *TopVal);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Top )( 
            IMSVidRect * This,
            /* [in] */ LONG TopVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Left )( 
            IMSVidRect * This,
            /* [retval][out] */ LONG *LeftVal);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Left )( 
            IMSVidRect * This,
            /* [in] */ LONG LeftVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Width )( 
            IMSVidRect * This,
            /* [retval][out] */ LONG *WidthVal);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Width )( 
            IMSVidRect * This,
            /* [in] */ LONG WidthVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Height )( 
            IMSVidRect * This,
            /* [retval][out] */ LONG *HeightVal);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Height )( 
            IMSVidRect * This,
            /* [in] */ LONG HeightVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HWnd )( 
            IMSVidRect * This,
            /* [retval][out] */ HWND *HWndVal);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_HWnd )( 
            IMSVidRect * This,
            /* [in] */ HWND HWndVal);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Rect )( 
            IMSVidRect * This,
            /* [in] */ IMSVidRect *RectVal);
        
        END_INTERFACE
    } IMSVidRectVtbl;

    interface IMSVidRect
    {
        CONST_VTBL struct IMSVidRectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSVidRect_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSVidRect_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSVidRect_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSVidRect_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSVidRect_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSVidRect_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSVidRect_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSVidRect_get_Top(This,TopVal)	\
    (This)->lpVtbl -> get_Top(This,TopVal)

#define IMSVidRect_put_Top(This,TopVal)	\
    (This)->lpVtbl -> put_Top(This,TopVal)

#define IMSVidRect_get_Left(This,LeftVal)	\
    (This)->lpVtbl -> get_Left(This,LeftVal)

#define IMSVidRect_put_Left(This,LeftVal)	\
    (This)->lpVtbl -> put_Left(This,LeftVal)

#define IMSVidRect_get_Width(This,WidthVal)	\
    (This)->lpVtbl -> get_Width(This,WidthVal)

#define IMSVidRect_put_Width(This,WidthVal)	\
    (This)->lpVtbl -> put_Width(This,WidthVal)

#define IMSVidRect_get_Height(This,HeightVal)	\
    (This)->lpVtbl -> get_Height(This,HeightVal)

#define IMSVidRect_put_Height(This,HeightVal)	\
    (This)->lpVtbl -> put_Height(This,HeightVal)

#define IMSVidRect_get_HWnd(This,HWndVal)	\
    (This)->lpVtbl -> get_HWnd(This,HWndVal)

#define IMSVidRect_put_HWnd(This,HWndVal)	\
    (This)->lpVtbl -> put_HWnd(This,HWndVal)

#define IMSVidRect_put_Rect(This,RectVal)	\
    (This)->lpVtbl -> put_Rect(This,RectVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMSVidRect_get_Top_Proxy( 
    IMSVidRect * This,
    /* [retval][out] */ LONG *TopVal);


void __RPC_STUB IMSVidRect_get_Top_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IMSVidRect_put_Top_Proxy( 
    IMSVidRect * This,
    /* [in] */ LONG TopVal);


void __RPC_STUB IMSVidRect_put_Top_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMSVidRect_get_Left_Proxy( 
    IMSVidRect * This,
    /* [retval][out] */ LONG *LeftVal);


void __RPC_STUB IMSVidRect_get_Left_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IMSVidRect_put_Left_Proxy( 
    IMSVidRect * This,
    /* [in] */ LONG LeftVal);


void __RPC_STUB IMSVidRect_put_Left_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMSVidRect_get_Width_Proxy( 
    IMSVidRect * This,
    /* [retval][out] */ LONG *WidthVal);


void __RPC_STUB IMSVidRect_get_Width_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IMSVidRect_put_Width_Proxy( 
    IMSVidRect * This,
    /* [in] */ LONG WidthVal);


void __RPC_STUB IMSVidRect_put_Width_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMSVidRect_get_Height_Proxy( 
    IMSVidRect * This,
    /* [retval][out] */ LONG *HeightVal);


void __RPC_STUB IMSVidRect_get_Height_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IMSVidRect_put_Height_Proxy( 
    IMSVidRect * This,
    /* [in] */ LONG HeightVal);


void __RPC_STUB IMSVidRect_put_Height_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMSVidRect_get_HWnd_Proxy( 
    IMSVidRect * This,
    /* [retval][out] */ HWND *HWndVal);


void __RPC_STUB IMSVidRect_get_HWnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IMSVidRect_put_HWnd_Proxy( 
    IMSVidRect * This,
    /* [in] */ HWND HWndVal);


void __RPC_STUB IMSVidRect_put_HWnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IMSVidRect_put_Rect_Proxy( 
    IMSVidRect * This,
    /* [in] */ IMSVidRect *RectVal);


void __RPC_STUB IMSVidRect_put_Rect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSVidRect_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_segment_0463 */
/* [local] */ 






extern RPC_IF_HANDLE __MIDL_itf_segment_0463_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_segment_0463_v0_0_s_ifspec;

#ifndef __IMSVidGraphSegmentContainer_INTERFACE_DEFINED__
#define __IMSVidGraphSegmentContainer_INTERFACE_DEFINED__

/* interface IMSVidGraphSegmentContainer */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IMSVidGraphSegmentContainer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3DD2903D-E0AA-11d2-B63A-00C04F79498E")
    IMSVidGraphSegmentContainer : public IUnknown
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Graph( 
            /* [out] */ IGraphBuilder **ppGraph) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Input( 
            /* [out] */ IMSVidGraphSegment **pInput) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Outputs( 
            /* [out] */ IEnumMSVidGraphSegment **pOutputs) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_VideoRenderer( 
            /* [out] */ IMSVidGraphSegment **pVR) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_AudioRenderer( 
            /* [out] */ IMSVidGraphSegment **pAR) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Features( 
            /* [out] */ IEnumMSVidGraphSegment **pOutputs) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Composites( 
            /* [out] */ IEnumMSVidGraphSegment **pComposites) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ParentContainer( 
            /* [out] */ IUnknown **ppContainer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Decompose( 
            IMSVidGraphSegment *pSegment) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsWindowless( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFocus( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSVidGraphSegmentContainerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSVidGraphSegmentContainer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSVidGraphSegmentContainer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSVidGraphSegmentContainer * This);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Graph )( 
            IMSVidGraphSegmentContainer * This,
            /* [out] */ IGraphBuilder **ppGraph);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Input )( 
            IMSVidGraphSegmentContainer * This,
            /* [out] */ IMSVidGraphSegment **pInput);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Outputs )( 
            IMSVidGraphSegmentContainer * This,
            /* [out] */ IEnumMSVidGraphSegment **pOutputs);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_VideoRenderer )( 
            IMSVidGraphSegmentContainer * This,
            /* [out] */ IMSVidGraphSegment **pVR);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AudioRenderer )( 
            IMSVidGraphSegmentContainer * This,
            /* [out] */ IMSVidGraphSegment **pAR);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Features )( 
            IMSVidGraphSegmentContainer * This,
            /* [out] */ IEnumMSVidGraphSegment **pOutputs);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Composites )( 
            IMSVidGraphSegmentContainer * This,
            /* [out] */ IEnumMSVidGraphSegment **pComposites);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ParentContainer )( 
            IMSVidGraphSegmentContainer * This,
            /* [out] */ IUnknown **ppContainer);
        
        HRESULT ( STDMETHODCALLTYPE *Decompose )( 
            IMSVidGraphSegmentContainer * This,
            IMSVidGraphSegment *pSegment);
        
        HRESULT ( STDMETHODCALLTYPE *IsWindowless )( 
            IMSVidGraphSegmentContainer * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetFocus )( 
            IMSVidGraphSegmentContainer * This);
        
        END_INTERFACE
    } IMSVidGraphSegmentContainerVtbl;

    interface IMSVidGraphSegmentContainer
    {
        CONST_VTBL struct IMSVidGraphSegmentContainerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSVidGraphSegmentContainer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSVidGraphSegmentContainer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSVidGraphSegmentContainer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSVidGraphSegmentContainer_get_Graph(This,ppGraph)	\
    (This)->lpVtbl -> get_Graph(This,ppGraph)

#define IMSVidGraphSegmentContainer_get_Input(This,pInput)	\
    (This)->lpVtbl -> get_Input(This,pInput)

#define IMSVidGraphSegmentContainer_get_Outputs(This,pOutputs)	\
    (This)->lpVtbl -> get_Outputs(This,pOutputs)

#define IMSVidGraphSegmentContainer_get_VideoRenderer(This,pVR)	\
    (This)->lpVtbl -> get_VideoRenderer(This,pVR)

#define IMSVidGraphSegmentContainer_get_AudioRenderer(This,pAR)	\
    (This)->lpVtbl -> get_AudioRenderer(This,pAR)

#define IMSVidGraphSegmentContainer_get_Features(This,pOutputs)	\
    (This)->lpVtbl -> get_Features(This,pOutputs)

#define IMSVidGraphSegmentContainer_get_Composites(This,pComposites)	\
    (This)->lpVtbl -> get_Composites(This,pComposites)

#define IMSVidGraphSegmentContainer_get_ParentContainer(This,ppContainer)	\
    (This)->lpVtbl -> get_ParentContainer(This,ppContainer)

#define IMSVidGraphSegmentContainer_Decompose(This,pSegment)	\
    (This)->lpVtbl -> Decompose(This,pSegment)

#define IMSVidGraphSegmentContainer_IsWindowless(This)	\
    (This)->lpVtbl -> IsWindowless(This)

#define IMSVidGraphSegmentContainer_GetFocus(This)	\
    (This)->lpVtbl -> GetFocus(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMSVidGraphSegmentContainer_get_Graph_Proxy( 
    IMSVidGraphSegmentContainer * This,
    /* [out] */ IGraphBuilder **ppGraph);


void __RPC_STUB IMSVidGraphSegmentContainer_get_Graph_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMSVidGraphSegmentContainer_get_Input_Proxy( 
    IMSVidGraphSegmentContainer * This,
    /* [out] */ IMSVidGraphSegment **pInput);


void __RPC_STUB IMSVidGraphSegmentContainer_get_Input_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMSVidGraphSegmentContainer_get_Outputs_Proxy( 
    IMSVidGraphSegmentContainer * This,
    /* [out] */ IEnumMSVidGraphSegment **pOutputs);


void __RPC_STUB IMSVidGraphSegmentContainer_get_Outputs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMSVidGraphSegmentContainer_get_VideoRenderer_Proxy( 
    IMSVidGraphSegmentContainer * This,
    /* [out] */ IMSVidGraphSegment **pVR);


void __RPC_STUB IMSVidGraphSegmentContainer_get_VideoRenderer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMSVidGraphSegmentContainer_get_AudioRenderer_Proxy( 
    IMSVidGraphSegmentContainer * This,
    /* [out] */ IMSVidGraphSegment **pAR);


void __RPC_STUB IMSVidGraphSegmentContainer_get_AudioRenderer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMSVidGraphSegmentContainer_get_Features_Proxy( 
    IMSVidGraphSegmentContainer * This,
    /* [out] */ IEnumMSVidGraphSegment **pOutputs);


void __RPC_STUB IMSVidGraphSegmentContainer_get_Features_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMSVidGraphSegmentContainer_get_Composites_Proxy( 
    IMSVidGraphSegmentContainer * This,
    /* [out] */ IEnumMSVidGraphSegment **pComposites);


void __RPC_STUB IMSVidGraphSegmentContainer_get_Composites_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMSVidGraphSegmentContainer_get_ParentContainer_Proxy( 
    IMSVidGraphSegmentContainer * This,
    /* [out] */ IUnknown **ppContainer);


void __RPC_STUB IMSVidGraphSegmentContainer_get_ParentContainer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSVidGraphSegmentContainer_Decompose_Proxy( 
    IMSVidGraphSegmentContainer * This,
    IMSVidGraphSegment *pSegment);


void __RPC_STUB IMSVidGraphSegmentContainer_Decompose_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSVidGraphSegmentContainer_IsWindowless_Proxy( 
    IMSVidGraphSegmentContainer * This);


void __RPC_STUB IMSVidGraphSegmentContainer_IsWindowless_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSVidGraphSegmentContainer_GetFocus_Proxy( 
    IMSVidGraphSegmentContainer * This);


void __RPC_STUB IMSVidGraphSegmentContainer_GetFocus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSVidGraphSegmentContainer_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_segment_0464 */
/* [local] */ 

typedef 
enum MSVidSegmentType
    {	MSVidSEG_SOURCE	= 0,
	MSVidSEG_XFORM	= MSVidSEG_SOURCE + 1,
	MSVidSEG_DEST	= MSVidSEG_XFORM + 1
    } 	MSVidSegmentType;



extern RPC_IF_HANDLE __MIDL_itf_segment_0464_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_segment_0464_v0_0_s_ifspec;

#ifndef __IMSVidGraphSegment_INTERFACE_DEFINED__
#define __IMSVidGraphSegment_INTERFACE_DEFINED__

/* interface IMSVidGraphSegment */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IMSVidGraphSegment;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1C15D482-911D-11d2-B632-00C04F79498E")
    IMSVidGraphSegment : public IPersist
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Init( 
            /* [retval][out] */ IUnknown **pInit) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Init( 
            /* [in] */ IUnknown *pInit) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumFilters( 
            /* [out] */ IEnumFilters **pNewEnum) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Container( 
            /* [retval][out] */ IMSVidGraphSegmentContainer **ppCtl) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Container( 
            /* [in] */ IMSVidGraphSegmentContainer *pCtl) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ MSVidSegmentType *pType) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Category( 
            /* [retval][out] */ GUID *pGuid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Build( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PreRun( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PostRun( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PreStop( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PostStop( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnEventNotify( 
            LONG lEventCode,
            LONG_PTR lEventParm1,
            LONG_PTR lEventParm2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Decompose( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSVidGraphSegmentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSVidGraphSegment * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSVidGraphSegment * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSVidGraphSegment * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassID )( 
            IMSVidGraphSegment * This,
            /* [out] */ CLSID *pClassID);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Init )( 
            IMSVidGraphSegment * This,
            /* [retval][out] */ IUnknown **pInit);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Init )( 
            IMSVidGraphSegment * This,
            /* [in] */ IUnknown *pInit);
        
        HRESULT ( STDMETHODCALLTYPE *EnumFilters )( 
            IMSVidGraphSegment * This,
            /* [out] */ IEnumFilters **pNewEnum);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Container )( 
            IMSVidGraphSegment * This,
            /* [retval][out] */ IMSVidGraphSegmentContainer **ppCtl);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Container )( 
            IMSVidGraphSegment * This,
            /* [in] */ IMSVidGraphSegmentContainer *pCtl);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Type )( 
            IMSVidGraphSegment * This,
            /* [retval][out] */ MSVidSegmentType *pType);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Category )( 
            IMSVidGraphSegment * This,
            /* [retval][out] */ GUID *pGuid);
        
        HRESULT ( STDMETHODCALLTYPE *Build )( 
            IMSVidGraphSegment * This);
        
        HRESULT ( STDMETHODCALLTYPE *PreRun )( 
            IMSVidGraphSegment * This);
        
        HRESULT ( STDMETHODCALLTYPE *PostRun )( 
            IMSVidGraphSegment * This);
        
        HRESULT ( STDMETHODCALLTYPE *PreStop )( 
            IMSVidGraphSegment * This);
        
        HRESULT ( STDMETHODCALLTYPE *PostStop )( 
            IMSVidGraphSegment * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnEventNotify )( 
            IMSVidGraphSegment * This,
            LONG lEventCode,
            LONG_PTR lEventParm1,
            LONG_PTR lEventParm2);
        
        HRESULT ( STDMETHODCALLTYPE *Decompose )( 
            IMSVidGraphSegment * This);
        
        END_INTERFACE
    } IMSVidGraphSegmentVtbl;

    interface IMSVidGraphSegment
    {
        CONST_VTBL struct IMSVidGraphSegmentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSVidGraphSegment_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSVidGraphSegment_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSVidGraphSegment_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSVidGraphSegment_GetClassID(This,pClassID)	\
    (This)->lpVtbl -> GetClassID(This,pClassID)


#define IMSVidGraphSegment_get_Init(This,pInit)	\
    (This)->lpVtbl -> get_Init(This,pInit)

#define IMSVidGraphSegment_put_Init(This,pInit)	\
    (This)->lpVtbl -> put_Init(This,pInit)

#define IMSVidGraphSegment_EnumFilters(This,pNewEnum)	\
    (This)->lpVtbl -> EnumFilters(This,pNewEnum)

#define IMSVidGraphSegment_get_Container(This,ppCtl)	\
    (This)->lpVtbl -> get_Container(This,ppCtl)

#define IMSVidGraphSegment_put_Container(This,pCtl)	\
    (This)->lpVtbl -> put_Container(This,pCtl)

#define IMSVidGraphSegment_get_Type(This,pType)	\
    (This)->lpVtbl -> get_Type(This,pType)

#define IMSVidGraphSegment_get_Category(This,pGuid)	\
    (This)->lpVtbl -> get_Category(This,pGuid)

#define IMSVidGraphSegment_Build(This)	\
    (This)->lpVtbl -> Build(This)

#define IMSVidGraphSegment_PreRun(This)	\
    (This)->lpVtbl -> PreRun(This)

#define IMSVidGraphSegment_PostRun(This)	\
    (This)->lpVtbl -> PostRun(This)

#define IMSVidGraphSegment_PreStop(This)	\
    (This)->lpVtbl -> PreStop(This)

#define IMSVidGraphSegment_PostStop(This)	\
    (This)->lpVtbl -> PostStop(This)

#define IMSVidGraphSegment_OnEventNotify(This,lEventCode,lEventParm1,lEventParm2)	\
    (This)->lpVtbl -> OnEventNotify(This,lEventCode,lEventParm1,lEventParm2)

#define IMSVidGraphSegment_Decompose(This)	\
    (This)->lpVtbl -> Decompose(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT STDMETHODCALLTYPE IMSVidGraphSegment_get_Init_Proxy( 
    IMSVidGraphSegment * This,
    /* [retval][out] */ IUnknown **pInit);


void __RPC_STUB IMSVidGraphSegment_get_Init_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IMSVidGraphSegment_put_Init_Proxy( 
    IMSVidGraphSegment * This,
    /* [in] */ IUnknown *pInit);


void __RPC_STUB IMSVidGraphSegment_put_Init_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSVidGraphSegment_EnumFilters_Proxy( 
    IMSVidGraphSegment * This,
    /* [out] */ IEnumFilters **pNewEnum);


void __RPC_STUB IMSVidGraphSegment_EnumFilters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMSVidGraphSegment_get_Container_Proxy( 
    IMSVidGraphSegment * This,
    /* [retval][out] */ IMSVidGraphSegmentContainer **ppCtl);


void __RPC_STUB IMSVidGraphSegment_get_Container_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IMSVidGraphSegment_put_Container_Proxy( 
    IMSVidGraphSegment * This,
    /* [in] */ IMSVidGraphSegmentContainer *pCtl);


void __RPC_STUB IMSVidGraphSegment_put_Container_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMSVidGraphSegment_get_Type_Proxy( 
    IMSVidGraphSegment * This,
    /* [retval][out] */ MSVidSegmentType *pType);


void __RPC_STUB IMSVidGraphSegment_get_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMSVidGraphSegment_get_Category_Proxy( 
    IMSVidGraphSegment * This,
    /* [retval][out] */ GUID *pGuid);


void __RPC_STUB IMSVidGraphSegment_get_Category_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSVidGraphSegment_Build_Proxy( 
    IMSVidGraphSegment * This);


void __RPC_STUB IMSVidGraphSegment_Build_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSVidGraphSegment_PreRun_Proxy( 
    IMSVidGraphSegment * This);


void __RPC_STUB IMSVidGraphSegment_PreRun_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSVidGraphSegment_PostRun_Proxy( 
    IMSVidGraphSegment * This);


void __RPC_STUB IMSVidGraphSegment_PostRun_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSVidGraphSegment_PreStop_Proxy( 
    IMSVidGraphSegment * This);


void __RPC_STUB IMSVidGraphSegment_PreStop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSVidGraphSegment_PostStop_Proxy( 
    IMSVidGraphSegment * This);


void __RPC_STUB IMSVidGraphSegment_PostStop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSVidGraphSegment_OnEventNotify_Proxy( 
    IMSVidGraphSegment * This,
    LONG lEventCode,
    LONG_PTR lEventParm1,
    LONG_PTR lEventParm2);


void __RPC_STUB IMSVidGraphSegment_OnEventNotify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSVidGraphSegment_Decompose_Proxy( 
    IMSVidGraphSegment * This);


void __RPC_STUB IMSVidGraphSegment_Decompose_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSVidGraphSegment_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_segment_0465 */
/* [local] */ 


enum __MIDL___MIDL_itf_segment_0465_0001
    {	MSVIDCTL_LEFT_BUTTON	= 0x1,
	MSVIDCTL_RIGHT_BUTTON	= 0x2,
	MSVIDCTL_MIDDLE_BUTTON	= 0x4,
	MSVIDCTL_X_BUTTON1	= 0x8,
	MSVIDCTL_X_BUTTON2	= 0x10,
	MSVIDCTL_SHIFT	= 0x1,
	MSVIDCTL_CTRL	= 0x2,
	MSVIDCTL_ALT	= 0x4
    } ;


extern RPC_IF_HANDLE __MIDL_itf_segment_0465_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_segment_0465_v0_0_s_ifspec;

#ifndef __IMSVidGraphSegmentUserInput_INTERFACE_DEFINED__
#define __IMSVidGraphSegmentUserInput_INTERFACE_DEFINED__

/* interface IMSVidGraphSegmentUserInput */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IMSVidGraphSegmentUserInput;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("301C060E-20D9-4587-9B03-F82ED9A9943C")
    IMSVidGraphSegmentUserInput : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Click( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DblClick( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE KeyDown( 
            short *KeyCode,
            short ShiftState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE KeyPress( 
            short *KeyAscii) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE KeyUp( 
            short *KeyCode,
            short ShiftState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MouseDown( 
            short ButtonState,
            short ShiftState,
            /* external definition not present */ OLE_XPOS_PIXELS x,
            /* external definition not present */ OLE_YPOS_PIXELS y) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MouseMove( 
            short ButtonState,
            short ShiftState,
            /* external definition not present */ OLE_XPOS_PIXELS x,
            /* external definition not present */ OLE_YPOS_PIXELS y) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MouseUp( 
            short ButtonState,
            short ShiftState,
            /* external definition not present */ OLE_XPOS_PIXELS x,
            /* external definition not present */ OLE_YPOS_PIXELS y) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSVidGraphSegmentUserInputVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSVidGraphSegmentUserInput * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSVidGraphSegmentUserInput * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSVidGraphSegmentUserInput * This);
        
        HRESULT ( STDMETHODCALLTYPE *Click )( 
            IMSVidGraphSegmentUserInput * This);
        
        HRESULT ( STDMETHODCALLTYPE *DblClick )( 
            IMSVidGraphSegmentUserInput * This);
        
        HRESULT ( STDMETHODCALLTYPE *KeyDown )( 
            IMSVidGraphSegmentUserInput * This,
            short *KeyCode,
            short ShiftState);
        
        HRESULT ( STDMETHODCALLTYPE *KeyPress )( 
            IMSVidGraphSegmentUserInput * This,
            short *KeyAscii);
        
        HRESULT ( STDMETHODCALLTYPE *KeyUp )( 
            IMSVidGraphSegmentUserInput * This,
            short *KeyCode,
            short ShiftState);
        
        HRESULT ( STDMETHODCALLTYPE *MouseDown )( 
            IMSVidGraphSegmentUserInput * This,
            short ButtonState,
            short ShiftState,
            /* external definition not present */ OLE_XPOS_PIXELS x,
            /* external definition not present */ OLE_YPOS_PIXELS y);
        
        HRESULT ( STDMETHODCALLTYPE *MouseMove )( 
            IMSVidGraphSegmentUserInput * This,
            short ButtonState,
            short ShiftState,
            /* external definition not present */ OLE_XPOS_PIXELS x,
            /* external definition not present */ OLE_YPOS_PIXELS y);
        
        HRESULT ( STDMETHODCALLTYPE *MouseUp )( 
            IMSVidGraphSegmentUserInput * This,
            short ButtonState,
            short ShiftState,
            /* external definition not present */ OLE_XPOS_PIXELS x,
            /* external definition not present */ OLE_YPOS_PIXELS y);
        
        END_INTERFACE
    } IMSVidGraphSegmentUserInputVtbl;

    interface IMSVidGraphSegmentUserInput
    {
        CONST_VTBL struct IMSVidGraphSegmentUserInputVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSVidGraphSegmentUserInput_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSVidGraphSegmentUserInput_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSVidGraphSegmentUserInput_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSVidGraphSegmentUserInput_Click(This)	\
    (This)->lpVtbl -> Click(This)

#define IMSVidGraphSegmentUserInput_DblClick(This)	\
    (This)->lpVtbl -> DblClick(This)

#define IMSVidGraphSegmentUserInput_KeyDown(This,KeyCode,ShiftState)	\
    (This)->lpVtbl -> KeyDown(This,KeyCode,ShiftState)

#define IMSVidGraphSegmentUserInput_KeyPress(This,KeyAscii)	\
    (This)->lpVtbl -> KeyPress(This,KeyAscii)

#define IMSVidGraphSegmentUserInput_KeyUp(This,KeyCode,ShiftState)	\
    (This)->lpVtbl -> KeyUp(This,KeyCode,ShiftState)

#define IMSVidGraphSegmentUserInput_MouseDown(This,ButtonState,ShiftState,x,y)	\
    (This)->lpVtbl -> MouseDown(This,ButtonState,ShiftState,x,y)

#define IMSVidGraphSegmentUserInput_MouseMove(This,ButtonState,ShiftState,x,y)	\
    (This)->lpVtbl -> MouseMove(This,ButtonState,ShiftState,x,y)

#define IMSVidGraphSegmentUserInput_MouseUp(This,ButtonState,ShiftState,x,y)	\
    (This)->lpVtbl -> MouseUp(This,ButtonState,ShiftState,x,y)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMSVidGraphSegmentUserInput_Click_Proxy( 
    IMSVidGraphSegmentUserInput * This);


void __RPC_STUB IMSVidGraphSegmentUserInput_Click_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSVidGraphSegmentUserInput_DblClick_Proxy( 
    IMSVidGraphSegmentUserInput * This);


void __RPC_STUB IMSVidGraphSegmentUserInput_DblClick_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSVidGraphSegmentUserInput_KeyDown_Proxy( 
    IMSVidGraphSegmentUserInput * This,
    short *KeyCode,
    short ShiftState);


void __RPC_STUB IMSVidGraphSegmentUserInput_KeyDown_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSVidGraphSegmentUserInput_KeyPress_Proxy( 
    IMSVidGraphSegmentUserInput * This,
    short *KeyAscii);


void __RPC_STUB IMSVidGraphSegmentUserInput_KeyPress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSVidGraphSegmentUserInput_KeyUp_Proxy( 
    IMSVidGraphSegmentUserInput * This,
    short *KeyCode,
    short ShiftState);


void __RPC_STUB IMSVidGraphSegmentUserInput_KeyUp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSVidGraphSegmentUserInput_MouseDown_Proxy( 
    IMSVidGraphSegmentUserInput * This,
    short ButtonState,
    short ShiftState,
    /* external definition not present */ OLE_XPOS_PIXELS x,
    /* external definition not present */ OLE_YPOS_PIXELS y);


void __RPC_STUB IMSVidGraphSegmentUserInput_MouseDown_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSVidGraphSegmentUserInput_MouseMove_Proxy( 
    IMSVidGraphSegmentUserInput * This,
    short ButtonState,
    short ShiftState,
    /* external definition not present */ OLE_XPOS_PIXELS x,
    /* external definition not present */ OLE_YPOS_PIXELS y);


void __RPC_STUB IMSVidGraphSegmentUserInput_MouseMove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSVidGraphSegmentUserInput_MouseUp_Proxy( 
    IMSVidGraphSegmentUserInput * This,
    short ButtonState,
    short ShiftState,
    /* external definition not present */ OLE_XPOS_PIXELS x,
    /* external definition not present */ OLE_YPOS_PIXELS y);


void __RPC_STUB IMSVidGraphSegmentUserInput_MouseUp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSVidGraphSegmentUserInput_INTERFACE_DEFINED__ */


#ifndef __IMSVidCompositionSegment_INTERFACE_DEFINED__
#define __IMSVidCompositionSegment_INTERFACE_DEFINED__

/* interface IMSVidCompositionSegment */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IMSVidCompositionSegment;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1C15D483-911D-11d2-B632-00C04F79498E")
    IMSVidCompositionSegment : public IMSVidGraphSegment
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Compose( 
            /* [in] */ IMSVidGraphSegment *upstream,
            /* [in] */ IMSVidGraphSegment *downstream) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Up( 
            /* [out] */ IMSVidGraphSegment **upstream) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Down( 
            /* [out] */ IMSVidGraphSegment **downstream) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSVidCompositionSegmentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSVidCompositionSegment * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSVidCompositionSegment * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSVidCompositionSegment * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassID )( 
            IMSVidCompositionSegment * This,
            /* [out] */ CLSID *pClassID);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Init )( 
            IMSVidCompositionSegment * This,
            /* [retval][out] */ IUnknown **pInit);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Init )( 
            IMSVidCompositionSegment * This,
            /* [in] */ IUnknown *pInit);
        
        HRESULT ( STDMETHODCALLTYPE *EnumFilters )( 
            IMSVidCompositionSegment * This,
            /* [out] */ IEnumFilters **pNewEnum);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Container )( 
            IMSVidCompositionSegment * This,
            /* [retval][out] */ IMSVidGraphSegmentContainer **ppCtl);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Container )( 
            IMSVidCompositionSegment * This,
            /* [in] */ IMSVidGraphSegmentContainer *pCtl);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Type )( 
            IMSVidCompositionSegment * This,
            /* [retval][out] */ MSVidSegmentType *pType);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Category )( 
            IMSVidCompositionSegment * This,
            /* [retval][out] */ GUID *pGuid);
        
        HRESULT ( STDMETHODCALLTYPE *Build )( 
            IMSVidCompositionSegment * This);
        
        HRESULT ( STDMETHODCALLTYPE *PreRun )( 
            IMSVidCompositionSegment * This);
        
        HRESULT ( STDMETHODCALLTYPE *PostRun )( 
            IMSVidCompositionSegment * This);
        
        HRESULT ( STDMETHODCALLTYPE *PreStop )( 
            IMSVidCompositionSegment * This);
        
        HRESULT ( STDMETHODCALLTYPE *PostStop )( 
            IMSVidCompositionSegment * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnEventNotify )( 
            IMSVidCompositionSegment * This,
            LONG lEventCode,
            LONG_PTR lEventParm1,
            LONG_PTR lEventParm2);
        
        HRESULT ( STDMETHODCALLTYPE *Decompose )( 
            IMSVidCompositionSegment * This);
        
        HRESULT ( STDMETHODCALLTYPE *Compose )( 
            IMSVidCompositionSegment * This,
            /* [in] */ IMSVidGraphSegment *upstream,
            /* [in] */ IMSVidGraphSegment *downstream);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Up )( 
            IMSVidCompositionSegment * This,
            /* [out] */ IMSVidGraphSegment **upstream);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Down )( 
            IMSVidCompositionSegment * This,
            /* [out] */ IMSVidGraphSegment **downstream);
        
        END_INTERFACE
    } IMSVidCompositionSegmentVtbl;

    interface IMSVidCompositionSegment
    {
        CONST_VTBL struct IMSVidCompositionSegmentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSVidCompositionSegment_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSVidCompositionSegment_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSVidCompositionSegment_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSVidCompositionSegment_GetClassID(This,pClassID)	\
    (This)->lpVtbl -> GetClassID(This,pClassID)


#define IMSVidCompositionSegment_get_Init(This,pInit)	\
    (This)->lpVtbl -> get_Init(This,pInit)

#define IMSVidCompositionSegment_put_Init(This,pInit)	\
    (This)->lpVtbl -> put_Init(This,pInit)

#define IMSVidCompositionSegment_EnumFilters(This,pNewEnum)	\
    (This)->lpVtbl -> EnumFilters(This,pNewEnum)

#define IMSVidCompositionSegment_get_Container(This,ppCtl)	\
    (This)->lpVtbl -> get_Container(This,ppCtl)

#define IMSVidCompositionSegment_put_Container(This,pCtl)	\
    (This)->lpVtbl -> put_Container(This,pCtl)

#define IMSVidCompositionSegment_get_Type(This,pType)	\
    (This)->lpVtbl -> get_Type(This,pType)

#define IMSVidCompositionSegment_get_Category(This,pGuid)	\
    (This)->lpVtbl -> get_Category(This,pGuid)

#define IMSVidCompositionSegment_Build(This)	\
    (This)->lpVtbl -> Build(This)

#define IMSVidCompositionSegment_PreRun(This)	\
    (This)->lpVtbl -> PreRun(This)

#define IMSVidCompositionSegment_PostRun(This)	\
    (This)->lpVtbl -> PostRun(This)

#define IMSVidCompositionSegment_PreStop(This)	\
    (This)->lpVtbl -> PreStop(This)

#define IMSVidCompositionSegment_PostStop(This)	\
    (This)->lpVtbl -> PostStop(This)

#define IMSVidCompositionSegment_OnEventNotify(This,lEventCode,lEventParm1,lEventParm2)	\
    (This)->lpVtbl -> OnEventNotify(This,lEventCode,lEventParm1,lEventParm2)

#define IMSVidCompositionSegment_Decompose(This)	\
    (This)->lpVtbl -> Decompose(This)


#define IMSVidCompositionSegment_Compose(This,upstream,downstream)	\
    (This)->lpVtbl -> Compose(This,upstream,downstream)

#define IMSVidCompositionSegment_get_Up(This,upstream)	\
    (This)->lpVtbl -> get_Up(This,upstream)

#define IMSVidCompositionSegment_get_Down(This,downstream)	\
    (This)->lpVtbl -> get_Down(This,downstream)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMSVidCompositionSegment_Compose_Proxy( 
    IMSVidCompositionSegment * This,
    /* [in] */ IMSVidGraphSegment *upstream,
    /* [in] */ IMSVidGraphSegment *downstream);


void __RPC_STUB IMSVidCompositionSegment_Compose_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMSVidCompositionSegment_get_Up_Proxy( 
    IMSVidCompositionSegment * This,
    /* [out] */ IMSVidGraphSegment **upstream);


void __RPC_STUB IMSVidCompositionSegment_get_Up_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMSVidCompositionSegment_get_Down_Proxy( 
    IMSVidCompositionSegment * This,
    /* [out] */ IMSVidGraphSegment **downstream);


void __RPC_STUB IMSVidCompositionSegment_get_Down_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSVidCompositionSegment_INTERFACE_DEFINED__ */


#ifndef __IEnumMSVidGraphSegment_INTERFACE_DEFINED__
#define __IEnumMSVidGraphSegment_INTERFACE_DEFINED__

/* interface IEnumMSVidGraphSegment */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEnumMSVidGraphSegment;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3DD2903E-E0AA-11d2-B63A-00C04F79498E")
    IEnumMSVidGraphSegment : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ IMSVidGraphSegment **rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumMSVidGraphSegment **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumMSVidGraphSegmentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumMSVidGraphSegment * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumMSVidGraphSegment * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumMSVidGraphSegment * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumMSVidGraphSegment * This,
            /* [in] */ ULONG celt,
            /* [out] */ IMSVidGraphSegment **rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumMSVidGraphSegment * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumMSVidGraphSegment * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumMSVidGraphSegment * This,
            /* [out] */ IEnumMSVidGraphSegment **ppenum);
        
        END_INTERFACE
    } IEnumMSVidGraphSegmentVtbl;

    interface IEnumMSVidGraphSegment
    {
        CONST_VTBL struct IEnumMSVidGraphSegmentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumMSVidGraphSegment_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumMSVidGraphSegment_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumMSVidGraphSegment_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumMSVidGraphSegment_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumMSVidGraphSegment_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumMSVidGraphSegment_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumMSVidGraphSegment_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumMSVidGraphSegment_Next_Proxy( 
    IEnumMSVidGraphSegment * This,
    /* [in] */ ULONG celt,
    /* [out] */ IMSVidGraphSegment **rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IEnumMSVidGraphSegment_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumMSVidGraphSegment_Skip_Proxy( 
    IEnumMSVidGraphSegment * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumMSVidGraphSegment_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumMSVidGraphSegment_Reset_Proxy( 
    IEnumMSVidGraphSegment * This);


void __RPC_STUB IEnumMSVidGraphSegment_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumMSVidGraphSegment_Clone_Proxy( 
    IEnumMSVidGraphSegment * This,
    /* [out] */ IEnumMSVidGraphSegment **ppenum);


void __RPC_STUB IEnumMSVidGraphSegment_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumMSVidGraphSegment_INTERFACE_DEFINED__ */


#ifndef __IMSVidVRGraphSegment_INTERFACE_DEFINED__
#define __IMSVidVRGraphSegment_INTERFACE_DEFINED__

/* interface IMSVidVRGraphSegment */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IMSVidVRGraphSegment;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DD47DE3F-9874-4f7b-8B22-7CB2688461E7")
    IMSVidVRGraphSegment : public IMSVidGraphSegment
    {
    public:
        virtual /* [propput][restricted][hidden] */ HRESULT STDMETHODCALLTYPE put__VMRendererMode( 
            /* [in] */ LONG dwMode) = 0;
        
        virtual /* [propput][restricted][hidden] */ HRESULT STDMETHODCALLTYPE put_Owner( 
            /* [in] */ HWND Window) = 0;
        
        virtual /* [propget][restricted][hidden] */ HRESULT STDMETHODCALLTYPE get_Owner( 
            /* [retval][out] */ HWND *Window) = 0;
        
        virtual /* [propget][restricted][hidden] */ HRESULT STDMETHODCALLTYPE get_UseOverlay( 
            /* [retval][out] */ VARIANT_BOOL *UseOverlayVal) = 0;
        
        virtual /* [propput][restricted][hidden] */ HRESULT STDMETHODCALLTYPE put_UseOverlay( 
            /* [in] */ VARIANT_BOOL UseOverlayVal) = 0;
        
        virtual /* [propget][restricted][hidden] */ HRESULT STDMETHODCALLTYPE get_Visible( 
            /* [retval][out] */ VARIANT_BOOL *Visible) = 0;
        
        virtual /* [propput][restricted][hidden] */ HRESULT STDMETHODCALLTYPE put_Visible( 
            /* [in] */ VARIANT_BOOL Visible) = 0;
        
        virtual /* [restricted][hidden][propget] */ HRESULT STDMETHODCALLTYPE get_ColorKey( 
            /* [retval][out] */ OLE_COLOR *ColorKey) = 0;
        
        virtual /* [restricted][hidden][propput] */ HRESULT STDMETHODCALLTYPE put_ColorKey( 
            /* [in] */ OLE_COLOR ColorKey) = 0;
        
        virtual /* [restricted][hidden][propget] */ HRESULT STDMETHODCALLTYPE get_Source( 
            /* [retval][out] */ LPRECT r) = 0;
        
        virtual /* [restricted][hidden][propput] */ HRESULT STDMETHODCALLTYPE put_Source( 
            /* [in] */ RECT r) = 0;
        
        virtual /* [restricted][hidden][propget] */ HRESULT STDMETHODCALLTYPE get_Destination( 
            /* [retval][out] */ LPRECT r) = 0;
        
        virtual /* [restricted][hidden][propput] */ HRESULT STDMETHODCALLTYPE put_Destination( 
            /* [in] */ RECT r) = 0;
        
        virtual /* [restricted][hidden][propget] */ HRESULT STDMETHODCALLTYPE get_NativeSize( 
            /* [out] */ LPSIZE sizeval,
            /* [out] */ LPSIZE aspectratio) = 0;
        
        virtual /* [restricted][hidden][propget] */ HRESULT STDMETHODCALLTYPE get_BorderColor( 
            /* [retval][out] */ OLE_COLOR *color) = 0;
        
        virtual /* [restricted][hidden][propput] */ HRESULT STDMETHODCALLTYPE put_BorderColor( 
            /* [in] */ OLE_COLOR color) = 0;
        
        virtual /* [restricted][hidden][propget] */ HRESULT STDMETHODCALLTYPE get_MaintainAspectRatio( 
            /* [retval][out] */ VARIANT_BOOL *fMaintain) = 0;
        
        virtual /* [restricted][hidden][propput] */ HRESULT STDMETHODCALLTYPE put_MaintainAspectRatio( 
            /* [in] */ VARIANT_BOOL fMaintain) = 0;
        
        virtual /* [restricted][hidden] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
        virtual /* [restricted][hidden] */ HRESULT STDMETHODCALLTYPE DisplayChange( void) = 0;
        
        virtual /* [restricted][hidden] */ HRESULT STDMETHODCALLTYPE RePaint( 
            /* [in] */ HDC hdc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSVidVRGraphSegmentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSVidVRGraphSegment * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSVidVRGraphSegment * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSVidVRGraphSegment * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassID )( 
            IMSVidVRGraphSegment * This,
            /* [out] */ CLSID *pClassID);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Init )( 
            IMSVidVRGraphSegment * This,
            /* [retval][out] */ IUnknown **pInit);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Init )( 
            IMSVidVRGraphSegment * This,
            /* [in] */ IUnknown *pInit);
        
        HRESULT ( STDMETHODCALLTYPE *EnumFilters )( 
            IMSVidVRGraphSegment * This,
            /* [out] */ IEnumFilters **pNewEnum);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Container )( 
            IMSVidVRGraphSegment * This,
            /* [retval][out] */ IMSVidGraphSegmentContainer **ppCtl);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Container )( 
            IMSVidVRGraphSegment * This,
            /* [in] */ IMSVidGraphSegmentContainer *pCtl);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Type )( 
            IMSVidVRGraphSegment * This,
            /* [retval][out] */ MSVidSegmentType *pType);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Category )( 
            IMSVidVRGraphSegment * This,
            /* [retval][out] */ GUID *pGuid);
        
        HRESULT ( STDMETHODCALLTYPE *Build )( 
            IMSVidVRGraphSegment * This);
        
        HRESULT ( STDMETHODCALLTYPE *PreRun )( 
            IMSVidVRGraphSegment * This);
        
        HRESULT ( STDMETHODCALLTYPE *PostRun )( 
            IMSVidVRGraphSegment * This);
        
        HRESULT ( STDMETHODCALLTYPE *PreStop )( 
            IMSVidVRGraphSegment * This);
        
        HRESULT ( STDMETHODCALLTYPE *PostStop )( 
            IMSVidVRGraphSegment * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnEventNotify )( 
            IMSVidVRGraphSegment * This,
            LONG lEventCode,
            LONG_PTR lEventParm1,
            LONG_PTR lEventParm2);
        
        HRESULT ( STDMETHODCALLTYPE *Decompose )( 
            IMSVidVRGraphSegment * This);
        
        /* [propput][restricted][hidden] */ HRESULT ( STDMETHODCALLTYPE *put__VMRendererMode )( 
            IMSVidVRGraphSegment * This,
            /* [in] */ LONG dwMode);
        
        /* [propput][restricted][hidden] */ HRESULT ( STDMETHODCALLTYPE *put_Owner )( 
            IMSVidVRGraphSegment * This,
            /* [in] */ HWND Window);
        
        /* [propget][restricted][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_Owner )( 
            IMSVidVRGraphSegment * This,
            /* [retval][out] */ HWND *Window);
        
        /* [propget][restricted][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_UseOverlay )( 
            IMSVidVRGraphSegment * This,
            /* [retval][out] */ VARIANT_BOOL *UseOverlayVal);
        
        /* [propput][restricted][hidden] */ HRESULT ( STDMETHODCALLTYPE *put_UseOverlay )( 
            IMSVidVRGraphSegment * This,
            /* [in] */ VARIANT_BOOL UseOverlayVal);
        
        /* [propget][restricted][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_Visible )( 
            IMSVidVRGraphSegment * This,
            /* [retval][out] */ VARIANT_BOOL *Visible);
        
        /* [propput][restricted][hidden] */ HRESULT ( STDMETHODCALLTYPE *put_Visible )( 
            IMSVidVRGraphSegment * This,
            /* [in] */ VARIANT_BOOL Visible);
        
        /* [restricted][hidden][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ColorKey )( 
            IMSVidVRGraphSegment * This,
            /* [retval][out] */ OLE_COLOR *ColorKey);
        
        /* [restricted][hidden][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ColorKey )( 
            IMSVidVRGraphSegment * This,
            /* [in] */ OLE_COLOR ColorKey);
        
        /* [restricted][hidden][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Source )( 
            IMSVidVRGraphSegment * This,
            /* [retval][out] */ LPRECT r);
        
        /* [restricted][hidden][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Source )( 
            IMSVidVRGraphSegment * This,
            /* [in] */ RECT r);
        
        /* [restricted][hidden][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Destination )( 
            IMSVidVRGraphSegment * This,
            /* [retval][out] */ LPRECT r);
        
        /* [restricted][hidden][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Destination )( 
            IMSVidVRGraphSegment * This,
            /* [in] */ RECT r);
        
        /* [restricted][hidden][propget] */ HRESULT ( STDMETHODCALLTYPE *get_NativeSize )( 
            IMSVidVRGraphSegment * This,
            /* [out] */ LPSIZE sizeval,
            /* [out] */ LPSIZE aspectratio);
        
        /* [restricted][hidden][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BorderColor )( 
            IMSVidVRGraphSegment * This,
            /* [retval][out] */ OLE_COLOR *color);
        
        /* [restricted][hidden][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BorderColor )( 
            IMSVidVRGraphSegment * This,
            /* [in] */ OLE_COLOR color);
        
        /* [restricted][hidden][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MaintainAspectRatio )( 
            IMSVidVRGraphSegment * This,
            /* [retval][out] */ VARIANT_BOOL *fMaintain);
        
        /* [restricted][hidden][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MaintainAspectRatio )( 
            IMSVidVRGraphSegment * This,
            /* [in] */ VARIANT_BOOL fMaintain);
        
        /* [restricted][hidden] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IMSVidVRGraphSegment * This);
        
        /* [restricted][hidden] */ HRESULT ( STDMETHODCALLTYPE *DisplayChange )( 
            IMSVidVRGraphSegment * This);
        
        /* [restricted][hidden] */ HRESULT ( STDMETHODCALLTYPE *RePaint )( 
            IMSVidVRGraphSegment * This,
            /* [in] */ HDC hdc);
        
        END_INTERFACE
    } IMSVidVRGraphSegmentVtbl;

    interface IMSVidVRGraphSegment
    {
        CONST_VTBL struct IMSVidVRGraphSegmentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSVidVRGraphSegment_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSVidVRGraphSegment_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSVidVRGraphSegment_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSVidVRGraphSegment_GetClassID(This,pClassID)	\
    (This)->lpVtbl -> GetClassID(This,pClassID)


#define IMSVidVRGraphSegment_get_Init(This,pInit)	\
    (This)->lpVtbl -> get_Init(This,pInit)

#define IMSVidVRGraphSegment_put_Init(This,pInit)	\
    (This)->lpVtbl -> put_Init(This,pInit)

#define IMSVidVRGraphSegment_EnumFilters(This,pNewEnum)	\
    (This)->lpVtbl -> EnumFilters(This,pNewEnum)

#define IMSVidVRGraphSegment_get_Container(This,ppCtl)	\
    (This)->lpVtbl -> get_Container(This,ppCtl)

#define IMSVidVRGraphSegment_put_Container(This,pCtl)	\
    (This)->lpVtbl -> put_Container(This,pCtl)

#define IMSVidVRGraphSegment_get_Type(This,pType)	\
    (This)->lpVtbl -> get_Type(This,pType)

#define IMSVidVRGraphSegment_get_Category(This,pGuid)	\
    (This)->lpVtbl -> get_Category(This,pGuid)

#define IMSVidVRGraphSegment_Build(This)	\
    (This)->lpVtbl -> Build(This)

#define IMSVidVRGraphSegment_PreRun(This)	\
    (This)->lpVtbl -> PreRun(This)

#define IMSVidVRGraphSegment_PostRun(This)	\
    (This)->lpVtbl -> PostRun(This)

#define IMSVidVRGraphSegment_PreStop(This)	\
    (This)->lpVtbl -> PreStop(This)

#define IMSVidVRGraphSegment_PostStop(This)	\
    (This)->lpVtbl -> PostStop(This)

#define IMSVidVRGraphSegment_OnEventNotify(This,lEventCode,lEventParm1,lEventParm2)	\
    (This)->lpVtbl -> OnEventNotify(This,lEventCode,lEventParm1,lEventParm2)

#define IMSVidVRGraphSegment_Decompose(This)	\
    (This)->lpVtbl -> Decompose(This)


#define IMSVidVRGraphSegment_put__VMRendererMode(This,dwMode)	\
    (This)->lpVtbl -> put__VMRendererMode(This,dwMode)

#define IMSVidVRGraphSegment_put_Owner(This,Window)	\
    (This)->lpVtbl -> put_Owner(This,Window)

#define IMSVidVRGraphSegment_get_Owner(This,Window)	\
    (This)->lpVtbl -> get_Owner(This,Window)

#define IMSVidVRGraphSegment_get_UseOverlay(This,UseOverlayVal)	\
    (This)->lpVtbl -> get_UseOverlay(This,UseOverlayVal)

#define IMSVidVRGraphSegment_put_UseOverlay(This,UseOverlayVal)	\
    (This)->lpVtbl -> put_UseOverlay(This,UseOverlayVal)

#define IMSVidVRGraphSegment_get_Visible(This,Visible)	\
    (This)->lpVtbl -> get_Visible(This,Visible)

#define IMSVidVRGraphSegment_put_Visible(This,Visible)	\
    (This)->lpVtbl -> put_Visible(This,Visible)

#define IMSVidVRGraphSegment_get_ColorKey(This,ColorKey)	\
    (This)->lpVtbl -> get_ColorKey(This,ColorKey)

#define IMSVidVRGraphSegment_put_ColorKey(This,ColorKey)	\
    (This)->lpVtbl -> put_ColorKey(This,ColorKey)

#define IMSVidVRGraphSegment_get_Source(This,r)	\
    (This)->lpVtbl -> get_Source(This,r)

#define IMSVidVRGraphSegment_put_Source(This,r)	\
    (This)->lpVtbl -> put_Source(This,r)

#define IMSVidVRGraphSegment_get_Destination(This,r)	\
    (This)->lpVtbl -> get_Destination(This,r)

#define IMSVidVRGraphSegment_put_Destination(This,r)	\
    (This)->lpVtbl -> put_Destination(This,r)

#define IMSVidVRGraphSegment_get_NativeSize(This,sizeval,aspectratio)	\
    (This)->lpVtbl -> get_NativeSize(This,sizeval,aspectratio)

#define IMSVidVRGraphSegment_get_BorderColor(This,color)	\
    (This)->lpVtbl -> get_BorderColor(This,color)

#define IMSVidVRGraphSegment_put_BorderColor(This,color)	\
    (This)->lpVtbl -> put_BorderColor(This,color)

#define IMSVidVRGraphSegment_get_MaintainAspectRatio(This,fMaintain)	\
    (This)->lpVtbl -> get_MaintainAspectRatio(This,fMaintain)

#define IMSVidVRGraphSegment_put_MaintainAspectRatio(This,fMaintain)	\
    (This)->lpVtbl -> put_MaintainAspectRatio(This,fMaintain)

#define IMSVidVRGraphSegment_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define IMSVidVRGraphSegment_DisplayChange(This)	\
    (This)->lpVtbl -> DisplayChange(This)

#define IMSVidVRGraphSegment_RePaint(This,hdc)	\
    (This)->lpVtbl -> RePaint(This,hdc)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propput][restricted][hidden] */ HRESULT STDMETHODCALLTYPE IMSVidVRGraphSegment_put__VMRendererMode_Proxy( 
    IMSVidVRGraphSegment * This,
    /* [in] */ LONG dwMode);


void __RPC_STUB IMSVidVRGraphSegment_put__VMRendererMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][restricted][hidden] */ HRESULT STDMETHODCALLTYPE IMSVidVRGraphSegment_put_Owner_Proxy( 
    IMSVidVRGraphSegment * This,
    /* [in] */ HWND Window);


void __RPC_STUB IMSVidVRGraphSegment_put_Owner_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][restricted][hidden] */ HRESULT STDMETHODCALLTYPE IMSVidVRGraphSegment_get_Owner_Proxy( 
    IMSVidVRGraphSegment * This,
    /* [retval][out] */ HWND *Window);


void __RPC_STUB IMSVidVRGraphSegment_get_Owner_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][restricted][hidden] */ HRESULT STDMETHODCALLTYPE IMSVidVRGraphSegment_get_UseOverlay_Proxy( 
    IMSVidVRGraphSegment * This,
    /* [retval][out] */ VARIANT_BOOL *UseOverlayVal);


void __RPC_STUB IMSVidVRGraphSegment_get_UseOverlay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][restricted][hidden] */ HRESULT STDMETHODCALLTYPE IMSVidVRGraphSegment_put_UseOverlay_Proxy( 
    IMSVidVRGraphSegment * This,
    /* [in] */ VARIANT_BOOL UseOverlayVal);


void __RPC_STUB IMSVidVRGraphSegment_put_UseOverlay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][restricted][hidden] */ HRESULT STDMETHODCALLTYPE IMSVidVRGraphSegment_get_Visible_Proxy( 
    IMSVidVRGraphSegment * This,
    /* [retval][out] */ VARIANT_BOOL *Visible);


void __RPC_STUB IMSVidVRGraphSegment_get_Visible_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][restricted][hidden] */ HRESULT STDMETHODCALLTYPE IMSVidVRGraphSegment_put_Visible_Proxy( 
    IMSVidVRGraphSegment * This,
    /* [in] */ VARIANT_BOOL Visible);


void __RPC_STUB IMSVidVRGraphSegment_put_Visible_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][propget] */ HRESULT STDMETHODCALLTYPE IMSVidVRGraphSegment_get_ColorKey_Proxy( 
    IMSVidVRGraphSegment * This,
    /* [retval][out] */ OLE_COLOR *ColorKey);


void __RPC_STUB IMSVidVRGraphSegment_get_ColorKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][propput] */ HRESULT STDMETHODCALLTYPE IMSVidVRGraphSegment_put_ColorKey_Proxy( 
    IMSVidVRGraphSegment * This,
    /* [in] */ OLE_COLOR ColorKey);


void __RPC_STUB IMSVidVRGraphSegment_put_ColorKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][propget] */ HRESULT STDMETHODCALLTYPE IMSVidVRGraphSegment_get_Source_Proxy( 
    IMSVidVRGraphSegment * This,
    /* [retval][out] */ LPRECT r);


void __RPC_STUB IMSVidVRGraphSegment_get_Source_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][propput] */ HRESULT STDMETHODCALLTYPE IMSVidVRGraphSegment_put_Source_Proxy( 
    IMSVidVRGraphSegment * This,
    /* [in] */ RECT r);


void __RPC_STUB IMSVidVRGraphSegment_put_Source_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][propget] */ HRESULT STDMETHODCALLTYPE IMSVidVRGraphSegment_get_Destination_Proxy( 
    IMSVidVRGraphSegment * This,
    /* [retval][out] */ LPRECT r);


void __RPC_STUB IMSVidVRGraphSegment_get_Destination_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][propput] */ HRESULT STDMETHODCALLTYPE IMSVidVRGraphSegment_put_Destination_Proxy( 
    IMSVidVRGraphSegment * This,
    /* [in] */ RECT r);


void __RPC_STUB IMSVidVRGraphSegment_put_Destination_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][propget] */ HRESULT STDMETHODCALLTYPE IMSVidVRGraphSegment_get_NativeSize_Proxy( 
    IMSVidVRGraphSegment * This,
    /* [out] */ LPSIZE sizeval,
    /* [out] */ LPSIZE aspectratio);


void __RPC_STUB IMSVidVRGraphSegment_get_NativeSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][propget] */ HRESULT STDMETHODCALLTYPE IMSVidVRGraphSegment_get_BorderColor_Proxy( 
    IMSVidVRGraphSegment * This,
    /* [retval][out] */ OLE_COLOR *color);


void __RPC_STUB IMSVidVRGraphSegment_get_BorderColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][propput] */ HRESULT STDMETHODCALLTYPE IMSVidVRGraphSegment_put_BorderColor_Proxy( 
    IMSVidVRGraphSegment * This,
    /* [in] */ OLE_COLOR color);


void __RPC_STUB IMSVidVRGraphSegment_put_BorderColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][propget] */ HRESULT STDMETHODCALLTYPE IMSVidVRGraphSegment_get_MaintainAspectRatio_Proxy( 
    IMSVidVRGraphSegment * This,
    /* [retval][out] */ VARIANT_BOOL *fMaintain);


void __RPC_STUB IMSVidVRGraphSegment_get_MaintainAspectRatio_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][propput] */ HRESULT STDMETHODCALLTYPE IMSVidVRGraphSegment_put_MaintainAspectRatio_Proxy( 
    IMSVidVRGraphSegment * This,
    /* [in] */ VARIANT_BOOL fMaintain);


void __RPC_STUB IMSVidVRGraphSegment_put_MaintainAspectRatio_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden] */ HRESULT STDMETHODCALLTYPE IMSVidVRGraphSegment_Refresh_Proxy( 
    IMSVidVRGraphSegment * This);


void __RPC_STUB IMSVidVRGraphSegment_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden] */ HRESULT STDMETHODCALLTYPE IMSVidVRGraphSegment_DisplayChange_Proxy( 
    IMSVidVRGraphSegment * This);


void __RPC_STUB IMSVidVRGraphSegment_DisplayChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden] */ HRESULT STDMETHODCALLTYPE IMSVidVRGraphSegment_RePaint_Proxy( 
    IMSVidVRGraphSegment * This,
    /* [in] */ HDC hdc);


void __RPC_STUB IMSVidVRGraphSegment_RePaint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSVidVRGraphSegment_INTERFACE_DEFINED__ */


#ifndef __IMSVidDevice_INTERFACE_DEFINED__
#define __IMSVidDevice_INTERFACE_DEFINED__

/* interface IMSVidDevice */
/* [unique][helpstring][uuid][oleautomation][dual][object] */ 


EXTERN_C const IID IID_IMSVidDevice;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1C15D47C-911D-11d2-B632-00C04F79498E")
    IMSVidDevice : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR *Name) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ long *Status) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Power( 
            /* [in] */ VARIANT_BOOL Power) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Power( 
            /* [out][retval] */ VARIANT_BOOL *Power) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Category( 
            /* [retval][out] */ BSTR *Guid) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ClassID( 
            /* [retval][out] */ BSTR *Clsid) = 0;
        
        virtual /* [restricted][hidden][id][propget] */ HRESULT STDMETHODCALLTYPE get__Category( 
            /* [retval][out] */ GUID *Guid) = 0;
        
        virtual /* [restricted][hidden][id][propget] */ HRESULT STDMETHODCALLTYPE get__ClassID( 
            /* [retval][out] */ GUID *Clsid) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsEqualDevice( 
            /* [in] */ IMSVidDevice *Device,
            /* [retval][out] */ VARIANT_BOOL *IsEqual) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSVidDeviceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSVidDevice * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSVidDevice * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSVidDevice * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSVidDevice * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSVidDevice * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSVidDevice * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSVidDevice * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IMSVidDevice * This,
            /* [retval][out] */ BSTR *Name);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            IMSVidDevice * This,
            /* [retval][out] */ long *Status);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Power )( 
            IMSVidDevice * This,
            /* [in] */ VARIANT_BOOL Power);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Power )( 
            IMSVidDevice * This,
            /* [out][retval] */ VARIANT_BOOL *Power);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Category )( 
            IMSVidDevice * This,
            /* [retval][out] */ BSTR *Guid);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClassID )( 
            IMSVidDevice * This,
            /* [retval][out] */ BSTR *Clsid);
        
        /* [restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__Category )( 
            IMSVidDevice * This,
            /* [retval][out] */ GUID *Guid);
        
        /* [restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__ClassID )( 
            IMSVidDevice * This,
            /* [retval][out] */ GUID *Clsid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsEqualDevice )( 
            IMSVidDevice * This,
            /* [in] */ IMSVidDevice *Device,
            /* [retval][out] */ VARIANT_BOOL *IsEqual);
        
        END_INTERFACE
    } IMSVidDeviceVtbl;

    interface IMSVidDevice
    {
        CONST_VTBL struct IMSVidDeviceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSVidDevice_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSVidDevice_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSVidDevice_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSVidDevice_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSVidDevice_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSVidDevice_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSVidDevice_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSVidDevice_get_Name(This,Name)	\
    (This)->lpVtbl -> get_Name(This,Name)

#define IMSVidDevice_get_Status(This,Status)	\
    (This)->lpVtbl -> get_Status(This,Status)

#define IMSVidDevice_put_Power(This,Power)	\
    (This)->lpVtbl -> put_Power(This,Power)

#define IMSVidDevice_get_Power(This,Power)	\
    (This)->lpVtbl -> get_Power(This,Power)

#define IMSVidDevice_get_Category(This,Guid)	\
    (This)->lpVtbl -> get_Category(This,Guid)

#define IMSVidDevice_get_ClassID(This,Clsid)	\
    (This)->lpVtbl -> get_ClassID(This,Clsid)

#define IMSVidDevice_get__Category(This,Guid)	\
    (This)->lpVtbl -> get__Category(This,Guid)

#define IMSVidDevice_get__ClassID(This,Clsid)	\
    (This)->lpVtbl -> get__ClassID(This,Clsid)

#define IMSVidDevice_IsEqualDevice(This,Device,IsEqual)	\
    (This)->lpVtbl -> IsEqualDevice(This,Device,IsEqual)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidDevice_get_Name_Proxy( 
    IMSVidDevice * This,
    /* [retval][out] */ BSTR *Name);


void __RPC_STUB IMSVidDevice_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidDevice_get_Status_Proxy( 
    IMSVidDevice * This,
    /* [retval][out] */ long *Status);


void __RPC_STUB IMSVidDevice_get_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IMSVidDevice_put_Power_Proxy( 
    IMSVidDevice * This,
    /* [in] */ VARIANT_BOOL Power);


void __RPC_STUB IMSVidDevice_put_Power_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidDevice_get_Power_Proxy( 
    IMSVidDevice * This,
    /* [out][retval] */ VARIANT_BOOL *Power);


void __RPC_STUB IMSVidDevice_get_Power_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidDevice_get_Category_Proxy( 
    IMSVidDevice * This,
    /* [retval][out] */ BSTR *Guid);


void __RPC_STUB IMSVidDevice_get_Category_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidDevice_get_ClassID_Proxy( 
    IMSVidDevice * This,
    /* [retval][out] */ BSTR *Clsid);


void __RPC_STUB IMSVidDevice_get_ClassID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidDevice_get__Category_Proxy( 
    IMSVidDevice * This,
    /* [retval][out] */ GUID *Guid);


void __RPC_STUB IMSVidDevice_get__Category_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidDevice_get__ClassID_Proxy( 
    IMSVidDevice * This,
    /* [retval][out] */ GUID *Clsid);


void __RPC_STUB IMSVidDevice_get__ClassID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidDevice_IsEqualDevice_Proxy( 
    IMSVidDevice * This,
    /* [in] */ IMSVidDevice *Device,
    /* [retval][out] */ VARIANT_BOOL *IsEqual);


void __RPC_STUB IMSVidDevice_IsEqualDevice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSVidDevice_INTERFACE_DEFINED__ */


#ifndef __IMSVidInputDevice_INTERFACE_DEFINED__
#define __IMSVidInputDevice_INTERFACE_DEFINED__

/* interface IMSVidInputDevice */
/* [unique][helpstring][uuid][oleautomation][dual][object] */ 


EXTERN_C const IID IID_IMSVidInputDevice;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("37B0353D-A4C8-11d2-B634-00C04F79498E")
    IMSVidInputDevice : public IMSVidDevice
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE IsViewable( 
            /* [in] */ VARIANT *v,
            /* [retval][out] */ VARIANT_BOOL *pfViewable) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE View( 
            /* [in] */ VARIANT *v) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSVidInputDeviceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSVidInputDevice * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSVidInputDevice * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSVidInputDevice * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSVidInputDevice * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSVidInputDevice * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSVidInputDevice * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSVidInputDevice * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IMSVidInputDevice * This,
            /* [retval][out] */ BSTR *Name);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            IMSVidInputDevice * This,
            /* [retval][out] */ long *Status);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Power )( 
            IMSVidInputDevice * This,
            /* [in] */ VARIANT_BOOL Power);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Power )( 
            IMSVidInputDevice * This,
            /* [out][retval] */ VARIANT_BOOL *Power);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Category )( 
            IMSVidInputDevice * This,
            /* [retval][out] */ BSTR *Guid);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClassID )( 
            IMSVidInputDevice * This,
            /* [retval][out] */ BSTR *Clsid);
        
        /* [restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__Category )( 
            IMSVidInputDevice * This,
            /* [retval][out] */ GUID *Guid);
        
        /* [restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__ClassID )( 
            IMSVidInputDevice * This,
            /* [retval][out] */ GUID *Clsid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsEqualDevice )( 
            IMSVidInputDevice * This,
            /* [in] */ IMSVidDevice *Device,
            /* [retval][out] */ VARIANT_BOOL *IsEqual);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *IsViewable )( 
            IMSVidInputDevice * This,
            /* [in] */ VARIANT *v,
            /* [retval][out] */ VARIANT_BOOL *pfViewable);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *View )( 
            IMSVidInputDevice * This,
            /* [in] */ VARIANT *v);
        
        END_INTERFACE
    } IMSVidInputDeviceVtbl;

    interface IMSVidInputDevice
    {
        CONST_VTBL struct IMSVidInputDeviceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSVidInputDevice_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSVidInputDevice_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSVidInputDevice_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSVidInputDevice_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSVidInputDevice_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSVidInputDevice_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSVidInputDevice_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSVidInputDevice_get_Name(This,Name)	\
    (This)->lpVtbl -> get_Name(This,Name)

#define IMSVidInputDevice_get_Status(This,Status)	\
    (This)->lpVtbl -> get_Status(This,Status)

#define IMSVidInputDevice_put_Power(This,Power)	\
    (This)->lpVtbl -> put_Power(This,Power)

#define IMSVidInputDevice_get_Power(This,Power)	\
    (This)->lpVtbl -> get_Power(This,Power)

#define IMSVidInputDevice_get_Category(This,Guid)	\
    (This)->lpVtbl -> get_Category(This,Guid)

#define IMSVidInputDevice_get_ClassID(This,Clsid)	\
    (This)->lpVtbl -> get_ClassID(This,Clsid)

#define IMSVidInputDevice_get__Category(This,Guid)	\
    (This)->lpVtbl -> get__Category(This,Guid)

#define IMSVidInputDevice_get__ClassID(This,Clsid)	\
    (This)->lpVtbl -> get__ClassID(This,Clsid)

#define IMSVidInputDevice_IsEqualDevice(This,Device,IsEqual)	\
    (This)->lpVtbl -> IsEqualDevice(This,Device,IsEqual)


#define IMSVidInputDevice_IsViewable(This,v,pfViewable)	\
    (This)->lpVtbl -> IsViewable(This,v,pfViewable)

#define IMSVidInputDevice_View(This,v)	\
    (This)->lpVtbl -> View(This,v)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IMSVidInputDevice_IsViewable_Proxy( 
    IMSVidInputDevice * This,
    /* [in] */ VARIANT *v,
    /* [retval][out] */ VARIANT_BOOL *pfViewable);


void __RPC_STUB IMSVidInputDevice_IsViewable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IMSVidInputDevice_View_Proxy( 
    IMSVidInputDevice * This,
    /* [in] */ VARIANT *v);


void __RPC_STUB IMSVidInputDevice_View_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSVidInputDevice_INTERFACE_DEFINED__ */


#ifndef __IMSVidDeviceEvent_INTERFACE_DEFINED__
#define __IMSVidDeviceEvent_INTERFACE_DEFINED__

/* interface IMSVidDeviceEvent */
/* [unique][helpstring][uuid][oleautomation][object] */ 


EXTERN_C const IID IID_IMSVidDeviceEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1C15D480-911D-11d2-B632-00C04F79498E")
    IMSVidDeviceEvent : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE StateChange( 
            /* [in] */ IMSVidDevice *lpd,
            /* [in] */ long oldState,
            /* [in] */ long newState) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSVidDeviceEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSVidDeviceEvent * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSVidDeviceEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSVidDeviceEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSVidDeviceEvent * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSVidDeviceEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSVidDeviceEvent * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSVidDeviceEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *StateChange )( 
            IMSVidDeviceEvent * This,
            /* [in] */ IMSVidDevice *lpd,
            /* [in] */ long oldState,
            /* [in] */ long newState);
        
        END_INTERFACE
    } IMSVidDeviceEventVtbl;

    interface IMSVidDeviceEvent
    {
        CONST_VTBL struct IMSVidDeviceEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSVidDeviceEvent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSVidDeviceEvent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSVidDeviceEvent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSVidDeviceEvent_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSVidDeviceEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSVidDeviceEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSVidDeviceEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSVidDeviceEvent_StateChange(This,lpd,oldState,newState)	\
    (This)->lpVtbl -> StateChange(This,lpd,oldState,newState)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IMSVidDeviceEvent_StateChange_Proxy( 
    IMSVidDeviceEvent * This,
    /* [in] */ IMSVidDevice *lpd,
    /* [in] */ long oldState,
    /* [in] */ long newState);


void __RPC_STUB IMSVidDeviceEvent_StateChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSVidDeviceEvent_INTERFACE_DEFINED__ */


#ifndef __IMSVidInputDeviceEvent_INTERFACE_DEFINED__
#define __IMSVidInputDeviceEvent_INTERFACE_DEFINED__

/* interface IMSVidInputDeviceEvent */
/* [unique][helpstring][uuid][oleautomation][object] */ 


EXTERN_C const IID IID_IMSVidInputDeviceEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("37B0353E-A4C8-11d2-B634-00C04F79498E")
    IMSVidInputDeviceEvent : public IDispatch
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IMSVidInputDeviceEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSVidInputDeviceEvent * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSVidInputDeviceEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSVidInputDeviceEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSVidInputDeviceEvent * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSVidInputDeviceEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSVidInputDeviceEvent * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSVidInputDeviceEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } IMSVidInputDeviceEventVtbl;

    interface IMSVidInputDeviceEvent
    {
        CONST_VTBL struct IMSVidInputDeviceEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSVidInputDeviceEvent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSVidInputDeviceEvent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSVidInputDeviceEvent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSVidInputDeviceEvent_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSVidInputDeviceEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSVidInputDeviceEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSVidInputDeviceEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMSVidInputDeviceEvent_INTERFACE_DEFINED__ */


#ifndef __IMSVidVideoInputDevice_INTERFACE_DEFINED__
#define __IMSVidVideoInputDevice_INTERFACE_DEFINED__

/* interface IMSVidVideoInputDevice */
/* [unique][helpstring][uuid][oleautomation][dual][object] */ 


EXTERN_C const IID IID_IMSVidVideoInputDevice;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1C15D47F-911D-11d2-B632-00C04F79498E")
    IMSVidVideoInputDevice : public IMSVidInputDevice
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IMSVidVideoInputDeviceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSVidVideoInputDevice * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSVidVideoInputDevice * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSVidVideoInputDevice * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSVidVideoInputDevice * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSVidVideoInputDevice * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSVidVideoInputDevice * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSVidVideoInputDevice * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IMSVidVideoInputDevice * This,
            /* [retval][out] */ BSTR *Name);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            IMSVidVideoInputDevice * This,
            /* [retval][out] */ long *Status);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Power )( 
            IMSVidVideoInputDevice * This,
            /* [in] */ VARIANT_BOOL Power);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Power )( 
            IMSVidVideoInputDevice * This,
            /* [out][retval] */ VARIANT_BOOL *Power);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Category )( 
            IMSVidVideoInputDevice * This,
            /* [retval][out] */ BSTR *Guid);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClassID )( 
            IMSVidVideoInputDevice * This,
            /* [retval][out] */ BSTR *Clsid);
        
        /* [restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__Category )( 
            IMSVidVideoInputDevice * This,
            /* [retval][out] */ GUID *Guid);
        
        /* [restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__ClassID )( 
            IMSVidVideoInputDevice * This,
            /* [retval][out] */ GUID *Clsid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsEqualDevice )( 
            IMSVidVideoInputDevice * This,
            /* [in] */ IMSVidDevice *Device,
            /* [retval][out] */ VARIANT_BOOL *IsEqual);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *IsViewable )( 
            IMSVidVideoInputDevice * This,
            /* [in] */ VARIANT *v,
            /* [retval][out] */ VARIANT_BOOL *pfViewable);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *View )( 
            IMSVidVideoInputDevice * This,
            /* [in] */ VARIANT *v);
        
        END_INTERFACE
    } IMSVidVideoInputDeviceVtbl;

    interface IMSVidVideoInputDevice
    {
        CONST_VTBL struct IMSVidVideoInputDeviceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSVidVideoInputDevice_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSVidVideoInputDevice_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSVidVideoInputDevice_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSVidVideoInputDevice_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSVidVideoInputDevice_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSVidVideoInputDevice_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSVidVideoInputDevice_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSVidVideoInputDevice_get_Name(This,Name)	\
    (This)->lpVtbl -> get_Name(This,Name)

#define IMSVidVideoInputDevice_get_Status(This,Status)	\
    (This)->lpVtbl -> get_Status(This,Status)

#define IMSVidVideoInputDevice_put_Power(This,Power)	\
    (This)->lpVtbl -> put_Power(This,Power)

#define IMSVidVideoInputDevice_get_Power(This,Power)	\
    (This)->lpVtbl -> get_Power(This,Power)

#define IMSVidVideoInputDevice_get_Category(This,Guid)	\
    (This)->lpVtbl -> get_Category(This,Guid)

#define IMSVidVideoInputDevice_get_ClassID(This,Clsid)	\
    (This)->lpVtbl -> get_ClassID(This,Clsid)

#define IMSVidVideoInputDevice_get__Category(This,Guid)	\
    (This)->lpVtbl -> get__Category(This,Guid)

#define IMSVidVideoInputDevice_get__ClassID(This,Clsid)	\
    (This)->lpVtbl -> get__ClassID(This,Clsid)

#define IMSVidVideoInputDevice_IsEqualDevice(This,Device,IsEqual)	\
    (This)->lpVtbl -> IsEqualDevice(This,Device,IsEqual)


#define IMSVidVideoInputDevice_IsViewable(This,v,pfViewable)	\
    (This)->lpVtbl -> IsViewable(This,v,pfViewable)

#define IMSVidVideoInputDevice_View(This,v)	\
    (This)->lpVtbl -> View(This,v)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMSVidVideoInputDevice_INTERFACE_DEFINED__ */


#ifndef __IMSVidPlayback_INTERFACE_DEFINED__
#define __IMSVidPlayback_INTERFACE_DEFINED__

/* interface IMSVidPlayback */
/* [unique][helpstring][uuid][oleautomation][dual][object] */ 


EXTERN_C const IID IID_IMSVidPlayback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("37B03538-A4C8-11d2-B634-00C04F79498E")
    IMSVidPlayback : public IMSVidInputDevice
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EnableResetOnStop( 
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_EnableResetOnStop( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Run( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_CanStep( 
            /* [in] */ VARIANT_BOOL fBackwards,
            /* [retval][out] */ VARIANT_BOOL *pfCan) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Step( 
            /* [in] */ long lStep) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Rate( 
            /* [in] */ double plRate) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Rate( 
            /* [retval][out] */ double *plRate) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CurrentPosition( 
            /* [in] */ long lPosition) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentPosition( 
            /* [retval][out] */ long *lPosition) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PositionMode( 
            /* [in] */ PositionModeList lPositionMode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PositionMode( 
            /* [retval][out] */ PositionModeList *lPositionMode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Length( 
            /* [retval][out] */ long *lLength) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSVidPlaybackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSVidPlayback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSVidPlayback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSVidPlayback * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSVidPlayback * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSVidPlayback * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSVidPlayback * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSVidPlayback * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IMSVidPlayback * This,
            /* [retval][out] */ BSTR *Name);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            IMSVidPlayback * This,
            /* [retval][out] */ long *Status);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Power )( 
            IMSVidPlayback * This,
            /* [in] */ VARIANT_BOOL Power);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Power )( 
            IMSVidPlayback * This,
            /* [out][retval] */ VARIANT_BOOL *Power);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Category )( 
            IMSVidPlayback * This,
            /* [retval][out] */ BSTR *Guid);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClassID )( 
            IMSVidPlayback * This,
            /* [retval][out] */ BSTR *Clsid);
        
        /* [restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__Category )( 
            IMSVidPlayback * This,
            /* [retval][out] */ GUID *Guid);
        
        /* [restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__ClassID )( 
            IMSVidPlayback * This,
            /* [retval][out] */ GUID *Clsid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsEqualDevice )( 
            IMSVidPlayback * This,
            /* [in] */ IMSVidDevice *Device,
            /* [retval][out] */ VARIANT_BOOL *IsEqual);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *IsViewable )( 
            IMSVidPlayback * This,
            /* [in] */ VARIANT *v,
            /* [retval][out] */ VARIANT_BOOL *pfViewable);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *View )( 
            IMSVidPlayback * This,
            /* [in] */ VARIANT *v);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnableResetOnStop )( 
            IMSVidPlayback * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_EnableResetOnStop )( 
            IMSVidPlayback * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Run )( 
            IMSVidPlayback * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IMSVidPlayback * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IMSVidPlayback * This);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CanStep )( 
            IMSVidPlayback * This,
            /* [in] */ VARIANT_BOOL fBackwards,
            /* [retval][out] */ VARIANT_BOOL *pfCan);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Step )( 
            IMSVidPlayback * This,
            /* [in] */ long lStep);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Rate )( 
            IMSVidPlayback * This,
            /* [in] */ double plRate);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Rate )( 
            IMSVidPlayback * This,
            /* [retval][out] */ double *plRate);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CurrentPosition )( 
            IMSVidPlayback * This,
            /* [in] */ long lPosition);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentPosition )( 
            IMSVidPlayback * This,
            /* [retval][out] */ long *lPosition);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PositionMode )( 
            IMSVidPlayback * This,
            /* [in] */ PositionModeList lPositionMode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PositionMode )( 
            IMSVidPlayback * This,
            /* [retval][out] */ PositionModeList *lPositionMode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Length )( 
            IMSVidPlayback * This,
            /* [retval][out] */ long *lLength);
        
        END_INTERFACE
    } IMSVidPlaybackVtbl;

    interface IMSVidPlayback
    {
        CONST_VTBL struct IMSVidPlaybackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSVidPlayback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSVidPlayback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSVidPlayback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSVidPlayback_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSVidPlayback_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSVidPlayback_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSVidPlayback_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSVidPlayback_get_Name(This,Name)	\
    (This)->lpVtbl -> get_Name(This,Name)

#define IMSVidPlayback_get_Status(This,Status)	\
    (This)->lpVtbl -> get_Status(This,Status)

#define IMSVidPlayback_put_Power(This,Power)	\
    (This)->lpVtbl -> put_Power(This,Power)

#define IMSVidPlayback_get_Power(This,Power)	\
    (This)->lpVtbl -> get_Power(This,Power)

#define IMSVidPlayback_get_Category(This,Guid)	\
    (This)->lpVtbl -> get_Category(This,Guid)

#define IMSVidPlayback_get_ClassID(This,Clsid)	\
    (This)->lpVtbl -> get_ClassID(This,Clsid)

#define IMSVidPlayback_get__Category(This,Guid)	\
    (This)->lpVtbl -> get__Category(This,Guid)

#define IMSVidPlayback_get__ClassID(This,Clsid)	\
    (This)->lpVtbl -> get__ClassID(This,Clsid)

#define IMSVidPlayback_IsEqualDevice(This,Device,IsEqual)	\
    (This)->lpVtbl -> IsEqualDevice(This,Device,IsEqual)


#define IMSVidPlayback_IsViewable(This,v,pfViewable)	\
    (This)->lpVtbl -> IsViewable(This,v,pfViewable)

#define IMSVidPlayback_View(This,v)	\
    (This)->lpVtbl -> View(This,v)


#define IMSVidPlayback_get_EnableResetOnStop(This,pVal)	\
    (This)->lpVtbl -> get_EnableResetOnStop(This,pVal)

#define IMSVidPlayback_put_EnableResetOnStop(This,newVal)	\
    (This)->lpVtbl -> put_EnableResetOnStop(This,newVal)

#define IMSVidPlayback_Run(This)	\
    (This)->lpVtbl -> Run(This)

#define IMSVidPlayback_Pause(This)	\
    (This)->lpVtbl -> Pause(This)

#define IMSVidPlayback_Stop(This)	\
    (This)->lpVtbl -> Stop(This)

#define IMSVidPlayback_get_CanStep(This,fBackwards,pfCan)	\
    (This)->lpVtbl -> get_CanStep(This,fBackwards,pfCan)

#define IMSVidPlayback_Step(This,lStep)	\
    (This)->lpVtbl -> Step(This,lStep)

#define IMSVidPlayback_put_Rate(This,plRate)	\
    (This)->lpVtbl -> put_Rate(This,plRate)

#define IMSVidPlayback_get_Rate(This,plRate)	\
    (This)->lpVtbl -> get_Rate(This,plRate)

#define IMSVidPlayback_put_CurrentPosition(This,lPosition)	\
    (This)->lpVtbl -> put_CurrentPosition(This,lPosition)

#define IMSVidPlayback_get_CurrentPosition(This,lPosition)	\
    (This)->lpVtbl -> get_CurrentPosition(This,lPosition)

#define IMSVidPlayback_put_PositionMode(This,lPositionMode)	\
    (This)->lpVtbl -> put_PositionMode(This,lPositionMode)

#define IMSVidPlayback_get_PositionMode(This,lPositionMode)	\
    (This)->lpVtbl -> get_PositionMode(This,lPositionMode)

#define IMSVidPlayback_get_Length(This,lLength)	\
    (This)->lpVtbl -> get_Length(This,lLength)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidPlayback_get_EnableResetOnStop_Proxy( 
    IMSVidPlayback * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IMSVidPlayback_get_EnableResetOnStop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSVidPlayback_put_EnableResetOnStop_Proxy( 
    IMSVidPlayback * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IMSVidPlayback_put_EnableResetOnStop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IMSVidPlayback_Run_Proxy( 
    IMSVidPlayback * This);


void __RPC_STUB IMSVidPlayback_Run_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IMSVidPlayback_Pause_Proxy( 
    IMSVidPlayback * This);


void __RPC_STUB IMSVidPlayback_Pause_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IMSVidPlayback_Stop_Proxy( 
    IMSVidPlayback * This);


void __RPC_STUB IMSVidPlayback_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidPlayback_get_CanStep_Proxy( 
    IMSVidPlayback * This,
    /* [in] */ VARIANT_BOOL fBackwards,
    /* [retval][out] */ VARIANT_BOOL *pfCan);


void __RPC_STUB IMSVidPlayback_get_CanStep_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IMSVidPlayback_Step_Proxy( 
    IMSVidPlayback * This,
    /* [in] */ long lStep);


void __RPC_STUB IMSVidPlayback_Step_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSVidPlayback_put_Rate_Proxy( 
    IMSVidPlayback * This,
    /* [in] */ double plRate);


void __RPC_STUB IMSVidPlayback_put_Rate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidPlayback_get_Rate_Proxy( 
    IMSVidPlayback * This,
    /* [retval][out] */ double *plRate);


void __RPC_STUB IMSVidPlayback_get_Rate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSVidPlayback_put_CurrentPosition_Proxy( 
    IMSVidPlayback * This,
    /* [in] */ long lPosition);


void __RPC_STUB IMSVidPlayback_put_CurrentPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidPlayback_get_CurrentPosition_Proxy( 
    IMSVidPlayback * This,
    /* [retval][out] */ long *lPosition);


void __RPC_STUB IMSVidPlayback_get_CurrentPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSVidPlayback_put_PositionMode_Proxy( 
    IMSVidPlayback * This,
    /* [in] */ PositionModeList lPositionMode);


void __RPC_STUB IMSVidPlayback_put_PositionMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidPlayback_get_PositionMode_Proxy( 
    IMSVidPlayback * This,
    /* [retval][out] */ PositionModeList *lPositionMode);


void __RPC_STUB IMSVidPlayback_get_PositionMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidPlayback_get_Length_Proxy( 
    IMSVidPlayback * This,
    /* [retval][out] */ long *lLength);


void __RPC_STUB IMSVidPlayback_get_Length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSVidPlayback_INTERFACE_DEFINED__ */


#ifndef __IMSVidPlaybackEvent_INTERFACE_DEFINED__
#define __IMSVidPlaybackEvent_INTERFACE_DEFINED__

/* interface IMSVidPlaybackEvent */
/* [unique][helpstring][uuid][oleautomation][object] */ 


EXTERN_C const IID IID_IMSVidPlaybackEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("37B0353B-A4C8-11d2-B634-00C04F79498E")
    IMSVidPlaybackEvent : public IMSVidInputDeviceEvent
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE EndOfMedia( 
            /* [in] */ IMSVidPlayback *lpd) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSVidPlaybackEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSVidPlaybackEvent * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSVidPlaybackEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSVidPlaybackEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSVidPlaybackEvent * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSVidPlaybackEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSVidPlaybackEvent * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSVidPlaybackEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *EndOfMedia )( 
            IMSVidPlaybackEvent * This,
            /* [in] */ IMSVidPlayback *lpd);
        
        END_INTERFACE
    } IMSVidPlaybackEventVtbl;

    interface IMSVidPlaybackEvent
    {
        CONST_VTBL struct IMSVidPlaybackEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSVidPlaybackEvent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSVidPlaybackEvent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSVidPlaybackEvent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSVidPlaybackEvent_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSVidPlaybackEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSVidPlaybackEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSVidPlaybackEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)



#define IMSVidPlaybackEvent_EndOfMedia(This,lpd)	\
    (This)->lpVtbl -> EndOfMedia(This,lpd)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IMSVidPlaybackEvent_EndOfMedia_Proxy( 
    IMSVidPlaybackEvent * This,
    /* [in] */ IMSVidPlayback *lpd);


void __RPC_STUB IMSVidPlaybackEvent_EndOfMedia_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSVidPlaybackEvent_INTERFACE_DEFINED__ */


#ifndef __IMSVidTuner_INTERFACE_DEFINED__
#define __IMSVidTuner_INTERFACE_DEFINED__

/* interface IMSVidTuner */
/* [unique][helpstring][uuid][hidden][oleautomation][dual][object] */ 


EXTERN_C const IID IID_IMSVidTuner;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1C15D47D-911D-11d2-B632-00C04F79498E")
    IMSVidTuner : public IMSVidVideoInputDevice
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Tune( 
            /* [retval][out] */ ITuneRequest **ppTR) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Tune( 
            /* [in] */ ITuneRequest *pTR) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_TuningSpace( 
            /* [retval][out] */ ITuningSpace **plTS) = 0;
        
        virtual /* [id][propput][restricted][hidden] */ HRESULT STDMETHODCALLTYPE put_TuningSpace( 
            /* [in] */ ITuningSpace *plTS) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSVidTunerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSVidTuner * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSVidTuner * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSVidTuner * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSVidTuner * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSVidTuner * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSVidTuner * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSVidTuner * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IMSVidTuner * This,
            /* [retval][out] */ BSTR *Name);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            IMSVidTuner * This,
            /* [retval][out] */ long *Status);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Power )( 
            IMSVidTuner * This,
            /* [in] */ VARIANT_BOOL Power);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Power )( 
            IMSVidTuner * This,
            /* [out][retval] */ VARIANT_BOOL *Power);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Category )( 
            IMSVidTuner * This,
            /* [retval][out] */ BSTR *Guid);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClassID )( 
            IMSVidTuner * This,
            /* [retval][out] */ BSTR *Clsid);
        
        /* [restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__Category )( 
            IMSVidTuner * This,
            /* [retval][out] */ GUID *Guid);
        
        /* [restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__ClassID )( 
            IMSVidTuner * This,
            /* [retval][out] */ GUID *Clsid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsEqualDevice )( 
            IMSVidTuner * This,
            /* [in] */ IMSVidDevice *Device,
            /* [retval][out] */ VARIANT_BOOL *IsEqual);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *IsViewable )( 
            IMSVidTuner * This,
            /* [in] */ VARIANT *v,
            /* [retval][out] */ VARIANT_BOOL *pfViewable);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *View )( 
            IMSVidTuner * This,
            /* [in] */ VARIANT *v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Tune )( 
            IMSVidTuner * This,
            /* [retval][out] */ ITuneRequest **ppTR);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Tune )( 
            IMSVidTuner * This,
            /* [in] */ ITuneRequest *pTR);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TuningSpace )( 
            IMSVidTuner * This,
            /* [retval][out] */ ITuningSpace **plTS);
        
        /* [id][propput][restricted][hidden] */ HRESULT ( STDMETHODCALLTYPE *put_TuningSpace )( 
            IMSVidTuner * This,
            /* [in] */ ITuningSpace *plTS);
        
        END_INTERFACE
    } IMSVidTunerVtbl;

    interface IMSVidTuner
    {
        CONST_VTBL struct IMSVidTunerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSVidTuner_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSVidTuner_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSVidTuner_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSVidTuner_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSVidTuner_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSVidTuner_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSVidTuner_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSVidTuner_get_Name(This,Name)	\
    (This)->lpVtbl -> get_Name(This,Name)

#define IMSVidTuner_get_Status(This,Status)	\
    (This)->lpVtbl -> get_Status(This,Status)

#define IMSVidTuner_put_Power(This,Power)	\
    (This)->lpVtbl -> put_Power(This,Power)

#define IMSVidTuner_get_Power(This,Power)	\
    (This)->lpVtbl -> get_Power(This,Power)

#define IMSVidTuner_get_Category(This,Guid)	\
    (This)->lpVtbl -> get_Category(This,Guid)

#define IMSVidTuner_get_ClassID(This,Clsid)	\
    (This)->lpVtbl -> get_ClassID(This,Clsid)

#define IMSVidTuner_get__Category(This,Guid)	\
    (This)->lpVtbl -> get__Category(This,Guid)

#define IMSVidTuner_get__ClassID(This,Clsid)	\
    (This)->lpVtbl -> get__ClassID(This,Clsid)

#define IMSVidTuner_IsEqualDevice(This,Device,IsEqual)	\
    (This)->lpVtbl -> IsEqualDevice(This,Device,IsEqual)


#define IMSVidTuner_IsViewable(This,v,pfViewable)	\
    (This)->lpVtbl -> IsViewable(This,v,pfViewable)

#define IMSVidTuner_View(This,v)	\
    (This)->lpVtbl -> View(This,v)



#define IMSVidTuner_get_Tune(This,ppTR)	\
    (This)->lpVtbl -> get_Tune(This,ppTR)

#define IMSVidTuner_put_Tune(This,pTR)	\
    (This)->lpVtbl -> put_Tune(This,pTR)

#define IMSVidTuner_get_TuningSpace(This,plTS)	\
    (This)->lpVtbl -> get_TuningSpace(This,plTS)

#define IMSVidTuner_put_TuningSpace(This,plTS)	\
    (This)->lpVtbl -> put_TuningSpace(This,plTS)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidTuner_get_Tune_Proxy( 
    IMSVidTuner * This,
    /* [retval][out] */ ITuneRequest **ppTR);


void __RPC_STUB IMSVidTuner_get_Tune_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IMSVidTuner_put_Tune_Proxy( 
    IMSVidTuner * This,
    /* [in] */ ITuneRequest *pTR);


void __RPC_STUB IMSVidTuner_put_Tune_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidTuner_get_TuningSpace_Proxy( 
    IMSVidTuner * This,
    /* [retval][out] */ ITuningSpace **plTS);


void __RPC_STUB IMSVidTuner_get_TuningSpace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][restricted][hidden] */ HRESULT STDMETHODCALLTYPE IMSVidTuner_put_TuningSpace_Proxy( 
    IMSVidTuner * This,
    /* [in] */ ITuningSpace *plTS);


void __RPC_STUB IMSVidTuner_put_TuningSpace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSVidTuner_INTERFACE_DEFINED__ */


#ifndef __IMSVidTunerEvent_INTERFACE_DEFINED__
#define __IMSVidTunerEvent_INTERFACE_DEFINED__

/* interface IMSVidTunerEvent */
/* [unique][helpstring][uuid][hidden][oleautomation][object] */ 


EXTERN_C const IID IID_IMSVidTunerEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1C15D485-911D-11d2-B632-00C04F79498E")
    IMSVidTunerEvent : public IMSVidInputDeviceEvent
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE TuneChanged( 
            /* [in] */ IMSVidTuner *lpd) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSVidTunerEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSVidTunerEvent * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSVidTunerEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSVidTunerEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSVidTunerEvent * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSVidTunerEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSVidTunerEvent * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSVidTunerEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *TuneChanged )( 
            IMSVidTunerEvent * This,
            /* [in] */ IMSVidTuner *lpd);
        
        END_INTERFACE
    } IMSVidTunerEventVtbl;

    interface IMSVidTunerEvent
    {
        CONST_VTBL struct IMSVidTunerEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSVidTunerEvent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSVidTunerEvent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSVidTunerEvent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSVidTunerEvent_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSVidTunerEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSVidTunerEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSVidTunerEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)



#define IMSVidTunerEvent_TuneChanged(This,lpd)	\
    (This)->lpVtbl -> TuneChanged(This,lpd)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IMSVidTunerEvent_TuneChanged_Proxy( 
    IMSVidTunerEvent * This,
    /* [in] */ IMSVidTuner *lpd);


void __RPC_STUB IMSVidTunerEvent_TuneChanged_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSVidTunerEvent_INTERFACE_DEFINED__ */


#ifndef __IMSVidAnalogTuner_INTERFACE_DEFINED__
#define __IMSVidAnalogTuner_INTERFACE_DEFINED__

/* interface IMSVidAnalogTuner */
/* [unique][helpstring][uuid][hidden][oleautomation][dual][object] */ 


EXTERN_C const IID IID_IMSVidAnalogTuner;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1C15D47E-911D-11d2-B632-00C04F79498E")
    IMSVidAnalogTuner : public IMSVidTuner
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Channel( 
            /* [retval][out] */ long *Channel) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Channel( 
            /* [in] */ long Channel) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_VideoFrequency( 
            /* [out][retval] */ long *lcc) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_AudioFrequency( 
            /* [out][retval] */ long *lcc) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_CountryCode( 
            /* [out][retval] */ long *lcc) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_CountryCode( 
            /* [in] */ long lcc) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_SAP( 
            /* [retval][out] */ VARIANT_BOOL *pfSapOn) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_SAP( 
            /* [in] */ VARIANT_BOOL fSapOn) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ChannelAvailable( 
            /* [in] */ long nChannel,
            /* [out] */ long *SignalStrength,
            /* [out][retval] */ VARIANT_BOOL *fSignalPresent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSVidAnalogTunerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSVidAnalogTuner * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSVidAnalogTuner * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSVidAnalogTuner * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSVidAnalogTuner * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSVidAnalogTuner * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSVidAnalogTuner * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSVidAnalogTuner * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IMSVidAnalogTuner * This,
            /* [retval][out] */ BSTR *Name);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            IMSVidAnalogTuner * This,
            /* [retval][out] */ long *Status);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Power )( 
            IMSVidAnalogTuner * This,
            /* [in] */ VARIANT_BOOL Power);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Power )( 
            IMSVidAnalogTuner * This,
            /* [out][retval] */ VARIANT_BOOL *Power);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Category )( 
            IMSVidAnalogTuner * This,
            /* [retval][out] */ BSTR *Guid);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClassID )( 
            IMSVidAnalogTuner * This,
            /* [retval][out] */ BSTR *Clsid);
        
        /* [restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__Category )( 
            IMSVidAnalogTuner * This,
            /* [retval][out] */ GUID *Guid);
        
        /* [restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__ClassID )( 
            IMSVidAnalogTuner * This,
            /* [retval][out] */ GUID *Clsid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsEqualDevice )( 
            IMSVidAnalogTuner * This,
            /* [in] */ IMSVidDevice *Device,
            /* [retval][out] */ VARIANT_BOOL *IsEqual);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *IsViewable )( 
            IMSVidAnalogTuner * This,
            /* [in] */ VARIANT *v,
            /* [retval][out] */ VARIANT_BOOL *pfViewable);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *View )( 
            IMSVidAnalogTuner * This,
            /* [in] */ VARIANT *v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Tune )( 
            IMSVidAnalogTuner * This,
            /* [retval][out] */ ITuneRequest **ppTR);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Tune )( 
            IMSVidAnalogTuner * This,
            /* [in] */ ITuneRequest *pTR);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TuningSpace )( 
            IMSVidAnalogTuner * This,
            /* [retval][out] */ ITuningSpace **plTS);
        
        /* [id][propput][restricted][hidden] */ HRESULT ( STDMETHODCALLTYPE *put_TuningSpace )( 
            IMSVidAnalogTuner * This,
            /* [in] */ ITuningSpace *plTS);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Channel )( 
            IMSVidAnalogTuner * This,
            /* [retval][out] */ long *Channel);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Channel )( 
            IMSVidAnalogTuner * This,
            /* [in] */ long Channel);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_VideoFrequency )( 
            IMSVidAnalogTuner * This,
            /* [out][retval] */ long *lcc);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AudioFrequency )( 
            IMSVidAnalogTuner * This,
            /* [out][retval] */ long *lcc);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CountryCode )( 
            IMSVidAnalogTuner * This,
            /* [out][retval] */ long *lcc);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CountryCode )( 
            IMSVidAnalogTuner * This,
            /* [in] */ long lcc);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SAP )( 
            IMSVidAnalogTuner * This,
            /* [retval][out] */ VARIANT_BOOL *pfSapOn);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SAP )( 
            IMSVidAnalogTuner * This,
            /* [in] */ VARIANT_BOOL fSapOn);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *ChannelAvailable )( 
            IMSVidAnalogTuner * This,
            /* [in] */ long nChannel,
            /* [out] */ long *SignalStrength,
            /* [out][retval] */ VARIANT_BOOL *fSignalPresent);
        
        END_INTERFACE
    } IMSVidAnalogTunerVtbl;

    interface IMSVidAnalogTuner
    {
        CONST_VTBL struct IMSVidAnalogTunerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSVidAnalogTuner_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSVidAnalogTuner_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSVidAnalogTuner_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSVidAnalogTuner_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSVidAnalogTuner_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSVidAnalogTuner_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSVidAnalogTuner_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSVidAnalogTuner_get_Name(This,Name)	\
    (This)->lpVtbl -> get_Name(This,Name)

#define IMSVidAnalogTuner_get_Status(This,Status)	\
    (This)->lpVtbl -> get_Status(This,Status)

#define IMSVidAnalogTuner_put_Power(This,Power)	\
    (This)->lpVtbl -> put_Power(This,Power)

#define IMSVidAnalogTuner_get_Power(This,Power)	\
    (This)->lpVtbl -> get_Power(This,Power)

#define IMSVidAnalogTuner_get_Category(This,Guid)	\
    (This)->lpVtbl -> get_Category(This,Guid)

#define IMSVidAnalogTuner_get_ClassID(This,Clsid)	\
    (This)->lpVtbl -> get_ClassID(This,Clsid)

#define IMSVidAnalogTuner_get__Category(This,Guid)	\
    (This)->lpVtbl -> get__Category(This,Guid)

#define IMSVidAnalogTuner_get__ClassID(This,Clsid)	\
    (This)->lpVtbl -> get__ClassID(This,Clsid)

#define IMSVidAnalogTuner_IsEqualDevice(This,Device,IsEqual)	\
    (This)->lpVtbl -> IsEqualDevice(This,Device,IsEqual)


#define IMSVidAnalogTuner_IsViewable(This,v,pfViewable)	\
    (This)->lpVtbl -> IsViewable(This,v,pfViewable)

#define IMSVidAnalogTuner_View(This,v)	\
    (This)->lpVtbl -> View(This,v)



#define IMSVidAnalogTuner_get_Tune(This,ppTR)	\
    (This)->lpVtbl -> get_Tune(This,ppTR)

#define IMSVidAnalogTuner_put_Tune(This,pTR)	\
    (This)->lpVtbl -> put_Tune(This,pTR)

#define IMSVidAnalogTuner_get_TuningSpace(This,plTS)	\
    (This)->lpVtbl -> get_TuningSpace(This,plTS)

#define IMSVidAnalogTuner_put_TuningSpace(This,plTS)	\
    (This)->lpVtbl -> put_TuningSpace(This,plTS)


#define IMSVidAnalogTuner_get_Channel(This,Channel)	\
    (This)->lpVtbl -> get_Channel(This,Channel)

#define IMSVidAnalogTuner_put_Channel(This,Channel)	\
    (This)->lpVtbl -> put_Channel(This,Channel)

#define IMSVidAnalogTuner_get_VideoFrequency(This,lcc)	\
    (This)->lpVtbl -> get_VideoFrequency(This,lcc)

#define IMSVidAnalogTuner_get_AudioFrequency(This,lcc)	\
    (This)->lpVtbl -> get_AudioFrequency(This,lcc)

#define IMSVidAnalogTuner_get_CountryCode(This,lcc)	\
    (This)->lpVtbl -> get_CountryCode(This,lcc)

#define IMSVidAnalogTuner_put_CountryCode(This,lcc)	\
    (This)->lpVtbl -> put_CountryCode(This,lcc)

#define IMSVidAnalogTuner_get_SAP(This,pfSapOn)	\
    (This)->lpVtbl -> get_SAP(This,pfSapOn)

#define IMSVidAnalogTuner_put_SAP(This,fSapOn)	\
    (This)->lpVtbl -> put_SAP(This,fSapOn)

#define IMSVidAnalogTuner_ChannelAvailable(This,nChannel,SignalStrength,fSignalPresent)	\
    (This)->lpVtbl -> ChannelAvailable(This,nChannel,SignalStrength,fSignalPresent)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidAnalogTuner_get_Channel_Proxy( 
    IMSVidAnalogTuner * This,
    /* [retval][out] */ long *Channel);


void __RPC_STUB IMSVidAnalogTuner_get_Channel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IMSVidAnalogTuner_put_Channel_Proxy( 
    IMSVidAnalogTuner * This,
    /* [in] */ long Channel);


void __RPC_STUB IMSVidAnalogTuner_put_Channel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidAnalogTuner_get_VideoFrequency_Proxy( 
    IMSVidAnalogTuner * This,
    /* [out][retval] */ long *lcc);


void __RPC_STUB IMSVidAnalogTuner_get_VideoFrequency_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidAnalogTuner_get_AudioFrequency_Proxy( 
    IMSVidAnalogTuner * This,
    /* [out][retval] */ long *lcc);


void __RPC_STUB IMSVidAnalogTuner_get_AudioFrequency_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidAnalogTuner_get_CountryCode_Proxy( 
    IMSVidAnalogTuner * This,
    /* [out][retval] */ long *lcc);


void __RPC_STUB IMSVidAnalogTuner_get_CountryCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IMSVidAnalogTuner_put_CountryCode_Proxy( 
    IMSVidAnalogTuner * This,
    /* [in] */ long lcc);


void __RPC_STUB IMSVidAnalogTuner_put_CountryCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidAnalogTuner_get_SAP_Proxy( 
    IMSVidAnalogTuner * This,
    /* [retval][out] */ VARIANT_BOOL *pfSapOn);


void __RPC_STUB IMSVidAnalogTuner_get_SAP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IMSVidAnalogTuner_put_SAP_Proxy( 
    IMSVidAnalogTuner * This,
    /* [in] */ VARIANT_BOOL fSapOn);


void __RPC_STUB IMSVidAnalogTuner_put_SAP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IMSVidAnalogTuner_ChannelAvailable_Proxy( 
    IMSVidAnalogTuner * This,
    /* [in] */ long nChannel,
    /* [out] */ long *SignalStrength,
    /* [out][retval] */ VARIANT_BOOL *fSignalPresent);


void __RPC_STUB IMSVidAnalogTuner_ChannelAvailable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSVidAnalogTuner_INTERFACE_DEFINED__ */


#ifndef __IMSVidAnalogTunerEvent_INTERFACE_DEFINED__
#define __IMSVidAnalogTunerEvent_INTERFACE_DEFINED__

/* interface IMSVidAnalogTunerEvent */
/* [unique][helpstring][uuid][oleautomation][object] */ 


EXTERN_C const IID IID_IMSVidAnalogTunerEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1C15D486-911D-11d2-B632-00C04F79498E")
    IMSVidAnalogTunerEvent : public IMSVidTunerEvent
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IMSVidAnalogTunerEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSVidAnalogTunerEvent * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSVidAnalogTunerEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSVidAnalogTunerEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSVidAnalogTunerEvent * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSVidAnalogTunerEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSVidAnalogTunerEvent * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSVidAnalogTunerEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *TuneChanged )( 
            IMSVidAnalogTunerEvent * This,
            /* [in] */ IMSVidTuner *lpd);
        
        END_INTERFACE
    } IMSVidAnalogTunerEventVtbl;

    interface IMSVidAnalogTunerEvent
    {
        CONST_VTBL struct IMSVidAnalogTunerEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSVidAnalogTunerEvent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSVidAnalogTunerEvent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSVidAnalogTunerEvent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSVidAnalogTunerEvent_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSVidAnalogTunerEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSVidAnalogTunerEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSVidAnalogTunerEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)



#define IMSVidAnalogTunerEvent_TuneChanged(This,lpd)	\
    (This)->lpVtbl -> TuneChanged(This,lpd)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMSVidAnalogTunerEvent_INTERFACE_DEFINED__ */


#ifndef __IMSVidFilePlayback_INTERFACE_DEFINED__
#define __IMSVidFilePlayback_INTERFACE_DEFINED__

/* interface IMSVidFilePlayback */
/* [unique][helpstring][uuid][hidden][oleautomation][dual][object] */ 


EXTERN_C const IID IID_IMSVidFilePlayback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("37B03539-A4C8-11d2-B634-00C04F79498E")
    IMSVidFilePlayback : public IMSVidPlayback
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_FileName( 
            /* [retval][out] */ BSTR *FileName) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_FileName( 
            /* [in] */ BSTR FileName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSVidFilePlaybackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSVidFilePlayback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSVidFilePlayback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSVidFilePlayback * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSVidFilePlayback * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSVidFilePlayback * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSVidFilePlayback * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSVidFilePlayback * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IMSVidFilePlayback * This,
            /* [retval][out] */ BSTR *Name);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            IMSVidFilePlayback * This,
            /* [retval][out] */ long *Status);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Power )( 
            IMSVidFilePlayback * This,
            /* [in] */ VARIANT_BOOL Power);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Power )( 
            IMSVidFilePlayback * This,
            /* [out][retval] */ VARIANT_BOOL *Power);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Category )( 
            IMSVidFilePlayback * This,
            /* [retval][out] */ BSTR *Guid);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClassID )( 
            IMSVidFilePlayback * This,
            /* [retval][out] */ BSTR *Clsid);
        
        /* [restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__Category )( 
            IMSVidFilePlayback * This,
            /* [retval][out] */ GUID *Guid);
        
        /* [restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__ClassID )( 
            IMSVidFilePlayback * This,
            /* [retval][out] */ GUID *Clsid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsEqualDevice )( 
            IMSVidFilePlayback * This,
            /* [in] */ IMSVidDevice *Device,
            /* [retval][out] */ VARIANT_BOOL *IsEqual);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *IsViewable )( 
            IMSVidFilePlayback * This,
            /* [in] */ VARIANT *v,
            /* [retval][out] */ VARIANT_BOOL *pfViewable);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *View )( 
            IMSVidFilePlayback * This,
            /* [in] */ VARIANT *v);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnableResetOnStop )( 
            IMSVidFilePlayback * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_EnableResetOnStop )( 
            IMSVidFilePlayback * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Run )( 
            IMSVidFilePlayback * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IMSVidFilePlayback * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IMSVidFilePlayback * This);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CanStep )( 
            IMSVidFilePlayback * This,
            /* [in] */ VARIANT_BOOL fBackwards,
            /* [retval][out] */ VARIANT_BOOL *pfCan);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Step )( 
            IMSVidFilePlayback * This,
            /* [in] */ long lStep);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Rate )( 
            IMSVidFilePlayback * This,
            /* [in] */ double plRate);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Rate )( 
            IMSVidFilePlayback * This,
            /* [retval][out] */ double *plRate);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CurrentPosition )( 
            IMSVidFilePlayback * This,
            /* [in] */ long lPosition);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentPosition )( 
            IMSVidFilePlayback * This,
            /* [retval][out] */ long *lPosition);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PositionMode )( 
            IMSVidFilePlayback * This,
            /* [in] */ PositionModeList lPositionMode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PositionMode )( 
            IMSVidFilePlayback * This,
            /* [retval][out] */ PositionModeList *lPositionMode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Length )( 
            IMSVidFilePlayback * This,
            /* [retval][out] */ long *lLength);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileName )( 
            IMSVidFilePlayback * This,
            /* [retval][out] */ BSTR *FileName);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_FileName )( 
            IMSVidFilePlayback * This,
            /* [in] */ BSTR FileName);
        
        END_INTERFACE
    } IMSVidFilePlaybackVtbl;

    interface IMSVidFilePlayback
    {
        CONST_VTBL struct IMSVidFilePlaybackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSVidFilePlayback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSVidFilePlayback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSVidFilePlayback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSVidFilePlayback_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSVidFilePlayback_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSVidFilePlayback_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSVidFilePlayback_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSVidFilePlayback_get_Name(This,Name)	\
    (This)->lpVtbl -> get_Name(This,Name)

#define IMSVidFilePlayback_get_Status(This,Status)	\
    (This)->lpVtbl -> get_Status(This,Status)

#define IMSVidFilePlayback_put_Power(This,Power)	\
    (This)->lpVtbl -> put_Power(This,Power)

#define IMSVidFilePlayback_get_Power(This,Power)	\
    (This)->lpVtbl -> get_Power(This,Power)

#define IMSVidFilePlayback_get_Category(This,Guid)	\
    (This)->lpVtbl -> get_Category(This,Guid)

#define IMSVidFilePlayback_get_ClassID(This,Clsid)	\
    (This)->lpVtbl -> get_ClassID(This,Clsid)

#define IMSVidFilePlayback_get__Category(This,Guid)	\
    (This)->lpVtbl -> get__Category(This,Guid)

#define IMSVidFilePlayback_get__ClassID(This,Clsid)	\
    (This)->lpVtbl -> get__ClassID(This,Clsid)

#define IMSVidFilePlayback_IsEqualDevice(This,Device,IsEqual)	\
    (This)->lpVtbl -> IsEqualDevice(This,Device,IsEqual)


#define IMSVidFilePlayback_IsViewable(This,v,pfViewable)	\
    (This)->lpVtbl -> IsViewable(This,v,pfViewable)

#define IMSVidFilePlayback_View(This,v)	\
    (This)->lpVtbl -> View(This,v)


#define IMSVidFilePlayback_get_EnableResetOnStop(This,pVal)	\
    (This)->lpVtbl -> get_EnableResetOnStop(This,pVal)

#define IMSVidFilePlayback_put_EnableResetOnStop(This,newVal)	\
    (This)->lpVtbl -> put_EnableResetOnStop(This,newVal)

#define IMSVidFilePlayback_Run(This)	\
    (This)->lpVtbl -> Run(This)

#define IMSVidFilePlayback_Pause(This)	\
    (This)->lpVtbl -> Pause(This)

#define IMSVidFilePlayback_Stop(This)	\
    (This)->lpVtbl -> Stop(This)

#define IMSVidFilePlayback_get_CanStep(This,fBackwards,pfCan)	\
    (This)->lpVtbl -> get_CanStep(This,fBackwards,pfCan)

#define IMSVidFilePlayback_Step(This,lStep)	\
    (This)->lpVtbl -> Step(This,lStep)

#define IMSVidFilePlayback_put_Rate(This,plRate)	\
    (This)->lpVtbl -> put_Rate(This,plRate)

#define IMSVidFilePlayback_get_Rate(This,plRate)	\
    (This)->lpVtbl -> get_Rate(This,plRate)

#define IMSVidFilePlayback_put_CurrentPosition(This,lPosition)	\
    (This)->lpVtbl -> put_CurrentPosition(This,lPosition)

#define IMSVidFilePlayback_get_CurrentPosition(This,lPosition)	\
    (This)->lpVtbl -> get_CurrentPosition(This,lPosition)

#define IMSVidFilePlayback_put_PositionMode(This,lPositionMode)	\
    (This)->lpVtbl -> put_PositionMode(This,lPositionMode)

#define IMSVidFilePlayback_get_PositionMode(This,lPositionMode)	\
    (This)->lpVtbl -> get_PositionMode(This,lPositionMode)

#define IMSVidFilePlayback_get_Length(This,lLength)	\
    (This)->lpVtbl -> get_Length(This,lLength)


#define IMSVidFilePlayback_get_FileName(This,FileName)	\
    (This)->lpVtbl -> get_FileName(This,FileName)

#define IMSVidFilePlayback_put_FileName(This,FileName)	\
    (This)->lpVtbl -> put_FileName(This,FileName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidFilePlayback_get_FileName_Proxy( 
    IMSVidFilePlayback * This,
    /* [retval][out] */ BSTR *FileName);


void __RPC_STUB IMSVidFilePlayback_get_FileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IMSVidFilePlayback_put_FileName_Proxy( 
    IMSVidFilePlayback * This,
    /* [in] */ BSTR FileName);


void __RPC_STUB IMSVidFilePlayback_put_FileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSVidFilePlayback_INTERFACE_DEFINED__ */


#ifndef __IMSVidFilePlaybackEvent_INTERFACE_DEFINED__
#define __IMSVidFilePlaybackEvent_INTERFACE_DEFINED__

/* interface IMSVidFilePlaybackEvent */
/* [unique][helpstring][uuid][hidden][oleautomation][object] */ 


EXTERN_C const IID IID_IMSVidFilePlaybackEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("37B0353A-A4C8-11d2-B634-00C04F79498E")
    IMSVidFilePlaybackEvent : public IMSVidPlaybackEvent
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IMSVidFilePlaybackEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSVidFilePlaybackEvent * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSVidFilePlaybackEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSVidFilePlaybackEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSVidFilePlaybackEvent * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSVidFilePlaybackEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSVidFilePlaybackEvent * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSVidFilePlaybackEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *EndOfMedia )( 
            IMSVidFilePlaybackEvent * This,
            /* [in] */ IMSVidPlayback *lpd);
        
        END_INTERFACE
    } IMSVidFilePlaybackEventVtbl;

    interface IMSVidFilePlaybackEvent
    {
        CONST_VTBL struct IMSVidFilePlaybackEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSVidFilePlaybackEvent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSVidFilePlaybackEvent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSVidFilePlaybackEvent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSVidFilePlaybackEvent_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSVidFilePlaybackEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSVidFilePlaybackEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSVidFilePlaybackEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)



#define IMSVidFilePlaybackEvent_EndOfMedia(This,lpd)	\
    (This)->lpVtbl -> EndOfMedia(This,lpd)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMSVidFilePlaybackEvent_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_segment_0482 */
/* [local] */ 

typedef /* [public][public][public] */ 
enum __MIDL___MIDL_itf_segment_0482_0001
    {	dvdMenu_Title	= 2,
	dvdMenu_Root	= dvdMenu_Title + 1,
	dvdMenu_Subpicture	= dvdMenu_Root + 1,
	dvdMenu_Audio	= dvdMenu_Subpicture + 1,
	dvdMenu_Angle	= dvdMenu_Audio + 1,
	dvdMenu_Chapter	= dvdMenu_Angle + 1
    } 	DVDMenuIDConstants;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_segment_0482_0002
    {	dvdState_Undefined	= -2,
	dvdState_Unitialized	= dvdState_Undefined + 1,
	dvdState_Stopped	= dvdState_Unitialized + 1,
	dvdState_Paused	= dvdState_Stopped + 1,
	dvdState_Running	= dvdState_Paused + 1
    } 	DVDFilterState;

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_segment_0482_0003
    {	dvdStruct_Volume	= 0x1,
	dvdStruct_Title	= 0x2,
	dvdStruct_ParentalID	= 0x3,
	dvdStruct_PartOfTitle	= 0x4,
	dvdStruct_Cell	= 0x5,
	dvdStream_Audio	= 0x10,
	dvdStream_Subpicture	= 0x11,
	dvdStream_Angle	= 0x12,
	dvdChannel_Audio	= 0x20,
	dvdGeneral_Name	= 0x30,
	dvdGeneral_Comments	= 0x31,
	dvdTitle_Series	= 0x38,
	dvdTitle_Movie	= 0x39,
	dvdTitle_Video	= 0x3a,
	dvdTitle_Album	= 0x3b,
	dvdTitle_Song	= 0x3c,
	dvdTitle_Other	= 0x3f,
	dvdTitle_Sub_Series	= 0x40,
	dvdTitle_Sub_Movie	= 0x41,
	dvdTitle_Sub_Video	= 0x42,
	dvdTitle_Sub_Album	= 0x43,
	dvdTitle_Sub_Song	= 0x44,
	dvdTitle_Sub_Other	= 0x47,
	dvdTitle_Orig_Series	= 0x48,
	dvdTitle_Orig_Movie	= 0x49,
	dvdTitle_Orig_Video	= 0x4a,
	dvdTitle_Orig_Album	= 0x4b,
	dvdTitle_Orig_Song	= 0x4c,
	dvdTitle_Orig_Other	= 0x4f,
	dvdOther_Scene	= 0x50,
	dvdOther_Cut	= 0x51,
	dvdOther_Take	= 0x52
    } 	DVDTextStringType;

typedef /* [public][public][public] */ 
enum __MIDL___MIDL_itf_segment_0482_0004
    {	dvdSPExt_NotSpecified	= 0,
	dvdSPExt_Caption_Normal	= 1,
	dvdSPExt_Caption_Big	= 2,
	dvdSPExt_Caption_Children	= 3,
	dvdSPExt_CC_Normal	= 5,
	dvdSPExt_CC_Big	= 6,
	dvdSPExt_CC_Children	= 7,
	dvdSPExt_Forced	= 9,
	dvdSPExt_DirectorComments_Normal	= 13,
	dvdSPExt_DirectorComments_Big	= 14,
	dvdSPExt_DirectorComments_Children	= 15
    } 	DVDSPExt;



extern RPC_IF_HANDLE __MIDL_itf_segment_0482_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_segment_0482_v0_0_s_ifspec;

#ifndef __IMSVidWebDVD_INTERFACE_DEFINED__
#define __IMSVidWebDVD_INTERFACE_DEFINED__

/* interface IMSVidWebDVD */
/* [unique][helpstring][uuid][hidden][oleautomation][dual][object] */ 


EXTERN_C const IID IID_IMSVidWebDVD;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CF45F88B-AC56-4EE2-A73A-ED04E2885D3C")
    IMSVidWebDVD : public IMSVidPlayback
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnDVDEvent( 
            /* [in] */ long lEvent,
            /* [in] */ LONG_PTR lParam1,
            /* [in] */ LONG_PTR lParam2) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PlayTitle( 
            /* [in] */ long lTitle) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PlayChapterInTitle( 
            /* [in] */ long lTitle,
            /* [in] */ long lChapter) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PlayChapter( 
            /* [in] */ long lChapter) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PlayChaptersAutoStop( 
            /* [in] */ long lTitle,
            /* [in] */ long lstrChapter,
            /* [in] */ long lChapterCount) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PlayAtTime( 
            /* [in] */ BSTR strTime) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PlayAtTimeInTitle( 
            /* [in] */ long lTitle,
            /* [in] */ BSTR strTime) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PlayPeriodInTitleAutoStop( 
            /* [in] */ long lTitle,
            /* [in] */ BSTR strStartTime,
            /* [in] */ BSTR strEndTime) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ReplayChapter( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PlayPrevChapter( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PlayNextChapter( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE StillOff( void) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AudioLanguage( 
            /* [in] */ long lStream,
            /* [defaultvalue][in] */ VARIANT_BOOL fFormat,
            /* [retval][out] */ BSTR *strAudioLang) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ShowMenu( 
            /* [in] */ DVDMenuIDConstants MenuID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ReturnFromSubmenu( void) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ButtonsAvailable( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentButton( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SelectAndActivateButton( 
            /* [in] */ long lButton) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ActivateButton( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SelectRightButton( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SelectLeftButton( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SelectLowerButton( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SelectUpperButton( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ActivateAtPosition( 
            /* [in] */ long xPos,
            /* [in] */ long yPos) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SelectAtPosition( 
            /* [in] */ long xPos,
            /* [in] */ long yPos) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ButtonAtPosition( 
            /* [in] */ long xPos,
            /* [in] */ long yPos,
            /* [retval][out] */ long *plButton) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_NumberOfChapters( 
            /* [in] */ long lTitle,
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TotalTitleTime( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TitlesAvailable( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_VolumesAvailable( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentVolume( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentDiscSide( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentDomain( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentChapter( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentTitle( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentTime( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DVDTimeCode2bstr( 
            /* [in] */ long timeCode,
            /* [retval][out] */ BSTR *pTimeStr) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DVDDirectory( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DVDDirectory( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsSubpictureStreamEnabled( 
            /* [in] */ long lstream,
            /* [retval][out] */ VARIANT_BOOL *fEnabled) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsAudioStreamEnabled( 
            /* [in] */ long lstream,
            /* [retval][out] */ VARIANT_BOOL *fEnabled) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentSubpictureStream( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CurrentSubpictureStream( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SubpictureLanguage( 
            long lStream,
            /* [retval][out] */ BSTR *strLanguage) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentAudioStream( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CurrentAudioStream( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AudioStreamsAvailable( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AnglesAvailable( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentAngle( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CurrentAngle( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SubpictureStreamsAvailable( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SubpictureOn( 
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SubpictureOn( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DVDUniqueID( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AcceptParentalLevelChange( 
            /* [in] */ VARIANT_BOOL fAccept,
            /* [in] */ BSTR strUserName,
            /* [in] */ BSTR strPassword) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE NotifyParentalLevelChange( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SelectParentalCountry( 
            /* [in] */ long lCountry,
            /* [in] */ BSTR strUserName,
            /* [in] */ BSTR strPassword) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SelectParentalLevel( 
            /* [in] */ long lParentalLevel,
            /* [in] */ BSTR strUserName,
            /* [in] */ BSTR strPassword) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TitleParentalLevels( 
            /* [in] */ long lTitle,
            /* [retval][out] */ long *plParentalLevels) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PlayerParentalCountry( 
            /* [retval][out] */ long *plCountryCode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PlayerParentalLevel( 
            /* [retval][out] */ long *plParentalLevel) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Eject( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE UOPValid( 
            /* [in] */ long lUOP,
            /* [retval][out] */ VARIANT_BOOL *pfValid) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SPRM( 
            /* [in] */ long lIndex,
            /* [retval][out] */ short *psSPRM) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_GPRM( 
            /* [in] */ long lIndex,
            /* [retval][out] */ short *psSPRM) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_GPRM( 
            /* [in] */ long lIndex,
            /* [in] */ short sValue) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DVDTextStringType( 
            /* [in] */ long lLangIndex,
            /* [in] */ long lStringIndex,
            /* [retval][out] */ DVDTextStringType *pType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DVDTextString( 
            /* [in] */ long lLangIndex,
            /* [in] */ long lStringIndex,
            /* [retval][out] */ BSTR *pstrText) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DVDTextNumberOfStrings( 
            /* [in] */ long lLangIndex,
            /* [retval][out] */ long *plNumOfStrings) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DVDTextNumberOfLanguages( 
            /* [retval][out] */ long *plNumOfLangs) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DVDTextLanguageLCID( 
            /* [in] */ long lLangIndex,
            /* [retval][out] */ long *lcid) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RegionChange( void) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DVDAdm( 
            /* [retval][out] */ IDispatch **pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DeleteBookmark( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RestoreBookmark( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SaveBookmark( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SelectDefaultAudioLanguage( 
            /* [in] */ long lang,
            /* [in] */ long ext) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SelectDefaultSubpictureLanguage( 
            /* [in] */ long lang,
            /* [in] */ DVDSPExt ext) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PreferredSubpictureStream( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DefaultMenuLanguage( 
            /* [retval][out] */ long *lang) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DefaultMenuLanguage( 
            /* [in] */ long lang) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DefaultSubpictureLanguage( 
            /* [retval][out] */ long *lang) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DefaultAudioLanguage( 
            /* [retval][out] */ long *lang) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DefaultSubpictureLanguageExt( 
            /* [retval][out] */ DVDSPExt *ext) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DefaultAudioLanguageExt( 
            /* [retval][out] */ long *ext) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LanguageFromLCID( 
            /* [in] */ long lcid,
            /* [retval][out] */ BSTR *lang) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_KaraokeAudioPresentationMode( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_KaraokeAudioPresentationMode( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_KaraokeChannelContent( 
            /* [in] */ long lStream,
            /* [in] */ long lChan,
            /* [retval][out] */ long *lContent) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_KaraokeChannelAssignment( 
            /* [in] */ long lStream,
            /* [retval][out] */ long *lChannelAssignment) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RestorePreferredSettings( void) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ButtonRect( 
            /* [in] */ long lButton,
            /* [retval][out] */ IMSVidRect **pRect) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DVDScreenInMouseCoordinates( 
            /* [retval][out] */ IMSVidRect **ppRect) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DVDScreenInMouseCoordinates( 
            /* [in] */ IMSVidRect *pRect) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSVidWebDVDVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSVidWebDVD * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSVidWebDVD * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSVidWebDVD * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSVidWebDVD * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSVidWebDVD * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSVidWebDVD * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSVidWebDVD * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IMSVidWebDVD * This,
            /* [retval][out] */ BSTR *Name);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            IMSVidWebDVD * This,
            /* [retval][out] */ long *Status);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Power )( 
            IMSVidWebDVD * This,
            /* [in] */ VARIANT_BOOL Power);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Power )( 
            IMSVidWebDVD * This,
            /* [out][retval] */ VARIANT_BOOL *Power);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Category )( 
            IMSVidWebDVD * This,
            /* [retval][out] */ BSTR *Guid);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClassID )( 
            IMSVidWebDVD * This,
            /* [retval][out] */ BSTR *Clsid);
        
        /* [restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__Category )( 
            IMSVidWebDVD * This,
            /* [retval][out] */ GUID *Guid);
        
        /* [restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__ClassID )( 
            IMSVidWebDVD * This,
            /* [retval][out] */ GUID *Clsid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsEqualDevice )( 
            IMSVidWebDVD * This,
            /* [in] */ IMSVidDevice *Device,
            /* [retval][out] */ VARIANT_BOOL *IsEqual);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *IsViewable )( 
            IMSVidWebDVD * This,
            /* [in] */ VARIANT *v,
            /* [retval][out] */ VARIANT_BOOL *pfViewable);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *View )( 
            IMSVidWebDVD * This,
            /* [in] */ VARIANT *v);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnableResetOnStop )( 
            IMSVidWebDVD * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_EnableResetOnStop )( 
            IMSVidWebDVD * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Run )( 
            IMSVidWebDVD * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IMSVidWebDVD * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IMSVidWebDVD * This);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CanStep )( 
            IMSVidWebDVD * This,
            /* [in] */ VARIANT_BOOL fBackwards,
            /* [retval][out] */ VARIANT_BOOL *pfCan);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Step )( 
            IMSVidWebDVD * This,
            /* [in] */ long lStep);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Rate )( 
            IMSVidWebDVD * This,
            /* [in] */ double plRate);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Rate )( 
            IMSVidWebDVD * This,
            /* [retval][out] */ double *plRate);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CurrentPosition )( 
            IMSVidWebDVD * This,
            /* [in] */ long lPosition);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentPosition )( 
            IMSVidWebDVD * This,
            /* [retval][out] */ long *lPosition);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PositionMode )( 
            IMSVidWebDVD * This,
            /* [in] */ PositionModeList lPositionMode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PositionMode )( 
            IMSVidWebDVD * This,
            /* [retval][out] */ PositionModeList *lPositionMode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Length )( 
            IMSVidWebDVD * This,
            /* [retval][out] */ long *lLength);
        
        HRESULT ( STDMETHODCALLTYPE *OnDVDEvent )( 
            IMSVidWebDVD * This,
            /* [in] */ long lEvent,
            /* [in] */ LONG_PTR lParam1,
            /* [in] */ LONG_PTR lParam2);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *PlayTitle )( 
            IMSVidWebDVD * This,
            /* [in] */ long lTitle);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *PlayChapterInTitle )( 
            IMSVidWebDVD * This,
            /* [in] */ long lTitle,
            /* [in] */ long lChapter);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *PlayChapter )( 
            IMSVidWebDVD * This,
            /* [in] */ long lChapter);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *PlayChaptersAutoStop )( 
            IMSVidWebDVD * This,
            /* [in] */ long lTitle,
            /* [in] */ long lstrChapter,
            /* [in] */ long lChapterCount);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *PlayAtTime )( 
            IMSVidWebDVD * This,
            /* [in] */ BSTR strTime);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *PlayAtTimeInTitle )( 
            IMSVidWebDVD * This,
            /* [in] */ long lTitle,
            /* [in] */ BSTR strTime);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *PlayPeriodInTitleAutoStop )( 
            IMSVidWebDVD * This,
            /* [in] */ long lTitle,
            /* [in] */ BSTR strStartTime,
            /* [in] */ BSTR strEndTime);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ReplayChapter )( 
            IMSVidWebDVD * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *PlayPrevChapter )( 
            IMSVidWebDVD * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *PlayNextChapter )( 
            IMSVidWebDVD * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StillOff )( 
            IMSVidWebDVD * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AudioLanguage )( 
            IMSVidWebDVD * This,
            /* [in] */ long lStream,
            /* [defaultvalue][in] */ VARIANT_BOOL fFormat,
            /* [retval][out] */ BSTR *strAudioLang);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ShowMenu )( 
            IMSVidWebDVD * This,
            /* [in] */ DVDMenuIDConstants MenuID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IMSVidWebDVD * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ReturnFromSubmenu )( 
            IMSVidWebDVD * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ButtonsAvailable )( 
            IMSVidWebDVD * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentButton )( 
            IMSVidWebDVD * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SelectAndActivateButton )( 
            IMSVidWebDVD * This,
            /* [in] */ long lButton);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ActivateButton )( 
            IMSVidWebDVD * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SelectRightButton )( 
            IMSVidWebDVD * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SelectLeftButton )( 
            IMSVidWebDVD * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SelectLowerButton )( 
            IMSVidWebDVD * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SelectUpperButton )( 
            IMSVidWebDVD * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ActivateAtPosition )( 
            IMSVidWebDVD * This,
            /* [in] */ long xPos,
            /* [in] */ long yPos);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SelectAtPosition )( 
            IMSVidWebDVD * This,
            /* [in] */ long xPos,
            /* [in] */ long yPos);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ButtonAtPosition )( 
            IMSVidWebDVD * This,
            /* [in] */ long xPos,
            /* [in] */ long yPos,
            /* [retval][out] */ long *plButton);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_NumberOfChapters )( 
            IMSVidWebDVD * This,
            /* [in] */ long lTitle,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TotalTitleTime )( 
            IMSVidWebDVD * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TitlesAvailable )( 
            IMSVidWebDVD * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_VolumesAvailable )( 
            IMSVidWebDVD * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentVolume )( 
            IMSVidWebDVD * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentDiscSide )( 
            IMSVidWebDVD * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentDomain )( 
            IMSVidWebDVD * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentChapter )( 
            IMSVidWebDVD * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentTitle )( 
            IMSVidWebDVD * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentTime )( 
            IMSVidWebDVD * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DVDTimeCode2bstr )( 
            IMSVidWebDVD * This,
            /* [in] */ long timeCode,
            /* [retval][out] */ BSTR *pTimeStr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DVDDirectory )( 
            IMSVidWebDVD * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DVDDirectory )( 
            IMSVidWebDVD * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsSubpictureStreamEnabled )( 
            IMSVidWebDVD * This,
            /* [in] */ long lstream,
            /* [retval][out] */ VARIANT_BOOL *fEnabled);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsAudioStreamEnabled )( 
            IMSVidWebDVD * This,
            /* [in] */ long lstream,
            /* [retval][out] */ VARIANT_BOOL *fEnabled);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentSubpictureStream )( 
            IMSVidWebDVD * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CurrentSubpictureStream )( 
            IMSVidWebDVD * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SubpictureLanguage )( 
            IMSVidWebDVD * This,
            long lStream,
            /* [retval][out] */ BSTR *strLanguage);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentAudioStream )( 
            IMSVidWebDVD * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CurrentAudioStream )( 
            IMSVidWebDVD * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AudioStreamsAvailable )( 
            IMSVidWebDVD * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AnglesAvailable )( 
            IMSVidWebDVD * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentAngle )( 
            IMSVidWebDVD * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CurrentAngle )( 
            IMSVidWebDVD * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SubpictureStreamsAvailable )( 
            IMSVidWebDVD * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SubpictureOn )( 
            IMSVidWebDVD * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SubpictureOn )( 
            IMSVidWebDVD * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DVDUniqueID )( 
            IMSVidWebDVD * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AcceptParentalLevelChange )( 
            IMSVidWebDVD * This,
            /* [in] */ VARIANT_BOOL fAccept,
            /* [in] */ BSTR strUserName,
            /* [in] */ BSTR strPassword);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *NotifyParentalLevelChange )( 
            IMSVidWebDVD * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SelectParentalCountry )( 
            IMSVidWebDVD * This,
            /* [in] */ long lCountry,
            /* [in] */ BSTR strUserName,
            /* [in] */ BSTR strPassword);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SelectParentalLevel )( 
            IMSVidWebDVD * This,
            /* [in] */ long lParentalLevel,
            /* [in] */ BSTR strUserName,
            /* [in] */ BSTR strPassword);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TitleParentalLevels )( 
            IMSVidWebDVD * This,
            /* [in] */ long lTitle,
            /* [retval][out] */ long *plParentalLevels);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PlayerParentalCountry )( 
            IMSVidWebDVD * This,
            /* [retval][out] */ long *plCountryCode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PlayerParentalLevel )( 
            IMSVidWebDVD * This,
            /* [retval][out] */ long *plParentalLevel);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Eject )( 
            IMSVidWebDVD * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *UOPValid )( 
            IMSVidWebDVD * This,
            /* [in] */ long lUOP,
            /* [retval][out] */ VARIANT_BOOL *pfValid);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SPRM )( 
            IMSVidWebDVD * This,
            /* [in] */ long lIndex,
            /* [retval][out] */ short *psSPRM);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GPRM )( 
            IMSVidWebDVD * This,
            /* [in] */ long lIndex,
            /* [retval][out] */ short *psSPRM);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_GPRM )( 
            IMSVidWebDVD * This,
            /* [in] */ long lIndex,
            /* [in] */ short sValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DVDTextStringType )( 
            IMSVidWebDVD * This,
            /* [in] */ long lLangIndex,
            /* [in] */ long lStringIndex,
            /* [retval][out] */ DVDTextStringType *pType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DVDTextString )( 
            IMSVidWebDVD * This,
            /* [in] */ long lLangIndex,
            /* [in] */ long lStringIndex,
            /* [retval][out] */ BSTR *pstrText);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DVDTextNumberOfStrings )( 
            IMSVidWebDVD * This,
            /* [in] */ long lLangIndex,
            /* [retval][out] */ long *plNumOfStrings);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DVDTextNumberOfLanguages )( 
            IMSVidWebDVD * This,
            /* [retval][out] */ long *plNumOfLangs);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DVDTextLanguageLCID )( 
            IMSVidWebDVD * This,
            /* [in] */ long lLangIndex,
            /* [retval][out] */ long *lcid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RegionChange )( 
            IMSVidWebDVD * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DVDAdm )( 
            IMSVidWebDVD * This,
            /* [retval][out] */ IDispatch **pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DeleteBookmark )( 
            IMSVidWebDVD * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RestoreBookmark )( 
            IMSVidWebDVD * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SaveBookmark )( 
            IMSVidWebDVD * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SelectDefaultAudioLanguage )( 
            IMSVidWebDVD * This,
            /* [in] */ long lang,
            /* [in] */ long ext);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SelectDefaultSubpictureLanguage )( 
            IMSVidWebDVD * This,
            /* [in] */ long lang,
            /* [in] */ DVDSPExt ext);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PreferredSubpictureStream )( 
            IMSVidWebDVD * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DefaultMenuLanguage )( 
            IMSVidWebDVD * This,
            /* [retval][out] */ long *lang);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DefaultMenuLanguage )( 
            IMSVidWebDVD * This,
            /* [in] */ long lang);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DefaultSubpictureLanguage )( 
            IMSVidWebDVD * This,
            /* [retval][out] */ long *lang);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DefaultAudioLanguage )( 
            IMSVidWebDVD * This,
            /* [retval][out] */ long *lang);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DefaultSubpictureLanguageExt )( 
            IMSVidWebDVD * This,
            /* [retval][out] */ DVDSPExt *ext);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DefaultAudioLanguageExt )( 
            IMSVidWebDVD * This,
            /* [retval][out] */ long *ext);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LanguageFromLCID )( 
            IMSVidWebDVD * This,
            /* [in] */ long lcid,
            /* [retval][out] */ BSTR *lang);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_KaraokeAudioPresentationMode )( 
            IMSVidWebDVD * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_KaraokeAudioPresentationMode )( 
            IMSVidWebDVD * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_KaraokeChannelContent )( 
            IMSVidWebDVD * This,
            /* [in] */ long lStream,
            /* [in] */ long lChan,
            /* [retval][out] */ long *lContent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_KaraokeChannelAssignment )( 
            IMSVidWebDVD * This,
            /* [in] */ long lStream,
            /* [retval][out] */ long *lChannelAssignment);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RestorePreferredSettings )( 
            IMSVidWebDVD * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ButtonRect )( 
            IMSVidWebDVD * This,
            /* [in] */ long lButton,
            /* [retval][out] */ IMSVidRect **pRect);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DVDScreenInMouseCoordinates )( 
            IMSVidWebDVD * This,
            /* [retval][out] */ IMSVidRect **ppRect);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DVDScreenInMouseCoordinates )( 
            IMSVidWebDVD * This,
            /* [in] */ IMSVidRect *pRect);
        
        END_INTERFACE
    } IMSVidWebDVDVtbl;

    interface IMSVidWebDVD
    {
        CONST_VTBL struct IMSVidWebDVDVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSVidWebDVD_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSVidWebDVD_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSVidWebDVD_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSVidWebDVD_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSVidWebDVD_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSVidWebDVD_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSVidWebDVD_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSVidWebDVD_get_Name(This,Name)	\
    (This)->lpVtbl -> get_Name(This,Name)

#define IMSVidWebDVD_get_Status(This,Status)	\
    (This)->lpVtbl -> get_Status(This,Status)

#define IMSVidWebDVD_put_Power(This,Power)	\
    (This)->lpVtbl -> put_Power(This,Power)

#define IMSVidWebDVD_get_Power(This,Power)	\
    (This)->lpVtbl -> get_Power(This,Power)

#define IMSVidWebDVD_get_Category(This,Guid)	\
    (This)->lpVtbl -> get_Category(This,Guid)

#define IMSVidWebDVD_get_ClassID(This,Clsid)	\
    (This)->lpVtbl -> get_ClassID(This,Clsid)

#define IMSVidWebDVD_get__Category(This,Guid)	\
    (This)->lpVtbl -> get__Category(This,Guid)

#define IMSVidWebDVD_get__ClassID(This,Clsid)	\
    (This)->lpVtbl -> get__ClassID(This,Clsid)

#define IMSVidWebDVD_IsEqualDevice(This,Device,IsEqual)	\
    (This)->lpVtbl -> IsEqualDevice(This,Device,IsEqual)


#define IMSVidWebDVD_IsViewable(This,v,pfViewable)	\
    (This)->lpVtbl -> IsViewable(This,v,pfViewable)

#define IMSVidWebDVD_View(This,v)	\
    (This)->lpVtbl -> View(This,v)


#define IMSVidWebDVD_get_EnableResetOnStop(This,pVal)	\
    (This)->lpVtbl -> get_EnableResetOnStop(This,pVal)

#define IMSVidWebDVD_put_EnableResetOnStop(This,newVal)	\
    (This)->lpVtbl -> put_EnableResetOnStop(This,newVal)

#define IMSVidWebDVD_Run(This)	\
    (This)->lpVtbl -> Run(This)

#define IMSVidWebDVD_Pause(This)	\
    (This)->lpVtbl -> Pause(This)

#define IMSVidWebDVD_Stop(This)	\
    (This)->lpVtbl -> Stop(This)

#define IMSVidWebDVD_get_CanStep(This,fBackwards,pfCan)	\
    (This)->lpVtbl -> get_CanStep(This,fBackwards,pfCan)

#define IMSVidWebDVD_Step(This,lStep)	\
    (This)->lpVtbl -> Step(This,lStep)

#define IMSVidWebDVD_put_Rate(This,plRate)	\
    (This)->lpVtbl -> put_Rate(This,plRate)

#define IMSVidWebDVD_get_Rate(This,plRate)	\
    (This)->lpVtbl -> get_Rate(This,plRate)

#define IMSVidWebDVD_put_CurrentPosition(This,lPosition)	\
    (This)->lpVtbl -> put_CurrentPosition(This,lPosition)

#define IMSVidWebDVD_get_CurrentPosition(This,lPosition)	\
    (This)->lpVtbl -> get_CurrentPosition(This,lPosition)

#define IMSVidWebDVD_put_PositionMode(This,lPositionMode)	\
    (This)->lpVtbl -> put_PositionMode(This,lPositionMode)

#define IMSVidWebDVD_get_PositionMode(This,lPositionMode)	\
    (This)->lpVtbl -> get_PositionMode(This,lPositionMode)

#define IMSVidWebDVD_get_Length(This,lLength)	\
    (This)->lpVtbl -> get_Length(This,lLength)


#define IMSVidWebDVD_OnDVDEvent(This,lEvent,lParam1,lParam2)	\
    (This)->lpVtbl -> OnDVDEvent(This,lEvent,lParam1,lParam2)

#define IMSVidWebDVD_PlayTitle(This,lTitle)	\
    (This)->lpVtbl -> PlayTitle(This,lTitle)

#define IMSVidWebDVD_PlayChapterInTitle(This,lTitle,lChapter)	\
    (This)->lpVtbl -> PlayChapterInTitle(This,lTitle,lChapter)

#define IMSVidWebDVD_PlayChapter(This,lChapter)	\
    (This)->lpVtbl -> PlayChapter(This,lChapter)

#define IMSVidWebDVD_PlayChaptersAutoStop(This,lTitle,lstrChapter,lChapterCount)	\
    (This)->lpVtbl -> PlayChaptersAutoStop(This,lTitle,lstrChapter,lChapterCount)

#define IMSVidWebDVD_PlayAtTime(This,strTime)	\
    (This)->lpVtbl -> PlayAtTime(This,strTime)

#define IMSVidWebDVD_PlayAtTimeInTitle(This,lTitle,strTime)	\
    (This)->lpVtbl -> PlayAtTimeInTitle(This,lTitle,strTime)

#define IMSVidWebDVD_PlayPeriodInTitleAutoStop(This,lTitle,strStartTime,strEndTime)	\
    (This)->lpVtbl -> PlayPeriodInTitleAutoStop(This,lTitle,strStartTime,strEndTime)

#define IMSVidWebDVD_ReplayChapter(This)	\
    (This)->lpVtbl -> ReplayChapter(This)

#define IMSVidWebDVD_PlayPrevChapter(This)	\
    (This)->lpVtbl -> PlayPrevChapter(This)

#define IMSVidWebDVD_PlayNextChapter(This)	\
    (This)->lpVtbl -> PlayNextChapter(This)

#define IMSVidWebDVD_StillOff(This)	\
    (This)->lpVtbl -> StillOff(This)

#define IMSVidWebDVD_get_AudioLanguage(This,lStream,fFormat,strAudioLang)	\
    (This)->lpVtbl -> get_AudioLanguage(This,lStream,fFormat,strAudioLang)

#define IMSVidWebDVD_ShowMenu(This,MenuID)	\
    (This)->lpVtbl -> ShowMenu(This,MenuID)

#define IMSVidWebDVD_Resume(This)	\
    (This)->lpVtbl -> Resume(This)

#define IMSVidWebDVD_ReturnFromSubmenu(This)	\
    (This)->lpVtbl -> ReturnFromSubmenu(This)

#define IMSVidWebDVD_get_ButtonsAvailable(This,pVal)	\
    (This)->lpVtbl -> get_ButtonsAvailable(This,pVal)

#define IMSVidWebDVD_get_CurrentButton(This,pVal)	\
    (This)->lpVtbl -> get_CurrentButton(This,pVal)

#define IMSVidWebDVD_SelectAndActivateButton(This,lButton)	\
    (This)->lpVtbl -> SelectAndActivateButton(This,lButton)

#define IMSVidWebDVD_ActivateButton(This)	\
    (This)->lpVtbl -> ActivateButton(This)

#define IMSVidWebDVD_SelectRightButton(This)	\
    (This)->lpVtbl -> SelectRightButton(This)

#define IMSVidWebDVD_SelectLeftButton(This)	\
    (This)->lpVtbl -> SelectLeftButton(This)

#define IMSVidWebDVD_SelectLowerButton(This)	\
    (This)->lpVtbl -> SelectLowerButton(This)

#define IMSVidWebDVD_SelectUpperButton(This)	\
    (This)->lpVtbl -> SelectUpperButton(This)

#define IMSVidWebDVD_ActivateAtPosition(This,xPos,yPos)	\
    (This)->lpVtbl -> ActivateAtPosition(This,xPos,yPos)

#define IMSVidWebDVD_SelectAtPosition(This,xPos,yPos)	\
    (This)->lpVtbl -> SelectAtPosition(This,xPos,yPos)

#define IMSVidWebDVD_get_ButtonAtPosition(This,xPos,yPos,plButton)	\
    (This)->lpVtbl -> get_ButtonAtPosition(This,xPos,yPos,plButton)

#define IMSVidWebDVD_get_NumberOfChapters(This,lTitle,pVal)	\
    (This)->lpVtbl -> get_NumberOfChapters(This,lTitle,pVal)

#define IMSVidWebDVD_get_TotalTitleTime(This,pVal)	\
    (This)->lpVtbl -> get_TotalTitleTime(This,pVal)

#define IMSVidWebDVD_get_TitlesAvailable(This,pVal)	\
    (This)->lpVtbl -> get_TitlesAvailable(This,pVal)

#define IMSVidWebDVD_get_VolumesAvailable(This,pVal)	\
    (This)->lpVtbl -> get_VolumesAvailable(This,pVal)

#define IMSVidWebDVD_get_CurrentVolume(This,pVal)	\
    (This)->lpVtbl -> get_CurrentVolume(This,pVal)

#define IMSVidWebDVD_get_CurrentDiscSide(This,pVal)	\
    (This)->lpVtbl -> get_CurrentDiscSide(This,pVal)

#define IMSVidWebDVD_get_CurrentDomain(This,pVal)	\
    (This)->lpVtbl -> get_CurrentDomain(This,pVal)

#define IMSVidWebDVD_get_CurrentChapter(This,pVal)	\
    (This)->lpVtbl -> get_CurrentChapter(This,pVal)

#define IMSVidWebDVD_get_CurrentTitle(This,pVal)	\
    (This)->lpVtbl -> get_CurrentTitle(This,pVal)

#define IMSVidWebDVD_get_CurrentTime(This,pVal)	\
    (This)->lpVtbl -> get_CurrentTime(This,pVal)

#define IMSVidWebDVD_DVDTimeCode2bstr(This,timeCode,pTimeStr)	\
    (This)->lpVtbl -> DVDTimeCode2bstr(This,timeCode,pTimeStr)

#define IMSVidWebDVD_get_DVDDirectory(This,pVal)	\
    (This)->lpVtbl -> get_DVDDirectory(This,pVal)

#define IMSVidWebDVD_put_DVDDirectory(This,newVal)	\
    (This)->lpVtbl -> put_DVDDirectory(This,newVal)

#define IMSVidWebDVD_IsSubpictureStreamEnabled(This,lstream,fEnabled)	\
    (This)->lpVtbl -> IsSubpictureStreamEnabled(This,lstream,fEnabled)

#define IMSVidWebDVD_IsAudioStreamEnabled(This,lstream,fEnabled)	\
    (This)->lpVtbl -> IsAudioStreamEnabled(This,lstream,fEnabled)

#define IMSVidWebDVD_get_CurrentSubpictureStream(This,pVal)	\
    (This)->lpVtbl -> get_CurrentSubpictureStream(This,pVal)

#define IMSVidWebDVD_put_CurrentSubpictureStream(This,newVal)	\
    (This)->lpVtbl -> put_CurrentSubpictureStream(This,newVal)

#define IMSVidWebDVD_get_SubpictureLanguage(This,lStream,strLanguage)	\
    (This)->lpVtbl -> get_SubpictureLanguage(This,lStream,strLanguage)

#define IMSVidWebDVD_get_CurrentAudioStream(This,pVal)	\
    (This)->lpVtbl -> get_CurrentAudioStream(This,pVal)

#define IMSVidWebDVD_put_CurrentAudioStream(This,newVal)	\
    (This)->lpVtbl -> put_CurrentAudioStream(This,newVal)

#define IMSVidWebDVD_get_AudioStreamsAvailable(This,pVal)	\
    (This)->lpVtbl -> get_AudioStreamsAvailable(This,pVal)

#define IMSVidWebDVD_get_AnglesAvailable(This,pVal)	\
    (This)->lpVtbl -> get_AnglesAvailable(This,pVal)

#define IMSVidWebDVD_get_CurrentAngle(This,pVal)	\
    (This)->lpVtbl -> get_CurrentAngle(This,pVal)

#define IMSVidWebDVD_put_CurrentAngle(This,newVal)	\
    (This)->lpVtbl -> put_CurrentAngle(This,newVal)

#define IMSVidWebDVD_get_SubpictureStreamsAvailable(This,pVal)	\
    (This)->lpVtbl -> get_SubpictureStreamsAvailable(This,pVal)

#define IMSVidWebDVD_get_SubpictureOn(This,pVal)	\
    (This)->lpVtbl -> get_SubpictureOn(This,pVal)

#define IMSVidWebDVD_put_SubpictureOn(This,newVal)	\
    (This)->lpVtbl -> put_SubpictureOn(This,newVal)

#define IMSVidWebDVD_get_DVDUniqueID(This,pVal)	\
    (This)->lpVtbl -> get_DVDUniqueID(This,pVal)

#define IMSVidWebDVD_AcceptParentalLevelChange(This,fAccept,strUserName,strPassword)	\
    (This)->lpVtbl -> AcceptParentalLevelChange(This,fAccept,strUserName,strPassword)

#define IMSVidWebDVD_NotifyParentalLevelChange(This,newVal)	\
    (This)->lpVtbl -> NotifyParentalLevelChange(This,newVal)

#define IMSVidWebDVD_SelectParentalCountry(This,lCountry,strUserName,strPassword)	\
    (This)->lpVtbl -> SelectParentalCountry(This,lCountry,strUserName,strPassword)

#define IMSVidWebDVD_SelectParentalLevel(This,lParentalLevel,strUserName,strPassword)	\
    (This)->lpVtbl -> SelectParentalLevel(This,lParentalLevel,strUserName,strPassword)

#define IMSVidWebDVD_get_TitleParentalLevels(This,lTitle,plParentalLevels)	\
    (This)->lpVtbl -> get_TitleParentalLevels(This,lTitle,plParentalLevels)

#define IMSVidWebDVD_get_PlayerParentalCountry(This,plCountryCode)	\
    (This)->lpVtbl -> get_PlayerParentalCountry(This,plCountryCode)

#define IMSVidWebDVD_get_PlayerParentalLevel(This,plParentalLevel)	\
    (This)->lpVtbl -> get_PlayerParentalLevel(This,plParentalLevel)

#define IMSVidWebDVD_Eject(This)	\
    (This)->lpVtbl -> Eject(This)

#define IMSVidWebDVD_UOPValid(This,lUOP,pfValid)	\
    (This)->lpVtbl -> UOPValid(This,lUOP,pfValid)

#define IMSVidWebDVD_get_SPRM(This,lIndex,psSPRM)	\
    (This)->lpVtbl -> get_SPRM(This,lIndex,psSPRM)

#define IMSVidWebDVD_get_GPRM(This,lIndex,psSPRM)	\
    (This)->lpVtbl -> get_GPRM(This,lIndex,psSPRM)

#define IMSVidWebDVD_put_GPRM(This,lIndex,sValue)	\
    (This)->lpVtbl -> put_GPRM(This,lIndex,sValue)

#define IMSVidWebDVD_get_DVDTextStringType(This,lLangIndex,lStringIndex,pType)	\
    (This)->lpVtbl -> get_DVDTextStringType(This,lLangIndex,lStringIndex,pType)

#define IMSVidWebDVD_get_DVDTextString(This,lLangIndex,lStringIndex,pstrText)	\
    (This)->lpVtbl -> get_DVDTextString(This,lLangIndex,lStringIndex,pstrText)

#define IMSVidWebDVD_get_DVDTextNumberOfStrings(This,lLangIndex,plNumOfStrings)	\
    (This)->lpVtbl -> get_DVDTextNumberOfStrings(This,lLangIndex,plNumOfStrings)

#define IMSVidWebDVD_get_DVDTextNumberOfLanguages(This,plNumOfLangs)	\
    (This)->lpVtbl -> get_DVDTextNumberOfLanguages(This,plNumOfLangs)

#define IMSVidWebDVD_get_DVDTextLanguageLCID(This,lLangIndex,lcid)	\
    (This)->lpVtbl -> get_DVDTextLanguageLCID(This,lLangIndex,lcid)

#define IMSVidWebDVD_RegionChange(This)	\
    (This)->lpVtbl -> RegionChange(This)

#define IMSVidWebDVD_get_DVDAdm(This,pVal)	\
    (This)->lpVtbl -> get_DVDAdm(This,pVal)

#define IMSVidWebDVD_DeleteBookmark(This)	\
    (This)->lpVtbl -> DeleteBookmark(This)

#define IMSVidWebDVD_RestoreBookmark(This)	\
    (This)->lpVtbl -> RestoreBookmark(This)

#define IMSVidWebDVD_SaveBookmark(This)	\
    (This)->lpVtbl -> SaveBookmark(This)

#define IMSVidWebDVD_SelectDefaultAudioLanguage(This,lang,ext)	\
    (This)->lpVtbl -> SelectDefaultAudioLanguage(This,lang,ext)

#define IMSVidWebDVD_SelectDefaultSubpictureLanguage(This,lang,ext)	\
    (This)->lpVtbl -> SelectDefaultSubpictureLanguage(This,lang,ext)

#define IMSVidWebDVD_get_PreferredSubpictureStream(This,pVal)	\
    (This)->lpVtbl -> get_PreferredSubpictureStream(This,pVal)

#define IMSVidWebDVD_get_DefaultMenuLanguage(This,lang)	\
    (This)->lpVtbl -> get_DefaultMenuLanguage(This,lang)

#define IMSVidWebDVD_put_DefaultMenuLanguage(This,lang)	\
    (This)->lpVtbl -> put_DefaultMenuLanguage(This,lang)

#define IMSVidWebDVD_get_DefaultSubpictureLanguage(This,lang)	\
    (This)->lpVtbl -> get_DefaultSubpictureLanguage(This,lang)

#define IMSVidWebDVD_get_DefaultAudioLanguage(This,lang)	\
    (This)->lpVtbl -> get_DefaultAudioLanguage(This,lang)

#define IMSVidWebDVD_get_DefaultSubpictureLanguageExt(This,ext)	\
    (This)->lpVtbl -> get_DefaultSubpictureLanguageExt(This,ext)

#define IMSVidWebDVD_get_DefaultAudioLanguageExt(This,ext)	\
    (This)->lpVtbl -> get_DefaultAudioLanguageExt(This,ext)

#define IMSVidWebDVD_get_LanguageFromLCID(This,lcid,lang)	\
    (This)->lpVtbl -> get_LanguageFromLCID(This,lcid,lang)

#define IMSVidWebDVD_get_KaraokeAudioPresentationMode(This,pVal)	\
    (This)->lpVtbl -> get_KaraokeAudioPresentationMode(This,pVal)

#define IMSVidWebDVD_put_KaraokeAudioPresentationMode(This,newVal)	\
    (This)->lpVtbl -> put_KaraokeAudioPresentationMode(This,newVal)

#define IMSVidWebDVD_get_KaraokeChannelContent(This,lStream,lChan,lContent)	\
    (This)->lpVtbl -> get_KaraokeChannelContent(This,lStream,lChan,lContent)

#define IMSVidWebDVD_get_KaraokeChannelAssignment(This,lStream,lChannelAssignment)	\
    (This)->lpVtbl -> get_KaraokeChannelAssignment(This,lStream,lChannelAssignment)

#define IMSVidWebDVD_RestorePreferredSettings(This)	\
    (This)->lpVtbl -> RestorePreferredSettings(This)

#define IMSVidWebDVD_get_ButtonRect(This,lButton,pRect)	\
    (This)->lpVtbl -> get_ButtonRect(This,lButton,pRect)

#define IMSVidWebDVD_get_DVDScreenInMouseCoordinates(This,ppRect)	\
    (This)->lpVtbl -> get_DVDScreenInMouseCoordinates(This,ppRect)

#define IMSVidWebDVD_put_DVDScreenInMouseCoordinates(This,pRect)	\
    (This)->lpVtbl -> put_DVDScreenInMouseCoordinates(This,pRect)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMSVidWebDVD_OnDVDEvent_Proxy( 
    IMSVidWebDVD * This,
    /* [in] */ long lEvent,
    /* [in] */ LONG_PTR lParam1,
    /* [in] */ LONG_PTR lParam2);


void __RPC_STUB IMSVidWebDVD_OnDVDEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_PlayTitle_Proxy( 
    IMSVidWebDVD * This,
    /* [in] */ long lTitle);


void __RPC_STUB IMSVidWebDVD_PlayTitle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_PlayChapterInTitle_Proxy( 
    IMSVidWebDVD * This,
    /* [in] */ long lTitle,
    /* [in] */ long lChapter);


void __RPC_STUB IMSVidWebDVD_PlayChapterInTitle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_PlayChapter_Proxy( 
    IMSVidWebDVD * This,
    /* [in] */ long lChapter);


void __RPC_STUB IMSVidWebDVD_PlayChapter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_PlayChaptersAutoStop_Proxy( 
    IMSVidWebDVD * This,
    /* [in] */ long lTitle,
    /* [in] */ long lstrChapter,
    /* [in] */ long lChapterCount);


void __RPC_STUB IMSVidWebDVD_PlayChaptersAutoStop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_PlayAtTime_Proxy( 
    IMSVidWebDVD * This,
    /* [in] */ BSTR strTime);


void __RPC_STUB IMSVidWebDVD_PlayAtTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_PlayAtTimeInTitle_Proxy( 
    IMSVidWebDVD * This,
    /* [in] */ long lTitle,
    /* [in] */ BSTR strTime);


void __RPC_STUB IMSVidWebDVD_PlayAtTimeInTitle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_PlayPeriodInTitleAutoStop_Proxy( 
    IMSVidWebDVD * This,
    /* [in] */ long lTitle,
    /* [in] */ BSTR strStartTime,
    /* [in] */ BSTR strEndTime);


void __RPC_STUB IMSVidWebDVD_PlayPeriodInTitleAutoStop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_ReplayChapter_Proxy( 
    IMSVidWebDVD * This);


void __RPC_STUB IMSVidWebDVD_ReplayChapter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_PlayPrevChapter_Proxy( 
    IMSVidWebDVD * This);


void __RPC_STUB IMSVidWebDVD_PlayPrevChapter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_PlayNextChapter_Proxy( 
    IMSVidWebDVD * This);


void __RPC_STUB IMSVidWebDVD_PlayNextChapter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_StillOff_Proxy( 
    IMSVidWebDVD * This);


void __RPC_STUB IMSVidWebDVD_StillOff_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_get_AudioLanguage_Proxy( 
    IMSVidWebDVD * This,
    /* [in] */ long lStream,
    /* [defaultvalue][in] */ VARIANT_BOOL fFormat,
    /* [retval][out] */ BSTR *strAudioLang);


void __RPC_STUB IMSVidWebDVD_get_AudioLanguage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_ShowMenu_Proxy( 
    IMSVidWebDVD * This,
    /* [in] */ DVDMenuIDConstants MenuID);


void __RPC_STUB IMSVidWebDVD_ShowMenu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_Resume_Proxy( 
    IMSVidWebDVD * This);


void __RPC_STUB IMSVidWebDVD_Resume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_ReturnFromSubmenu_Proxy( 
    IMSVidWebDVD * This);


void __RPC_STUB IMSVidWebDVD_ReturnFromSubmenu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_get_ButtonsAvailable_Proxy( 
    IMSVidWebDVD * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IMSVidWebDVD_get_ButtonsAvailable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_get_CurrentButton_Proxy( 
    IMSVidWebDVD * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IMSVidWebDVD_get_CurrentButton_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_SelectAndActivateButton_Proxy( 
    IMSVidWebDVD * This,
    /* [in] */ long lButton);


void __RPC_STUB IMSVidWebDVD_SelectAndActivateButton_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_ActivateButton_Proxy( 
    IMSVidWebDVD * This);


void __RPC_STUB IMSVidWebDVD_ActivateButton_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_SelectRightButton_Proxy( 
    IMSVidWebDVD * This);


void __RPC_STUB IMSVidWebDVD_SelectRightButton_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_SelectLeftButton_Proxy( 
    IMSVidWebDVD * This);


void __RPC_STUB IMSVidWebDVD_SelectLeftButton_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_SelectLowerButton_Proxy( 
    IMSVidWebDVD * This);


void __RPC_STUB IMSVidWebDVD_SelectLowerButton_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_SelectUpperButton_Proxy( 
    IMSVidWebDVD * This);


void __RPC_STUB IMSVidWebDVD_SelectUpperButton_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_ActivateAtPosition_Proxy( 
    IMSVidWebDVD * This,
    /* [in] */ long xPos,
    /* [in] */ long yPos);


void __RPC_STUB IMSVidWebDVD_ActivateAtPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_SelectAtPosition_Proxy( 
    IMSVidWebDVD * This,
    /* [in] */ long xPos,
    /* [in] */ long yPos);


void __RPC_STUB IMSVidWebDVD_SelectAtPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_get_ButtonAtPosition_Proxy( 
    IMSVidWebDVD * This,
    /* [in] */ long xPos,
    /* [in] */ long yPos,
    /* [retval][out] */ long *plButton);


void __RPC_STUB IMSVidWebDVD_get_ButtonAtPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_get_NumberOfChapters_Proxy( 
    IMSVidWebDVD * This,
    /* [in] */ long lTitle,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IMSVidWebDVD_get_NumberOfChapters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_get_TotalTitleTime_Proxy( 
    IMSVidWebDVD * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IMSVidWebDVD_get_TotalTitleTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_get_TitlesAvailable_Proxy( 
    IMSVidWebDVD * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IMSVidWebDVD_get_TitlesAvailable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_get_VolumesAvailable_Proxy( 
    IMSVidWebDVD * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IMSVidWebDVD_get_VolumesAvailable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_get_CurrentVolume_Proxy( 
    IMSVidWebDVD * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IMSVidWebDVD_get_CurrentVolume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_get_CurrentDiscSide_Proxy( 
    IMSVidWebDVD * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IMSVidWebDVD_get_CurrentDiscSide_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_get_CurrentDomain_Proxy( 
    IMSVidWebDVD * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IMSVidWebDVD_get_CurrentDomain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_get_CurrentChapter_Proxy( 
    IMSVidWebDVD * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IMSVidWebDVD_get_CurrentChapter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_get_CurrentTitle_Proxy( 
    IMSVidWebDVD * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IMSVidWebDVD_get_CurrentTitle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_get_CurrentTime_Proxy( 
    IMSVidWebDVD * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IMSVidWebDVD_get_CurrentTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_DVDTimeCode2bstr_Proxy( 
    IMSVidWebDVD * This,
    /* [in] */ long timeCode,
    /* [retval][out] */ BSTR *pTimeStr);


void __RPC_STUB IMSVidWebDVD_DVDTimeCode2bstr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_get_DVDDirectory_Proxy( 
    IMSVidWebDVD * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IMSVidWebDVD_get_DVDDirectory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_put_DVDDirectory_Proxy( 
    IMSVidWebDVD * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IMSVidWebDVD_put_DVDDirectory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_IsSubpictureStreamEnabled_Proxy( 
    IMSVidWebDVD * This,
    /* [in] */ long lstream,
    /* [retval][out] */ VARIANT_BOOL *fEnabled);


void __RPC_STUB IMSVidWebDVD_IsSubpictureStreamEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_IsAudioStreamEnabled_Proxy( 
    IMSVidWebDVD * This,
    /* [in] */ long lstream,
    /* [retval][out] */ VARIANT_BOOL *fEnabled);


void __RPC_STUB IMSVidWebDVD_IsAudioStreamEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_get_CurrentSubpictureStream_Proxy( 
    IMSVidWebDVD * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IMSVidWebDVD_get_CurrentSubpictureStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_put_CurrentSubpictureStream_Proxy( 
    IMSVidWebDVD * This,
    /* [in] */ long newVal);


void __RPC_STUB IMSVidWebDVD_put_CurrentSubpictureStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_get_SubpictureLanguage_Proxy( 
    IMSVidWebDVD * This,
    long lStream,
    /* [retval][out] */ BSTR *strLanguage);


void __RPC_STUB IMSVidWebDVD_get_SubpictureLanguage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_get_CurrentAudioStream_Proxy( 
    IMSVidWebDVD * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IMSVidWebDVD_get_CurrentAudioStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_put_CurrentAudioStream_Proxy( 
    IMSVidWebDVD * This,
    /* [in] */ long newVal);


void __RPC_STUB IMSVidWebDVD_put_CurrentAudioStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_get_AudioStreamsAvailable_Proxy( 
    IMSVidWebDVD * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IMSVidWebDVD_get_AudioStreamsAvailable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_get_AnglesAvailable_Proxy( 
    IMSVidWebDVD * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IMSVidWebDVD_get_AnglesAvailable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_get_CurrentAngle_Proxy( 
    IMSVidWebDVD * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IMSVidWebDVD_get_CurrentAngle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_put_CurrentAngle_Proxy( 
    IMSVidWebDVD * This,
    /* [in] */ long newVal);


void __RPC_STUB IMSVidWebDVD_put_CurrentAngle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_get_SubpictureStreamsAvailable_Proxy( 
    IMSVidWebDVD * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IMSVidWebDVD_get_SubpictureStreamsAvailable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_get_SubpictureOn_Proxy( 
    IMSVidWebDVD * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IMSVidWebDVD_get_SubpictureOn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_put_SubpictureOn_Proxy( 
    IMSVidWebDVD * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IMSVidWebDVD_put_SubpictureOn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_get_DVDUniqueID_Proxy( 
    IMSVidWebDVD * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IMSVidWebDVD_get_DVDUniqueID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_AcceptParentalLevelChange_Proxy( 
    IMSVidWebDVD * This,
    /* [in] */ VARIANT_BOOL fAccept,
    /* [in] */ BSTR strUserName,
    /* [in] */ BSTR strPassword);


void __RPC_STUB IMSVidWebDVD_AcceptParentalLevelChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_NotifyParentalLevelChange_Proxy( 
    IMSVidWebDVD * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IMSVidWebDVD_NotifyParentalLevelChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_SelectParentalCountry_Proxy( 
    IMSVidWebDVD * This,
    /* [in] */ long lCountry,
    /* [in] */ BSTR strUserName,
    /* [in] */ BSTR strPassword);


void __RPC_STUB IMSVidWebDVD_SelectParentalCountry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_SelectParentalLevel_Proxy( 
    IMSVidWebDVD * This,
    /* [in] */ long lParentalLevel,
    /* [in] */ BSTR strUserName,
    /* [in] */ BSTR strPassword);


void __RPC_STUB IMSVidWebDVD_SelectParentalLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_get_TitleParentalLevels_Proxy( 
    IMSVidWebDVD * This,
    /* [in] */ long lTitle,
    /* [retval][out] */ long *plParentalLevels);


void __RPC_STUB IMSVidWebDVD_get_TitleParentalLevels_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_get_PlayerParentalCountry_Proxy( 
    IMSVidWebDVD * This,
    /* [retval][out] */ long *plCountryCode);


void __RPC_STUB IMSVidWebDVD_get_PlayerParentalCountry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_get_PlayerParentalLevel_Proxy( 
    IMSVidWebDVD * This,
    /* [retval][out] */ long *plParentalLevel);


void __RPC_STUB IMSVidWebDVD_get_PlayerParentalLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_Eject_Proxy( 
    IMSVidWebDVD * This);


void __RPC_STUB IMSVidWebDVD_Eject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_UOPValid_Proxy( 
    IMSVidWebDVD * This,
    /* [in] */ long lUOP,
    /* [retval][out] */ VARIANT_BOOL *pfValid);


void __RPC_STUB IMSVidWebDVD_UOPValid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_get_SPRM_Proxy( 
    IMSVidWebDVD * This,
    /* [in] */ long lIndex,
    /* [retval][out] */ short *psSPRM);


void __RPC_STUB IMSVidWebDVD_get_SPRM_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_get_GPRM_Proxy( 
    IMSVidWebDVD * This,
    /* [in] */ long lIndex,
    /* [retval][out] */ short *psSPRM);


void __RPC_STUB IMSVidWebDVD_get_GPRM_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_put_GPRM_Proxy( 
    IMSVidWebDVD * This,
    /* [in] */ long lIndex,
    /* [in] */ short sValue);


void __RPC_STUB IMSVidWebDVD_put_GPRM_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_get_DVDTextStringType_Proxy( 
    IMSVidWebDVD * This,
    /* [in] */ long lLangIndex,
    /* [in] */ long lStringIndex,
    /* [retval][out] */ DVDTextStringType *pType);


void __RPC_STUB IMSVidWebDVD_get_DVDTextStringType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_get_DVDTextString_Proxy( 
    IMSVidWebDVD * This,
    /* [in] */ long lLangIndex,
    /* [in] */ long lStringIndex,
    /* [retval][out] */ BSTR *pstrText);


void __RPC_STUB IMSVidWebDVD_get_DVDTextString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_get_DVDTextNumberOfStrings_Proxy( 
    IMSVidWebDVD * This,
    /* [in] */ long lLangIndex,
    /* [retval][out] */ long *plNumOfStrings);


void __RPC_STUB IMSVidWebDVD_get_DVDTextNumberOfStrings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_get_DVDTextNumberOfLanguages_Proxy( 
    IMSVidWebDVD * This,
    /* [retval][out] */ long *plNumOfLangs);


void __RPC_STUB IMSVidWebDVD_get_DVDTextNumberOfLanguages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_get_DVDTextLanguageLCID_Proxy( 
    IMSVidWebDVD * This,
    /* [in] */ long lLangIndex,
    /* [retval][out] */ long *lcid);


void __RPC_STUB IMSVidWebDVD_get_DVDTextLanguageLCID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_RegionChange_Proxy( 
    IMSVidWebDVD * This);


void __RPC_STUB IMSVidWebDVD_RegionChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_get_DVDAdm_Proxy( 
    IMSVidWebDVD * This,
    /* [retval][out] */ IDispatch **pVal);


void __RPC_STUB IMSVidWebDVD_get_DVDAdm_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_DeleteBookmark_Proxy( 
    IMSVidWebDVD * This);


void __RPC_STUB IMSVidWebDVD_DeleteBookmark_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_RestoreBookmark_Proxy( 
    IMSVidWebDVD * This);


void __RPC_STUB IMSVidWebDVD_RestoreBookmark_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_SaveBookmark_Proxy( 
    IMSVidWebDVD * This);


void __RPC_STUB IMSVidWebDVD_SaveBookmark_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_SelectDefaultAudioLanguage_Proxy( 
    IMSVidWebDVD * This,
    /* [in] */ long lang,
    /* [in] */ long ext);


void __RPC_STUB IMSVidWebDVD_SelectDefaultAudioLanguage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_SelectDefaultSubpictureLanguage_Proxy( 
    IMSVidWebDVD * This,
    /* [in] */ long lang,
    /* [in] */ DVDSPExt ext);


void __RPC_STUB IMSVidWebDVD_SelectDefaultSubpictureLanguage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_get_PreferredSubpictureStream_Proxy( 
    IMSVidWebDVD * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IMSVidWebDVD_get_PreferredSubpictureStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_get_DefaultMenuLanguage_Proxy( 
    IMSVidWebDVD * This,
    /* [retval][out] */ long *lang);


void __RPC_STUB IMSVidWebDVD_get_DefaultMenuLanguage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_put_DefaultMenuLanguage_Proxy( 
    IMSVidWebDVD * This,
    /* [in] */ long lang);


void __RPC_STUB IMSVidWebDVD_put_DefaultMenuLanguage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_get_DefaultSubpictureLanguage_Proxy( 
    IMSVidWebDVD * This,
    /* [retval][out] */ long *lang);


void __RPC_STUB IMSVidWebDVD_get_DefaultSubpictureLanguage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_get_DefaultAudioLanguage_Proxy( 
    IMSVidWebDVD * This,
    /* [retval][out] */ long *lang);


void __RPC_STUB IMSVidWebDVD_get_DefaultAudioLanguage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_get_DefaultSubpictureLanguageExt_Proxy( 
    IMSVidWebDVD * This,
    /* [retval][out] */ DVDSPExt *ext);


void __RPC_STUB IMSVidWebDVD_get_DefaultSubpictureLanguageExt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_get_DefaultAudioLanguageExt_Proxy( 
    IMSVidWebDVD * This,
    /* [retval][out] */ long *ext);


void __RPC_STUB IMSVidWebDVD_get_DefaultAudioLanguageExt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_get_LanguageFromLCID_Proxy( 
    IMSVidWebDVD * This,
    /* [in] */ long lcid,
    /* [retval][out] */ BSTR *lang);


void __RPC_STUB IMSVidWebDVD_get_LanguageFromLCID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_get_KaraokeAudioPresentationMode_Proxy( 
    IMSVidWebDVD * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IMSVidWebDVD_get_KaraokeAudioPresentationMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_put_KaraokeAudioPresentationMode_Proxy( 
    IMSVidWebDVD * This,
    /* [in] */ long newVal);


void __RPC_STUB IMSVidWebDVD_put_KaraokeAudioPresentationMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_get_KaraokeChannelContent_Proxy( 
    IMSVidWebDVD * This,
    /* [in] */ long lStream,
    /* [in] */ long lChan,
    /* [retval][out] */ long *lContent);


void __RPC_STUB IMSVidWebDVD_get_KaraokeChannelContent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_get_KaraokeChannelAssignment_Proxy( 
    IMSVidWebDVD * This,
    /* [in] */ long lStream,
    /* [retval][out] */ long *lChannelAssignment);


void __RPC_STUB IMSVidWebDVD_get_KaraokeChannelAssignment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_RestorePreferredSettings_Proxy( 
    IMSVidWebDVD * This);


void __RPC_STUB IMSVidWebDVD_RestorePreferredSettings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_get_ButtonRect_Proxy( 
    IMSVidWebDVD * This,
    /* [in] */ long lButton,
    /* [retval][out] */ IMSVidRect **pRect);


void __RPC_STUB IMSVidWebDVD_get_ButtonRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_get_DVDScreenInMouseCoordinates_Proxy( 
    IMSVidWebDVD * This,
    /* [retval][out] */ IMSVidRect **ppRect);


void __RPC_STUB IMSVidWebDVD_get_DVDScreenInMouseCoordinates_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVD_put_DVDScreenInMouseCoordinates_Proxy( 
    IMSVidWebDVD * This,
    /* [in] */ IMSVidRect *pRect);


void __RPC_STUB IMSVidWebDVD_put_DVDScreenInMouseCoordinates_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSVidWebDVD_INTERFACE_DEFINED__ */


#ifndef __IMSVidWebDVDEvent_INTERFACE_DEFINED__
#define __IMSVidWebDVDEvent_INTERFACE_DEFINED__

/* interface IMSVidWebDVDEvent */
/* [unique][helpstring][uuid][hidden][oleautomation][object] */ 


EXTERN_C const IID IID_IMSVidWebDVDEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B4F7A674-9B83-49cb-A357-C63B871BE958")
    IMSVidWebDVDEvent : public IMSVidPlaybackEvent
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DVDNotify( 
            /* [in] */ long lEventCode,
            /* [in] */ VARIANT lParam1,
            /* [in] */ VARIANT lParam2) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PlayForwards( 
            /* [in] */ VARIANT_BOOL bEnabled) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PlayBackwards( 
            /* [in] */ VARIANT_BOOL bEnabled) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ShowMenu( 
            /* [in] */ DVDMenuIDConstants __MIDL_0019,
            /* [in] */ VARIANT_BOOL bEnabled) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Resume( 
            /* [in] */ VARIANT_BOOL bEnabled) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SelectOrActivateButton( 
            /* [in] */ VARIANT_BOOL bEnabled) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE StillOff( 
            /* [in] */ VARIANT_BOOL bEnabled) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PauseOn( 
            /* [in] */ VARIANT_BOOL bEnabled) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ChangeCurrentAudioStream( 
            /* [in] */ VARIANT_BOOL bEnabled) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ChangeCurrentSubpictureStream( 
            /* [in] */ VARIANT_BOOL bEnabled) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ChangeCurrentAngle( 
            /* [in] */ VARIANT_BOOL bEnabled) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PlayAtTimeInTitle( 
            /* [in] */ VARIANT_BOOL bEnabled) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PlayAtTime( 
            /* [in] */ VARIANT_BOOL bEnabled) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PlayChapterInTitle( 
            /* [in] */ VARIANT_BOOL bEnabled) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PlayChapter( 
            /* [in] */ VARIANT_BOOL bEnabled) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ReplayChapter( 
            /* [in] */ VARIANT_BOOL bEnabled) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PlayNextChapter( 
            /* [in] */ VARIANT_BOOL bEnabled) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Stop( 
            /* [in] */ VARIANT_BOOL bEnabled) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ReturnFromSubmenu( 
            /* [in] */ VARIANT_BOOL bEnabled) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PlayTitle( 
            /* [in] */ VARIANT_BOOL bEnabled) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PlayPrevChapter( 
            /* [in] */ VARIANT_BOOL bEnabled) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ChangeKaraokePresMode( 
            /* [in] */ VARIANT_BOOL bEnabled) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ChangeVideoPresMode( 
            /* [in] */ VARIANT_BOOL bEnabled) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSVidWebDVDEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSVidWebDVDEvent * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSVidWebDVDEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSVidWebDVDEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSVidWebDVDEvent * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSVidWebDVDEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSVidWebDVDEvent * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSVidWebDVDEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *EndOfMedia )( 
            IMSVidWebDVDEvent * This,
            /* [in] */ IMSVidPlayback *lpd);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DVDNotify )( 
            IMSVidWebDVDEvent * This,
            /* [in] */ long lEventCode,
            /* [in] */ VARIANT lParam1,
            /* [in] */ VARIANT lParam2);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *PlayForwards )( 
            IMSVidWebDVDEvent * This,
            /* [in] */ VARIANT_BOOL bEnabled);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *PlayBackwards )( 
            IMSVidWebDVDEvent * This,
            /* [in] */ VARIANT_BOOL bEnabled);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ShowMenu )( 
            IMSVidWebDVDEvent * This,
            /* [in] */ DVDMenuIDConstants __MIDL_0019,
            /* [in] */ VARIANT_BOOL bEnabled);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IMSVidWebDVDEvent * This,
            /* [in] */ VARIANT_BOOL bEnabled);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SelectOrActivateButton )( 
            IMSVidWebDVDEvent * This,
            /* [in] */ VARIANT_BOOL bEnabled);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StillOff )( 
            IMSVidWebDVDEvent * This,
            /* [in] */ VARIANT_BOOL bEnabled);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *PauseOn )( 
            IMSVidWebDVDEvent * This,
            /* [in] */ VARIANT_BOOL bEnabled);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ChangeCurrentAudioStream )( 
            IMSVidWebDVDEvent * This,
            /* [in] */ VARIANT_BOOL bEnabled);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ChangeCurrentSubpictureStream )( 
            IMSVidWebDVDEvent * This,
            /* [in] */ VARIANT_BOOL bEnabled);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ChangeCurrentAngle )( 
            IMSVidWebDVDEvent * This,
            /* [in] */ VARIANT_BOOL bEnabled);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *PlayAtTimeInTitle )( 
            IMSVidWebDVDEvent * This,
            /* [in] */ VARIANT_BOOL bEnabled);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *PlayAtTime )( 
            IMSVidWebDVDEvent * This,
            /* [in] */ VARIANT_BOOL bEnabled);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *PlayChapterInTitle )( 
            IMSVidWebDVDEvent * This,
            /* [in] */ VARIANT_BOOL bEnabled);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *PlayChapter )( 
            IMSVidWebDVDEvent * This,
            /* [in] */ VARIANT_BOOL bEnabled);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ReplayChapter )( 
            IMSVidWebDVDEvent * This,
            /* [in] */ VARIANT_BOOL bEnabled);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *PlayNextChapter )( 
            IMSVidWebDVDEvent * This,
            /* [in] */ VARIANT_BOOL bEnabled);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IMSVidWebDVDEvent * This,
            /* [in] */ VARIANT_BOOL bEnabled);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ReturnFromSubmenu )( 
            IMSVidWebDVDEvent * This,
            /* [in] */ VARIANT_BOOL bEnabled);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *PlayTitle )( 
            IMSVidWebDVDEvent * This,
            /* [in] */ VARIANT_BOOL bEnabled);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *PlayPrevChapter )( 
            IMSVidWebDVDEvent * This,
            /* [in] */ VARIANT_BOOL bEnabled);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ChangeKaraokePresMode )( 
            IMSVidWebDVDEvent * This,
            /* [in] */ VARIANT_BOOL bEnabled);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ChangeVideoPresMode )( 
            IMSVidWebDVDEvent * This,
            /* [in] */ VARIANT_BOOL bEnabled);
        
        END_INTERFACE
    } IMSVidWebDVDEventVtbl;

    interface IMSVidWebDVDEvent
    {
        CONST_VTBL struct IMSVidWebDVDEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSVidWebDVDEvent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSVidWebDVDEvent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSVidWebDVDEvent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSVidWebDVDEvent_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSVidWebDVDEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSVidWebDVDEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSVidWebDVDEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)



#define IMSVidWebDVDEvent_EndOfMedia(This,lpd)	\
    (This)->lpVtbl -> EndOfMedia(This,lpd)


#define IMSVidWebDVDEvent_DVDNotify(This,lEventCode,lParam1,lParam2)	\
    (This)->lpVtbl -> DVDNotify(This,lEventCode,lParam1,lParam2)

#define IMSVidWebDVDEvent_PlayForwards(This,bEnabled)	\
    (This)->lpVtbl -> PlayForwards(This,bEnabled)

#define IMSVidWebDVDEvent_PlayBackwards(This,bEnabled)	\
    (This)->lpVtbl -> PlayBackwards(This,bEnabled)

#define IMSVidWebDVDEvent_ShowMenu(This,__MIDL_0019,bEnabled)	\
    (This)->lpVtbl -> ShowMenu(This,__MIDL_0019,bEnabled)

#define IMSVidWebDVDEvent_Resume(This,bEnabled)	\
    (This)->lpVtbl -> Resume(This,bEnabled)

#define IMSVidWebDVDEvent_SelectOrActivateButton(This,bEnabled)	\
    (This)->lpVtbl -> SelectOrActivateButton(This,bEnabled)

#define IMSVidWebDVDEvent_StillOff(This,bEnabled)	\
    (This)->lpVtbl -> StillOff(This,bEnabled)

#define IMSVidWebDVDEvent_PauseOn(This,bEnabled)	\
    (This)->lpVtbl -> PauseOn(This,bEnabled)

#define IMSVidWebDVDEvent_ChangeCurrentAudioStream(This,bEnabled)	\
    (This)->lpVtbl -> ChangeCurrentAudioStream(This,bEnabled)

#define IMSVidWebDVDEvent_ChangeCurrentSubpictureStream(This,bEnabled)	\
    (This)->lpVtbl -> ChangeCurrentSubpictureStream(This,bEnabled)

#define IMSVidWebDVDEvent_ChangeCurrentAngle(This,bEnabled)	\
    (This)->lpVtbl -> ChangeCurrentAngle(This,bEnabled)

#define IMSVidWebDVDEvent_PlayAtTimeInTitle(This,bEnabled)	\
    (This)->lpVtbl -> PlayAtTimeInTitle(This,bEnabled)

#define IMSVidWebDVDEvent_PlayAtTime(This,bEnabled)	\
    (This)->lpVtbl -> PlayAtTime(This,bEnabled)

#define IMSVidWebDVDEvent_PlayChapterInTitle(This,bEnabled)	\
    (This)->lpVtbl -> PlayChapterInTitle(This,bEnabled)

#define IMSVidWebDVDEvent_PlayChapter(This,bEnabled)	\
    (This)->lpVtbl -> PlayChapter(This,bEnabled)

#define IMSVidWebDVDEvent_ReplayChapter(This,bEnabled)	\
    (This)->lpVtbl -> ReplayChapter(This,bEnabled)

#define IMSVidWebDVDEvent_PlayNextChapter(This,bEnabled)	\
    (This)->lpVtbl -> PlayNextChapter(This,bEnabled)

#define IMSVidWebDVDEvent_Stop(This,bEnabled)	\
    (This)->lpVtbl -> Stop(This,bEnabled)

#define IMSVidWebDVDEvent_ReturnFromSubmenu(This,bEnabled)	\
    (This)->lpVtbl -> ReturnFromSubmenu(This,bEnabled)

#define IMSVidWebDVDEvent_PlayTitle(This,bEnabled)	\
    (This)->lpVtbl -> PlayTitle(This,bEnabled)

#define IMSVidWebDVDEvent_PlayPrevChapter(This,bEnabled)	\
    (This)->lpVtbl -> PlayPrevChapter(This,bEnabled)

#define IMSVidWebDVDEvent_ChangeKaraokePresMode(This,bEnabled)	\
    (This)->lpVtbl -> ChangeKaraokePresMode(This,bEnabled)

#define IMSVidWebDVDEvent_ChangeVideoPresMode(This,bEnabled)	\
    (This)->lpVtbl -> ChangeVideoPresMode(This,bEnabled)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVDEvent_DVDNotify_Proxy( 
    IMSVidWebDVDEvent * This,
    /* [in] */ long lEventCode,
    /* [in] */ VARIANT lParam1,
    /* [in] */ VARIANT lParam2);


void __RPC_STUB IMSVidWebDVDEvent_DVDNotify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVDEvent_PlayForwards_Proxy( 
    IMSVidWebDVDEvent * This,
    /* [in] */ VARIANT_BOOL bEnabled);


void __RPC_STUB IMSVidWebDVDEvent_PlayForwards_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVDEvent_PlayBackwards_Proxy( 
    IMSVidWebDVDEvent * This,
    /* [in] */ VARIANT_BOOL bEnabled);


void __RPC_STUB IMSVidWebDVDEvent_PlayBackwards_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVDEvent_ShowMenu_Proxy( 
    IMSVidWebDVDEvent * This,
    /* [in] */ DVDMenuIDConstants __MIDL_0019,
    /* [in] */ VARIANT_BOOL bEnabled);


void __RPC_STUB IMSVidWebDVDEvent_ShowMenu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVDEvent_Resume_Proxy( 
    IMSVidWebDVDEvent * This,
    /* [in] */ VARIANT_BOOL bEnabled);


void __RPC_STUB IMSVidWebDVDEvent_Resume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVDEvent_SelectOrActivateButton_Proxy( 
    IMSVidWebDVDEvent * This,
    /* [in] */ VARIANT_BOOL bEnabled);


void __RPC_STUB IMSVidWebDVDEvent_SelectOrActivateButton_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVDEvent_StillOff_Proxy( 
    IMSVidWebDVDEvent * This,
    /* [in] */ VARIANT_BOOL bEnabled);


void __RPC_STUB IMSVidWebDVDEvent_StillOff_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVDEvent_PauseOn_Proxy( 
    IMSVidWebDVDEvent * This,
    /* [in] */ VARIANT_BOOL bEnabled);


void __RPC_STUB IMSVidWebDVDEvent_PauseOn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVDEvent_ChangeCurrentAudioStream_Proxy( 
    IMSVidWebDVDEvent * This,
    /* [in] */ VARIANT_BOOL bEnabled);


void __RPC_STUB IMSVidWebDVDEvent_ChangeCurrentAudioStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVDEvent_ChangeCurrentSubpictureStream_Proxy( 
    IMSVidWebDVDEvent * This,
    /* [in] */ VARIANT_BOOL bEnabled);


void __RPC_STUB IMSVidWebDVDEvent_ChangeCurrentSubpictureStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVDEvent_ChangeCurrentAngle_Proxy( 
    IMSVidWebDVDEvent * This,
    /* [in] */ VARIANT_BOOL bEnabled);


void __RPC_STUB IMSVidWebDVDEvent_ChangeCurrentAngle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVDEvent_PlayAtTimeInTitle_Proxy( 
    IMSVidWebDVDEvent * This,
    /* [in] */ VARIANT_BOOL bEnabled);


void __RPC_STUB IMSVidWebDVDEvent_PlayAtTimeInTitle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVDEvent_PlayAtTime_Proxy( 
    IMSVidWebDVDEvent * This,
    /* [in] */ VARIANT_BOOL bEnabled);


void __RPC_STUB IMSVidWebDVDEvent_PlayAtTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVDEvent_PlayChapterInTitle_Proxy( 
    IMSVidWebDVDEvent * This,
    /* [in] */ VARIANT_BOOL bEnabled);


void __RPC_STUB IMSVidWebDVDEvent_PlayChapterInTitle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVDEvent_PlayChapter_Proxy( 
    IMSVidWebDVDEvent * This,
    /* [in] */ VARIANT_BOOL bEnabled);


void __RPC_STUB IMSVidWebDVDEvent_PlayChapter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVDEvent_ReplayChapter_Proxy( 
    IMSVidWebDVDEvent * This,
    /* [in] */ VARIANT_BOOL bEnabled);


void __RPC_STUB IMSVidWebDVDEvent_ReplayChapter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVDEvent_PlayNextChapter_Proxy( 
    IMSVidWebDVDEvent * This,
    /* [in] */ VARIANT_BOOL bEnabled);


void __RPC_STUB IMSVidWebDVDEvent_PlayNextChapter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVDEvent_Stop_Proxy( 
    IMSVidWebDVDEvent * This,
    /* [in] */ VARIANT_BOOL bEnabled);


void __RPC_STUB IMSVidWebDVDEvent_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVDEvent_ReturnFromSubmenu_Proxy( 
    IMSVidWebDVDEvent * This,
    /* [in] */ VARIANT_BOOL bEnabled);


void __RPC_STUB IMSVidWebDVDEvent_ReturnFromSubmenu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVDEvent_PlayTitle_Proxy( 
    IMSVidWebDVDEvent * This,
    /* [in] */ VARIANT_BOOL bEnabled);


void __RPC_STUB IMSVidWebDVDEvent_PlayTitle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVDEvent_PlayPrevChapter_Proxy( 
    IMSVidWebDVDEvent * This,
    /* [in] */ VARIANT_BOOL bEnabled);


void __RPC_STUB IMSVidWebDVDEvent_PlayPrevChapter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVDEvent_ChangeKaraokePresMode_Proxy( 
    IMSVidWebDVDEvent * This,
    /* [in] */ VARIANT_BOOL bEnabled);


void __RPC_STUB IMSVidWebDVDEvent_ChangeKaraokePresMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVDEvent_ChangeVideoPresMode_Proxy( 
    IMSVidWebDVDEvent * This,
    /* [in] */ VARIANT_BOOL bEnabled);


void __RPC_STUB IMSVidWebDVDEvent_ChangeVideoPresMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSVidWebDVDEvent_INTERFACE_DEFINED__ */


#ifndef __IMSVidWebDVDAdm_INTERFACE_DEFINED__
#define __IMSVidWebDVDAdm_INTERFACE_DEFINED__

/* interface IMSVidWebDVDAdm */
/* [unique][helpstring][uuid][hidden][oleautomation][dual][object] */ 


EXTERN_C const IID IID_IMSVidWebDVDAdm;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B8BE681A-EB2C-47f0-B415-94D5452F0E05")
    IMSVidWebDVDAdm : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ChangePassword( 
            /* [in] */ BSTR strUserName,
            /* [in] */ BSTR strOld,
            /* [in] */ BSTR strNew) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SaveParentalLevel( 
            /* [in] */ long level,
            /* [in] */ BSTR strUserName,
            /* [in] */ BSTR strPassword) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SaveParentalCountry( 
            /* [in] */ long country,
            /* [in] */ BSTR strUserName,
            /* [in] */ BSTR strPassword) = 0;
        
        virtual /* [helpstring][restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE ConfirmPassword( 
            /* [in] */ BSTR strUserName,
            /* [in] */ BSTR strPassword,
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetParentalLevel( 
            /* [retval][out] */ long *lLevel) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetParentalCountry( 
            /* [retval][out] */ long *lCountry) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DefaultAudioLCID( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DefaultAudioLCID( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DefaultSubpictureLCID( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DefaultSubpictureLCID( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DefaultMenuLCID( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DefaultMenuLCID( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BookmarkOnStop( 
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_BookmarkOnStop( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSVidWebDVDAdmVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSVidWebDVDAdm * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSVidWebDVDAdm * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSVidWebDVDAdm * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSVidWebDVDAdm * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSVidWebDVDAdm * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSVidWebDVDAdm * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSVidWebDVDAdm * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ChangePassword )( 
            IMSVidWebDVDAdm * This,
            /* [in] */ BSTR strUserName,
            /* [in] */ BSTR strOld,
            /* [in] */ BSTR strNew);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SaveParentalLevel )( 
            IMSVidWebDVDAdm * This,
            /* [in] */ long level,
            /* [in] */ BSTR strUserName,
            /* [in] */ BSTR strPassword);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SaveParentalCountry )( 
            IMSVidWebDVDAdm * This,
            /* [in] */ long country,
            /* [in] */ BSTR strUserName,
            /* [in] */ BSTR strPassword);
        
        /* [helpstring][restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *ConfirmPassword )( 
            IMSVidWebDVDAdm * This,
            /* [in] */ BSTR strUserName,
            /* [in] */ BSTR strPassword,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetParentalLevel )( 
            IMSVidWebDVDAdm * This,
            /* [retval][out] */ long *lLevel);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetParentalCountry )( 
            IMSVidWebDVDAdm * This,
            /* [retval][out] */ long *lCountry);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DefaultAudioLCID )( 
            IMSVidWebDVDAdm * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DefaultAudioLCID )( 
            IMSVidWebDVDAdm * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DefaultSubpictureLCID )( 
            IMSVidWebDVDAdm * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DefaultSubpictureLCID )( 
            IMSVidWebDVDAdm * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DefaultMenuLCID )( 
            IMSVidWebDVDAdm * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DefaultMenuLCID )( 
            IMSVidWebDVDAdm * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BookmarkOnStop )( 
            IMSVidWebDVDAdm * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BookmarkOnStop )( 
            IMSVidWebDVDAdm * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        END_INTERFACE
    } IMSVidWebDVDAdmVtbl;

    interface IMSVidWebDVDAdm
    {
        CONST_VTBL struct IMSVidWebDVDAdmVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSVidWebDVDAdm_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSVidWebDVDAdm_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSVidWebDVDAdm_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSVidWebDVDAdm_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSVidWebDVDAdm_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSVidWebDVDAdm_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSVidWebDVDAdm_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSVidWebDVDAdm_ChangePassword(This,strUserName,strOld,strNew)	\
    (This)->lpVtbl -> ChangePassword(This,strUserName,strOld,strNew)

#define IMSVidWebDVDAdm_SaveParentalLevel(This,level,strUserName,strPassword)	\
    (This)->lpVtbl -> SaveParentalLevel(This,level,strUserName,strPassword)

#define IMSVidWebDVDAdm_SaveParentalCountry(This,country,strUserName,strPassword)	\
    (This)->lpVtbl -> SaveParentalCountry(This,country,strUserName,strPassword)

#define IMSVidWebDVDAdm_ConfirmPassword(This,strUserName,strPassword,pVal)	\
    (This)->lpVtbl -> ConfirmPassword(This,strUserName,strPassword,pVal)

#define IMSVidWebDVDAdm_GetParentalLevel(This,lLevel)	\
    (This)->lpVtbl -> GetParentalLevel(This,lLevel)

#define IMSVidWebDVDAdm_GetParentalCountry(This,lCountry)	\
    (This)->lpVtbl -> GetParentalCountry(This,lCountry)

#define IMSVidWebDVDAdm_get_DefaultAudioLCID(This,pVal)	\
    (This)->lpVtbl -> get_DefaultAudioLCID(This,pVal)

#define IMSVidWebDVDAdm_put_DefaultAudioLCID(This,newVal)	\
    (This)->lpVtbl -> put_DefaultAudioLCID(This,newVal)

#define IMSVidWebDVDAdm_get_DefaultSubpictureLCID(This,pVal)	\
    (This)->lpVtbl -> get_DefaultSubpictureLCID(This,pVal)

#define IMSVidWebDVDAdm_put_DefaultSubpictureLCID(This,newVal)	\
    (This)->lpVtbl -> put_DefaultSubpictureLCID(This,newVal)

#define IMSVidWebDVDAdm_get_DefaultMenuLCID(This,pVal)	\
    (This)->lpVtbl -> get_DefaultMenuLCID(This,pVal)

#define IMSVidWebDVDAdm_put_DefaultMenuLCID(This,newVal)	\
    (This)->lpVtbl -> put_DefaultMenuLCID(This,newVal)

#define IMSVidWebDVDAdm_get_BookmarkOnStop(This,pVal)	\
    (This)->lpVtbl -> get_BookmarkOnStop(This,pVal)

#define IMSVidWebDVDAdm_put_BookmarkOnStop(This,newVal)	\
    (This)->lpVtbl -> put_BookmarkOnStop(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVDAdm_ChangePassword_Proxy( 
    IMSVidWebDVDAdm * This,
    /* [in] */ BSTR strUserName,
    /* [in] */ BSTR strOld,
    /* [in] */ BSTR strNew);


void __RPC_STUB IMSVidWebDVDAdm_ChangePassword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVDAdm_SaveParentalLevel_Proxy( 
    IMSVidWebDVDAdm * This,
    /* [in] */ long level,
    /* [in] */ BSTR strUserName,
    /* [in] */ BSTR strPassword);


void __RPC_STUB IMSVidWebDVDAdm_SaveParentalLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVDAdm_SaveParentalCountry_Proxy( 
    IMSVidWebDVDAdm * This,
    /* [in] */ long country,
    /* [in] */ BSTR strUserName,
    /* [in] */ BSTR strPassword);


void __RPC_STUB IMSVidWebDVDAdm_SaveParentalCountry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVDAdm_ConfirmPassword_Proxy( 
    IMSVidWebDVDAdm * This,
    /* [in] */ BSTR strUserName,
    /* [in] */ BSTR strPassword,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IMSVidWebDVDAdm_ConfirmPassword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVDAdm_GetParentalLevel_Proxy( 
    IMSVidWebDVDAdm * This,
    /* [retval][out] */ long *lLevel);


void __RPC_STUB IMSVidWebDVDAdm_GetParentalLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVDAdm_GetParentalCountry_Proxy( 
    IMSVidWebDVDAdm * This,
    /* [retval][out] */ long *lCountry);


void __RPC_STUB IMSVidWebDVDAdm_GetParentalCountry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVDAdm_get_DefaultAudioLCID_Proxy( 
    IMSVidWebDVDAdm * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IMSVidWebDVDAdm_get_DefaultAudioLCID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVDAdm_put_DefaultAudioLCID_Proxy( 
    IMSVidWebDVDAdm * This,
    /* [in] */ long newVal);


void __RPC_STUB IMSVidWebDVDAdm_put_DefaultAudioLCID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVDAdm_get_DefaultSubpictureLCID_Proxy( 
    IMSVidWebDVDAdm * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IMSVidWebDVDAdm_get_DefaultSubpictureLCID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVDAdm_put_DefaultSubpictureLCID_Proxy( 
    IMSVidWebDVDAdm * This,
    /* [in] */ long newVal);


void __RPC_STUB IMSVidWebDVDAdm_put_DefaultSubpictureLCID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVDAdm_get_DefaultMenuLCID_Proxy( 
    IMSVidWebDVDAdm * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IMSVidWebDVDAdm_get_DefaultMenuLCID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVDAdm_put_DefaultMenuLCID_Proxy( 
    IMSVidWebDVDAdm * This,
    /* [in] */ long newVal);


void __RPC_STUB IMSVidWebDVDAdm_put_DefaultMenuLCID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVDAdm_get_BookmarkOnStop_Proxy( 
    IMSVidWebDVDAdm * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IMSVidWebDVDAdm_get_BookmarkOnStop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSVidWebDVDAdm_put_BookmarkOnStop_Proxy( 
    IMSVidWebDVDAdm * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IMSVidWebDVDAdm_put_BookmarkOnStop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSVidWebDVDAdm_INTERFACE_DEFINED__ */


#ifndef __IMSVidOutputDevice_INTERFACE_DEFINED__
#define __IMSVidOutputDevice_INTERFACE_DEFINED__

/* interface IMSVidOutputDevice */
/* [unique][helpstring][uuid][oleautomation][dual][object] */ 


EXTERN_C const IID IID_IMSVidOutputDevice;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("37B03546-A4C8-11d2-B634-00C04F79498E")
    IMSVidOutputDevice : public IMSVidDevice
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IMSVidOutputDeviceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSVidOutputDevice * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSVidOutputDevice * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSVidOutputDevice * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSVidOutputDevice * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSVidOutputDevice * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSVidOutputDevice * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSVidOutputDevice * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IMSVidOutputDevice * This,
            /* [retval][out] */ BSTR *Name);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            IMSVidOutputDevice * This,
            /* [retval][out] */ long *Status);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Power )( 
            IMSVidOutputDevice * This,
            /* [in] */ VARIANT_BOOL Power);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Power )( 
            IMSVidOutputDevice * This,
            /* [out][retval] */ VARIANT_BOOL *Power);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Category )( 
            IMSVidOutputDevice * This,
            /* [retval][out] */ BSTR *Guid);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClassID )( 
            IMSVidOutputDevice * This,
            /* [retval][out] */ BSTR *Clsid);
        
        /* [restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__Category )( 
            IMSVidOutputDevice * This,
            /* [retval][out] */ GUID *Guid);
        
        /* [restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__ClassID )( 
            IMSVidOutputDevice * This,
            /* [retval][out] */ GUID *Clsid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsEqualDevice )( 
            IMSVidOutputDevice * This,
            /* [in] */ IMSVidDevice *Device,
            /* [retval][out] */ VARIANT_BOOL *IsEqual);
        
        END_INTERFACE
    } IMSVidOutputDeviceVtbl;

    interface IMSVidOutputDevice
    {
        CONST_VTBL struct IMSVidOutputDeviceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSVidOutputDevice_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSVidOutputDevice_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSVidOutputDevice_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSVidOutputDevice_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSVidOutputDevice_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSVidOutputDevice_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSVidOutputDevice_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSVidOutputDevice_get_Name(This,Name)	\
    (This)->lpVtbl -> get_Name(This,Name)

#define IMSVidOutputDevice_get_Status(This,Status)	\
    (This)->lpVtbl -> get_Status(This,Status)

#define IMSVidOutputDevice_put_Power(This,Power)	\
    (This)->lpVtbl -> put_Power(This,Power)

#define IMSVidOutputDevice_get_Power(This,Power)	\
    (This)->lpVtbl -> get_Power(This,Power)

#define IMSVidOutputDevice_get_Category(This,Guid)	\
    (This)->lpVtbl -> get_Category(This,Guid)

#define IMSVidOutputDevice_get_ClassID(This,Clsid)	\
    (This)->lpVtbl -> get_ClassID(This,Clsid)

#define IMSVidOutputDevice_get__Category(This,Guid)	\
    (This)->lpVtbl -> get__Category(This,Guid)

#define IMSVidOutputDevice_get__ClassID(This,Clsid)	\
    (This)->lpVtbl -> get__ClassID(This,Clsid)

#define IMSVidOutputDevice_IsEqualDevice(This,Device,IsEqual)	\
    (This)->lpVtbl -> IsEqualDevice(This,Device,IsEqual)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMSVidOutputDevice_INTERFACE_DEFINED__ */


#ifndef __IMSVidOutputDeviceEvent_INTERFACE_DEFINED__
#define __IMSVidOutputDeviceEvent_INTERFACE_DEFINED__

/* interface IMSVidOutputDeviceEvent */
/* [unique][helpstring][uuid][oleautomation][object] */ 


EXTERN_C const IID IID_IMSVidOutputDeviceEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2E6A14E2-571C-11d3-B652-00C04F79498E")
    IMSVidOutputDeviceEvent : public IMSVidDeviceEvent
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IMSVidOutputDeviceEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSVidOutputDeviceEvent * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSVidOutputDeviceEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSVidOutputDeviceEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSVidOutputDeviceEvent * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSVidOutputDeviceEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSVidOutputDeviceEvent * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSVidOutputDeviceEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *StateChange )( 
            IMSVidOutputDeviceEvent * This,
            /* [in] */ IMSVidDevice *lpd,
            /* [in] */ long oldState,
            /* [in] */ long newState);
        
        END_INTERFACE
    } IMSVidOutputDeviceEventVtbl;

    interface IMSVidOutputDeviceEvent
    {
        CONST_VTBL struct IMSVidOutputDeviceEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSVidOutputDeviceEvent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSVidOutputDeviceEvent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSVidOutputDeviceEvent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSVidOutputDeviceEvent_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSVidOutputDeviceEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSVidOutputDeviceEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSVidOutputDeviceEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSVidOutputDeviceEvent_StateChange(This,lpd,oldState,newState)	\
    (This)->lpVtbl -> StateChange(This,lpd,oldState,newState)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMSVidOutputDeviceEvent_INTERFACE_DEFINED__ */


#ifndef __IMSVidFeature_INTERFACE_DEFINED__
#define __IMSVidFeature_INTERFACE_DEFINED__

/* interface IMSVidFeature */
/* [unique][helpstring][uuid][oleautomation][dual][object] */ 


EXTERN_C const IID IID_IMSVidFeature;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("37B03547-A4C8-11d2-B634-00C04F79498E")
    IMSVidFeature : public IMSVidDevice
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IMSVidFeatureVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSVidFeature * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSVidFeature * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSVidFeature * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSVidFeature * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSVidFeature * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSVidFeature * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSVidFeature * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IMSVidFeature * This,
            /* [retval][out] */ BSTR *Name);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            IMSVidFeature * This,
            /* [retval][out] */ long *Status);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Power )( 
            IMSVidFeature * This,
            /* [in] */ VARIANT_BOOL Power);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Power )( 
            IMSVidFeature * This,
            /* [out][retval] */ VARIANT_BOOL *Power);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Category )( 
            IMSVidFeature * This,
            /* [retval][out] */ BSTR *Guid);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClassID )( 
            IMSVidFeature * This,
            /* [retval][out] */ BSTR *Clsid);
        
        /* [restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__Category )( 
            IMSVidFeature * This,
            /* [retval][out] */ GUID *Guid);
        
        /* [restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__ClassID )( 
            IMSVidFeature * This,
            /* [retval][out] */ GUID *Clsid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsEqualDevice )( 
            IMSVidFeature * This,
            /* [in] */ IMSVidDevice *Device,
            /* [retval][out] */ VARIANT_BOOL *IsEqual);
        
        END_INTERFACE
    } IMSVidFeatureVtbl;

    interface IMSVidFeature
    {
        CONST_VTBL struct IMSVidFeatureVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSVidFeature_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSVidFeature_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSVidFeature_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSVidFeature_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSVidFeature_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSVidFeature_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSVidFeature_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSVidFeature_get_Name(This,Name)	\
    (This)->lpVtbl -> get_Name(This,Name)

#define IMSVidFeature_get_Status(This,Status)	\
    (This)->lpVtbl -> get_Status(This,Status)

#define IMSVidFeature_put_Power(This,Power)	\
    (This)->lpVtbl -> put_Power(This,Power)

#define IMSVidFeature_get_Power(This,Power)	\
    (This)->lpVtbl -> get_Power(This,Power)

#define IMSVidFeature_get_Category(This,Guid)	\
    (This)->lpVtbl -> get_Category(This,Guid)

#define IMSVidFeature_get_ClassID(This,Clsid)	\
    (This)->lpVtbl -> get_ClassID(This,Clsid)

#define IMSVidFeature_get__Category(This,Guid)	\
    (This)->lpVtbl -> get__Category(This,Guid)

#define IMSVidFeature_get__ClassID(This,Clsid)	\
    (This)->lpVtbl -> get__ClassID(This,Clsid)

#define IMSVidFeature_IsEqualDevice(This,Device,IsEqual)	\
    (This)->lpVtbl -> IsEqualDevice(This,Device,IsEqual)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMSVidFeature_INTERFACE_DEFINED__ */


#ifndef __IMSVidFeatureEvent_INTERFACE_DEFINED__
#define __IMSVidFeatureEvent_INTERFACE_DEFINED__

/* interface IMSVidFeatureEvent */
/* [unique][helpstring][uuid][oleautomation][object] */ 


EXTERN_C const IID IID_IMSVidFeatureEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3DD2903C-E0AA-11d2-B63A-00C04F79498E")
    IMSVidFeatureEvent : public IMSVidDeviceEvent
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IMSVidFeatureEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSVidFeatureEvent * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSVidFeatureEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSVidFeatureEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSVidFeatureEvent * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSVidFeatureEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSVidFeatureEvent * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSVidFeatureEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *StateChange )( 
            IMSVidFeatureEvent * This,
            /* [in] */ IMSVidDevice *lpd,
            /* [in] */ long oldState,
            /* [in] */ long newState);
        
        END_INTERFACE
    } IMSVidFeatureEventVtbl;

    interface IMSVidFeatureEvent
    {
        CONST_VTBL struct IMSVidFeatureEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSVidFeatureEvent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSVidFeatureEvent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSVidFeatureEvent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSVidFeatureEvent_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSVidFeatureEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSVidFeatureEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSVidFeatureEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSVidFeatureEvent_StateChange(This,lpd,oldState,newState)	\
    (This)->lpVtbl -> StateChange(This,lpd,oldState,newState)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMSVidFeatureEvent_INTERFACE_DEFINED__ */


#ifndef __IMSVidEncoder_INTERFACE_DEFINED__
#define __IMSVidEncoder_INTERFACE_DEFINED__

/* interface IMSVidEncoder */
/* [unique][helpstring][uuid][oleautomation][dual][object] */ 


EXTERN_C const IID IID_IMSVidEncoder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C0020FD4-BEE7-43d9-A495-9F213117103D")
    IMSVidEncoder : public IMSVidFeature
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_VideoEncoderInterface( 
            /* [retval][out] */ IUnknown **ppEncInt) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_AudioEncoderInterface( 
            /* [retval][out] */ IUnknown **ppEncInt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSVidEncoderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSVidEncoder * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSVidEncoder * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSVidEncoder * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSVidEncoder * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSVidEncoder * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSVidEncoder * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSVidEncoder * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IMSVidEncoder * This,
            /* [retval][out] */ BSTR *Name);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            IMSVidEncoder * This,
            /* [retval][out] */ long *Status);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Power )( 
            IMSVidEncoder * This,
            /* [in] */ VARIANT_BOOL Power);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Power )( 
            IMSVidEncoder * This,
            /* [out][retval] */ VARIANT_BOOL *Power);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Category )( 
            IMSVidEncoder * This,
            /* [retval][out] */ BSTR *Guid);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClassID )( 
            IMSVidEncoder * This,
            /* [retval][out] */ BSTR *Clsid);
        
        /* [restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__Category )( 
            IMSVidEncoder * This,
            /* [retval][out] */ GUID *Guid);
        
        /* [restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__ClassID )( 
            IMSVidEncoder * This,
            /* [retval][out] */ GUID *Clsid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsEqualDevice )( 
            IMSVidEncoder * This,
            /* [in] */ IMSVidDevice *Device,
            /* [retval][out] */ VARIANT_BOOL *IsEqual);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_VideoEncoderInterface )( 
            IMSVidEncoder * This,
            /* [retval][out] */ IUnknown **ppEncInt);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AudioEncoderInterface )( 
            IMSVidEncoder * This,
            /* [retval][out] */ IUnknown **ppEncInt);
        
        END_INTERFACE
    } IMSVidEncoderVtbl;

    interface IMSVidEncoder
    {
        CONST_VTBL struct IMSVidEncoderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSVidEncoder_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSVidEncoder_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSVidEncoder_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSVidEncoder_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSVidEncoder_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSVidEncoder_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSVidEncoder_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSVidEncoder_get_Name(This,Name)	\
    (This)->lpVtbl -> get_Name(This,Name)

#define IMSVidEncoder_get_Status(This,Status)	\
    (This)->lpVtbl -> get_Status(This,Status)

#define IMSVidEncoder_put_Power(This,Power)	\
    (This)->lpVtbl -> put_Power(This,Power)

#define IMSVidEncoder_get_Power(This,Power)	\
    (This)->lpVtbl -> get_Power(This,Power)

#define IMSVidEncoder_get_Category(This,Guid)	\
    (This)->lpVtbl -> get_Category(This,Guid)

#define IMSVidEncoder_get_ClassID(This,Clsid)	\
    (This)->lpVtbl -> get_ClassID(This,Clsid)

#define IMSVidEncoder_get__Category(This,Guid)	\
    (This)->lpVtbl -> get__Category(This,Guid)

#define IMSVidEncoder_get__ClassID(This,Clsid)	\
    (This)->lpVtbl -> get__ClassID(This,Clsid)

#define IMSVidEncoder_IsEqualDevice(This,Device,IsEqual)	\
    (This)->lpVtbl -> IsEqualDevice(This,Device,IsEqual)



#define IMSVidEncoder_get_VideoEncoderInterface(This,ppEncInt)	\
    (This)->lpVtbl -> get_VideoEncoderInterface(This,ppEncInt)

#define IMSVidEncoder_get_AudioEncoderInterface(This,ppEncInt)	\
    (This)->lpVtbl -> get_AudioEncoderInterface(This,ppEncInt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidEncoder_get_VideoEncoderInterface_Proxy( 
    IMSVidEncoder * This,
    /* [retval][out] */ IUnknown **ppEncInt);


void __RPC_STUB IMSVidEncoder_get_VideoEncoderInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidEncoder_get_AudioEncoderInterface_Proxy( 
    IMSVidEncoder * This,
    /* [retval][out] */ IUnknown **ppEncInt);


void __RPC_STUB IMSVidEncoder_get_AudioEncoderInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSVidEncoder_INTERFACE_DEFINED__ */


#ifndef __IMSVidXDS_INTERFACE_DEFINED__
#define __IMSVidXDS_INTERFACE_DEFINED__

/* interface IMSVidXDS */
/* [unique][helpstring][uuid][oleautomation][dual][object] */ 


EXTERN_C const IID IID_IMSVidXDS;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("11EBC158-E712-4d1f-8BB3-01ED5274C4CE")
    IMSVidXDS : public IMSVidFeature
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IMSVidXDSVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSVidXDS * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSVidXDS * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSVidXDS * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSVidXDS * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSVidXDS * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSVidXDS * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSVidXDS * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IMSVidXDS * This,
            /* [retval][out] */ BSTR *Name);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            IMSVidXDS * This,
            /* [retval][out] */ long *Status);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Power )( 
            IMSVidXDS * This,
            /* [in] */ VARIANT_BOOL Power);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Power )( 
            IMSVidXDS * This,
            /* [out][retval] */ VARIANT_BOOL *Power);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Category )( 
            IMSVidXDS * This,
            /* [retval][out] */ BSTR *Guid);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClassID )( 
            IMSVidXDS * This,
            /* [retval][out] */ BSTR *Clsid);
        
        /* [restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__Category )( 
            IMSVidXDS * This,
            /* [retval][out] */ GUID *Guid);
        
        /* [restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__ClassID )( 
            IMSVidXDS * This,
            /* [retval][out] */ GUID *Clsid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsEqualDevice )( 
            IMSVidXDS * This,
            /* [in] */ IMSVidDevice *Device,
            /* [retval][out] */ VARIANT_BOOL *IsEqual);
        
        END_INTERFACE
    } IMSVidXDSVtbl;

    interface IMSVidXDS
    {
        CONST_VTBL struct IMSVidXDSVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSVidXDS_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSVidXDS_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSVidXDS_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSVidXDS_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSVidXDS_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSVidXDS_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSVidXDS_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSVidXDS_get_Name(This,Name)	\
    (This)->lpVtbl -> get_Name(This,Name)

#define IMSVidXDS_get_Status(This,Status)	\
    (This)->lpVtbl -> get_Status(This,Status)

#define IMSVidXDS_put_Power(This,Power)	\
    (This)->lpVtbl -> put_Power(This,Power)

#define IMSVidXDS_get_Power(This,Power)	\
    (This)->lpVtbl -> get_Power(This,Power)

#define IMSVidXDS_get_Category(This,Guid)	\
    (This)->lpVtbl -> get_Category(This,Guid)

#define IMSVidXDS_get_ClassID(This,Clsid)	\
    (This)->lpVtbl -> get_ClassID(This,Clsid)

#define IMSVidXDS_get__Category(This,Guid)	\
    (This)->lpVtbl -> get__Category(This,Guid)

#define IMSVidXDS_get__ClassID(This,Clsid)	\
    (This)->lpVtbl -> get__ClassID(This,Clsid)

#define IMSVidXDS_IsEqualDevice(This,Device,IsEqual)	\
    (This)->lpVtbl -> IsEqualDevice(This,Device,IsEqual)



#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMSVidXDS_INTERFACE_DEFINED__ */


#ifndef __IMSVidDataServices_INTERFACE_DEFINED__
#define __IMSVidDataServices_INTERFACE_DEFINED__

/* interface IMSVidDataServices */
/* [unique][helpstring][uuid][hidden][oleautomation][dual][object] */ 


EXTERN_C const IID IID_IMSVidDataServices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("334125C1-77E5-11d3-B653-00C04F79498E")
    IMSVidDataServices : public IMSVidFeature
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IMSVidDataServicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSVidDataServices * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSVidDataServices * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSVidDataServices * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSVidDataServices * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSVidDataServices * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSVidDataServices * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSVidDataServices * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IMSVidDataServices * This,
            /* [retval][out] */ BSTR *Name);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            IMSVidDataServices * This,
            /* [retval][out] */ long *Status);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Power )( 
            IMSVidDataServices * This,
            /* [in] */ VARIANT_BOOL Power);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Power )( 
            IMSVidDataServices * This,
            /* [out][retval] */ VARIANT_BOOL *Power);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Category )( 
            IMSVidDataServices * This,
            /* [retval][out] */ BSTR *Guid);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClassID )( 
            IMSVidDataServices * This,
            /* [retval][out] */ BSTR *Clsid);
        
        /* [restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__Category )( 
            IMSVidDataServices * This,
            /* [retval][out] */ GUID *Guid);
        
        /* [restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__ClassID )( 
            IMSVidDataServices * This,
            /* [retval][out] */ GUID *Clsid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsEqualDevice )( 
            IMSVidDataServices * This,
            /* [in] */ IMSVidDevice *Device,
            /* [retval][out] */ VARIANT_BOOL *IsEqual);
        
        END_INTERFACE
    } IMSVidDataServicesVtbl;

    interface IMSVidDataServices
    {
        CONST_VTBL struct IMSVidDataServicesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSVidDataServices_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSVidDataServices_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSVidDataServices_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSVidDataServices_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSVidDataServices_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSVidDataServices_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSVidDataServices_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSVidDataServices_get_Name(This,Name)	\
    (This)->lpVtbl -> get_Name(This,Name)

#define IMSVidDataServices_get_Status(This,Status)	\
    (This)->lpVtbl -> get_Status(This,Status)

#define IMSVidDataServices_put_Power(This,Power)	\
    (This)->lpVtbl -> put_Power(This,Power)

#define IMSVidDataServices_get_Power(This,Power)	\
    (This)->lpVtbl -> get_Power(This,Power)

#define IMSVidDataServices_get_Category(This,Guid)	\
    (This)->lpVtbl -> get_Category(This,Guid)

#define IMSVidDataServices_get_ClassID(This,Clsid)	\
    (This)->lpVtbl -> get_ClassID(This,Clsid)

#define IMSVidDataServices_get__Category(This,Guid)	\
    (This)->lpVtbl -> get__Category(This,Guid)

#define IMSVidDataServices_get__ClassID(This,Clsid)	\
    (This)->lpVtbl -> get__ClassID(This,Clsid)

#define IMSVidDataServices_IsEqualDevice(This,Device,IsEqual)	\
    (This)->lpVtbl -> IsEqualDevice(This,Device,IsEqual)



#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMSVidDataServices_INTERFACE_DEFINED__ */


#ifndef __IMSVidDataServicesEvent_INTERFACE_DEFINED__
#define __IMSVidDataServicesEvent_INTERFACE_DEFINED__

/* interface IMSVidDataServicesEvent */
/* [unique][helpstring][uuid][hidden][oleautomation][object] */ 


EXTERN_C const IID IID_IMSVidDataServicesEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("334125C2-77E5-11d3-B653-00C04F79498E")
    IMSVidDataServicesEvent : public IMSVidDeviceEvent
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IMSVidDataServicesEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSVidDataServicesEvent * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSVidDataServicesEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSVidDataServicesEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSVidDataServicesEvent * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSVidDataServicesEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSVidDataServicesEvent * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSVidDataServicesEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *StateChange )( 
            IMSVidDataServicesEvent * This,
            /* [in] */ IMSVidDevice *lpd,
            /* [in] */ long oldState,
            /* [in] */ long newState);
        
        END_INTERFACE
    } IMSVidDataServicesEventVtbl;

    interface IMSVidDataServicesEvent
    {
        CONST_VTBL struct IMSVidDataServicesEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSVidDataServicesEvent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSVidDataServicesEvent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSVidDataServicesEvent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSVidDataServicesEvent_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSVidDataServicesEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSVidDataServicesEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSVidDataServicesEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSVidDataServicesEvent_StateChange(This,lpd,oldState,newState)	\
    (This)->lpVtbl -> StateChange(This,lpd,oldState,newState)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMSVidDataServicesEvent_INTERFACE_DEFINED__ */


#ifndef __IMSVidClosedCaptioning_INTERFACE_DEFINED__
#define __IMSVidClosedCaptioning_INTERFACE_DEFINED__

/* interface IMSVidClosedCaptioning */
/* [unique][helpstring][uuid][hidden][oleautomation][dual][object] */ 


EXTERN_C const IID IID_IMSVidClosedCaptioning;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("99652EA1-C1F7-414f-BB7B-1C967DE75983")
    IMSVidClosedCaptioning : public IMSVidFeature
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Enable( 
            /* [retval][out] */ VARIANT_BOOL *On) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Enable( 
            /* [in] */ VARIANT_BOOL On) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSVidClosedCaptioningVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSVidClosedCaptioning * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSVidClosedCaptioning * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSVidClosedCaptioning * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSVidClosedCaptioning * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSVidClosedCaptioning * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSVidClosedCaptioning * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSVidClosedCaptioning * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IMSVidClosedCaptioning * This,
            /* [retval][out] */ BSTR *Name);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            IMSVidClosedCaptioning * This,
            /* [retval][out] */ long *Status);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Power )( 
            IMSVidClosedCaptioning * This,
            /* [in] */ VARIANT_BOOL Power);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Power )( 
            IMSVidClosedCaptioning * This,
            /* [out][retval] */ VARIANT_BOOL *Power);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Category )( 
            IMSVidClosedCaptioning * This,
            /* [retval][out] */ BSTR *Guid);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClassID )( 
            IMSVidClosedCaptioning * This,
            /* [retval][out] */ BSTR *Clsid);
        
        /* [restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__Category )( 
            IMSVidClosedCaptioning * This,
            /* [retval][out] */ GUID *Guid);
        
        /* [restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__ClassID )( 
            IMSVidClosedCaptioning * This,
            /* [retval][out] */ GUID *Clsid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsEqualDevice )( 
            IMSVidClosedCaptioning * This,
            /* [in] */ IMSVidDevice *Device,
            /* [retval][out] */ VARIANT_BOOL *IsEqual);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Enable )( 
            IMSVidClosedCaptioning * This,
            /* [retval][out] */ VARIANT_BOOL *On);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Enable )( 
            IMSVidClosedCaptioning * This,
            /* [in] */ VARIANT_BOOL On);
        
        END_INTERFACE
    } IMSVidClosedCaptioningVtbl;

    interface IMSVidClosedCaptioning
    {
        CONST_VTBL struct IMSVidClosedCaptioningVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSVidClosedCaptioning_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSVidClosedCaptioning_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSVidClosedCaptioning_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSVidClosedCaptioning_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSVidClosedCaptioning_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSVidClosedCaptioning_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSVidClosedCaptioning_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSVidClosedCaptioning_get_Name(This,Name)	\
    (This)->lpVtbl -> get_Name(This,Name)

#define IMSVidClosedCaptioning_get_Status(This,Status)	\
    (This)->lpVtbl -> get_Status(This,Status)

#define IMSVidClosedCaptioning_put_Power(This,Power)	\
    (This)->lpVtbl -> put_Power(This,Power)

#define IMSVidClosedCaptioning_get_Power(This,Power)	\
    (This)->lpVtbl -> get_Power(This,Power)

#define IMSVidClosedCaptioning_get_Category(This,Guid)	\
    (This)->lpVtbl -> get_Category(This,Guid)

#define IMSVidClosedCaptioning_get_ClassID(This,Clsid)	\
    (This)->lpVtbl -> get_ClassID(This,Clsid)

#define IMSVidClosedCaptioning_get__Category(This,Guid)	\
    (This)->lpVtbl -> get__Category(This,Guid)

#define IMSVidClosedCaptioning_get__ClassID(This,Clsid)	\
    (This)->lpVtbl -> get__ClassID(This,Clsid)

#define IMSVidClosedCaptioning_IsEqualDevice(This,Device,IsEqual)	\
    (This)->lpVtbl -> IsEqualDevice(This,Device,IsEqual)



#define IMSVidClosedCaptioning_get_Enable(This,On)	\
    (This)->lpVtbl -> get_Enable(This,On)

#define IMSVidClosedCaptioning_put_Enable(This,On)	\
    (This)->lpVtbl -> put_Enable(This,On)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidClosedCaptioning_get_Enable_Proxy( 
    IMSVidClosedCaptioning * This,
    /* [retval][out] */ VARIANT_BOOL *On);


void __RPC_STUB IMSVidClosedCaptioning_get_Enable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IMSVidClosedCaptioning_put_Enable_Proxy( 
    IMSVidClosedCaptioning * This,
    /* [in] */ VARIANT_BOOL On);


void __RPC_STUB IMSVidClosedCaptioning_put_Enable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSVidClosedCaptioning_INTERFACE_DEFINED__ */


#ifndef __IMSVidClosedCaptioning2_INTERFACE_DEFINED__
#define __IMSVidClosedCaptioning2_INTERFACE_DEFINED__

/* interface IMSVidClosedCaptioning2 */
/* [unique][helpstring][uuid][hidden][oleautomation][dual][object] */ 


EXTERN_C const IID IID_IMSVidClosedCaptioning2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E00CB864-A029-4310-9987-A873F5887D97")
    IMSVidClosedCaptioning2 : public IMSVidClosedCaptioning
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Service( 
            /* [retval][out] */ MSVidCCService *On) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Service( 
            /* [in] */ MSVidCCService On) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSVidClosedCaptioning2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSVidClosedCaptioning2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSVidClosedCaptioning2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSVidClosedCaptioning2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSVidClosedCaptioning2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSVidClosedCaptioning2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSVidClosedCaptioning2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSVidClosedCaptioning2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IMSVidClosedCaptioning2 * This,
            /* [retval][out] */ BSTR *Name);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            IMSVidClosedCaptioning2 * This,
            /* [retval][out] */ long *Status);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Power )( 
            IMSVidClosedCaptioning2 * This,
            /* [in] */ VARIANT_BOOL Power);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Power )( 
            IMSVidClosedCaptioning2 * This,
            /* [out][retval] */ VARIANT_BOOL *Power);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Category )( 
            IMSVidClosedCaptioning2 * This,
            /* [retval][out] */ BSTR *Guid);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClassID )( 
            IMSVidClosedCaptioning2 * This,
            /* [retval][out] */ BSTR *Clsid);
        
        /* [restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__Category )( 
            IMSVidClosedCaptioning2 * This,
            /* [retval][out] */ GUID *Guid);
        
        /* [restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__ClassID )( 
            IMSVidClosedCaptioning2 * This,
            /* [retval][out] */ GUID *Clsid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsEqualDevice )( 
            IMSVidClosedCaptioning2 * This,
            /* [in] */ IMSVidDevice *Device,
            /* [retval][out] */ VARIANT_BOOL *IsEqual);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Enable )( 
            IMSVidClosedCaptioning2 * This,
            /* [retval][out] */ VARIANT_BOOL *On);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Enable )( 
            IMSVidClosedCaptioning2 * This,
            /* [in] */ VARIANT_BOOL On);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Service )( 
            IMSVidClosedCaptioning2 * This,
            /* [retval][out] */ MSVidCCService *On);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Service )( 
            IMSVidClosedCaptioning2 * This,
            /* [in] */ MSVidCCService On);
        
        END_INTERFACE
    } IMSVidClosedCaptioning2Vtbl;

    interface IMSVidClosedCaptioning2
    {
        CONST_VTBL struct IMSVidClosedCaptioning2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSVidClosedCaptioning2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSVidClosedCaptioning2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSVidClosedCaptioning2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSVidClosedCaptioning2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSVidClosedCaptioning2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSVidClosedCaptioning2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSVidClosedCaptioning2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSVidClosedCaptioning2_get_Name(This,Name)	\
    (This)->lpVtbl -> get_Name(This,Name)

#define IMSVidClosedCaptioning2_get_Status(This,Status)	\
    (This)->lpVtbl -> get_Status(This,Status)

#define IMSVidClosedCaptioning2_put_Power(This,Power)	\
    (This)->lpVtbl -> put_Power(This,Power)

#define IMSVidClosedCaptioning2_get_Power(This,Power)	\
    (This)->lpVtbl -> get_Power(This,Power)

#define IMSVidClosedCaptioning2_get_Category(This,Guid)	\
    (This)->lpVtbl -> get_Category(This,Guid)

#define IMSVidClosedCaptioning2_get_ClassID(This,Clsid)	\
    (This)->lpVtbl -> get_ClassID(This,Clsid)

#define IMSVidClosedCaptioning2_get__Category(This,Guid)	\
    (This)->lpVtbl -> get__Category(This,Guid)

#define IMSVidClosedCaptioning2_get__ClassID(This,Clsid)	\
    (This)->lpVtbl -> get__ClassID(This,Clsid)

#define IMSVidClosedCaptioning2_IsEqualDevice(This,Device,IsEqual)	\
    (This)->lpVtbl -> IsEqualDevice(This,Device,IsEqual)



#define IMSVidClosedCaptioning2_get_Enable(This,On)	\
    (This)->lpVtbl -> get_Enable(This,On)

#define IMSVidClosedCaptioning2_put_Enable(This,On)	\
    (This)->lpVtbl -> put_Enable(This,On)


#define IMSVidClosedCaptioning2_get_Service(This,On)	\
    (This)->lpVtbl -> get_Service(This,On)

#define IMSVidClosedCaptioning2_put_Service(This,On)	\
    (This)->lpVtbl -> put_Service(This,On)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidClosedCaptioning2_get_Service_Proxy( 
    IMSVidClosedCaptioning2 * This,
    /* [retval][out] */ MSVidCCService *On);


void __RPC_STUB IMSVidClosedCaptioning2_get_Service_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IMSVidClosedCaptioning2_put_Service_Proxy( 
    IMSVidClosedCaptioning2 * This,
    /* [in] */ MSVidCCService On);


void __RPC_STUB IMSVidClosedCaptioning2_put_Service_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSVidClosedCaptioning2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_segment_0495 */
/* [local] */ 

typedef /* [public][public][public] */ 
enum __MIDL___MIDL_itf_segment_0495_0001
    {	sslFullSize	= 0,
	sslClipByOverScan	= sslFullSize + 1,
	sslClipByClipRect	= sslClipByOverScan + 1
    } 	SourceSizeList;



extern RPC_IF_HANDLE __MIDL_itf_segment_0495_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_segment_0495_v0_0_s_ifspec;

#ifndef __IMSVidVideoRenderer_INTERFACE_DEFINED__
#define __IMSVidVideoRenderer_INTERFACE_DEFINED__

/* interface IMSVidVideoRenderer */
/* [unique][helpstring][uuid][hidden][oleautomation][dual][object] */ 


EXTERN_C const IID IID_IMSVidVideoRenderer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("37B03540-A4C8-11d2-B634-00C04F79498E")
    IMSVidVideoRenderer : public IMSVidOutputDevice
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_CustomCompositorClass( 
            /* [retval][out] */ BSTR *CompositorCLSID) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_CustomCompositorClass( 
            /* [in] */ BSTR CompositorCLSID) = 0;
        
        virtual /* [id][restricted][hidden][propget] */ HRESULT STDMETHODCALLTYPE get__CustomCompositorClass( 
            /* [retval][out] */ GUID *CompositorCLSID) = 0;
        
        virtual /* [id][restricted][hidden][propput] */ HRESULT STDMETHODCALLTYPE put__CustomCompositorClass( 
            /* [in] */ REFCLSID CompositorCLSID) = 0;
        
        virtual /* [id][restricted][hidden][propget] */ HRESULT STDMETHODCALLTYPE get__CustomCompositor( 
            /* [retval][out] */ IVMRImageCompositor **Compositor) = 0;
        
        virtual /* [id][restricted][hidden][propput] */ HRESULT STDMETHODCALLTYPE put__CustomCompositor( 
            /* [in] */ IVMRImageCompositor *Compositor) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_MixerBitmap( 
            /* [retval][out] */ IPictureDisp **MixerPictureDisp) = 0;
        
        virtual /* [id][restricted][hidden][propget] */ HRESULT STDMETHODCALLTYPE get__MixerBitmap( 
            /* [retval][out] */ IVMRMixerBitmap **MixerPicture) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_MixerBitmap( 
            /* [in] */ IPictureDisp *MixerPictureDisp) = 0;
        
        virtual /* [id][restricted][hidden][propput] */ HRESULT STDMETHODCALLTYPE put__MixerBitmap( 
            /* [in] */ VMRALPHABITMAP *MixerPicture) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_MixerBitmapPositionRect( 
            /* [retval][out] */ IMSVidRect **rDest) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_MixerBitmapPositionRect( 
            /* [in] */ IMSVidRect *rDest) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_MixerBitmapOpacity( 
            /* [retval][out] */ int *opacity) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_MixerBitmapOpacity( 
            /* [in] */ int opacity) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetupMixerBitmap( 
            /* [in] */ IPictureDisp *MixerPictureDisp,
            /* [in] */ long Opacity,
            /* [in] */ IMSVidRect *rDest) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_SourceSize( 
            /* [out][retval] */ SourceSizeList *CurrentSize) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_SourceSize( 
            /* [in] */ SourceSizeList NewSize) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OverScan( 
            /* [out][retval] */ long *plPercent) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_OverScan( 
            /* [in] */ long lPercent) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_AvailableSourceRect( 
            /* [retval][out] */ IMSVidRect **pRect) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_MaxVidRect( 
            /* [retval][out] */ IMSVidRect **ppVidRect) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_MinVidRect( 
            /* [retval][out] */ IMSVidRect **ppVidRect) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ClippedSourceRect( 
            /* [retval][out] */ IMSVidRect **pRect) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_ClippedSourceRect( 
            /* [in] */ IMSVidRect *pRect) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_UsingOverlay( 
            /* [retval][out] */ VARIANT_BOOL *UseOverlayVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_UsingOverlay( 
            /* [in] */ VARIANT_BOOL UseOverlayVal) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Capture( 
            /* [retval][out] */ IPictureDisp **currentImage) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FramesPerSecond( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DecimateInput( 
            /* [retval][out] */ VARIANT_BOOL *pDeci) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DecimateInput( 
            /* [in] */ VARIANT_BOOL pDeci) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSVidVideoRendererVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSVidVideoRenderer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSVidVideoRenderer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSVidVideoRenderer * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSVidVideoRenderer * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSVidVideoRenderer * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSVidVideoRenderer * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSVidVideoRenderer * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IMSVidVideoRenderer * This,
            /* [retval][out] */ BSTR *Name);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            IMSVidVideoRenderer * This,
            /* [retval][out] */ long *Status);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Power )( 
            IMSVidVideoRenderer * This,
            /* [in] */ VARIANT_BOOL Power);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Power )( 
            IMSVidVideoRenderer * This,
            /* [out][retval] */ VARIANT_BOOL *Power);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Category )( 
            IMSVidVideoRenderer * This,
            /* [retval][out] */ BSTR *Guid);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClassID )( 
            IMSVidVideoRenderer * This,
            /* [retval][out] */ BSTR *Clsid);
        
        /* [restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__Category )( 
            IMSVidVideoRenderer * This,
            /* [retval][out] */ GUID *Guid);
        
        /* [restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__ClassID )( 
            IMSVidVideoRenderer * This,
            /* [retval][out] */ GUID *Clsid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsEqualDevice )( 
            IMSVidVideoRenderer * This,
            /* [in] */ IMSVidDevice *Device,
            /* [retval][out] */ VARIANT_BOOL *IsEqual);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CustomCompositorClass )( 
            IMSVidVideoRenderer * This,
            /* [retval][out] */ BSTR *CompositorCLSID);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CustomCompositorClass )( 
            IMSVidVideoRenderer * This,
            /* [in] */ BSTR CompositorCLSID);
        
        /* [id][restricted][hidden][propget] */ HRESULT ( STDMETHODCALLTYPE *get__CustomCompositorClass )( 
            IMSVidVideoRenderer * This,
            /* [retval][out] */ GUID *CompositorCLSID);
        
        /* [id][restricted][hidden][propput] */ HRESULT ( STDMETHODCALLTYPE *put__CustomCompositorClass )( 
            IMSVidVideoRenderer * This,
            /* [in] */ REFCLSID CompositorCLSID);
        
        /* [id][restricted][hidden][propget] */ HRESULT ( STDMETHODCALLTYPE *get__CustomCompositor )( 
            IMSVidVideoRenderer * This,
            /* [retval][out] */ IVMRImageCompositor **Compositor);
        
        /* [id][restricted][hidden][propput] */ HRESULT ( STDMETHODCALLTYPE *put__CustomCompositor )( 
            IMSVidVideoRenderer * This,
            /* [in] */ IVMRImageCompositor *Compositor);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MixerBitmap )( 
            IMSVidVideoRenderer * This,
            /* [retval][out] */ IPictureDisp **MixerPictureDisp);
        
        /* [id][restricted][hidden][propget] */ HRESULT ( STDMETHODCALLTYPE *get__MixerBitmap )( 
            IMSVidVideoRenderer * This,
            /* [retval][out] */ IVMRMixerBitmap **MixerPicture);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MixerBitmap )( 
            IMSVidVideoRenderer * This,
            /* [in] */ IPictureDisp *MixerPictureDisp);
        
        /* [id][restricted][hidden][propput] */ HRESULT ( STDMETHODCALLTYPE *put__MixerBitmap )( 
            IMSVidVideoRenderer * This,
            /* [in] */ VMRALPHABITMAP *MixerPicture);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MixerBitmapPositionRect )( 
            IMSVidVideoRenderer * This,
            /* [retval][out] */ IMSVidRect **rDest);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MixerBitmapPositionRect )( 
            IMSVidVideoRenderer * This,
            /* [in] */ IMSVidRect *rDest);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MixerBitmapOpacity )( 
            IMSVidVideoRenderer * This,
            /* [retval][out] */ int *opacity);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MixerBitmapOpacity )( 
            IMSVidVideoRenderer * This,
            /* [in] */ int opacity);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *SetupMixerBitmap )( 
            IMSVidVideoRenderer * This,
            /* [in] */ IPictureDisp *MixerPictureDisp,
            /* [in] */ long Opacity,
            /* [in] */ IMSVidRect *rDest);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourceSize )( 
            IMSVidVideoRenderer * This,
            /* [out][retval] */ SourceSizeList *CurrentSize);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SourceSize )( 
            IMSVidVideoRenderer * This,
            /* [in] */ SourceSizeList NewSize);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OverScan )( 
            IMSVidVideoRenderer * This,
            /* [out][retval] */ long *plPercent);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OverScan )( 
            IMSVidVideoRenderer * This,
            /* [in] */ long lPercent);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AvailableSourceRect )( 
            IMSVidVideoRenderer * This,
            /* [retval][out] */ IMSVidRect **pRect);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MaxVidRect )( 
            IMSVidVideoRenderer * This,
            /* [retval][out] */ IMSVidRect **ppVidRect);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MinVidRect )( 
            IMSVidVideoRenderer * This,
            /* [retval][out] */ IMSVidRect **ppVidRect);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClippedSourceRect )( 
            IMSVidVideoRenderer * This,
            /* [retval][out] */ IMSVidRect **pRect);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ClippedSourceRect )( 
            IMSVidVideoRenderer * This,
            /* [in] */ IMSVidRect *pRect);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UsingOverlay )( 
            IMSVidVideoRenderer * This,
            /* [retval][out] */ VARIANT_BOOL *UseOverlayVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_UsingOverlay )( 
            IMSVidVideoRenderer * This,
            /* [in] */ VARIANT_BOOL UseOverlayVal);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Capture )( 
            IMSVidVideoRenderer * This,
            /* [retval][out] */ IPictureDisp **currentImage);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FramesPerSecond )( 
            IMSVidVideoRenderer * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DecimateInput )( 
            IMSVidVideoRenderer * This,
            /* [retval][out] */ VARIANT_BOOL *pDeci);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DecimateInput )( 
            IMSVidVideoRenderer * This,
            /* [in] */ VARIANT_BOOL pDeci);
        
        END_INTERFACE
    } IMSVidVideoRendererVtbl;

    interface IMSVidVideoRenderer
    {
        CONST_VTBL struct IMSVidVideoRendererVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSVidVideoRenderer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSVidVideoRenderer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSVidVideoRenderer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSVidVideoRenderer_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSVidVideoRenderer_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSVidVideoRenderer_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSVidVideoRenderer_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSVidVideoRenderer_get_Name(This,Name)	\
    (This)->lpVtbl -> get_Name(This,Name)

#define IMSVidVideoRenderer_get_Status(This,Status)	\
    (This)->lpVtbl -> get_Status(This,Status)

#define IMSVidVideoRenderer_put_Power(This,Power)	\
    (This)->lpVtbl -> put_Power(This,Power)

#define IMSVidVideoRenderer_get_Power(This,Power)	\
    (This)->lpVtbl -> get_Power(This,Power)

#define IMSVidVideoRenderer_get_Category(This,Guid)	\
    (This)->lpVtbl -> get_Category(This,Guid)

#define IMSVidVideoRenderer_get_ClassID(This,Clsid)	\
    (This)->lpVtbl -> get_ClassID(This,Clsid)

#define IMSVidVideoRenderer_get__Category(This,Guid)	\
    (This)->lpVtbl -> get__Category(This,Guid)

#define IMSVidVideoRenderer_get__ClassID(This,Clsid)	\
    (This)->lpVtbl -> get__ClassID(This,Clsid)

#define IMSVidVideoRenderer_IsEqualDevice(This,Device,IsEqual)	\
    (This)->lpVtbl -> IsEqualDevice(This,Device,IsEqual)



#define IMSVidVideoRenderer_get_CustomCompositorClass(This,CompositorCLSID)	\
    (This)->lpVtbl -> get_CustomCompositorClass(This,CompositorCLSID)

#define IMSVidVideoRenderer_put_CustomCompositorClass(This,CompositorCLSID)	\
    (This)->lpVtbl -> put_CustomCompositorClass(This,CompositorCLSID)

#define IMSVidVideoRenderer_get__CustomCompositorClass(This,CompositorCLSID)	\
    (This)->lpVtbl -> get__CustomCompositorClass(This,CompositorCLSID)

#define IMSVidVideoRenderer_put__CustomCompositorClass(This,CompositorCLSID)	\
    (This)->lpVtbl -> put__CustomCompositorClass(This,CompositorCLSID)

#define IMSVidVideoRenderer_get__CustomCompositor(This,Compositor)	\
    (This)->lpVtbl -> get__CustomCompositor(This,Compositor)

#define IMSVidVideoRenderer_put__CustomCompositor(This,Compositor)	\
    (This)->lpVtbl -> put__CustomCompositor(This,Compositor)

#define IMSVidVideoRenderer_get_MixerBitmap(This,MixerPictureDisp)	\
    (This)->lpVtbl -> get_MixerBitmap(This,MixerPictureDisp)

#define IMSVidVideoRenderer_get__MixerBitmap(This,MixerPicture)	\
    (This)->lpVtbl -> get__MixerBitmap(This,MixerPicture)

#define IMSVidVideoRenderer_put_MixerBitmap(This,MixerPictureDisp)	\
    (This)->lpVtbl -> put_MixerBitmap(This,MixerPictureDisp)

#define IMSVidVideoRenderer_put__MixerBitmap(This,MixerPicture)	\
    (This)->lpVtbl -> put__MixerBitmap(This,MixerPicture)

#define IMSVidVideoRenderer_get_MixerBitmapPositionRect(This,rDest)	\
    (This)->lpVtbl -> get_MixerBitmapPositionRect(This,rDest)

#define IMSVidVideoRenderer_put_MixerBitmapPositionRect(This,rDest)	\
    (This)->lpVtbl -> put_MixerBitmapPositionRect(This,rDest)

#define IMSVidVideoRenderer_get_MixerBitmapOpacity(This,opacity)	\
    (This)->lpVtbl -> get_MixerBitmapOpacity(This,opacity)

#define IMSVidVideoRenderer_put_MixerBitmapOpacity(This,opacity)	\
    (This)->lpVtbl -> put_MixerBitmapOpacity(This,opacity)

#define IMSVidVideoRenderer_SetupMixerBitmap(This,MixerPictureDisp,Opacity,rDest)	\
    (This)->lpVtbl -> SetupMixerBitmap(This,MixerPictureDisp,Opacity,rDest)

#define IMSVidVideoRenderer_get_SourceSize(This,CurrentSize)	\
    (This)->lpVtbl -> get_SourceSize(This,CurrentSize)

#define IMSVidVideoRenderer_put_SourceSize(This,NewSize)	\
    (This)->lpVtbl -> put_SourceSize(This,NewSize)

#define IMSVidVideoRenderer_get_OverScan(This,plPercent)	\
    (This)->lpVtbl -> get_OverScan(This,plPercent)

#define IMSVidVideoRenderer_put_OverScan(This,lPercent)	\
    (This)->lpVtbl -> put_OverScan(This,lPercent)

#define IMSVidVideoRenderer_get_AvailableSourceRect(This,pRect)	\
    (This)->lpVtbl -> get_AvailableSourceRect(This,pRect)

#define IMSVidVideoRenderer_get_MaxVidRect(This,ppVidRect)	\
    (This)->lpVtbl -> get_MaxVidRect(This,ppVidRect)

#define IMSVidVideoRenderer_get_MinVidRect(This,ppVidRect)	\
    (This)->lpVtbl -> get_MinVidRect(This,ppVidRect)

#define IMSVidVideoRenderer_get_ClippedSourceRect(This,pRect)	\
    (This)->lpVtbl -> get_ClippedSourceRect(This,pRect)

#define IMSVidVideoRenderer_put_ClippedSourceRect(This,pRect)	\
    (This)->lpVtbl -> put_ClippedSourceRect(This,pRect)

#define IMSVidVideoRenderer_get_UsingOverlay(This,UseOverlayVal)	\
    (This)->lpVtbl -> get_UsingOverlay(This,UseOverlayVal)

#define IMSVidVideoRenderer_put_UsingOverlay(This,UseOverlayVal)	\
    (This)->lpVtbl -> put_UsingOverlay(This,UseOverlayVal)

#define IMSVidVideoRenderer_Capture(This,currentImage)	\
    (This)->lpVtbl -> Capture(This,currentImage)

#define IMSVidVideoRenderer_get_FramesPerSecond(This,pVal)	\
    (This)->lpVtbl -> get_FramesPerSecond(This,pVal)

#define IMSVidVideoRenderer_get_DecimateInput(This,pDeci)	\
    (This)->lpVtbl -> get_DecimateInput(This,pDeci)

#define IMSVidVideoRenderer_put_DecimateInput(This,pDeci)	\
    (This)->lpVtbl -> put_DecimateInput(This,pDeci)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidVideoRenderer_get_CustomCompositorClass_Proxy( 
    IMSVidVideoRenderer * This,
    /* [retval][out] */ BSTR *CompositorCLSID);


void __RPC_STUB IMSVidVideoRenderer_get_CustomCompositorClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IMSVidVideoRenderer_put_CustomCompositorClass_Proxy( 
    IMSVidVideoRenderer * This,
    /* [in] */ BSTR CompositorCLSID);


void __RPC_STUB IMSVidVideoRenderer_put_CustomCompositorClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][restricted][hidden][propget] */ HRESULT STDMETHODCALLTYPE IMSVidVideoRenderer_get__CustomCompositorClass_Proxy( 
    IMSVidVideoRenderer * This,
    /* [retval][out] */ GUID *CompositorCLSID);


void __RPC_STUB IMSVidVideoRenderer_get__CustomCompositorClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][restricted][hidden][propput] */ HRESULT STDMETHODCALLTYPE IMSVidVideoRenderer_put__CustomCompositorClass_Proxy( 
    IMSVidVideoRenderer * This,
    /* [in] */ REFCLSID CompositorCLSID);


void __RPC_STUB IMSVidVideoRenderer_put__CustomCompositorClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][restricted][hidden][propget] */ HRESULT STDMETHODCALLTYPE IMSVidVideoRenderer_get__CustomCompositor_Proxy( 
    IMSVidVideoRenderer * This,
    /* [retval][out] */ IVMRImageCompositor **Compositor);


void __RPC_STUB IMSVidVideoRenderer_get__CustomCompositor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][restricted][hidden][propput] */ HRESULT STDMETHODCALLTYPE IMSVidVideoRenderer_put__CustomCompositor_Proxy( 
    IMSVidVideoRenderer * This,
    /* [in] */ IVMRImageCompositor *Compositor);


void __RPC_STUB IMSVidVideoRenderer_put__CustomCompositor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidVideoRenderer_get_MixerBitmap_Proxy( 
    IMSVidVideoRenderer * This,
    /* [retval][out] */ IPictureDisp **MixerPictureDisp);


void __RPC_STUB IMSVidVideoRenderer_get_MixerBitmap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][restricted][hidden][propget] */ HRESULT STDMETHODCALLTYPE IMSVidVideoRenderer_get__MixerBitmap_Proxy( 
    IMSVidVideoRenderer * This,
    /* [retval][out] */ IVMRMixerBitmap **MixerPicture);


void __RPC_STUB IMSVidVideoRenderer_get__MixerBitmap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IMSVidVideoRenderer_put_MixerBitmap_Proxy( 
    IMSVidVideoRenderer * This,
    /* [in] */ IPictureDisp *MixerPictureDisp);


void __RPC_STUB IMSVidVideoRenderer_put_MixerBitmap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][restricted][hidden][propput] */ HRESULT STDMETHODCALLTYPE IMSVidVideoRenderer_put__MixerBitmap_Proxy( 
    IMSVidVideoRenderer * This,
    /* [in] */ VMRALPHABITMAP *MixerPicture);


void __RPC_STUB IMSVidVideoRenderer_put__MixerBitmap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidVideoRenderer_get_MixerBitmapPositionRect_Proxy( 
    IMSVidVideoRenderer * This,
    /* [retval][out] */ IMSVidRect **rDest);


void __RPC_STUB IMSVidVideoRenderer_get_MixerBitmapPositionRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IMSVidVideoRenderer_put_MixerBitmapPositionRect_Proxy( 
    IMSVidVideoRenderer * This,
    /* [in] */ IMSVidRect *rDest);


void __RPC_STUB IMSVidVideoRenderer_put_MixerBitmapPositionRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidVideoRenderer_get_MixerBitmapOpacity_Proxy( 
    IMSVidVideoRenderer * This,
    /* [retval][out] */ int *opacity);


void __RPC_STUB IMSVidVideoRenderer_get_MixerBitmapOpacity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IMSVidVideoRenderer_put_MixerBitmapOpacity_Proxy( 
    IMSVidVideoRenderer * This,
    /* [in] */ int opacity);


void __RPC_STUB IMSVidVideoRenderer_put_MixerBitmapOpacity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IMSVidVideoRenderer_SetupMixerBitmap_Proxy( 
    IMSVidVideoRenderer * This,
    /* [in] */ IPictureDisp *MixerPictureDisp,
    /* [in] */ long Opacity,
    /* [in] */ IMSVidRect *rDest);


void __RPC_STUB IMSVidVideoRenderer_SetupMixerBitmap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidVideoRenderer_get_SourceSize_Proxy( 
    IMSVidVideoRenderer * This,
    /* [out][retval] */ SourceSizeList *CurrentSize);


void __RPC_STUB IMSVidVideoRenderer_get_SourceSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IMSVidVideoRenderer_put_SourceSize_Proxy( 
    IMSVidVideoRenderer * This,
    /* [in] */ SourceSizeList NewSize);


void __RPC_STUB IMSVidVideoRenderer_put_SourceSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidVideoRenderer_get_OverScan_Proxy( 
    IMSVidVideoRenderer * This,
    /* [out][retval] */ long *plPercent);


void __RPC_STUB IMSVidVideoRenderer_get_OverScan_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSVidVideoRenderer_put_OverScan_Proxy( 
    IMSVidVideoRenderer * This,
    /* [in] */ long lPercent);


void __RPC_STUB IMSVidVideoRenderer_put_OverScan_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidVideoRenderer_get_AvailableSourceRect_Proxy( 
    IMSVidVideoRenderer * This,
    /* [retval][out] */ IMSVidRect **pRect);


void __RPC_STUB IMSVidVideoRenderer_get_AvailableSourceRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidVideoRenderer_get_MaxVidRect_Proxy( 
    IMSVidVideoRenderer * This,
    /* [retval][out] */ IMSVidRect **ppVidRect);


void __RPC_STUB IMSVidVideoRenderer_get_MaxVidRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidVideoRenderer_get_MinVidRect_Proxy( 
    IMSVidVideoRenderer * This,
    /* [retval][out] */ IMSVidRect **ppVidRect);


void __RPC_STUB IMSVidVideoRenderer_get_MinVidRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidVideoRenderer_get_ClippedSourceRect_Proxy( 
    IMSVidVideoRenderer * This,
    /* [retval][out] */ IMSVidRect **pRect);


void __RPC_STUB IMSVidVideoRenderer_get_ClippedSourceRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IMSVidVideoRenderer_put_ClippedSourceRect_Proxy( 
    IMSVidVideoRenderer * This,
    /* [in] */ IMSVidRect *pRect);


void __RPC_STUB IMSVidVideoRenderer_put_ClippedSourceRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidVideoRenderer_get_UsingOverlay_Proxy( 
    IMSVidVideoRenderer * This,
    /* [retval][out] */ VARIANT_BOOL *UseOverlayVal);


void __RPC_STUB IMSVidVideoRenderer_get_UsingOverlay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IMSVidVideoRenderer_put_UsingOverlay_Proxy( 
    IMSVidVideoRenderer * This,
    /* [in] */ VARIANT_BOOL UseOverlayVal);


void __RPC_STUB IMSVidVideoRenderer_put_UsingOverlay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IMSVidVideoRenderer_Capture_Proxy( 
    IMSVidVideoRenderer * This,
    /* [retval][out] */ IPictureDisp **currentImage);


void __RPC_STUB IMSVidVideoRenderer_Capture_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidVideoRenderer_get_FramesPerSecond_Proxy( 
    IMSVidVideoRenderer * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IMSVidVideoRenderer_get_FramesPerSecond_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidVideoRenderer_get_DecimateInput_Proxy( 
    IMSVidVideoRenderer * This,
    /* [retval][out] */ VARIANT_BOOL *pDeci);


void __RPC_STUB IMSVidVideoRenderer_get_DecimateInput_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSVidVideoRenderer_put_DecimateInput_Proxy( 
    IMSVidVideoRenderer * This,
    /* [in] */ VARIANT_BOOL pDeci);


void __RPC_STUB IMSVidVideoRenderer_put_DecimateInput_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSVidVideoRenderer_INTERFACE_DEFINED__ */


#ifndef __IMSVidVideoRendererEvent_INTERFACE_DEFINED__
#define __IMSVidVideoRendererEvent_INTERFACE_DEFINED__

/* interface IMSVidVideoRendererEvent */
/* [unique][helpstring][uuid][hidden][oleautomation][object] */ 


EXTERN_C const IID IID_IMSVidVideoRendererEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("37B03545-A4C8-11d2-B634-00C04F79498E")
    IMSVidVideoRendererEvent : public IMSVidOutputDeviceEvent
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OverlayUnavailable( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSVidVideoRendererEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSVidVideoRendererEvent * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSVidVideoRendererEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSVidVideoRendererEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSVidVideoRendererEvent * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSVidVideoRendererEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSVidVideoRendererEvent * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSVidVideoRendererEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *StateChange )( 
            IMSVidVideoRendererEvent * This,
            /* [in] */ IMSVidDevice *lpd,
            /* [in] */ long oldState,
            /* [in] */ long newState);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OverlayUnavailable )( 
            IMSVidVideoRendererEvent * This);
        
        END_INTERFACE
    } IMSVidVideoRendererEventVtbl;

    interface IMSVidVideoRendererEvent
    {
        CONST_VTBL struct IMSVidVideoRendererEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSVidVideoRendererEvent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSVidVideoRendererEvent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSVidVideoRendererEvent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSVidVideoRendererEvent_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSVidVideoRendererEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSVidVideoRendererEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSVidVideoRendererEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSVidVideoRendererEvent_StateChange(This,lpd,oldState,newState)	\
    (This)->lpVtbl -> StateChange(This,lpd,oldState,newState)



#define IMSVidVideoRendererEvent_OverlayUnavailable(This)	\
    (This)->lpVtbl -> OverlayUnavailable(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidVideoRendererEvent_OverlayUnavailable_Proxy( 
    IMSVidVideoRendererEvent * This);


void __RPC_STUB IMSVidVideoRendererEvent_OverlayUnavailable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSVidVideoRendererEvent_INTERFACE_DEFINED__ */


#ifndef __IMSVidStreamBufferRecordingControl_INTERFACE_DEFINED__
#define __IMSVidStreamBufferRecordingControl_INTERFACE_DEFINED__

/* interface IMSVidStreamBufferRecordingControl */
/* [helpstring][uuid][unique][nonextensible][hidden][oleautomation][dual][object] */ 


EXTERN_C const IID IID_IMSVidStreamBufferRecordingControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("160621AA-BBBC-4326-A824-C395AEBC6E74")
    IMSVidStreamBufferRecordingControl : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StartTime( 
            /* [retval][out] */ long *rtStart) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_StartTime( 
            /* [in] */ long rtStart) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StopTime( 
            /* [retval][out] */ long *rtStop) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_StopTime( 
            /* [in] */ long rtStop) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RecordingStopped( 
            /* [retval][out] */ VARIANT_BOOL *phResult) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RecordingStarted( 
            /* [retval][out] */ VARIANT_BOOL *phResult) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RecordingType( 
            /* [retval][out] */ RecordingType *dwType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RecordingAttribute( 
            /* [retval][out] */ IUnknown **pRecordingAttribute) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSVidStreamBufferRecordingControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSVidStreamBufferRecordingControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSVidStreamBufferRecordingControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSVidStreamBufferRecordingControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSVidStreamBufferRecordingControl * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSVidStreamBufferRecordingControl * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSVidStreamBufferRecordingControl * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSVidStreamBufferRecordingControl * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StartTime )( 
            IMSVidStreamBufferRecordingControl * This,
            /* [retval][out] */ long *rtStart);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_StartTime )( 
            IMSVidStreamBufferRecordingControl * This,
            /* [in] */ long rtStart);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StopTime )( 
            IMSVidStreamBufferRecordingControl * This,
            /* [retval][out] */ long *rtStop);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_StopTime )( 
            IMSVidStreamBufferRecordingControl * This,
            /* [in] */ long rtStop);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RecordingStopped )( 
            IMSVidStreamBufferRecordingControl * This,
            /* [retval][out] */ VARIANT_BOOL *phResult);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RecordingStarted )( 
            IMSVidStreamBufferRecordingControl * This,
            /* [retval][out] */ VARIANT_BOOL *phResult);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RecordingType )( 
            IMSVidStreamBufferRecordingControl * This,
            /* [retval][out] */ RecordingType *dwType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RecordingAttribute )( 
            IMSVidStreamBufferRecordingControl * This,
            /* [retval][out] */ IUnknown **pRecordingAttribute);
        
        END_INTERFACE
    } IMSVidStreamBufferRecordingControlVtbl;

    interface IMSVidStreamBufferRecordingControl
    {
        CONST_VTBL struct IMSVidStreamBufferRecordingControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSVidStreamBufferRecordingControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSVidStreamBufferRecordingControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSVidStreamBufferRecordingControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSVidStreamBufferRecordingControl_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSVidStreamBufferRecordingControl_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSVidStreamBufferRecordingControl_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSVidStreamBufferRecordingControl_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSVidStreamBufferRecordingControl_get_StartTime(This,rtStart)	\
    (This)->lpVtbl -> get_StartTime(This,rtStart)

#define IMSVidStreamBufferRecordingControl_put_StartTime(This,rtStart)	\
    (This)->lpVtbl -> put_StartTime(This,rtStart)

#define IMSVidStreamBufferRecordingControl_get_StopTime(This,rtStop)	\
    (This)->lpVtbl -> get_StopTime(This,rtStop)

#define IMSVidStreamBufferRecordingControl_put_StopTime(This,rtStop)	\
    (This)->lpVtbl -> put_StopTime(This,rtStop)

#define IMSVidStreamBufferRecordingControl_get_RecordingStopped(This,phResult)	\
    (This)->lpVtbl -> get_RecordingStopped(This,phResult)

#define IMSVidStreamBufferRecordingControl_get_RecordingStarted(This,phResult)	\
    (This)->lpVtbl -> get_RecordingStarted(This,phResult)

#define IMSVidStreamBufferRecordingControl_get_RecordingType(This,dwType)	\
    (This)->lpVtbl -> get_RecordingType(This,dwType)

#define IMSVidStreamBufferRecordingControl_get_RecordingAttribute(This,pRecordingAttribute)	\
    (This)->lpVtbl -> get_RecordingAttribute(This,pRecordingAttribute)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidStreamBufferRecordingControl_get_StartTime_Proxy( 
    IMSVidStreamBufferRecordingControl * This,
    /* [retval][out] */ long *rtStart);


void __RPC_STUB IMSVidStreamBufferRecordingControl_get_StartTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSVidStreamBufferRecordingControl_put_StartTime_Proxy( 
    IMSVidStreamBufferRecordingControl * This,
    /* [in] */ long rtStart);


void __RPC_STUB IMSVidStreamBufferRecordingControl_put_StartTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidStreamBufferRecordingControl_get_StopTime_Proxy( 
    IMSVidStreamBufferRecordingControl * This,
    /* [retval][out] */ long *rtStop);


void __RPC_STUB IMSVidStreamBufferRecordingControl_get_StopTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSVidStreamBufferRecordingControl_put_StopTime_Proxy( 
    IMSVidStreamBufferRecordingControl * This,
    /* [in] */ long rtStop);


void __RPC_STUB IMSVidStreamBufferRecordingControl_put_StopTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidStreamBufferRecordingControl_get_RecordingStopped_Proxy( 
    IMSVidStreamBufferRecordingControl * This,
    /* [retval][out] */ VARIANT_BOOL *phResult);


void __RPC_STUB IMSVidStreamBufferRecordingControl_get_RecordingStopped_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidStreamBufferRecordingControl_get_RecordingStarted_Proxy( 
    IMSVidStreamBufferRecordingControl * This,
    /* [retval][out] */ VARIANT_BOOL *phResult);


void __RPC_STUB IMSVidStreamBufferRecordingControl_get_RecordingStarted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidStreamBufferRecordingControl_get_RecordingType_Proxy( 
    IMSVidStreamBufferRecordingControl * This,
    /* [retval][out] */ RecordingType *dwType);


void __RPC_STUB IMSVidStreamBufferRecordingControl_get_RecordingType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidStreamBufferRecordingControl_get_RecordingAttribute_Proxy( 
    IMSVidStreamBufferRecordingControl * This,
    /* [retval][out] */ IUnknown **pRecordingAttribute);


void __RPC_STUB IMSVidStreamBufferRecordingControl_get_RecordingAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSVidStreamBufferRecordingControl_INTERFACE_DEFINED__ */


#ifndef __IMSVidStreamBufferSink_INTERFACE_DEFINED__
#define __IMSVidStreamBufferSink_INTERFACE_DEFINED__

/* interface IMSVidStreamBufferSink */
/* [unique][helpstring][uuid][hidden][oleautomation][dual][object] */ 


EXTERN_C const IID IID_IMSVidStreamBufferSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("159DBB45-CD1B-4dab-83EA-5CB1F4F21D07")
    IMSVidStreamBufferSink : public IMSVidOutputDevice
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ContentRecorder( 
            /* [in] */ BSTR pszFilename,
            /* [out][retval] */ IMSVidStreamBufferRecordingControl **pRecordingIUnknown) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ReferenceRecorder( 
            /* [in] */ BSTR pszFilename,
            /* [out][retval] */ IMSVidStreamBufferRecordingControl **pRecordingIUnknown) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SinkName( 
            /* [out][retval] */ BSTR *pName) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SinkName( 
            /* [in] */ BSTR Name) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE NameSetLock( void) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SBESink( 
            /* [out][retval] */ IUnknown **sbeConfig) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSVidStreamBufferSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSVidStreamBufferSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSVidStreamBufferSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSVidStreamBufferSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSVidStreamBufferSink * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSVidStreamBufferSink * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSVidStreamBufferSink * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSVidStreamBufferSink * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IMSVidStreamBufferSink * This,
            /* [retval][out] */ BSTR *Name);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            IMSVidStreamBufferSink * This,
            /* [retval][out] */ long *Status);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Power )( 
            IMSVidStreamBufferSink * This,
            /* [in] */ VARIANT_BOOL Power);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Power )( 
            IMSVidStreamBufferSink * This,
            /* [out][retval] */ VARIANT_BOOL *Power);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Category )( 
            IMSVidStreamBufferSink * This,
            /* [retval][out] */ BSTR *Guid);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClassID )( 
            IMSVidStreamBufferSink * This,
            /* [retval][out] */ BSTR *Clsid);
        
        /* [restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__Category )( 
            IMSVidStreamBufferSink * This,
            /* [retval][out] */ GUID *Guid);
        
        /* [restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__ClassID )( 
            IMSVidStreamBufferSink * This,
            /* [retval][out] */ GUID *Clsid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsEqualDevice )( 
            IMSVidStreamBufferSink * This,
            /* [in] */ IMSVidDevice *Device,
            /* [retval][out] */ VARIANT_BOOL *IsEqual);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ContentRecorder )( 
            IMSVidStreamBufferSink * This,
            /* [in] */ BSTR pszFilename,
            /* [out][retval] */ IMSVidStreamBufferRecordingControl **pRecordingIUnknown);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReferenceRecorder )( 
            IMSVidStreamBufferSink * This,
            /* [in] */ BSTR pszFilename,
            /* [out][retval] */ IMSVidStreamBufferRecordingControl **pRecordingIUnknown);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SinkName )( 
            IMSVidStreamBufferSink * This,
            /* [out][retval] */ BSTR *pName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SinkName )( 
            IMSVidStreamBufferSink * This,
            /* [in] */ BSTR Name);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *NameSetLock )( 
            IMSVidStreamBufferSink * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SBESink )( 
            IMSVidStreamBufferSink * This,
            /* [out][retval] */ IUnknown **sbeConfig);
        
        END_INTERFACE
    } IMSVidStreamBufferSinkVtbl;

    interface IMSVidStreamBufferSink
    {
        CONST_VTBL struct IMSVidStreamBufferSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSVidStreamBufferSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSVidStreamBufferSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSVidStreamBufferSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSVidStreamBufferSink_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSVidStreamBufferSink_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSVidStreamBufferSink_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSVidStreamBufferSink_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSVidStreamBufferSink_get_Name(This,Name)	\
    (This)->lpVtbl -> get_Name(This,Name)

#define IMSVidStreamBufferSink_get_Status(This,Status)	\
    (This)->lpVtbl -> get_Status(This,Status)

#define IMSVidStreamBufferSink_put_Power(This,Power)	\
    (This)->lpVtbl -> put_Power(This,Power)

#define IMSVidStreamBufferSink_get_Power(This,Power)	\
    (This)->lpVtbl -> get_Power(This,Power)

#define IMSVidStreamBufferSink_get_Category(This,Guid)	\
    (This)->lpVtbl -> get_Category(This,Guid)

#define IMSVidStreamBufferSink_get_ClassID(This,Clsid)	\
    (This)->lpVtbl -> get_ClassID(This,Clsid)

#define IMSVidStreamBufferSink_get__Category(This,Guid)	\
    (This)->lpVtbl -> get__Category(This,Guid)

#define IMSVidStreamBufferSink_get__ClassID(This,Clsid)	\
    (This)->lpVtbl -> get__ClassID(This,Clsid)

#define IMSVidStreamBufferSink_IsEqualDevice(This,Device,IsEqual)	\
    (This)->lpVtbl -> IsEqualDevice(This,Device,IsEqual)



#define IMSVidStreamBufferSink_get_ContentRecorder(This,pszFilename,pRecordingIUnknown)	\
    (This)->lpVtbl -> get_ContentRecorder(This,pszFilename,pRecordingIUnknown)

#define IMSVidStreamBufferSink_get_ReferenceRecorder(This,pszFilename,pRecordingIUnknown)	\
    (This)->lpVtbl -> get_ReferenceRecorder(This,pszFilename,pRecordingIUnknown)

#define IMSVidStreamBufferSink_get_SinkName(This,pName)	\
    (This)->lpVtbl -> get_SinkName(This,pName)

#define IMSVidStreamBufferSink_put_SinkName(This,Name)	\
    (This)->lpVtbl -> put_SinkName(This,Name)

#define IMSVidStreamBufferSink_NameSetLock(This)	\
    (This)->lpVtbl -> NameSetLock(This)

#define IMSVidStreamBufferSink_get_SBESink(This,sbeConfig)	\
    (This)->lpVtbl -> get_SBESink(This,sbeConfig)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidStreamBufferSink_get_ContentRecorder_Proxy( 
    IMSVidStreamBufferSink * This,
    /* [in] */ BSTR pszFilename,
    /* [out][retval] */ IMSVidStreamBufferRecordingControl **pRecordingIUnknown);


void __RPC_STUB IMSVidStreamBufferSink_get_ContentRecorder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidStreamBufferSink_get_ReferenceRecorder_Proxy( 
    IMSVidStreamBufferSink * This,
    /* [in] */ BSTR pszFilename,
    /* [out][retval] */ IMSVidStreamBufferRecordingControl **pRecordingIUnknown);


void __RPC_STUB IMSVidStreamBufferSink_get_ReferenceRecorder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidStreamBufferSink_get_SinkName_Proxy( 
    IMSVidStreamBufferSink * This,
    /* [out][retval] */ BSTR *pName);


void __RPC_STUB IMSVidStreamBufferSink_get_SinkName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSVidStreamBufferSink_put_SinkName_Proxy( 
    IMSVidStreamBufferSink * This,
    /* [in] */ BSTR Name);


void __RPC_STUB IMSVidStreamBufferSink_put_SinkName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidStreamBufferSink_NameSetLock_Proxy( 
    IMSVidStreamBufferSink * This);


void __RPC_STUB IMSVidStreamBufferSink_NameSetLock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidStreamBufferSink_get_SBESink_Proxy( 
    IMSVidStreamBufferSink * This,
    /* [out][retval] */ IUnknown **sbeConfig);


void __RPC_STUB IMSVidStreamBufferSink_get_SBESink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSVidStreamBufferSink_INTERFACE_DEFINED__ */


#ifndef __IMSVidStreamBufferSinkEvent_INTERFACE_DEFINED__
#define __IMSVidStreamBufferSinkEvent_INTERFACE_DEFINED__

/* interface IMSVidStreamBufferSinkEvent */
/* [unique][helpstring][uuid][hidden][oleautomation][object] */ 


EXTERN_C const IID IID_IMSVidStreamBufferSinkEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F798A36B-B05B-4bbe-9703-EAEA7D61CD51")
    IMSVidStreamBufferSinkEvent : public IMSVidOutputDeviceEvent
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CertificateFailure( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CertificateSuccess( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE WriteFailure( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSVidStreamBufferSinkEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSVidStreamBufferSinkEvent * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSVidStreamBufferSinkEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSVidStreamBufferSinkEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSVidStreamBufferSinkEvent * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSVidStreamBufferSinkEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSVidStreamBufferSinkEvent * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSVidStreamBufferSinkEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *StateChange )( 
            IMSVidStreamBufferSinkEvent * This,
            /* [in] */ IMSVidDevice *lpd,
            /* [in] */ long oldState,
            /* [in] */ long newState);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CertificateFailure )( 
            IMSVidStreamBufferSinkEvent * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CertificateSuccess )( 
            IMSVidStreamBufferSinkEvent * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *WriteFailure )( 
            IMSVidStreamBufferSinkEvent * This);
        
        END_INTERFACE
    } IMSVidStreamBufferSinkEventVtbl;

    interface IMSVidStreamBufferSinkEvent
    {
        CONST_VTBL struct IMSVidStreamBufferSinkEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSVidStreamBufferSinkEvent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSVidStreamBufferSinkEvent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSVidStreamBufferSinkEvent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSVidStreamBufferSinkEvent_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSVidStreamBufferSinkEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSVidStreamBufferSinkEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSVidStreamBufferSinkEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSVidStreamBufferSinkEvent_StateChange(This,lpd,oldState,newState)	\
    (This)->lpVtbl -> StateChange(This,lpd,oldState,newState)



#define IMSVidStreamBufferSinkEvent_CertificateFailure(This)	\
    (This)->lpVtbl -> CertificateFailure(This)

#define IMSVidStreamBufferSinkEvent_CertificateSuccess(This)	\
    (This)->lpVtbl -> CertificateSuccess(This)

#define IMSVidStreamBufferSinkEvent_WriteFailure(This)	\
    (This)->lpVtbl -> WriteFailure(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidStreamBufferSinkEvent_CertificateFailure_Proxy( 
    IMSVidStreamBufferSinkEvent * This);


void __RPC_STUB IMSVidStreamBufferSinkEvent_CertificateFailure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidStreamBufferSinkEvent_CertificateSuccess_Proxy( 
    IMSVidStreamBufferSinkEvent * This);


void __RPC_STUB IMSVidStreamBufferSinkEvent_CertificateSuccess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidStreamBufferSinkEvent_WriteFailure_Proxy( 
    IMSVidStreamBufferSinkEvent * This);


void __RPC_STUB IMSVidStreamBufferSinkEvent_WriteFailure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSVidStreamBufferSinkEvent_INTERFACE_DEFINED__ */


#ifndef __IMSVidStreamBufferSource_INTERFACE_DEFINED__
#define __IMSVidStreamBufferSource_INTERFACE_DEFINED__

/* interface IMSVidStreamBufferSource */
/* [unique][helpstring][uuid][hidden][oleautomation][dual][object] */ 


EXTERN_C const IID IID_IMSVidStreamBufferSource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EB0C8CF9-6950-4772-87B1-47D11CF3A02F")
    IMSVidStreamBufferSource : public IMSVidFilePlayback
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Start( 
            /* [retval][out] */ long *lStart) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RecordingAttribute( 
            /* [retval][out] */ IUnknown **pRecordingAttribute) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CurrentRatings( 
            /* [out] */ EnTvRat_System *pEnSystem,
            /* [out] */ EnTvRat_GenericLevel *pEnRating,
            /* [out] */ LONG *pBfEnAttr) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE MaxRatingsLevel( 
            /* [in] */ EnTvRat_System enSystem,
            /* [in] */ EnTvRat_GenericLevel enRating,
            /* [in] */ LONG lbfEnAttr) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_BlockUnrated( 
            /* [in] */ VARIANT_BOOL bBlock) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_UnratedDelay( 
            /* [in] */ long dwDelay) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SBESource( 
            /* [retval][out] */ IUnknown **sbeFilter) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSVidStreamBufferSourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSVidStreamBufferSource * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSVidStreamBufferSource * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSVidStreamBufferSource * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSVidStreamBufferSource * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSVidStreamBufferSource * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSVidStreamBufferSource * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSVidStreamBufferSource * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IMSVidStreamBufferSource * This,
            /* [retval][out] */ BSTR *Name);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            IMSVidStreamBufferSource * This,
            /* [retval][out] */ long *Status);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Power )( 
            IMSVidStreamBufferSource * This,
            /* [in] */ VARIANT_BOOL Power);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Power )( 
            IMSVidStreamBufferSource * This,
            /* [out][retval] */ VARIANT_BOOL *Power);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Category )( 
            IMSVidStreamBufferSource * This,
            /* [retval][out] */ BSTR *Guid);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClassID )( 
            IMSVidStreamBufferSource * This,
            /* [retval][out] */ BSTR *Clsid);
        
        /* [restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__Category )( 
            IMSVidStreamBufferSource * This,
            /* [retval][out] */ GUID *Guid);
        
        /* [restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__ClassID )( 
            IMSVidStreamBufferSource * This,
            /* [retval][out] */ GUID *Clsid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsEqualDevice )( 
            IMSVidStreamBufferSource * This,
            /* [in] */ IMSVidDevice *Device,
            /* [retval][out] */ VARIANT_BOOL *IsEqual);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *IsViewable )( 
            IMSVidStreamBufferSource * This,
            /* [in] */ VARIANT *v,
            /* [retval][out] */ VARIANT_BOOL *pfViewable);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *View )( 
            IMSVidStreamBufferSource * This,
            /* [in] */ VARIANT *v);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnableResetOnStop )( 
            IMSVidStreamBufferSource * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_EnableResetOnStop )( 
            IMSVidStreamBufferSource * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Run )( 
            IMSVidStreamBufferSource * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IMSVidStreamBufferSource * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IMSVidStreamBufferSource * This);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CanStep )( 
            IMSVidStreamBufferSource * This,
            /* [in] */ VARIANT_BOOL fBackwards,
            /* [retval][out] */ VARIANT_BOOL *pfCan);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Step )( 
            IMSVidStreamBufferSource * This,
            /* [in] */ long lStep);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Rate )( 
            IMSVidStreamBufferSource * This,
            /* [in] */ double plRate);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Rate )( 
            IMSVidStreamBufferSource * This,
            /* [retval][out] */ double *plRate);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CurrentPosition )( 
            IMSVidStreamBufferSource * This,
            /* [in] */ long lPosition);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentPosition )( 
            IMSVidStreamBufferSource * This,
            /* [retval][out] */ long *lPosition);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PositionMode )( 
            IMSVidStreamBufferSource * This,
            /* [in] */ PositionModeList lPositionMode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PositionMode )( 
            IMSVidStreamBufferSource * This,
            /* [retval][out] */ PositionModeList *lPositionMode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Length )( 
            IMSVidStreamBufferSource * This,
            /* [retval][out] */ long *lLength);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileName )( 
            IMSVidStreamBufferSource * This,
            /* [retval][out] */ BSTR *FileName);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_FileName )( 
            IMSVidStreamBufferSource * This,
            /* [in] */ BSTR FileName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Start )( 
            IMSVidStreamBufferSource * This,
            /* [retval][out] */ long *lStart);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RecordingAttribute )( 
            IMSVidStreamBufferSource * This,
            /* [retval][out] */ IUnknown **pRecordingAttribute);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CurrentRatings )( 
            IMSVidStreamBufferSource * This,
            /* [out] */ EnTvRat_System *pEnSystem,
            /* [out] */ EnTvRat_GenericLevel *pEnRating,
            /* [out] */ LONG *pBfEnAttr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *MaxRatingsLevel )( 
            IMSVidStreamBufferSource * This,
            /* [in] */ EnTvRat_System enSystem,
            /* [in] */ EnTvRat_GenericLevel enRating,
            /* [in] */ LONG lbfEnAttr);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BlockUnrated )( 
            IMSVidStreamBufferSource * This,
            /* [in] */ VARIANT_BOOL bBlock);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_UnratedDelay )( 
            IMSVidStreamBufferSource * This,
            /* [in] */ long dwDelay);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SBESource )( 
            IMSVidStreamBufferSource * This,
            /* [retval][out] */ IUnknown **sbeFilter);
        
        END_INTERFACE
    } IMSVidStreamBufferSourceVtbl;

    interface IMSVidStreamBufferSource
    {
        CONST_VTBL struct IMSVidStreamBufferSourceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSVidStreamBufferSource_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSVidStreamBufferSource_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSVidStreamBufferSource_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSVidStreamBufferSource_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSVidStreamBufferSource_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSVidStreamBufferSource_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSVidStreamBufferSource_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSVidStreamBufferSource_get_Name(This,Name)	\
    (This)->lpVtbl -> get_Name(This,Name)

#define IMSVidStreamBufferSource_get_Status(This,Status)	\
    (This)->lpVtbl -> get_Status(This,Status)

#define IMSVidStreamBufferSource_put_Power(This,Power)	\
    (This)->lpVtbl -> put_Power(This,Power)

#define IMSVidStreamBufferSource_get_Power(This,Power)	\
    (This)->lpVtbl -> get_Power(This,Power)

#define IMSVidStreamBufferSource_get_Category(This,Guid)	\
    (This)->lpVtbl -> get_Category(This,Guid)

#define IMSVidStreamBufferSource_get_ClassID(This,Clsid)	\
    (This)->lpVtbl -> get_ClassID(This,Clsid)

#define IMSVidStreamBufferSource_get__Category(This,Guid)	\
    (This)->lpVtbl -> get__Category(This,Guid)

#define IMSVidStreamBufferSource_get__ClassID(This,Clsid)	\
    (This)->lpVtbl -> get__ClassID(This,Clsid)

#define IMSVidStreamBufferSource_IsEqualDevice(This,Device,IsEqual)	\
    (This)->lpVtbl -> IsEqualDevice(This,Device,IsEqual)


#define IMSVidStreamBufferSource_IsViewable(This,v,pfViewable)	\
    (This)->lpVtbl -> IsViewable(This,v,pfViewable)

#define IMSVidStreamBufferSource_View(This,v)	\
    (This)->lpVtbl -> View(This,v)


#define IMSVidStreamBufferSource_get_EnableResetOnStop(This,pVal)	\
    (This)->lpVtbl -> get_EnableResetOnStop(This,pVal)

#define IMSVidStreamBufferSource_put_EnableResetOnStop(This,newVal)	\
    (This)->lpVtbl -> put_EnableResetOnStop(This,newVal)

#define IMSVidStreamBufferSource_Run(This)	\
    (This)->lpVtbl -> Run(This)

#define IMSVidStreamBufferSource_Pause(This)	\
    (This)->lpVtbl -> Pause(This)

#define IMSVidStreamBufferSource_Stop(This)	\
    (This)->lpVtbl -> Stop(This)

#define IMSVidStreamBufferSource_get_CanStep(This,fBackwards,pfCan)	\
    (This)->lpVtbl -> get_CanStep(This,fBackwards,pfCan)

#define IMSVidStreamBufferSource_Step(This,lStep)	\
    (This)->lpVtbl -> Step(This,lStep)

#define IMSVidStreamBufferSource_put_Rate(This,plRate)	\
    (This)->lpVtbl -> put_Rate(This,plRate)

#define IMSVidStreamBufferSource_get_Rate(This,plRate)	\
    (This)->lpVtbl -> get_Rate(This,plRate)

#define IMSVidStreamBufferSource_put_CurrentPosition(This,lPosition)	\
    (This)->lpVtbl -> put_CurrentPosition(This,lPosition)

#define IMSVidStreamBufferSource_get_CurrentPosition(This,lPosition)	\
    (This)->lpVtbl -> get_CurrentPosition(This,lPosition)

#define IMSVidStreamBufferSource_put_PositionMode(This,lPositionMode)	\
    (This)->lpVtbl -> put_PositionMode(This,lPositionMode)

#define IMSVidStreamBufferSource_get_PositionMode(This,lPositionMode)	\
    (This)->lpVtbl -> get_PositionMode(This,lPositionMode)

#define IMSVidStreamBufferSource_get_Length(This,lLength)	\
    (This)->lpVtbl -> get_Length(This,lLength)


#define IMSVidStreamBufferSource_get_FileName(This,FileName)	\
    (This)->lpVtbl -> get_FileName(This,FileName)

#define IMSVidStreamBufferSource_put_FileName(This,FileName)	\
    (This)->lpVtbl -> put_FileName(This,FileName)


#define IMSVidStreamBufferSource_get_Start(This,lStart)	\
    (This)->lpVtbl -> get_Start(This,lStart)

#define IMSVidStreamBufferSource_get_RecordingAttribute(This,pRecordingAttribute)	\
    (This)->lpVtbl -> get_RecordingAttribute(This,pRecordingAttribute)

#define IMSVidStreamBufferSource_CurrentRatings(This,pEnSystem,pEnRating,pBfEnAttr)	\
    (This)->lpVtbl -> CurrentRatings(This,pEnSystem,pEnRating,pBfEnAttr)

#define IMSVidStreamBufferSource_MaxRatingsLevel(This,enSystem,enRating,lbfEnAttr)	\
    (This)->lpVtbl -> MaxRatingsLevel(This,enSystem,enRating,lbfEnAttr)

#define IMSVidStreamBufferSource_put_BlockUnrated(This,bBlock)	\
    (This)->lpVtbl -> put_BlockUnrated(This,bBlock)

#define IMSVidStreamBufferSource_put_UnratedDelay(This,dwDelay)	\
    (This)->lpVtbl -> put_UnratedDelay(This,dwDelay)

#define IMSVidStreamBufferSource_get_SBESource(This,sbeFilter)	\
    (This)->lpVtbl -> get_SBESource(This,sbeFilter)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidStreamBufferSource_get_Start_Proxy( 
    IMSVidStreamBufferSource * This,
    /* [retval][out] */ long *lStart);


void __RPC_STUB IMSVidStreamBufferSource_get_Start_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidStreamBufferSource_get_RecordingAttribute_Proxy( 
    IMSVidStreamBufferSource * This,
    /* [retval][out] */ IUnknown **pRecordingAttribute);


void __RPC_STUB IMSVidStreamBufferSource_get_RecordingAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidStreamBufferSource_CurrentRatings_Proxy( 
    IMSVidStreamBufferSource * This,
    /* [out] */ EnTvRat_System *pEnSystem,
    /* [out] */ EnTvRat_GenericLevel *pEnRating,
    /* [out] */ LONG *pBfEnAttr);


void __RPC_STUB IMSVidStreamBufferSource_CurrentRatings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidStreamBufferSource_MaxRatingsLevel_Proxy( 
    IMSVidStreamBufferSource * This,
    /* [in] */ EnTvRat_System enSystem,
    /* [in] */ EnTvRat_GenericLevel enRating,
    /* [in] */ LONG lbfEnAttr);


void __RPC_STUB IMSVidStreamBufferSource_MaxRatingsLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSVidStreamBufferSource_put_BlockUnrated_Proxy( 
    IMSVidStreamBufferSource * This,
    /* [in] */ VARIANT_BOOL bBlock);


void __RPC_STUB IMSVidStreamBufferSource_put_BlockUnrated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMSVidStreamBufferSource_put_UnratedDelay_Proxy( 
    IMSVidStreamBufferSource * This,
    /* [in] */ long dwDelay);


void __RPC_STUB IMSVidStreamBufferSource_put_UnratedDelay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidStreamBufferSource_get_SBESource_Proxy( 
    IMSVidStreamBufferSource * This,
    /* [retval][out] */ IUnknown **sbeFilter);


void __RPC_STUB IMSVidStreamBufferSource_get_SBESource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSVidStreamBufferSource_INTERFACE_DEFINED__ */


#ifndef __IMSVidStreamBufferSourceEvent_INTERFACE_DEFINED__
#define __IMSVidStreamBufferSourceEvent_INTERFACE_DEFINED__

/* interface IMSVidStreamBufferSourceEvent */
/* [unique][helpstring][uuid][hidden][oleautomation][object] */ 


EXTERN_C const IID IID_IMSVidStreamBufferSourceEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("50CE8A7D-9C28-4DA8-9042-CDFA7116F979")
    IMSVidStreamBufferSourceEvent : public IMSVidFilePlaybackEvent
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CertificateFailure( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CertificateSuccess( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RatingsBlocked( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RatingsUnblocked( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RatingsChanged( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE TimeHole( 
            /* [in] */ long StreamOffsetMS,
            /* [in] */ long SizeMS) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE StaleDataRead( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ContentBecomingStale( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE StaleFileDeleted( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSVidStreamBufferSourceEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSVidStreamBufferSourceEvent * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSVidStreamBufferSourceEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSVidStreamBufferSourceEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSVidStreamBufferSourceEvent * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSVidStreamBufferSourceEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSVidStreamBufferSourceEvent * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSVidStreamBufferSourceEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *EndOfMedia )( 
            IMSVidStreamBufferSourceEvent * This,
            /* [in] */ IMSVidPlayback *lpd);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CertificateFailure )( 
            IMSVidStreamBufferSourceEvent * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CertificateSuccess )( 
            IMSVidStreamBufferSourceEvent * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RatingsBlocked )( 
            IMSVidStreamBufferSourceEvent * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RatingsUnblocked )( 
            IMSVidStreamBufferSourceEvent * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RatingsChanged )( 
            IMSVidStreamBufferSourceEvent * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *TimeHole )( 
            IMSVidStreamBufferSourceEvent * This,
            /* [in] */ long StreamOffsetMS,
            /* [in] */ long SizeMS);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StaleDataRead )( 
            IMSVidStreamBufferSourceEvent * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ContentBecomingStale )( 
            IMSVidStreamBufferSourceEvent * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StaleFileDeleted )( 
            IMSVidStreamBufferSourceEvent * This);
        
        END_INTERFACE
    } IMSVidStreamBufferSourceEventVtbl;

    interface IMSVidStreamBufferSourceEvent
    {
        CONST_VTBL struct IMSVidStreamBufferSourceEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSVidStreamBufferSourceEvent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSVidStreamBufferSourceEvent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSVidStreamBufferSourceEvent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSVidStreamBufferSourceEvent_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSVidStreamBufferSourceEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSVidStreamBufferSourceEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSVidStreamBufferSourceEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)



#define IMSVidStreamBufferSourceEvent_EndOfMedia(This,lpd)	\
    (This)->lpVtbl -> EndOfMedia(This,lpd)



#define IMSVidStreamBufferSourceEvent_CertificateFailure(This)	\
    (This)->lpVtbl -> CertificateFailure(This)

#define IMSVidStreamBufferSourceEvent_CertificateSuccess(This)	\
    (This)->lpVtbl -> CertificateSuccess(This)

#define IMSVidStreamBufferSourceEvent_RatingsBlocked(This)	\
    (This)->lpVtbl -> RatingsBlocked(This)

#define IMSVidStreamBufferSourceEvent_RatingsUnblocked(This)	\
    (This)->lpVtbl -> RatingsUnblocked(This)

#define IMSVidStreamBufferSourceEvent_RatingsChanged(This)	\
    (This)->lpVtbl -> RatingsChanged(This)

#define IMSVidStreamBufferSourceEvent_TimeHole(This,StreamOffsetMS,SizeMS)	\
    (This)->lpVtbl -> TimeHole(This,StreamOffsetMS,SizeMS)

#define IMSVidStreamBufferSourceEvent_StaleDataRead(This)	\
    (This)->lpVtbl -> StaleDataRead(This)

#define IMSVidStreamBufferSourceEvent_ContentBecomingStale(This)	\
    (This)->lpVtbl -> ContentBecomingStale(This)

#define IMSVidStreamBufferSourceEvent_StaleFileDeleted(This)	\
    (This)->lpVtbl -> StaleFileDeleted(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidStreamBufferSourceEvent_CertificateFailure_Proxy( 
    IMSVidStreamBufferSourceEvent * This);


void __RPC_STUB IMSVidStreamBufferSourceEvent_CertificateFailure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidStreamBufferSourceEvent_CertificateSuccess_Proxy( 
    IMSVidStreamBufferSourceEvent * This);


void __RPC_STUB IMSVidStreamBufferSourceEvent_CertificateSuccess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidStreamBufferSourceEvent_RatingsBlocked_Proxy( 
    IMSVidStreamBufferSourceEvent * This);


void __RPC_STUB IMSVidStreamBufferSourceEvent_RatingsBlocked_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidStreamBufferSourceEvent_RatingsUnblocked_Proxy( 
    IMSVidStreamBufferSourceEvent * This);


void __RPC_STUB IMSVidStreamBufferSourceEvent_RatingsUnblocked_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidStreamBufferSourceEvent_RatingsChanged_Proxy( 
    IMSVidStreamBufferSourceEvent * This);


void __RPC_STUB IMSVidStreamBufferSourceEvent_RatingsChanged_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidStreamBufferSourceEvent_TimeHole_Proxy( 
    IMSVidStreamBufferSourceEvent * This,
    /* [in] */ long StreamOffsetMS,
    /* [in] */ long SizeMS);


void __RPC_STUB IMSVidStreamBufferSourceEvent_TimeHole_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidStreamBufferSourceEvent_StaleDataRead_Proxy( 
    IMSVidStreamBufferSourceEvent * This);


void __RPC_STUB IMSVidStreamBufferSourceEvent_StaleDataRead_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidStreamBufferSourceEvent_ContentBecomingStale_Proxy( 
    IMSVidStreamBufferSourceEvent * This);


void __RPC_STUB IMSVidStreamBufferSourceEvent_ContentBecomingStale_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidStreamBufferSourceEvent_StaleFileDeleted_Proxy( 
    IMSVidStreamBufferSourceEvent * This);


void __RPC_STUB IMSVidStreamBufferSourceEvent_StaleFileDeleted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSVidStreamBufferSourceEvent_INTERFACE_DEFINED__ */


#ifndef __IMSVidVideoRenderer2_INTERFACE_DEFINED__
#define __IMSVidVideoRenderer2_INTERFACE_DEFINED__

/* interface IMSVidVideoRenderer2 */
/* [unique][helpstring][uuid][hidden][oleautomation][dual][object] */ 


EXTERN_C const IID IID_IMSVidVideoRenderer2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6BDD5C1E-2810-4159-94BC-05511AE8549B")
    IMSVidVideoRenderer2 : public IMSVidVideoRenderer
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Allocator( 
            /* [retval][out] */ IUnknown **AllocPresent) = 0;
        
        virtual /* [restricted][hidden][id][propget] */ HRESULT STDMETHODCALLTYPE get__Allocator( 
            /* [retval][out] */ IVMRSurfaceAllocator **AllocPresent) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Allocator_ID( 
            /* [retval][out] */ long *ID) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetAllocator( 
            /* [in] */ IUnknown *AllocPresent,
            /* [defaultvalue][in] */ long ID = -1) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE _SetAllocator( 
            /* [in] */ IVMRSurfaceAllocator *AllocPresent,
            /* [defaultvalue][in] */ long ID = -1) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_SuppressEffects( 
            /* [in] */ VARIANT_BOOL bSuppress) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_SuppressEffects( 
            /* [retval][out] */ VARIANT_BOOL *bSuppress) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSVidVideoRenderer2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSVidVideoRenderer2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSVidVideoRenderer2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSVidVideoRenderer2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSVidVideoRenderer2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSVidVideoRenderer2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSVidVideoRenderer2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSVidVideoRenderer2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IMSVidVideoRenderer2 * This,
            /* [retval][out] */ BSTR *Name);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            IMSVidVideoRenderer2 * This,
            /* [retval][out] */ long *Status);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Power )( 
            IMSVidVideoRenderer2 * This,
            /* [in] */ VARIANT_BOOL Power);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Power )( 
            IMSVidVideoRenderer2 * This,
            /* [out][retval] */ VARIANT_BOOL *Power);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Category )( 
            IMSVidVideoRenderer2 * This,
            /* [retval][out] */ BSTR *Guid);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClassID )( 
            IMSVidVideoRenderer2 * This,
            /* [retval][out] */ BSTR *Clsid);
        
        /* [restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__Category )( 
            IMSVidVideoRenderer2 * This,
            /* [retval][out] */ GUID *Guid);
        
        /* [restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__ClassID )( 
            IMSVidVideoRenderer2 * This,
            /* [retval][out] */ GUID *Clsid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsEqualDevice )( 
            IMSVidVideoRenderer2 * This,
            /* [in] */ IMSVidDevice *Device,
            /* [retval][out] */ VARIANT_BOOL *IsEqual);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CustomCompositorClass )( 
            IMSVidVideoRenderer2 * This,
            /* [retval][out] */ BSTR *CompositorCLSID);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CustomCompositorClass )( 
            IMSVidVideoRenderer2 * This,
            /* [in] */ BSTR CompositorCLSID);
        
        /* [id][restricted][hidden][propget] */ HRESULT ( STDMETHODCALLTYPE *get__CustomCompositorClass )( 
            IMSVidVideoRenderer2 * This,
            /* [retval][out] */ GUID *CompositorCLSID);
        
        /* [id][restricted][hidden][propput] */ HRESULT ( STDMETHODCALLTYPE *put__CustomCompositorClass )( 
            IMSVidVideoRenderer2 * This,
            /* [in] */ REFCLSID CompositorCLSID);
        
        /* [id][restricted][hidden][propget] */ HRESULT ( STDMETHODCALLTYPE *get__CustomCompositor )( 
            IMSVidVideoRenderer2 * This,
            /* [retval][out] */ IVMRImageCompositor **Compositor);
        
        /* [id][restricted][hidden][propput] */ HRESULT ( STDMETHODCALLTYPE *put__CustomCompositor )( 
            IMSVidVideoRenderer2 * This,
            /* [in] */ IVMRImageCompositor *Compositor);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MixerBitmap )( 
            IMSVidVideoRenderer2 * This,
            /* [retval][out] */ IPictureDisp **MixerPictureDisp);
        
        /* [id][restricted][hidden][propget] */ HRESULT ( STDMETHODCALLTYPE *get__MixerBitmap )( 
            IMSVidVideoRenderer2 * This,
            /* [retval][out] */ IVMRMixerBitmap **MixerPicture);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MixerBitmap )( 
            IMSVidVideoRenderer2 * This,
            /* [in] */ IPictureDisp *MixerPictureDisp);
        
        /* [id][restricted][hidden][propput] */ HRESULT ( STDMETHODCALLTYPE *put__MixerBitmap )( 
            IMSVidVideoRenderer2 * This,
            /* [in] */ VMRALPHABITMAP *MixerPicture);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MixerBitmapPositionRect )( 
            IMSVidVideoRenderer2 * This,
            /* [retval][out] */ IMSVidRect **rDest);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MixerBitmapPositionRect )( 
            IMSVidVideoRenderer2 * This,
            /* [in] */ IMSVidRect *rDest);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MixerBitmapOpacity )( 
            IMSVidVideoRenderer2 * This,
            /* [retval][out] */ int *opacity);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MixerBitmapOpacity )( 
            IMSVidVideoRenderer2 * This,
            /* [in] */ int opacity);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *SetupMixerBitmap )( 
            IMSVidVideoRenderer2 * This,
            /* [in] */ IPictureDisp *MixerPictureDisp,
            /* [in] */ long Opacity,
            /* [in] */ IMSVidRect *rDest);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourceSize )( 
            IMSVidVideoRenderer2 * This,
            /* [out][retval] */ SourceSizeList *CurrentSize);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SourceSize )( 
            IMSVidVideoRenderer2 * This,
            /* [in] */ SourceSizeList NewSize);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OverScan )( 
            IMSVidVideoRenderer2 * This,
            /* [out][retval] */ long *plPercent);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OverScan )( 
            IMSVidVideoRenderer2 * This,
            /* [in] */ long lPercent);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AvailableSourceRect )( 
            IMSVidVideoRenderer2 * This,
            /* [retval][out] */ IMSVidRect **pRect);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MaxVidRect )( 
            IMSVidVideoRenderer2 * This,
            /* [retval][out] */ IMSVidRect **ppVidRect);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MinVidRect )( 
            IMSVidVideoRenderer2 * This,
            /* [retval][out] */ IMSVidRect **ppVidRect);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClippedSourceRect )( 
            IMSVidVideoRenderer2 * This,
            /* [retval][out] */ IMSVidRect **pRect);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ClippedSourceRect )( 
            IMSVidVideoRenderer2 * This,
            /* [in] */ IMSVidRect *pRect);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UsingOverlay )( 
            IMSVidVideoRenderer2 * This,
            /* [retval][out] */ VARIANT_BOOL *UseOverlayVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_UsingOverlay )( 
            IMSVidVideoRenderer2 * This,
            /* [in] */ VARIANT_BOOL UseOverlayVal);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Capture )( 
            IMSVidVideoRenderer2 * This,
            /* [retval][out] */ IPictureDisp **currentImage);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FramesPerSecond )( 
            IMSVidVideoRenderer2 * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DecimateInput )( 
            IMSVidVideoRenderer2 * This,
            /* [retval][out] */ VARIANT_BOOL *pDeci);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DecimateInput )( 
            IMSVidVideoRenderer2 * This,
            /* [in] */ VARIANT_BOOL pDeci);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Allocator )( 
            IMSVidVideoRenderer2 * This,
            /* [retval][out] */ IUnknown **AllocPresent);
        
        /* [restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__Allocator )( 
            IMSVidVideoRenderer2 * This,
            /* [retval][out] */ IVMRSurfaceAllocator **AllocPresent);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Allocator_ID )( 
            IMSVidVideoRenderer2 * This,
            /* [retval][out] */ long *ID);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *SetAllocator )( 
            IMSVidVideoRenderer2 * This,
            /* [in] */ IUnknown *AllocPresent,
            /* [defaultvalue][in] */ long ID);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *_SetAllocator )( 
            IMSVidVideoRenderer2 * This,
            /* [in] */ IVMRSurfaceAllocator *AllocPresent,
            /* [defaultvalue][in] */ long ID);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SuppressEffects )( 
            IMSVidVideoRenderer2 * This,
            /* [in] */ VARIANT_BOOL bSuppress);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SuppressEffects )( 
            IMSVidVideoRenderer2 * This,
            /* [retval][out] */ VARIANT_BOOL *bSuppress);
        
        END_INTERFACE
    } IMSVidVideoRenderer2Vtbl;

    interface IMSVidVideoRenderer2
    {
        CONST_VTBL struct IMSVidVideoRenderer2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSVidVideoRenderer2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSVidVideoRenderer2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSVidVideoRenderer2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSVidVideoRenderer2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSVidVideoRenderer2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSVidVideoRenderer2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSVidVideoRenderer2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSVidVideoRenderer2_get_Name(This,Name)	\
    (This)->lpVtbl -> get_Name(This,Name)

#define IMSVidVideoRenderer2_get_Status(This,Status)	\
    (This)->lpVtbl -> get_Status(This,Status)

#define IMSVidVideoRenderer2_put_Power(This,Power)	\
    (This)->lpVtbl -> put_Power(This,Power)

#define IMSVidVideoRenderer2_get_Power(This,Power)	\
    (This)->lpVtbl -> get_Power(This,Power)

#define IMSVidVideoRenderer2_get_Category(This,Guid)	\
    (This)->lpVtbl -> get_Category(This,Guid)

#define IMSVidVideoRenderer2_get_ClassID(This,Clsid)	\
    (This)->lpVtbl -> get_ClassID(This,Clsid)

#define IMSVidVideoRenderer2_get__Category(This,Guid)	\
    (This)->lpVtbl -> get__Category(This,Guid)

#define IMSVidVideoRenderer2_get__ClassID(This,Clsid)	\
    (This)->lpVtbl -> get__ClassID(This,Clsid)

#define IMSVidVideoRenderer2_IsEqualDevice(This,Device,IsEqual)	\
    (This)->lpVtbl -> IsEqualDevice(This,Device,IsEqual)



#define IMSVidVideoRenderer2_get_CustomCompositorClass(This,CompositorCLSID)	\
    (This)->lpVtbl -> get_CustomCompositorClass(This,CompositorCLSID)

#define IMSVidVideoRenderer2_put_CustomCompositorClass(This,CompositorCLSID)	\
    (This)->lpVtbl -> put_CustomCompositorClass(This,CompositorCLSID)

#define IMSVidVideoRenderer2_get__CustomCompositorClass(This,CompositorCLSID)	\
    (This)->lpVtbl -> get__CustomCompositorClass(This,CompositorCLSID)

#define IMSVidVideoRenderer2_put__CustomCompositorClass(This,CompositorCLSID)	\
    (This)->lpVtbl -> put__CustomCompositorClass(This,CompositorCLSID)

#define IMSVidVideoRenderer2_get__CustomCompositor(This,Compositor)	\
    (This)->lpVtbl -> get__CustomCompositor(This,Compositor)

#define IMSVidVideoRenderer2_put__CustomCompositor(This,Compositor)	\
    (This)->lpVtbl -> put__CustomCompositor(This,Compositor)

#define IMSVidVideoRenderer2_get_MixerBitmap(This,MixerPictureDisp)	\
    (This)->lpVtbl -> get_MixerBitmap(This,MixerPictureDisp)

#define IMSVidVideoRenderer2_get__MixerBitmap(This,MixerPicture)	\
    (This)->lpVtbl -> get__MixerBitmap(This,MixerPicture)

#define IMSVidVideoRenderer2_put_MixerBitmap(This,MixerPictureDisp)	\
    (This)->lpVtbl -> put_MixerBitmap(This,MixerPictureDisp)

#define IMSVidVideoRenderer2_put__MixerBitmap(This,MixerPicture)	\
    (This)->lpVtbl -> put__MixerBitmap(This,MixerPicture)

#define IMSVidVideoRenderer2_get_MixerBitmapPositionRect(This,rDest)	\
    (This)->lpVtbl -> get_MixerBitmapPositionRect(This,rDest)

#define IMSVidVideoRenderer2_put_MixerBitmapPositionRect(This,rDest)	\
    (This)->lpVtbl -> put_MixerBitmapPositionRect(This,rDest)

#define IMSVidVideoRenderer2_get_MixerBitmapOpacity(This,opacity)	\
    (This)->lpVtbl -> get_MixerBitmapOpacity(This,opacity)

#define IMSVidVideoRenderer2_put_MixerBitmapOpacity(This,opacity)	\
    (This)->lpVtbl -> put_MixerBitmapOpacity(This,opacity)

#define IMSVidVideoRenderer2_SetupMixerBitmap(This,MixerPictureDisp,Opacity,rDest)	\
    (This)->lpVtbl -> SetupMixerBitmap(This,MixerPictureDisp,Opacity,rDest)

#define IMSVidVideoRenderer2_get_SourceSize(This,CurrentSize)	\
    (This)->lpVtbl -> get_SourceSize(This,CurrentSize)

#define IMSVidVideoRenderer2_put_SourceSize(This,NewSize)	\
    (This)->lpVtbl -> put_SourceSize(This,NewSize)

#define IMSVidVideoRenderer2_get_OverScan(This,plPercent)	\
    (This)->lpVtbl -> get_OverScan(This,plPercent)

#define IMSVidVideoRenderer2_put_OverScan(This,lPercent)	\
    (This)->lpVtbl -> put_OverScan(This,lPercent)

#define IMSVidVideoRenderer2_get_AvailableSourceRect(This,pRect)	\
    (This)->lpVtbl -> get_AvailableSourceRect(This,pRect)

#define IMSVidVideoRenderer2_get_MaxVidRect(This,ppVidRect)	\
    (This)->lpVtbl -> get_MaxVidRect(This,ppVidRect)

#define IMSVidVideoRenderer2_get_MinVidRect(This,ppVidRect)	\
    (This)->lpVtbl -> get_MinVidRect(This,ppVidRect)

#define IMSVidVideoRenderer2_get_ClippedSourceRect(This,pRect)	\
    (This)->lpVtbl -> get_ClippedSourceRect(This,pRect)

#define IMSVidVideoRenderer2_put_ClippedSourceRect(This,pRect)	\
    (This)->lpVtbl -> put_ClippedSourceRect(This,pRect)

#define IMSVidVideoRenderer2_get_UsingOverlay(This,UseOverlayVal)	\
    (This)->lpVtbl -> get_UsingOverlay(This,UseOverlayVal)

#define IMSVidVideoRenderer2_put_UsingOverlay(This,UseOverlayVal)	\
    (This)->lpVtbl -> put_UsingOverlay(This,UseOverlayVal)

#define IMSVidVideoRenderer2_Capture(This,currentImage)	\
    (This)->lpVtbl -> Capture(This,currentImage)

#define IMSVidVideoRenderer2_get_FramesPerSecond(This,pVal)	\
    (This)->lpVtbl -> get_FramesPerSecond(This,pVal)

#define IMSVidVideoRenderer2_get_DecimateInput(This,pDeci)	\
    (This)->lpVtbl -> get_DecimateInput(This,pDeci)

#define IMSVidVideoRenderer2_put_DecimateInput(This,pDeci)	\
    (This)->lpVtbl -> put_DecimateInput(This,pDeci)


#define IMSVidVideoRenderer2_get_Allocator(This,AllocPresent)	\
    (This)->lpVtbl -> get_Allocator(This,AllocPresent)

#define IMSVidVideoRenderer2_get__Allocator(This,AllocPresent)	\
    (This)->lpVtbl -> get__Allocator(This,AllocPresent)

#define IMSVidVideoRenderer2_get_Allocator_ID(This,ID)	\
    (This)->lpVtbl -> get_Allocator_ID(This,ID)

#define IMSVidVideoRenderer2_SetAllocator(This,AllocPresent,ID)	\
    (This)->lpVtbl -> SetAllocator(This,AllocPresent,ID)

#define IMSVidVideoRenderer2__SetAllocator(This,AllocPresent,ID)	\
    (This)->lpVtbl -> _SetAllocator(This,AllocPresent,ID)

#define IMSVidVideoRenderer2_put_SuppressEffects(This,bSuppress)	\
    (This)->lpVtbl -> put_SuppressEffects(This,bSuppress)

#define IMSVidVideoRenderer2_get_SuppressEffects(This,bSuppress)	\
    (This)->lpVtbl -> get_SuppressEffects(This,bSuppress)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidVideoRenderer2_get_Allocator_Proxy( 
    IMSVidVideoRenderer2 * This,
    /* [retval][out] */ IUnknown **AllocPresent);


void __RPC_STUB IMSVidVideoRenderer2_get_Allocator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidVideoRenderer2_get__Allocator_Proxy( 
    IMSVidVideoRenderer2 * This,
    /* [retval][out] */ IVMRSurfaceAllocator **AllocPresent);


void __RPC_STUB IMSVidVideoRenderer2_get__Allocator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidVideoRenderer2_get_Allocator_ID_Proxy( 
    IMSVidVideoRenderer2 * This,
    /* [retval][out] */ long *ID);


void __RPC_STUB IMSVidVideoRenderer2_get_Allocator_ID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IMSVidVideoRenderer2_SetAllocator_Proxy( 
    IMSVidVideoRenderer2 * This,
    /* [in] */ IUnknown *AllocPresent,
    /* [defaultvalue][in] */ long ID);


void __RPC_STUB IMSVidVideoRenderer2_SetAllocator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IMSVidVideoRenderer2__SetAllocator_Proxy( 
    IMSVidVideoRenderer2 * This,
    /* [in] */ IVMRSurfaceAllocator *AllocPresent,
    /* [defaultvalue][in] */ long ID);


void __RPC_STUB IMSVidVideoRenderer2__SetAllocator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IMSVidVideoRenderer2_put_SuppressEffects_Proxy( 
    IMSVidVideoRenderer2 * This,
    /* [in] */ VARIANT_BOOL bSuppress);


void __RPC_STUB IMSVidVideoRenderer2_put_SuppressEffects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidVideoRenderer2_get_SuppressEffects_Proxy( 
    IMSVidVideoRenderer2 * This,
    /* [retval][out] */ VARIANT_BOOL *bSuppress);


void __RPC_STUB IMSVidVideoRenderer2_get_SuppressEffects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSVidVideoRenderer2_INTERFACE_DEFINED__ */


#ifndef __IMSVidVideoRendererEvent2_INTERFACE_DEFINED__
#define __IMSVidVideoRendererEvent2_INTERFACE_DEFINED__

/* interface IMSVidVideoRendererEvent2 */
/* [unique][helpstring][uuid][hidden][oleautomation][object] */ 


EXTERN_C const IID IID_IMSVidVideoRendererEvent2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7145ED66-4730-4fdb-8A53-FDE7508D3E5E")
    IMSVidVideoRendererEvent2 : public IMSVidOutputDeviceEvent
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OverlayUnavailable( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSVidVideoRendererEvent2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSVidVideoRendererEvent2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSVidVideoRendererEvent2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSVidVideoRendererEvent2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSVidVideoRendererEvent2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSVidVideoRendererEvent2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSVidVideoRendererEvent2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSVidVideoRendererEvent2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *StateChange )( 
            IMSVidVideoRendererEvent2 * This,
            /* [in] */ IMSVidDevice *lpd,
            /* [in] */ long oldState,
            /* [in] */ long newState);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OverlayUnavailable )( 
            IMSVidVideoRendererEvent2 * This);
        
        END_INTERFACE
    } IMSVidVideoRendererEvent2Vtbl;

    interface IMSVidVideoRendererEvent2
    {
        CONST_VTBL struct IMSVidVideoRendererEvent2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSVidVideoRendererEvent2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSVidVideoRendererEvent2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSVidVideoRendererEvent2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSVidVideoRendererEvent2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSVidVideoRendererEvent2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSVidVideoRendererEvent2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSVidVideoRendererEvent2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSVidVideoRendererEvent2_StateChange(This,lpd,oldState,newState)	\
    (This)->lpVtbl -> StateChange(This,lpd,oldState,newState)



#define IMSVidVideoRendererEvent2_OverlayUnavailable(This)	\
    (This)->lpVtbl -> OverlayUnavailable(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMSVidVideoRendererEvent2_OverlayUnavailable_Proxy( 
    IMSVidVideoRendererEvent2 * This);


void __RPC_STUB IMSVidVideoRendererEvent2_OverlayUnavailable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSVidVideoRendererEvent2_INTERFACE_DEFINED__ */


#ifndef __IMSVidAudioRenderer_INTERFACE_DEFINED__
#define __IMSVidAudioRenderer_INTERFACE_DEFINED__

/* interface IMSVidAudioRenderer */
/* [unique][helpstring][uuid][hidden][oleautomation][dual][object] */ 


EXTERN_C const IID IID_IMSVidAudioRenderer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("37B0353F-A4C8-11d2-B634-00C04F79498E")
    IMSVidAudioRenderer : public IMSVidOutputDevice
    {
    public:
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Volume( 
            /* [in] */ long lVol) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Volume( 
            /* [out][retval] */ long *lVol) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Balance( 
            /* [in] */ long lBal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Balance( 
            /* [out][retval] */ long *lBal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSVidAudioRendererVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSVidAudioRenderer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSVidAudioRenderer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSVidAudioRenderer * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSVidAudioRenderer * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSVidAudioRenderer * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSVidAudioRenderer * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSVidAudioRenderer * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IMSVidAudioRenderer * This,
            /* [retval][out] */ BSTR *Name);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            IMSVidAudioRenderer * This,
            /* [retval][out] */ long *Status);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Power )( 
            IMSVidAudioRenderer * This,
            /* [in] */ VARIANT_BOOL Power);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Power )( 
            IMSVidAudioRenderer * This,
            /* [out][retval] */ VARIANT_BOOL *Power);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Category )( 
            IMSVidAudioRenderer * This,
            /* [retval][out] */ BSTR *Guid);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClassID )( 
            IMSVidAudioRenderer * This,
            /* [retval][out] */ BSTR *Clsid);
        
        /* [restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__Category )( 
            IMSVidAudioRenderer * This,
            /* [retval][out] */ GUID *Guid);
        
        /* [restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__ClassID )( 
            IMSVidAudioRenderer * This,
            /* [retval][out] */ GUID *Clsid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsEqualDevice )( 
            IMSVidAudioRenderer * This,
            /* [in] */ IMSVidDevice *Device,
            /* [retval][out] */ VARIANT_BOOL *IsEqual);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Volume )( 
            IMSVidAudioRenderer * This,
            /* [in] */ long lVol);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Volume )( 
            IMSVidAudioRenderer * This,
            /* [out][retval] */ long *lVol);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Balance )( 
            IMSVidAudioRenderer * This,
            /* [in] */ long lBal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Balance )( 
            IMSVidAudioRenderer * This,
            /* [out][retval] */ long *lBal);
        
        END_INTERFACE
    } IMSVidAudioRendererVtbl;

    interface IMSVidAudioRenderer
    {
        CONST_VTBL struct IMSVidAudioRendererVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSVidAudioRenderer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSVidAudioRenderer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSVidAudioRenderer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSVidAudioRenderer_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSVidAudioRenderer_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSVidAudioRenderer_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSVidAudioRenderer_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSVidAudioRenderer_get_Name(This,Name)	\
    (This)->lpVtbl -> get_Name(This,Name)

#define IMSVidAudioRenderer_get_Status(This,Status)	\
    (This)->lpVtbl -> get_Status(This,Status)

#define IMSVidAudioRenderer_put_Power(This,Power)	\
    (This)->lpVtbl -> put_Power(This,Power)

#define IMSVidAudioRenderer_get_Power(This,Power)	\
    (This)->lpVtbl -> get_Power(This,Power)

#define IMSVidAudioRenderer_get_Category(This,Guid)	\
    (This)->lpVtbl -> get_Category(This,Guid)

#define IMSVidAudioRenderer_get_ClassID(This,Clsid)	\
    (This)->lpVtbl -> get_ClassID(This,Clsid)

#define IMSVidAudioRenderer_get__Category(This,Guid)	\
    (This)->lpVtbl -> get__Category(This,Guid)

#define IMSVidAudioRenderer_get__ClassID(This,Clsid)	\
    (This)->lpVtbl -> get__ClassID(This,Clsid)

#define IMSVidAudioRenderer_IsEqualDevice(This,Device,IsEqual)	\
    (This)->lpVtbl -> IsEqualDevice(This,Device,IsEqual)



#define IMSVidAudioRenderer_put_Volume(This,lVol)	\
    (This)->lpVtbl -> put_Volume(This,lVol)

#define IMSVidAudioRenderer_get_Volume(This,lVol)	\
    (This)->lpVtbl -> get_Volume(This,lVol)

#define IMSVidAudioRenderer_put_Balance(This,lBal)	\
    (This)->lpVtbl -> put_Balance(This,lBal)

#define IMSVidAudioRenderer_get_Balance(This,lBal)	\
    (This)->lpVtbl -> get_Balance(This,lBal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propput] */ HRESULT STDMETHODCALLTYPE IMSVidAudioRenderer_put_Volume_Proxy( 
    IMSVidAudioRenderer * This,
    /* [in] */ long lVol);


void __RPC_STUB IMSVidAudioRenderer_put_Volume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidAudioRenderer_get_Volume_Proxy( 
    IMSVidAudioRenderer * This,
    /* [out][retval] */ long *lVol);


void __RPC_STUB IMSVidAudioRenderer_get_Volume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IMSVidAudioRenderer_put_Balance_Proxy( 
    IMSVidAudioRenderer * This,
    /* [in] */ long lBal);


void __RPC_STUB IMSVidAudioRenderer_put_Balance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidAudioRenderer_get_Balance_Proxy( 
    IMSVidAudioRenderer * This,
    /* [out][retval] */ long *lBal);


void __RPC_STUB IMSVidAudioRenderer_get_Balance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSVidAudioRenderer_INTERFACE_DEFINED__ */


#ifndef __IMSVidAudioRendererEvent_INTERFACE_DEFINED__
#define __IMSVidAudioRendererEvent_INTERFACE_DEFINED__

/* interface IMSVidAudioRendererEvent */
/* [unique][helpstring][uuid][hidden][oleautomation][object] */ 


EXTERN_C const IID IID_IMSVidAudioRendererEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("37B03541-A4C8-11d2-B634-00C04F79498E")
    IMSVidAudioRendererEvent : public IMSVidOutputDeviceEvent
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IMSVidAudioRendererEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSVidAudioRendererEvent * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSVidAudioRendererEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSVidAudioRendererEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSVidAudioRendererEvent * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSVidAudioRendererEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSVidAudioRendererEvent * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSVidAudioRendererEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *StateChange )( 
            IMSVidAudioRendererEvent * This,
            /* [in] */ IMSVidDevice *lpd,
            /* [in] */ long oldState,
            /* [in] */ long newState);
        
        END_INTERFACE
    } IMSVidAudioRendererEventVtbl;

    interface IMSVidAudioRendererEvent
    {
        CONST_VTBL struct IMSVidAudioRendererEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSVidAudioRendererEvent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSVidAudioRendererEvent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSVidAudioRendererEvent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSVidAudioRendererEvent_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSVidAudioRendererEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSVidAudioRendererEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSVidAudioRendererEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSVidAudioRendererEvent_StateChange(This,lpd,oldState,newState)	\
    (This)->lpVtbl -> StateChange(This,lpd,oldState,newState)



#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMSVidAudioRendererEvent_INTERFACE_DEFINED__ */


#ifndef __IMSVidInputDevices_INTERFACE_DEFINED__
#define __IMSVidInputDevices_INTERFACE_DEFINED__

/* interface IMSVidInputDevices */
/* [unique][helpstring][uuid][hidden][oleautomation][dual][object] */ 


EXTERN_C const IID IID_IMSVidInputDevices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C5702CD1-9B79-11d3-B654-00C04F79498E")
    IMSVidInputDevices : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *lCount) = 0;
        
        virtual /* [restricted][hidden][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IEnumVARIANT **pD) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT v,
            /* [retval][out] */ IMSVidInputDevice **pDB) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ IMSVidInputDevice *pDB) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ VARIANT v) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSVidInputDevicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSVidInputDevices * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSVidInputDevices * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSVidInputDevices * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSVidInputDevices * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSVidInputDevices * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSVidInputDevices * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSVidInputDevices * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IMSVidInputDevices * This,
            /* [retval][out] */ long *lCount);
        
        /* [restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IMSVidInputDevices * This,
            /* [retval][out] */ IEnumVARIANT **pD);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IMSVidInputDevices * This,
            /* [in] */ VARIANT v,
            /* [retval][out] */ IMSVidInputDevice **pDB);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            IMSVidInputDevices * This,
            /* [in] */ IMSVidInputDevice *pDB);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IMSVidInputDevices * This,
            /* [in] */ VARIANT v);
        
        END_INTERFACE
    } IMSVidInputDevicesVtbl;

    interface IMSVidInputDevices
    {
        CONST_VTBL struct IMSVidInputDevicesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSVidInputDevices_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSVidInputDevices_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSVidInputDevices_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSVidInputDevices_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSVidInputDevices_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSVidInputDevices_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSVidInputDevices_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSVidInputDevices_get_Count(This,lCount)	\
    (This)->lpVtbl -> get_Count(This,lCount)

#define IMSVidInputDevices_get__NewEnum(This,pD)	\
    (This)->lpVtbl -> get__NewEnum(This,pD)

#define IMSVidInputDevices_get_Item(This,v,pDB)	\
    (This)->lpVtbl -> get_Item(This,v,pDB)

#define IMSVidInputDevices_Add(This,pDB)	\
    (This)->lpVtbl -> Add(This,pDB)

#define IMSVidInputDevices_Remove(This,v)	\
    (This)->lpVtbl -> Remove(This,v)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidInputDevices_get_Count_Proxy( 
    IMSVidInputDevices * This,
    /* [retval][out] */ long *lCount);


void __RPC_STUB IMSVidInputDevices_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidInputDevices_get__NewEnum_Proxy( 
    IMSVidInputDevices * This,
    /* [retval][out] */ IEnumVARIANT **pD);


void __RPC_STUB IMSVidInputDevices_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidInputDevices_get_Item_Proxy( 
    IMSVidInputDevices * This,
    /* [in] */ VARIANT v,
    /* [retval][out] */ IMSVidInputDevice **pDB);


void __RPC_STUB IMSVidInputDevices_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IMSVidInputDevices_Add_Proxy( 
    IMSVidInputDevices * This,
    /* [in] */ IMSVidInputDevice *pDB);


void __RPC_STUB IMSVidInputDevices_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IMSVidInputDevices_Remove_Proxy( 
    IMSVidInputDevices * This,
    /* [in] */ VARIANT v);


void __RPC_STUB IMSVidInputDevices_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSVidInputDevices_INTERFACE_DEFINED__ */


#ifndef __IMSVidOutputDevices_INTERFACE_DEFINED__
#define __IMSVidOutputDevices_INTERFACE_DEFINED__

/* interface IMSVidOutputDevices */
/* [unique][helpstring][uuid][hidden][oleautomation][dual][object] */ 


EXTERN_C const IID IID_IMSVidOutputDevices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C5702CD2-9B79-11d3-B654-00C04F79498E")
    IMSVidOutputDevices : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *lCount) = 0;
        
        virtual /* [restricted][hidden][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IEnumVARIANT **pD) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT v,
            /* [retval][out] */ IMSVidOutputDevice **pDB) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ IMSVidOutputDevice *pDB) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ VARIANT v) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSVidOutputDevicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSVidOutputDevices * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSVidOutputDevices * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSVidOutputDevices * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSVidOutputDevices * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSVidOutputDevices * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSVidOutputDevices * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSVidOutputDevices * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IMSVidOutputDevices * This,
            /* [retval][out] */ long *lCount);
        
        /* [restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IMSVidOutputDevices * This,
            /* [retval][out] */ IEnumVARIANT **pD);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IMSVidOutputDevices * This,
            /* [in] */ VARIANT v,
            /* [retval][out] */ IMSVidOutputDevice **pDB);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            IMSVidOutputDevices * This,
            /* [in] */ IMSVidOutputDevice *pDB);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IMSVidOutputDevices * This,
            /* [in] */ VARIANT v);
        
        END_INTERFACE
    } IMSVidOutputDevicesVtbl;

    interface IMSVidOutputDevices
    {
        CONST_VTBL struct IMSVidOutputDevicesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSVidOutputDevices_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSVidOutputDevices_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSVidOutputDevices_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSVidOutputDevices_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSVidOutputDevices_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSVidOutputDevices_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSVidOutputDevices_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSVidOutputDevices_get_Count(This,lCount)	\
    (This)->lpVtbl -> get_Count(This,lCount)

#define IMSVidOutputDevices_get__NewEnum(This,pD)	\
    (This)->lpVtbl -> get__NewEnum(This,pD)

#define IMSVidOutputDevices_get_Item(This,v,pDB)	\
    (This)->lpVtbl -> get_Item(This,v,pDB)

#define IMSVidOutputDevices_Add(This,pDB)	\
    (This)->lpVtbl -> Add(This,pDB)

#define IMSVidOutputDevices_Remove(This,v)	\
    (This)->lpVtbl -> Remove(This,v)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidOutputDevices_get_Count_Proxy( 
    IMSVidOutputDevices * This,
    /* [retval][out] */ long *lCount);


void __RPC_STUB IMSVidOutputDevices_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidOutputDevices_get__NewEnum_Proxy( 
    IMSVidOutputDevices * This,
    /* [retval][out] */ IEnumVARIANT **pD);


void __RPC_STUB IMSVidOutputDevices_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidOutputDevices_get_Item_Proxy( 
    IMSVidOutputDevices * This,
    /* [in] */ VARIANT v,
    /* [retval][out] */ IMSVidOutputDevice **pDB);


void __RPC_STUB IMSVidOutputDevices_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IMSVidOutputDevices_Add_Proxy( 
    IMSVidOutputDevices * This,
    /* [in] */ IMSVidOutputDevice *pDB);


void __RPC_STUB IMSVidOutputDevices_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IMSVidOutputDevices_Remove_Proxy( 
    IMSVidOutputDevices * This,
    /* [in] */ VARIANT v);


void __RPC_STUB IMSVidOutputDevices_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSVidOutputDevices_INTERFACE_DEFINED__ */


#ifndef __IMSVidVideoRendererDevices_INTERFACE_DEFINED__
#define __IMSVidVideoRendererDevices_INTERFACE_DEFINED__

/* interface IMSVidVideoRendererDevices */
/* [unique][helpstring][uuid][hidden][oleautomation][dual][object] */ 


EXTERN_C const IID IID_IMSVidVideoRendererDevices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C5702CD3-9B79-11d3-B654-00C04F79498E")
    IMSVidVideoRendererDevices : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *lCount) = 0;
        
        virtual /* [restricted][hidden][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IEnumVARIANT **pD) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT v,
            /* [retval][out] */ IMSVidVideoRenderer **pDB) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ IMSVidVideoRenderer *pDB) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ VARIANT v) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSVidVideoRendererDevicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSVidVideoRendererDevices * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSVidVideoRendererDevices * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSVidVideoRendererDevices * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSVidVideoRendererDevices * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSVidVideoRendererDevices * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSVidVideoRendererDevices * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSVidVideoRendererDevices * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IMSVidVideoRendererDevices * This,
            /* [retval][out] */ long *lCount);
        
        /* [restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IMSVidVideoRendererDevices * This,
            /* [retval][out] */ IEnumVARIANT **pD);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IMSVidVideoRendererDevices * This,
            /* [in] */ VARIANT v,
            /* [retval][out] */ IMSVidVideoRenderer **pDB);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            IMSVidVideoRendererDevices * This,
            /* [in] */ IMSVidVideoRenderer *pDB);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IMSVidVideoRendererDevices * This,
            /* [in] */ VARIANT v);
        
        END_INTERFACE
    } IMSVidVideoRendererDevicesVtbl;

    interface IMSVidVideoRendererDevices
    {
        CONST_VTBL struct IMSVidVideoRendererDevicesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSVidVideoRendererDevices_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSVidVideoRendererDevices_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSVidVideoRendererDevices_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSVidVideoRendererDevices_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSVidVideoRendererDevices_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSVidVideoRendererDevices_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSVidVideoRendererDevices_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSVidVideoRendererDevices_get_Count(This,lCount)	\
    (This)->lpVtbl -> get_Count(This,lCount)

#define IMSVidVideoRendererDevices_get__NewEnum(This,pD)	\
    (This)->lpVtbl -> get__NewEnum(This,pD)

#define IMSVidVideoRendererDevices_get_Item(This,v,pDB)	\
    (This)->lpVtbl -> get_Item(This,v,pDB)

#define IMSVidVideoRendererDevices_Add(This,pDB)	\
    (This)->lpVtbl -> Add(This,pDB)

#define IMSVidVideoRendererDevices_Remove(This,v)	\
    (This)->lpVtbl -> Remove(This,v)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidVideoRendererDevices_get_Count_Proxy( 
    IMSVidVideoRendererDevices * This,
    /* [retval][out] */ long *lCount);


void __RPC_STUB IMSVidVideoRendererDevices_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidVideoRendererDevices_get__NewEnum_Proxy( 
    IMSVidVideoRendererDevices * This,
    /* [retval][out] */ IEnumVARIANT **pD);


void __RPC_STUB IMSVidVideoRendererDevices_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidVideoRendererDevices_get_Item_Proxy( 
    IMSVidVideoRendererDevices * This,
    /* [in] */ VARIANT v,
    /* [retval][out] */ IMSVidVideoRenderer **pDB);


void __RPC_STUB IMSVidVideoRendererDevices_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IMSVidVideoRendererDevices_Add_Proxy( 
    IMSVidVideoRendererDevices * This,
    /* [in] */ IMSVidVideoRenderer *pDB);


void __RPC_STUB IMSVidVideoRendererDevices_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IMSVidVideoRendererDevices_Remove_Proxy( 
    IMSVidVideoRendererDevices * This,
    /* [in] */ VARIANT v);


void __RPC_STUB IMSVidVideoRendererDevices_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSVidVideoRendererDevices_INTERFACE_DEFINED__ */


#ifndef __IMSVidAudioRendererDevices_INTERFACE_DEFINED__
#define __IMSVidAudioRendererDevices_INTERFACE_DEFINED__

/* interface IMSVidAudioRendererDevices */
/* [unique][helpstring][uuid][hidden][oleautomation][dual][object] */ 


EXTERN_C const IID IID_IMSVidAudioRendererDevices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C5702CD4-9B79-11d3-B654-00C04F79498E")
    IMSVidAudioRendererDevices : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *lCount) = 0;
        
        virtual /* [restricted][hidden][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IEnumVARIANT **pD) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT v,
            /* [retval][out] */ IMSVidAudioRenderer **pDB) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ IMSVidAudioRenderer *pDB) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ VARIANT v) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSVidAudioRendererDevicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSVidAudioRendererDevices * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSVidAudioRendererDevices * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSVidAudioRendererDevices * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSVidAudioRendererDevices * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSVidAudioRendererDevices * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSVidAudioRendererDevices * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSVidAudioRendererDevices * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IMSVidAudioRendererDevices * This,
            /* [retval][out] */ long *lCount);
        
        /* [restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IMSVidAudioRendererDevices * This,
            /* [retval][out] */ IEnumVARIANT **pD);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IMSVidAudioRendererDevices * This,
            /* [in] */ VARIANT v,
            /* [retval][out] */ IMSVidAudioRenderer **pDB);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            IMSVidAudioRendererDevices * This,
            /* [in] */ IMSVidAudioRenderer *pDB);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IMSVidAudioRendererDevices * This,
            /* [in] */ VARIANT v);
        
        END_INTERFACE
    } IMSVidAudioRendererDevicesVtbl;

    interface IMSVidAudioRendererDevices
    {
        CONST_VTBL struct IMSVidAudioRendererDevicesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSVidAudioRendererDevices_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSVidAudioRendererDevices_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSVidAudioRendererDevices_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSVidAudioRendererDevices_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSVidAudioRendererDevices_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSVidAudioRendererDevices_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSVidAudioRendererDevices_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSVidAudioRendererDevices_get_Count(This,lCount)	\
    (This)->lpVtbl -> get_Count(This,lCount)

#define IMSVidAudioRendererDevices_get__NewEnum(This,pD)	\
    (This)->lpVtbl -> get__NewEnum(This,pD)

#define IMSVidAudioRendererDevices_get_Item(This,v,pDB)	\
    (This)->lpVtbl -> get_Item(This,v,pDB)

#define IMSVidAudioRendererDevices_Add(This,pDB)	\
    (This)->lpVtbl -> Add(This,pDB)

#define IMSVidAudioRendererDevices_Remove(This,v)	\
    (This)->lpVtbl -> Remove(This,v)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidAudioRendererDevices_get_Count_Proxy( 
    IMSVidAudioRendererDevices * This,
    /* [retval][out] */ long *lCount);


void __RPC_STUB IMSVidAudioRendererDevices_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidAudioRendererDevices_get__NewEnum_Proxy( 
    IMSVidAudioRendererDevices * This,
    /* [retval][out] */ IEnumVARIANT **pD);


void __RPC_STUB IMSVidAudioRendererDevices_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidAudioRendererDevices_get_Item_Proxy( 
    IMSVidAudioRendererDevices * This,
    /* [in] */ VARIANT v,
    /* [retval][out] */ IMSVidAudioRenderer **pDB);


void __RPC_STUB IMSVidAudioRendererDevices_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IMSVidAudioRendererDevices_Add_Proxy( 
    IMSVidAudioRendererDevices * This,
    /* [in] */ IMSVidAudioRenderer *pDB);


void __RPC_STUB IMSVidAudioRendererDevices_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IMSVidAudioRendererDevices_Remove_Proxy( 
    IMSVidAudioRendererDevices * This,
    /* [in] */ VARIANT v);


void __RPC_STUB IMSVidAudioRendererDevices_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSVidAudioRendererDevices_INTERFACE_DEFINED__ */


#ifndef __IMSVidFeatures_INTERFACE_DEFINED__
#define __IMSVidFeatures_INTERFACE_DEFINED__

/* interface IMSVidFeatures */
/* [unique][helpstring][uuid][hidden][oleautomation][dual][object] */ 


EXTERN_C const IID IID_IMSVidFeatures;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C5702CD5-9B79-11d3-B654-00C04F79498E")
    IMSVidFeatures : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *lCount) = 0;
        
        virtual /* [restricted][hidden][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IEnumVARIANT **pD) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT v,
            /* [retval][out] */ IMSVidFeature **pDB) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ IMSVidFeature *pDB) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ VARIANT v) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSVidFeaturesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMSVidFeatures * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMSVidFeatures * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMSVidFeatures * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMSVidFeatures * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMSVidFeatures * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMSVidFeatures * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMSVidFeatures * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IMSVidFeatures * This,
            /* [retval][out] */ long *lCount);
        
        /* [restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IMSVidFeatures * This,
            /* [retval][out] */ IEnumVARIANT **pD);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IMSVidFeatures * This,
            /* [in] */ VARIANT v,
            /* [retval][out] */ IMSVidFeature **pDB);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            IMSVidFeatures * This,
            /* [in] */ IMSVidFeature *pDB);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IMSVidFeatures * This,
            /* [in] */ VARIANT v);
        
        END_INTERFACE
    } IMSVidFeaturesVtbl;

    interface IMSVidFeatures
    {
        CONST_VTBL struct IMSVidFeaturesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSVidFeatures_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSVidFeatures_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSVidFeatures_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSVidFeatures_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMSVidFeatures_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMSVidFeatures_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMSVidFeatures_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMSVidFeatures_get_Count(This,lCount)	\
    (This)->lpVtbl -> get_Count(This,lCount)

#define IMSVidFeatures_get__NewEnum(This,pD)	\
    (This)->lpVtbl -> get__NewEnum(This,pD)

#define IMSVidFeatures_get_Item(This,v,pDB)	\
    (This)->lpVtbl -> get_Item(This,v,pDB)

#define IMSVidFeatures_Add(This,pDB)	\
    (This)->lpVtbl -> Add(This,pDB)

#define IMSVidFeatures_Remove(This,v)	\
    (This)->lpVtbl -> Remove(This,v)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidFeatures_get_Count_Proxy( 
    IMSVidFeatures * This,
    /* [retval][out] */ long *lCount);


void __RPC_STUB IMSVidFeatures_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidFeatures_get__NewEnum_Proxy( 
    IMSVidFeatures * This,
    /* [retval][out] */ IEnumVARIANT **pD);


void __RPC_STUB IMSVidFeatures_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMSVidFeatures_get_Item_Proxy( 
    IMSVidFeatures * This,
    /* [in] */ VARIANT v,
    /* [retval][out] */ IMSVidFeature **pDB);


void __RPC_STUB IMSVidFeatures_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IMSVidFeatures_Add_Proxy( 
    IMSVidFeatures * This,
    /* [in] */ IMSVidFeature *pDB);


void __RPC_STUB IMSVidFeatures_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IMSVidFeatures_Remove_Proxy( 
    IMSVidFeatures * This,
    /* [in] */ VARIANT v);


void __RPC_STUB IMSVidFeatures_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSVidFeatures_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  HDC_UserSize(     unsigned long *, unsigned long            , HDC * ); 
unsigned char * __RPC_USER  HDC_UserMarshal(  unsigned long *, unsigned char *, HDC * ); 
unsigned char * __RPC_USER  HDC_UserUnmarshal(unsigned long *, unsigned char *, HDC * ); 
void                      __RPC_USER  HDC_UserFree(     unsigned long *, HDC * ); 

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long *, unsigned long            , HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal(  unsigned long *, unsigned char *, HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal(unsigned long *, unsigned char *, HWND * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long *, HWND * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DirectX\9c\Include\sbe.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0357 */
/* Compiler settings for sbe.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __sbe_h__
#define __sbe_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IStreamBufferInitialize_FWD_DEFINED__
#define __IStreamBufferInitialize_FWD_DEFINED__
typedef interface IStreamBufferInitialize IStreamBufferInitialize;
#endif 	/* __IStreamBufferInitialize_FWD_DEFINED__ */


#ifndef __IStreamBufferSink_FWD_DEFINED__
#define __IStreamBufferSink_FWD_DEFINED__
typedef interface IStreamBufferSink IStreamBufferSink;
#endif 	/* __IStreamBufferSink_FWD_DEFINED__ */


#ifndef __IStreamBufferSource_FWD_DEFINED__
#define __IStreamBufferSource_FWD_DEFINED__
typedef interface IStreamBufferSource IStreamBufferSource;
#endif 	/* __IStreamBufferSource_FWD_DEFINED__ */


#ifndef __IStreamBufferRecordControl_FWD_DEFINED__
#define __IStreamBufferRecordControl_FWD_DEFINED__
typedef interface IStreamBufferRecordControl IStreamBufferRecordControl;
#endif 	/* __IStreamBufferRecordControl_FWD_DEFINED__ */


#ifndef __IStreamBufferRecComp_FWD_DEFINED__
#define __IStreamBufferRecComp_FWD_DEFINED__
typedef interface IStreamBufferRecComp IStreamBufferRecComp;
#endif 	/* __IStreamBufferRecComp_FWD_DEFINED__ */


#ifndef __IStreamBufferRecordingAttribute_FWD_DEFINED__
#define __IStreamBufferRecordingAttribute_FWD_DEFINED__
typedef interface IStreamBufferRecordingAttribute IStreamBufferRecordingAttribute;
#endif 	/* __IStreamBufferRecordingAttribute_FWD_DEFINED__ */


#ifndef __IEnumStreamBufferRecordingAttrib_FWD_DEFINED__
#define __IEnumStreamBufferRecordingAttrib_FWD_DEFINED__
typedef interface IEnumStreamBufferRecordingAttrib IEnumStreamBufferRecordingAttrib;
#endif 	/* __IEnumStreamBufferRecordingAttrib_FWD_DEFINED__ */


#ifndef __IStreamBufferConfigure_FWD_DEFINED__
#define __IStreamBufferConfigure_FWD_DEFINED__
typedef interface IStreamBufferConfigure IStreamBufferConfigure;
#endif 	/* __IStreamBufferConfigure_FWD_DEFINED__ */


#ifndef __IStreamBufferMediaSeeking_FWD_DEFINED__
#define __IStreamBufferMediaSeeking_FWD_DEFINED__
typedef interface IStreamBufferMediaSeeking IStreamBufferMediaSeeking;
#endif 	/* __IStreamBufferMediaSeeking_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "objidl.h"
#include "strmif.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_sbe_0000 */
/* [local] */ 












extern RPC_IF_HANDLE __MIDL_itf_sbe_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_sbe_0000_v0_0_s_ifspec;

#ifndef __IStreamBufferInitialize_INTERFACE_DEFINED__
#define __IStreamBufferInitialize_INTERFACE_DEFINED__

/* interface IStreamBufferInitialize */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IStreamBufferInitialize;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9ce50f2d-6ba7-40fb-a034-50b1a674ec78")
    IStreamBufferInitialize : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetHKEY( 
            /* [in] */ HKEY hkeyRoot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSIDs( 
            /* [in] */ DWORD cSIDs,
            /* [size_is][in] */ PSID *ppSID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStreamBufferInitializeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IStreamBufferInitialize * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IStreamBufferInitialize * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IStreamBufferInitialize * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetHKEY )( 
            IStreamBufferInitialize * This,
            /* [in] */ HKEY hkeyRoot);
        
        HRESULT ( STDMETHODCALLTYPE *SetSIDs )( 
            IStreamBufferInitialize * This,
            /* [in] */ DWORD cSIDs,
            /* [size_is][in] */ PSID *ppSID);
        
        END_INTERFACE
    } IStreamBufferInitializeVtbl;

    interface IStreamBufferInitialize
    {
        CONST_VTBL struct IStreamBufferInitializeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStreamBufferInitialize_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IStreamBufferInitialize_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IStreamBufferInitialize_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IStreamBufferInitialize_SetHKEY(This,hkeyRoot)	\
    (This)->lpVtbl -> SetHKEY(This,hkeyRoot)

#define IStreamBufferInitialize_SetSIDs(This,cSIDs,ppSID)	\
    (This)->lpVtbl -> SetSIDs(This,cSIDs,ppSID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IStreamBufferInitialize_SetHKEY_Proxy( 
    IStreamBufferInitialize * This,
    /* [in] */ HKEY hkeyRoot);


void __RPC_STUB IStreamBufferInitialize_SetHKEY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStreamBufferInitialize_SetSIDs_Proxy( 
    IStreamBufferInitialize * This,
    /* [in] */ DWORD cSIDs,
    /* [size_is][in] */ PSID *ppSID);


void __RPC_STUB IStreamBufferInitialize_SetSIDs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IStreamBufferInitialize_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_sbe_0408 */
/* [local] */ 


enum __MIDL___MIDL_itf_sbe_0408_0001
    {	RECORDING_TYPE_CONTENT	= 0,
	RECORDING_TYPE_REFERENCE	= RECORDING_TYPE_CONTENT + 1
    } ;


extern RPC_IF_HANDLE __MIDL_itf_sbe_0408_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_sbe_0408_v0_0_s_ifspec;

#ifndef __IStreamBufferSink_INTERFACE_DEFINED__
#define __IStreamBufferSink_INTERFACE_DEFINED__

/* interface IStreamBufferSink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IStreamBufferSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("afd1f242-7efd-45ee-ba4e-407a25c9a77a")
    IStreamBufferSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE LockProfile( 
            /* [in] */ LPCWSTR pszStreamBufferFilename) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateRecorder( 
            /* [in] */ LPCWSTR pszFilename,
            /* [in] */ DWORD dwRecordType,
            /* [out] */ IUnknown **pRecordingIUnknown) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsProfileLocked( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStreamBufferSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IStreamBufferSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IStreamBufferSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IStreamBufferSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *LockProfile )( 
            IStreamBufferSink * This,
            /* [in] */ LPCWSTR pszStreamBufferFilename);
        
        HRESULT ( STDMETHODCALLTYPE *CreateRecorder )( 
            IStreamBufferSink * This,
            /* [in] */ LPCWSTR pszFilename,
            /* [in] */ DWORD dwRecordType,
            /* [out] */ IUnknown **pRecordingIUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *IsProfileLocked )( 
            IStreamBufferSink * This);
        
        END_INTERFACE
    } IStreamBufferSinkVtbl;

    interface IStreamBufferSink
    {
        CONST_VTBL struct IStreamBufferSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStreamBufferSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IStreamBufferSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IStreamBufferSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IStreamBufferSink_LockProfile(This,pszStreamBufferFilename)	\
    (This)->lpVtbl -> LockProfile(This,pszStreamBufferFilename)

#define IStreamBufferSink_CreateRecorder(This,pszFilename,dwRecordType,pRecordingIUnknown)	\
    (This)->lpVtbl -> CreateRecorder(This,pszFilename,dwRecordType,pRecordingIUnknown)

#define IStreamBufferSink_IsProfileLocked(This)	\
    (This)->lpVtbl -> IsProfileLocked(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IStreamBufferSink_LockProfile_Proxy( 
    IStreamBufferSink * This,
    /* [in] */ LPCWSTR pszStreamBufferFilename);


void __RPC_STUB IStreamBufferSink_LockProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStreamBufferSink_CreateRecorder_Proxy( 
    IStreamBufferSink * This,
    /* [in] */ LPCWSTR pszFilename,
    /* [in] */ DWORD dwRecordType,
    /* [out] */ IUnknown **pRecordingIUnknown);


void __RPC_STUB IStreamBufferSink_CreateRecorder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStreamBufferSink_IsProfileLocked_Proxy( 
    IStreamBufferSink * This);


void __RPC_STUB IStreamBufferSink_IsProfileLocked_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IStreamBufferSink_INTERFACE_DEFINED__ */


#ifndef __IStreamBufferSource_INTERFACE_DEFINED__
#define __IStreamBufferSource_INTERFACE_DEFINED__

/* interface IStreamBufferSource */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IStreamBufferSource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1c5bd776-6ced-4f44-8164-5eab0e98db12")
    IStreamBufferSource : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetStreamSink( 
            /* [in] */ IStreamBufferSink *pIStreamBufferSink) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStreamBufferSourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IStreamBufferSource * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IStreamBufferSource * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IStreamBufferSource * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetStreamSink )( 
            IStreamBufferSource * This,
            /* [in] */ IStreamBufferSink *pIStreamBufferSink);
        
        END_INTERFACE
    } IStreamBufferSourceVtbl;

    interface IStreamBufferSource
    {
        CONST_VTBL struct IStreamBufferSourceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStreamBufferSource_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IStreamBufferSource_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IStreamBufferSource_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IStreamBufferSource_SetStreamSink(This,pIStreamBufferSink)	\
    (This)->lpVtbl -> SetStreamSink(This,pIStreamBufferSink)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IStreamBufferSource_SetStreamSink_Proxy( 
    IStreamBufferSource * This,
    /* [in] */ IStreamBufferSink *pIStreamBufferSink);


void __RPC_STUB IStreamBufferSource_SetStreamSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IStreamBufferSource_INTERFACE_DEFINED__ */


#ifndef __IStreamBufferRecordControl_INTERFACE_DEFINED__
#define __IStreamBufferRecordControl_INTERFACE_DEFINED__

/* interface IStreamBufferRecordControl */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IStreamBufferRecordControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ba9b6c99-f3c7-4ff2-92db-cfdd4851bf31")
    IStreamBufferRecordControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Start( 
            /* [out][in] */ REFERENCE_TIME *prtStart) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( 
            /* [in] */ REFERENCE_TIME rtStop) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordingStatus( 
            /* [out] */ HRESULT *phResult,
            /* [out] */ BOOL *pbStarted,
            /* [out] */ BOOL *pbStopped) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStreamBufferRecordControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IStreamBufferRecordControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IStreamBufferRecordControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IStreamBufferRecordControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *Start )( 
            IStreamBufferRecordControl * This,
            /* [out][in] */ REFERENCE_TIME *prtStart);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IStreamBufferRecordControl * This,
            /* [in] */ REFERENCE_TIME rtStop);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordingStatus )( 
            IStreamBufferRecordControl * This,
            /* [out] */ HRESULT *phResult,
            /* [out] */ BOOL *pbStarted,
            /* [out] */ BOOL *pbStopped);
        
        END_INTERFACE
    } IStreamBufferRecordControlVtbl;

    interface IStreamBufferRecordControl
    {
        CONST_VTBL struct IStreamBufferRecordControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStreamBufferRecordControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IStreamBufferRecordControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IStreamBufferRecordControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IStreamBufferRecordControl_Start(This,prtStart)	\
    (This)->lpVtbl -> Start(This,prtStart)

#define IStreamBufferRecordControl_Stop(This,rtStop)	\
    (This)->lpVtbl -> Stop(This,rtStop)

#define IStreamBufferRecordControl_GetRecordingStatus(This,phResult,pbStarted,pbStopped)	\
    (This)->lpVtbl -> GetRecordingStatus(This,phResult,pbStarted,pbStopped)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IStreamBufferRecordControl_Start_Proxy( 
    IStreamBufferRecordControl * This,
    /* [out][in] */ REFERENCE_TIME *prtStart);


void __RPC_STUB IStreamBufferRecordControl_Start_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStreamBufferRecordControl_Stop_Proxy( 
    IStreamBufferRecordControl * This,
    /* [in] */ REFERENCE_TIME rtStop);


void __RPC_STUB IStreamBufferRecordControl_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStreamBufferRecordControl_GetRecordingStatus_Proxy( 
    IStreamBufferRecordControl * This,
    /* [out] */ HRESULT *phResult,
    /* [out] */ BOOL *pbStarted,
    /* [out] */ BOOL *pbStopped);


void __RPC_STUB IStreamBufferRecordControl_GetRecordingStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IStreamBufferRecordControl_INTERFACE_DEFINED__ */


#ifndef __IStreamBufferRecComp_INTERFACE_DEFINED__
#define __IStreamBufferRecComp_INTERFACE_DEFINED__

/* interface IStreamBufferRecComp */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IStreamBufferRecComp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9E259A9B-8815-42ae-B09F-221970B154FD")
    IStreamBufferRecComp : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LPCWSTR pszTargetFilename,
            /* [in] */ LPCWSTR pszSBRecProfileRef) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Append( 
            /* [in] */ LPCWSTR pszSBRecording) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AppendEx( 
            /* [in] */ LPCWSTR pszSBRecording,
            /* [in] */ REFERENCE_TIME rtStart,
            /* [in] */ REFERENCE_TIME rtStop) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentLength( 
            /* [out] */ DWORD *pcSeconds) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Cancel( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStreamBufferRecCompVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IStreamBufferRecComp * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IStreamBufferRecComp * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IStreamBufferRecComp * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IStreamBufferRecComp * This,
            /* [in] */ LPCWSTR pszTargetFilename,
            /* [in] */ LPCWSTR pszSBRecProfileRef);
        
        HRESULT ( STDMETHODCALLTYPE *Append )( 
            IStreamBufferRecComp * This,
            /* [in] */ LPCWSTR pszSBRecording);
        
        HRESULT ( STDMETHODCALLTYPE *AppendEx )( 
            IStreamBufferRecComp * This,
            /* [in] */ LPCWSTR pszSBRecording,
            /* [in] */ REFERENCE_TIME rtStart,
            /* [in] */ REFERENCE_TIME rtStop);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentLength )( 
            IStreamBufferRecComp * This,
            /* [out] */ DWORD *pcSeconds);
        
        HRESULT ( STDMETHODCALLTYPE *Close )( 
            IStreamBufferRecComp * This);
        
        HRESULT ( STDMETHODCALLTYPE *Cancel )( 
            IStreamBufferRecComp * This);
        
        END_INTERFACE
    } IStreamBufferRecCompVtbl;

    interface IStreamBufferRecComp
    {
        CONST_VTBL struct IStreamBufferRecCompVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStreamBufferRecComp_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IStreamBufferRecComp_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IStreamBufferRecComp_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IStreamBufferRecComp_Initialize(This,pszTargetFilename,pszSBRecProfileRef)	\
    (This)->lpVtbl -> Initialize(This,pszTargetFilename,pszSBRecProfileRef)

#define IStreamBufferRecComp_Append(This,pszSBRecording)	\
    (This)->lpVtbl -> Append(This,pszSBRecording)

#define IStreamBufferRecComp_AppendEx(This,pszSBRecording,rtStart,rtStop)	\
    (This)->lpVtbl -> AppendEx(This,pszSBRecording,rtStart,rtStop)

#define IStreamBufferRecComp_GetCurrentLength(This,pcSeconds)	\
    (This)->lpVtbl -> GetCurrentLength(This,pcSeconds)

#define IStreamBufferRecComp_Close(This)	\
    (This)->lpVtbl -> Close(This)

#define IStreamBufferRecComp_Cancel(This)	\
    (This)->lpVtbl -> Cancel(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IStreamBufferRecComp_Initialize_Proxy( 
    IStreamBufferRecComp * This,
    /* [in] */ LPCWSTR pszTargetFilename,
    /* [in] */ LPCWSTR pszSBRecProfileRef);


void __RPC_STUB IStreamBufferRecComp_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStreamBufferRecComp_Append_Proxy( 
    IStreamBufferRecComp * This,
    /* [in] */ LPCWSTR pszSBRecording);


void __RPC_STUB IStreamBufferRecComp_Append_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStreamBufferRecComp_AppendEx_Proxy( 
    IStreamBufferRecComp * This,
    /* [in] */ LPCWSTR pszSBRecording,
    /* [in] */ REFERENCE_TIME rtStart,
    /* [in] */ REFERENCE_TIME rtStop);


void __RPC_STUB IStreamBufferRecComp_AppendEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStreamBufferRecComp_GetCurrentLength_Proxy( 
    IStreamBufferRecComp * This,
    /* [out] */ DWORD *pcSeconds);


void __RPC_STUB IStreamBufferRecComp_GetCurrentLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStreamBufferRecComp_Close_Proxy( 
    IStreamBufferRecComp * This);


void __RPC_STUB IStreamBufferRecComp_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStreamBufferRecComp_Cancel_Proxy( 
    IStreamBufferRecComp * This);


void __RPC_STUB IStreamBufferRecComp_Cancel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IStreamBufferRecComp_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_sbe_0412 */
/* [local] */ 

////////////////////////////////////////////////////////////////
//
// List of pre-defined attributes 
//
static const WCHAR g_wszStreamBufferRecordingDuration[] =L"Duration";
static const WCHAR g_wszStreamBufferRecordingBitrate[] =L"Bitrate";
static const WCHAR g_wszStreamBufferRecordingSeekable[] =L"Seekable";
static const WCHAR g_wszStreamBufferRecordingStridable[] =L"Stridable";
static const WCHAR g_wszStreamBufferRecordingBroadcast[] =L"Broadcast";
static const WCHAR g_wszStreamBufferRecordingProtected[] =L"Is_Protected";
static const WCHAR g_wszStreamBufferRecordingTrusted[] =L"Is_Trusted";
static const WCHAR g_wszStreamBufferRecordingSignature_Name[] =L"Signature_Name";
static const WCHAR g_wszStreamBufferRecordingHasAudio[] =L"HasAudio";
static const WCHAR g_wszStreamBufferRecordingHasImage[] =L"HasImage";
static const WCHAR g_wszStreamBufferRecordingHasScript[] =L"HasScript";
static const WCHAR g_wszStreamBufferRecordingHasVideo[] =L"HasVideo";
static const WCHAR g_wszStreamBufferRecordingCurrentBitrate[] =L"CurrentBitrate";
static const WCHAR g_wszStreamBufferRecordingOptimalBitrate[] =L"OptimalBitrate";
static const WCHAR g_wszStreamBufferRecordingHasAttachedImages[] =L"HasAttachedImages";
static const WCHAR g_wszStreamBufferRecordingSkipBackward[] =L"Can_Skip_Backward";
static const WCHAR g_wszStreamBufferRecordingSkipForward[] =L"Can_Skip_Forward";
static const WCHAR g_wszStreamBufferRecordingNumberOfFrames[] =L"NumberOfFrames";
static const WCHAR g_wszStreamBufferRecordingFileSize[] =L"FileSize";
static const WCHAR g_wszStreamBufferRecordingHasArbitraryDataStream[] =L"HasArbitraryDataStream";
static const WCHAR g_wszStreamBufferRecordingHasFileTransferStream[] =L"HasFileTransferStream";

////////////////////////////////////////////////////////////////
//
// The content description object supports 5 basic attributes.
//
static const WCHAR g_wszStreamBufferRecordingTitle[] =L"Title";
static const WCHAR g_wszStreamBufferRecordingAuthor[] =L"Author";
static const WCHAR g_wszStreamBufferRecordingDescription[] =L"Description";
static const WCHAR g_wszStreamBufferRecordingRating[] =L"Rating";
static const WCHAR g_wszStreamBufferRecordingCopyright[] =L"Copyright";

////////////////////////////////////////////////////////////////
//
// These attributes are used to configure DRM using IWMDRMWriter::SetDRMAttribute.
//
static const WCHAR *g_wszStreamBufferRecordingUse_DRM = L"Use_DRM";
static const WCHAR *g_wszStreamBufferRecordingDRM_Flags = L"DRM_Flags";
static const WCHAR *g_wszStreamBufferRecordingDRM_Level = L"DRM_Level";

////////////////////////////////////////////////////////////////
//
// These are the additional attributes defined in the WM attribute
// namespace that give information about the content.
//
static const WCHAR g_wszStreamBufferRecordingAlbumTitle[] =L"WM/AlbumTitle";
static const WCHAR g_wszStreamBufferRecordingTrack[] =L"WM/Track";
static const WCHAR g_wszStreamBufferRecordingPromotionURL[] =L"WM/PromotionURL";
static const WCHAR g_wszStreamBufferRecordingAlbumCoverURL[] =L"WM/AlbumCoverURL";
static const WCHAR g_wszStreamBufferRecordingGenre[] =L"WM/Genre";
static const WCHAR g_wszStreamBufferRecordingYear[] =L"WM/Year";
static const WCHAR g_wszStreamBufferRecordingGenreID[] =L"WM/GenreID";
static const WCHAR g_wszStreamBufferRecordingMCDI[] =L"WM/MCDI";
static const WCHAR g_wszStreamBufferRecordingComposer[] =L"WM/Composer";
static const WCHAR g_wszStreamBufferRecordingLyrics[] =L"WM/Lyrics";
static const WCHAR g_wszStreamBufferRecordingTrackNumber[] =L"WM/TrackNumber";
static const WCHAR g_wszStreamBufferRecordingToolName[] =L"WM/ToolName";
static const WCHAR g_wszStreamBufferRecordingToolVersion[] =L"WM/ToolVersion";
static const WCHAR g_wszStreamBufferRecordingIsVBR[] =L"IsVBR";
static const WCHAR g_wszStreamBufferRecordingAlbumArtist[] =L"WM/AlbumArtist";

////////////////////////////////////////////////////////////////
//
// These optional attributes may be used to give information 
// about the branding of the content.
//
static const WCHAR g_wszStreamBufferRecordingBannerImageType[] =L"BannerImageType";
static const WCHAR g_wszStreamBufferRecordingBannerImageData[] =L"BannerImageData";
static const WCHAR g_wszStreamBufferRecordingBannerImageURL[] =L"BannerImageURL";
static const WCHAR g_wszStreamBufferRecordingCopyrightURL[] =L"CopyrightURL";
////////////////////////////////////////////////////////////////
//
// Optional attributes, used to give information 
// about video stream properties.
//
static const WCHAR g_wszStreamBufferRecordingAspectRatioX[] =L"AspectRatioX";
static const WCHAR g_wszStreamBufferRecordingAspectRatioY[] =L"AspectRatioY";
////////////////////////////////////////////////////////////////
//
// The NSC file supports the following attributes.
//
static const WCHAR g_wszStreamBufferRecordingNSCName[] =L"NSC_Name";
static const WCHAR g_wszStreamBufferRecordingNSCAddress[] =L"NSC_Address";
static const WCHAR g_wszStreamBufferRecordingNSCPhone[] =L"NSC_Phone";
static const WCHAR g_wszStreamBufferRecordingNSCEmail[] =L"NSC_Email";
static const WCHAR g_wszStreamBufferRecordingNSCDescription[] =L"NSC_Description";

typedef /* [public][public][public][public][public][public] */ 
enum __MIDL___MIDL_itf_sbe_0412_0001
    {	STREAMBUFFER_TYPE_DWORD	= 0,
	STREAMBUFFER_TYPE_STRING	= 1,
	STREAMBUFFER_TYPE_BINARY	= 2,
	STREAMBUFFER_TYPE_BOOL	= 3,
	STREAMBUFFER_TYPE_QWORD	= 4,
	STREAMBUFFER_TYPE_WORD	= 5,
	STREAMBUFFER_TYPE_GUID	= 6
    } 	STREAMBUFFER_ATTR_DATATYPE;



extern RPC_IF_HANDLE __MIDL_itf_sbe_0412_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_sbe_0412_v0_0_s_ifspec;

#ifndef __IStreamBufferRecordingAttribute_INTERFACE_DEFINED__
#define __IStreamBufferRecordingAttribute_INTERFACE_DEFINED__

/* interface IStreamBufferRecordingAttribute */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IStreamBufferRecordingAttribute;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("16CA4E03-FE69-4705-BD41-5B7DFC0C95F3")
    IStreamBufferRecordingAttribute : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetAttribute( 
            /* [in] */ ULONG ulReserved,
            /* [in] */ LPCWSTR pszAttributeName,
            /* [in] */ STREAMBUFFER_ATTR_DATATYPE StreamBufferAttributeType,
            /* [in] */ BYTE *pbAttribute,
            /* [in] */ WORD cbAttributeLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttributeCount( 
            /* [in] */ ULONG ulReserved,
            /* [out] */ WORD *pcAttributes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttributeByName( 
            /* [in] */ LPCWSTR pszAttributeName,
            /* [in] */ ULONG *pulReserved,
            /* [out] */ STREAMBUFFER_ATTR_DATATYPE *pStreamBufferAttributeType,
            /* [out] */ BYTE *pbAttribute,
            /* [out][in] */ WORD *pcbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttributeByIndex( 
            /* [in] */ WORD wIndex,
            /* [in] */ ULONG *pulReserved,
            /* [out] */ WCHAR *pszAttributeName,
            /* [out][in] */ WORD *pcchNameLength,
            /* [out] */ STREAMBUFFER_ATTR_DATATYPE *pStreamBufferAttributeType,
            /* [out] */ BYTE *pbAttribute,
            /* [out][in] */ WORD *pcbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumAttributes( 
            /* [out] */ IEnumStreamBufferRecordingAttrib **ppIEnumStreamBufferAttrib) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStreamBufferRecordingAttributeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IStreamBufferRecordingAttribute * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IStreamBufferRecordingAttribute * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IStreamBufferRecordingAttribute * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetAttribute )( 
            IStreamBufferRecordingAttribute * This,
            /* [in] */ ULONG ulReserved,
            /* [in] */ LPCWSTR pszAttributeName,
            /* [in] */ STREAMBUFFER_ATTR_DATATYPE StreamBufferAttributeType,
            /* [in] */ BYTE *pbAttribute,
            /* [in] */ WORD cbAttributeLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributeCount )( 
            IStreamBufferRecordingAttribute * This,
            /* [in] */ ULONG ulReserved,
            /* [out] */ WORD *pcAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributeByName )( 
            IStreamBufferRecordingAttribute * This,
            /* [in] */ LPCWSTR pszAttributeName,
            /* [in] */ ULONG *pulReserved,
            /* [out] */ STREAMBUFFER_ATTR_DATATYPE *pStreamBufferAttributeType,
            /* [out] */ BYTE *pbAttribute,
            /* [out][in] */ WORD *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributeByIndex )( 
            IStreamBufferRecordingAttribute * This,
            /* [in] */ WORD wIndex,
            /* [in] */ ULONG *pulReserved,
            /* [out] */ WCHAR *pszAttributeName,
            /* [out][in] */ WORD *pcchNameLength,
            /* [out] */ STREAMBUFFER_ATTR_DATATYPE *pStreamBufferAttributeType,
            /* [out] */ BYTE *pbAttribute,
            /* [out][in] */ WORD *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE *EnumAttributes )( 
            IStreamBufferRecordingAttribute * This,
            /* [out] */ IEnumStreamBufferRecordingAttrib **ppIEnumStreamBufferAttrib);
        
        END_INTERFACE
    } IStreamBufferRecordingAttributeVtbl;

    interface IStreamBufferRecordingAttribute
    {
        CONST_VTBL struct IStreamBufferRecordingAttributeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStreamBufferRecordingAttribute_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IStreamBufferRecordingAttribute_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IStreamBufferRecordingAttribute_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IStreamBufferRecordingAttribute_SetAttribute(This,ulReserved,pszAttributeName,StreamBufferAttributeType,pbAttribute,cbAttributeLength)	\
    (This)->lpVtbl -> SetAttribute(This,ulReserved,pszAttributeName,StreamBufferAttributeType,pbAttribute,cbAttributeLength)

#define IStreamBufferRecordingAttribute_GetAttributeCount(This,ulReserved,pcAttributes)	\
    (This)->lpVtbl -> GetAttributeCount(This,ulReserved,pcAttributes)

#define IStreamBufferRecordingAttribute_GetAttributeByName(This,pszAttributeName,pulReserved,pStreamBufferAttributeType,pbAttribute,pcbLength)	\
    (This)->lpVtbl -> GetAttributeByName(This,pszAttributeName,pulReserved,pStreamBufferAttributeType,pbAttribute,pcbLength)

#define IStreamBufferRecordingAttribute_GetAttributeByIndex(This,wIndex,pulReserved,pszAttributeName,pcchNameLength,pStreamBufferAttributeType,pbAttribute,pcbLength)	\
    (This)->lpVtbl -> GetAttributeByIndex(This,wIndex,pulReserved,pszAttributeName,pcchNameLength,pStreamBufferAttributeType,pbAttribute,pcbLength)

#define IStreamBufferRecordingAttribute_EnumAttributes(This,ppIEnumStreamBufferAttrib)	\
    (This)->lpVtbl -> EnumAttributes(This,ppIEnumStreamBufferAttrib)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IStreamBufferRecordingAttribute_SetAttribute_Proxy( 
    IStreamBufferRecordingAttribute * This,
    /* [in] */ ULONG ulReserved,
    /* [in] */ LPCWSTR pszAttributeName,
    /* [in] */ STREAMBUFFER_ATTR_DATATYPE StreamBufferAttributeType,
    /* [in] */ BYTE *pbAttribute,
    /* [in] */ WORD cbAttributeLength);


void __RPC_STUB IStreamBufferRecordingAttribute_SetAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStreamBufferRecordingAttribute_GetAttributeCount_Proxy( 
    IStreamBufferRecordingAttribute * This,
    /* [in] */ ULONG ulReserved,
    /* [out] */ WORD *pcAttributes);


void __RPC_STUB IStreamBufferRecordingAttribute_GetAttributeCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStreamBufferRecordingAttribute_GetAttributeByName_Proxy( 
    IStreamBufferRecordingAttribute * This,
    /* [in] */ LPCWSTR pszAttributeName,
    /* [in] */ ULONG *pulReserved,
    /* [out] */ STREAMBUFFER_ATTR_DATATYPE *pStreamBufferAttributeType,
    /* [out] */ BYTE *pbAttribute,
    /* [out][in] */ WORD *pcbLength);


void __RPC_STUB IStreamBufferRecordingAttribute_GetAttributeByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStreamBufferRecordingAttribute_GetAttributeByIndex_Proxy( 
    IStreamBufferRecordingAttribute * This,
    /* [in] */ WORD wIndex,
    /* [in] */ ULONG *pulReserved,
    /* [out] */ WCHAR *pszAttributeName,
    /* [out][in] */ WORD *pcchNameLength,
    /* [out] */ STREAMBUFFER_ATTR_DATATYPE *pStreamBufferAttributeType,
    /* [out] */ BYTE *pbAttribute,
    /* [out][in] */ WORD *pcbLength);


void __RPC_STUB IStreamBufferRecordingAttribute_GetAttributeByIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStreamBufferRecordingAttribute_EnumAttributes_Proxy( 
    IStreamBufferRecordingAttribute * This,
    /* [out] */ IEnumStreamBufferRecordingAttrib **ppIEnumStreamBufferAttrib);


void __RPC_STUB IStreamBufferRecordingAttribute_EnumAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IStreamBufferRecordingAttribute_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_sbe_0413 */
/* [local] */ 

typedef /* [public][public] */ struct __MIDL___MIDL_itf_sbe_0413_0001
    {
    LPWSTR pszName;
    STREAMBUFFER_ATTR_DATATYPE StreamBufferAttributeType;
    BYTE *pbAttribute;
    WORD cbLength;
    } 	STREAMBUFFER_ATTRIBUTE;



extern RPC_IF_HANDLE __MIDL_itf_sbe_0413_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_sbe_0413_v0_0_s_ifspec;

#ifndef __IEnumStreamBufferRecordingAttrib_INTERFACE_DEFINED__
#define __IEnumStreamBufferRecordingAttrib_INTERFACE_DEFINED__

/* interface IEnumStreamBufferRecordingAttrib */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumStreamBufferRecordingAttrib;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C18A9162-1E82-4142-8C73-5690FA62FE33")
    IEnumStreamBufferRecordingAttrib : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG cRequest,
            /* [size_is][out][in] */ STREAMBUFFER_ATTRIBUTE *pStreamBufferAttribute,
            /* [out] */ ULONG *pcReceived) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cRecords) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumStreamBufferRecordingAttrib **ppIEnumStreamBufferAttrib) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumStreamBufferRecordingAttribVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumStreamBufferRecordingAttrib * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumStreamBufferRecordingAttrib * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumStreamBufferRecordingAttrib * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumStreamBufferRecordingAttrib * This,
            /* [in] */ ULONG cRequest,
            /* [size_is][out][in] */ STREAMBUFFER_ATTRIBUTE *pStreamBufferAttribute,
            /* [out] */ ULONG *pcReceived);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumStreamBufferRecordingAttrib * This,
            /* [in] */ ULONG cRecords);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumStreamBufferRecordingAttrib * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumStreamBufferRecordingAttrib * This,
            /* [out] */ IEnumStreamBufferRecordingAttrib **ppIEnumStreamBufferAttrib);
        
        END_INTERFACE
    } IEnumStreamBufferRecordingAttribVtbl;

    interface IEnumStreamBufferRecordingAttrib
    {
        CONST_VTBL struct IEnumStreamBufferRecordingAttribVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumStreamBufferRecordingAttrib_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumStreamBufferRecordingAttrib_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumStreamBufferRecordingAttrib_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumStreamBufferRecordingAttrib_Next(This,cRequest,pStreamBufferAttribute,pcReceived)	\
    (This)->lpVtbl -> Next(This,cRequest,pStreamBufferAttribute,pcReceived)

#define IEnumStreamBufferRecordingAttrib_Skip(This,cRecords)	\
    (This)->lpVtbl -> Skip(This,cRecords)

#define IEnumStreamBufferRecordingAttrib_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumStreamBufferRecordingAttrib_Clone(This,ppIEnumStreamBufferAttrib)	\
    (This)->lpVtbl -> Clone(This,ppIEnumStreamBufferAttrib)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumStreamBufferRecordingAttrib_Next_Proxy( 
    IEnumStreamBufferRecordingAttrib * This,
    /* [in] */ ULONG cRequest,
    /* [size_is][out][in] */ STREAMBUFFER_ATTRIBUTE *pStreamBufferAttribute,
    /* [out] */ ULONG *pcReceived);


void __RPC_STUB IEnumStreamBufferRecordingAttrib_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumStreamBufferRecordingAttrib_Skip_Proxy( 
    IEnumStreamBufferRecordingAttrib * This,
    /* [in] */ ULONG cRecords);


void __RPC_STUB IEnumStreamBufferRecordingAttrib_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumStreamBufferRecordingAttrib_Reset_Proxy( 
    IEnumStreamBufferRecordingAttrib * This);


void __RPC_STUB IEnumStreamBufferRecordingAttrib_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumStreamBufferRecordingAttrib_Clone_Proxy( 
    IEnumStreamBufferRecordingAttrib * This,
    /* [out] */ IEnumStreamBufferRecordingAttrib **ppIEnumStreamBufferAttrib);


void __RPC_STUB IEnumStreamBufferRecordingAttrib_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumStreamBufferRecordingAttrib_INTERFACE_DEFINED__ */


#ifndef __IStreamBufferConfigure_INTERFACE_DEFINED__
#define __IStreamBufferConfigure_INTERFACE_DEFINED__

/* interface IStreamBufferConfigure */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IStreamBufferConfigure;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ce14dfae-4098-4af7-bbf7-d6511f835414")
    IStreamBufferConfigure : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetDirectory( 
            /* [in] */ LPCWSTR pszDirectoryName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDirectory( 
            /* [out] */ LPWSTR *ppszDirectoryName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBackingFileCount( 
            /* [in] */ DWORD dwMin,
            /* [in] */ DWORD dwMax) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBackingFileCount( 
            /* [out] */ DWORD *pdwMin,
            /* [out] */ DWORD *pdwMax) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBackingFileDuration( 
            /* [in] */ DWORD dwSeconds) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBackingFileDuration( 
            /* [out] */ DWORD *pdwSeconds) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStreamBufferConfigureVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IStreamBufferConfigure * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IStreamBufferConfigure * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IStreamBufferConfigure * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetDirectory )( 
            IStreamBufferConfigure * This,
            /* [in] */ LPCWSTR pszDirectoryName);
        
        HRESULT ( STDMETHODCALLTYPE *GetDirectory )( 
            IStreamBufferConfigure * This,
            /* [out] */ LPWSTR *ppszDirectoryName);
        
        HRESULT ( STDMETHODCALLTYPE *SetBackingFileCount )( 
            IStreamBufferConfigure * This,
            /* [in] */ DWORD dwMin,
            /* [in] */ DWORD dwMax);
        
        HRESULT ( STDMETHODCALLTYPE *GetBackingFileCount )( 
            IStreamBufferConfigure * This,
            /* [out] */ DWORD *pdwMin,
            /* [out] */ DWORD *pdwMax);
        
        HRESULT ( STDMETHODCALLTYPE *SetBackingFileDuration )( 
            IStreamBufferConfigure * This,
            /* [in] */ DWORD dwSeconds);
        
        HRESULT ( STDMETHODCALLTYPE *GetBackingFileDuration )( 
            IStreamBufferConfigure * This,
            /* [out] */ DWORD *pdwSeconds);
        
        END_INTERFACE
    } IStreamBufferConfigureVtbl;

    interface IStreamBufferConfigure
    {
        CONST_VTBL struct IStreamBufferConfigureVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStreamBufferConfigure_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IStreamBufferConfigure_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IStreamBufferConfigure_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IStreamBufferConfigure_SetDirectory(This,pszDirectoryName)	\
    (This)->lpVtbl -> SetDirectory(This,pszDirectoryName)

#define IStreamBufferConfigure_GetDirectory(This,ppszDirectoryName)	\
    (This)->lpVtbl -> GetDirectory(This,ppszDirectoryName)

#define IStreamBufferConfigure_SetBackingFileCount(This,dwMin,dwMax)	\
    (This)->lpVtbl -> SetBackingFileCount(This,dwMin,dwMax)

#define IStreamBufferConfigure_GetBackingFileCount(This,pdwMin,pdwMax)	\
    (This)->lpVtbl -> GetBackingFileCount(This,pdwMin,pdwMax)

#define IStreamBufferConfigure_SetBackingFileDuration(This,dwSeconds)	\
    (This)->lpVtbl -> SetBackingFileDuration(This,dwSeconds)

#define IStreamBufferConfigure_GetBackingFileDuration(This,pdwSeconds)	\
    (This)->lpVtbl -> GetBackingFileDuration(This,pdwSeconds)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IStreamBufferConfigure_SetDirectory_Proxy( 
    IStreamBufferConfigure * This,
    /* [in] */ LPCWSTR pszDirectoryName);


void __RPC_STUB IStreamBufferConfigure_SetDirectory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStreamBufferConfigure_GetDirectory_Proxy( 
    IStreamBufferConfigure * This,
    /* [out] */ LPWSTR *ppszDirectoryName);


void __RPC_STUB IStreamBufferConfigure_GetDirectory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStreamBufferConfigure_SetBackingFileCount_Proxy( 
    IStreamBufferConfigure * This,
    /* [in] */ DWORD dwMin,
    /* [in] */ DWORD dwMax);


void __RPC_STUB IStreamBufferConfigure_SetBackingFileCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStreamBufferConfigure_GetBackingFileCount_Proxy( 
    IStreamBufferConfigure * This,
    /* [out] */ DWORD *pdwMin,
    /* [out] */ DWORD *pdwMax);


void __RPC_STUB IStreamBufferConfigure_GetBackingFileCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStreamBufferConfigure_SetBackingFileDuration_Proxy( 
    IStreamBufferConfigure * This,
    /* [in] */ DWORD dwSeconds);


void __RPC_STUB IStreamBufferConfigure_SetBackingFileDuration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStreamBufferConfigure_GetBackingFileDuration_Proxy( 
    IStreamBufferConfigure * This,
    /* [out] */ DWORD *pdwSeconds);


void __RPC_STUB IStreamBufferConfigure_GetBackingFileDuration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IStreamBufferConfigure_INTERFACE_DEFINED__ */


#ifndef __IStreamBufferMediaSeeking_INTERFACE_DEFINED__
#define __IStreamBufferMediaSeeking_INTERFACE_DEFINED__

/* interface IStreamBufferMediaSeeking */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IStreamBufferMediaSeeking;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f61f5c26-863d-4afa-b0ba-2f81dc978596")
    IStreamBufferMediaSeeking : public IMediaSeeking
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IStreamBufferMediaSeekingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IStreamBufferMediaSeeking * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IStreamBufferMediaSeeking * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IStreamBufferMediaSeeking * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCapabilities )( 
            IStreamBufferMediaSeeking * This,
            /* [out] */ DWORD *pCapabilities);
        
        HRESULT ( STDMETHODCALLTYPE *CheckCapabilities )( 
            IStreamBufferMediaSeeking * This,
            /* [out][in] */ DWORD *pCapabilities);
        
        HRESULT ( STDMETHODCALLTYPE *IsFormatSupported )( 
            IStreamBufferMediaSeeking * This,
            /* [in] */ const GUID *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE *QueryPreferredFormat )( 
            IStreamBufferMediaSeeking * This,
            /* [out] */ GUID *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE *GetTimeFormat )( 
            IStreamBufferMediaSeeking * This,
            /* [out] */ GUID *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE *IsUsingTimeFormat )( 
            IStreamBufferMediaSeeking * This,
            /* [in] */ const GUID *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE *SetTimeFormat )( 
            IStreamBufferMediaSeeking * This,
            /* [in] */ const GUID *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE *GetDuration )( 
            IStreamBufferMediaSeeking * This,
            /* [out] */ LONGLONG *pDuration);
        
        HRESULT ( STDMETHODCALLTYPE *GetStopPosition )( 
            IStreamBufferMediaSeeking * This,
            /* [out] */ LONGLONG *pStop);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentPosition )( 
            IStreamBufferMediaSeeking * This,
            /* [out] */ LONGLONG *pCurrent);
        
        HRESULT ( STDMETHODCALLTYPE *ConvertTimeFormat )( 
            IStreamBufferMediaSeeking * This,
            /* [out] */ LONGLONG *pTarget,
            /* [in] */ const GUID *pTargetFormat,
            /* [in] */ LONGLONG Source,
            /* [in] */ const GUID *pSourceFormat);
        
        HRESULT ( STDMETHODCALLTYPE *SetPositions )( 
            IStreamBufferMediaSeeking * This,
            /* [out][in] */ LONGLONG *pCurrent,
            /* [in] */ DWORD dwCurrentFlags,
            /* [out][in] */ LONGLONG *pStop,
            /* [in] */ DWORD dwStopFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetPositions )( 
            IStreamBufferMediaSeeking * This,
            /* [out] */ LONGLONG *pCurrent,
            /* [out] */ LONGLONG *pStop);
        
        HRESULT ( STDMETHODCALLTYPE *GetAvailable )( 
            IStreamBufferMediaSeeking * This,
            /* [out] */ LONGLONG *pEarliest,
            /* [out] */ LONGLONG *pLatest);
        
        HRESULT ( STDMETHODCALLTYPE *SetRate )( 
            IStreamBufferMediaSeeking * This,
            /* [in] */ double dRate);
        
        HRESULT ( STDMETHODCALLTYPE *GetRate )( 
            IStreamBufferMediaSeeking * This,
            /* [out] */ double *pdRate);
        
        HRESULT ( STDMETHODCALLTYPE *GetPreroll )( 
            IStreamBufferMediaSeeking * This,
            /* [out] */ LONGLONG *pllPreroll);
        
        END_INTERFACE
    } IStreamBufferMediaSeekingVtbl;

    interface IStreamBufferMediaSeeking
    {
        CONST_VTBL struct IStreamBufferMediaSeekingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStreamBufferMediaSeeking_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IStreamBufferMediaSeeking_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IStreamBufferMediaSeeking_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IStreamBufferMediaSeeking_GetCapabilities(This,pCapabilities)	\
    (This)->lpVtbl -> GetCapabilities(This,pCapabilities)

#define IStreamBufferMediaSeeking_CheckCapabilities(This,pCapabilities)	\
    (This)->lpVtbl -> CheckCapabilities(This,pCapabilities)

#define IStreamBufferMediaSeeking_IsFormatSupported(This,pFormat)	\
    (This)->lpVtbl -> IsFormatSupported(This,pFormat)

#define IStreamBufferMediaSeeking_QueryPreferredFormat(This,pFormat)	\
    (This)->lpVtbl -> QueryPreferredFormat(This,pFormat)

#define IStreamBufferMediaSeeking_GetTimeFormat(This,pFormat)	\
    (This)->lpVtbl -> GetTimeFormat(This,pFormat)

#define IStreamBufferMediaSeeking_IsUsingTimeFormat(This,pFormat)	\
    (This)->lpVtbl -> IsUsingTimeFormat(This,pFormat)

#define IStreamBufferMediaSeeking_SetTimeFormat(This,pFormat)	\
    (This)->lpVtbl -> SetTimeFormat(This,pFormat)

#define IStreamBufferMediaSeeking_GetDuration(This,pDuration)	\
    (This)->lpVtbl -> GetDuration(This,pDuration)

#define IStreamBufferMediaSeeking_GetStopPosition(This,pStop)	\
    (This)->lpVtbl -> GetStopPosition(This,pStop)

#define IStreamBufferMediaSeeking_GetCurrentPosition(This,pCurrent)	\
    (This)->lpVtbl -> GetCurrentPosition(This,pCurrent)

#define IStreamBufferMediaSeeking_ConvertTimeFormat(This,pTarget,pTargetFormat,Source,pSourceFormat)	\
    (This)->lpVtbl -> ConvertTimeFormat(This,pTarget,pTargetFormat,Source,pSourceFormat)

#define IStreamBufferMediaSeeking_SetPositions(This,pCurrent,dwCurrentFlags,pStop,dwStopFlags)	\
    (This)->lpVtbl -> SetPositions(This,pCurrent,dwCurrentFlags,pStop,dwStopFlags)

#define IStreamBufferMediaSeeking_GetPositions(This,pCurrent,pStop)	\
    (This)->lpVtbl -> GetPositions(This,pCurrent,pStop)

#define IStreamBufferMediaSeeking_GetAvailable(This,pEarliest,pLatest)	\
    (This)->lpVtbl -> GetAvailable(This,pEarliest,pLatest)

#define IStreamBufferMediaSeeking_SetRate(This,dRate)	\
    (This)->lpVtbl -> SetRate(This,dRate)

#define IStreamBufferMediaSeeking_GetRate(This,pdRate)	\
    (This)->lpVtbl -> GetRate(This,pdRate)

#define IStreamBufferMediaSeeking_GetPreroll(This,pllPreroll)	\
    (This)->lpVtbl -> GetPreroll(This,pllPreroll)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IStreamBufferMediaSeeking_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_sbe_0416 */
/* [local] */ 

#define STREAMBUFFER_EC_BASE                     0x0326
enum {
    //  timehole event
    //      param1 = timehole stream offset ms
    //      param1 = timehole size ms
    STREAMBUFFER_EC_TIMEHOLE = STREAMBUFFER_EC_BASE,
    
    STREAMBUFFER_EC_STALE_DATA_READ,
    
    STREAMBUFFER_EC_STALE_FILE_DELETED,
    STREAMBUFFER_EC_CONTENT_BECOMING_STALE,
    STREAMBUFFER_EC_WRITE_FAILURE,
    //
    //  unexpected read failure
    //      param1 = HRESULT failure
    //      param2 = undefined
    STREAMBUFFER_EC_READ_FAILURE,
    //
    //  playback rate change
    //      param1 = old_playback_rate * 10000 e.g. 2x is 20000
    //      param2 = new_playback_rate * 10000
    STREAMBUFFER_EC_RATE_CHANGED,
} ;


extern RPC_IF_HANDLE __MIDL_itf_sbe_0416_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_sbe_0416_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DirectX\9c\Include\strmif.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0357 */
/* Compiler settings for strmif.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __strmif_h__
#define __strmif_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ICreateDevEnum_FWD_DEFINED__
#define __ICreateDevEnum_FWD_DEFINED__
typedef interface ICreateDevEnum ICreateDevEnum;
#endif 	/* __ICreateDevEnum_FWD_DEFINED__ */


#ifndef __IPin_FWD_DEFINED__
#define __IPin_FWD_DEFINED__
typedef interface IPin IPin;
#endif 	/* __IPin_FWD_DEFINED__ */


#ifndef __IEnumPins_FWD_DEFINED__
#define __IEnumPins_FWD_DEFINED__
typedef interface IEnumPins IEnumPins;
#endif 	/* __IEnumPins_FWD_DEFINED__ */


#ifndef __IEnumMediaTypes_FWD_DEFINED__
#define __IEnumMediaTypes_FWD_DEFINED__
typedef interface IEnumMediaTypes IEnumMediaTypes;
#endif 	/* __IEnumMediaTypes_FWD_DEFINED__ */


#ifndef __IFilterGraph_FWD_DEFINED__
#define __IFilterGraph_FWD_DEFINED__
typedef interface IFilterGraph IFilterGraph;
#endif 	/* __IFilterGraph_FWD_DEFINED__ */


#ifndef __IEnumFilters_FWD_DEFINED__
#define __IEnumFilters_FWD_DEFINED__
typedef interface IEnumFilters IEnumFilters;
#endif 	/* __IEnumFilters_FWD_DEFINED__ */


#ifndef __IMediaFilter_FWD_DEFINED__
#define __IMediaFilter_FWD_DEFINED__
typedef interface IMediaFilter IMediaFilter;
#endif 	/* __IMediaFilter_FWD_DEFINED__ */


#ifndef __IBaseFilter_FWD_DEFINED__
#define __IBaseFilter_FWD_DEFINED__
typedef interface IBaseFilter IBaseFilter;
#endif 	/* __IBaseFilter_FWD_DEFINED__ */


#ifndef __IReferenceClock_FWD_DEFINED__
#define __IReferenceClock_FWD_DEFINED__
typedef interface IReferenceClock IReferenceClock;
#endif 	/* __IReferenceClock_FWD_DEFINED__ */


#ifndef __IReferenceClock2_FWD_DEFINED__
#define __IReferenceClock2_FWD_DEFINED__
typedef interface IReferenceClock2 IReferenceClock2;
#endif 	/* __IReferenceClock2_FWD_DEFINED__ */


#ifndef __IMediaSample_FWD_DEFINED__
#define __IMediaSample_FWD_DEFINED__
typedef interface IMediaSample IMediaSample;
#endif 	/* __IMediaSample_FWD_DEFINED__ */


#ifndef __IMediaSample2_FWD_DEFINED__
#define __IMediaSample2_FWD_DEFINED__
typedef interface IMediaSample2 IMediaSample2;
#endif 	/* __IMediaSample2_FWD_DEFINED__ */


#ifndef __IMemAllocator_FWD_DEFINED__
#define __IMemAllocator_FWD_DEFINED__
typedef interface IMemAllocator IMemAllocator;
#endif 	/* __IMemAllocator_FWD_DEFINED__ */


#ifndef __IMemAllocatorCallbackTemp_FWD_DEFINED__
#define __IMemAllocatorCallbackTemp_FWD_DEFINED__
typedef interface IMemAllocatorCallbackTemp IMemAllocatorCallbackTemp;
#endif 	/* __IMemAllocatorCallbackTemp_FWD_DEFINED__ */


#ifndef __IMemAllocatorNotifyCallbackTemp_FWD_DEFINED__
#define __IMemAllocatorNotifyCallbackTemp_FWD_DEFINED__
typedef interface IMemAllocatorNotifyCallbackTemp IMemAllocatorNotifyCallbackTemp;
#endif 	/* __IMemAllocatorNotifyCallbackTemp_FWD_DEFINED__ */


#ifndef __IMemInputPin_FWD_DEFINED__
#define __IMemInputPin_FWD_DEFINED__
typedef interface IMemInputPin IMemInputPin;
#endif 	/* __IMemInputPin_FWD_DEFINED__ */


#ifndef __IAMovieSetup_FWD_DEFINED__
#define __IAMovieSetup_FWD_DEFINED__
typedef interface IAMovieSetup IAMovieSetup;
#endif 	/* __IAMovieSetup_FWD_DEFINED__ */


#ifndef __IMediaSeeking_FWD_DEFINED__
#define __IMediaSeeking_FWD_DEFINED__
typedef interface IMediaSeeking IMediaSeeking;
#endif 	/* __IMediaSeeking_FWD_DEFINED__ */


#ifndef __IEnumRegFilters_FWD_DEFINED__
#define __IEnumRegFilters_FWD_DEFINED__
typedef interface IEnumRegFilters IEnumRegFilters;
#endif 	/* __IEnumRegFilters_FWD_DEFINED__ */


#ifndef __IFilterMapper_FWD_DEFINED__
#define __IFilterMapper_FWD_DEFINED__
typedef interface IFilterMapper IFilterMapper;
#endif 	/* __IFilterMapper_FWD_DEFINED__ */


#ifndef __IFilterMapper2_FWD_DEFINED__
#define __IFilterMapper2_FWD_DEFINED__
typedef interface IFilterMapper2 IFilterMapper2;
#endif 	/* __IFilterMapper2_FWD_DEFINED__ */


#ifndef __IFilterMapper3_FWD_DEFINED__
#define __IFilterMapper3_FWD_DEFINED__
typedef interface IFilterMapper3 IFilterMapper3;
#endif 	/* __IFilterMapper3_FWD_DEFINED__ */


#ifndef __IQualityControl_FWD_DEFINED__
#define __IQualityControl_FWD_DEFINED__
typedef interface IQualityControl IQualityControl;
#endif 	/* __IQualityControl_FWD_DEFINED__ */


#ifndef __IOverlayNotify_FWD_DEFINED__
#define __IOverlayNotify_FWD_DEFINED__
typedef interface IOverlayNotify IOverlayNotify;
#endif 	/* __IOverlayNotify_FWD_DEFINED__ */


#ifndef __IOverlayNotify2_FWD_DEFINED__
#define __IOverlayNotify2_FWD_DEFINED__
typedef interface IOverlayNotify2 IOverlayNotify2;
#endif 	/* __IOverlayNotify2_FWD_DEFINED__ */


#ifndef __IOverlay_FWD_DEFINED__
#define __IOverlay_FWD_DEFINED__
typedef interface IOverlay IOverlay;
#endif 	/* __IOverlay_FWD_DEFINED__ */


#ifndef __IMediaEventSink_FWD_DEFINED__
#define __IMediaEventSink_FWD_DEFINED__
typedef interface IMediaEventSink IMediaEventSink;
#endif 	/* __IMediaEventSink_FWD_DEFINED__ */


#ifndef __IFileSourceFilter_FWD_DEFINED__
#define __IFileSourceFilter_FWD_DEFINED__
typedef interface IFileSourceFilter IFileSourceFilter;
#endif 	/* __IFileSourceFilter_FWD_DEFINED__ */


#ifndef __IFileSinkFilter_FWD_DEFINED__
#define __IFileSinkFilter_FWD_DEFINED__
typedef interface IFileSinkFilter IFileSinkFilter;
#endif 	/* __IFileSinkFilter_FWD_DEFINED__ */


#ifndef __IFileSinkFilter2_FWD_DEFINED__
#define __IFileSinkFilter2_FWD_DEFINED__
typedef interface IFileSinkFilter2 IFileSinkFilter2;
#endif 	/* __IFileSinkFilter2_FWD_DEFINED__ */


#ifndef __IGraphBuilder_FWD_DEFINED__
#define __IGraphBuilder_FWD_DEFINED__
typedef interface IGraphBuilder IGraphBuilder;
#endif 	/* __IGraphBuilder_FWD_DEFINED__ */


#ifndef __ICaptureGraphBuilder_FWD_DEFINED__
#define __ICaptureGraphBuilder_FWD_DEFINED__
typedef interface ICaptureGraphBuilder ICaptureGraphBuilder;
#endif 	/* __ICaptureGraphBuilder_FWD_DEFINED__ */


#ifndef __IAMCopyCaptureFileProgress_FWD_DEFINED__
#define __IAMCopyCaptureFileProgress_FWD_DEFINED__
typedef interface IAMCopyCaptureFileProgress IAMCopyCaptureFileProgress;
#endif 	/* __IAMCopyCaptureFileProgress_FWD_DEFINED__ */


#ifndef __ICaptureGraphBuilder2_FWD_DEFINED__
#define __ICaptureGraphBuilder2_FWD_DEFINED__
typedef interface ICaptureGraphBuilder2 ICaptureGraphBuilder2;
#endif 	/* __ICaptureGraphBuilder2_FWD_DEFINED__ */


#ifndef __IFilterGraph2_FWD_DEFINED__
#define __IFilterGraph2_FWD_DEFINED__
typedef interface IFilterGraph2 IFilterGraph2;
#endif 	/* __IFilterGraph2_FWD_DEFINED__ */


#ifndef __IStreamBuilder_FWD_DEFINED__
#define __IStreamBuilder_FWD_DEFINED__
typedef interface IStreamBuilder IStreamBuilder;
#endif 	/* __IStreamBuilder_FWD_DEFINED__ */


#ifndef __IAsyncReader_FWD_DEFINED__
#define __IAsyncReader_FWD_DEFINED__
typedef interface IAsyncReader IAsyncReader;
#endif 	/* __IAsyncReader_FWD_DEFINED__ */


#ifndef __IGraphVersion_FWD_DEFINED__
#define __IGraphVersion_FWD_DEFINED__
typedef interface IGraphVersion IGraphVersion;
#endif 	/* __IGraphVersion_FWD_DEFINED__ */


#ifndef __IResourceConsumer_FWD_DEFINED__
#define __IResourceConsumer_FWD_DEFINED__
typedef interface IResourceConsumer IResourceConsumer;
#endif 	/* __IResourceConsumer_FWD_DEFINED__ */


#ifndef __IResourceManager_FWD_DEFINED__
#define __IResourceManager_FWD_DEFINED__
typedef interface IResourceManager IResourceManager;
#endif 	/* __IResourceManager_FWD_DEFINED__ */


#ifndef __IDistributorNotify_FWD_DEFINED__
#define __IDistributorNotify_FWD_DEFINED__
typedef interface IDistributorNotify IDistributorNotify;
#endif 	/* __IDistributorNotify_FWD_DEFINED__ */


#ifndef __IAMStreamControl_FWD_DEFINED__
#define __IAMStreamControl_FWD_DEFINED__
typedef interface IAMStreamControl IAMStreamControl;
#endif 	/* __IAMStreamControl_FWD_DEFINED__ */


#ifndef __ISeekingPassThru_FWD_DEFINED__
#define __ISeekingPassThru_FWD_DEFINED__
typedef interface ISeekingPassThru ISeekingPassThru;
#endif 	/* __ISeekingPassThru_FWD_DEFINED__ */


#ifndef __IAMStreamConfig_FWD_DEFINED__
#define __IAMStreamConfig_FWD_DEFINED__
typedef interface IAMStreamConfig IAMStreamConfig;
#endif 	/* __IAMStreamConfig_FWD_DEFINED__ */


#ifndef __IConfigInterleaving_FWD_DEFINED__
#define __IConfigInterleaving_FWD_DEFINED__
typedef interface IConfigInterleaving IConfigInterleaving;
#endif 	/* __IConfigInterleaving_FWD_DEFINED__ */


#ifndef __IConfigAviMux_FWD_DEFINED__
#define __IConfigAviMux_FWD_DEFINED__
typedef interface IConfigAviMux IConfigAviMux;
#endif 	/* __IConfigAviMux_FWD_DEFINED__ */


#ifndef __IAMVideoCompression_FWD_DEFINED__
#define __IAMVideoCompression_FWD_DEFINED__
typedef interface IAMVideoCompression IAMVideoCompression;
#endif 	/* __IAMVideoCompression_FWD_DEFINED__ */


#ifndef __IAMVfwCaptureDialogs_FWD_DEFINED__
#define __IAMVfwCaptureDialogs_FWD_DEFINED__
typedef interface IAMVfwCaptureDialogs IAMVfwCaptureDialogs;
#endif 	/* __IAMVfwCaptureDialogs_FWD_DEFINED__ */


#ifndef __IAMVfwCompressDialogs_FWD_DEFINED__
#define __IAMVfwCompressDialogs_FWD_DEFINED__
typedef interface IAMVfwCompressDialogs IAMVfwCompressDialogs;
#endif 	/* __IAMVfwCompressDialogs_FWD_DEFINED__ */


#ifndef __IAMDroppedFrames_FWD_DEFINED__
#define __IAMDroppedFrames_FWD_DEFINED__
typedef interface IAMDroppedFrames IAMDroppedFrames;
#endif 	/* __IAMDroppedFrames_FWD_DEFINED__ */


#ifndef __IAMAudioInputMixer_FWD_DEFINED__
#define __IAMAudioInputMixer_FWD_DEFINED__
typedef interface IAMAudioInputMixer IAMAudioInputMixer;
#endif 	/* __IAMAudioInputMixer_FWD_DEFINED__ */


#ifndef __IAMBufferNegotiation_FWD_DEFINED__
#define __IAMBufferNegotiation_FWD_DEFINED__
typedef interface IAMBufferNegotiation IAMBufferNegotiation;
#endif 	/* __IAMBufferNegotiation_FWD_DEFINED__ */


#ifndef __IAMAnalogVideoDecoder_FWD_DEFINED__
#define __IAMAnalogVideoDecoder_FWD_DEFINED__
typedef interface IAMAnalogVideoDecoder IAMAnalogVideoDecoder;
#endif 	/* __IAMAnalogVideoDecoder_FWD_DEFINED__ */


#ifndef __IAMVideoProcAmp_FWD_DEFINED__
#define __IAMVideoProcAmp_FWD_DEFINED__
typedef interface IAMVideoProcAmp IAMVideoProcAmp;
#endif 	/* __IAMVideoProcAmp_FWD_DEFINED__ */


#ifndef __IAMCameraControl_FWD_DEFINED__
#define __IAMCameraControl_FWD_DEFINED__
typedef interface IAMCameraControl IAMCameraControl;
#endif 	/* __IAMCameraControl_FWD_DEFINED__ */


#ifndef __IAMVideoControl_FWD_DEFINED__
#define __IAMVideoControl_FWD_DEFINED__
typedef interface IAMVideoControl IAMVideoControl;
#endif 	/* __IAMVideoControl_FWD_DEFINED__ */


#ifndef __IAMCrossbar_FWD_DEFINED__
#define __IAMCrossbar_FWD_DEFINED__
typedef interface IAMCrossbar IAMCrossbar;
#endif 	/* __IAMCrossbar_FWD_DEFINED__ */


#ifndef __IAMTuner_FWD_DEFINED__
#define __IAMTuner_FWD_DEFINED__
typedef interface IAMTuner IAMTuner;
#endif 	/* __IAMTuner_FWD_DEFINED__ */


#ifndef __IAMTunerNotification_FWD_DEFINED__
#define __IAMTunerNotification_FWD_DEFINED__
typedef interface IAMTunerNotification IAMTunerNotification;
#endif 	/* __IAMTunerNotification_FWD_DEFINED__ */


#ifndef __IAMTVTuner_FWD_DEFINED__
#define __IAMTVTuner_FWD_DEFINED__
typedef interface IAMTVTuner IAMTVTuner;
#endif 	/* __IAMTVTuner_FWD_DEFINED__ */


#ifndef __IBPCSatelliteTuner_FWD_DEFINED__
#define __IBPCSatelliteTuner_FWD_DEFINED__
typedef interface IBPCSatelliteTuner IBPCSatelliteTuner;
#endif 	/* __IBPCSatelliteTuner_FWD_DEFINED__ */


#ifndef __IAMTVAudio_FWD_DEFINED__
#define __IAMTVAudio_FWD_DEFINED__
typedef interface IAMTVAudio IAMTVAudio;
#endif 	/* __IAMTVAudio_FWD_DEFINED__ */


#ifndef __IAMTVAudioNotification_FWD_DEFINED__
#define __IAMTVAudioNotification_FWD_DEFINED__
typedef interface IAMTVAudioNotification IAMTVAudioNotification;
#endif 	/* __IAMTVAudioNotification_FWD_DEFINED__ */


#ifndef __IAMAnalogVideoEncoder_FWD_DEFINED__
#define __IAMAnalogVideoEncoder_FWD_DEFINED__
typedef interface IAMAnalogVideoEncoder IAMAnalogVideoEncoder;
#endif 	/* __IAMAnalogVideoEncoder_FWD_DEFINED__ */


#ifndef __IKsPropertySet_FWD_DEFINED__
#define __IKsPropertySet_FWD_DEFINED__
typedef interface IKsPropertySet IKsPropertySet;
#endif 	/* __IKsPropertySet_FWD_DEFINED__ */


#ifndef __IMediaPropertyBag_FWD_DEFINED__
#define __IMediaPropertyBag_FWD_DEFINED__
typedef interface IMediaPropertyBag IMediaPropertyBag;
#endif 	/* __IMediaPropertyBag_FWD_DEFINED__ */


#ifndef __IPersistMediaPropertyBag_FWD_DEFINED__
#define __IPersistMediaPropertyBag_FWD_DEFINED__
typedef interface IPersistMediaPropertyBag IPersistMediaPropertyBag;
#endif 	/* __IPersistMediaPropertyBag_FWD_DEFINED__ */


#ifndef __IAMPhysicalPinInfo_FWD_DEFINED__
#define __IAMPhysicalPinInfo_FWD_DEFINED__
typedef interface IAMPhysicalPinInfo IAMPhysicalPinInfo;
#endif 	/* __IAMPhysicalPinInfo_FWD_DEFINED__ */


#ifndef __IAMExtDevice_FWD_DEFINED__
#define __IAMExtDevice_FWD_DEFINED__
typedef interface IAMExtDevice IAMExtDevice;
#endif 	/* __IAMExtDevice_FWD_DEFINED__ */


#ifndef __IAMExtTransport_FWD_DEFINED__
#define __IAMExtTransport_FWD_DEFINED__
typedef interface IAMExtTransport IAMExtTransport;
#endif 	/* __IAMExtTransport_FWD_DEFINED__ */


#ifndef __IAMTimecodeReader_FWD_DEFINED__
#define __IAMTimecodeReader_FWD_DEFINED__
typedef interface IAMTimecodeReader IAMTimecodeReader;
#endif 	/* __IAMTimecodeReader_FWD_DEFINED__ */


#ifndef __IAMTimecodeGenerator_FWD_DEFINED__
#define __IAMTimecodeGenerator_FWD_DEFINED__
typedef interface IAMTimecodeGenerator IAMTimecodeGenerator;
#endif 	/* __IAMTimecodeGenerator_FWD_DEFINED__ */


#ifndef __IAMTimecodeDisplay_FWD_DEFINED__
#define __IAMTimecodeDisplay_FWD_DEFINED__
typedef interface IAMTimecodeDisplay IAMTimecodeDisplay;
#endif 	/* __IAMTimecodeDisplay_FWD_DEFINED__ */


#ifndef __IAMDevMemoryAllocator_FWD_DEFINED__
#define __IAMDevMemoryAllocator_FWD_DEFINED__
typedef interface IAMDevMemoryAllocator IAMDevMemoryAllocator;
#endif 	/* __IAMDevMemoryAllocator_FWD_DEFINED__ */


#ifndef __IAMDevMemoryControl_FWD_DEFINED__
#define __IAMDevMemoryControl_FWD_DEFINED__
typedef interface IAMDevMemoryControl IAMDevMemoryControl;
#endif 	/* __IAMDevMemoryControl_FWD_DEFINED__ */


#ifndef __IAMStreamSelect_FWD_DEFINED__
#define __IAMStreamSelect_FWD_DEFINED__
typedef interface IAMStreamSelect IAMStreamSelect;
#endif 	/* __IAMStreamSelect_FWD_DEFINED__ */


#ifndef __IAMResourceControl_FWD_DEFINED__
#define __IAMResourceControl_FWD_DEFINED__
typedef interface IAMResourceControl IAMResourceControl;
#endif 	/* __IAMResourceControl_FWD_DEFINED__ */


#ifndef __IAMClockAdjust_FWD_DEFINED__
#define __IAMClockAdjust_FWD_DEFINED__
typedef interface IAMClockAdjust IAMClockAdjust;
#endif 	/* __IAMClockAdjust_FWD_DEFINED__ */


#ifndef __IAMFilterMiscFlags_FWD_DEFINED__
#define __IAMFilterMiscFlags_FWD_DEFINED__
typedef interface IAMFilterMiscFlags IAMFilterMiscFlags;
#endif 	/* __IAMFilterMiscFlags_FWD_DEFINED__ */


#ifndef __IDrawVideoImage_FWD_DEFINED__
#define __IDrawVideoImage_FWD_DEFINED__
typedef interface IDrawVideoImage IDrawVideoImage;
#endif 	/* __IDrawVideoImage_FWD_DEFINED__ */


#ifndef __IDecimateVideoImage_FWD_DEFINED__
#define __IDecimateVideoImage_FWD_DEFINED__
typedef interface IDecimateVideoImage IDecimateVideoImage;
#endif 	/* __IDecimateVideoImage_FWD_DEFINED__ */


#ifndef __IAMVideoDecimationProperties_FWD_DEFINED__
#define __IAMVideoDecimationProperties_FWD_DEFINED__
typedef interface IAMVideoDecimationProperties IAMVideoDecimationProperties;
#endif 	/* __IAMVideoDecimationProperties_FWD_DEFINED__ */


#ifndef __IVideoFrameStep_FWD_DEFINED__
#define __IVideoFrameStep_FWD_DEFINED__
typedef interface IVideoFrameStep IVideoFrameStep;
#endif 	/* __IVideoFrameStep_FWD_DEFINED__ */


#ifndef __IAMLatency_FWD_DEFINED__
#define __IAMLatency_FWD_DEFINED__
typedef interface IAMLatency IAMLatency;
#endif 	/* __IAMLatency_FWD_DEFINED__ */


#ifndef __IAMPushSource_FWD_DEFINED__
#define __IAMPushSource_FWD_DEFINED__
typedef interface IAMPushSource IAMPushSource;
#endif 	/* __IAMPushSource_FWD_DEFINED__ */


#ifndef __IAMDeviceRemoval_FWD_DEFINED__
#define __IAMDeviceRemoval_FWD_DEFINED__
typedef interface IAMDeviceRemoval IAMDeviceRemoval;
#endif 	/* __IAMDeviceRemoval_FWD_DEFINED__ */


#ifndef __IDVEnc_FWD_DEFINED__
#define __IDVEnc_FWD_DEFINED__
typedef interface IDVEnc IDVEnc;
#endif 	/* __IDVEnc_FWD_DEFINED__ */


#ifndef __IIPDVDec_FWD_DEFINED__
#define __IIPDVDec_FWD_DEFINED__
typedef interface IIPDVDec IIPDVDec;
#endif 	/* __IIPDVDec_FWD_DEFINED__ */


#ifndef __IDVRGB219_FWD_DEFINED__
#define __IDVRGB219_FWD_DEFINED__
typedef interface IDVRGB219 IDVRGB219;
#endif 	/* __IDVRGB219_FWD_DEFINED__ */


#ifndef __IDVSplitter_FWD_DEFINED__
#define __IDVSplitter_FWD_DEFINED__
typedef interface IDVSplitter IDVSplitter;
#endif 	/* __IDVSplitter_FWD_DEFINED__ */


#ifndef __IAMAudioRendererStats_FWD_DEFINED__
#define __IAMAudioRendererStats_FWD_DEFINED__
typedef interface IAMAudioRendererStats IAMAudioRendererStats;
#endif 	/* __IAMAudioRendererStats_FWD_DEFINED__ */


#ifndef __IAMGraphStreams_FWD_DEFINED__
#define __IAMGraphStreams_FWD_DEFINED__
typedef interface IAMGraphStreams IAMGraphStreams;
#endif 	/* __IAMGraphStreams_FWD_DEFINED__ */


#ifndef __IAMOverlayFX_FWD_DEFINED__
#define __IAMOverlayFX_FWD_DEFINED__
typedef interface IAMOverlayFX IAMOverlayFX;
#endif 	/* __IAMOverlayFX_FWD_DEFINED__ */


#ifndef __IAMOpenProgress_FWD_DEFINED__
#define __IAMOpenProgress_FWD_DEFINED__
typedef interface IAMOpenProgress IAMOpenProgress;
#endif 	/* __IAMOpenProgress_FWD_DEFINED__ */


#ifndef __IMpeg2Demultiplexer_FWD_DEFINED__
#define __IMpeg2Demultiplexer_FWD_DEFINED__
typedef interface IMpeg2Demultiplexer IMpeg2Demultiplexer;
#endif 	/* __IMpeg2Demultiplexer_FWD_DEFINED__ */


#ifndef __IEnumStreamIdMap_FWD_DEFINED__
#define __IEnumStreamIdMap_FWD_DEFINED__
typedef interface IEnumStreamIdMap IEnumStreamIdMap;
#endif 	/* __IEnumStreamIdMap_FWD_DEFINED__ */


#ifndef __IMPEG2StreamIdMap_FWD_DEFINED__
#define __IMPEG2StreamIdMap_FWD_DEFINED__
typedef interface IMPEG2StreamIdMap IMPEG2StreamIdMap;
#endif 	/* __IMPEG2StreamIdMap_FWD_DEFINED__ */


#ifndef __IRegisterServiceProvider_FWD_DEFINED__
#define __IRegisterServiceProvider_FWD_DEFINED__
typedef interface IRegisterServiceProvider IRegisterServiceProvider;
#endif 	/* __IRegisterServiceProvider_FWD_DEFINED__ */


#ifndef __IAMClockSlave_FWD_DEFINED__
#define __IAMClockSlave_FWD_DEFINED__
typedef interface IAMClockSlave IAMClockSlave;
#endif 	/* __IAMClockSlave_FWD_DEFINED__ */


#ifndef __IAMGraphBuilderCallback_FWD_DEFINED__
#define __IAMGraphBuilderCallback_FWD_DEFINED__
typedef interface IAMGraphBuilderCallback IAMGraphBuilderCallback;
#endif 	/* __IAMGraphBuilderCallback_FWD_DEFINED__ */


#ifndef __ICodecAPI_FWD_DEFINED__
#define __ICodecAPI_FWD_DEFINED__
typedef interface ICodecAPI ICodecAPI;
#endif 	/* __ICodecAPI_FWD_DEFINED__ */


#ifndef __IGetCapabilitiesKey_FWD_DEFINED__
#define __IGetCapabilitiesKey_FWD_DEFINED__
typedef interface IGetCapabilitiesKey IGetCapabilitiesKey;
#endif 	/* __IGetCapabilitiesKey_FWD_DEFINED__ */


#ifndef __IEncoderAPI_FWD_DEFINED__
#define __IEncoderAPI_FWD_DEFINED__
typedef interface IEncoderAPI IEncoderAPI;
#endif 	/* __IEncoderAPI_FWD_DEFINED__ */


#ifndef __IVideoEncoder_FWD_DEFINED__
#define __IVideoEncoder_FWD_DEFINED__
typedef interface IVideoEncoder IVideoEncoder;
#endif 	/* __IVideoEncoder_FWD_DEFINED__ */


#ifndef __IAMDecoderCaps_FWD_DEFINED__
#define __IAMDecoderCaps_FWD_DEFINED__
typedef interface IAMDecoderCaps IAMDecoderCaps;
#endif 	/* __IAMDecoderCaps_FWD_DEFINED__ */


#ifndef __IDvdControl_FWD_DEFINED__
#define __IDvdControl_FWD_DEFINED__
typedef interface IDvdControl IDvdControl;
#endif 	/* __IDvdControl_FWD_DEFINED__ */


#ifndef __IDvdInfo_FWD_DEFINED__
#define __IDvdInfo_FWD_DEFINED__
typedef interface IDvdInfo IDvdInfo;
#endif 	/* __IDvdInfo_FWD_DEFINED__ */


#ifndef __IDvdCmd_FWD_DEFINED__
#define __IDvdCmd_FWD_DEFINED__
typedef interface IDvdCmd IDvdCmd;
#endif 	/* __IDvdCmd_FWD_DEFINED__ */


#ifndef __IDvdState_FWD_DEFINED__
#define __IDvdState_FWD_DEFINED__
typedef interface IDvdState IDvdState;
#endif 	/* __IDvdState_FWD_DEFINED__ */


#ifndef __IDvdControl2_FWD_DEFINED__
#define __IDvdControl2_FWD_DEFINED__
typedef interface IDvdControl2 IDvdControl2;
#endif 	/* __IDvdControl2_FWD_DEFINED__ */


#ifndef __IDvdInfo2_FWD_DEFINED__
#define __IDvdInfo2_FWD_DEFINED__
typedef interface IDvdInfo2 IDvdInfo2;
#endif 	/* __IDvdInfo2_FWD_DEFINED__ */


#ifndef __IDvdGraphBuilder_FWD_DEFINED__
#define __IDvdGraphBuilder_FWD_DEFINED__
typedef interface IDvdGraphBuilder IDvdGraphBuilder;
#endif 	/* __IDvdGraphBuilder_FWD_DEFINED__ */


#ifndef __IDDrawExclModeVideo_FWD_DEFINED__
#define __IDDrawExclModeVideo_FWD_DEFINED__
typedef interface IDDrawExclModeVideo IDDrawExclModeVideo;
#endif 	/* __IDDrawExclModeVideo_FWD_DEFINED__ */


#ifndef __IDDrawExclModeVideoCallback_FWD_DEFINED__
#define __IDDrawExclModeVideoCallback_FWD_DEFINED__
typedef interface IDDrawExclModeVideoCallback IDDrawExclModeVideoCallback;
#endif 	/* __IDDrawExclModeVideoCallback_FWD_DEFINED__ */


#ifndef __IPinConnection_FWD_DEFINED__
#define __IPinConnection_FWD_DEFINED__
typedef interface IPinConnection IPinConnection;
#endif 	/* __IPinConnection_FWD_DEFINED__ */


#ifndef __IPinFlowControl_FWD_DEFINED__
#define __IPinFlowControl_FWD_DEFINED__
typedef interface IPinFlowControl IPinFlowControl;
#endif 	/* __IPinFlowControl_FWD_DEFINED__ */


#ifndef __IGraphConfig_FWD_DEFINED__
#define __IGraphConfig_FWD_DEFINED__
typedef interface IGraphConfig IGraphConfig;
#endif 	/* __IGraphConfig_FWD_DEFINED__ */


#ifndef __IGraphConfigCallback_FWD_DEFINED__
#define __IGraphConfigCallback_FWD_DEFINED__
typedef interface IGraphConfigCallback IGraphConfigCallback;
#endif 	/* __IGraphConfigCallback_FWD_DEFINED__ */


#ifndef __IFilterChain_FWD_DEFINED__
#define __IFilterChain_FWD_DEFINED__
typedef interface IFilterChain IFilterChain;
#endif 	/* __IFilterChain_FWD_DEFINED__ */


#ifndef __IVMRImagePresenter_FWD_DEFINED__
#define __IVMRImagePresenter_FWD_DEFINED__
typedef interface IVMRImagePresenter IVMRImagePresenter;
#endif 	/* __IVMRImagePresenter_FWD_DEFINED__ */


#ifndef __IVMRSurfaceAllocator_FWD_DEFINED__
#define __IVMRSurfaceAllocator_FWD_DEFINED__
typedef interface IVMRSurfaceAllocator IVMRSurfaceAllocator;
#endif 	/* __IVMRSurfaceAllocator_FWD_DEFINED__ */


#ifndef __IVMRSurfaceAllocatorNotify_FWD_DEFINED__
#define __IVMRSurfaceAllocatorNotify_FWD_DEFINED__
typedef interface IVMRSurfaceAllocatorNotify IVMRSurfaceAllocatorNotify;
#endif 	/* __IVMRSurfaceAllocatorNotify_FWD_DEFINED__ */


#ifndef __IVMRWindowlessControl_FWD_DEFINED__
#define __IVMRWindowlessControl_FWD_DEFINED__
typedef interface IVMRWindowlessControl IVMRWindowlessControl;
#endif 	/* __IVMRWindowlessControl_FWD_DEFINED__ */


#ifndef __IVMRMixerControl_FWD_DEFINED__
#define __IVMRMixerControl_FWD_DEFINED__
typedef interface IVMRMixerControl IVMRMixerControl;
#endif 	/* __IVMRMixerControl_FWD_DEFINED__ */


#ifndef __IVMRMonitorConfig_FWD_DEFINED__
#define __IVMRMonitorConfig_FWD_DEFINED__
typedef interface IVMRMonitorConfig IVMRMonitorConfig;
#endif 	/* __IVMRMonitorConfig_FWD_DEFINED__ */


#ifndef __IVMRFilterConfig_FWD_DEFINED__
#define __IVMRFilterConfig_FWD_DEFINED__
typedef interface IVMRFilterConfig IVMRFilterConfig;
#endif 	/* __IVMRFilterConfig_FWD_DEFINED__ */


#ifndef __IVMRAspectRatioControl_FWD_DEFINED__
#define __IVMRAspectRatioControl_FWD_DEFINED__
typedef interface IVMRAspectRatioControl IVMRAspectRatioControl;
#endif 	/* __IVMRAspectRatioControl_FWD_DEFINED__ */


#ifndef __IVMRDeinterlaceControl_FWD_DEFINED__
#define __IVMRDeinterlaceControl_FWD_DEFINED__
typedef interface IVMRDeinterlaceControl IVMRDeinterlaceControl;
#endif 	/* __IVMRDeinterlaceControl_FWD_DEFINED__ */


#ifndef __IVMRMixerBitmap_FWD_DEFINED__
#define __IVMRMixerBitmap_FWD_DEFINED__
typedef interface IVMRMixerBitmap IVMRMixerBitmap;
#endif 	/* __IVMRMixerBitmap_FWD_DEFINED__ */


#ifndef __IVMRImageCompositor_FWD_DEFINED__
#define __IVMRImageCompositor_FWD_DEFINED__
typedef interface IVMRImageCompositor IVMRImageCompositor;
#endif 	/* __IVMRImageCompositor_FWD_DEFINED__ */


#ifndef __IVMRVideoStreamControl_FWD_DEFINED__
#define __IVMRVideoStreamControl_FWD_DEFINED__
typedef interface IVMRVideoStreamControl IVMRVideoStreamControl;
#endif 	/* __IVMRVideoStreamControl_FWD_DEFINED__ */


#ifndef __IVMRSurface_FWD_DEFINED__
#define __IVMRSurface_FWD_DEFINED__
typedef interface IVMRSurface IVMRSurface;
#endif 	/* __IVMRSurface_FWD_DEFINED__ */


#ifndef __IVMRImagePresenterConfig_FWD_DEFINED__
#define __IVMRImagePresenterConfig_FWD_DEFINED__
typedef interface IVMRImagePresenterConfig IVMRImagePresenterConfig;
#endif 	/* __IVMRImagePresenterConfig_FWD_DEFINED__ */


#ifndef __IVMRImagePresenterExclModeConfig_FWD_DEFINED__
#define __IVMRImagePresenterExclModeConfig_FWD_DEFINED__
typedef interface IVMRImagePresenterExclModeConfig IVMRImagePresenterExclModeConfig;
#endif 	/* __IVMRImagePresenterExclModeConfig_FWD_DEFINED__ */


#ifndef __IVPManager_FWD_DEFINED__
#define __IVPManager_FWD_DEFINED__
typedef interface IVPManager IVPManager;
#endif 	/* __IVPManager_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "objidl.h"
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_strmif_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1999-2002.
//
//--------------------------------------------------------------------------
// Disable /W4 compiler warning C4201: nameless struct/union
#pragma warning(push)
#pragma warning(disable:4201)  // Disable C4201: nameless struct/union
  
#define CDEF_CLASS_DEFAULT      0x0001
#define CDEF_BYPASS_CLASS_MANAGER   0x0002
#define CDEF_MERIT_ABOVE_DO_NOT_USE  0x0008
#define CDEF_DEVMON_CMGR_DEVICE  0x0010
#define CDEF_DEVMON_DMO  0x0020
#define CDEF_DEVMON_PNP_DEVICE  0x0040
#define CDEF_DEVMON_FILTER  0x0080
#define CDEF_DEVMON_SELECTIVE_MASK  0x00f0


extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_v0_0_s_ifspec;

#ifndef __ICreateDevEnum_INTERFACE_DEFINED__
#define __ICreateDevEnum_INTERFACE_DEFINED__

/* interface ICreateDevEnum */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICreateDevEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("29840822-5B84-11D0-BD3B-00A0C911CE86")
    ICreateDevEnum : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateClassEnumerator( 
            /* [in] */ REFCLSID clsidDeviceClass,
            /* [out] */ IEnumMoniker **ppEnumMoniker,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICreateDevEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICreateDevEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICreateDevEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICreateDevEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateClassEnumerator )( 
            ICreateDevEnum * This,
            /* [in] */ REFCLSID clsidDeviceClass,
            /* [out] */ IEnumMoniker **ppEnumMoniker,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } ICreateDevEnumVtbl;

    interface ICreateDevEnum
    {
        CONST_VTBL struct ICreateDevEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICreateDevEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICreateDevEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICreateDevEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICreateDevEnum_CreateClassEnumerator(This,clsidDeviceClass,ppEnumMoniker,dwFlags)	\
    (This)->lpVtbl -> CreateClassEnumerator(This,clsidDeviceClass,ppEnumMoniker,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICreateDevEnum_CreateClassEnumerator_Proxy( 
    ICreateDevEnum * This,
    /* [in] */ REFCLSID clsidDeviceClass,
    /* [out] */ IEnumMoniker **ppEnumMoniker,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB ICreateDevEnum_CreateClassEnumerator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICreateDevEnum_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0113 */
/* [local] */ 

#define CHARS_IN_GUID     39
typedef struct _AMMediaType
    {
    GUID majortype;
    GUID subtype;
    BOOL bFixedSizeSamples;
    BOOL bTemporalCompression;
    ULONG lSampleSize;
    GUID formattype;
    IUnknown *pUnk;
    ULONG cbFormat;
    /* [size_is] */ BYTE *pbFormat;
    } 	AM_MEDIA_TYPE;

typedef 
enum _PinDirection
    {	PINDIR_INPUT	= 0,
	PINDIR_OUTPUT	= PINDIR_INPUT + 1
    } 	PIN_DIRECTION;

#define MAX_PIN_NAME     128
#define MAX_FILTER_NAME  128
typedef LONGLONG REFERENCE_TIME;

typedef double REFTIME;

typedef DWORD_PTR HSEMAPHORE;

typedef DWORD_PTR HEVENT;

typedef struct _AllocatorProperties
    {
    long cBuffers;
    long cbBuffer;
    long cbAlign;
    long cbPrefix;
    } 	ALLOCATOR_PROPERTIES;

















extern RPC_IF_HANDLE __MIDL_itf_strmif_0113_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0113_v0_0_s_ifspec;

#ifndef __IPin_INTERFACE_DEFINED__
#define __IPin_INTERFACE_DEFINED__

/* interface IPin */
/* [unique][uuid][object] */ 

typedef struct _PinInfo
    {
    IBaseFilter *pFilter;
    PIN_DIRECTION dir;
    WCHAR achName[ 128 ];
    } 	PIN_INFO;


EXTERN_C const IID IID_IPin;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a86891-0ad4-11ce-b03a-0020af0ba770")
    IPin : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Connect( 
            /* [in] */ IPin *pReceivePin,
            /* [in] */ const AM_MEDIA_TYPE *pmt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReceiveConnection( 
            /* [in] */ IPin *pConnector,
            /* [in] */ const AM_MEDIA_TYPE *pmt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Disconnect( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConnectedTo( 
            /* [out] */ IPin **pPin) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConnectionMediaType( 
            /* [out] */ AM_MEDIA_TYPE *pmt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryPinInfo( 
            /* [out] */ PIN_INFO *pInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryDirection( 
            /* [out] */ PIN_DIRECTION *pPinDir) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryId( 
            /* [out] */ LPWSTR *Id) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryAccept( 
            /* [in] */ const AM_MEDIA_TYPE *pmt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumMediaTypes( 
            /* [out] */ IEnumMediaTypes **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryInternalConnections( 
            /* [out] */ IPin **apPin,
            /* [out][in] */ ULONG *nPin) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndOfStream( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginFlush( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndFlush( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NewSegment( 
            /* [in] */ REFERENCE_TIME tStart,
            /* [in] */ REFERENCE_TIME tStop,
            /* [in] */ double dRate) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPinVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPin * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPin * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPin * This);
        
        HRESULT ( STDMETHODCALLTYPE *Connect )( 
            IPin * This,
            /* [in] */ IPin *pReceivePin,
            /* [in] */ const AM_MEDIA_TYPE *pmt);
        
        HRESULT ( STDMETHODCALLTYPE *ReceiveConnection )( 
            IPin * This,
            /* [in] */ IPin *pConnector,
            /* [in] */ const AM_MEDIA_TYPE *pmt);
        
        HRESULT ( STDMETHODCALLTYPE *Disconnect )( 
            IPin * This);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectedTo )( 
            IPin * This,
            /* [out] */ IPin **pPin);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectionMediaType )( 
            IPin * This,
            /* [out] */ AM_MEDIA_TYPE *pmt);
        
        HRESULT ( STDMETHODCALLTYPE *QueryPinInfo )( 
            IPin * This,
            /* [out] */ PIN_INFO *pInfo);
        
        HRESULT ( STDMETHODCALLTYPE *QueryDirection )( 
            IPin * This,
            /* [out] */ PIN_DIRECTION *pPinDir);
        
        HRESULT ( STDMETHODCALLTYPE *QueryId )( 
            IPin * This,
            /* [out] */ LPWSTR *Id);
        
        HRESULT ( STDMETHODCALLTYPE *QueryAccept )( 
            IPin * This,
            /* [in] */ const AM_MEDIA_TYPE *pmt);
        
        HRESULT ( STDMETHODCALLTYPE *EnumMediaTypes )( 
            IPin * This,
            /* [out] */ IEnumMediaTypes **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *QueryInternalConnections )( 
            IPin * This,
            /* [out] */ IPin **apPin,
            /* [out][in] */ ULONG *nPin);
        
        HRESULT ( STDMETHODCALLTYPE *EndOfStream )( 
            IPin * This);
        
        HRESULT ( STDMETHODCALLTYPE *BeginFlush )( 
            IPin * This);
        
        HRESULT ( STDMETHODCALLTYPE *EndFlush )( 
            IPin * This);
        
        HRESULT ( STDMETHODCALLTYPE *NewSegment )( 
            IPin * This,
            /* [in] */ REFERENCE_TIME tStart,
            /* [in] */ REFERENCE_TIME tStop,
            /* [in] */ double dRate);
        
        END_INTERFACE
    } IPinVtbl;

    interface IPin
    {
        CONST_VTBL struct IPinVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPin_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPin_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPin_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPin_Connect(This,pReceivePin,pmt)	\
    (This)->lpVtbl -> Connect(This,pReceivePin,pmt)

#define IPin_ReceiveConnection(This,pConnector,pmt)	\
    (This)->lpVtbl -> ReceiveConnection(This,pConnector,pmt)

#define IPin_Disconnect(This)	\
    (This)->lpVtbl -> Disconnect(This)

#define IPin_ConnectedTo(This,pPin)	\
    (This)->lpVtbl -> ConnectedTo(This,pPin)

#define IPin_ConnectionMediaType(This,pmt)	\
    (This)->lpVtbl -> ConnectionMediaType(This,pmt)

#define IPin_QueryPinInfo(This,pInfo)	\
    (This)->lpVtbl -> QueryPinInfo(This,pInfo)

#define IPin_QueryDirection(This,pPinDir)	\
    (This)->lpVtbl -> QueryDirection(This,pPinDir)

#define IPin_QueryId(This,Id)	\
    (This)->lpVtbl -> QueryId(This,Id)

#define IPin_QueryAccept(This,pmt)	\
    (This)->lpVtbl -> QueryAccept(This,pmt)

#define IPin_EnumMediaTypes(This,ppEnum)	\
    (This)->lpVtbl -> EnumMediaTypes(This,ppEnum)

#define IPin_QueryInternalConnections(This,apPin,nPin)	\
    (This)->lpVtbl -> QueryInternalConnections(This,apPin,nPin)

#define IPin_EndOfStream(This)	\
    (This)->lpVtbl -> EndOfStream(This)

#define IPin_BeginFlush(This)	\
    (This)->lpVtbl -> BeginFlush(This)

#define IPin_EndFlush(This)	\
    (This)->lpVtbl -> EndFlush(This)

#define IPin_NewSegment(This,tStart,tStop,dRate)	\
    (This)->lpVtbl -> NewSegment(This,tStart,tStop,dRate)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPin_Connect_Proxy( 
    IPin * This,
    /* [in] */ IPin *pReceivePin,
    /* [in] */ const AM_MEDIA_TYPE *pmt);


void __RPC_STUB IPin_Connect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPin_ReceiveConnection_Proxy( 
    IPin * This,
    /* [in] */ IPin *pConnector,
    /* [in] */ const AM_MEDIA_TYPE *pmt);


void __RPC_STUB IPin_ReceiveConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPin_Disconnect_Proxy( 
    IPin * This);


void __RPC_STUB IPin_Disconnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPin_ConnectedTo_Proxy( 
    IPin * This,
    /* [out] */ IPin **pPin);


void __RPC_STUB IPin_ConnectedTo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPin_ConnectionMediaType_Proxy( 
    IPin * This,
    /* [out] */ AM_MEDIA_TYPE *pmt);


void __RPC_STUB IPin_ConnectionMediaType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPin_QueryPinInfo_Proxy( 
    IPin * This,
    /* [out] */ PIN_INFO *pInfo);


void __RPC_STUB IPin_QueryPinInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPin_QueryDirection_Proxy( 
    IPin * This,
    /* [out] */ PIN_DIRECTION *pPinDir);


void __RPC_STUB IPin_QueryDirection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPin_QueryId_Proxy( 
    IPin * This,
    /* [out] */ LPWSTR *Id);


void __RPC_STUB IPin_QueryId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPin_QueryAccept_Proxy( 
    IPin * This,
    /* [in] */ const AM_MEDIA_TYPE *pmt);


void __RPC_STUB IPin_QueryAccept_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPin_EnumMediaTypes_Proxy( 
    IPin * This,
    /* [out] */ IEnumMediaTypes **ppEnum);


void __RPC_STUB IPin_EnumMediaTypes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPin_QueryInternalConnections_Proxy( 
    IPin * This,
    /* [out] */ IPin **apPin,
    /* [out][in] */ ULONG *nPin);


void __RPC_STUB IPin_QueryInternalConnections_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPin_EndOfStream_Proxy( 
    IPin * This);


void __RPC_STUB IPin_EndOfStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPin_BeginFlush_Proxy( 
    IPin * This);


void __RPC_STUB IPin_BeginFlush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPin_EndFlush_Proxy( 
    IPin * This);


void __RPC_STUB IPin_EndFlush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPin_NewSegment_Proxy( 
    IPin * This,
    /* [in] */ REFERENCE_TIME tStart,
    /* [in] */ REFERENCE_TIME tStop,
    /* [in] */ double dRate);


void __RPC_STUB IPin_NewSegment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPin_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0114 */
/* [local] */ 

typedef IPin *PPIN;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0114_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0114_v0_0_s_ifspec;

#ifndef __IEnumPins_INTERFACE_DEFINED__
#define __IEnumPins_INTERFACE_DEFINED__

/* interface IEnumPins */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumPins;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a86892-0ad4-11ce-b03a-0020af0ba770")
    IEnumPins : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG cPins,
            /* [size_is][out] */ IPin **ppPins,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cPins) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumPins **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumPinsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumPins * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumPins * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumPins * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumPins * This,
            /* [in] */ ULONG cPins,
            /* [size_is][out] */ IPin **ppPins,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumPins * This,
            /* [in] */ ULONG cPins);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumPins * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumPins * This,
            /* [out] */ IEnumPins **ppEnum);
        
        END_INTERFACE
    } IEnumPinsVtbl;

    interface IEnumPins
    {
        CONST_VTBL struct IEnumPinsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumPins_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumPins_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumPins_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumPins_Next(This,cPins,ppPins,pcFetched)	\
    (This)->lpVtbl -> Next(This,cPins,ppPins,pcFetched)

#define IEnumPins_Skip(This,cPins)	\
    (This)->lpVtbl -> Skip(This,cPins)

#define IEnumPins_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumPins_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumPins_Next_Proxy( 
    IEnumPins * This,
    /* [in] */ ULONG cPins,
    /* [size_is][out] */ IPin **ppPins,
    /* [out] */ ULONG *pcFetched);


void __RPC_STUB IEnumPins_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPins_Skip_Proxy( 
    IEnumPins * This,
    /* [in] */ ULONG cPins);


void __RPC_STUB IEnumPins_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPins_Reset_Proxy( 
    IEnumPins * This);


void __RPC_STUB IEnumPins_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPins_Clone_Proxy( 
    IEnumPins * This,
    /* [out] */ IEnumPins **ppEnum);


void __RPC_STUB IEnumPins_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumPins_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0115 */
/* [local] */ 

typedef IEnumPins *PENUMPINS;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0115_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0115_v0_0_s_ifspec;

#ifndef __IEnumMediaTypes_INTERFACE_DEFINED__
#define __IEnumMediaTypes_INTERFACE_DEFINED__

/* interface IEnumMediaTypes */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumMediaTypes;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("89c31040-846b-11ce-97d3-00aa0055595a")
    IEnumMediaTypes : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG cMediaTypes,
            /* [size_is][out] */ AM_MEDIA_TYPE **ppMediaTypes,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cMediaTypes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumMediaTypes **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumMediaTypesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumMediaTypes * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumMediaTypes * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumMediaTypes * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumMediaTypes * This,
            /* [in] */ ULONG cMediaTypes,
            /* [size_is][out] */ AM_MEDIA_TYPE **ppMediaTypes,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumMediaTypes * This,
            /* [in] */ ULONG cMediaTypes);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumMediaTypes * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumMediaTypes * This,
            /* [out] */ IEnumMediaTypes **ppEnum);
        
        END_INTERFACE
    } IEnumMediaTypesVtbl;

    interface IEnumMediaTypes
    {
        CONST_VTBL struct IEnumMediaTypesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumMediaTypes_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumMediaTypes_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumMediaTypes_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumMediaTypes_Next(This,cMediaTypes,ppMediaTypes,pcFetched)	\
    (This)->lpVtbl -> Next(This,cMediaTypes,ppMediaTypes,pcFetched)

#define IEnumMediaTypes_Skip(This,cMediaTypes)	\
    (This)->lpVtbl -> Skip(This,cMediaTypes)

#define IEnumMediaTypes_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumMediaTypes_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumMediaTypes_Next_Proxy( 
    IEnumMediaTypes * This,
    /* [in] */ ULONG cMediaTypes,
    /* [size_is][out] */ AM_MEDIA_TYPE **ppMediaTypes,
    /* [out] */ ULONG *pcFetched);


void __RPC_STUB IEnumMediaTypes_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumMediaTypes_Skip_Proxy( 
    IEnumMediaTypes * This,
    /* [in] */ ULONG cMediaTypes);


void __RPC_STUB IEnumMediaTypes_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumMediaTypes_Reset_Proxy( 
    IEnumMediaTypes * This);


void __RPC_STUB IEnumMediaTypes_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumMediaTypes_Clone_Proxy( 
    IEnumMediaTypes * This,
    /* [out] */ IEnumMediaTypes **ppEnum);


void __RPC_STUB IEnumMediaTypes_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumMediaTypes_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0116 */
/* [local] */ 

typedef IEnumMediaTypes *PENUMMEDIATYPES;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0116_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0116_v0_0_s_ifspec;

#ifndef __IFilterGraph_INTERFACE_DEFINED__
#define __IFilterGraph_INTERFACE_DEFINED__

/* interface IFilterGraph */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IFilterGraph;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a8689f-0ad4-11ce-b03a-0020af0ba770")
    IFilterGraph : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddFilter( 
            /* [in] */ IBaseFilter *pFilter,
            /* [string][in] */ LPCWSTR pName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveFilter( 
            /* [in] */ IBaseFilter *pFilter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumFilters( 
            /* [out] */ IEnumFilters **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindFilterByName( 
            /* [string][in] */ LPCWSTR pName,
            /* [out] */ IBaseFilter **ppFilter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConnectDirect( 
            /* [in] */ IPin *ppinOut,
            /* [in] */ IPin *ppinIn,
            /* [unique][in] */ const AM_MEDIA_TYPE *pmt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reconnect( 
            /* [in] */ IPin *ppin) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Disconnect( 
            /* [in] */ IPin *ppin) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDefaultSyncSource( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFilterGraphVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFilterGraph * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFilterGraph * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFilterGraph * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddFilter )( 
            IFilterGraph * This,
            /* [in] */ IBaseFilter *pFilter,
            /* [string][in] */ LPCWSTR pName);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveFilter )( 
            IFilterGraph * This,
            /* [in] */ IBaseFilter *pFilter);
        
        HRESULT ( STDMETHODCALLTYPE *EnumFilters )( 
            IFilterGraph * This,
            /* [out] */ IEnumFilters **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *FindFilterByName )( 
            IFilterGraph * This,
            /* [string][in] */ LPCWSTR pName,
            /* [out] */ IBaseFilter **ppFilter);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectDirect )( 
            IFilterGraph * This,
            /* [in] */ IPin *ppinOut,
            /* [in] */ IPin *ppinIn,
            /* [unique][in] */ const AM_MEDIA_TYPE *pmt);
        
        HRESULT ( STDMETHODCALLTYPE *Reconnect )( 
            IFilterGraph * This,
            /* [in] */ IPin *ppin);
        
        HRESULT ( STDMETHODCALLTYPE *Disconnect )( 
            IFilterGraph * This,
            /* [in] */ IPin *ppin);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultSyncSource )( 
            IFilterGraph * This);
        
        END_INTERFACE
    } IFilterGraphVtbl;

    interface IFilterGraph
    {
        CONST_VTBL struct IFilterGraphVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFilterGraph_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFilterGraph_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFilterGraph_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFilterGraph_AddFilter(This,pFilter,pName)	\
    (This)->lpVtbl -> AddFilter(This,pFilter,pName)

#define IFilterGraph_RemoveFilter(This,pFilter)	\
    (This)->lpVtbl -> RemoveFilter(This,pFilter)

#define IFilterGraph_EnumFilters(This,ppEnum)	\
    (This)->lpVtbl -> EnumFilters(This,ppEnum)

#define IFilterGraph_FindFilterByName(This,pName,ppFilter)	\
    (This)->lpVtbl -> FindFilterByName(This,pName,ppFilter)

#define IFilterGraph_ConnectDirect(This,ppinOut,ppinIn,pmt)	\
    (This)->lpVtbl -> ConnectDirect(This,ppinOut,ppinIn,pmt)

#define IFilterGraph_Reconnect(This,ppin)	\
    (This)->lpVtbl -> Reconnect(This,ppin)

#define IFilterGraph_Disconnect(This,ppin)	\
    (This)->lpVtbl -> Disconnect(This,ppin)

#define IFilterGraph_SetDefaultSyncSource(This)	\
    (This)->lpVtbl -> SetDefaultSyncSource(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IFilterGraph_AddFilter_Proxy( 
    IFilterGraph * This,
    /* [in] */ IBaseFilter *pFilter,
    /* [string][in] */ LPCWSTR pName);


void __RPC_STUB IFilterGraph_AddFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IFilterGraph_RemoveFilter_Proxy( 
    IFilterGraph * This,
    /* [in] */ IBaseFilter *pFilter);


void __RPC_STUB IFilterGraph_RemoveFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IFilterGraph_EnumFilters_Proxy( 
    IFilterGraph * This,
    /* [out] */ IEnumFilters **ppEnum);


void __RPC_STUB IFilterGraph_EnumFilters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IFilterGraph_FindFilterByName_Proxy( 
    IFilterGraph * This,
    /* [string][in] */ LPCWSTR pName,
    /* [out] */ IBaseFilter **ppFilter);


void __RPC_STUB IFilterGraph_FindFilterByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IFilterGraph_ConnectDirect_Proxy( 
    IFilterGraph * This,
    /* [in] */ IPin *ppinOut,
    /* [in] */ IPin *ppinIn,
    /* [unique][in] */ const AM_MEDIA_TYPE *pmt);


void __RPC_STUB IFilterGraph_ConnectDirect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IFilterGraph_Reconnect_Proxy( 
    IFilterGraph * This,
    /* [in] */ IPin *ppin);


void __RPC_STUB IFilterGraph_Reconnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IFilterGraph_Disconnect_Proxy( 
    IFilterGraph * This,
    /* [in] */ IPin *ppin);


void __RPC_STUB IFilterGraph_Disconnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IFilterGraph_SetDefaultSyncSource_Proxy( 
    IFilterGraph * This);


void __RPC_STUB IFilterGraph_SetDefaultSyncSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFilterGraph_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0117 */
/* [local] */ 

typedef IFilterGraph *PFILTERGRAPH;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0117_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0117_v0_0_s_ifspec;

#ifndef __IEnumFilters_INTERFACE_DEFINED__
#define __IEnumFilters_INTERFACE_DEFINED__

/* interface IEnumFilters */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumFilters;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a86893-0ad4-11ce-b03a-0020af0ba770")
    IEnumFilters : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG cFilters,
            /* [out] */ IBaseFilter **ppFilter,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cFilters) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumFilters **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumFiltersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumFilters * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumFilters * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumFilters * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumFilters * This,
            /* [in] */ ULONG cFilters,
            /* [out] */ IBaseFilter **ppFilter,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumFilters * This,
            /* [in] */ ULONG cFilters);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumFilters * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumFilters * This,
            /* [out] */ IEnumFilters **ppEnum);
        
        END_INTERFACE
    } IEnumFiltersVtbl;

    interface IEnumFilters
    {
        CONST_VTBL struct IEnumFiltersVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumFilters_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumFilters_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumFilters_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumFilters_Next(This,cFilters,ppFilter,pcFetched)	\
    (This)->lpVtbl -> Next(This,cFilters,ppFilter,pcFetched)

#define IEnumFilters_Skip(This,cFilters)	\
    (This)->lpVtbl -> Skip(This,cFilters)

#define IEnumFilters_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumFilters_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumFilters_Next_Proxy( 
    IEnumFilters * This,
    /* [in] */ ULONG cFilters,
    /* [out] */ IBaseFilter **ppFilter,
    /* [out] */ ULONG *pcFetched);


void __RPC_STUB IEnumFilters_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumFilters_Skip_Proxy( 
    IEnumFilters * This,
    /* [in] */ ULONG cFilters);


void __RPC_STUB IEnumFilters_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumFilters_Reset_Proxy( 
    IEnumFilters * This);


void __RPC_STUB IEnumFilters_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumFilters_Clone_Proxy( 
    IEnumFilters * This,
    /* [out] */ IEnumFilters **ppEnum);


void __RPC_STUB IEnumFilters_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumFilters_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0118 */
/* [local] */ 

typedef IEnumFilters *PENUMFILTERS;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0118_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0118_v0_0_s_ifspec;

#ifndef __IMediaFilter_INTERFACE_DEFINED__
#define __IMediaFilter_INTERFACE_DEFINED__

/* interface IMediaFilter */
/* [unique][uuid][object] */ 

typedef 
enum _FilterState
    {	State_Stopped	= 0,
	State_Paused	= State_Stopped + 1,
	State_Running	= State_Paused + 1
    } 	FILTER_STATE;


EXTERN_C const IID IID_IMediaFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a86899-0ad4-11ce-b03a-0020af0ba770")
    IMediaFilter : public IPersist
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Run( 
            REFERENCE_TIME tStart) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetState( 
            /* [in] */ DWORD dwMilliSecsTimeout,
            /* [out] */ FILTER_STATE *State) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSyncSource( 
            /* [in] */ IReferenceClock *pClock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSyncSource( 
            /* [out] */ IReferenceClock **pClock) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaFilter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaFilter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassID )( 
            IMediaFilter * This,
            /* [out] */ CLSID *pClassID);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IMediaFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IMediaFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *Run )( 
            IMediaFilter * This,
            REFERENCE_TIME tStart);
        
        HRESULT ( STDMETHODCALLTYPE *GetState )( 
            IMediaFilter * This,
            /* [in] */ DWORD dwMilliSecsTimeout,
            /* [out] */ FILTER_STATE *State);
        
        HRESULT ( STDMETHODCALLTYPE *SetSyncSource )( 
            IMediaFilter * This,
            /* [in] */ IReferenceClock *pClock);
        
        HRESULT ( STDMETHODCALLTYPE *GetSyncSource )( 
            IMediaFilter * This,
            /* [out] */ IReferenceClock **pClock);
        
        END_INTERFACE
    } IMediaFilterVtbl;

    interface IMediaFilter
    {
        CONST_VTBL struct IMediaFilterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaFilter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMediaFilter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMediaFilter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMediaFilter_GetClassID(This,pClassID)	\
    (This)->lpVtbl -> GetClassID(This,pClassID)


#define IMediaFilter_Stop(This)	\
    (This)->lpVtbl -> Stop(This)

#define IMediaFilter_Pause(This)	\
    (This)->lpVtbl -> Pause(This)

#define IMediaFilter_Run(This,tStart)	\
    (This)->lpVtbl -> Run(This,tStart)

#define IMediaFilter_GetState(This,dwMilliSecsTimeout,State)	\
    (This)->lpVtbl -> GetState(This,dwMilliSecsTimeout,State)

#define IMediaFilter_SetSyncSource(This,pClock)	\
    (This)->lpVtbl -> SetSyncSource(This,pClock)

#define IMediaFilter_GetSyncSource(This,pClock)	\
    (This)->lpVtbl -> GetSyncSource(This,pClock)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMediaFilter_Stop_Proxy( 
    IMediaFilter * This);


void __RPC_STUB IMediaFilter_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaFilter_Pause_Proxy( 
    IMediaFilter * This);


void __RPC_STUB IMediaFilter_Pause_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaFilter_Run_Proxy( 
    IMediaFilter * This,
    REFERENCE_TIME tStart);


void __RPC_STUB IMediaFilter_Run_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaFilter_GetState_Proxy( 
    IMediaFilter * This,
    /* [in] */ DWORD dwMilliSecsTimeout,
    /* [out] */ FILTER_STATE *State);


void __RPC_STUB IMediaFilter_GetState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaFilter_SetSyncSource_Proxy( 
    IMediaFilter * This,
    /* [in] */ IReferenceClock *pClock);


void __RPC_STUB IMediaFilter_SetSyncSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaFilter_GetSyncSource_Proxy( 
    IMediaFilter * This,
    /* [out] */ IReferenceClock **pClock);


void __RPC_STUB IMediaFilter_GetSyncSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMediaFilter_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0119 */
/* [local] */ 

typedef IMediaFilter *PMEDIAFILTER;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0119_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0119_v0_0_s_ifspec;

#ifndef __IBaseFilter_INTERFACE_DEFINED__
#define __IBaseFilter_INTERFACE_DEFINED__

/* interface IBaseFilter */
/* [unique][uuid][object] */ 

typedef struct _FilterInfo
    {
    WCHAR achName[ 128 ];
    IFilterGraph *pGraph;
    } 	FILTER_INFO;


EXTERN_C const IID IID_IBaseFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a86895-0ad4-11ce-b03a-0020af0ba770")
    IBaseFilter : public IMediaFilter
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumPins( 
            /* [out] */ IEnumPins **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindPin( 
            /* [string][in] */ LPCWSTR Id,
            /* [out] */ IPin **ppPin) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryFilterInfo( 
            /* [out] */ FILTER_INFO *pInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE JoinFilterGraph( 
            /* [in] */ IFilterGraph *pGraph,
            /* [string][in] */ LPCWSTR pName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryVendorInfo( 
            /* [string][out] */ LPWSTR *pVendorInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBaseFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBaseFilter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBaseFilter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBaseFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassID )( 
            IBaseFilter * This,
            /* [out] */ CLSID *pClassID);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IBaseFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IBaseFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *Run )( 
            IBaseFilter * This,
            REFERENCE_TIME tStart);
        
        HRESULT ( STDMETHODCALLTYPE *GetState )( 
            IBaseFilter * This,
            /* [in] */ DWORD dwMilliSecsTimeout,
            /* [out] */ FILTER_STATE *State);
        
        HRESULT ( STDMETHODCALLTYPE *SetSyncSource )( 
            IBaseFilter * This,
            /* [in] */ IReferenceClock *pClock);
        
        HRESULT ( STDMETHODCALLTYPE *GetSyncSource )( 
            IBaseFilter * This,
            /* [out] */ IReferenceClock **pClock);
        
        HRESULT ( STDMETHODCALLTYPE *EnumPins )( 
            IBaseFilter * This,
            /* [out] */ IEnumPins **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *FindPin )( 
            IBaseFilter * This,
            /* [string][in] */ LPCWSTR Id,
            /* [out] */ IPin **ppPin);
        
        HRESULT ( STDMETHODCALLTYPE *QueryFilterInfo )( 
            IBaseFilter * This,
            /* [out] */ FILTER_INFO *pInfo);
        
        HRESULT ( STDMETHODCALLTYPE *JoinFilterGraph )( 
            IBaseFilter * This,
            /* [in] */ IFilterGraph *pGraph,
            /* [string][in] */ LPCWSTR pName);
        
        HRESULT ( STDMETHODCALLTYPE *QueryVendorInfo )( 
            IBaseFilter * This,
            /* [string][out] */ LPWSTR *pVendorInfo);
        
        END_INTERFACE
    } IBaseFilterVtbl;

    interface IBaseFilter
    {
        CONST_VTBL struct IBaseFilterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBaseFilter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBaseFilter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBaseFilter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBaseFilter_GetClassID(This,pClassID)	\
    (This)->lpVtbl -> GetClassID(This,pClassID)


#define IBaseFilter_Stop(This)	\
    (This)->lpVtbl -> Stop(This)

#define IBaseFilter_Pause(This)	\
    (This)->lpVtbl -> Pause(This)

#define IBaseFilter_Run(This,tStart)	\
    (This)->lpVtbl -> Run(This,tStart)

#define IBaseFilter_GetState(This,dwMilliSecsTimeout,State)	\
    (This)->lpVtbl -> GetState(This,dwMilliSecsTimeout,State)

#define IBaseFilter_SetSyncSource(This,pClock)	\
    (This)->lpVtbl -> SetSyncSource(This,pClock)

#define IBaseFilter_GetSyncSource(This,pClock)	\
    (This)->lpVtbl -> GetSyncSource(This,pClock)


#define IBaseFilter_EnumPins(This,ppEnum)	\
    (This)->lpVtbl -> EnumPins(This,ppEnum)

#define IBaseFilter_FindPin(This,Id,ppPin)	\
    (This)->lpVtbl -> FindPin(This,Id,ppPin)

#define IBaseFilter_QueryFilterInfo(This,pInfo)	\
    (This)->lpVtbl -> QueryFilterInfo(This,pInfo)

#define IBaseFilter_JoinFilterGraph(This,pGraph,pName)	\
    (This)->lpVtbl -> JoinFilterGraph(This,pGraph,pName)

#define IBaseFilter_QueryVendorInfo(This,pVendorInfo)	\
    (This)->lpVtbl -> QueryVendorInfo(This,pVendorInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IBaseFilter_EnumPins_Proxy( 
    IBaseFilter * This,
    /* [out] */ IEnumPins **ppEnum);


void __RPC_STUB IBaseFilter_EnumPins_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBaseFilter_FindPin_Proxy( 
    IBaseFilter * This,
    /* [string][in] */ LPCWSTR Id,
    /* [out] */ IPin **ppPin);


void __RPC_STUB IBaseFilter_FindPin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBaseFilter_QueryFilterInfo_Proxy( 
    IBaseFilter * This,
    /* [out] */ FILTER_INFO *pInfo);


void __RPC_STUB IBaseFilter_QueryFilterInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBaseFilter_JoinFilterGraph_Proxy( 
    IBaseFilter * This,
    /* [in] */ IFilterGraph *pGraph,
    /* [string][in] */ LPCWSTR pName);


void __RPC_STUB IBaseFilter_JoinFilterGraph_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBaseFilter_QueryVendorInfo_Proxy( 
    IBaseFilter * This,
    /* [string][out] */ LPWSTR *pVendorInfo);


void __RPC_STUB IBaseFilter_QueryVendorInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBaseFilter_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0120 */
/* [local] */ 

typedef IBaseFilter *PFILTER;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0120_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0120_v0_0_s_ifspec;

#ifndef __IReferenceClock_INTERFACE_DEFINED__
#define __IReferenceClock_INTERFACE_DEFINED__

/* interface IReferenceClock */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IReferenceClock;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a86897-0ad4-11ce-b03a-0020af0ba770")
    IReferenceClock : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTime( 
            /* [out] */ REFERENCE_TIME *pTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AdviseTime( 
            /* [in] */ REFERENCE_TIME baseTime,
            /* [in] */ REFERENCE_TIME streamTime,
            /* [in] */ HEVENT hEvent,
            /* [out] */ DWORD_PTR *pdwAdviseCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AdvisePeriodic( 
            /* [in] */ REFERENCE_TIME startTime,
            /* [in] */ REFERENCE_TIME periodTime,
            /* [in] */ HSEMAPHORE hSemaphore,
            /* [out] */ DWORD_PTR *pdwAdviseCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unadvise( 
            /* [in] */ DWORD_PTR dwAdviseCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IReferenceClockVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IReferenceClock * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IReferenceClock * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IReferenceClock * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTime )( 
            IReferenceClock * This,
            /* [out] */ REFERENCE_TIME *pTime);
        
        HRESULT ( STDMETHODCALLTYPE *AdviseTime )( 
            IReferenceClock * This,
            /* [in] */ REFERENCE_TIME baseTime,
            /* [in] */ REFERENCE_TIME streamTime,
            /* [in] */ HEVENT hEvent,
            /* [out] */ DWORD_PTR *pdwAdviseCookie);
        
        HRESULT ( STDMETHODCALLTYPE *AdvisePeriodic )( 
            IReferenceClock * This,
            /* [in] */ REFERENCE_TIME startTime,
            /* [in] */ REFERENCE_TIME periodTime,
            /* [in] */ HSEMAPHORE hSemaphore,
            /* [out] */ DWORD_PTR *pdwAdviseCookie);
        
        HRESULT ( STDMETHODCALLTYPE *Unadvise )( 
            IReferenceClock * This,
            /* [in] */ DWORD_PTR dwAdviseCookie);
        
        END_INTERFACE
    } IReferenceClockVtbl;

    interface IReferenceClock
    {
        CONST_VTBL struct IReferenceClockVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IReferenceClock_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IReferenceClock_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IReferenceClock_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IReferenceClock_GetTime(This,pTime)	\
    (This)->lpVtbl -> GetTime(This,pTime)

#define IReferenceClock_AdviseTime(This,baseTime,streamTime,hEvent,pdwAdviseCookie)	\
    (This)->lpVtbl -> AdviseTime(This,baseTime,streamTime,hEvent,pdwAdviseCookie)

#define IReferenceClock_AdvisePeriodic(This,startTime,periodTime,hSemaphore,pdwAdviseCookie)	\
    (This)->lpVtbl -> AdvisePeriodic(This,startTime,periodTime,hSemaphore,pdwAdviseCookie)

#define IReferenceClock_Unadvise(This,dwAdviseCookie)	\
    (This)->lpVtbl -> Unadvise(This,dwAdviseCookie)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IReferenceClock_GetTime_Proxy( 
    IReferenceClock * This,
    /* [out] */ REFERENCE_TIME *pTime);


void __RPC_STUB IReferenceClock_GetTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IReferenceClock_AdviseTime_Proxy( 
    IReferenceClock * This,
    /* [in] */ REFERENCE_TIME baseTime,
    /* [in] */ REFERENCE_TIME streamTime,
    /* [in] */ HEVENT hEvent,
    /* [out] */ DWORD_PTR *pdwAdviseCookie);


void __RPC_STUB IReferenceClock_AdviseTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IReferenceClock_AdvisePeriodic_Proxy( 
    IReferenceClock * This,
    /* [in] */ REFERENCE_TIME startTime,
    /* [in] */ REFERENCE_TIME periodTime,
    /* [in] */ HSEMAPHORE hSemaphore,
    /* [out] */ DWORD_PTR *pdwAdviseCookie);


void __RPC_STUB IReferenceClock_AdvisePeriodic_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IReferenceClock_Unadvise_Proxy( 
    IReferenceClock * This,
    /* [in] */ DWORD_PTR dwAdviseCookie);


void __RPC_STUB IReferenceClock_Unadvise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IReferenceClock_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0121 */
/* [local] */ 

typedef IReferenceClock *PREFERENCECLOCK;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0121_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0121_v0_0_s_ifspec;

#ifndef __IReferenceClock2_INTERFACE_DEFINED__
#define __IReferenceClock2_INTERFACE_DEFINED__

/* interface IReferenceClock2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IReferenceClock2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("36b73885-c2c8-11cf-8b46-00805f6cef60")
    IReferenceClock2 : public IReferenceClock
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IReferenceClock2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IReferenceClock2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IReferenceClock2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IReferenceClock2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTime )( 
            IReferenceClock2 * This,
            /* [out] */ REFERENCE_TIME *pTime);
        
        HRESULT ( STDMETHODCALLTYPE *AdviseTime )( 
            IReferenceClock2 * This,
            /* [in] */ REFERENCE_TIME baseTime,
            /* [in] */ REFERENCE_TIME streamTime,
            /* [in] */ HEVENT hEvent,
            /* [out] */ DWORD_PTR *pdwAdviseCookie);
        
        HRESULT ( STDMETHODCALLTYPE *AdvisePeriodic )( 
            IReferenceClock2 * This,
            /* [in] */ REFERENCE_TIME startTime,
            /* [in] */ REFERENCE_TIME periodTime,
            /* [in] */ HSEMAPHORE hSemaphore,
            /* [out] */ DWORD_PTR *pdwAdviseCookie);
        
        HRESULT ( STDMETHODCALLTYPE *Unadvise )( 
            IReferenceClock2 * This,
            /* [in] */ DWORD_PTR dwAdviseCookie);
        
        END_INTERFACE
    } IReferenceClock2Vtbl;

    interface IReferenceClock2
    {
        CONST_VTBL struct IReferenceClock2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IReferenceClock2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IReferenceClock2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IReferenceClock2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IReferenceClock2_GetTime(This,pTime)	\
    (This)->lpVtbl -> GetTime(This,pTime)

#define IReferenceClock2_AdviseTime(This,baseTime,streamTime,hEvent,pdwAdviseCookie)	\
    (This)->lpVtbl -> AdviseTime(This,baseTime,streamTime,hEvent,pdwAdviseCookie)

#define IReferenceClock2_AdvisePeriodic(This,startTime,periodTime,hSemaphore,pdwAdviseCookie)	\
    (This)->lpVtbl -> AdvisePeriodic(This,startTime,periodTime,hSemaphore,pdwAdviseCookie)

#define IReferenceClock2_Unadvise(This,dwAdviseCookie)	\
    (This)->lpVtbl -> Unadvise(This,dwAdviseCookie)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IReferenceClock2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0122 */
/* [local] */ 

typedef IReferenceClock2 *PREFERENCECLOCK2;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0122_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0122_v0_0_s_ifspec;

#ifndef __IMediaSample_INTERFACE_DEFINED__
#define __IMediaSample_INTERFACE_DEFINED__

/* interface IMediaSample */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IMediaSample;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a8689a-0ad4-11ce-b03a-0020af0ba770")
    IMediaSample : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPointer( 
            /* [out] */ BYTE **ppBuffer) = 0;
        
        virtual long STDMETHODCALLTYPE GetSize( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTime( 
            /* [out] */ REFERENCE_TIME *pTimeStart,
            /* [out] */ REFERENCE_TIME *pTimeEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTime( 
            /* [in] */ REFERENCE_TIME *pTimeStart,
            /* [in] */ REFERENCE_TIME *pTimeEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsSyncPoint( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSyncPoint( 
            BOOL bIsSyncPoint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsPreroll( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPreroll( 
            BOOL bIsPreroll) = 0;
        
        virtual long STDMETHODCALLTYPE GetActualDataLength( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetActualDataLength( 
            long __MIDL_0010) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMediaType( 
            AM_MEDIA_TYPE **ppMediaType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMediaType( 
            AM_MEDIA_TYPE *pMediaType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsDiscontinuity( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDiscontinuity( 
            BOOL bDiscontinuity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMediaTime( 
            /* [out] */ LONGLONG *pTimeStart,
            /* [out] */ LONGLONG *pTimeEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMediaTime( 
            /* [in] */ LONGLONG *pTimeStart,
            /* [in] */ LONGLONG *pTimeEnd) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaSampleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaSample * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaSample * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaSample * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPointer )( 
            IMediaSample * This,
            /* [out] */ BYTE **ppBuffer);
        
        long ( STDMETHODCALLTYPE *GetSize )( 
            IMediaSample * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTime )( 
            IMediaSample * This,
            /* [out] */ REFERENCE_TIME *pTimeStart,
            /* [out] */ REFERENCE_TIME *pTimeEnd);
        
        HRESULT ( STDMETHODCALLTYPE *SetTime )( 
            IMediaSample * This,
            /* [in] */ REFERENCE_TIME *pTimeStart,
            /* [in] */ REFERENCE_TIME *pTimeEnd);
        
        HRESULT ( STDMETHODCALLTYPE *IsSyncPoint )( 
            IMediaSample * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetSyncPoint )( 
            IMediaSample * This,
            BOOL bIsSyncPoint);
        
        HRESULT ( STDMETHODCALLTYPE *IsPreroll )( 
            IMediaSample * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetPreroll )( 
            IMediaSample * This,
            BOOL bIsPreroll);
        
        long ( STDMETHODCALLTYPE *GetActualDataLength )( 
            IMediaSample * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetActualDataLength )( 
            IMediaSample * This,
            long __MIDL_0010);
        
        HRESULT ( STDMETHODCALLTYPE *GetMediaType )( 
            IMediaSample * This,
            AM_MEDIA_TYPE **ppMediaType);
        
        HRESULT ( STDMETHODCALLTYPE *SetMediaType )( 
            IMediaSample * This,
            AM_MEDIA_TYPE *pMediaType);
        
        HRESULT ( STDMETHODCALLTYPE *IsDiscontinuity )( 
            IMediaSample * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetDiscontinuity )( 
            IMediaSample * This,
            BOOL bDiscontinuity);
        
        HRESULT ( STDMETHODCALLTYPE *GetMediaTime )( 
            IMediaSample * This,
            /* [out] */ LONGLONG *pTimeStart,
            /* [out] */ LONGLONG *pTimeEnd);
        
        HRESULT ( STDMETHODCALLTYPE *SetMediaTime )( 
            IMediaSample * This,
            /* [in] */ LONGLONG *pTimeStart,
            /* [in] */ LONGLONG *pTimeEnd);
        
        END_INTERFACE
    } IMediaSampleVtbl;

    interface IMediaSample
    {
        CONST_VTBL struct IMediaSampleVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaSample_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMediaSample_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMediaSample_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMediaSample_GetPointer(This,ppBuffer)	\
    (This)->lpVtbl -> GetPointer(This,ppBuffer)

#define IMediaSample_GetSize(This)	\
    (This)->lpVtbl -> GetSize(This)

#define IMediaSample_GetTime(This,pTimeStart,pTimeEnd)	\
    (This)->lpVtbl -> GetTime(This,pTimeStart,pTimeEnd)

#define IMediaSample_SetTime(This,pTimeStart,pTimeEnd)	\
    (This)->lpVtbl -> SetTime(This,pTimeStart,pTimeEnd)

#define IMediaSample_IsSyncPoint(This)	\
    (This)->lpVtbl -> IsSyncPoint(This)

#define IMediaSample_SetSyncPoint(This,bIsSyncPoint)	\
    (This)->lpVtbl -> SetSyncPoint(This,bIsSyncPoint)

#define IMediaSample_IsPreroll(This)	\
    (This)->lpVtbl -> IsPreroll(This)

#define IMediaSample_SetPreroll(This,bIsPreroll)	\
    (This)->lpVtbl -> SetPreroll(This,bIsPreroll)

#define IMediaSample_GetActualDataLength(This)	\
    (This)->lpVtbl -> GetActualDataLength(This)

#define IMediaSample_SetActualDataLength(This,__MIDL_0010)	\
    (This)->lpVtbl -> SetActualDataLength(This,__MIDL_0010)

#define IMediaSample_GetMediaType(This,ppMediaType)	\
    (This)->lpVtbl -> GetMediaType(This,ppMediaType)

#define IMediaSample_SetMediaType(This,pMediaType)	\
    (This)->lpVtbl -> SetMediaType(This,pMediaType)

#define IMediaSample_IsDiscontinuity(This)	\
    (This)->lpVtbl -> IsDiscontinuity(This)

#define IMediaSample_SetDiscontinuity(This,bDiscontinuity)	\
    (This)->lpVtbl -> SetDiscontinuity(This,bDiscontinuity)

#define IMediaSample_GetMediaTime(This,pTimeStart,pTimeEnd)	\
    (This)->lpVtbl -> GetMediaTime(This,pTimeStart,pTimeEnd)

#define IMediaSample_SetMediaTime(This,pTimeStart,pTimeEnd)	\
    (This)->lpVtbl -> SetMediaTime(This,pTimeStart,pTimeEnd)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMediaSample_GetPointer_Proxy( 
    IMediaSample * This,
    /* [out] */ BYTE **ppBuffer);


void __RPC_STUB IMediaSample_GetPointer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


long STDMETHODCALLTYPE IMediaSample_GetSize_Proxy( 
    IMediaSample * This);


void __RPC_STUB IMediaSample_GetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaSample_GetTime_Proxy( 
    IMediaSample * This,
    /* [out] */ REFERENCE_TIME *pTimeStart,
    /* [out] */ REFERENCE_TIME *pTimeEnd);


void __RPC_STUB IMediaSample_GetTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaSample_SetTime_Proxy( 
    IMediaSample * This,
    /* [in] */ REFERENCE_TIME *pTimeStart,
    /* [in] */ REFERENCE_TIME *pTimeEnd);


void __RPC_STUB IMediaSample_SetTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaSample_IsSyncPoint_Proxy( 
    IMediaSample * This);


void __RPC_STUB IMediaSample_IsSyncPoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaSample_SetSyncPoint_Proxy( 
    IMediaSample * This,
    BOOL bIsSyncPoint);


void __RPC_STUB IMediaSample_SetSyncPoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaSample_IsPreroll_Proxy( 
    IMediaSample * This);


void __RPC_STUB IMediaSample_IsPreroll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaSample_SetPreroll_Proxy( 
    IMediaSample * This,
    BOOL bIsPreroll);


void __RPC_STUB IMediaSample_SetPreroll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


long STDMETHODCALLTYPE IMediaSample_GetActualDataLength_Proxy( 
    IMediaSample * This);


void __RPC_STUB IMediaSample_GetActualDataLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaSample_SetActualDataLength_Proxy( 
    IMediaSample * This,
    long __MIDL_0010);


void __RPC_STUB IMediaSample_SetActualDataLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaSample_GetMediaType_Proxy( 
    IMediaSample * This,
    AM_MEDIA_TYPE **ppMediaType);


void __RPC_STUB IMediaSample_GetMediaType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaSample_SetMediaType_Proxy( 
    IMediaSample * This,
    AM_MEDIA_TYPE *pMediaType);


void __RPC_STUB IMediaSample_SetMediaType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaSample_IsDiscontinuity_Proxy( 
    IMediaSample * This);


void __RPC_STUB IMediaSample_IsDiscontinuity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaSample_SetDiscontinuity_Proxy( 
    IMediaSample * This,
    BOOL bDiscontinuity);


void __RPC_STUB IMediaSample_SetDiscontinuity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaSample_GetMediaTime_Proxy( 
    IMediaSample * This,
    /* [out] */ LONGLONG *pTimeStart,
    /* [out] */ LONGLONG *pTimeEnd);


void __RPC_STUB IMediaSample_GetMediaTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaSample_SetMediaTime_Proxy( 
    IMediaSample * This,
    /* [in] */ LONGLONG *pTimeStart,
    /* [in] */ LONGLONG *pTimeEnd);


void __RPC_STUB IMediaSample_SetMediaTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMediaSample_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0123 */
/* [local] */ 

typedef IMediaSample *PMEDIASAMPLE;


enum tagAM_SAMPLE_PROPERTY_FLAGS
    {	AM_SAMPLE_SPLICEPOINT	= 0x1,
	AM_SAMPLE_PREROLL	= 0x2,
	AM_SAMPLE_DATADISCONTINUITY	= 0x4,
	AM_SAMPLE_TYPECHANGED	= 0x8,
	AM_SAMPLE_TIMEVALID	= 0x10,
	AM_SAMPLE_TIMEDISCONTINUITY	= 0x40,
	AM_SAMPLE_FLUSH_ON_PAUSE	= 0x80,
	AM_SAMPLE_STOPVALID	= 0x100,
	AM_SAMPLE_ENDOFSTREAM	= 0x200,
	AM_STREAM_MEDIA	= 0,
	AM_STREAM_CONTROL	= 1
    } ;
typedef struct tagAM_SAMPLE2_PROPERTIES
    {
    DWORD cbData;
    DWORD dwTypeSpecificFlags;
    DWORD dwSampleFlags;
    LONG lActual;
    REFERENCE_TIME tStart;
    REFERENCE_TIME tStop;
    DWORD dwStreamId;
    AM_MEDIA_TYPE *pMediaType;
    BYTE *pbBuffer;
    LONG cbBuffer;
    } 	AM_SAMPLE2_PROPERTIES;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0123_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0123_v0_0_s_ifspec;

#ifndef __IMediaSample2_INTERFACE_DEFINED__
#define __IMediaSample2_INTERFACE_DEFINED__

/* interface IMediaSample2 */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IMediaSample2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("36b73884-c2c8-11cf-8b46-00805f6cef60")
    IMediaSample2 : public IMediaSample
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [in] */ DWORD cbProperties,
            /* [size_is][out] */ BYTE *pbProperties) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProperties( 
            /* [in] */ DWORD cbProperties,
            /* [size_is][in] */ const BYTE *pbProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaSample2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaSample2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaSample2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaSample2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPointer )( 
            IMediaSample2 * This,
            /* [out] */ BYTE **ppBuffer);
        
        long ( STDMETHODCALLTYPE *GetSize )( 
            IMediaSample2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTime )( 
            IMediaSample2 * This,
            /* [out] */ REFERENCE_TIME *pTimeStart,
            /* [out] */ REFERENCE_TIME *pTimeEnd);
        
        HRESULT ( STDMETHODCALLTYPE *SetTime )( 
            IMediaSample2 * This,
            /* [in] */ REFERENCE_TIME *pTimeStart,
            /* [in] */ REFERENCE_TIME *pTimeEnd);
        
        HRESULT ( STDMETHODCALLTYPE *IsSyncPoint )( 
            IMediaSample2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetSyncPoint )( 
            IMediaSample2 * This,
            BOOL bIsSyncPoint);
        
        HRESULT ( STDMETHODCALLTYPE *IsPreroll )( 
            IMediaSample2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetPreroll )( 
            IMediaSample2 * This,
            BOOL bIsPreroll);
        
        long ( STDMETHODCALLTYPE *GetActualDataLength )( 
            IMediaSample2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetActualDataLength )( 
            IMediaSample2 * This,
            long __MIDL_0010);
        
        HRESULT ( STDMETHODCALLTYPE *GetMediaType )( 
            IMediaSample2 * This,
            AM_MEDIA_TYPE **ppMediaType);
        
        HRESULT ( STDMETHODCALLTYPE *SetMediaType )( 
            IMediaSample2 * This,
            AM_MEDIA_TYPE *pMediaType);
        
        HRESULT ( STDMETHODCALLTYPE *IsDiscontinuity )( 
            IMediaSample2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetDiscontinuity )( 
            IMediaSample2 * This,
            BOOL bDiscontinuity);
        
        HRESULT ( STDMETHODCALLTYPE *GetMediaTime )( 
            IMediaSample2 * This,
            /* [out] */ LONGLONG *pTimeStart,
            /* [out] */ LONGLONG *pTimeEnd);
        
        HRESULT ( STDMETHODCALLTYPE *SetMediaTime )( 
            IMediaSample2 * This,
            /* [in] */ LONGLONG *pTimeStart,
            /* [in] */ LONGLONG *pTimeEnd);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            IMediaSample2 * This,
            /* [in] */ DWORD cbProperties,
            /* [size_is][out] */ BYTE *pbProperties);
        
        HRESULT ( STDMETHODCALLTYPE *SetProperties )( 
            IMediaSample2 * This,
            /* [in] */ DWORD cbProperties,
            /* [size_is][in] */ const BYTE *pbProperties);
        
        END_INTERFACE
    } IMediaSample2Vtbl;

    interface IMediaSample2
    {
        CONST_VTBL struct IMediaSample2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaSample2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMediaSample2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMediaSample2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMediaSample2_GetPointer(This,ppBuffer)	\
    (This)->lpVtbl -> GetPointer(This,ppBuffer)

#define IMediaSample2_GetSize(This)	\
    (This)->lpVtbl -> GetSize(This)

#define IMediaSample2_GetTime(This,pTimeStart,pTimeEnd)	\
    (This)->lpVtbl -> GetTime(This,pTimeStart,pTimeEnd)

#define IMediaSample2_SetTime(This,pTimeStart,pTimeEnd)	\
    (This)->lpVtbl -> SetTime(This,pTimeStart,pTimeEnd)

#define IMediaSample2_IsSyncPoint(This)	\
    (This)->lpVtbl -> IsSyncPoint(This)

#define IMediaSample2_SetSyncPoint(This,bIsSyncPoint)	\
    (This)->lpVtbl -> SetSyncPoint(This,bIsSyncPoint)

#define IMediaSample2_IsPreroll(This)	\
    (This)->lpVtbl -> IsPreroll(This)

#define IMediaSample2_SetPreroll(This,bIsPreroll)	\
    (This)->lpVtbl -> SetPreroll(This,bIsPreroll)

#define IMediaSample2_GetActualDataLength(This)	\
    (This)->lpVtbl -> GetActualDataLength(This)

#define IMediaSample2_SetActualDataLength(This,__MIDL_0010)	\
    (This)->lpVtbl -> SetActualDataLength(This,__MIDL_0010)

#define IMediaSample2_GetMediaType(This,ppMediaType)	\
    (This)->lpVtbl -> GetMediaType(This,ppMediaType)

#define IMediaSample2_SetMediaType(This,pMediaType)	\
    (This)->lpVtbl -> SetMediaType(This,pMediaType)

#define IMediaSample2_IsDiscontinuity(This)	\
    (This)->lpVtbl -> IsDiscontinuity(This)

#define IMediaSample2_SetDiscontinuity(This,bDiscontinuity)	\
    (This)->lpVtbl -> SetDiscontinuity(This,bDiscontinuity)

#define IMediaSample2_GetMediaTime(This,pTimeStart,pTimeEnd)	\
    (This)->lpVtbl -> GetMediaTime(This,pTimeStart,pTimeEnd)

#define IMediaSample2_SetMediaTime(This,pTimeStart,pTimeEnd)	\
    (This)->lpVtbl -> SetMediaTime(This,pTimeStart,pTimeEnd)


#define IMediaSample2_GetProperties(This,cbProperties,pbProperties)	\
    (This)->lpVtbl -> GetProperties(This,cbProperties,pbProperties)

#define IMediaSample2_SetProperties(This,cbProperties,pbProperties)	\
    (This)->lpVtbl -> SetProperties(This,cbProperties,pbProperties)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMediaSample2_GetProperties_Proxy( 
    IMediaSample2 * This,
    /* [in] */ DWORD cbProperties,
    /* [size_is][out] */ BYTE *pbProperties);


void __RPC_STUB IMediaSample2_GetProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaSample2_SetProperties_Proxy( 
    IMediaSample2 * This,
    /* [in] */ DWORD cbProperties,
    /* [size_is][in] */ const BYTE *pbProperties);


void __RPC_STUB IMediaSample2_SetProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMediaSample2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0124 */
/* [local] */ 

typedef IMediaSample2 *PMEDIASAMPLE2;

#define AM_GBF_PREVFRAMESKIPPED 1
#define AM_GBF_NOTASYNCPOINT 2
#define AM_GBF_NOWAIT 4
#define AM_GBF_NODDSURFACELOCK 8


extern RPC_IF_HANDLE __MIDL_itf_strmif_0124_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0124_v0_0_s_ifspec;

#ifndef __IMemAllocator_INTERFACE_DEFINED__
#define __IMemAllocator_INTERFACE_DEFINED__

/* interface IMemAllocator */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IMemAllocator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a8689c-0ad4-11ce-b03a-0020af0ba770")
    IMemAllocator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetProperties( 
            /* [in] */ ALLOCATOR_PROPERTIES *pRequest,
            /* [out] */ ALLOCATOR_PROPERTIES *pActual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ ALLOCATOR_PROPERTIES *pProps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Commit( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Decommit( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBuffer( 
            /* [out] */ IMediaSample **ppBuffer,
            /* [in] */ REFERENCE_TIME *pStartTime,
            /* [in] */ REFERENCE_TIME *pEndTime,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseBuffer( 
            /* [in] */ IMediaSample *pBuffer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMemAllocatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMemAllocator * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMemAllocator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMemAllocator * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetProperties )( 
            IMemAllocator * This,
            /* [in] */ ALLOCATOR_PROPERTIES *pRequest,
            /* [out] */ ALLOCATOR_PROPERTIES *pActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            IMemAllocator * This,
            /* [out] */ ALLOCATOR_PROPERTIES *pProps);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            IMemAllocator * This);
        
        HRESULT ( STDMETHODCALLTYPE *Decommit )( 
            IMemAllocator * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetBuffer )( 
            IMemAllocator * This,
            /* [out] */ IMediaSample **ppBuffer,
            /* [in] */ REFERENCE_TIME *pStartTime,
            /* [in] */ REFERENCE_TIME *pEndTime,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *ReleaseBuffer )( 
            IMemAllocator * This,
            /* [in] */ IMediaSample *pBuffer);
        
        END_INTERFACE
    } IMemAllocatorVtbl;

    interface IMemAllocator
    {
        CONST_VTBL struct IMemAllocatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMemAllocator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMemAllocator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMemAllocator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMemAllocator_SetProperties(This,pRequest,pActual)	\
    (This)->lpVtbl -> SetProperties(This,pRequest,pActual)

#define IMemAllocator_GetProperties(This,pProps)	\
    (This)->lpVtbl -> GetProperties(This,pProps)

#define IMemAllocator_Commit(This)	\
    (This)->lpVtbl -> Commit(This)

#define IMemAllocator_Decommit(This)	\
    (This)->lpVtbl -> Decommit(This)

#define IMemAllocator_GetBuffer(This,ppBuffer,pStartTime,pEndTime,dwFlags)	\
    (This)->lpVtbl -> GetBuffer(This,ppBuffer,pStartTime,pEndTime,dwFlags)

#define IMemAllocator_ReleaseBuffer(This,pBuffer)	\
    (This)->lpVtbl -> ReleaseBuffer(This,pBuffer)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMemAllocator_SetProperties_Proxy( 
    IMemAllocator * This,
    /* [in] */ ALLOCATOR_PROPERTIES *pRequest,
    /* [out] */ ALLOCATOR_PROPERTIES *pActual);


void __RPC_STUB IMemAllocator_SetProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMemAllocator_GetProperties_Proxy( 
    IMemAllocator * This,
    /* [out] */ ALLOCATOR_PROPERTIES *pProps);


void __RPC_STUB IMemAllocator_GetProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMemAllocator_Commit_Proxy( 
    IMemAllocator * This);


void __RPC_STUB IMemAllocator_Commit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMemAllocator_Decommit_Proxy( 
    IMemAllocator * This);


void __RPC_STUB IMemAllocator_Decommit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMemAllocator_GetBuffer_Proxy( 
    IMemAllocator * This,
    /* [out] */ IMediaSample **ppBuffer,
    /* [in] */ REFERENCE_TIME *pStartTime,
    /* [in] */ REFERENCE_TIME *pEndTime,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IMemAllocator_GetBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMemAllocator_ReleaseBuffer_Proxy( 
    IMemAllocator * This,
    /* [in] */ IMediaSample *pBuffer);


void __RPC_STUB IMemAllocator_ReleaseBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMemAllocator_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0125 */
/* [local] */ 

typedef IMemAllocator *PMEMALLOCATOR;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0125_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0125_v0_0_s_ifspec;

#ifndef __IMemAllocatorCallbackTemp_INTERFACE_DEFINED__
#define __IMemAllocatorCallbackTemp_INTERFACE_DEFINED__

/* interface IMemAllocatorCallbackTemp */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IMemAllocatorCallbackTemp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("379a0cf0-c1de-11d2-abf5-00a0c905f375")
    IMemAllocatorCallbackTemp : public IMemAllocator
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetNotify( 
            /* [in] */ IMemAllocatorNotifyCallbackTemp *pNotify) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFreeCount( 
            /* [out] */ LONG *plBuffersFree) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMemAllocatorCallbackTempVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMemAllocatorCallbackTemp * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMemAllocatorCallbackTemp * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMemAllocatorCallbackTemp * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetProperties )( 
            IMemAllocatorCallbackTemp * This,
            /* [in] */ ALLOCATOR_PROPERTIES *pRequest,
            /* [out] */ ALLOCATOR_PROPERTIES *pActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            IMemAllocatorCallbackTemp * This,
            /* [out] */ ALLOCATOR_PROPERTIES *pProps);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            IMemAllocatorCallbackTemp * This);
        
        HRESULT ( STDMETHODCALLTYPE *Decommit )( 
            IMemAllocatorCallbackTemp * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetBuffer )( 
            IMemAllocatorCallbackTemp * This,
            /* [out] */ IMediaSample **ppBuffer,
            /* [in] */ REFERENCE_TIME *pStartTime,
            /* [in] */ REFERENCE_TIME *pEndTime,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *ReleaseBuffer )( 
            IMemAllocatorCallbackTemp * This,
            /* [in] */ IMediaSample *pBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *SetNotify )( 
            IMemAllocatorCallbackTemp * This,
            /* [in] */ IMemAllocatorNotifyCallbackTemp *pNotify);
        
        HRESULT ( STDMETHODCALLTYPE *GetFreeCount )( 
            IMemAllocatorCallbackTemp * This,
            /* [out] */ LONG *plBuffersFree);
        
        END_INTERFACE
    } IMemAllocatorCallbackTempVtbl;

    interface IMemAllocatorCallbackTemp
    {
        CONST_VTBL struct IMemAllocatorCallbackTempVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMemAllocatorCallbackTemp_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMemAllocatorCallbackTemp_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMemAllocatorCallbackTemp_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMemAllocatorCallbackTemp_SetProperties(This,pRequest,pActual)	\
    (This)->lpVtbl -> SetProperties(This,pRequest,pActual)

#define IMemAllocatorCallbackTemp_GetProperties(This,pProps)	\
    (This)->lpVtbl -> GetProperties(This,pProps)

#define IMemAllocatorCallbackTemp_Commit(This)	\
    (This)->lpVtbl -> Commit(This)

#define IMemAllocatorCallbackTemp_Decommit(This)	\
    (This)->lpVtbl -> Decommit(This)

#define IMemAllocatorCallbackTemp_GetBuffer(This,ppBuffer,pStartTime,pEndTime,dwFlags)	\
    (This)->lpVtbl -> GetBuffer(This,ppBuffer,pStartTime,pEndTime,dwFlags)

#define IMemAllocatorCallbackTemp_ReleaseBuffer(This,pBuffer)	\
    (This)->lpVtbl -> ReleaseBuffer(This,pBuffer)


#define IMemAllocatorCallbackTemp_SetNotify(This,pNotify)	\
    (This)->lpVtbl -> SetNotify(This,pNotify)

#define IMemAllocatorCallbackTemp_GetFreeCount(This,plBuffersFree)	\
    (This)->lpVtbl -> GetFreeCount(This,plBuffersFree)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMemAllocatorCallbackTemp_SetNotify_Proxy( 
    IMemAllocatorCallbackTemp * This,
    /* [in] */ IMemAllocatorNotifyCallbackTemp *pNotify);


void __RPC_STUB IMemAllocatorCallbackTemp_SetNotify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMemAllocatorCallbackTemp_GetFreeCount_Proxy( 
    IMemAllocatorCallbackTemp * This,
    /* [out] */ LONG *plBuffersFree);


void __RPC_STUB IMemAllocatorCallbackTemp_GetFreeCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMemAllocatorCallbackTemp_INTERFACE_DEFINED__ */


#ifndef __IMemAllocatorNotifyCallbackTemp_INTERFACE_DEFINED__
#define __IMemAllocatorNotifyCallbackTemp_INTERFACE_DEFINED__

/* interface IMemAllocatorNotifyCallbackTemp */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IMemAllocatorNotifyCallbackTemp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("92980b30-c1de-11d2-abf5-00a0c905f375")
    IMemAllocatorNotifyCallbackTemp : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE NotifyRelease( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMemAllocatorNotifyCallbackTempVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMemAllocatorNotifyCallbackTemp * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMemAllocatorNotifyCallbackTemp * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMemAllocatorNotifyCallbackTemp * This);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyRelease )( 
            IMemAllocatorNotifyCallbackTemp * This);
        
        END_INTERFACE
    } IMemAllocatorNotifyCallbackTempVtbl;

    interface IMemAllocatorNotifyCallbackTemp
    {
        CONST_VTBL struct IMemAllocatorNotifyCallbackTempVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMemAllocatorNotifyCallbackTemp_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMemAllocatorNotifyCallbackTemp_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMemAllocatorNotifyCallbackTemp_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMemAllocatorNotifyCallbackTemp_NotifyRelease(This)	\
    (This)->lpVtbl -> NotifyRelease(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMemAllocatorNotifyCallbackTemp_NotifyRelease_Proxy( 
    IMemAllocatorNotifyCallbackTemp * This);


void __RPC_STUB IMemAllocatorNotifyCallbackTemp_NotifyRelease_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMemAllocatorNotifyCallbackTemp_INTERFACE_DEFINED__ */


#ifndef __IMemInputPin_INTERFACE_DEFINED__
#define __IMemInputPin_INTERFACE_DEFINED__

/* interface IMemInputPin */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IMemInputPin;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a8689d-0ad4-11ce-b03a-0020af0ba770")
    IMemInputPin : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAllocator( 
            /* [out] */ IMemAllocator **ppAllocator) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyAllocator( 
            /* [in] */ IMemAllocator *pAllocator,
            /* [in] */ BOOL bReadOnly) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAllocatorRequirements( 
            /* [out] */ ALLOCATOR_PROPERTIES *pProps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Receive( 
            /* [in] */ IMediaSample *pSample) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReceiveMultiple( 
            /* [size_is][in] */ IMediaSample **pSamples,
            /* [in] */ long nSamples,
            /* [out] */ long *nSamplesProcessed) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReceiveCanBlock( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMemInputPinVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMemInputPin * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMemInputPin * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMemInputPin * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocator )( 
            IMemInputPin * This,
            /* [out] */ IMemAllocator **ppAllocator);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyAllocator )( 
            IMemInputPin * This,
            /* [in] */ IMemAllocator *pAllocator,
            /* [in] */ BOOL bReadOnly);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocatorRequirements )( 
            IMemInputPin * This,
            /* [out] */ ALLOCATOR_PROPERTIES *pProps);
        
        HRESULT ( STDMETHODCALLTYPE *Receive )( 
            IMemInputPin * This,
            /* [in] */ IMediaSample *pSample);
        
        HRESULT ( STDMETHODCALLTYPE *ReceiveMultiple )( 
            IMemInputPin * This,
            /* [size_is][in] */ IMediaSample **pSamples,
            /* [in] */ long nSamples,
            /* [out] */ long *nSamplesProcessed);
        
        HRESULT ( STDMETHODCALLTYPE *ReceiveCanBlock )( 
            IMemInputPin * This);
        
        END_INTERFACE
    } IMemInputPinVtbl;

    interface IMemInputPin
    {
        CONST_VTBL struct IMemInputPinVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMemInputPin_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMemInputPin_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMemInputPin_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMemInputPin_GetAllocator(This,ppAllocator)	\
    (This)->lpVtbl -> GetAllocator(This,ppAllocator)

#define IMemInputPin_NotifyAllocator(This,pAllocator,bReadOnly)	\
    (This)->lpVtbl -> NotifyAllocator(This,pAllocator,bReadOnly)

#define IMemInputPin_GetAllocatorRequirements(This,pProps)	\
    (This)->lpVtbl -> GetAllocatorRequirements(This,pProps)

#define IMemInputPin_Receive(This,pSample)	\
    (This)->lpVtbl -> Receive(This,pSample)

#define IMemInputPin_ReceiveMultiple(This,pSamples,nSamples,nSamplesProcessed)	\
    (This)->lpVtbl -> ReceiveMultiple(This,pSamples,nSamples,nSamplesProcessed)

#define IMemInputPin_ReceiveCanBlock(This)	\
    (This)->lpVtbl -> ReceiveCanBlock(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMemInputPin_GetAllocator_Proxy( 
    IMemInputPin * This,
    /* [out] */ IMemAllocator **ppAllocator);


void __RPC_STUB IMemInputPin_GetAllocator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMemInputPin_NotifyAllocator_Proxy( 
    IMemInputPin * This,
    /* [in] */ IMemAllocator *pAllocator,
    /* [in] */ BOOL bReadOnly);


void __RPC_STUB IMemInputPin_NotifyAllocator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMemInputPin_GetAllocatorRequirements_Proxy( 
    IMemInputPin * This,
    /* [out] */ ALLOCATOR_PROPERTIES *pProps);


void __RPC_STUB IMemInputPin_GetAllocatorRequirements_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMemInputPin_Receive_Proxy( 
    IMemInputPin * This,
    /* [in] */ IMediaSample *pSample);


void __RPC_STUB IMemInputPin_Receive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMemInputPin_ReceiveMultiple_Proxy( 
    IMemInputPin * This,
    /* [size_is][in] */ IMediaSample **pSamples,
    /* [in] */ long nSamples,
    /* [out] */ long *nSamplesProcessed);


void __RPC_STUB IMemInputPin_ReceiveMultiple_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMemInputPin_ReceiveCanBlock_Proxy( 
    IMemInputPin * This);


void __RPC_STUB IMemInputPin_ReceiveCanBlock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMemInputPin_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0128 */
/* [local] */ 

typedef IMemInputPin *PMEMINPUTPIN;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0128_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0128_v0_0_s_ifspec;

#ifndef __IAMovieSetup_INTERFACE_DEFINED__
#define __IAMovieSetup_INTERFACE_DEFINED__

/* interface IAMovieSetup */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMovieSetup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a3d8cec0-7e5a-11cf-bbc5-00805f6cef20")
    IAMovieSetup : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Register( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unregister( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMovieSetupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMovieSetup * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMovieSetup * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMovieSetup * This);
        
        HRESULT ( STDMETHODCALLTYPE *Register )( 
            IAMovieSetup * This);
        
        HRESULT ( STDMETHODCALLTYPE *Unregister )( 
            IAMovieSetup * This);
        
        END_INTERFACE
    } IAMovieSetupVtbl;

    interface IAMovieSetup
    {
        CONST_VTBL struct IAMovieSetupVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMovieSetup_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMovieSetup_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMovieSetup_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMovieSetup_Register(This)	\
    (This)->lpVtbl -> Register(This)

#define IAMovieSetup_Unregister(This)	\
    (This)->lpVtbl -> Unregister(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAMovieSetup_Register_Proxy( 
    IAMovieSetup * This);


void __RPC_STUB IAMovieSetup_Register_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMovieSetup_Unregister_Proxy( 
    IAMovieSetup * This);


void __RPC_STUB IAMovieSetup_Unregister_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMovieSetup_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0129 */
/* [local] */ 

typedef IAMovieSetup *PAMOVIESETUP;

typedef 
enum AM_SEEKING_SeekingFlags
    {	AM_SEEKING_NoPositioning	= 0,
	AM_SEEKING_AbsolutePositioning	= 0x1,
	AM_SEEKING_RelativePositioning	= 0x2,
	AM_SEEKING_IncrementalPositioning	= 0x3,
	AM_SEEKING_PositioningBitsMask	= 0x3,
	AM_SEEKING_SeekToKeyFrame	= 0x4,
	AM_SEEKING_ReturnTime	= 0x8,
	AM_SEEKING_Segment	= 0x10,
	AM_SEEKING_NoFlush	= 0x20
    } 	AM_SEEKING_SEEKING_FLAGS;

typedef 
enum AM_SEEKING_SeekingCapabilities
    {	AM_SEEKING_CanSeekAbsolute	= 0x1,
	AM_SEEKING_CanSeekForwards	= 0x2,
	AM_SEEKING_CanSeekBackwards	= 0x4,
	AM_SEEKING_CanGetCurrentPos	= 0x8,
	AM_SEEKING_CanGetStopPos	= 0x10,
	AM_SEEKING_CanGetDuration	= 0x20,
	AM_SEEKING_CanPlayBackwards	= 0x40,
	AM_SEEKING_CanDoSegments	= 0x80,
	AM_SEEKING_Source	= 0x100
    } 	AM_SEEKING_SEEKING_CAPABILITIES;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0129_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0129_v0_0_s_ifspec;

#ifndef __IMediaSeeking_INTERFACE_DEFINED__
#define __IMediaSeeking_INTERFACE_DEFINED__

/* interface IMediaSeeking */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IMediaSeeking;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("36b73880-c2c8-11cf-8b46-00805f6cef60")
    IMediaSeeking : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCapabilities( 
            /* [out] */ DWORD *pCapabilities) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CheckCapabilities( 
            /* [out][in] */ DWORD *pCapabilities) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsFormatSupported( 
            /* [in] */ const GUID *pFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryPreferredFormat( 
            /* [out] */ GUID *pFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTimeFormat( 
            /* [out] */ GUID *pFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsUsingTimeFormat( 
            /* [in] */ const GUID *pFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTimeFormat( 
            /* [in] */ const GUID *pFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDuration( 
            /* [out] */ LONGLONG *pDuration) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStopPosition( 
            /* [out] */ LONGLONG *pStop) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentPosition( 
            /* [out] */ LONGLONG *pCurrent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConvertTimeFormat( 
            /* [out] */ LONGLONG *pTarget,
            /* [in] */ const GUID *pTargetFormat,
            /* [in] */ LONGLONG Source,
            /* [in] */ const GUID *pSourceFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPositions( 
            /* [out][in] */ LONGLONG *pCurrent,
            /* [in] */ DWORD dwCurrentFlags,
            /* [out][in] */ LONGLONG *pStop,
            /* [in] */ DWORD dwStopFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPositions( 
            /* [out] */ LONGLONG *pCurrent,
            /* [out] */ LONGLONG *pStop) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAvailable( 
            /* [out] */ LONGLONG *pEarliest,
            /* [out] */ LONGLONG *pLatest) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRate( 
            /* [in] */ double dRate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRate( 
            /* [out] */ double *pdRate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPreroll( 
            /* [out] */ LONGLONG *pllPreroll) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaSeekingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaSeeking * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaSeeking * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaSeeking * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCapabilities )( 
            IMediaSeeking * This,
            /* [out] */ DWORD *pCapabilities);
        
        HRESULT ( STDMETHODCALLTYPE *CheckCapabilities )( 
            IMediaSeeking * This,
            /* [out][in] */ DWORD *pCapabilities);
        
        HRESULT ( STDMETHODCALLTYPE *IsFormatSupported )( 
            IMediaSeeking * This,
            /* [in] */ const GUID *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE *QueryPreferredFormat )( 
            IMediaSeeking * This,
            /* [out] */ GUID *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE *GetTimeFormat )( 
            IMediaSeeking * This,
            /* [out] */ GUID *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE *IsUsingTimeFormat )( 
            IMediaSeeking * This,
            /* [in] */ const GUID *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE *SetTimeFormat )( 
            IMediaSeeking * This,
            /* [in] */ const GUID *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE *GetDuration )( 
            IMediaSeeking * This,
            /* [out] */ LONGLONG *pDuration);
        
        HRESULT ( STDMETHODCALLTYPE *GetStopPosition )( 
            IMediaSeeking * This,
            /* [out] */ LONGLONG *pStop);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentPosition )( 
            IMediaSeeking * This,
            /* [out] */ LONGLONG *pCurrent);
        
        HRESULT ( STDMETHODCALLTYPE *ConvertTimeFormat )( 
            IMediaSeeking * This,
            /* [out] */ LONGLONG *pTarget,
            /* [in] */ const GUID *pTargetFormat,
            /* [in] */ LONGLONG Source,
            /* [in] */ const GUID *pSourceFormat);
        
        HRESULT ( STDMETHODCALLTYPE *SetPositions )( 
            IMediaSeeking * This,
            /* [out][in] */ LONGLONG *pCurrent,
            /* [in] */ DWORD dwCurrentFlags,
            /* [out][in] */ LONGLONG *pStop,
            /* [in] */ DWORD dwStopFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetPositions )( 
            IMediaSeeking * This,
            /* [out] */ LONGLONG *pCurrent,
            /* [out] */ LONGLONG *pStop);
        
        HRESULT ( STDMETHODCALLTYPE *GetAvailable )( 
            IMediaSeeking * This,
            /* [out] */ LONGLONG *pEarliest,
            /* [out] */ LONGLONG *pLatest);
        
        HRESULT ( STDMETHODCALLTYPE *SetRate )( 
            IMediaSeeking * This,
            /* [in] */ double dRate);
        
        HRESULT ( STDMETHODCALLTYPE *GetRate )( 
            IMediaSeeking * This,
            /* [out] */ double *pdRate);
        
        HRESULT ( STDMETHODCALLTYPE *GetPreroll )( 
            IMediaSeeking * This,
            /* [out] */ LONGLONG *pllPreroll);
        
        END_INTERFACE
    } IMediaSeekingVtbl;

    interface IMediaSeeking
    {
        CONST_VTBL struct IMediaSeekingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaSeeking_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMediaSeeking_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMediaSeeking_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMediaSeeking_GetCapabilities(This,pCapabilities)	\
    (This)->lpVtbl -> GetCapabilities(This,pCapabilities)

#define IMediaSeeking_CheckCapabilities(This,pCapabilities)	\
    (This)->lpVtbl -> CheckCapabilities(This,pCapabilities)

#define IMediaSeeking_IsFormatSupported(This,pFormat)	\
    (This)->lpVtbl -> IsFormatSupported(This,pFormat)

#define IMediaSeeking_QueryPreferredFormat(This,pFormat)	\
    (This)->lpVtbl -> QueryPreferredFormat(This,pFormat)

#define IMediaSeeking_GetTimeFormat(This,pFormat)	\
    (This)->lpVtbl -> GetTimeFormat(This,pFormat)

#define IMediaSeeking_IsUsingTimeFormat(This,pFormat)	\
    (This)->lpVtbl -> IsUsingTimeFormat(This,pFormat)

#define IMediaSeeking_SetTimeFormat(This,pFormat)	\
    (This)->lpVtbl -> SetTimeFormat(This,pFormat)

#define IMediaSeeking_GetDuration(This,pDuration)	\
    (This)->lpVtbl -> GetDuration(This,pDuration)

#define IMediaSeeking_GetStopPosition(This,pStop)	\
    (This)->lpVtbl -> GetStopPosition(This,pStop)

#define IMediaSeeking_GetCurrentPosition(This,pCurrent)	\
    (This)->lpVtbl -> GetCurrentPosition(This,pCurrent)

#define IMediaSeeking_ConvertTimeFormat(This,pTarget,pTargetFormat,Source,pSourceFormat)	\
    (This)->lpVtbl -> ConvertTimeFormat(This,pTarget,pTargetFormat,Source,pSourceFormat)

#define IMediaSeeking_SetPositions(This,pCurrent,dwCurrentFlags,pStop,dwStopFlags)	\
    (This)->lpVtbl -> SetPositions(This,pCurrent,dwCurrentFlags,pStop,dwStopFlags)

#define IMediaSeeking_GetPositions(This,pCurrent,pStop)	\
    (This)->lpVtbl -> GetPositions(This,pCurrent,pStop)

#define IMediaSeeking_GetAvailable(This,pEarliest,pLatest)	\
    (This)->lpVtbl -> GetAvailable(This,pEarliest,pLatest)

#define IMediaSeeking_SetRate(This,dRate)	\
    (This)->lpVtbl -> SetRate(This,dRate)

#define IMediaSeeking_GetRate(This,pdRate)	\
    (This)->lpVtbl -> GetRate(This,pdRate)

#define IMediaSeeking_GetPreroll(This,pllPreroll)	\
    (This)->lpVtbl -> GetPreroll(This,pllPreroll)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMediaSeeking_GetCapabilities_Proxy( 
    IMediaSeeking * This,
    /* [out] */ DWORD *pCapabilities);


void __RPC_STUB IMediaSeeking_GetCapabilities_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaSeeking_CheckCapabilities_Proxy( 
    IMediaSeeking * This,
    /* [out][in] */ DWORD *pCapabilities);


void __RPC_STUB IMediaSeeking_CheckCapabilities_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaSeeking_IsFormatSupported_Proxy( 
    IMediaSeeking * This,
    /* [in] */ const GUID *pFormat);


void __RPC_STUB IMediaSeeking_IsFormatSupported_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaSeeking_QueryPreferredFormat_Proxy( 
    IMediaSeeking * This,
    /* [out] */ GUID *pFormat);


void __RPC_STUB IMediaSeeking_QueryPreferredFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaSeeking_GetTimeFormat_Proxy( 
    IMediaSeeking * This,
    /* [out] */ GUID *pFormat);


void __RPC_STUB IMediaSeeking_GetTimeFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaSeeking_IsUsingTimeFormat_Proxy( 
    IMediaSeeking * This,
    /* [in] */ const GUID *pFormat);


void __RPC_STUB IMediaSeeking_IsUsingTimeFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaSeeking_SetTimeFormat_Proxy( 
    IMediaSeeking * This,
    /* [in] */ const GUID *pFormat);


void __RPC_STUB IMediaSeeking_SetTimeFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaSeeking_GetDuration_Proxy( 
    IMediaSeeking * This,
    /* [out] */ LONGLONG *pDuration);


void __RPC_STUB IMediaSeeking_GetDuration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaSeeking_GetStopPosition_Proxy( 
    IMediaSeeking * This,
    /* [out] */ LONGLONG *pStop);


void __RPC_STUB IMediaSeeking_GetStopPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaSeeking_GetCurrentPosition_Proxy( 
    IMediaSeeking * This,
    /* [out] */ LONGLONG *pCurrent);


void __RPC_STUB IMediaSeeking_GetCurrentPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaSeeking_ConvertTimeFormat_Proxy( 
    IMediaSeeking * This,
    /* [out] */ LONGLONG *pTarget,
    /* [in] */ const GUID *pTargetFormat,
    /* [in] */ LONGLONG Source,
    /* [in] */ const GUID *pSourceFormat);


void __RPC_STUB IMediaSeeking_ConvertTimeFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaSeeking_SetPositions_Proxy( 
    IMediaSeeking * This,
    /* [out][in] */ LONGLONG *pCurrent,
    /* [in] */ DWORD dwCurrentFlags,
    /* [out][in] */ LONGLONG *pStop,
    /* [in] */ DWORD dwStopFlags);


void __RPC_STUB IMediaSeeking_SetPositions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaSeeking_GetPositions_Proxy( 
    IMediaSeeking * This,
    /* [out] */ LONGLONG *pCurrent,
    /* [out] */ LONGLONG *pStop);


void __RPC_STUB IMediaSeeking_GetPositions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaSeeking_GetAvailable_Proxy( 
    IMediaSeeking * This,
    /* [out] */ LONGLONG *pEarliest,
    /* [out] */ LONGLONG *pLatest);


void __RPC_STUB IMediaSeeking_GetAvailable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaSeeking_SetRate_Proxy( 
    IMediaSeeking * This,
    /* [in] */ double dRate);


void __RPC_STUB IMediaSeeking_SetRate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaSeeking_GetRate_Proxy( 
    IMediaSeeking * This,
    /* [out] */ double *pdRate);


void __RPC_STUB IMediaSeeking_GetRate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaSeeking_GetPreroll_Proxy( 
    IMediaSeeking * This,
    /* [out] */ LONGLONG *pllPreroll);


void __RPC_STUB IMediaSeeking_GetPreroll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMediaSeeking_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0130 */
/* [local] */ 

typedef IMediaSeeking *PMEDIASEEKING;

enum tagAM_MEDIAEVENT_FLAGS
{
    AM_MEDIAEVENT_NONOTIFY = 0x01
};
























































typedef /* [public][public] */ struct __MIDL___MIDL_itf_strmif_0130_0001
    {
    CLSID Clsid;
    LPWSTR Name;
    } 	REGFILTER;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0130_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0130_v0_0_s_ifspec;

#ifndef __IEnumRegFilters_INTERFACE_DEFINED__
#define __IEnumRegFilters_INTERFACE_DEFINED__

/* interface IEnumRegFilters */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumRegFilters;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868a4-0ad4-11ce-b03a-0020af0ba770")
    IEnumRegFilters : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG cFilters,
            /* [out] */ REGFILTER **apRegFilter,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cFilters) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumRegFilters **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumRegFiltersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumRegFilters * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumRegFilters * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumRegFilters * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumRegFilters * This,
            /* [in] */ ULONG cFilters,
            /* [out] */ REGFILTER **apRegFilter,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumRegFilters * This,
            /* [in] */ ULONG cFilters);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumRegFilters * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumRegFilters * This,
            /* [out] */ IEnumRegFilters **ppEnum);
        
        END_INTERFACE
    } IEnumRegFiltersVtbl;

    interface IEnumRegFilters
    {
        CONST_VTBL struct IEnumRegFiltersVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumRegFilters_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumRegFilters_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumRegFilters_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumRegFilters_Next(This,cFilters,apRegFilter,pcFetched)	\
    (This)->lpVtbl -> Next(This,cFilters,apRegFilter,pcFetched)

#define IEnumRegFilters_Skip(This,cFilters)	\
    (This)->lpVtbl -> Skip(This,cFilters)

#define IEnumRegFilters_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumRegFilters_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumRegFilters_Next_Proxy( 
    IEnumRegFilters * This,
    /* [in] */ ULONG cFilters,
    /* [out] */ REGFILTER **apRegFilter,
    /* [out] */ ULONG *pcFetched);


void __RPC_STUB IEnumRegFilters_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRegFilters_Skip_Proxy( 
    IEnumRegFilters * This,
    /* [in] */ ULONG cFilters);


void __RPC_STUB IEnumRegFilters_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRegFilters_Reset_Proxy( 
    IEnumRegFilters * This);


void __RPC_STUB IEnumRegFilters_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRegFilters_Clone_Proxy( 
    IEnumRegFilters * This,
    /* [out] */ IEnumRegFilters **ppEnum);


void __RPC_STUB IEnumRegFilters_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumRegFilters_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0132 */
/* [local] */ 

typedef IEnumRegFilters *PENUMREGFILTERS;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0132_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0132_v0_0_s_ifspec;

#ifndef __IFilterMapper_INTERFACE_DEFINED__
#define __IFilterMapper_INTERFACE_DEFINED__

/* interface IFilterMapper */
/* [unique][uuid][object] */ 


enum __MIDL_IFilterMapper_0001
    {	MERIT_PREFERRED	= 0x800000,
	MERIT_NORMAL	= 0x600000,
	MERIT_UNLIKELY	= 0x400000,
	MERIT_DO_NOT_USE	= 0x200000,
	MERIT_SW_COMPRESSOR	= 0x100000,
	MERIT_HW_COMPRESSOR	= 0x100050
    } ;

EXTERN_C const IID IID_IFilterMapper;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868a3-0ad4-11ce-b03a-0020af0ba770")
    IFilterMapper : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterFilter( 
            /* [in] */ CLSID clsid,
            /* [in] */ LPCWSTR Name,
            /* [in] */ DWORD dwMerit) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterFilterInstance( 
            /* [in] */ CLSID clsid,
            /* [in] */ LPCWSTR Name,
            /* [out] */ CLSID *MRId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterPin( 
            /* [in] */ CLSID Filter,
            /* [in] */ LPCWSTR Name,
            /* [in] */ BOOL bRendered,
            /* [in] */ BOOL bOutput,
            /* [in] */ BOOL bZero,
            /* [in] */ BOOL bMany,
            /* [in] */ CLSID ConnectsToFilter,
            /* [in] */ LPCWSTR ConnectsToPin) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterPinType( 
            /* [in] */ CLSID clsFilter,
            /* [in] */ LPCWSTR strName,
            /* [in] */ CLSID clsMajorType,
            /* [in] */ CLSID clsSubType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterFilter( 
            /* [in] */ CLSID Filter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterFilterInstance( 
            /* [in] */ CLSID MRId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterPin( 
            /* [in] */ CLSID Filter,
            /* [in] */ LPCWSTR Name) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumMatchingFilters( 
            /* [out] */ IEnumRegFilters **ppEnum,
            /* [in] */ DWORD dwMerit,
            /* [in] */ BOOL bInputNeeded,
            /* [in] */ CLSID clsInMaj,
            /* [in] */ CLSID clsInSub,
            /* [in] */ BOOL bRender,
            /* [in] */ BOOL bOututNeeded,
            /* [in] */ CLSID clsOutMaj,
            /* [in] */ CLSID clsOutSub) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFilterMapperVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFilterMapper * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFilterMapper * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFilterMapper * This);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterFilter )( 
            IFilterMapper * This,
            /* [in] */ CLSID clsid,
            /* [in] */ LPCWSTR Name,
            /* [in] */ DWORD dwMerit);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterFilterInstance )( 
            IFilterMapper * This,
            /* [in] */ CLSID clsid,
            /* [in] */ LPCWSTR Name,
            /* [out] */ CLSID *MRId);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterPin )( 
            IFilterMapper * This,
            /* [in] */ CLSID Filter,
            /* [in] */ LPCWSTR Name,
            /* [in] */ BOOL bRendered,
            /* [in] */ BOOL bOutput,
            /* [in] */ BOOL bZero,
            /* [in] */ BOOL bMany,
            /* [in] */ CLSID ConnectsToFilter,
            /* [in] */ LPCWSTR ConnectsToPin);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterPinType )( 
            IFilterMapper * This,
            /* [in] */ CLSID clsFilter,
            /* [in] */ LPCWSTR strName,
            /* [in] */ CLSID clsMajorType,
            /* [in] */ CLSID clsSubType);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterFilter )( 
            IFilterMapper * This,
            /* [in] */ CLSID Filter);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterFilterInstance )( 
            IFilterMapper * This,
            /* [in] */ CLSID MRId);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterPin )( 
            IFilterMapper * This,
            /* [in] */ CLSID Filter,
            /* [in] */ LPCWSTR Name);
        
        HRESULT ( STDMETHODCALLTYPE *EnumMatchingFilters )( 
            IFilterMapper * This,
            /* [out] */ IEnumRegFilters **ppEnum,
            /* [in] */ DWORD dwMerit,
            /* [in] */ BOOL bInputNeeded,
            /* [in] */ CLSID clsInMaj,
            /* [in] */ CLSID clsInSub,
            /* [in] */ BOOL bRender,
            /* [in] */ BOOL bOututNeeded,
            /* [in] */ CLSID clsOutMaj,
            /* [in] */ CLSID clsOutSub);
        
        END_INTERFACE
    } IFilterMapperVtbl;

    interface IFilterMapper
    {
        CONST_VTBL struct IFilterMapperVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFilterMapper_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFilterMapper_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFilterMapper_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFilterMapper_RegisterFilter(This,clsid,Name,dwMerit)	\
    (This)->lpVtbl -> RegisterFilter(This,clsid,Name,dwMerit)

#define IFilterMapper_RegisterFilterInstance(This,clsid,Name,MRId)	\
    (This)->lpVtbl -> RegisterFilterInstance(This,clsid,Name,MRId)

#define IFilterMapper_RegisterPin(This,Filter,Name,bRendered,bOutput,bZero,bMany,ConnectsToFilter,ConnectsToPin)	\
    (This)->lpVtbl -> RegisterPin(This,Filter,Name,bRendered,bOutput,bZero,bMany,ConnectsToFilter,ConnectsToPin)

#define IFilterMapper_RegisterPinType(This,clsFilter,strName,clsMajorType,clsSubType)	\
    (This)->lpVtbl -> RegisterPinType(This,clsFilter,strName,clsMajorType,clsSubType)

#define IFilterMapper_UnregisterFilter(This,Filter)	\
    (This)->lpVtbl -> UnregisterFilter(This,Filter)

#define IFilterMapper_UnregisterFilterInstance(This,MRId)	\
    (This)->lpVtbl -> UnregisterFilterInstance(This,MRId)

#define IFilterMapper_UnregisterPin(This,Filter,Name)	\
    (This)->lpVtbl -> UnregisterPin(This,Filter,Name)

#define IFilterMapper_EnumMatchingFilters(This,ppEnum,dwMerit,bInputNeeded,clsInMaj,clsInSub,bRender,bOututNeeded,clsOutMaj,clsOutSub)	\
    (This)->lpVtbl -> EnumMatchingFilters(This,ppEnum,dwMerit,bInputNeeded,clsInMaj,clsInSub,bRender,bOututNeeded,clsOutMaj,clsOutSub)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IFilterMapper_RegisterFilter_Proxy( 
    IFilterMapper * This,
    /* [in] */ CLSID clsid,
    /* [in] */ LPCWSTR Name,
    /* [in] */ DWORD dwMerit);


void __RPC_STUB IFilterMapper_RegisterFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IFilterMapper_RegisterFilterInstance_Proxy( 
    IFilterMapper * This,
    /* [in] */ CLSID clsid,
    /* [in] */ LPCWSTR Name,
    /* [out] */ CLSID *MRId);


void __RPC_STUB IFilterMapper_RegisterFilterInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IFilterMapper_RegisterPin_Proxy( 
    IFilterMapper * This,
    /* [in] */ CLSID Filter,
    /* [in] */ LPCWSTR Name,
    /* [in] */ BOOL bRendered,
    /* [in] */ BOOL bOutput,
    /* [in] */ BOOL bZero,
    /* [in] */ BOOL bMany,
    /* [in] */ CLSID ConnectsToFilter,
    /* [in] */ LPCWSTR ConnectsToPin);


void __RPC_STUB IFilterMapper_RegisterPin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IFilterMapper_RegisterPinType_Proxy( 
    IFilterMapper * This,
    /* [in] */ CLSID clsFilter,
    /* [in] */ LPCWSTR strName,
    /* [in] */ CLSID clsMajorType,
    /* [in] */ CLSID clsSubType);


void __RPC_STUB IFilterMapper_RegisterPinType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IFilterMapper_UnregisterFilter_Proxy( 
    IFilterMapper * This,
    /* [in] */ CLSID Filter);


void __RPC_STUB IFilterMapper_UnregisterFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IFilterMapper_UnregisterFilterInstance_Proxy( 
    IFilterMapper * This,
    /* [in] */ CLSID MRId);


void __RPC_STUB IFilterMapper_UnregisterFilterInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IFilterMapper_UnregisterPin_Proxy( 
    IFilterMapper * This,
    /* [in] */ CLSID Filter,
    /* [in] */ LPCWSTR Name);


void __RPC_STUB IFilterMapper_UnregisterPin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IFilterMapper_EnumMatchingFilters_Proxy( 
    IFilterMapper * This,
    /* [out] */ IEnumRegFilters **ppEnum,
    /* [in] */ DWORD dwMerit,
    /* [in] */ BOOL bInputNeeded,
    /* [in] */ CLSID clsInMaj,
    /* [in] */ CLSID clsInSub,
    /* [in] */ BOOL bRender,
    /* [in] */ BOOL bOututNeeded,
    /* [in] */ CLSID clsOutMaj,
    /* [in] */ CLSID clsOutSub);


void __RPC_STUB IFilterMapper_EnumMatchingFilters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFilterMapper_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0134 */
/* [local] */ 

typedef /* [public][public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_strmif_0134_0001
    {
    const CLSID *clsMajorType;
    const CLSID *clsMinorType;
    } 	REGPINTYPES;

typedef /* [public][public][public] */ struct __MIDL___MIDL_itf_strmif_0134_0002
    {
    LPWSTR strName;
    BOOL bRendered;
    BOOL bOutput;
    BOOL bZero;
    BOOL bMany;
    const CLSID *clsConnectsToFilter;
    const WCHAR *strConnectsToPin;
    UINT nMediaTypes;
    const REGPINTYPES *lpMediaType;
    } 	REGFILTERPINS;

typedef /* [public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_strmif_0134_0003
    {
    CLSID clsMedium;
    DWORD dw1;
    DWORD dw2;
    } 	REGPINMEDIUM;


enum __MIDL___MIDL_itf_strmif_0134_0004
    {	REG_PINFLAG_B_ZERO	= 0x1,
	REG_PINFLAG_B_RENDERER	= 0x2,
	REG_PINFLAG_B_MANY	= 0x4,
	REG_PINFLAG_B_OUTPUT	= 0x8
    } ;
typedef /* [public][public][public] */ struct __MIDL___MIDL_itf_strmif_0134_0005
    {
    DWORD dwFlags;
    UINT cInstances;
    UINT nMediaTypes;
    /* [size_is] */ const REGPINTYPES *lpMediaType;
    UINT nMediums;
    /* [size_is] */ const REGPINMEDIUM *lpMedium;
    const CLSID *clsPinCategory;
    } 	REGFILTERPINS2;

typedef /* [public][public] */ struct __MIDL___MIDL_itf_strmif_0134_0006
    {
    DWORD dwVersion;
    DWORD dwMerit;
    /* [switch_type][switch_is] */ union 
        {
        /* [case()] */ struct 
            {
            ULONG cPins;
            /* [size_is] */ const REGFILTERPINS *rgPins;
            } 	;
        /* [case()] */ struct 
            {
            ULONG cPins2;
            /* [size_is] */ const REGFILTERPINS2 *rgPins2;
            } 	;
        /* [default] */  /* Empty union arm */ 
        } 	;
    } 	REGFILTER2;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0134_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0134_v0_0_s_ifspec;

#ifndef __IFilterMapper2_INTERFACE_DEFINED__
#define __IFilterMapper2_INTERFACE_DEFINED__

/* interface IFilterMapper2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IFilterMapper2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b79bb0b0-33c1-11d1-abe1-00a0c905f375")
    IFilterMapper2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateCategory( 
            /* [in] */ REFCLSID clsidCategory,
            /* [in] */ DWORD dwCategoryMerit,
            /* [in] */ LPCWSTR Description) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterFilter( 
            /* [in] */ const CLSID *pclsidCategory,
            /* [in] */ const OLECHAR *szInstance,
            /* [in] */ REFCLSID Filter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterFilter( 
            /* [in] */ REFCLSID clsidFilter,
            /* [in] */ LPCWSTR Name,
            /* [out][in] */ IMoniker **ppMoniker,
            /* [in] */ const CLSID *pclsidCategory,
            /* [in] */ const OLECHAR *szInstance,
            /* [in] */ const REGFILTER2 *prf2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumMatchingFilters( 
            /* [out] */ IEnumMoniker **ppEnum,
            /* [in] */ DWORD dwFlags,
            /* [in] */ BOOL bExactMatch,
            /* [in] */ DWORD dwMerit,
            /* [in] */ BOOL bInputNeeded,
            /* [in] */ DWORD cInputTypes,
            /* [size_is] */ const GUID *pInputTypes,
            /* [in] */ const REGPINMEDIUM *pMedIn,
            /* [in] */ const CLSID *pPinCategoryIn,
            /* [in] */ BOOL bRender,
            /* [in] */ BOOL bOutputNeeded,
            /* [in] */ DWORD cOutputTypes,
            /* [size_is] */ const GUID *pOutputTypes,
            /* [in] */ const REGPINMEDIUM *pMedOut,
            /* [in] */ const CLSID *pPinCategoryOut) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFilterMapper2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFilterMapper2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFilterMapper2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFilterMapper2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateCategory )( 
            IFilterMapper2 * This,
            /* [in] */ REFCLSID clsidCategory,
            /* [in] */ DWORD dwCategoryMerit,
            /* [in] */ LPCWSTR Description);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterFilter )( 
            IFilterMapper2 * This,
            /* [in] */ const CLSID *pclsidCategory,
            /* [in] */ const OLECHAR *szInstance,
            /* [in] */ REFCLSID Filter);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterFilter )( 
            IFilterMapper2 * This,
            /* [in] */ REFCLSID clsidFilter,
            /* [in] */ LPCWSTR Name,
            /* [out][in] */ IMoniker **ppMoniker,
            /* [in] */ const CLSID *pclsidCategory,
            /* [in] */ const OLECHAR *szInstance,
            /* [in] */ const REGFILTER2 *prf2);
        
        HRESULT ( STDMETHODCALLTYPE *EnumMatchingFilters )( 
            IFilterMapper2 * This,
            /* [out] */ IEnumMoniker **ppEnum,
            /* [in] */ DWORD dwFlags,
            /* [in] */ BOOL bExactMatch,
            /* [in] */ DWORD dwMerit,
            /* [in] */ BOOL bInputNeeded,
            /* [in] */ DWORD cInputTypes,
            /* [size_is] */ const GUID *pInputTypes,
            /* [in] */ const REGPINMEDIUM *pMedIn,
            /* [in] */ const CLSID *pPinCategoryIn,
            /* [in] */ BOOL bRender,
            /* [in] */ BOOL bOutputNeeded,
            /* [in] */ DWORD cOutputTypes,
            /* [size_is] */ const GUID *pOutputTypes,
            /* [in] */ const REGPINMEDIUM *pMedOut,
            /* [in] */ const CLSID *pPinCategoryOut);
        
        END_INTERFACE
    } IFilterMapper2Vtbl;

    interface IFilterMapper2
    {
        CONST_VTBL struct IFilterMapper2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFilterMapper2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFilterMapper2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFilterMapper2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFilterMapper2_CreateCategory(This,clsidCategory,dwCategoryMerit,Description)	\
    (This)->lpVtbl -> CreateCategory(This,clsidCategory,dwCategoryMerit,Description)

#define IFilterMapper2_UnregisterFilter(This,pclsidCategory,szInstance,Filter)	\
    (This)->lpVtbl -> UnregisterFilter(This,pclsidCategory,szInstance,Filter)

#define IFilterMapper2_RegisterFilter(This,clsidFilter,Name,ppMoniker,pclsidCategory,szInstance,prf2)	\
    (This)->lpVtbl -> RegisterFilter(This,clsidFilter,Name,ppMoniker,pclsidCategory,szInstance,prf2)

#define IFilterMapper2_EnumMatchingFilters(This,ppEnum,dwFlags,bExactMatch,dwMerit,bInputNeeded,cInputTypes,pInputTypes,pMedIn,pPinCategoryIn,bRender,bOutputNeeded,cOutputTypes,pOutputTypes,pMedOut,pPinCategoryOut)	\
    (This)->lpVtbl -> EnumMatchingFilters(This,ppEnum,dwFlags,bExactMatch,dwMerit,bInputNeeded,cInputTypes,pInputTypes,pMedIn,pPinCategoryIn,bRender,bOutputNeeded,cOutputTypes,pOutputTypes,pMedOut,pPinCategoryOut)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IFilterMapper2_CreateCategory_Proxy( 
    IFilterMapper2 * This,
    /* [in] */ REFCLSID clsidCategory,
    /* [in] */ DWORD dwCategoryMerit,
    /* [in] */ LPCWSTR Description);


void __RPC_STUB IFilterMapper2_CreateCategory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IFilterMapper2_UnregisterFilter_Proxy( 
    IFilterMapper2 * This,
    /* [in] */ const CLSID *pclsidCategory,
    /* [in] */ const OLECHAR *szInstance,
    /* [in] */ REFCLSID Filter);


void __RPC_STUB IFilterMapper2_UnregisterFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IFilterMapper2_RegisterFilter_Proxy( 
    IFilterMapper2 * This,
    /* [in] */ REFCLSID clsidFilter,
    /* [in] */ LPCWSTR Name,
    /* [out][in] */ IMoniker **ppMoniker,
    /* [in] */ const CLSID *pclsidCategory,
    /* [in] */ const OLECHAR *szInstance,
    /* [in] */ const REGFILTER2 *prf2);


void __RPC_STUB IFilterMapper2_RegisterFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IFilterMapper2_EnumMatchingFilters_Proxy( 
    IFilterMapper2 * This,
    /* [out] */ IEnumMoniker **ppEnum,
    /* [in] */ DWORD dwFlags,
    /* [in] */ BOOL bExactMatch,
    /* [in] */ DWORD dwMerit,
    /* [in] */ BOOL bInputNeeded,
    /* [in] */ DWORD cInputTypes,
    /* [size_is] */ const GUID *pInputTypes,
    /* [in] */ const REGPINMEDIUM *pMedIn,
    /* [in] */ const CLSID *pPinCategoryIn,
    /* [in] */ BOOL bRender,
    /* [in] */ BOOL bOutputNeeded,
    /* [in] */ DWORD cOutputTypes,
    /* [size_is] */ const GUID *pOutputTypes,
    /* [in] */ const REGPINMEDIUM *pMedOut,
    /* [in] */ const CLSID *pPinCategoryOut);


void __RPC_STUB IFilterMapper2_EnumMatchingFilters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFilterMapper2_INTERFACE_DEFINED__ */


#ifndef __IFilterMapper3_INTERFACE_DEFINED__
#define __IFilterMapper3_INTERFACE_DEFINED__

/* interface IFilterMapper3 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IFilterMapper3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b79bb0b1-33c1-11d1-abe1-00a0c905f375")
    IFilterMapper3 : public IFilterMapper2
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetICreateDevEnum( 
            /* [out] */ ICreateDevEnum **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFilterMapper3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFilterMapper3 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFilterMapper3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFilterMapper3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateCategory )( 
            IFilterMapper3 * This,
            /* [in] */ REFCLSID clsidCategory,
            /* [in] */ DWORD dwCategoryMerit,
            /* [in] */ LPCWSTR Description);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterFilter )( 
            IFilterMapper3 * This,
            /* [in] */ const CLSID *pclsidCategory,
            /* [in] */ const OLECHAR *szInstance,
            /* [in] */ REFCLSID Filter);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterFilter )( 
            IFilterMapper3 * This,
            /* [in] */ REFCLSID clsidFilter,
            /* [in] */ LPCWSTR Name,
            /* [out][in] */ IMoniker **ppMoniker,
            /* [in] */ const CLSID *pclsidCategory,
            /* [in] */ const OLECHAR *szInstance,
            /* [in] */ const REGFILTER2 *prf2);
        
        HRESULT ( STDMETHODCALLTYPE *EnumMatchingFilters )( 
            IFilterMapper3 * This,
            /* [out] */ IEnumMoniker **ppEnum,
            /* [in] */ DWORD dwFlags,
            /* [in] */ BOOL bExactMatch,
            /* [in] */ DWORD dwMerit,
            /* [in] */ BOOL bInputNeeded,
            /* [in] */ DWORD cInputTypes,
            /* [size_is] */ const GUID *pInputTypes,
            /* [in] */ const REGPINMEDIUM *pMedIn,
            /* [in] */ const CLSID *pPinCategoryIn,
            /* [in] */ BOOL bRender,
            /* [in] */ BOOL bOutputNeeded,
            /* [in] */ DWORD cOutputTypes,
            /* [size_is] */ const GUID *pOutputTypes,
            /* [in] */ const REGPINMEDIUM *pMedOut,
            /* [in] */ const CLSID *pPinCategoryOut);
        
        HRESULT ( STDMETHODCALLTYPE *GetICreateDevEnum )( 
            IFilterMapper3 * This,
            /* [out] */ ICreateDevEnum **ppEnum);
        
        END_INTERFACE
    } IFilterMapper3Vtbl;

    interface IFilterMapper3
    {
        CONST_VTBL struct IFilterMapper3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFilterMapper3_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFilterMapper3_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFilterMapper3_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFilterMapper3_CreateCategory(This,clsidCategory,dwCategoryMerit,Description)	\
    (This)->lpVtbl -> CreateCategory(This,clsidCategory,dwCategoryMerit,Description)

#define IFilterMapper3_UnregisterFilter(This,pclsidCategory,szInstance,Filter)	\
    (This)->lpVtbl -> UnregisterFilter(This,pclsidCategory,szInstance,Filter)

#define IFilterMapper3_RegisterFilter(This,clsidFilter,Name,ppMoniker,pclsidCategory,szInstance,prf2)	\
    (This)->lpVtbl -> RegisterFilter(This,clsidFilter,Name,ppMoniker,pclsidCategory,szInstance,prf2)

#define IFilterMapper3_EnumMatchingFilters(This,ppEnum,dwFlags,bExactMatch,dwMerit,bInputNeeded,cInputTypes,pInputTypes,pMedIn,pPinCategoryIn,bRender,bOutputNeeded,cOutputTypes,pOutputTypes,pMedOut,pPinCategoryOut)	\
    (This)->lpVtbl -> EnumMatchingFilters(This,ppEnum,dwFlags,bExactMatch,dwMerit,bInputNeeded,cInputTypes,pInputTypes,pMedIn,pPinCategoryIn,bRender,bOutputNeeded,cOutputTypes,pOutputTypes,pMedOut,pPinCategoryOut)


#define IFilterMapper3_GetICreateDevEnum(This,ppEnum)	\
    (This)->lpVtbl -> GetICreateDevEnum(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IFilterMapper3_GetICreateDevEnum_Proxy( 
    IFilterMapper3 * This,
    /* [out] */ ICreateDevEnum **ppEnum);


void __RPC_STUB IFilterMapper3_GetICreateDevEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFilterMapper3_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0137 */
/* [local] */ 

typedef 
enum tagQualityMessageType
    {	Famine	= 0,
	Flood	= Famine + 1
    } 	QualityMessageType;

typedef struct tagQuality
    {
    QualityMessageType Type;
    long Proportion;
    REFERENCE_TIME Late;
    REFERENCE_TIME TimeStamp;
    } 	Quality;

typedef IQualityControl *PQUALITYCONTROL;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0137_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0137_v0_0_s_ifspec;

#ifndef __IQualityControl_INTERFACE_DEFINED__
#define __IQualityControl_INTERFACE_DEFINED__

/* interface IQualityControl */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IQualityControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868a5-0ad4-11ce-b03a-0020af0ba770")
    IQualityControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ IBaseFilter *pSelf,
            /* [in] */ Quality q) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSink( 
            /* [in] */ IQualityControl *piqc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IQualityControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IQualityControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IQualityControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IQualityControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *Notify )( 
            IQualityControl * This,
            /* [in] */ IBaseFilter *pSelf,
            /* [in] */ Quality q);
        
        HRESULT ( STDMETHODCALLTYPE *SetSink )( 
            IQualityControl * This,
            /* [in] */ IQualityControl *piqc);
        
        END_INTERFACE
    } IQualityControlVtbl;

    interface IQualityControl
    {
        CONST_VTBL struct IQualityControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IQualityControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IQualityControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IQualityControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IQualityControl_Notify(This,pSelf,q)	\
    (This)->lpVtbl -> Notify(This,pSelf,q)

#define IQualityControl_SetSink(This,piqc)	\
    (This)->lpVtbl -> SetSink(This,piqc)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IQualityControl_Notify_Proxy( 
    IQualityControl * This,
    /* [in] */ IBaseFilter *pSelf,
    /* [in] */ Quality q);


void __RPC_STUB IQualityControl_Notify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IQualityControl_SetSink_Proxy( 
    IQualityControl * This,
    /* [in] */ IQualityControl *piqc);


void __RPC_STUB IQualityControl_SetSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IQualityControl_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0138 */
/* [local] */ 


enum __MIDL___MIDL_itf_strmif_0138_0001
    {	CK_NOCOLORKEY	= 0,
	CK_INDEX	= 0x1,
	CK_RGB	= 0x2
    } ;
typedef struct tagCOLORKEY
    {
    DWORD KeyType;
    DWORD PaletteIndex;
    COLORREF LowColorValue;
    COLORREF HighColorValue;
    } 	COLORKEY;


enum __MIDL___MIDL_itf_strmif_0138_0002
    {	ADVISE_NONE	= 0,
	ADVISE_CLIPPING	= 0x1,
	ADVISE_PALETTE	= 0x2,
	ADVISE_COLORKEY	= 0x4,
	ADVISE_POSITION	= 0x8,
	ADVISE_DISPLAY_CHANGE	= 0x10
    } ;
#define	ADVISE_ALL	( ADVISE_CLIPPING | ADVISE_PALETTE | ADVISE_COLORKEY | ADVISE_POSITION )

#define	ADVISE_ALL2	( ADVISE_ALL | ADVISE_DISPLAY_CHANGE )

#ifndef _WINGDI_
typedef struct _RGNDATAHEADER
    {
    DWORD dwSize;
    DWORD iType;
    DWORD nCount;
    DWORD nRgnSize;
    RECT rcBound;
    } 	RGNDATAHEADER;

typedef struct _RGNDATA
    {
    RGNDATAHEADER rdh;
    char Buffer[ 1 ];
    } 	RGNDATA;

#endif


extern RPC_IF_HANDLE __MIDL_itf_strmif_0138_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0138_v0_0_s_ifspec;

#ifndef __IOverlayNotify_INTERFACE_DEFINED__
#define __IOverlayNotify_INTERFACE_DEFINED__

/* interface IOverlayNotify */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IOverlayNotify;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868a0-0ad4-11ce-b03a-0020af0ba770")
    IOverlayNotify : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnPaletteChange( 
            /* [in] */ DWORD dwColors,
            /* [in] */ const PALETTEENTRY *pPalette) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnClipChange( 
            /* [in] */ const RECT *pSourceRect,
            /* [in] */ const RECT *pDestinationRect,
            /* [in] */ const RGNDATA *pRgnData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnColorKeyChange( 
            /* [in] */ const COLORKEY *pColorKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnPositionChange( 
            /* [in] */ const RECT *pSourceRect,
            /* [in] */ const RECT *pDestinationRect) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOverlayNotifyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IOverlayNotify * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IOverlayNotify * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IOverlayNotify * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnPaletteChange )( 
            IOverlayNotify * This,
            /* [in] */ DWORD dwColors,
            /* [in] */ const PALETTEENTRY *pPalette);
        
        HRESULT ( STDMETHODCALLTYPE *OnClipChange )( 
            IOverlayNotify * This,
            /* [in] */ const RECT *pSourceRect,
            /* [in] */ const RECT *pDestinationRect,
            /* [in] */ const RGNDATA *pRgnData);
        
        HRESULT ( STDMETHODCALLTYPE *OnColorKeyChange )( 
            IOverlayNotify * This,
            /* [in] */ const COLORKEY *pColorKey);
        
        HRESULT ( STDMETHODCALLTYPE *OnPositionChange )( 
            IOverlayNotify * This,
            /* [in] */ const RECT *pSourceRect,
            /* [in] */ const RECT *pDestinationRect);
        
        END_INTERFACE
    } IOverlayNotifyVtbl;

    interface IOverlayNotify
    {
        CONST_VTBL struct IOverlayNotifyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOverlayNotify_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOverlayNotify_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IOverlayNotify_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IOverlayNotify_OnPaletteChange(This,dwColors,pPalette)	\
    (This)->lpVtbl -> OnPaletteChange(This,dwColors,pPalette)

#define IOverlayNotify_OnClipChange(This,pSourceRect,pDestinationRect,pRgnData)	\
    (This)->lpVtbl -> OnClipChange(This,pSourceRect,pDestinationRect,pRgnData)

#define IOverlayNotify_OnColorKeyChange(This,pColorKey)	\
    (This)->lpVtbl -> OnColorKeyChange(This,pColorKey)

#define IOverlayNotify_OnPositionChange(This,pSourceRect,pDestinationRect)	\
    (This)->lpVtbl -> OnPositionChange(This,pSourceRect,pDestinationRect)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IOverlayNotify_OnPaletteChange_Proxy( 
    IOverlayNotify * This,
    /* [in] */ DWORD dwColors,
    /* [in] */ const PALETTEENTRY *pPalette);


void __RPC_STUB IOverlayNotify_OnPaletteChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOverlayNotify_OnClipChange_Proxy( 
    IOverlayNotify * This,
    /* [in] */ const RECT *pSourceRect,
    /* [in] */ const RECT *pDestinationRect,
    /* [in] */ const RGNDATA *pRgnData);


void __RPC_STUB IOverlayNotify_OnClipChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOverlayNotify_OnColorKeyChange_Proxy( 
    IOverlayNotify * This,
    /* [in] */ const COLORKEY *pColorKey);


void __RPC_STUB IOverlayNotify_OnColorKeyChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOverlayNotify_OnPositionChange_Proxy( 
    IOverlayNotify * This,
    /* [in] */ const RECT *pSourceRect,
    /* [in] */ const RECT *pDestinationRect);


void __RPC_STUB IOverlayNotify_OnPositionChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IOverlayNotify_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0139 */
/* [local] */ 

typedef IOverlayNotify *POVERLAYNOTIFY;

#if !defined(HMONITOR_DECLARED) && !defined(HMONITOR) && (WINVER < 0x0500)
#define HMONITOR_DECLARED
#if 0
typedef HANDLE HMONITOR;

#endif
DECLARE_HANDLE(HMONITOR);
#endif


extern RPC_IF_HANDLE __MIDL_itf_strmif_0139_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0139_v0_0_s_ifspec;

#ifndef __IOverlayNotify2_INTERFACE_DEFINED__
#define __IOverlayNotify2_INTERFACE_DEFINED__

/* interface IOverlayNotify2 */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IOverlayNotify2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("680EFA10-D535-11D1-87C8-00A0C9223196")
    IOverlayNotify2 : public IOverlayNotify
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnDisplayChange( 
            HMONITOR hMonitor) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOverlayNotify2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IOverlayNotify2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IOverlayNotify2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IOverlayNotify2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnPaletteChange )( 
            IOverlayNotify2 * This,
            /* [in] */ DWORD dwColors,
            /* [in] */ const PALETTEENTRY *pPalette);
        
        HRESULT ( STDMETHODCALLTYPE *OnClipChange )( 
            IOverlayNotify2 * This,
            /* [in] */ const RECT *pSourceRect,
            /* [in] */ const RECT *pDestinationRect,
            /* [in] */ const RGNDATA *pRgnData);
        
        HRESULT ( STDMETHODCALLTYPE *OnColorKeyChange )( 
            IOverlayNotify2 * This,
            /* [in] */ const COLORKEY *pColorKey);
        
        HRESULT ( STDMETHODCALLTYPE *OnPositionChange )( 
            IOverlayNotify2 * This,
            /* [in] */ const RECT *pSourceRect,
            /* [in] */ const RECT *pDestinationRect);
        
        HRESULT ( STDMETHODCALLTYPE *OnDisplayChange )( 
            IOverlayNotify2 * This,
            HMONITOR hMonitor);
        
        END_INTERFACE
    } IOverlayNotify2Vtbl;

    interface IOverlayNotify2
    {
        CONST_VTBL struct IOverlayNotify2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOverlayNotify2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOverlayNotify2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IOverlayNotify2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IOverlayNotify2_OnPaletteChange(This,dwColors,pPalette)	\
    (This)->lpVtbl -> OnPaletteChange(This,dwColors,pPalette)

#define IOverlayNotify2_OnClipChange(This,pSourceRect,pDestinationRect,pRgnData)	\
    (This)->lpVtbl -> OnClipChange(This,pSourceRect,pDestinationRect,pRgnData)

#define IOverlayNotify2_OnColorKeyChange(This,pColorKey)	\
    (This)->lpVtbl -> OnColorKeyChange(This,pColorKey)

#define IOverlayNotify2_OnPositionChange(This,pSourceRect,pDestinationRect)	\
    (This)->lpVtbl -> OnPositionChange(This,pSourceRect,pDestinationRect)


#define IOverlayNotify2_OnDisplayChange(This,hMonitor)	\
    (This)->lpVtbl -> OnDisplayChange(This,hMonitor)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IOverlayNotify2_OnDisplayChange_Proxy( 
    IOverlayNotify2 * This,
    HMONITOR hMonitor);


void __RPC_STUB IOverlayNotify2_OnDisplayChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IOverlayNotify2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0140 */
/* [local] */ 

typedef IOverlayNotify2 *POVERLAYNOTIFY2;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0140_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0140_v0_0_s_ifspec;

#ifndef __IOverlay_INTERFACE_DEFINED__
#define __IOverlay_INTERFACE_DEFINED__

/* interface IOverlay */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IOverlay;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868a1-0ad4-11ce-b03a-0020af0ba770")
    IOverlay : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPalette( 
            /* [out] */ DWORD *pdwColors,
            /* [out] */ PALETTEENTRY **ppPalette) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPalette( 
            /* [in] */ DWORD dwColors,
            /* [in] */ PALETTEENTRY *pPalette) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultColorKey( 
            /* [out] */ COLORKEY *pColorKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetColorKey( 
            /* [out] */ COLORKEY *pColorKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetColorKey( 
            /* [out][in] */ COLORKEY *pColorKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWindowHandle( 
            /* [out] */ HWND *pHwnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClipList( 
            /* [out] */ RECT *pSourceRect,
            /* [out] */ RECT *pDestinationRect,
            /* [out] */ RGNDATA **ppRgnData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVideoPosition( 
            /* [out] */ RECT *pSourceRect,
            /* [out] */ RECT *pDestinationRect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Advise( 
            /* [in] */ IOverlayNotify *pOverlayNotify,
            /* [in] */ DWORD dwInterests) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unadvise( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOverlayVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IOverlay * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IOverlay * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IOverlay * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPalette )( 
            IOverlay * This,
            /* [out] */ DWORD *pdwColors,
            /* [out] */ PALETTEENTRY **ppPalette);
        
        HRESULT ( STDMETHODCALLTYPE *SetPalette )( 
            IOverlay * This,
            /* [in] */ DWORD dwColors,
            /* [in] */ PALETTEENTRY *pPalette);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultColorKey )( 
            IOverlay * This,
            /* [out] */ COLORKEY *pColorKey);
        
        HRESULT ( STDMETHODCALLTYPE *GetColorKey )( 
            IOverlay * This,
            /* [out] */ COLORKEY *pColorKey);
        
        HRESULT ( STDMETHODCALLTYPE *SetColorKey )( 
            IOverlay * This,
            /* [out][in] */ COLORKEY *pColorKey);
        
        HRESULT ( STDMETHODCALLTYPE *GetWindowHandle )( 
            IOverlay * This,
            /* [out] */ HWND *pHwnd);
        
        HRESULT ( STDMETHODCALLTYPE *GetClipList )( 
            IOverlay * This,
            /* [out] */ RECT *pSourceRect,
            /* [out] */ RECT *pDestinationRect,
            /* [out] */ RGNDATA **ppRgnData);
        
        HRESULT ( STDMETHODCALLTYPE *GetVideoPosition )( 
            IOverlay * This,
            /* [out] */ RECT *pSourceRect,
            /* [out] */ RECT *pDestinationRect);
        
        HRESULT ( STDMETHODCALLTYPE *Advise )( 
            IOverlay * This,
            /* [in] */ IOverlayNotify *pOverlayNotify,
            /* [in] */ DWORD dwInterests);
        
        HRESULT ( STDMETHODCALLTYPE *Unadvise )( 
            IOverlay * This);
        
        END_INTERFACE
    } IOverlayVtbl;

    interface IOverlay
    {
        CONST_VTBL struct IOverlayVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOverlay_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOverlay_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IOverlay_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IOverlay_GetPalette(This,pdwColors,ppPalette)	\
    (This)->lpVtbl -> GetPalette(This,pdwColors,ppPalette)

#define IOverlay_SetPalette(This,dwColors,pPalette)	\
    (This)->lpVtbl -> SetPalette(This,dwColors,pPalette)

#define IOverlay_GetDefaultColorKey(This,pColorKey)	\
    (This)->lpVtbl -> GetDefaultColorKey(This,pColorKey)

#define IOverlay_GetColorKey(This,pColorKey)	\
    (This)->lpVtbl -> GetColorKey(This,pColorKey)

#define IOverlay_SetColorKey(This,pColorKey)	\
    (This)->lpVtbl -> SetColorKey(This,pColorKey)

#define IOverlay_GetWindowHandle(This,pHwnd)	\
    (This)->lpVtbl -> GetWindowHandle(This,pHwnd)

#define IOverlay_GetClipList(This,pSourceRect,pDestinationRect,ppRgnData)	\
    (This)->lpVtbl -> GetClipList(This,pSourceRect,pDestinationRect,ppRgnData)

#define IOverlay_GetVideoPosition(This,pSourceRect,pDestinationRect)	\
    (This)->lpVtbl -> GetVideoPosition(This,pSourceRect,pDestinationRect)

#define IOverlay_Advise(This,pOverlayNotify,dwInterests)	\
    (This)->lpVtbl -> Advise(This,pOverlayNotify,dwInterests)

#define IOverlay_Unadvise(This)	\
    (This)->lpVtbl -> Unadvise(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IOverlay_GetPalette_Proxy( 
    IOverlay * This,
    /* [out] */ DWORD *pdwColors,
    /* [out] */ PALETTEENTRY **ppPalette);


void __RPC_STUB IOverlay_GetPalette_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOverlay_SetPalette_Proxy( 
    IOverlay * This,
    /* [in] */ DWORD dwColors,
    /* [in] */ PALETTEENTRY *pPalette);


void __RPC_STUB IOverlay_SetPalette_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOverlay_GetDefaultColorKey_Proxy( 
    IOverlay * This,
    /* [out] */ COLORKEY *pColorKey);


void __RPC_STUB IOverlay_GetDefaultColorKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOverlay_GetColorKey_Proxy( 
    IOverlay * This,
    /* [out] */ COLORKEY *pColorKey);


void __RPC_STUB IOverlay_GetColorKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOverlay_SetColorKey_Proxy( 
    IOverlay * This,
    /* [out][in] */ COLORKEY *pColorKey);


void __RPC_STUB IOverlay_SetColorKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOverlay_GetWindowHandle_Proxy( 
    IOverlay * This,
    /* [out] */ HWND *pHwnd);


void __RPC_STUB IOverlay_GetWindowHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOverlay_GetClipList_Proxy( 
    IOverlay * This,
    /* [out] */ RECT *pSourceRect,
    /* [out] */ RECT *pDestinationRect,
    /* [out] */ RGNDATA **ppRgnData);


void __RPC_STUB IOverlay_GetClipList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOverlay_GetVideoPosition_Proxy( 
    IOverlay * This,
    /* [out] */ RECT *pSourceRect,
    /* [out] */ RECT *pDestinationRect);


void __RPC_STUB IOverlay_GetVideoPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOverlay_Advise_Proxy( 
    IOverlay * This,
    /* [in] */ IOverlayNotify *pOverlayNotify,
    /* [in] */ DWORD dwInterests);


void __RPC_STUB IOverlay_Advise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOverlay_Unadvise_Proxy( 
    IOverlay * This);


void __RPC_STUB IOverlay_Unadvise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IOverlay_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0141 */
/* [local] */ 

typedef IOverlay *POVERLAY;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0141_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0141_v0_0_s_ifspec;

#ifndef __IMediaEventSink_INTERFACE_DEFINED__
#define __IMediaEventSink_INTERFACE_DEFINED__

/* interface IMediaEventSink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IMediaEventSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868a2-0ad4-11ce-b03a-0020af0ba770")
    IMediaEventSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ long EventCode,
            /* [in] */ LONG_PTR EventParam1,
            /* [in] */ LONG_PTR EventParam2) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaEventSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaEventSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaEventSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaEventSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *Notify )( 
            IMediaEventSink * This,
            /* [in] */ long EventCode,
            /* [in] */ LONG_PTR EventParam1,
            /* [in] */ LONG_PTR EventParam2);
        
        END_INTERFACE
    } IMediaEventSinkVtbl;

    interface IMediaEventSink
    {
        CONST_VTBL struct IMediaEventSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaEventSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMediaEventSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMediaEventSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMediaEventSink_Notify(This,EventCode,EventParam1,EventParam2)	\
    (This)->lpVtbl -> Notify(This,EventCode,EventParam1,EventParam2)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMediaEventSink_Notify_Proxy( 
    IMediaEventSink * This,
    /* [in] */ long EventCode,
    /* [in] */ LONG_PTR EventParam1,
    /* [in] */ LONG_PTR EventParam2);


void __RPC_STUB IMediaEventSink_Notify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMediaEventSink_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0142 */
/* [local] */ 

typedef IMediaEventSink *PMEDIAEVENTSINK;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0142_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0142_v0_0_s_ifspec;

#ifndef __IFileSourceFilter_INTERFACE_DEFINED__
#define __IFileSourceFilter_INTERFACE_DEFINED__

/* interface IFileSourceFilter */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IFileSourceFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868a6-0ad4-11ce-b03a-0020af0ba770")
    IFileSourceFilter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Load( 
            /* [in] */ LPCOLESTR pszFileName,
            /* [unique][in] */ const AM_MEDIA_TYPE *pmt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurFile( 
            /* [out] */ LPOLESTR *ppszFileName,
            /* [out] */ AM_MEDIA_TYPE *pmt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFileSourceFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFileSourceFilter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFileSourceFilter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFileSourceFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *Load )( 
            IFileSourceFilter * This,
            /* [in] */ LPCOLESTR pszFileName,
            /* [unique][in] */ const AM_MEDIA_TYPE *pmt);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurFile )( 
            IFileSourceFilter * This,
            /* [out] */ LPOLESTR *ppszFileName,
            /* [out] */ AM_MEDIA_TYPE *pmt);
        
        END_INTERFACE
    } IFileSourceFilterVtbl;

    interface IFileSourceFilter
    {
        CONST_VTBL struct IFileSourceFilterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFileSourceFilter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFileSourceFilter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFileSourceFilter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFileSourceFilter_Load(This,pszFileName,pmt)	\
    (This)->lpVtbl -> Load(This,pszFileName,pmt)

#define IFileSourceFilter_GetCurFile(This,ppszFileName,pmt)	\
    (This)->lpVtbl -> GetCurFile(This,ppszFileName,pmt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IFileSourceFilter_Load_Proxy( 
    IFileSourceFilter * This,
    /* [in] */ LPCOLESTR pszFileName,
    /* [unique][in] */ const AM_MEDIA_TYPE *pmt);


void __RPC_STUB IFileSourceFilter_Load_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IFileSourceFilter_GetCurFile_Proxy( 
    IFileSourceFilter * This,
    /* [out] */ LPOLESTR *ppszFileName,
    /* [out] */ AM_MEDIA_TYPE *pmt);


void __RPC_STUB IFileSourceFilter_GetCurFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFileSourceFilter_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0143 */
/* [local] */ 

typedef IFileSourceFilter *PFILTERFILESOURCE;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0143_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0143_v0_0_s_ifspec;

#ifndef __IFileSinkFilter_INTERFACE_DEFINED__
#define __IFileSinkFilter_INTERFACE_DEFINED__

/* interface IFileSinkFilter */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IFileSinkFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a2104830-7c70-11cf-8bce-00aa00a3f1a6")
    IFileSinkFilter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFileName( 
            /* [in] */ LPCOLESTR pszFileName,
            /* [unique][in] */ const AM_MEDIA_TYPE *pmt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurFile( 
            /* [out] */ LPOLESTR *ppszFileName,
            /* [out] */ AM_MEDIA_TYPE *pmt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFileSinkFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFileSinkFilter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFileSinkFilter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFileSinkFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFileName )( 
            IFileSinkFilter * This,
            /* [in] */ LPCOLESTR pszFileName,
            /* [unique][in] */ const AM_MEDIA_TYPE *pmt);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurFile )( 
            IFileSinkFilter * This,
            /* [out] */ LPOLESTR *ppszFileName,
            /* [out] */ AM_MEDIA_TYPE *pmt);
        
        END_INTERFACE
    } IFileSinkFilterVtbl;

    interface IFileSinkFilter
    {
        CONST_VTBL struct IFileSinkFilterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFileSinkFilter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFileSinkFilter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFileSinkFilter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFileSinkFilter_SetFileName(This,pszFileName,pmt)	\
    (This)->lpVtbl -> SetFileName(This,pszFileName,pmt)

#define IFileSinkFilter_GetCurFile(This,ppszFileName,pmt)	\
    (This)->lpVtbl -> GetCurFile(This,ppszFileName,pmt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IFileSinkFilter_SetFileName_Proxy( 
    IFileSinkFilter * This,
    /* [in] */ LPCOLESTR pszFileName,
    /* [unique][in] */ const AM_MEDIA_TYPE *pmt);


void __RPC_STUB IFileSinkFilter_SetFileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IFileSinkFilter_GetCurFile_Proxy( 
    IFileSinkFilter * This,
    /* [out] */ LPOLESTR *ppszFileName,
    /* [out] */ AM_MEDIA_TYPE *pmt);


void __RPC_STUB IFileSinkFilter_GetCurFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFileSinkFilter_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0144 */
/* [local] */ 

typedef IFileSinkFilter *PFILTERFILESINK;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0144_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0144_v0_0_s_ifspec;

#ifndef __IFileSinkFilter2_INTERFACE_DEFINED__
#define __IFileSinkFilter2_INTERFACE_DEFINED__

/* interface IFileSinkFilter2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IFileSinkFilter2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00855B90-CE1B-11d0-BD4F-00A0C911CE86")
    IFileSinkFilter2 : public IFileSinkFilter
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetMode( 
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMode( 
            /* [out] */ DWORD *pdwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFileSinkFilter2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFileSinkFilter2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFileSinkFilter2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFileSinkFilter2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFileName )( 
            IFileSinkFilter2 * This,
            /* [in] */ LPCOLESTR pszFileName,
            /* [unique][in] */ const AM_MEDIA_TYPE *pmt);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurFile )( 
            IFileSinkFilter2 * This,
            /* [out] */ LPOLESTR *ppszFileName,
            /* [out] */ AM_MEDIA_TYPE *pmt);
        
        HRESULT ( STDMETHODCALLTYPE *SetMode )( 
            IFileSinkFilter2 * This,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetMode )( 
            IFileSinkFilter2 * This,
            /* [out] */ DWORD *pdwFlags);
        
        END_INTERFACE
    } IFileSinkFilter2Vtbl;

    interface IFileSinkFilter2
    {
        CONST_VTBL struct IFileSinkFilter2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFileSinkFilter2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFileSinkFilter2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFileSinkFilter2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFileSinkFilter2_SetFileName(This,pszFileName,pmt)	\
    (This)->lpVtbl -> SetFileName(This,pszFileName,pmt)

#define IFileSinkFilter2_GetCurFile(This,ppszFileName,pmt)	\
    (This)->lpVtbl -> GetCurFile(This,ppszFileName,pmt)


#define IFileSinkFilter2_SetMode(This,dwFlags)	\
    (This)->lpVtbl -> SetMode(This,dwFlags)

#define IFileSinkFilter2_GetMode(This,pdwFlags)	\
    (This)->lpVtbl -> GetMode(This,pdwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IFileSinkFilter2_SetMode_Proxy( 
    IFileSinkFilter2 * This,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IFileSinkFilter2_SetMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IFileSinkFilter2_GetMode_Proxy( 
    IFileSinkFilter2 * This,
    /* [out] */ DWORD *pdwFlags);


void __RPC_STUB IFileSinkFilter2_GetMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFileSinkFilter2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0145 */
/* [local] */ 

typedef IFileSinkFilter2 *PFILESINKFILTER2;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_strmif_0145_0001
    {	AM_FILE_OVERWRITE	= 0x1
    } 	AM_FILESINK_FLAGS;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0145_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0145_v0_0_s_ifspec;

#ifndef __IGraphBuilder_INTERFACE_DEFINED__
#define __IGraphBuilder_INTERFACE_DEFINED__

/* interface IGraphBuilder */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IGraphBuilder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868a9-0ad4-11ce-b03a-0020af0ba770")
    IGraphBuilder : public IFilterGraph
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Connect( 
            /* [in] */ IPin *ppinOut,
            /* [in] */ IPin *ppinIn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Render( 
            /* [in] */ IPin *ppinOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RenderFile( 
            /* [in] */ LPCWSTR lpcwstrFile,
            /* [unique][in] */ LPCWSTR lpcwstrPlayList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddSourceFilter( 
            /* [in] */ LPCWSTR lpcwstrFileName,
            /* [unique][in] */ LPCWSTR lpcwstrFilterName,
            /* [out] */ IBaseFilter **ppFilter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLogFile( 
            /* [in] */ DWORD_PTR hFile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Abort( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShouldOperationContinue( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGraphBuilderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGraphBuilder * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGraphBuilder * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGraphBuilder * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddFilter )( 
            IGraphBuilder * This,
            /* [in] */ IBaseFilter *pFilter,
            /* [string][in] */ LPCWSTR pName);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveFilter )( 
            IGraphBuilder * This,
            /* [in] */ IBaseFilter *pFilter);
        
        HRESULT ( STDMETHODCALLTYPE *EnumFilters )( 
            IGraphBuilder * This,
            /* [out] */ IEnumFilters **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *FindFilterByName )( 
            IGraphBuilder * This,
            /* [string][in] */ LPCWSTR pName,
            /* [out] */ IBaseFilter **ppFilter);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectDirect )( 
            IGraphBuilder * This,
            /* [in] */ IPin *ppinOut,
            /* [in] */ IPin *ppinIn,
            /* [unique][in] */ const AM_MEDIA_TYPE *pmt);
        
        HRESULT ( STDMETHODCALLTYPE *Reconnect )( 
            IGraphBuilder * This,
            /* [in] */ IPin *ppin);
        
        HRESULT ( STDMETHODCALLTYPE *Disconnect )( 
            IGraphBuilder * This,
            /* [in] */ IPin *ppin);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultSyncSource )( 
            IGraphBuilder * This);
        
        HRESULT ( STDMETHODCALLTYPE *Connect )( 
            IGraphBuilder * This,
            /* [in] */ IPin *ppinOut,
            /* [in] */ IPin *ppinIn);
        
        HRESULT ( STDMETHODCALLTYPE *Render )( 
            IGraphBuilder * This,
            /* [in] */ IPin *ppinOut);
        
        HRESULT ( STDMETHODCALLTYPE *RenderFile )( 
            IGraphBuilder * This,
            /* [in] */ LPCWSTR lpcwstrFile,
            /* [unique][in] */ LPCWSTR lpcwstrPlayList);
        
        HRESULT ( STDMETHODCALLTYPE *AddSourceFilter )( 
            IGraphBuilder * This,
            /* [in] */ LPCWSTR lpcwstrFileName,
            /* [unique][in] */ LPCWSTR lpcwstrFilterName,
            /* [out] */ IBaseFilter **ppFilter);
        
        HRESULT ( STDMETHODCALLTYPE *SetLogFile )( 
            IGraphBuilder * This,
            /* [in] */ DWORD_PTR hFile);
        
        HRESULT ( STDMETHODCALLTYPE *Abort )( 
            IGraphBuilder * This);
        
        HRESULT ( STDMETHODCALLTYPE *ShouldOperationContinue )( 
            IGraphBuilder * This);
        
        END_INTERFACE
    } IGraphBuilderVtbl;

    interface IGraphBuilder
    {
        CONST_VTBL struct IGraphBuilderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGraphBuilder_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGraphBuilder_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGraphBuilder_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGraphBuilder_AddFilter(This,pFilter,pName)	\
    (This)->lpVtbl -> AddFilter(This,pFilter,pName)

#define IGraphBuilder_RemoveFilter(This,pFilter)	\
    (This)->lpVtbl -> RemoveFilter(This,pFilter)

#define IGraphBuilder_EnumFilters(This,ppEnum)	\
    (This)->lpVtbl -> EnumFilters(This,ppEnum)

#define IGraphBuilder_FindFilterByName(This,pName,ppFilter)	\
    (This)->lpVtbl -> FindFilterByName(This,pName,ppFilter)

#define IGraphBuilder_ConnectDirect(This,ppinOut,ppinIn,pmt)	\
    (This)->lpVtbl -> ConnectDirect(This,ppinOut,ppinIn,pmt)

#define IGraphBuilder_Reconnect(This,ppin)	\
    (This)->lpVtbl -> Reconnect(This,ppin)

#define IGraphBuilder_Disconnect(This,ppin)	\
    (This)->lpVtbl -> Disconnect(This,ppin)

#define IGraphBuilder_SetDefaultSyncSource(This)	\
    (This)->lpVtbl -> SetDefaultSyncSource(This)


#define IGraphBuilder_Connect(This,ppinOut,ppinIn)	\
    (This)->lpVtbl -> Connect(This,ppinOut,ppinIn)

#define IGraphBuilder_Render(This,ppinOut)	\
    (This)->lpVtbl -> Render(This,ppinOut)

#define IGraphBuilder_RenderFile(This,lpcwstrFile,lpcwstrPlayList)	\
    (This)->lpVtbl -> RenderFile(This,lpcwstrFile,lpcwstrPlayList)

#define IGraphBuilder_AddSourceFilter(This,lpcwstrFileName,lpcwstrFilterName,ppFilter)	\
    (This)->lpVtbl -> AddSourceFilter(This,lpcwstrFileName,lpcwstrFilterName,ppFilter)

#define IGraphBuilder_SetLogFile(This,hFile)	\
    (This)->lpVtbl -> SetLogFile(This,hFile)

#define IGraphBuilder_Abort(This)	\
    (This)->lpVtbl -> Abort(This)

#define IGraphBuilder_ShouldOperationContinue(This)	\
    (This)->lpVtbl -> ShouldOperationContinue(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IGraphBuilder_Connect_Proxy( 
    IGraphBuilder * This,
    /* [in] */ IPin *ppinOut,
    /* [in] */ IPin *ppinIn);


void __RPC_STUB IGraphBuilder_Connect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IGraphBuilder_Render_Proxy( 
    IGraphBuilder * This,
    /* [in] */ IPin *ppinOut);


void __RPC_STUB IGraphBuilder_Render_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IGraphBuilder_RenderFile_Proxy( 
    IGraphBuilder * This,
    /* [in] */ LPCWSTR lpcwstrFile,
    /* [unique][in] */ LPCWSTR lpcwstrPlayList);


void __RPC_STUB IGraphBuilder_RenderFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IGraphBuilder_AddSourceFilter_Proxy( 
    IGraphBuilder * This,
    /* [in] */ LPCWSTR lpcwstrFileName,
    /* [unique][in] */ LPCWSTR lpcwstrFilterName,
    /* [out] */ IBaseFilter **ppFilter);


void __RPC_STUB IGraphBuilder_AddSourceFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IGraphBuilder_SetLogFile_Proxy( 
    IGraphBuilder * This,
    /* [in] */ DWORD_PTR hFile);


void __RPC_STUB IGraphBuilder_SetLogFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IGraphBuilder_Abort_Proxy( 
    IGraphBuilder * This);


void __RPC_STUB IGraphBuilder_Abort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IGraphBuilder_ShouldOperationContinue_Proxy( 
    IGraphBuilder * This);


void __RPC_STUB IGraphBuilder_ShouldOperationContinue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGraphBuilder_INTERFACE_DEFINED__ */


#ifndef __ICaptureGraphBuilder_INTERFACE_DEFINED__
#define __ICaptureGraphBuilder_INTERFACE_DEFINED__

/* interface ICaptureGraphBuilder */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICaptureGraphBuilder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("bf87b6e0-8c27-11d0-b3f0-00aa003761c5")
    ICaptureGraphBuilder : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFiltergraph( 
            /* [in] */ IGraphBuilder *pfg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFiltergraph( 
            /* [out] */ IGraphBuilder **ppfg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOutputFileName( 
            /* [in] */ const GUID *pType,
            /* [in] */ LPCOLESTR lpstrFile,
            /* [out] */ IBaseFilter **ppf,
            /* [out] */ IFileSinkFilter **ppSink) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE FindInterface( 
            /* [unique][in] */ const GUID *pCategory,
            /* [in] */ IBaseFilter *pf,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RenderStream( 
            /* [in] */ const GUID *pCategory,
            /* [in] */ IUnknown *pSource,
            /* [in] */ IBaseFilter *pfCompressor,
            /* [in] */ IBaseFilter *pfRenderer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ControlStream( 
            /* [in] */ const GUID *pCategory,
            /* [in] */ IBaseFilter *pFilter,
            /* [in] */ REFERENCE_TIME *pstart,
            /* [in] */ REFERENCE_TIME *pstop,
            /* [in] */ WORD wStartCookie,
            /* [in] */ WORD wStopCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocCapFile( 
            /* [in] */ LPCOLESTR lpstr,
            /* [in] */ DWORDLONG dwlSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CopyCaptureFile( 
            /* [in] */ LPOLESTR lpwstrOld,
            /* [in] */ LPOLESTR lpwstrNew,
            /* [in] */ int fAllowEscAbort,
            /* [in] */ IAMCopyCaptureFileProgress *pCallback) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICaptureGraphBuilderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICaptureGraphBuilder * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICaptureGraphBuilder * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICaptureGraphBuilder * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFiltergraph )( 
            ICaptureGraphBuilder * This,
            /* [in] */ IGraphBuilder *pfg);
        
        HRESULT ( STDMETHODCALLTYPE *GetFiltergraph )( 
            ICaptureGraphBuilder * This,
            /* [out] */ IGraphBuilder **ppfg);
        
        HRESULT ( STDMETHODCALLTYPE *SetOutputFileName )( 
            ICaptureGraphBuilder * This,
            /* [in] */ const GUID *pType,
            /* [in] */ LPCOLESTR lpstrFile,
            /* [out] */ IBaseFilter **ppf,
            /* [out] */ IFileSinkFilter **ppSink);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *FindInterface )( 
            ICaptureGraphBuilder * This,
            /* [unique][in] */ const GUID *pCategory,
            /* [in] */ IBaseFilter *pf,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppint);
        
        HRESULT ( STDMETHODCALLTYPE *RenderStream )( 
            ICaptureGraphBuilder * This,
            /* [in] */ const GUID *pCategory,
            /* [in] */ IUnknown *pSource,
            /* [in] */ IBaseFilter *pfCompressor,
            /* [in] */ IBaseFilter *pfRenderer);
        
        HRESULT ( STDMETHODCALLTYPE *ControlStream )( 
            ICaptureGraphBuilder * This,
            /* [in] */ const GUID *pCategory,
            /* [in] */ IBaseFilter *pFilter,
            /* [in] */ REFERENCE_TIME *pstart,
            /* [in] */ REFERENCE_TIME *pstop,
            /* [in] */ WORD wStartCookie,
            /* [in] */ WORD wStopCookie);
        
        HRESULT ( STDMETHODCALLTYPE *AllocCapFile )( 
            ICaptureGraphBuilder * This,
            /* [in] */ LPCOLESTR lpstr,
            /* [in] */ DWORDLONG dwlSize);
        
        HRESULT ( STDMETHODCALLTYPE *CopyCaptureFile )( 
            ICaptureGraphBuilder * This,
            /* [in] */ LPOLESTR lpwstrOld,
            /* [in] */ LPOLESTR lpwstrNew,
            /* [in] */ int fAllowEscAbort,
            /* [in] */ IAMCopyCaptureFileProgress *pCallback);
        
        END_INTERFACE
    } ICaptureGraphBuilderVtbl;

    interface ICaptureGraphBuilder
    {
        CONST_VTBL struct ICaptureGraphBuilderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICaptureGraphBuilder_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICaptureGraphBuilder_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICaptureGraphBuilder_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICaptureGraphBuilder_SetFiltergraph(This,pfg)	\
    (This)->lpVtbl -> SetFiltergraph(This,pfg)

#define ICaptureGraphBuilder_GetFiltergraph(This,ppfg)	\
    (This)->lpVtbl -> GetFiltergraph(This,ppfg)

#define ICaptureGraphBuilder_SetOutputFileName(This,pType,lpstrFile,ppf,ppSink)	\
    (This)->lpVtbl -> SetOutputFileName(This,pType,lpstrFile,ppf,ppSink)

#define ICaptureGraphBuilder_FindInterface(This,pCategory,pf,riid,ppint)	\
    (This)->lpVtbl -> FindInterface(This,pCategory,pf,riid,ppint)

#define ICaptureGraphBuilder_RenderStream(This,pCategory,pSource,pfCompressor,pfRenderer)	\
    (This)->lpVtbl -> RenderStream(This,pCategory,pSource,pfCompressor,pfRenderer)

#define ICaptureGraphBuilder_ControlStream(This,pCategory,pFilter,pstart,pstop,wStartCookie,wStopCookie)	\
    (This)->lpVtbl -> ControlStream(This,pCategory,pFilter,pstart,pstop,wStartCookie,wStopCookie)

#define ICaptureGraphBuilder_AllocCapFile(This,lpstr,dwlSize)	\
    (This)->lpVtbl -> AllocCapFile(This,lpstr,dwlSize)

#define ICaptureGraphBuilder_CopyCaptureFile(This,lpwstrOld,lpwstrNew,fAllowEscAbort,pCallback)	\
    (This)->lpVtbl -> CopyCaptureFile(This,lpwstrOld,lpwstrNew,fAllowEscAbort,pCallback)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICaptureGraphBuilder_SetFiltergraph_Proxy( 
    ICaptureGraphBuilder * This,
    /* [in] */ IGraphBuilder *pfg);


void __RPC_STUB ICaptureGraphBuilder_SetFiltergraph_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICaptureGraphBuilder_GetFiltergraph_Proxy( 
    ICaptureGraphBuilder * This,
    /* [out] */ IGraphBuilder **ppfg);


void __RPC_STUB ICaptureGraphBuilder_GetFiltergraph_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICaptureGraphBuilder_SetOutputFileName_Proxy( 
    ICaptureGraphBuilder * This,
    /* [in] */ const GUID *pType,
    /* [in] */ LPCOLESTR lpstrFile,
    /* [out] */ IBaseFilter **ppf,
    /* [out] */ IFileSinkFilter **ppSink);


void __RPC_STUB ICaptureGraphBuilder_SetOutputFileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ICaptureGraphBuilder_RemoteFindInterface_Proxy( 
    ICaptureGraphBuilder * This,
    /* [unique][in] */ const GUID *pCategory,
    /* [in] */ IBaseFilter *pf,
    /* [in] */ REFIID riid,
    /* [out] */ IUnknown **ppint);


void __RPC_STUB ICaptureGraphBuilder_RemoteFindInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICaptureGraphBuilder_RenderStream_Proxy( 
    ICaptureGraphBuilder * This,
    /* [in] */ const GUID *pCategory,
    /* [in] */ IUnknown *pSource,
    /* [in] */ IBaseFilter *pfCompressor,
    /* [in] */ IBaseFilter *pfRenderer);


void __RPC_STUB ICaptureGraphBuilder_RenderStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICaptureGraphBuilder_ControlStream_Proxy( 
    ICaptureGraphBuilder * This,
    /* [in] */ const GUID *pCategory,
    /* [in] */ IBaseFilter *pFilter,
    /* [in] */ REFERENCE_TIME *pstart,
    /* [in] */ REFERENCE_TIME *pstop,
    /* [in] */ WORD wStartCookie,
    /* [in] */ WORD wStopCookie);


void __RPC_STUB ICaptureGraphBuilder_ControlStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICaptureGraphBuilder_AllocCapFile_Proxy( 
    ICaptureGraphBuilder * This,
    /* [in] */ LPCOLESTR lpstr,
    /* [in] */ DWORDLONG dwlSize);


void __RPC_STUB ICaptureGraphBuilder_AllocCapFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICaptureGraphBuilder_CopyCaptureFile_Proxy( 
    ICaptureGraphBuilder * This,
    /* [in] */ LPOLESTR lpwstrOld,
    /* [in] */ LPOLESTR lpwstrNew,
    /* [in] */ int fAllowEscAbort,
    /* [in] */ IAMCopyCaptureFileProgress *pCallback);


void __RPC_STUB ICaptureGraphBuilder_CopyCaptureFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICaptureGraphBuilder_INTERFACE_DEFINED__ */


#ifndef __IAMCopyCaptureFileProgress_INTERFACE_DEFINED__
#define __IAMCopyCaptureFileProgress_INTERFACE_DEFINED__

/* interface IAMCopyCaptureFileProgress */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMCopyCaptureFileProgress;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("670d1d20-a068-11d0-b3f0-00aa003761c5")
    IAMCopyCaptureFileProgress : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Progress( 
            /* [in] */ int iProgress) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMCopyCaptureFileProgressVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMCopyCaptureFileProgress * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMCopyCaptureFileProgress * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMCopyCaptureFileProgress * This);
        
        HRESULT ( STDMETHODCALLTYPE *Progress )( 
            IAMCopyCaptureFileProgress * This,
            /* [in] */ int iProgress);
        
        END_INTERFACE
    } IAMCopyCaptureFileProgressVtbl;

    interface IAMCopyCaptureFileProgress
    {
        CONST_VTBL struct IAMCopyCaptureFileProgressVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMCopyCaptureFileProgress_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMCopyCaptureFileProgress_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMCopyCaptureFileProgress_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMCopyCaptureFileProgress_Progress(This,iProgress)	\
    (This)->lpVtbl -> Progress(This,iProgress)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAMCopyCaptureFileProgress_Progress_Proxy( 
    IAMCopyCaptureFileProgress * This,
    /* [in] */ int iProgress);


void __RPC_STUB IAMCopyCaptureFileProgress_Progress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMCopyCaptureFileProgress_INTERFACE_DEFINED__ */


#ifndef __ICaptureGraphBuilder2_INTERFACE_DEFINED__
#define __ICaptureGraphBuilder2_INTERFACE_DEFINED__

/* interface ICaptureGraphBuilder2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICaptureGraphBuilder2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("93E5A4E0-2D50-11d2-ABFA-00A0C9C6E38D")
    ICaptureGraphBuilder2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFiltergraph( 
            /* [in] */ IGraphBuilder *pfg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFiltergraph( 
            /* [out] */ IGraphBuilder **ppfg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOutputFileName( 
            /* [in] */ const GUID *pType,
            /* [in] */ LPCOLESTR lpstrFile,
            /* [out] */ IBaseFilter **ppf,
            /* [out] */ IFileSinkFilter **ppSink) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE FindInterface( 
            /* [in] */ const GUID *pCategory,
            /* [in] */ const GUID *pType,
            /* [in] */ IBaseFilter *pf,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RenderStream( 
            /* [in] */ const GUID *pCategory,
            /* [in] */ const GUID *pType,
            /* [in] */ IUnknown *pSource,
            /* [in] */ IBaseFilter *pfCompressor,
            /* [in] */ IBaseFilter *pfRenderer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ControlStream( 
            /* [in] */ const GUID *pCategory,
            /* [in] */ const GUID *pType,
            /* [in] */ IBaseFilter *pFilter,
            /* [in] */ REFERENCE_TIME *pstart,
            /* [in] */ REFERENCE_TIME *pstop,
            /* [in] */ WORD wStartCookie,
            /* [in] */ WORD wStopCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocCapFile( 
            /* [in] */ LPCOLESTR lpstr,
            /* [in] */ DWORDLONG dwlSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CopyCaptureFile( 
            /* [in] */ LPOLESTR lpwstrOld,
            /* [in] */ LPOLESTR lpwstrNew,
            /* [in] */ int fAllowEscAbort,
            /* [in] */ IAMCopyCaptureFileProgress *pCallback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindPin( 
            /* [in] */ IUnknown *pSource,
            /* [in] */ PIN_DIRECTION pindir,
            /* [in] */ const GUID *pCategory,
            /* [in] */ const GUID *pType,
            /* [in] */ BOOL fUnconnected,
            /* [in] */ int num,
            /* [out] */ IPin **ppPin) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICaptureGraphBuilder2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICaptureGraphBuilder2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICaptureGraphBuilder2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICaptureGraphBuilder2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFiltergraph )( 
            ICaptureGraphBuilder2 * This,
            /* [in] */ IGraphBuilder *pfg);
        
        HRESULT ( STDMETHODCALLTYPE *GetFiltergraph )( 
            ICaptureGraphBuilder2 * This,
            /* [out] */ IGraphBuilder **ppfg);
        
        HRESULT ( STDMETHODCALLTYPE *SetOutputFileName )( 
            ICaptureGraphBuilder2 * This,
            /* [in] */ const GUID *pType,
            /* [in] */ LPCOLESTR lpstrFile,
            /* [out] */ IBaseFilter **ppf,
            /* [out] */ IFileSinkFilter **ppSink);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *FindInterface )( 
            ICaptureGraphBuilder2 * This,
            /* [in] */ const GUID *pCategory,
            /* [in] */ const GUID *pType,
            /* [in] */ IBaseFilter *pf,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppint);
        
        HRESULT ( STDMETHODCALLTYPE *RenderStream )( 
            ICaptureGraphBuilder2 * This,
            /* [in] */ const GUID *pCategory,
            /* [in] */ const GUID *pType,
            /* [in] */ IUnknown *pSource,
            /* [in] */ IBaseFilter *pfCompressor,
            /* [in] */ IBaseFilter *pfRenderer);
        
        HRESULT ( STDMETHODCALLTYPE *ControlStream )( 
            ICaptureGraphBuilder2 * This,
            /* [in] */ const GUID *pCategory,
            /* [in] */ const GUID *pType,
            /* [in] */ IBaseFilter *pFilter,
            /* [in] */ REFERENCE_TIME *pstart,
            /* [in] */ REFERENCE_TIME *pstop,
            /* [in] */ WORD wStartCookie,
            /* [in] */ WORD wStopCookie);
        
        HRESULT ( STDMETHODCALLTYPE *AllocCapFile )( 
            ICaptureGraphBuilder2 * This,
            /* [in] */ LPCOLESTR lpstr,
            /* [in] */ DWORDLONG dwlSize);
        
        HRESULT ( STDMETHODCALLTYPE *CopyCaptureFile )( 
            ICaptureGraphBuilder2 * This,
            /* [in] */ LPOLESTR lpwstrOld,
            /* [in] */ LPOLESTR lpwstrNew,
            /* [in] */ int fAllowEscAbort,
            /* [in] */ IAMCopyCaptureFileProgress *pCallback);
        
        HRESULT ( STDMETHODCALLTYPE *FindPin )( 
            ICaptureGraphBuilder2 * This,
            /* [in] */ IUnknown *pSource,
            /* [in] */ PIN_DIRECTION pindir,
            /* [in] */ const GUID *pCategory,
            /* [in] */ const GUID *pType,
            /* [in] */ BOOL fUnconnected,
            /* [in] */ int num,
            /* [out] */ IPin **ppPin);
        
        END_INTERFACE
    } ICaptureGraphBuilder2Vtbl;

    interface ICaptureGraphBuilder2
    {
        CONST_VTBL struct ICaptureGraphBuilder2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICaptureGraphBuilder2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICaptureGraphBuilder2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICaptureGraphBuilder2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICaptureGraphBuilder2_SetFiltergraph(This,pfg)	\
    (This)->lpVtbl -> SetFiltergraph(This,pfg)

#define ICaptureGraphBuilder2_GetFiltergraph(This,ppfg)	\
    (This)->lpVtbl -> GetFiltergraph(This,ppfg)

#define ICaptureGraphBuilder2_SetOutputFileName(This,pType,lpstrFile,ppf,ppSink)	\
    (This)->lpVtbl -> SetOutputFileName(This,pType,lpstrFile,ppf,ppSink)

#define ICaptureGraphBuilder2_FindInterface(This,pCategory,pType,pf,riid,ppint)	\
    (This)->lpVtbl -> FindInterface(This,pCategory,pType,pf,riid,ppint)

#define ICaptureGraphBuilder2_RenderStream(This,pCategory,pType,pSource,pfCompressor,pfRenderer)	\
    (This)->lpVtbl -> RenderStream(This,pCategory,pType,pSource,pfCompressor,pfRenderer)

#define ICaptureGraphBuilder2_ControlStream(This,pCategory,pType,pFilter,pstart,pstop,wStartCookie,wStopCookie)	\
    (This)->lpVtbl -> ControlStream(This,pCategory,pType,pFilter,pstart,pstop,wStartCookie,wStopCookie)

#define ICaptureGraphBuilder2_AllocCapFile(This,lpstr,dwlSize)	\
    (This)->lpVtbl -> AllocCapFile(This,lpstr,dwlSize)

#define ICaptureGraphBuilder2_CopyCaptureFile(This,lpwstrOld,lpwstrNew,fAllowEscAbort,pCallback)	\
    (This)->lpVtbl -> CopyCaptureFile(This,lpwstrOld,lpwstrNew,fAllowEscAbort,pCallback)

#define ICaptureGraphBuilder2_FindPin(This,pSource,pindir,pCategory,pType,fUnconnected,num,ppPin)	\
    (This)->lpVtbl -> FindPin(This,pSource,pindir,pCategory,pType,fUnconnected,num,ppPin)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICaptureGraphBuilder2_SetFiltergraph_Proxy( 
    ICaptureGraphBuilder2 * This,
    /* [in] */ IGraphBuilder *pfg);


void __RPC_STUB ICaptureGraphBuilder2_SetFiltergraph_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICaptureGraphBuilder2_GetFiltergraph_Proxy( 
    ICaptureGraphBuilder2 * This,
    /* [out] */ IGraphBuilder **ppfg);


void __RPC_STUB ICaptureGraphBuilder2_GetFiltergraph_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICaptureGraphBuilder2_SetOutputFileName_Proxy( 
    ICaptureGraphBuilder2 * This,
    /* [in] */ const GUID *pType,
    /* [in] */ LPCOLESTR lpstrFile,
    /* [out] */ IBaseFilter **ppf,
    /* [out] */ IFileSinkFilter **ppSink);


void __RPC_STUB ICaptureGraphBuilder2_SetOutputFileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ICaptureGraphBuilder2_RemoteFindInterface_Proxy( 
    ICaptureGraphBuilder2 * This,
    /* [in] */ const GUID *pCategory,
    /* [in] */ const GUID *pType,
    /* [in] */ IBaseFilter *pf,
    /* [in] */ REFIID riid,
    /* [out] */ IUnknown **ppint);


void __RPC_STUB ICaptureGraphBuilder2_RemoteFindInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICaptureGraphBuilder2_RenderStream_Proxy( 
    ICaptureGraphBuilder2 * This,
    /* [in] */ const GUID *pCategory,
    /* [in] */ const GUID *pType,
    /* [in] */ IUnknown *pSource,
    /* [in] */ IBaseFilter *pfCompressor,
    /* [in] */ IBaseFilter *pfRenderer);


void __RPC_STUB ICaptureGraphBuilder2_RenderStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICaptureGraphBuilder2_ControlStream_Proxy( 
    ICaptureGraphBuilder2 * This,
    /* [in] */ const GUID *pCategory,
    /* [in] */ const GUID *pType,
    /* [in] */ IBaseFilter *pFilter,
    /* [in] */ REFERENCE_TIME *pstart,
    /* [in] */ REFERENCE_TIME *pstop,
    /* [in] */ WORD wStartCookie,
    /* [in] */ WORD wStopCookie);


void __RPC_STUB ICaptureGraphBuilder2_ControlStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICaptureGraphBuilder2_AllocCapFile_Proxy( 
    ICaptureGraphBuilder2 * This,
    /* [in] */ LPCOLESTR lpstr,
    /* [in] */ DWORDLONG dwlSize);


void __RPC_STUB ICaptureGraphBuilder2_AllocCapFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICaptureGraphBuilder2_CopyCaptureFile_Proxy( 
    ICaptureGraphBuilder2 * This,
    /* [in] */ LPOLESTR lpwstrOld,
    /* [in] */ LPOLESTR lpwstrNew,
    /* [in] */ int fAllowEscAbort,
    /* [in] */ IAMCopyCaptureFileProgress *pCallback);


void __RPC_STUB ICaptureGraphBuilder2_CopyCaptureFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICaptureGraphBuilder2_FindPin_Proxy( 
    ICaptureGraphBuilder2 * This,
    /* [in] */ IUnknown *pSource,
    /* [in] */ PIN_DIRECTION pindir,
    /* [in] */ const GUID *pCategory,
    /* [in] */ const GUID *pType,
    /* [in] */ BOOL fUnconnected,
    /* [in] */ int num,
    /* [out] */ IPin **ppPin);


void __RPC_STUB ICaptureGraphBuilder2_FindPin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICaptureGraphBuilder2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0149 */
/* [local] */ 


enum _AM_RENSDEREXFLAGS
    {	AM_RENDEREX_RENDERTOEXISTINGRENDERERS	= 0x1
    } ;


extern RPC_IF_HANDLE __MIDL_itf_strmif_0149_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0149_v0_0_s_ifspec;

#ifndef __IFilterGraph2_INTERFACE_DEFINED__
#define __IFilterGraph2_INTERFACE_DEFINED__

/* interface IFilterGraph2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IFilterGraph2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("36b73882-c2c8-11cf-8b46-00805f6cef60")
    IFilterGraph2 : public IGraphBuilder
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddSourceFilterForMoniker( 
            /* [in] */ IMoniker *pMoniker,
            /* [in] */ IBindCtx *pCtx,
            /* [unique][in] */ LPCWSTR lpcwstrFilterName,
            /* [out] */ IBaseFilter **ppFilter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReconnectEx( 
            /* [in] */ IPin *ppin,
            /* [unique][in] */ const AM_MEDIA_TYPE *pmt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RenderEx( 
            /* [in] */ IPin *pPinOut,
            /* [in] */ DWORD dwFlags,
            /* [out][in] */ DWORD *pvContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFilterGraph2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFilterGraph2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFilterGraph2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFilterGraph2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddFilter )( 
            IFilterGraph2 * This,
            /* [in] */ IBaseFilter *pFilter,
            /* [string][in] */ LPCWSTR pName);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveFilter )( 
            IFilterGraph2 * This,
            /* [in] */ IBaseFilter *pFilter);
        
        HRESULT ( STDMETHODCALLTYPE *EnumFilters )( 
            IFilterGraph2 * This,
            /* [out] */ IEnumFilters **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *FindFilterByName )( 
            IFilterGraph2 * This,
            /* [string][in] */ LPCWSTR pName,
            /* [out] */ IBaseFilter **ppFilter);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectDirect )( 
            IFilterGraph2 * This,
            /* [in] */ IPin *ppinOut,
            /* [in] */ IPin *ppinIn,
            /* [unique][in] */ const AM_MEDIA_TYPE *pmt);
        
        HRESULT ( STDMETHODCALLTYPE *Reconnect )( 
            IFilterGraph2 * This,
            /* [in] */ IPin *ppin);
        
        HRESULT ( STDMETHODCALLTYPE *Disconnect )( 
            IFilterGraph2 * This,
            /* [in] */ IPin *ppin);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultSyncSource )( 
            IFilterGraph2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Connect )( 
            IFilterGraph2 * This,
            /* [in] */ IPin *ppinOut,
            /* [in] */ IPin *ppinIn);
        
        HRESULT ( STDMETHODCALLTYPE *Render )( 
            IFilterGraph2 * This,
            /* [in] */ IPin *ppinOut);
        
        HRESULT ( STDMETHODCALLTYPE *RenderFile )( 
            IFilterGraph2 * This,
            /* [in] */ LPCWSTR lpcwstrFile,
            /* [unique][in] */ LPCWSTR lpcwstrPlayList);
        
        HRESULT ( STDMETHODCALLTYPE *AddSourceFilter )( 
            IFilterGraph2 * This,
            /* [in] */ LPCWSTR lpcwstrFileName,
            /* [unique][in] */ LPCWSTR lpcwstrFilterName,
            /* [out] */ IBaseFilter **ppFilter);
        
        HRESULT ( STDMETHODCALLTYPE *SetLogFile )( 
            IFilterGraph2 * This,
            /* [in] */ DWORD_PTR hFile);
        
        HRESULT ( STDMETHODCALLTYPE *Abort )( 
            IFilterGraph2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *ShouldOperationContinue )( 
            IFilterGraph2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddSourceFilterForMoniker )( 
            IFilterGraph2 * This,
            /* [in] */ IMoniker *pMoniker,
            /* [in] */ IBindCtx *pCtx,
            /* [unique][in] */ LPCWSTR lpcwstrFilterName,
            /* [out] */ IBaseFilter **ppFilter);
        
        HRESULT ( STDMETHODCALLTYPE *ReconnectEx )( 
            IFilterGraph2 * This,
            /* [in] */ IPin *ppin,
            /* [unique][in] */ const AM_MEDIA_TYPE *pmt);
        
        HRESULT ( STDMETHODCALLTYPE *RenderEx )( 
            IFilterGraph2 * This,
            /* [in] */ IPin *pPinOut,
            /* [in] */ DWORD dwFlags,
            /* [out][in] */ DWORD *pvContext);
        
        END_INTERFACE
    } IFilterGraph2Vtbl;

    interface IFilterGraph2
    {
        CONST_VTBL struct IFilterGraph2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFilterGraph2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFilterGraph2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFilterGraph2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFilterGraph2_AddFilter(This,pFilter,pName)	\
    (This)->lpVtbl -> AddFilter(This,pFilter,pName)

#define IFilterGraph2_RemoveFilter(This,pFilter)	\
    (This)->lpVtbl -> RemoveFilter(This,pFilter)

#define IFilterGraph2_EnumFilters(This,ppEnum)	\
    (This)->lpVtbl -> EnumFilters(This,ppEnum)

#define IFilterGraph2_FindFilterByName(This,pName,ppFilter)	\
    (This)->lpVtbl -> FindFilterByName(This,pName,ppFilter)

#define IFilterGraph2_ConnectDirect(This,ppinOut,ppinIn,pmt)	\
    (This)->lpVtbl -> ConnectDirect(This,ppinOut,ppinIn,pmt)

#define IFilterGraph2_Reconnect(This,ppin)	\
    (This)->lpVtbl -> Reconnect(This,ppin)

#define IFilterGraph2_Disconnect(This,ppin)	\
    (This)->lpVtbl -> Disconnect(This,ppin)

#define IFilterGraph2_SetDefaultSyncSource(This)	\
    (This)->lpVtbl -> SetDefaultSyncSource(This)


#define IFilterGraph2_Connect(This,ppinOut,ppinIn)	\
    (This)->lpVtbl -> Connect(This,ppinOut,ppinIn)

#define IFilterGraph2_Render(This,ppinOut)	\
    (This)->lpVtbl -> Render(This,ppinOut)

#define IFilterGraph2_RenderFile(This,lpcwstrFile,lpcwstrPlayList)	\
    (This)->lpVtbl -> RenderFile(This,lpcwstrFile,lpcwstrPlayList)

#define IFilterGraph2_AddSourceFilter(This,lpcwstrFileName,lpcwstrFilterName,ppFilter)	\
    (This)->lpVtbl -> AddSourceFilter(This,lpcwstrFileName,lpcwstrFilterName,ppFilter)

#define IFilterGraph2_SetLogFile(This,hFile)	\
    (This)->lpVtbl -> SetLogFile(This,hFile)

#define IFilterGraph2_Abort(This)	\
    (This)->lpVtbl -> Abort(This)

#define IFilterGraph2_ShouldOperationContinue(This)	\
    (This)->lpVtbl -> ShouldOperationContinue(This)


#define IFilterGraph2_AddSourceFilterForMoniker(This,pMoniker,pCtx,lpcwstrFilterName,ppFilter)	\
    (This)->lpVtbl -> AddSourceFilterForMoniker(This,pMoniker,pCtx,lpcwstrFilterName,ppFilter)

#define IFilterGraph2_ReconnectEx(This,ppin,pmt)	\
    (This)->lpVtbl -> ReconnectEx(This,ppin,pmt)

#define IFilterGraph2_RenderEx(This,pPinOut,dwFlags,pvContext)	\
    (This)->lpVtbl -> RenderEx(This,pPinOut,dwFlags,pvContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IFilterGraph2_AddSourceFilterForMoniker_Proxy( 
    IFilterGraph2 * This,
    /* [in] */ IMoniker *pMoniker,
    /* [in] */ IBindCtx *pCtx,
    /* [unique][in] */ LPCWSTR lpcwstrFilterName,
    /* [out] */ IBaseFilter **ppFilter);


void __RPC_STUB IFilterGraph2_AddSourceFilterForMoniker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IFilterGraph2_ReconnectEx_Proxy( 
    IFilterGraph2 * This,
    /* [in] */ IPin *ppin,
    /* [unique][in] */ const AM_MEDIA_TYPE *pmt);


void __RPC_STUB IFilterGraph2_ReconnectEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IFilterGraph2_RenderEx_Proxy( 
    IFilterGraph2 * This,
    /* [in] */ IPin *pPinOut,
    /* [in] */ DWORD dwFlags,
    /* [out][in] */ DWORD *pvContext);


void __RPC_STUB IFilterGraph2_RenderEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFilterGraph2_INTERFACE_DEFINED__ */


#ifndef __IStreamBuilder_INTERFACE_DEFINED__
#define __IStreamBuilder_INTERFACE_DEFINED__

/* interface IStreamBuilder */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IStreamBuilder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868bf-0ad4-11ce-b03a-0020af0ba770")
    IStreamBuilder : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Render( 
            /* [in] */ IPin *ppinOut,
            /* [in] */ IGraphBuilder *pGraph) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Backout( 
            /* [in] */ IPin *ppinOut,
            /* [in] */ IGraphBuilder *pGraph) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStreamBuilderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IStreamBuilder * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IStreamBuilder * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IStreamBuilder * This);
        
        HRESULT ( STDMETHODCALLTYPE *Render )( 
            IStreamBuilder * This,
            /* [in] */ IPin *ppinOut,
            /* [in] */ IGraphBuilder *pGraph);
        
        HRESULT ( STDMETHODCALLTYPE *Backout )( 
            IStreamBuilder * This,
            /* [in] */ IPin *ppinOut,
            /* [in] */ IGraphBuilder *pGraph);
        
        END_INTERFACE
    } IStreamBuilderVtbl;

    interface IStreamBuilder
    {
        CONST_VTBL struct IStreamBuilderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStreamBuilder_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IStreamBuilder_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IStreamBuilder_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IStreamBuilder_Render(This,ppinOut,pGraph)	\
    (This)->lpVtbl -> Render(This,ppinOut,pGraph)

#define IStreamBuilder_Backout(This,ppinOut,pGraph)	\
    (This)->lpVtbl -> Backout(This,ppinOut,pGraph)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IStreamBuilder_Render_Proxy( 
    IStreamBuilder * This,
    /* [in] */ IPin *ppinOut,
    /* [in] */ IGraphBuilder *pGraph);


void __RPC_STUB IStreamBuilder_Render_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStreamBuilder_Backout_Proxy( 
    IStreamBuilder * This,
    /* [in] */ IPin *ppinOut,
    /* [in] */ IGraphBuilder *pGraph);


void __RPC_STUB IStreamBuilder_Backout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IStreamBuilder_INTERFACE_DEFINED__ */


#ifndef __IAsyncReader_INTERFACE_DEFINED__
#define __IAsyncReader_INTERFACE_DEFINED__

/* interface IAsyncReader */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAsyncReader;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868aa-0ad4-11ce-b03a-0020af0ba770")
    IAsyncReader : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RequestAllocator( 
            /* [in] */ IMemAllocator *pPreferred,
            /* [in] */ ALLOCATOR_PROPERTIES *pProps,
            /* [out] */ IMemAllocator **ppActual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Request( 
            /* [in] */ IMediaSample *pSample,
            /* [in] */ DWORD_PTR dwUser) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WaitForNext( 
            /* [in] */ DWORD dwTimeout,
            /* [out] */ IMediaSample **ppSample,
            /* [out] */ DWORD_PTR *pdwUser) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SyncReadAligned( 
            /* [in] */ IMediaSample *pSample) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SyncRead( 
            /* [in] */ LONGLONG llPosition,
            /* [in] */ LONG lLength,
            /* [size_is][out] */ BYTE *pBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Length( 
            /* [out] */ LONGLONG *pTotal,
            /* [out] */ LONGLONG *pAvailable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginFlush( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndFlush( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAsyncReaderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAsyncReader * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAsyncReader * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAsyncReader * This);
        
        HRESULT ( STDMETHODCALLTYPE *RequestAllocator )( 
            IAsyncReader * This,
            /* [in] */ IMemAllocator *pPreferred,
            /* [in] */ ALLOCATOR_PROPERTIES *pProps,
            /* [out] */ IMemAllocator **ppActual);
        
        HRESULT ( STDMETHODCALLTYPE *Request )( 
            IAsyncReader * This,
            /* [in] */ IMediaSample *pSample,
            /* [in] */ DWORD_PTR dwUser);
        
        HRESULT ( STDMETHODCALLTYPE *WaitForNext )( 
            IAsyncReader * This,
            /* [in] */ DWORD dwTimeout,
            /* [out] */ IMediaSample **ppSample,
            /* [out] */ DWORD_PTR *pdwUser);
        
        HRESULT ( STDMETHODCALLTYPE *SyncReadAligned )( 
            IAsyncReader * This,
            /* [in] */ IMediaSample *pSample);
        
        HRESULT ( STDMETHODCALLTYPE *SyncRead )( 
            IAsyncReader * This,
            /* [in] */ LONGLONG llPosition,
            /* [in] */ LONG lLength,
            /* [size_is][out] */ BYTE *pBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *Length )( 
            IAsyncReader * This,
            /* [out] */ LONGLONG *pTotal,
            /* [out] */ LONGLONG *pAvailable);
        
        HRESULT ( STDMETHODCALLTYPE *BeginFlush )( 
            IAsyncReader * This);
        
        HRESULT ( STDMETHODCALLTYPE *EndFlush )( 
            IAsyncReader * This);
        
        END_INTERFACE
    } IAsyncReaderVtbl;

    interface IAsyncReader
    {
        CONST_VTBL struct IAsyncReaderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAsyncReader_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAsyncReader_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAsyncReader_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAsyncReader_RequestAllocator(This,pPreferred,pProps,ppActual)	\
    (This)->lpVtbl -> RequestAllocator(This,pPreferred,pProps,ppActual)

#define IAsyncReader_Request(This,pSample,dwUser)	\
    (This)->lpVtbl -> Request(This,pSample,dwUser)

#define IAsyncReader_WaitForNext(This,dwTimeout,ppSample,pdwUser)	\
    (This)->lpVtbl -> WaitForNext(This,dwTimeout,ppSample,pdwUser)

#define IAsyncReader_SyncReadAligned(This,pSample)	\
    (This)->lpVtbl -> SyncReadAligned(This,pSample)

#define IAsyncReader_SyncRead(This,llPosition,lLength,pBuffer)	\
    (This)->lpVtbl -> SyncRead(This,llPosition,lLength,pBuffer)

#define IAsyncReader_Length(This,pTotal,pAvailable)	\
    (This)->lpVtbl -> Length(This,pTotal,pAvailable)

#define IAsyncReader_BeginFlush(This)	\
    (This)->lpVtbl -> BeginFlush(This)

#define IAsyncReader_EndFlush(This)	\
    (This)->lpVtbl -> EndFlush(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAsyncReader_RequestAllocator_Proxy( 
    IAsyncReader * This,
    /* [in] */ IMemAllocator *pPreferred,
    /* [in] */ ALLOCATOR_PROPERTIES *pProps,
    /* [out] */ IMemAllocator **ppActual);


void __RPC_STUB IAsyncReader_RequestAllocator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAsyncReader_Request_Proxy( 
    IAsyncReader * This,
    /* [in] */ IMediaSample *pSample,
    /* [in] */ DWORD_PTR dwUser);


void __RPC_STUB IAsyncReader_Request_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAsyncReader_WaitForNext_Proxy( 
    IAsyncReader * This,
    /* [in] */ DWORD dwTimeout,
    /* [out] */ IMediaSample **ppSample,
    /* [out] */ DWORD_PTR *pdwUser);


void __RPC_STUB IAsyncReader_WaitForNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAsyncReader_SyncReadAligned_Proxy( 
    IAsyncReader * This,
    /* [in] */ IMediaSample *pSample);


void __RPC_STUB IAsyncReader_SyncReadAligned_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAsyncReader_SyncRead_Proxy( 
    IAsyncReader * This,
    /* [in] */ LONGLONG llPosition,
    /* [in] */ LONG lLength,
    /* [size_is][out] */ BYTE *pBuffer);


void __RPC_STUB IAsyncReader_SyncRead_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAsyncReader_Length_Proxy( 
    IAsyncReader * This,
    /* [out] */ LONGLONG *pTotal,
    /* [out] */ LONGLONG *pAvailable);


void __RPC_STUB IAsyncReader_Length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAsyncReader_BeginFlush_Proxy( 
    IAsyncReader * This);


void __RPC_STUB IAsyncReader_BeginFlush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAsyncReader_EndFlush_Proxy( 
    IAsyncReader * This);


void __RPC_STUB IAsyncReader_EndFlush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAsyncReader_INTERFACE_DEFINED__ */


#ifndef __IGraphVersion_INTERFACE_DEFINED__
#define __IGraphVersion_INTERFACE_DEFINED__

/* interface IGraphVersion */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IGraphVersion;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868ab-0ad4-11ce-b03a-0020af0ba770")
    IGraphVersion : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryVersion( 
            LONG *pVersion) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGraphVersionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGraphVersion * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGraphVersion * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGraphVersion * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryVersion )( 
            IGraphVersion * This,
            LONG *pVersion);
        
        END_INTERFACE
    } IGraphVersionVtbl;

    interface IGraphVersion
    {
        CONST_VTBL struct IGraphVersionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGraphVersion_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGraphVersion_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGraphVersion_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGraphVersion_QueryVersion(This,pVersion)	\
    (This)->lpVtbl -> QueryVersion(This,pVersion)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IGraphVersion_QueryVersion_Proxy( 
    IGraphVersion * This,
    LONG *pVersion);


void __RPC_STUB IGraphVersion_QueryVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGraphVersion_INTERFACE_DEFINED__ */


#ifndef __IResourceConsumer_INTERFACE_DEFINED__
#define __IResourceConsumer_INTERFACE_DEFINED__

/* interface IResourceConsumer */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IResourceConsumer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868ad-0ad4-11ce-b03a-0020af0ba770")
    IResourceConsumer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AcquireResource( 
            /* [in] */ LONG idResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseResource( 
            /* [in] */ LONG idResource) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IResourceConsumerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IResourceConsumer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IResourceConsumer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IResourceConsumer * This);
        
        HRESULT ( STDMETHODCALLTYPE *AcquireResource )( 
            IResourceConsumer * This,
            /* [in] */ LONG idResource);
        
        HRESULT ( STDMETHODCALLTYPE *ReleaseResource )( 
            IResourceConsumer * This,
            /* [in] */ LONG idResource);
        
        END_INTERFACE
    } IResourceConsumerVtbl;

    interface IResourceConsumer
    {
        CONST_VTBL struct IResourceConsumerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IResourceConsumer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IResourceConsumer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IResourceConsumer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IResourceConsumer_AcquireResource(This,idResource)	\
    (This)->lpVtbl -> AcquireResource(This,idResource)

#define IResourceConsumer_ReleaseResource(This,idResource)	\
    (This)->lpVtbl -> ReleaseResource(This,idResource)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IResourceConsumer_AcquireResource_Proxy( 
    IResourceConsumer * This,
    /* [in] */ LONG idResource);


void __RPC_STUB IResourceConsumer_AcquireResource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IResourceConsumer_ReleaseResource_Proxy( 
    IResourceConsumer * This,
    /* [in] */ LONG idResource);


void __RPC_STUB IResourceConsumer_ReleaseResource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IResourceConsumer_INTERFACE_DEFINED__ */


#ifndef __IResourceManager_INTERFACE_DEFINED__
#define __IResourceManager_INTERFACE_DEFINED__

/* interface IResourceManager */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IResourceManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868ac-0ad4-11ce-b03a-0020af0ba770")
    IResourceManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Register( 
            /* [in] */ LPCWSTR pName,
            /* [in] */ LONG cResource,
            /* [out] */ LONG *plToken) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterGroup( 
            /* [in] */ LPCWSTR pName,
            /* [in] */ LONG cResource,
            /* [size_is][in] */ LONG *palTokens,
            /* [out] */ LONG *plToken) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RequestResource( 
            /* [in] */ LONG idResource,
            /* [in] */ IUnknown *pFocusObject,
            /* [in] */ IResourceConsumer *pConsumer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyAcquire( 
            /* [in] */ LONG idResource,
            /* [in] */ IResourceConsumer *pConsumer,
            /* [in] */ HRESULT hr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyRelease( 
            /* [in] */ LONG idResource,
            /* [in] */ IResourceConsumer *pConsumer,
            /* [in] */ BOOL bStillWant) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelRequest( 
            /* [in] */ LONG idResource,
            /* [in] */ IResourceConsumer *pConsumer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFocus( 
            /* [in] */ IUnknown *pFocusObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseFocus( 
            /* [in] */ IUnknown *pFocusObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IResourceManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IResourceManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IResourceManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IResourceManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *Register )( 
            IResourceManager * This,
            /* [in] */ LPCWSTR pName,
            /* [in] */ LONG cResource,
            /* [out] */ LONG *plToken);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterGroup )( 
            IResourceManager * This,
            /* [in] */ LPCWSTR pName,
            /* [in] */ LONG cResource,
            /* [size_is][in] */ LONG *palTokens,
            /* [out] */ LONG *plToken);
        
        HRESULT ( STDMETHODCALLTYPE *RequestResource )( 
            IResourceManager * This,
            /* [in] */ LONG idResource,
            /* [in] */ IUnknown *pFocusObject,
            /* [in] */ IResourceConsumer *pConsumer);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyAcquire )( 
            IResourceManager * This,
            /* [in] */ LONG idResource,
            /* [in] */ IResourceConsumer *pConsumer,
            /* [in] */ HRESULT hr);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyRelease )( 
            IResourceManager * This,
            /* [in] */ LONG idResource,
            /* [in] */ IResourceConsumer *pConsumer,
            /* [in] */ BOOL bStillWant);
        
        HRESULT ( STDMETHODCALLTYPE *CancelRequest )( 
            IResourceManager * This,
            /* [in] */ LONG idResource,
            /* [in] */ IResourceConsumer *pConsumer);
        
        HRESULT ( STDMETHODCALLTYPE *SetFocus )( 
            IResourceManager * This,
            /* [in] */ IUnknown *pFocusObject);
        
        HRESULT ( STDMETHODCALLTYPE *ReleaseFocus )( 
            IResourceManager * This,
            /* [in] */ IUnknown *pFocusObject);
        
        END_INTERFACE
    } IResourceManagerVtbl;

    interface IResourceManager
    {
        CONST_VTBL struct IResourceManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IResourceManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IResourceManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IResourceManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IResourceManager_Register(This,pName,cResource,plToken)	\
    (This)->lpVtbl -> Register(This,pName,cResource,plToken)

#define IResourceManager_RegisterGroup(This,pName,cResource,palTokens,plToken)	\
    (This)->lpVtbl -> RegisterGroup(This,pName,cResource,palTokens,plToken)

#define IResourceManager_RequestResource(This,idResource,pFocusObject,pConsumer)	\
    (This)->lpVtbl -> RequestResource(This,idResource,pFocusObject,pConsumer)

#define IResourceManager_NotifyAcquire(This,idResource,pConsumer,hr)	\
    (This)->lpVtbl -> NotifyAcquire(This,idResource,pConsumer,hr)

#define IResourceManager_NotifyRelease(This,idResource,pConsumer,bStillWant)	\
    (This)->lpVtbl -> NotifyRelease(This,idResource,pConsumer,bStillWant)

#define IResourceManager_CancelRequest(This,idResource,pConsumer)	\
    (This)->lpVtbl -> CancelRequest(This,idResource,pConsumer)

#define IResourceManager_SetFocus(This,pFocusObject)	\
    (This)->lpVtbl -> SetFocus(This,pFocusObject)

#define IResourceManager_ReleaseFocus(This,pFocusObject)	\
    (This)->lpVtbl -> ReleaseFocus(This,pFocusObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IResourceManager_Register_Proxy( 
    IResourceManager * This,
    /* [in] */ LPCWSTR pName,
    /* [in] */ LONG cResource,
    /* [out] */ LONG *plToken);


void __RPC_STUB IResourceManager_Register_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IResourceManager_RegisterGroup_Proxy( 
    IResourceManager * This,
    /* [in] */ LPCWSTR pName,
    /* [in] */ LONG cResource,
    /* [size_is][in] */ LONG *palTokens,
    /* [out] */ LONG *plToken);


void __RPC_STUB IResourceManager_RegisterGroup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IResourceManager_RequestResource_Proxy( 
    IResourceManager * This,
    /* [in] */ LONG idResource,
    /* [in] */ IUnknown *pFocusObject,
    /* [in] */ IResourceConsumer *pConsumer);


void __RPC_STUB IResourceManager_RequestResource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IResourceManager_NotifyAcquire_Proxy( 
    IResourceManager * This,
    /* [in] */ LONG idResource,
    /* [in] */ IResourceConsumer *pConsumer,
    /* [in] */ HRESULT hr);


void __RPC_STUB IResourceManager_NotifyAcquire_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IResourceManager_NotifyRelease_Proxy( 
    IResourceManager * This,
    /* [in] */ LONG idResource,
    /* [in] */ IResourceConsumer *pConsumer,
    /* [in] */ BOOL bStillWant);


void __RPC_STUB IResourceManager_NotifyRelease_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IResourceManager_CancelRequest_Proxy( 
    IResourceManager * This,
    /* [in] */ LONG idResource,
    /* [in] */ IResourceConsumer *pConsumer);


void __RPC_STUB IResourceManager_CancelRequest_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IResourceManager_SetFocus_Proxy( 
    IResourceManager * This,
    /* [in] */ IUnknown *pFocusObject);


void __RPC_STUB IResourceManager_SetFocus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IResourceManager_ReleaseFocus_Proxy( 
    IResourceManager * This,
    /* [in] */ IUnknown *pFocusObject);


void __RPC_STUB IResourceManager_ReleaseFocus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IResourceManager_INTERFACE_DEFINED__ */


#ifndef __IDistributorNotify_INTERFACE_DEFINED__
#define __IDistributorNotify_INTERFACE_DEFINED__

/* interface IDistributorNotify */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDistributorNotify;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56a868af-0ad4-11ce-b03a-0020af0ba770")
    IDistributorNotify : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Run( 
            REFERENCE_TIME tStart) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSyncSource( 
            /* [in] */ IReferenceClock *pClock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyGraphChange( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDistributorNotifyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDistributorNotify * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDistributorNotify * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDistributorNotify * This);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IDistributorNotify * This);
        
        HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IDistributorNotify * This);
        
        HRESULT ( STDMETHODCALLTYPE *Run )( 
            IDistributorNotify * This,
            REFERENCE_TIME tStart);
        
        HRESULT ( STDMETHODCALLTYPE *SetSyncSource )( 
            IDistributorNotify * This,
            /* [in] */ IReferenceClock *pClock);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyGraphChange )( 
            IDistributorNotify * This);
        
        END_INTERFACE
    } IDistributorNotifyVtbl;

    interface IDistributorNotify
    {
        CONST_VTBL struct IDistributorNotifyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDistributorNotify_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDistributorNotify_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDistributorNotify_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDistributorNotify_Stop(This)	\
    (This)->lpVtbl -> Stop(This)

#define IDistributorNotify_Pause(This)	\
    (This)->lpVtbl -> Pause(This)

#define IDistributorNotify_Run(This,tStart)	\
    (This)->lpVtbl -> Run(This,tStart)

#define IDistributorNotify_SetSyncSource(This,pClock)	\
    (This)->lpVtbl -> SetSyncSource(This,pClock)

#define IDistributorNotify_NotifyGraphChange(This)	\
    (This)->lpVtbl -> NotifyGraphChange(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDistributorNotify_Stop_Proxy( 
    IDistributorNotify * This);


void __RPC_STUB IDistributorNotify_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDistributorNotify_Pause_Proxy( 
    IDistributorNotify * This);


void __RPC_STUB IDistributorNotify_Pause_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDistributorNotify_Run_Proxy( 
    IDistributorNotify * This,
    REFERENCE_TIME tStart);


void __RPC_STUB IDistributorNotify_Run_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDistributorNotify_SetSyncSource_Proxy( 
    IDistributorNotify * This,
    /* [in] */ IReferenceClock *pClock);


void __RPC_STUB IDistributorNotify_SetSyncSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDistributorNotify_NotifyGraphChange_Proxy( 
    IDistributorNotify * This);


void __RPC_STUB IDistributorNotify_NotifyGraphChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDistributorNotify_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0156 */
/* [local] */ 

typedef /* [public] */ 
enum __MIDL___MIDL_itf_strmif_0156_0001
    {	AM_STREAM_INFO_START_DEFINED	= 0x1,
	AM_STREAM_INFO_STOP_DEFINED	= 0x2,
	AM_STREAM_INFO_DISCARDING	= 0x4,
	AM_STREAM_INFO_STOP_SEND_EXTRA	= 0x10
    } 	AM_STREAM_INFO_FLAGS;

typedef /* [public][public] */ struct __MIDL___MIDL_itf_strmif_0156_0002
    {
    REFERENCE_TIME tStart;
    REFERENCE_TIME tStop;
    DWORD dwStartCookie;
    DWORD dwStopCookie;
    DWORD dwFlags;
    } 	AM_STREAM_INFO;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0156_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0156_v0_0_s_ifspec;

#ifndef __IAMStreamControl_INTERFACE_DEFINED__
#define __IAMStreamControl_INTERFACE_DEFINED__

/* interface IAMStreamControl */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMStreamControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("36b73881-c2c8-11cf-8b46-00805f6cef60")
    IAMStreamControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE StartAt( 
            /* [in] */ const REFERENCE_TIME *ptStart,
            /* [in] */ DWORD dwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StopAt( 
            /* [in] */ const REFERENCE_TIME *ptStop,
            /* [in] */ BOOL bSendExtra,
            /* [in] */ DWORD dwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInfo( 
            /* [out] */ AM_STREAM_INFO *pInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMStreamControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMStreamControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMStreamControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMStreamControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *StartAt )( 
            IAMStreamControl * This,
            /* [in] */ const REFERENCE_TIME *ptStart,
            /* [in] */ DWORD dwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *StopAt )( 
            IAMStreamControl * This,
            /* [in] */ const REFERENCE_TIME *ptStop,
            /* [in] */ BOOL bSendExtra,
            /* [in] */ DWORD dwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            IAMStreamControl * This,
            /* [out] */ AM_STREAM_INFO *pInfo);
        
        END_INTERFACE
    } IAMStreamControlVtbl;

    interface IAMStreamControl
    {
        CONST_VTBL struct IAMStreamControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMStreamControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMStreamControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMStreamControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMStreamControl_StartAt(This,ptStart,dwCookie)	\
    (This)->lpVtbl -> StartAt(This,ptStart,dwCookie)

#define IAMStreamControl_StopAt(This,ptStop,bSendExtra,dwCookie)	\
    (This)->lpVtbl -> StopAt(This,ptStop,bSendExtra,dwCookie)

#define IAMStreamControl_GetInfo(This,pInfo)	\
    (This)->lpVtbl -> GetInfo(This,pInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAMStreamControl_StartAt_Proxy( 
    IAMStreamControl * This,
    /* [in] */ const REFERENCE_TIME *ptStart,
    /* [in] */ DWORD dwCookie);


void __RPC_STUB IAMStreamControl_StartAt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMStreamControl_StopAt_Proxy( 
    IAMStreamControl * This,
    /* [in] */ const REFERENCE_TIME *ptStop,
    /* [in] */ BOOL bSendExtra,
    /* [in] */ DWORD dwCookie);


void __RPC_STUB IAMStreamControl_StopAt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMStreamControl_GetInfo_Proxy( 
    IAMStreamControl * This,
    /* [out] */ AM_STREAM_INFO *pInfo);


void __RPC_STUB IAMStreamControl_GetInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMStreamControl_INTERFACE_DEFINED__ */


#ifndef __ISeekingPassThru_INTERFACE_DEFINED__
#define __ISeekingPassThru_INTERFACE_DEFINED__

/* interface ISeekingPassThru */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISeekingPassThru;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("36b73883-c2c8-11cf-8b46-00805f6cef60")
    ISeekingPassThru : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Init( 
            /* [in] */ BOOL bSupportRendering,
            /* [in] */ IPin *pPin) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISeekingPassThruVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISeekingPassThru * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISeekingPassThru * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISeekingPassThru * This);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            ISeekingPassThru * This,
            /* [in] */ BOOL bSupportRendering,
            /* [in] */ IPin *pPin);
        
        END_INTERFACE
    } ISeekingPassThruVtbl;

    interface ISeekingPassThru
    {
        CONST_VTBL struct ISeekingPassThruVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISeekingPassThru_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISeekingPassThru_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISeekingPassThru_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISeekingPassThru_Init(This,bSupportRendering,pPin)	\
    (This)->lpVtbl -> Init(This,bSupportRendering,pPin)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISeekingPassThru_Init_Proxy( 
    ISeekingPassThru * This,
    /* [in] */ BOOL bSupportRendering,
    /* [in] */ IPin *pPin);


void __RPC_STUB ISeekingPassThru_Init_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISeekingPassThru_INTERFACE_DEFINED__ */


#ifndef __IAMStreamConfig_INTERFACE_DEFINED__
#define __IAMStreamConfig_INTERFACE_DEFINED__

/* interface IAMStreamConfig */
/* [unique][uuid][object] */ 

typedef struct _VIDEO_STREAM_CONFIG_CAPS
    {
    GUID guid;
    ULONG VideoStandard;
    SIZE InputSize;
    SIZE MinCroppingSize;
    SIZE MaxCroppingSize;
    int CropGranularityX;
    int CropGranularityY;
    int CropAlignX;
    int CropAlignY;
    SIZE MinOutputSize;
    SIZE MaxOutputSize;
    int OutputGranularityX;
    int OutputGranularityY;
    int StretchTapsX;
    int StretchTapsY;
    int ShrinkTapsX;
    int ShrinkTapsY;
    LONGLONG MinFrameInterval;
    LONGLONG MaxFrameInterval;
    LONG MinBitsPerSecond;
    LONG MaxBitsPerSecond;
    } 	VIDEO_STREAM_CONFIG_CAPS;

typedef struct _AUDIO_STREAM_CONFIG_CAPS
    {
    GUID guid;
    ULONG MinimumChannels;
    ULONG MaximumChannels;
    ULONG ChannelsGranularity;
    ULONG MinimumBitsPerSample;
    ULONG MaximumBitsPerSample;
    ULONG BitsPerSampleGranularity;
    ULONG MinimumSampleFrequency;
    ULONG MaximumSampleFrequency;
    ULONG SampleFrequencyGranularity;
    } 	AUDIO_STREAM_CONFIG_CAPS;


EXTERN_C const IID IID_IAMStreamConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C6E13340-30AC-11d0-A18C-00A0C9118956")
    IAMStreamConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFormat( 
            /* [in] */ AM_MEDIA_TYPE *pmt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFormat( 
            /* [out] */ AM_MEDIA_TYPE **ppmt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNumberOfCapabilities( 
            /* [out] */ int *piCount,
            /* [out] */ int *piSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamCaps( 
            /* [in] */ int iIndex,
            /* [out] */ AM_MEDIA_TYPE **ppmt,
            /* [out] */ BYTE *pSCC) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMStreamConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMStreamConfig * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMStreamConfig * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMStreamConfig * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFormat )( 
            IAMStreamConfig * This,
            /* [in] */ AM_MEDIA_TYPE *pmt);
        
        HRESULT ( STDMETHODCALLTYPE *GetFormat )( 
            IAMStreamConfig * This,
            /* [out] */ AM_MEDIA_TYPE **ppmt);
        
        HRESULT ( STDMETHODCALLTYPE *GetNumberOfCapabilities )( 
            IAMStreamConfig * This,
            /* [out] */ int *piCount,
            /* [out] */ int *piSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamCaps )( 
            IAMStreamConfig * This,
            /* [in] */ int iIndex,
            /* [out] */ AM_MEDIA_TYPE **ppmt,
            /* [out] */ BYTE *pSCC);
        
        END_INTERFACE
    } IAMStreamConfigVtbl;

    interface IAMStreamConfig
    {
        CONST_VTBL struct IAMStreamConfigVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMStreamConfig_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMStreamConfig_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMStreamConfig_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMStreamConfig_SetFormat(This,pmt)	\
    (This)->lpVtbl -> SetFormat(This,pmt)

#define IAMStreamConfig_GetFormat(This,ppmt)	\
    (This)->lpVtbl -> GetFormat(This,ppmt)

#define IAMStreamConfig_GetNumberOfCapabilities(This,piCount,piSize)	\
    (This)->lpVtbl -> GetNumberOfCapabilities(This,piCount,piSize)

#define IAMStreamConfig_GetStreamCaps(This,iIndex,ppmt,pSCC)	\
    (This)->lpVtbl -> GetStreamCaps(This,iIndex,ppmt,pSCC)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAMStreamConfig_SetFormat_Proxy( 
    IAMStreamConfig * This,
    /* [in] */ AM_MEDIA_TYPE *pmt);


void __RPC_STUB IAMStreamConfig_SetFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMStreamConfig_GetFormat_Proxy( 
    IAMStreamConfig * This,
    /* [out] */ AM_MEDIA_TYPE **ppmt);


void __RPC_STUB IAMStreamConfig_GetFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMStreamConfig_GetNumberOfCapabilities_Proxy( 
    IAMStreamConfig * This,
    /* [out] */ int *piCount,
    /* [out] */ int *piSize);


void __RPC_STUB IAMStreamConfig_GetNumberOfCapabilities_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMStreamConfig_GetStreamCaps_Proxy( 
    IAMStreamConfig * This,
    /* [in] */ int iIndex,
    /* [out] */ AM_MEDIA_TYPE **ppmt,
    /* [out] */ BYTE *pSCC);


void __RPC_STUB IAMStreamConfig_GetStreamCaps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMStreamConfig_INTERFACE_DEFINED__ */


#ifndef __IConfigInterleaving_INTERFACE_DEFINED__
#define __IConfigInterleaving_INTERFACE_DEFINED__

/* interface IConfigInterleaving */
/* [unique][uuid][object] */ 

typedef /* [public][public][public] */ 
enum __MIDL_IConfigInterleaving_0001
    {	INTERLEAVE_NONE	= 0,
	INTERLEAVE_CAPTURE	= INTERLEAVE_NONE + 1,
	INTERLEAVE_FULL	= INTERLEAVE_CAPTURE + 1,
	INTERLEAVE_NONE_BUFFERED	= INTERLEAVE_FULL + 1
    } 	InterleavingMode;


EXTERN_C const IID IID_IConfigInterleaving;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BEE3D220-157B-11d0-BD23-00A0C911CE86")
    IConfigInterleaving : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE put_Mode( 
            /* [in] */ InterleavingMode mode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_Mode( 
            /* [out] */ InterleavingMode *pMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_Interleaving( 
            /* [in] */ const REFERENCE_TIME *prtInterleave,
            /* [in] */ const REFERENCE_TIME *prtPreroll) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_Interleaving( 
            /* [out] */ REFERENCE_TIME *prtInterleave,
            /* [out] */ REFERENCE_TIME *prtPreroll) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IConfigInterleavingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IConfigInterleaving * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IConfigInterleaving * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IConfigInterleaving * This);
        
        HRESULT ( STDMETHODCALLTYPE *put_Mode )( 
            IConfigInterleaving * This,
            /* [in] */ InterleavingMode mode);
        
        HRESULT ( STDMETHODCALLTYPE *get_Mode )( 
            IConfigInterleaving * This,
            /* [out] */ InterleavingMode *pMode);
        
        HRESULT ( STDMETHODCALLTYPE *put_Interleaving )( 
            IConfigInterleaving * This,
            /* [in] */ const REFERENCE_TIME *prtInterleave,
            /* [in] */ const REFERENCE_TIME *prtPreroll);
        
        HRESULT ( STDMETHODCALLTYPE *get_Interleaving )( 
            IConfigInterleaving * This,
            /* [out] */ REFERENCE_TIME *prtInterleave,
            /* [out] */ REFERENCE_TIME *prtPreroll);
        
        END_INTERFACE
    } IConfigInterleavingVtbl;

    interface IConfigInterleaving
    {
        CONST_VTBL struct IConfigInterleavingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IConfigInterleaving_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IConfigInterleaving_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IConfigInterleaving_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IConfigInterleaving_put_Mode(This,mode)	\
    (This)->lpVtbl -> put_Mode(This,mode)

#define IConfigInterleaving_get_Mode(This,pMode)	\
    (This)->lpVtbl -> get_Mode(This,pMode)

#define IConfigInterleaving_put_Interleaving(This,prtInterleave,prtPreroll)	\
    (This)->lpVtbl -> put_Interleaving(This,prtInterleave,prtPreroll)

#define IConfigInterleaving_get_Interleaving(This,prtInterleave,prtPreroll)	\
    (This)->lpVtbl -> get_Interleaving(This,prtInterleave,prtPreroll)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IConfigInterleaving_put_Mode_Proxy( 
    IConfigInterleaving * This,
    /* [in] */ InterleavingMode mode);


void __RPC_STUB IConfigInterleaving_put_Mode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IConfigInterleaving_get_Mode_Proxy( 
    IConfigInterleaving * This,
    /* [out] */ InterleavingMode *pMode);


void __RPC_STUB IConfigInterleaving_get_Mode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IConfigInterleaving_put_Interleaving_Proxy( 
    IConfigInterleaving * This,
    /* [in] */ const REFERENCE_TIME *prtInterleave,
    /* [in] */ const REFERENCE_TIME *prtPreroll);


void __RPC_STUB IConfigInterleaving_put_Interleaving_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IConfigInterleaving_get_Interleaving_Proxy( 
    IConfigInterleaving * This,
    /* [out] */ REFERENCE_TIME *prtInterleave,
    /* [out] */ REFERENCE_TIME *prtPreroll);


void __RPC_STUB IConfigInterleaving_get_Interleaving_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IConfigInterleaving_INTERFACE_DEFINED__ */


#ifndef __IConfigAviMux_INTERFACE_DEFINED__
#define __IConfigAviMux_INTERFACE_DEFINED__

/* interface IConfigAviMux */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IConfigAviMux;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5ACD6AA0-F482-11ce-8B67-00AA00A3F1A6")
    IConfigAviMux : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetMasterStream( 
            /* [in] */ LONG iStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMasterStream( 
            /* [out] */ LONG *pStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOutputCompatibilityIndex( 
            /* [in] */ BOOL fOldIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputCompatibilityIndex( 
            /* [out] */ BOOL *pfOldIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IConfigAviMuxVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IConfigAviMux * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IConfigAviMux * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IConfigAviMux * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetMasterStream )( 
            IConfigAviMux * This,
            /* [in] */ LONG iStream);
        
        HRESULT ( STDMETHODCALLTYPE *GetMasterStream )( 
            IConfigAviMux * This,
            /* [out] */ LONG *pStream);
        
        HRESULT ( STDMETHODCALLTYPE *SetOutputCompatibilityIndex )( 
            IConfigAviMux * This,
            /* [in] */ BOOL fOldIndex);
        
        HRESULT ( STDMETHODCALLTYPE *GetOutputCompatibilityIndex )( 
            IConfigAviMux * This,
            /* [out] */ BOOL *pfOldIndex);
        
        END_INTERFACE
    } IConfigAviMuxVtbl;

    interface IConfigAviMux
    {
        CONST_VTBL struct IConfigAviMuxVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IConfigAviMux_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IConfigAviMux_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IConfigAviMux_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IConfigAviMux_SetMasterStream(This,iStream)	\
    (This)->lpVtbl -> SetMasterStream(This,iStream)

#define IConfigAviMux_GetMasterStream(This,pStream)	\
    (This)->lpVtbl -> GetMasterStream(This,pStream)

#define IConfigAviMux_SetOutputCompatibilityIndex(This,fOldIndex)	\
    (This)->lpVtbl -> SetOutputCompatibilityIndex(This,fOldIndex)

#define IConfigAviMux_GetOutputCompatibilityIndex(This,pfOldIndex)	\
    (This)->lpVtbl -> GetOutputCompatibilityIndex(This,pfOldIndex)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IConfigAviMux_SetMasterStream_Proxy( 
    IConfigAviMux * This,
    /* [in] */ LONG iStream);


void __RPC_STUB IConfigAviMux_SetMasterStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IConfigAviMux_GetMasterStream_Proxy( 
    IConfigAviMux * This,
    /* [out] */ LONG *pStream);


void __RPC_STUB IConfigAviMux_GetMasterStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IConfigAviMux_SetOutputCompatibilityIndex_Proxy( 
    IConfigAviMux * This,
    /* [in] */ BOOL fOldIndex);


void __RPC_STUB IConfigAviMux_SetOutputCompatibilityIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IConfigAviMux_GetOutputCompatibilityIndex_Proxy( 
    IConfigAviMux * This,
    /* [out] */ BOOL *pfOldIndex);


void __RPC_STUB IConfigAviMux_GetOutputCompatibilityIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IConfigAviMux_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0163 */
/* [local] */ 

typedef /* [public] */ 
enum __MIDL___MIDL_itf_strmif_0163_0001
    {	CompressionCaps_CanQuality	= 0x1,
	CompressionCaps_CanCrunch	= 0x2,
	CompressionCaps_CanKeyFrame	= 0x4,
	CompressionCaps_CanBFrame	= 0x8,
	CompressionCaps_CanWindow	= 0x10
    } 	CompressionCaps;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0163_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0163_v0_0_s_ifspec;

#ifndef __IAMVideoCompression_INTERFACE_DEFINED__
#define __IAMVideoCompression_INTERFACE_DEFINED__

/* interface IAMVideoCompression */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMVideoCompression;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C6E13343-30AC-11d0-A18C-00A0C9118956")
    IAMVideoCompression : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE put_KeyFrameRate( 
            /* [in] */ long KeyFrameRate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_KeyFrameRate( 
            /* [out] */ long *pKeyFrameRate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_PFramesPerKeyFrame( 
            /* [in] */ long PFramesPerKeyFrame) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_PFramesPerKeyFrame( 
            /* [out] */ long *pPFramesPerKeyFrame) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_Quality( 
            /* [in] */ double Quality) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_Quality( 
            /* [out] */ double *pQuality) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_WindowSize( 
            /* [in] */ DWORDLONG WindowSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_WindowSize( 
            /* [out] */ DWORDLONG *pWindowSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInfo( 
            /* [size_is][out] */ WCHAR *pszVersion,
            /* [out][in] */ int *pcbVersion,
            /* [size_is][out] */ LPWSTR pszDescription,
            /* [out][in] */ int *pcbDescription,
            /* [out] */ long *pDefaultKeyFrameRate,
            /* [out] */ long *pDefaultPFramesPerKey,
            /* [out] */ double *pDefaultQuality,
            /* [out] */ long *pCapabilities) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OverrideKeyFrame( 
            /* [in] */ long FrameNumber) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OverrideFrameSize( 
            /* [in] */ long FrameNumber,
            /* [in] */ long Size) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMVideoCompressionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMVideoCompression * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMVideoCompression * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMVideoCompression * This);
        
        HRESULT ( STDMETHODCALLTYPE *put_KeyFrameRate )( 
            IAMVideoCompression * This,
            /* [in] */ long KeyFrameRate);
        
        HRESULT ( STDMETHODCALLTYPE *get_KeyFrameRate )( 
            IAMVideoCompression * This,
            /* [out] */ long *pKeyFrameRate);
        
        HRESULT ( STDMETHODCALLTYPE *put_PFramesPerKeyFrame )( 
            IAMVideoCompression * This,
            /* [in] */ long PFramesPerKeyFrame);
        
        HRESULT ( STDMETHODCALLTYPE *get_PFramesPerKeyFrame )( 
            IAMVideoCompression * This,
            /* [out] */ long *pPFramesPerKeyFrame);
        
        HRESULT ( STDMETHODCALLTYPE *put_Quality )( 
            IAMVideoCompression * This,
            /* [in] */ double Quality);
        
        HRESULT ( STDMETHODCALLTYPE *get_Quality )( 
            IAMVideoCompression * This,
            /* [out] */ double *pQuality);
        
        HRESULT ( STDMETHODCALLTYPE *put_WindowSize )( 
            IAMVideoCompression * This,
            /* [in] */ DWORDLONG WindowSize);
        
        HRESULT ( STDMETHODCALLTYPE *get_WindowSize )( 
            IAMVideoCompression * This,
            /* [out] */ DWORDLONG *pWindowSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            IAMVideoCompression * This,
            /* [size_is][out] */ WCHAR *pszVersion,
            /* [out][in] */ int *pcbVersion,
            /* [size_is][out] */ LPWSTR pszDescription,
            /* [out][in] */ int *pcbDescription,
            /* [out] */ long *pDefaultKeyFrameRate,
            /* [out] */ long *pDefaultPFramesPerKey,
            /* [out] */ double *pDefaultQuality,
            /* [out] */ long *pCapabilities);
        
        HRESULT ( STDMETHODCALLTYPE *OverrideKeyFrame )( 
            IAMVideoCompression * This,
            /* [in] */ long FrameNumber);
        
        HRESULT ( STDMETHODCALLTYPE *OverrideFrameSize )( 
            IAMVideoCompression * This,
            /* [in] */ long FrameNumber,
            /* [in] */ long Size);
        
        END_INTERFACE
    } IAMVideoCompressionVtbl;

    interface IAMVideoCompression
    {
        CONST_VTBL struct IAMVideoCompressionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMVideoCompression_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMVideoCompression_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMVideoCompression_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMVideoCompression_put_KeyFrameRate(This,KeyFrameRate)	\
    (This)->lpVtbl -> put_KeyFrameRate(This,KeyFrameRate)

#define IAMVideoCompression_get_KeyFrameRate(This,pKeyFrameRate)	\
    (This)->lpVtbl -> get_KeyFrameRate(This,pKeyFrameRate)

#define IAMVideoCompression_put_PFramesPerKeyFrame(This,PFramesPerKeyFrame)	\
    (This)->lpVtbl -> put_PFramesPerKeyFrame(This,PFramesPerKeyFrame)

#define IAMVideoCompression_get_PFramesPerKeyFrame(This,pPFramesPerKeyFrame)	\
    (This)->lpVtbl -> get_PFramesPerKeyFrame(This,pPFramesPerKeyFrame)

#define IAMVideoCompression_put_Quality(This,Quality)	\
    (This)->lpVtbl -> put_Quality(This,Quality)

#define IAMVideoCompression_get_Quality(This,pQuality)	\
    (This)->lpVtbl -> get_Quality(This,pQuality)

#define IAMVideoCompression_put_WindowSize(This,WindowSize)	\
    (This)->lpVtbl -> put_WindowSize(This,WindowSize)

#define IAMVideoCompression_get_WindowSize(This,pWindowSize)	\
    (This)->lpVtbl -> get_WindowSize(This,pWindowSize)

#define IAMVideoCompression_GetInfo(This,pszVersion,pcbVersion,pszDescription,pcbDescription,pDefaultKeyFrameRate,pDefaultPFramesPerKey,pDefaultQuality,pCapabilities)	\
    (This)->lpVtbl -> GetInfo(This,pszVersion,pcbVersion,pszDescription,pcbDescription,pDefaultKeyFrameRate,pDefaultPFramesPerKey,pDefaultQuality,pCapabilities)

#define IAMVideoCompression_OverrideKeyFrame(This,FrameNumber)	\
    (This)->lpVtbl -> OverrideKeyFrame(This,FrameNumber)

#define IAMVideoCompression_OverrideFrameSize(This,FrameNumber,Size)	\
    (This)->lpVtbl -> OverrideFrameSize(This,FrameNumber,Size)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAMVideoCompression_put_KeyFrameRate_Proxy( 
    IAMVideoCompression * This,
    /* [in] */ long KeyFrameRate);


void __RPC_STUB IAMVideoCompression_put_KeyFrameRate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMVideoCompression_get_KeyFrameRate_Proxy( 
    IAMVideoCompression * This,
    /* [out] */ long *pKeyFrameRate);


void __RPC_STUB IAMVideoCompression_get_KeyFrameRate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMVideoCompression_put_PFramesPerKeyFrame_Proxy( 
    IAMVideoCompression * This,
    /* [in] */ long PFramesPerKeyFrame);


void __RPC_STUB IAMVideoCompression_put_PFramesPerKeyFrame_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMVideoCompression_get_PFramesPerKeyFrame_Proxy( 
    IAMVideoCompression * This,
    /* [out] */ long *pPFramesPerKeyFrame);


void __RPC_STUB IAMVideoCompression_get_PFramesPerKeyFrame_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMVideoCompression_put_Quality_Proxy( 
    IAMVideoCompression * This,
    /* [in] */ double Quality);


void __RPC_STUB IAMVideoCompression_put_Quality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMVideoCompression_get_Quality_Proxy( 
    IAMVideoCompression * This,
    /* [out] */ double *pQuality);


void __RPC_STUB IAMVideoCompression_get_Quality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMVideoCompression_put_WindowSize_Proxy( 
    IAMVideoCompression * This,
    /* [in] */ DWORDLONG WindowSize);


void __RPC_STUB IAMVideoCompression_put_WindowSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMVideoCompression_get_WindowSize_Proxy( 
    IAMVideoCompression * This,
    /* [out] */ DWORDLONG *pWindowSize);


void __RPC_STUB IAMVideoCompression_get_WindowSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMVideoCompression_GetInfo_Proxy( 
    IAMVideoCompression * This,
    /* [size_is][out] */ WCHAR *pszVersion,
    /* [out][in] */ int *pcbVersion,
    /* [size_is][out] */ LPWSTR pszDescription,
    /* [out][in] */ int *pcbDescription,
    /* [out] */ long *pDefaultKeyFrameRate,
    /* [out] */ long *pDefaultPFramesPerKey,
    /* [out] */ double *pDefaultQuality,
    /* [out] */ long *pCapabilities);


void __RPC_STUB IAMVideoCompression_GetInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMVideoCompression_OverrideKeyFrame_Proxy( 
    IAMVideoCompression * This,
    /* [in] */ long FrameNumber);


void __RPC_STUB IAMVideoCompression_OverrideKeyFrame_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMVideoCompression_OverrideFrameSize_Proxy( 
    IAMVideoCompression * This,
    /* [in] */ long FrameNumber,
    /* [in] */ long Size);


void __RPC_STUB IAMVideoCompression_OverrideFrameSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMVideoCompression_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0164 */
/* [local] */ 

typedef /* [public] */ 
enum __MIDL___MIDL_itf_strmif_0164_0001
    {	VfwCaptureDialog_Source	= 0x1,
	VfwCaptureDialog_Format	= 0x2,
	VfwCaptureDialog_Display	= 0x4
    } 	VfwCaptureDialogs;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_strmif_0164_0002
    {	VfwCompressDialog_Config	= 0x1,
	VfwCompressDialog_About	= 0x2,
	VfwCompressDialog_QueryConfig	= 0x4,
	VfwCompressDialog_QueryAbout	= 0x8
    } 	VfwCompressDialogs;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0164_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0164_v0_0_s_ifspec;

#ifndef __IAMVfwCaptureDialogs_INTERFACE_DEFINED__
#define __IAMVfwCaptureDialogs_INTERFACE_DEFINED__

/* interface IAMVfwCaptureDialogs */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IAMVfwCaptureDialogs;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D8D715A0-6E5E-11D0-B3F0-00AA003761C5")
    IAMVfwCaptureDialogs : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE HasDialog( 
            /* [in] */ int iDialog) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShowDialog( 
            /* [in] */ int iDialog,
            /* [in] */ HWND hwnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SendDriverMessage( 
            /* [in] */ int iDialog,
            /* [in] */ int uMsg,
            /* [in] */ long dw1,
            /* [in] */ long dw2) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMVfwCaptureDialogsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMVfwCaptureDialogs * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMVfwCaptureDialogs * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMVfwCaptureDialogs * This);
        
        HRESULT ( STDMETHODCALLTYPE *HasDialog )( 
            IAMVfwCaptureDialogs * This,
            /* [in] */ int iDialog);
        
        HRESULT ( STDMETHODCALLTYPE *ShowDialog )( 
            IAMVfwCaptureDialogs * This,
            /* [in] */ int iDialog,
            /* [in] */ HWND hwnd);
        
        HRESULT ( STDMETHODCALLTYPE *SendDriverMessage )( 
            IAMVfwCaptureDialogs * This,
            /* [in] */ int iDialog,
            /* [in] */ int uMsg,
            /* [in] */ long dw1,
            /* [in] */ long dw2);
        
        END_INTERFACE
    } IAMVfwCaptureDialogsVtbl;

    interface IAMVfwCaptureDialogs
    {
        CONST_VTBL struct IAMVfwCaptureDialogsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMVfwCaptureDialogs_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMVfwCaptureDialogs_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMVfwCaptureDialogs_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMVfwCaptureDialogs_HasDialog(This,iDialog)	\
    (This)->lpVtbl -> HasDialog(This,iDialog)

#define IAMVfwCaptureDialogs_ShowDialog(This,iDialog,hwnd)	\
    (This)->lpVtbl -> ShowDialog(This,iDialog,hwnd)

#define IAMVfwCaptureDialogs_SendDriverMessage(This,iDialog,uMsg,dw1,dw2)	\
    (This)->lpVtbl -> SendDriverMessage(This,iDialog,uMsg,dw1,dw2)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAMVfwCaptureDialogs_HasDialog_Proxy( 
    IAMVfwCaptureDialogs * This,
    /* [in] */ int iDialog);


void __RPC_STUB IAMVfwCaptureDialogs_HasDialog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMVfwCaptureDialogs_ShowDialog_Proxy( 
    IAMVfwCaptureDialogs * This,
    /* [in] */ int iDialog,
    /* [in] */ HWND hwnd);


void __RPC_STUB IAMVfwCaptureDialogs_ShowDialog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMVfwCaptureDialogs_SendDriverMessage_Proxy( 
    IAMVfwCaptureDialogs * This,
    /* [in] */ int iDialog,
    /* [in] */ int uMsg,
    /* [in] */ long dw1,
    /* [in] */ long dw2);


void __RPC_STUB IAMVfwCaptureDialogs_SendDriverMessage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMVfwCaptureDialogs_INTERFACE_DEFINED__ */


#ifndef __IAMVfwCompressDialogs_INTERFACE_DEFINED__
#define __IAMVfwCompressDialogs_INTERFACE_DEFINED__

/* interface IAMVfwCompressDialogs */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IAMVfwCompressDialogs;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D8D715A3-6E5E-11D0-B3F0-00AA003761C5")
    IAMVfwCompressDialogs : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ShowDialog( 
            /* [in] */ int iDialog,
            /* [in] */ HWND hwnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetState( 
            /* [size_is][out] */ LPVOID pState,
            /* [out][in] */ int *pcbState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetState( 
            /* [size_is][in] */ LPVOID pState,
            /* [in] */ int cbState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SendDriverMessage( 
            /* [in] */ int uMsg,
            /* [in] */ long dw1,
            /* [in] */ long dw2) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMVfwCompressDialogsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMVfwCompressDialogs * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMVfwCompressDialogs * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMVfwCompressDialogs * This);
        
        HRESULT ( STDMETHODCALLTYPE *ShowDialog )( 
            IAMVfwCompressDialogs * This,
            /* [in] */ int iDialog,
            /* [in] */ HWND hwnd);
        
        HRESULT ( STDMETHODCALLTYPE *GetState )( 
            IAMVfwCompressDialogs * This,
            /* [size_is][out] */ LPVOID pState,
            /* [out][in] */ int *pcbState);
        
        HRESULT ( STDMETHODCALLTYPE *SetState )( 
            IAMVfwCompressDialogs * This,
            /* [size_is][in] */ LPVOID pState,
            /* [in] */ int cbState);
        
        HRESULT ( STDMETHODCALLTYPE *SendDriverMessage )( 
            IAMVfwCompressDialogs * This,
            /* [in] */ int uMsg,
            /* [in] */ long dw1,
            /* [in] */ long dw2);
        
        END_INTERFACE
    } IAMVfwCompressDialogsVtbl;

    interface IAMVfwCompressDialogs
    {
        CONST_VTBL struct IAMVfwCompressDialogsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMVfwCompressDialogs_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMVfwCompressDialogs_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMVfwCompressDialogs_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMVfwCompressDialogs_ShowDialog(This,iDialog,hwnd)	\
    (This)->lpVtbl -> ShowDialog(This,iDialog,hwnd)

#define IAMVfwCompressDialogs_GetState(This,pState,pcbState)	\
    (This)->lpVtbl -> GetState(This,pState,pcbState)

#define IAMVfwCompressDialogs_SetState(This,pState,cbState)	\
    (This)->lpVtbl -> SetState(This,pState,cbState)

#define IAMVfwCompressDialogs_SendDriverMessage(This,uMsg,dw1,dw2)	\
    (This)->lpVtbl -> SendDriverMessage(This,uMsg,dw1,dw2)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAMVfwCompressDialogs_ShowDialog_Proxy( 
    IAMVfwCompressDialogs * This,
    /* [in] */ int iDialog,
    /* [in] */ HWND hwnd);


void __RPC_STUB IAMVfwCompressDialogs_ShowDialog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMVfwCompressDialogs_GetState_Proxy( 
    IAMVfwCompressDialogs * This,
    /* [size_is][out] */ LPVOID pState,
    /* [out][in] */ int *pcbState);


void __RPC_STUB IAMVfwCompressDialogs_GetState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMVfwCompressDialogs_SetState_Proxy( 
    IAMVfwCompressDialogs * This,
    /* [size_is][in] */ LPVOID pState,
    /* [in] */ int cbState);


void __RPC_STUB IAMVfwCompressDialogs_SetState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMVfwCompressDialogs_SendDriverMessage_Proxy( 
    IAMVfwCompressDialogs * This,
    /* [in] */ int uMsg,
    /* [in] */ long dw1,
    /* [in] */ long dw2);


void __RPC_STUB IAMVfwCompressDialogs_SendDriverMessage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMVfwCompressDialogs_INTERFACE_DEFINED__ */


#ifndef __IAMDroppedFrames_INTERFACE_DEFINED__
#define __IAMDroppedFrames_INTERFACE_DEFINED__

/* interface IAMDroppedFrames */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMDroppedFrames;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C6E13344-30AC-11d0-A18C-00A0C9118956")
    IAMDroppedFrames : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNumDropped( 
            /* [out] */ long *plDropped) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNumNotDropped( 
            /* [out] */ long *plNotDropped) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDroppedInfo( 
            /* [in] */ long lSize,
            /* [out] */ long *plArray,
            /* [out] */ long *plNumCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAverageFrameSize( 
            /* [out] */ long *plAverageSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMDroppedFramesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMDroppedFrames * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMDroppedFrames * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMDroppedFrames * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetNumDropped )( 
            IAMDroppedFrames * This,
            /* [out] */ long *plDropped);
        
        HRESULT ( STDMETHODCALLTYPE *GetNumNotDropped )( 
            IAMDroppedFrames * This,
            /* [out] */ long *plNotDropped);
        
        HRESULT ( STDMETHODCALLTYPE *GetDroppedInfo )( 
            IAMDroppedFrames * This,
            /* [in] */ long lSize,
            /* [out] */ long *plArray,
            /* [out] */ long *plNumCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetAverageFrameSize )( 
            IAMDroppedFrames * This,
            /* [out] */ long *plAverageSize);
        
        END_INTERFACE
    } IAMDroppedFramesVtbl;

    interface IAMDroppedFrames
    {
        CONST_VTBL struct IAMDroppedFramesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMDroppedFrames_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMDroppedFrames_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMDroppedFrames_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMDroppedFrames_GetNumDropped(This,plDropped)	\
    (This)->lpVtbl -> GetNumDropped(This,plDropped)

#define IAMDroppedFrames_GetNumNotDropped(This,plNotDropped)	\
    (This)->lpVtbl -> GetNumNotDropped(This,plNotDropped)

#define IAMDroppedFrames_GetDroppedInfo(This,lSize,plArray,plNumCopied)	\
    (This)->lpVtbl -> GetDroppedInfo(This,lSize,plArray,plNumCopied)

#define IAMDroppedFrames_GetAverageFrameSize(This,plAverageSize)	\
    (This)->lpVtbl -> GetAverageFrameSize(This,plAverageSize)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAMDroppedFrames_GetNumDropped_Proxy( 
    IAMDroppedFrames * This,
    /* [out] */ long *plDropped);


void __RPC_STUB IAMDroppedFrames_GetNumDropped_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMDroppedFrames_GetNumNotDropped_Proxy( 
    IAMDroppedFrames * This,
    /* [out] */ long *plNotDropped);


void __RPC_STUB IAMDroppedFrames_GetNumNotDropped_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMDroppedFrames_GetDroppedInfo_Proxy( 
    IAMDroppedFrames * This,
    /* [in] */ long lSize,
    /* [out] */ long *plArray,
    /* [out] */ long *plNumCopied);


void __RPC_STUB IAMDroppedFrames_GetDroppedInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMDroppedFrames_GetAverageFrameSize_Proxy( 
    IAMDroppedFrames * This,
    /* [out] */ long *plAverageSize);


void __RPC_STUB IAMDroppedFrames_GetAverageFrameSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMDroppedFrames_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0167 */
/* [local] */ 

#define AMF_AUTOMATICGAIN -1.0


extern RPC_IF_HANDLE __MIDL_itf_strmif_0167_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0167_v0_0_s_ifspec;

#ifndef __IAMAudioInputMixer_INTERFACE_DEFINED__
#define __IAMAudioInputMixer_INTERFACE_DEFINED__

/* interface IAMAudioInputMixer */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMAudioInputMixer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("54C39221-8380-11d0-B3F0-00AA003761C5")
    IAMAudioInputMixer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE put_Enable( 
            /* [in] */ BOOL fEnable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_Enable( 
            /* [out] */ BOOL *pfEnable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_Mono( 
            /* [in] */ BOOL fMono) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_Mono( 
            /* [out] */ BOOL *pfMono) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_MixLevel( 
            /* [in] */ double Level) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_MixLevel( 
            /* [out] */ double *pLevel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_Pan( 
            /* [in] */ double Pan) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_Pan( 
            /* [out] */ double *pPan) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_Loudness( 
            /* [in] */ BOOL fLoudness) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_Loudness( 
            /* [out] */ BOOL *pfLoudness) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_Treble( 
            /* [in] */ double Treble) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_Treble( 
            /* [out] */ double *pTreble) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_TrebleRange( 
            /* [out] */ double *pRange) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_Bass( 
            /* [in] */ double Bass) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_Bass( 
            /* [out] */ double *pBass) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_BassRange( 
            /* [out] */ double *pRange) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMAudioInputMixerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMAudioInputMixer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMAudioInputMixer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMAudioInputMixer * This);
        
        HRESULT ( STDMETHODCALLTYPE *put_Enable )( 
            IAMAudioInputMixer * This,
            /* [in] */ BOOL fEnable);
        
        HRESULT ( STDMETHODCALLTYPE *get_Enable )( 
            IAMAudioInputMixer * This,
            /* [out] */ BOOL *pfEnable);
        
        HRESULT ( STDMETHODCALLTYPE *put_Mono )( 
            IAMAudioInputMixer * This,
            /* [in] */ BOOL fMono);
        
        HRESULT ( STDMETHODCALLTYPE *get_Mono )( 
            IAMAudioInputMixer * This,
            /* [out] */ BOOL *pfMono);
        
        HRESULT ( STDMETHODCALLTYPE *put_MixLevel )( 
            IAMAudioInputMixer * This,
            /* [in] */ double Level);
        
        HRESULT ( STDMETHODCALLTYPE *get_MixLevel )( 
            IAMAudioInputMixer * This,
            /* [out] */ double *pLevel);
        
        HRESULT ( STDMETHODCALLTYPE *put_Pan )( 
            IAMAudioInputMixer * This,
            /* [in] */ double Pan);
        
        HRESULT ( STDMETHODCALLTYPE *get_Pan )( 
            IAMAudioInputMixer * This,
            /* [out] */ double *pPan);
        
        HRESULT ( STDMETHODCALLTYPE *put_Loudness )( 
            IAMAudioInputMixer * This,
            /* [in] */ BOOL fLoudness);
        
        HRESULT ( STDMETHODCALLTYPE *get_Loudness )( 
            IAMAudioInputMixer * This,
            /* [out] */ BOOL *pfLoudness);
        
        HRESULT ( STDMETHODCALLTYPE *put_Treble )( 
            IAMAudioInputMixer * This,
            /* [in] */ double Treble);
        
        HRESULT ( STDMETHODCALLTYPE *get_Treble )( 
            IAMAudioInputMixer * This,
            /* [out] */ double *pTreble);
        
        HRESULT ( STDMETHODCALLTYPE *get_TrebleRange )( 
            IAMAudioInputMixer * This,
            /* [out] */ double *pRange);
        
        HRESULT ( STDMETHODCALLTYPE *put_Bass )( 
            IAMAudioInputMixer * This,
            /* [in] */ double Bass);
        
        HRESULT ( STDMETHODCALLTYPE *get_Bass )( 
            IAMAudioInputMixer * This,
            /* [out] */ double *pBass);
        
        HRESULT ( STDMETHODCALLTYPE *get_BassRange )( 
            IAMAudioInputMixer * This,
            /* [out] */ double *pRange);
        
        END_INTERFACE
    } IAMAudioInputMixerVtbl;

    interface IAMAudioInputMixer
    {
        CONST_VTBL struct IAMAudioInputMixerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMAudioInputMixer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMAudioInputMixer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMAudioInputMixer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMAudioInputMixer_put_Enable(This,fEnable)	\
    (This)->lpVtbl -> put_Enable(This,fEnable)

#define IAMAudioInputMixer_get_Enable(This,pfEnable)	\
    (This)->lpVtbl -> get_Enable(This,pfEnable)

#define IAMAudioInputMixer_put_Mono(This,fMono)	\
    (This)->lpVtbl -> put_Mono(This,fMono)

#define IAMAudioInputMixer_get_Mono(This,pfMono)	\
    (This)->lpVtbl -> get_Mono(This,pfMono)

#define IAMAudioInputMixer_put_MixLevel(This,Level)	\
    (This)->lpVtbl -> put_MixLevel(This,Level)

#define IAMAudioInputMixer_get_MixLevel(This,pLevel)	\
    (This)->lpVtbl -> get_MixLevel(This,pLevel)

#define IAMAudioInputMixer_put_Pan(This,Pan)	\
    (This)->lpVtbl -> put_Pan(This,Pan)

#define IAMAudioInputMixer_get_Pan(This,pPan)	\
    (This)->lpVtbl -> get_Pan(This,pPan)

#define IAMAudioInputMixer_put_Loudness(This,fLoudness)	\
    (This)->lpVtbl -> put_Loudness(This,fLoudness)

#define IAMAudioInputMixer_get_Loudness(This,pfLoudness)	\
    (This)->lpVtbl -> get_Loudness(This,pfLoudness)

#define IAMAudioInputMixer_put_Treble(This,Treble)	\
    (This)->lpVtbl -> put_Treble(This,Treble)

#define IAMAudioInputMixer_get_Treble(This,pTreble)	\
    (This)->lpVtbl -> get_Treble(This,pTreble)

#define IAMAudioInputMixer_get_TrebleRange(This,pRange)	\
    (This)->lpVtbl -> get_TrebleRange(This,pRange)

#define IAMAudioInputMixer_put_Bass(This,Bass)	\
    (This)->lpVtbl -> put_Bass(This,Bass)

#define IAMAudioInputMixer_get_Bass(This,pBass)	\
    (This)->lpVtbl -> get_Bass(This,pBass)

#define IAMAudioInputMixer_get_BassRange(This,pRange)	\
    (This)->lpVtbl -> get_BassRange(This,pRange)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAMAudioInputMixer_put_Enable_Proxy( 
    IAMAudioInputMixer * This,
    /* [in] */ BOOL fEnable);


void __RPC_STUB IAMAudioInputMixer_put_Enable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMAudioInputMixer_get_Enable_Proxy( 
    IAMAudioInputMixer * This,
    /* [out] */ BOOL *pfEnable);


void __RPC_STUB IAMAudioInputMixer_get_Enable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMAudioInputMixer_put_Mono_Proxy( 
    IAMAudioInputMixer * This,
    /* [in] */ BOOL fMono);


void __RPC_STUB IAMAudioInputMixer_put_Mono_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMAudioInputMixer_get_Mono_Proxy( 
    IAMAudioInputMixer * This,
    /* [out] */ BOOL *pfMono);


void __RPC_STUB IAMAudioInputMixer_get_Mono_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMAudioInputMixer_put_MixLevel_Proxy( 
    IAMAudioInputMixer * This,
    /* [in] */ double Level);


void __RPC_STUB IAMAudioInputMixer_put_MixLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMAudioInputMixer_get_MixLevel_Proxy( 
    IAMAudioInputMixer * This,
    /* [out] */ double *pLevel);


void __RPC_STUB IAMAudioInputMixer_get_MixLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMAudioInputMixer_put_Pan_Proxy( 
    IAMAudioInputMixer * This,
    /* [in] */ double Pan);


void __RPC_STUB IAMAudioInputMixer_put_Pan_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMAudioInputMixer_get_Pan_Proxy( 
    IAMAudioInputMixer * This,
    /* [out] */ double *pPan);


void __RPC_STUB IAMAudioInputMixer_get_Pan_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMAudioInputMixer_put_Loudness_Proxy( 
    IAMAudioInputMixer * This,
    /* [in] */ BOOL fLoudness);


void __RPC_STUB IAMAudioInputMixer_put_Loudness_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMAudioInputMixer_get_Loudness_Proxy( 
    IAMAudioInputMixer * This,
    /* [out] */ BOOL *pfLoudness);


void __RPC_STUB IAMAudioInputMixer_get_Loudness_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMAudioInputMixer_put_Treble_Proxy( 
    IAMAudioInputMixer * This,
    /* [in] */ double Treble);


void __RPC_STUB IAMAudioInputMixer_put_Treble_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMAudioInputMixer_get_Treble_Proxy( 
    IAMAudioInputMixer * This,
    /* [out] */ double *pTreble);


void __RPC_STUB IAMAudioInputMixer_get_Treble_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMAudioInputMixer_get_TrebleRange_Proxy( 
    IAMAudioInputMixer * This,
    /* [out] */ double *pRange);


void __RPC_STUB IAMAudioInputMixer_get_TrebleRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMAudioInputMixer_put_Bass_Proxy( 
    IAMAudioInputMixer * This,
    /* [in] */ double Bass);


void __RPC_STUB IAMAudioInputMixer_put_Bass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMAudioInputMixer_get_Bass_Proxy( 
    IAMAudioInputMixer * This,
    /* [out] */ double *pBass);


void __RPC_STUB IAMAudioInputMixer_get_Bass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMAudioInputMixer_get_BassRange_Proxy( 
    IAMAudioInputMixer * This,
    /* [out] */ double *pRange);


void __RPC_STUB IAMAudioInputMixer_get_BassRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMAudioInputMixer_INTERFACE_DEFINED__ */


#ifndef __IAMBufferNegotiation_INTERFACE_DEFINED__
#define __IAMBufferNegotiation_INTERFACE_DEFINED__

/* interface IAMBufferNegotiation */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMBufferNegotiation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56ED71A0-AF5F-11D0-B3F0-00AA003761C5")
    IAMBufferNegotiation : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SuggestAllocatorProperties( 
            /* [in] */ const ALLOCATOR_PROPERTIES *pprop) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAllocatorProperties( 
            /* [out] */ ALLOCATOR_PROPERTIES *pprop) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMBufferNegotiationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMBufferNegotiation * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMBufferNegotiation * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMBufferNegotiation * This);
        
        HRESULT ( STDMETHODCALLTYPE *SuggestAllocatorProperties )( 
            IAMBufferNegotiation * This,
            /* [in] */ const ALLOCATOR_PROPERTIES *pprop);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocatorProperties )( 
            IAMBufferNegotiation * This,
            /* [out] */ ALLOCATOR_PROPERTIES *pprop);
        
        END_INTERFACE
    } IAMBufferNegotiationVtbl;

    interface IAMBufferNegotiation
    {
        CONST_VTBL struct IAMBufferNegotiationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMBufferNegotiation_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMBufferNegotiation_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMBufferNegotiation_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMBufferNegotiation_SuggestAllocatorProperties(This,pprop)	\
    (This)->lpVtbl -> SuggestAllocatorProperties(This,pprop)

#define IAMBufferNegotiation_GetAllocatorProperties(This,pprop)	\
    (This)->lpVtbl -> GetAllocatorProperties(This,pprop)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAMBufferNegotiation_SuggestAllocatorProperties_Proxy( 
    IAMBufferNegotiation * This,
    /* [in] */ const ALLOCATOR_PROPERTIES *pprop);


void __RPC_STUB IAMBufferNegotiation_SuggestAllocatorProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMBufferNegotiation_GetAllocatorProperties_Proxy( 
    IAMBufferNegotiation * This,
    /* [out] */ ALLOCATOR_PROPERTIES *pprop);


void __RPC_STUB IAMBufferNegotiation_GetAllocatorProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMBufferNegotiation_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0169 */
/* [local] */ 

typedef 
enum tagAnalogVideoStandard
    {	AnalogVideo_None	= 0,
	AnalogVideo_NTSC_M	= 0x1,
	AnalogVideo_NTSC_M_J	= 0x2,
	AnalogVideo_NTSC_433	= 0x4,
	AnalogVideo_PAL_B	= 0x10,
	AnalogVideo_PAL_D	= 0x20,
	AnalogVideo_PAL_G	= 0x40,
	AnalogVideo_PAL_H	= 0x80,
	AnalogVideo_PAL_I	= 0x100,
	AnalogVideo_PAL_M	= 0x200,
	AnalogVideo_PAL_N	= 0x400,
	AnalogVideo_PAL_60	= 0x800,
	AnalogVideo_SECAM_B	= 0x1000,
	AnalogVideo_SECAM_D	= 0x2000,
	AnalogVideo_SECAM_G	= 0x4000,
	AnalogVideo_SECAM_H	= 0x8000,
	AnalogVideo_SECAM_K	= 0x10000,
	AnalogVideo_SECAM_K1	= 0x20000,
	AnalogVideo_SECAM_L	= 0x40000,
	AnalogVideo_SECAM_L1	= 0x80000,
	AnalogVideo_PAL_N_COMBO	= 0x100000
    } 	AnalogVideoStandard;

#define AnalogVideo_NTSC_Mask  0x00000007
#define AnalogVideo_PAL_Mask   0x00100FF0
#define AnalogVideo_SECAM_Mask 0x000FF000
typedef 
enum tagTunerInputType
    {	TunerInputCable	= 0,
	TunerInputAntenna	= TunerInputCable + 1
    } 	TunerInputType;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_strmif_0169_0001
    {	VideoCopyProtectionMacrovisionBasic	= 0,
	VideoCopyProtectionMacrovisionCBI	= VideoCopyProtectionMacrovisionBasic + 1
    } 	VideoCopyProtectionType;

typedef 
enum tagPhysicalConnectorType
    {	PhysConn_Video_Tuner	= 1,
	PhysConn_Video_Composite	= PhysConn_Video_Tuner + 1,
	PhysConn_Video_SVideo	= PhysConn_Video_Composite + 1,
	PhysConn_Video_RGB	= PhysConn_Video_SVideo + 1,
	PhysConn_Video_YRYBY	= PhysConn_Video_RGB + 1,
	PhysConn_Video_SerialDigital	= PhysConn_Video_YRYBY + 1,
	PhysConn_Video_ParallelDigital	= PhysConn_Video_SerialDigital + 1,
	PhysConn_Video_SCSI	= PhysConn_Video_ParallelDigital + 1,
	PhysConn_Video_AUX	= PhysConn_Video_SCSI + 1,
	PhysConn_Video_1394	= PhysConn_Video_AUX + 1,
	PhysConn_Video_USB	= PhysConn_Video_1394 + 1,
	PhysConn_Video_VideoDecoder	= PhysConn_Video_USB + 1,
	PhysConn_Video_VideoEncoder	= PhysConn_Video_VideoDecoder + 1,
	PhysConn_Video_SCART	= PhysConn_Video_VideoEncoder + 1,
	PhysConn_Video_Black	= PhysConn_Video_SCART + 1,
	PhysConn_Audio_Tuner	= 0x1000,
	PhysConn_Audio_Line	= PhysConn_Audio_Tuner + 1,
	PhysConn_Audio_Mic	= PhysConn_Audio_Line + 1,
	PhysConn_Audio_AESDigital	= PhysConn_Audio_Mic + 1,
	PhysConn_Audio_SPDIFDigital	= PhysConn_Audio_AESDigital + 1,
	PhysConn_Audio_SCSI	= PhysConn_Audio_SPDIFDigital + 1,
	PhysConn_Audio_AUX	= PhysConn_Audio_SCSI + 1,
	PhysConn_Audio_1394	= PhysConn_Audio_AUX + 1,
	PhysConn_Audio_USB	= PhysConn_Audio_1394 + 1,
	PhysConn_Audio_AudioDecoder	= PhysConn_Audio_USB + 1
    } 	PhysicalConnectorType;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0169_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0169_v0_0_s_ifspec;

#ifndef __IAMAnalogVideoDecoder_INTERFACE_DEFINED__
#define __IAMAnalogVideoDecoder_INTERFACE_DEFINED__

/* interface IAMAnalogVideoDecoder */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMAnalogVideoDecoder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C6E13350-30AC-11d0-A18C-00A0C9118956")
    IAMAnalogVideoDecoder : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE get_AvailableTVFormats( 
            /* [out] */ long *lAnalogVideoStandard) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_TVFormat( 
            /* [in] */ long lAnalogVideoStandard) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_TVFormat( 
            /* [out] */ long *plAnalogVideoStandard) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_HorizontalLocked( 
            /* [out] */ long *plLocked) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_VCRHorizontalLocking( 
            /* [in] */ long lVCRHorizontalLocking) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_VCRHorizontalLocking( 
            /* [out] */ long *plVCRHorizontalLocking) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_NumberOfLines( 
            /* [out] */ long *plNumberOfLines) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_OutputEnable( 
            /* [in] */ long lOutputEnable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_OutputEnable( 
            /* [out] */ long *plOutputEnable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMAnalogVideoDecoderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMAnalogVideoDecoder * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMAnalogVideoDecoder * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMAnalogVideoDecoder * This);
        
        HRESULT ( STDMETHODCALLTYPE *get_AvailableTVFormats )( 
            IAMAnalogVideoDecoder * This,
            /* [out] */ long *lAnalogVideoStandard);
        
        HRESULT ( STDMETHODCALLTYPE *put_TVFormat )( 
            IAMAnalogVideoDecoder * This,
            /* [in] */ long lAnalogVideoStandard);
        
        HRESULT ( STDMETHODCALLTYPE *get_TVFormat )( 
            IAMAnalogVideoDecoder * This,
            /* [out] */ long *plAnalogVideoStandard);
        
        HRESULT ( STDMETHODCALLTYPE *get_HorizontalLocked )( 
            IAMAnalogVideoDecoder * This,
            /* [out] */ long *plLocked);
        
        HRESULT ( STDMETHODCALLTYPE *put_VCRHorizontalLocking )( 
            IAMAnalogVideoDecoder * This,
            /* [in] */ long lVCRHorizontalLocking);
        
        HRESULT ( STDMETHODCALLTYPE *get_VCRHorizontalLocking )( 
            IAMAnalogVideoDecoder * This,
            /* [out] */ long *plVCRHorizontalLocking);
        
        HRESULT ( STDMETHODCALLTYPE *get_NumberOfLines )( 
            IAMAnalogVideoDecoder * This,
            /* [out] */ long *plNumberOfLines);
        
        HRESULT ( STDMETHODCALLTYPE *put_OutputEnable )( 
            IAMAnalogVideoDecoder * This,
            /* [in] */ long lOutputEnable);
        
        HRESULT ( STDMETHODCALLTYPE *get_OutputEnable )( 
            IAMAnalogVideoDecoder * This,
            /* [out] */ long *plOutputEnable);
        
        END_INTERFACE
    } IAMAnalogVideoDecoderVtbl;

    interface IAMAnalogVideoDecoder
    {
        CONST_VTBL struct IAMAnalogVideoDecoderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMAnalogVideoDecoder_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMAnalogVideoDecoder_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMAnalogVideoDecoder_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMAnalogVideoDecoder_get_AvailableTVFormats(This,lAnalogVideoStandard)	\
    (This)->lpVtbl -> get_AvailableTVFormats(This,lAnalogVideoStandard)

#define IAMAnalogVideoDecoder_put_TVFormat(This,lAnalogVideoStandard)	\
    (This)->lpVtbl -> put_TVFormat(This,lAnalogVideoStandard)

#define IAMAnalogVideoDecoder_get_TVFormat(This,plAnalogVideoStandard)	\
    (This)->lpVtbl -> get_TVFormat(This,plAnalogVideoStandard)

#define IAMAnalogVideoDecoder_get_HorizontalLocked(This,plLocked)	\
    (This)->lpVtbl -> get_HorizontalLocked(This,plLocked)

#define IAMAnalogVideoDecoder_put_VCRHorizontalLocking(This,lVCRHorizontalLocking)	\
    (This)->lpVtbl -> put_VCRHorizontalLocking(This,lVCRHorizontalLocking)

#define IAMAnalogVideoDecoder_get_VCRHorizontalLocking(This,plVCRHorizontalLocking)	\
    (This)->lpVtbl -> get_VCRHorizontalLocking(This,plVCRHorizontalLocking)

#define IAMAnalogVideoDecoder_get_NumberOfLines(This,plNumberOfLines)	\
    (This)->lpVtbl -> get_NumberOfLines(This,plNumberOfLines)

#define IAMAnalogVideoDecoder_put_OutputEnable(This,lOutputEnable)	\
    (This)->lpVtbl -> put_OutputEnable(This,lOutputEnable)

#define IAMAnalogVideoDecoder_get_OutputEnable(This,plOutputEnable)	\
    (This)->lpVtbl -> get_OutputEnable(This,plOutputEnable)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAMAnalogVideoDecoder_get_AvailableTVFormats_Proxy( 
    IAMAnalogVideoDecoder * This,
    /* [out] */ long *lAnalogVideoStandard);


void __RPC_STUB IAMAnalogVideoDecoder_get_AvailableTVFormats_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMAnalogVideoDecoder_put_TVFormat_Proxy( 
    IAMAnalogVideoDecoder * This,
    /* [in] */ long lAnalogVideoStandard);


void __RPC_STUB IAMAnalogVideoDecoder_put_TVFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMAnalogVideoDecoder_get_TVFormat_Proxy( 
    IAMAnalogVideoDecoder * This,
    /* [out] */ long *plAnalogVideoStandard);


void __RPC_STUB IAMAnalogVideoDecoder_get_TVFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMAnalogVideoDecoder_get_HorizontalLocked_Proxy( 
    IAMAnalogVideoDecoder * This,
    /* [out] */ long *plLocked);


void __RPC_STUB IAMAnalogVideoDecoder_get_HorizontalLocked_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMAnalogVideoDecoder_put_VCRHorizontalLocking_Proxy( 
    IAMAnalogVideoDecoder * This,
    /* [in] */ long lVCRHorizontalLocking);


void __RPC_STUB IAMAnalogVideoDecoder_put_VCRHorizontalLocking_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMAnalogVideoDecoder_get_VCRHorizontalLocking_Proxy( 
    IAMAnalogVideoDecoder * This,
    /* [out] */ long *plVCRHorizontalLocking);


void __RPC_STUB IAMAnalogVideoDecoder_get_VCRHorizontalLocking_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMAnalogVideoDecoder_get_NumberOfLines_Proxy( 
    IAMAnalogVideoDecoder * This,
    /* [out] */ long *plNumberOfLines);


void __RPC_STUB IAMAnalogVideoDecoder_get_NumberOfLines_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMAnalogVideoDecoder_put_OutputEnable_Proxy( 
    IAMAnalogVideoDecoder * This,
    /* [in] */ long lOutputEnable);


void __RPC_STUB IAMAnalogVideoDecoder_put_OutputEnable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMAnalogVideoDecoder_get_OutputEnable_Proxy( 
    IAMAnalogVideoDecoder * This,
    /* [out] */ long *plOutputEnable);


void __RPC_STUB IAMAnalogVideoDecoder_get_OutputEnable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMAnalogVideoDecoder_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0170 */
/* [local] */ 

typedef 
enum tagVideoProcAmpProperty
    {	VideoProcAmp_Brightness	= 0,
	VideoProcAmp_Contrast	= VideoProcAmp_Brightness + 1,
	VideoProcAmp_Hue	= VideoProcAmp_Contrast + 1,
	VideoProcAmp_Saturation	= VideoProcAmp_Hue + 1,
	VideoProcAmp_Sharpness	= VideoProcAmp_Saturation + 1,
	VideoProcAmp_Gamma	= VideoProcAmp_Sharpness + 1,
	VideoProcAmp_ColorEnable	= VideoProcAmp_Gamma + 1,
	VideoProcAmp_WhiteBalance	= VideoProcAmp_ColorEnable + 1,
	VideoProcAmp_BacklightCompensation	= VideoProcAmp_WhiteBalance + 1,
	VideoProcAmp_Gain	= VideoProcAmp_BacklightCompensation + 1
    } 	VideoProcAmpProperty;

typedef 
enum tagVideoProcAmpFlags
    {	VideoProcAmp_Flags_Auto	= 0x1,
	VideoProcAmp_Flags_Manual	= 0x2
    } 	VideoProcAmpFlags;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0170_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0170_v0_0_s_ifspec;

#ifndef __IAMVideoProcAmp_INTERFACE_DEFINED__
#define __IAMVideoProcAmp_INTERFACE_DEFINED__

/* interface IAMVideoProcAmp */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMVideoProcAmp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C6E13360-30AC-11d0-A18C-00A0C9118956")
    IAMVideoProcAmp : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRange( 
            /* [in] */ long Property,
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Set( 
            /* [in] */ long Property,
            /* [in] */ long lValue,
            /* [in] */ long Flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Get( 
            /* [in] */ long Property,
            /* [out] */ long *lValue,
            /* [out] */ long *Flags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMVideoProcAmpVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMVideoProcAmp * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMVideoProcAmp * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMVideoProcAmp * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetRange )( 
            IAMVideoProcAmp * This,
            /* [in] */ long Property,
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Set )( 
            IAMVideoProcAmp * This,
            /* [in] */ long Property,
            /* [in] */ long lValue,
            /* [in] */ long Flags);
        
        HRESULT ( STDMETHODCALLTYPE *Get )( 
            IAMVideoProcAmp * This,
            /* [in] */ long Property,
            /* [out] */ long *lValue,
            /* [out] */ long *Flags);
        
        END_INTERFACE
    } IAMVideoProcAmpVtbl;

    interface IAMVideoProcAmp
    {
        CONST_VTBL struct IAMVideoProcAmpVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMVideoProcAmp_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMVideoProcAmp_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMVideoProcAmp_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMVideoProcAmp_GetRange(This,Property,pMin,pMax,pSteppingDelta,pDefault,pCapsFlags)	\
    (This)->lpVtbl -> GetRange(This,Property,pMin,pMax,pSteppingDelta,pDefault,pCapsFlags)

#define IAMVideoProcAmp_Set(This,Property,lValue,Flags)	\
    (This)->lpVtbl -> Set(This,Property,lValue,Flags)

#define IAMVideoProcAmp_Get(This,Property,lValue,Flags)	\
    (This)->lpVtbl -> Get(This,Property,lValue,Flags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAMVideoProcAmp_GetRange_Proxy( 
    IAMVideoProcAmp * This,
    /* [in] */ long Property,
    /* [out] */ long *pMin,
    /* [out] */ long *pMax,
    /* [out] */ long *pSteppingDelta,
    /* [out] */ long *pDefault,
    /* [out] */ long *pCapsFlags);


void __RPC_STUB IAMVideoProcAmp_GetRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMVideoProcAmp_Set_Proxy( 
    IAMVideoProcAmp * This,
    /* [in] */ long Property,
    /* [in] */ long lValue,
    /* [in] */ long Flags);


void __RPC_STUB IAMVideoProcAmp_Set_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMVideoProcAmp_Get_Proxy( 
    IAMVideoProcAmp * This,
    /* [in] */ long Property,
    /* [out] */ long *lValue,
    /* [out] */ long *Flags);


void __RPC_STUB IAMVideoProcAmp_Get_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMVideoProcAmp_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0171 */
/* [local] */ 

typedef 
enum tagCameraControlProperty
    {	CameraControl_Pan	= 0,
	CameraControl_Tilt	= CameraControl_Pan + 1,
	CameraControl_Roll	= CameraControl_Tilt + 1,
	CameraControl_Zoom	= CameraControl_Roll + 1,
	CameraControl_Exposure	= CameraControl_Zoom + 1,
	CameraControl_Iris	= CameraControl_Exposure + 1,
	CameraControl_Focus	= CameraControl_Iris + 1
    } 	CameraControlProperty;

typedef 
enum tagCameraControlFlags
    {	CameraControl_Flags_Auto	= 0x1,
	CameraControl_Flags_Manual	= 0x2
    } 	CameraControlFlags;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0171_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0171_v0_0_s_ifspec;

#ifndef __IAMCameraControl_INTERFACE_DEFINED__
#define __IAMCameraControl_INTERFACE_DEFINED__

/* interface IAMCameraControl */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMCameraControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C6E13370-30AC-11d0-A18C-00A0C9118956")
    IAMCameraControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRange( 
            /* [in] */ long Property,
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Set( 
            /* [in] */ long Property,
            /* [in] */ long lValue,
            /* [in] */ long Flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Get( 
            /* [in] */ long Property,
            /* [out] */ long *lValue,
            /* [out] */ long *Flags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMCameraControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMCameraControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMCameraControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMCameraControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetRange )( 
            IAMCameraControl * This,
            /* [in] */ long Property,
            /* [out] */ long *pMin,
            /* [out] */ long *pMax,
            /* [out] */ long *pSteppingDelta,
            /* [out] */ long *pDefault,
            /* [out] */ long *pCapsFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Set )( 
            IAMCameraControl * This,
            /* [in] */ long Property,
            /* [in] */ long lValue,
            /* [in] */ long Flags);
        
        HRESULT ( STDMETHODCALLTYPE *Get )( 
            IAMCameraControl * This,
            /* [in] */ long Property,
            /* [out] */ long *lValue,
            /* [out] */ long *Flags);
        
        END_INTERFACE
    } IAMCameraControlVtbl;

    interface IAMCameraControl
    {
        CONST_VTBL struct IAMCameraControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMCameraControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMCameraControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMCameraControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMCameraControl_GetRange(This,Property,pMin,pMax,pSteppingDelta,pDefault,pCapsFlags)	\
    (This)->lpVtbl -> GetRange(This,Property,pMin,pMax,pSteppingDelta,pDefault,pCapsFlags)

#define IAMCameraControl_Set(This,Property,lValue,Flags)	\
    (This)->lpVtbl -> Set(This,Property,lValue,Flags)

#define IAMCameraControl_Get(This,Property,lValue,Flags)	\
    (This)->lpVtbl -> Get(This,Property,lValue,Flags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAMCameraControl_GetRange_Proxy( 
    IAMCameraControl * This,
    /* [in] */ long Property,
    /* [out] */ long *pMin,
    /* [out] */ long *pMax,
    /* [out] */ long *pSteppingDelta,
    /* [out] */ long *pDefault,
    /* [out] */ long *pCapsFlags);


void __RPC_STUB IAMCameraControl_GetRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMCameraControl_Set_Proxy( 
    IAMCameraControl * This,
    /* [in] */ long Property,
    /* [in] */ long lValue,
    /* [in] */ long Flags);


void __RPC_STUB IAMCameraControl_Set_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMCameraControl_Get_Proxy( 
    IAMCameraControl * This,
    /* [in] */ long Property,
    /* [out] */ long *lValue,
    /* [out] */ long *Flags);


void __RPC_STUB IAMCameraControl_Get_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMCameraControl_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0172 */
/* [local] */ 

typedef 
enum tagVideoControlFlags
    {	VideoControlFlag_FlipHorizontal	= 0x1,
	VideoControlFlag_FlipVertical	= 0x2,
	VideoControlFlag_ExternalTriggerEnable	= 0x4,
	VideoControlFlag_Trigger	= 0x8
    } 	VideoControlFlags;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0172_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0172_v0_0_s_ifspec;

#ifndef __IAMVideoControl_INTERFACE_DEFINED__
#define __IAMVideoControl_INTERFACE_DEFINED__

/* interface IAMVideoControl */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMVideoControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6a2e0670-28e4-11d0-a18c-00a0c9118956")
    IAMVideoControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCaps( 
            /* [in] */ IPin *pPin,
            /* [out] */ long *pCapsFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMode( 
            /* [in] */ IPin *pPin,
            /* [in] */ long Mode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMode( 
            /* [in] */ IPin *pPin,
            /* [out] */ long *Mode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentActualFrameRate( 
            /* [in] */ IPin *pPin,
            /* [out] */ LONGLONG *ActualFrameRate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaxAvailableFrameRate( 
            /* [in] */ IPin *pPin,
            /* [in] */ long iIndex,
            /* [in] */ SIZE Dimensions,
            /* [out] */ LONGLONG *MaxAvailableFrameRate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFrameRateList( 
            /* [in] */ IPin *pPin,
            /* [in] */ long iIndex,
            /* [in] */ SIZE Dimensions,
            /* [out] */ long *ListSize,
            /* [out] */ LONGLONG **FrameRates) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMVideoControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMVideoControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMVideoControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMVideoControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCaps )( 
            IAMVideoControl * This,
            /* [in] */ IPin *pPin,
            /* [out] */ long *pCapsFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetMode )( 
            IAMVideoControl * This,
            /* [in] */ IPin *pPin,
            /* [in] */ long Mode);
        
        HRESULT ( STDMETHODCALLTYPE *GetMode )( 
            IAMVideoControl * This,
            /* [in] */ IPin *pPin,
            /* [out] */ long *Mode);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentActualFrameRate )( 
            IAMVideoControl * This,
            /* [in] */ IPin *pPin,
            /* [out] */ LONGLONG *ActualFrameRate);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxAvailableFrameRate )( 
            IAMVideoControl * This,
            /* [in] */ IPin *pPin,
            /* [in] */ long iIndex,
            /* [in] */ SIZE Dimensions,
            /* [out] */ LONGLONG *MaxAvailableFrameRate);
        
        HRESULT ( STDMETHODCALLTYPE *GetFrameRateList )( 
            IAMVideoControl * This,
            /* [in] */ IPin *pPin,
            /* [in] */ long iIndex,
            /* [in] */ SIZE Dimensions,
            /* [out] */ long *ListSize,
            /* [out] */ LONGLONG **FrameRates);
        
        END_INTERFACE
    } IAMVideoControlVtbl;

    interface IAMVideoControl
    {
        CONST_VTBL struct IAMVideoControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMVideoControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMVideoControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMVideoControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMVideoControl_GetCaps(This,pPin,pCapsFlags)	\
    (This)->lpVtbl -> GetCaps(This,pPin,pCapsFlags)

#define IAMVideoControl_SetMode(This,pPin,Mode)	\
    (This)->lpVtbl -> SetMode(This,pPin,Mode)

#define IAMVideoControl_GetMode(This,pPin,Mode)	\
    (This)->lpVtbl -> GetMode(This,pPin,Mode)

#define IAMVideoControl_GetCurrentActualFrameRate(This,pPin,ActualFrameRate)	\
    (This)->lpVtbl -> GetCurrentActualFrameRate(This,pPin,ActualFrameRate)

#define IAMVideoControl_GetMaxAvailableFrameRate(This,pPin,iIndex,Dimensions,MaxAvailableFrameRate)	\
    (This)->lpVtbl -> GetMaxAvailableFrameRate(This,pPin,iIndex,Dimensions,MaxAvailableFrameRate)

#define IAMVideoControl_GetFrameRateList(This,pPin,iIndex,Dimensions,ListSize,FrameRates)	\
    (This)->lpVtbl -> GetFrameRateList(This,pPin,iIndex,Dimensions,ListSize,FrameRates)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAMVideoControl_GetCaps_Proxy( 
    IAMVideoControl * This,
    /* [in] */ IPin *pPin,
    /* [out] */ long *pCapsFlags);


void __RPC_STUB IAMVideoControl_GetCaps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMVideoControl_SetMode_Proxy( 
    IAMVideoControl * This,
    /* [in] */ IPin *pPin,
    /* [in] */ long Mode);


void __RPC_STUB IAMVideoControl_SetMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMVideoControl_GetMode_Proxy( 
    IAMVideoControl * This,
    /* [in] */ IPin *pPin,
    /* [out] */ long *Mode);


void __RPC_STUB IAMVideoControl_GetMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMVideoControl_GetCurrentActualFrameRate_Proxy( 
    IAMVideoControl * This,
    /* [in] */ IPin *pPin,
    /* [out] */ LONGLONG *ActualFrameRate);


void __RPC_STUB IAMVideoControl_GetCurrentActualFrameRate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMVideoControl_GetMaxAvailableFrameRate_Proxy( 
    IAMVideoControl * This,
    /* [in] */ IPin *pPin,
    /* [in] */ long iIndex,
    /* [in] */ SIZE Dimensions,
    /* [out] */ LONGLONG *MaxAvailableFrameRate);


void __RPC_STUB IAMVideoControl_GetMaxAvailableFrameRate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMVideoControl_GetFrameRateList_Proxy( 
    IAMVideoControl * This,
    /* [in] */ IPin *pPin,
    /* [in] */ long iIndex,
    /* [in] */ SIZE Dimensions,
    /* [out] */ long *ListSize,
    /* [out] */ LONGLONG **FrameRates);


void __RPC_STUB IAMVideoControl_GetFrameRateList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMVideoControl_INTERFACE_DEFINED__ */


#ifndef __IAMCrossbar_INTERFACE_DEFINED__
#define __IAMCrossbar_INTERFACE_DEFINED__

/* interface IAMCrossbar */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMCrossbar;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C6E13380-30AC-11d0-A18C-00A0C9118956")
    IAMCrossbar : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE get_PinCounts( 
            /* [out] */ long *OutputPinCount,
            /* [out] */ long *InputPinCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CanRoute( 
            /* [in] */ long OutputPinIndex,
            /* [in] */ long InputPinIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Route( 
            /* [in] */ long OutputPinIndex,
            /* [in] */ long InputPinIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_IsRoutedTo( 
            /* [in] */ long OutputPinIndex,
            /* [out] */ long *InputPinIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_CrossbarPinInfo( 
            /* [in] */ BOOL IsInputPin,
            /* [in] */ long PinIndex,
            /* [out] */ long *PinIndexRelated,
            /* [out] */ long *PhysicalType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMCrossbarVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMCrossbar * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMCrossbar * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMCrossbar * This);
        
        HRESULT ( STDMETHODCALLTYPE *get_PinCounts )( 
            IAMCrossbar * This,
            /* [out] */ long *OutputPinCount,
            /* [out] */ long *InputPinCount);
        
        HRESULT ( STDMETHODCALLTYPE *CanRoute )( 
            IAMCrossbar * This,
            /* [in] */ long OutputPinIndex,
            /* [in] */ long InputPinIndex);
        
        HRESULT ( STDMETHODCALLTYPE *Route )( 
            IAMCrossbar * This,
            /* [in] */ long OutputPinIndex,
            /* [in] */ long InputPinIndex);
        
        HRESULT ( STDMETHODCALLTYPE *get_IsRoutedTo )( 
            IAMCrossbar * This,
            /* [in] */ long OutputPinIndex,
            /* [out] */ long *InputPinIndex);
        
        HRESULT ( STDMETHODCALLTYPE *get_CrossbarPinInfo )( 
            IAMCrossbar * This,
            /* [in] */ BOOL IsInputPin,
            /* [in] */ long PinIndex,
            /* [out] */ long *PinIndexRelated,
            /* [out] */ long *PhysicalType);
        
        END_INTERFACE
    } IAMCrossbarVtbl;

    interface IAMCrossbar
    {
        CONST_VTBL struct IAMCrossbarVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMCrossbar_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMCrossbar_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMCrossbar_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMCrossbar_get_PinCounts(This,OutputPinCount,InputPinCount)	\
    (This)->lpVtbl -> get_PinCounts(This,OutputPinCount,InputPinCount)

#define IAMCrossbar_CanRoute(This,OutputPinIndex,InputPinIndex)	\
    (This)->lpVtbl -> CanRoute(This,OutputPinIndex,InputPinIndex)

#define IAMCrossbar_Route(This,OutputPinIndex,InputPinIndex)	\
    (This)->lpVtbl -> Route(This,OutputPinIndex,InputPinIndex)

#define IAMCrossbar_get_IsRoutedTo(This,OutputPinIndex,InputPinIndex)	\
    (This)->lpVtbl -> get_IsRoutedTo(This,OutputPinIndex,InputPinIndex)

#define IAMCrossbar_get_CrossbarPinInfo(This,IsInputPin,PinIndex,PinIndexRelated,PhysicalType)	\
    (This)->lpVtbl -> get_CrossbarPinInfo(This,IsInputPin,PinIndex,PinIndexRelated,PhysicalType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAMCrossbar_get_PinCounts_Proxy( 
    IAMCrossbar * This,
    /* [out] */ long *OutputPinCount,
    /* [out] */ long *InputPinCount);


void __RPC_STUB IAMCrossbar_get_PinCounts_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMCrossbar_CanRoute_Proxy( 
    IAMCrossbar * This,
    /* [in] */ long OutputPinIndex,
    /* [in] */ long InputPinIndex);


void __RPC_STUB IAMCrossbar_CanRoute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMCrossbar_Route_Proxy( 
    IAMCrossbar * This,
    /* [in] */ long OutputPinIndex,
    /* [in] */ long InputPinIndex);


void __RPC_STUB IAMCrossbar_Route_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMCrossbar_get_IsRoutedTo_Proxy( 
    IAMCrossbar * This,
    /* [in] */ long OutputPinIndex,
    /* [out] */ long *InputPinIndex);


void __RPC_STUB IAMCrossbar_get_IsRoutedTo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMCrossbar_get_CrossbarPinInfo_Proxy( 
    IAMCrossbar * This,
    /* [in] */ BOOL IsInputPin,
    /* [in] */ long PinIndex,
    /* [out] */ long *PinIndexRelated,
    /* [out] */ long *PhysicalType);


void __RPC_STUB IAMCrossbar_get_CrossbarPinInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMCrossbar_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0174 */
/* [local] */ 

typedef 
enum tagAMTunerSubChannel
    {	AMTUNER_SUBCHAN_NO_TUNE	= -2,
	AMTUNER_SUBCHAN_DEFAULT	= -1
    } 	AMTunerSubChannel;

typedef 
enum tagAMTunerSignalStrength
    {	AMTUNER_HASNOSIGNALSTRENGTH	= -1,
	AMTUNER_NOSIGNAL	= 0,
	AMTUNER_SIGNALPRESENT	= 1
    } 	AMTunerSignalStrength;

typedef 
enum tagAMTunerModeType
    {	AMTUNER_MODE_DEFAULT	= 0,
	AMTUNER_MODE_TV	= 0x1,
	AMTUNER_MODE_FM_RADIO	= 0x2,
	AMTUNER_MODE_AM_RADIO	= 0x4,
	AMTUNER_MODE_DSS	= 0x8
    } 	AMTunerModeType;

typedef 
enum tagAMTunerEventType
    {	AMTUNER_EVENT_CHANGED	= 0x1
    } 	AMTunerEventType;




extern RPC_IF_HANDLE __MIDL_itf_strmif_0174_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0174_v0_0_s_ifspec;

#ifndef __IAMTuner_INTERFACE_DEFINED__
#define __IAMTuner_INTERFACE_DEFINED__

/* interface IAMTuner */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMTuner;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("211A8761-03AC-11d1-8D13-00AA00BD8339")
    IAMTuner : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE put_Channel( 
            /* [in] */ long lChannel,
            /* [in] */ long lVideoSubChannel,
            /* [in] */ long lAudioSubChannel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_Channel( 
            /* [out] */ long *plChannel,
            /* [out] */ long *plVideoSubChannel,
            /* [out] */ long *plAudioSubChannel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ChannelMinMax( 
            /* [out] */ long *lChannelMin,
            /* [out] */ long *lChannelMax) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_CountryCode( 
            /* [in] */ long lCountryCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_CountryCode( 
            /* [out] */ long *plCountryCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_TuningSpace( 
            /* [in] */ long lTuningSpace) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_TuningSpace( 
            /* [out] */ long *plTuningSpace) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Logon( 
            /* [in] */ HANDLE hCurrentUser) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Logout( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SignalPresent( 
            /* [out] */ long *plSignalStrength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_Mode( 
            /* [in] */ AMTunerModeType lMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_Mode( 
            /* [out] */ AMTunerModeType *plMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAvailableModes( 
            /* [out] */ long *plModes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterNotificationCallBack( 
            /* [in] */ IAMTunerNotification *pNotify,
            /* [in] */ long lEvents) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnRegisterNotificationCallBack( 
            /* [in] */ IAMTunerNotification *pNotify) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMTunerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMTuner * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMTuner * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMTuner * This);
        
        HRESULT ( STDMETHODCALLTYPE *put_Channel )( 
            IAMTuner * This,
            /* [in] */ long lChannel,
            /* [in] */ long lVideoSubChannel,
            /* [in] */ long lAudioSubChannel);
        
        HRESULT ( STDMETHODCALLTYPE *get_Channel )( 
            IAMTuner * This,
            /* [out] */ long *plChannel,
            /* [out] */ long *plVideoSubChannel,
            /* [out] */ long *plAudioSubChannel);
        
        HRESULT ( STDMETHODCALLTYPE *ChannelMinMax )( 
            IAMTuner * This,
            /* [out] */ long *lChannelMin,
            /* [out] */ long *lChannelMax);
        
        HRESULT ( STDMETHODCALLTYPE *put_CountryCode )( 
            IAMTuner * This,
            /* [in] */ long lCountryCode);
        
        HRESULT ( STDMETHODCALLTYPE *get_CountryCode )( 
            IAMTuner * This,
            /* [out] */ long *plCountryCode);
        
        HRESULT ( STDMETHODCALLTYPE *put_TuningSpace )( 
            IAMTuner * This,
            /* [in] */ long lTuningSpace);
        
        HRESULT ( STDMETHODCALLTYPE *get_TuningSpace )( 
            IAMTuner * This,
            /* [out] */ long *plTuningSpace);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Logon )( 
            IAMTuner * This,
            /* [in] */ HANDLE hCurrentUser);
        
        HRESULT ( STDMETHODCALLTYPE *Logout )( 
            IAMTuner * This);
        
        HRESULT ( STDMETHODCALLTYPE *SignalPresent )( 
            IAMTuner * This,
            /* [out] */ long *plSignalStrength);
        
        HRESULT ( STDMETHODCALLTYPE *put_Mode )( 
            IAMTuner * This,
            /* [in] */ AMTunerModeType lMode);
        
        HRESULT ( STDMETHODCALLTYPE *get_Mode )( 
            IAMTuner * This,
            /* [out] */ AMTunerModeType *plMode);
        
        HRESULT ( STDMETHODCALLTYPE *GetAvailableModes )( 
            IAMTuner * This,
            /* [out] */ long *plModes);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterNotificationCallBack )( 
            IAMTuner * This,
            /* [in] */ IAMTunerNotification *pNotify,
            /* [in] */ long lEvents);
        
        HRESULT ( STDMETHODCALLTYPE *UnRegisterNotificationCallBack )( 
            IAMTuner * This,
            /* [in] */ IAMTunerNotification *pNotify);
        
        END_INTERFACE
    } IAMTunerVtbl;

    interface IAMTuner
    {
        CONST_VTBL struct IAMTunerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMTuner_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMTuner_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMTuner_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMTuner_put_Channel(This,lChannel,lVideoSubChannel,lAudioSubChannel)	\
    (This)->lpVtbl -> put_Channel(This,lChannel,lVideoSubChannel,lAudioSubChannel)

#define IAMTuner_get_Channel(This,plChannel,plVideoSubChannel,plAudioSubChannel)	\
    (This)->lpVtbl -> get_Channel(This,plChannel,plVideoSubChannel,plAudioSubChannel)

#define IAMTuner_ChannelMinMax(This,lChannelMin,lChannelMax)	\
    (This)->lpVtbl -> ChannelMinMax(This,lChannelMin,lChannelMax)

#define IAMTuner_put_CountryCode(This,lCountryCode)	\
    (This)->lpVtbl -> put_CountryCode(This,lCountryCode)

#define IAMTuner_get_CountryCode(This,plCountryCode)	\
    (This)->lpVtbl -> get_CountryCode(This,plCountryCode)

#define IAMTuner_put_TuningSpace(This,lTuningSpace)	\
    (This)->lpVtbl -> put_TuningSpace(This,lTuningSpace)

#define IAMTuner_get_TuningSpace(This,plTuningSpace)	\
    (This)->lpVtbl -> get_TuningSpace(This,plTuningSpace)

#define IAMTuner_Logon(This,hCurrentUser)	\
    (This)->lpVtbl -> Logon(This,hCurrentUser)

#define IAMTuner_Logout(This)	\
    (This)->lpVtbl -> Logout(This)

#define IAMTuner_SignalPresent(This,plSignalStrength)	\
    (This)->lpVtbl -> SignalPresent(This,plSignalStrength)

#define IAMTuner_put_Mode(This,lMode)	\
    (This)->lpVtbl -> put_Mode(This,lMode)

#define IAMTuner_get_Mode(This,plMode)	\
    (This)->lpVtbl -> get_Mode(This,plMode)

#define IAMTuner_GetAvailableModes(This,plModes)	\
    (This)->lpVtbl -> GetAvailableModes(This,plModes)

#define IAMTuner_RegisterNotificationCallBack(This,pNotify,lEvents)	\
    (This)->lpVtbl -> RegisterNotificationCallBack(This,pNotify,lEvents)

#define IAMTuner_UnRegisterNotificationCallBack(This,pNotify)	\
    (This)->lpVtbl -> UnRegisterNotificationCallBack(This,pNotify)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAMTuner_put_Channel_Proxy( 
    IAMTuner * This,
    /* [in] */ long lChannel,
    /* [in] */ long lVideoSubChannel,
    /* [in] */ long lAudioSubChannel);


void __RPC_STUB IAMTuner_put_Channel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTuner_get_Channel_Proxy( 
    IAMTuner * This,
    /* [out] */ long *plChannel,
    /* [out] */ long *plVideoSubChannel,
    /* [out] */ long *plAudioSubChannel);


void __RPC_STUB IAMTuner_get_Channel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTuner_ChannelMinMax_Proxy( 
    IAMTuner * This,
    /* [out] */ long *lChannelMin,
    /* [out] */ long *lChannelMax);


void __RPC_STUB IAMTuner_ChannelMinMax_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTuner_put_CountryCode_Proxy( 
    IAMTuner * This,
    /* [in] */ long lCountryCode);


void __RPC_STUB IAMTuner_put_CountryCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTuner_get_CountryCode_Proxy( 
    IAMTuner * This,
    /* [out] */ long *plCountryCode);


void __RPC_STUB IAMTuner_get_CountryCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTuner_put_TuningSpace_Proxy( 
    IAMTuner * This,
    /* [in] */ long lTuningSpace);


void __RPC_STUB IAMTuner_put_TuningSpace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTuner_get_TuningSpace_Proxy( 
    IAMTuner * This,
    /* [out] */ long *plTuningSpace);


void __RPC_STUB IAMTuner_get_TuningSpace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [local] */ HRESULT STDMETHODCALLTYPE IAMTuner_Logon_Proxy( 
    IAMTuner * This,
    /* [in] */ HANDLE hCurrentUser);


void __RPC_STUB IAMTuner_Logon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTuner_Logout_Proxy( 
    IAMTuner * This);


void __RPC_STUB IAMTuner_Logout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTuner_SignalPresent_Proxy( 
    IAMTuner * This,
    /* [out] */ long *plSignalStrength);


void __RPC_STUB IAMTuner_SignalPresent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTuner_put_Mode_Proxy( 
    IAMTuner * This,
    /* [in] */ AMTunerModeType lMode);


void __RPC_STUB IAMTuner_put_Mode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTuner_get_Mode_Proxy( 
    IAMTuner * This,
    /* [out] */ AMTunerModeType *plMode);


void __RPC_STUB IAMTuner_get_Mode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTuner_GetAvailableModes_Proxy( 
    IAMTuner * This,
    /* [out] */ long *plModes);


void __RPC_STUB IAMTuner_GetAvailableModes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTuner_RegisterNotificationCallBack_Proxy( 
    IAMTuner * This,
    /* [in] */ IAMTunerNotification *pNotify,
    /* [in] */ long lEvents);


void __RPC_STUB IAMTuner_RegisterNotificationCallBack_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTuner_UnRegisterNotificationCallBack_Proxy( 
    IAMTuner * This,
    /* [in] */ IAMTunerNotification *pNotify);


void __RPC_STUB IAMTuner_UnRegisterNotificationCallBack_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMTuner_INTERFACE_DEFINED__ */


#ifndef __IAMTunerNotification_INTERFACE_DEFINED__
#define __IAMTunerNotification_INTERFACE_DEFINED__

/* interface IAMTunerNotification */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMTunerNotification;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("211A8760-03AC-11d1-8D13-00AA00BD8339")
    IAMTunerNotification : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnEvent( 
            /* [in] */ AMTunerEventType Event) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMTunerNotificationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMTunerNotification * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMTunerNotification * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMTunerNotification * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnEvent )( 
            IAMTunerNotification * This,
            /* [in] */ AMTunerEventType Event);
        
        END_INTERFACE
    } IAMTunerNotificationVtbl;

    interface IAMTunerNotification
    {
        CONST_VTBL struct IAMTunerNotificationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMTunerNotification_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMTunerNotification_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMTunerNotification_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMTunerNotification_OnEvent(This,Event)	\
    (This)->lpVtbl -> OnEvent(This,Event)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAMTunerNotification_OnEvent_Proxy( 
    IAMTunerNotification * This,
    /* [in] */ AMTunerEventType Event);


void __RPC_STUB IAMTunerNotification_OnEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMTunerNotification_INTERFACE_DEFINED__ */


#ifndef __IAMTVTuner_INTERFACE_DEFINED__
#define __IAMTVTuner_INTERFACE_DEFINED__

/* interface IAMTVTuner */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMTVTuner;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("211A8766-03AC-11d1-8D13-00AA00BD8339")
    IAMTVTuner : public IAMTuner
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE get_AvailableTVFormats( 
            /* [out] */ long *lAnalogVideoStandard) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_TVFormat( 
            /* [out] */ long *plAnalogVideoStandard) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AutoTune( 
            /* [in] */ long lChannel,
            /* [out] */ long *plFoundSignal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StoreAutoTune( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_NumInputConnections( 
            /* [out] */ long *plNumInputConnections) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_InputType( 
            /* [in] */ long lIndex,
            /* [in] */ TunerInputType InputType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_InputType( 
            /* [in] */ long lIndex,
            /* [out] */ TunerInputType *pInputType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_ConnectInput( 
            /* [in] */ long lIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_ConnectInput( 
            /* [out] */ long *plIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_VideoFrequency( 
            /* [out] */ long *lFreq) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_AudioFrequency( 
            /* [out] */ long *lFreq) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMTVTunerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMTVTuner * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMTVTuner * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMTVTuner * This);
        
        HRESULT ( STDMETHODCALLTYPE *put_Channel )( 
            IAMTVTuner * This,
            /* [in] */ long lChannel,
            /* [in] */ long lVideoSubChannel,
            /* [in] */ long lAudioSubChannel);
        
        HRESULT ( STDMETHODCALLTYPE *get_Channel )( 
            IAMTVTuner * This,
            /* [out] */ long *plChannel,
            /* [out] */ long *plVideoSubChannel,
            /* [out] */ long *plAudioSubChannel);
        
        HRESULT ( STDMETHODCALLTYPE *ChannelMinMax )( 
            IAMTVTuner * This,
            /* [out] */ long *lChannelMin,
            /* [out] */ long *lChannelMax);
        
        HRESULT ( STDMETHODCALLTYPE *put_CountryCode )( 
            IAMTVTuner * This,
            /* [in] */ long lCountryCode);
        
        HRESULT ( STDMETHODCALLTYPE *get_CountryCode )( 
            IAMTVTuner * This,
            /* [out] */ long *plCountryCode);
        
        HRESULT ( STDMETHODCALLTYPE *put_TuningSpace )( 
            IAMTVTuner * This,
            /* [in] */ long lTuningSpace);
        
        HRESULT ( STDMETHODCALLTYPE *get_TuningSpace )( 
            IAMTVTuner * This,
            /* [out] */ long *plTuningSpace);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Logon )( 
            IAMTVTuner * This,
            /* [in] */ HANDLE hCurrentUser);
        
        HRESULT ( STDMETHODCALLTYPE *Logout )( 
            IAMTVTuner * This);
        
        HRESULT ( STDMETHODCALLTYPE *SignalPresent )( 
            IAMTVTuner * This,
            /* [out] */ long *plSignalStrength);
        
        HRESULT ( STDMETHODCALLTYPE *put_Mode )( 
            IAMTVTuner * This,
            /* [in] */ AMTunerModeType lMode);
        
        HRESULT ( STDMETHODCALLTYPE *get_Mode )( 
            IAMTVTuner * This,
            /* [out] */ AMTunerModeType *plMode);
        
        HRESULT ( STDMETHODCALLTYPE *GetAvailableModes )( 
            IAMTVTuner * This,
            /* [out] */ long *plModes);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterNotificationCallBack )( 
            IAMTVTuner * This,
            /* [in] */ IAMTunerNotification *pNotify,
            /* [in] */ long lEvents);
        
        HRESULT ( STDMETHODCALLTYPE *UnRegisterNotificationCallBack )( 
            IAMTVTuner * This,
            /* [in] */ IAMTunerNotification *pNotify);
        
        HRESULT ( STDMETHODCALLTYPE *get_AvailableTVFormats )( 
            IAMTVTuner * This,
            /* [out] */ long *lAnalogVideoStandard);
        
        HRESULT ( STDMETHODCALLTYPE *get_TVFormat )( 
            IAMTVTuner * This,
            /* [out] */ long *plAnalogVideoStandard);
        
        HRESULT ( STDMETHODCALLTYPE *AutoTune )( 
            IAMTVTuner * This,
            /* [in] */ long lChannel,
            /* [out] */ long *plFoundSignal);
        
        HRESULT ( STDMETHODCALLTYPE *StoreAutoTune )( 
            IAMTVTuner * This);
        
        HRESULT ( STDMETHODCALLTYPE *get_NumInputConnections )( 
            IAMTVTuner * This,
            /* [out] */ long *plNumInputConnections);
        
        HRESULT ( STDMETHODCALLTYPE *put_InputType )( 
            IAMTVTuner * This,
            /* [in] */ long lIndex,
            /* [in] */ TunerInputType InputType);
        
        HRESULT ( STDMETHODCALLTYPE *get_InputType )( 
            IAMTVTuner * This,
            /* [in] */ long lIndex,
            /* [out] */ TunerInputType *pInputType);
        
        HRESULT ( STDMETHODCALLTYPE *put_ConnectInput )( 
            IAMTVTuner * This,
            /* [in] */ long lIndex);
        
        HRESULT ( STDMETHODCALLTYPE *get_ConnectInput )( 
            IAMTVTuner * This,
            /* [out] */ long *plIndex);
        
        HRESULT ( STDMETHODCALLTYPE *get_VideoFrequency )( 
            IAMTVTuner * This,
            /* [out] */ long *lFreq);
        
        HRESULT ( STDMETHODCALLTYPE *get_AudioFrequency )( 
            IAMTVTuner * This,
            /* [out] */ long *lFreq);
        
        END_INTERFACE
    } IAMTVTunerVtbl;

    interface IAMTVTuner
    {
        CONST_VTBL struct IAMTVTunerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMTVTuner_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMTVTuner_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMTVTuner_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMTVTuner_put_Channel(This,lChannel,lVideoSubChannel,lAudioSubChannel)	\
    (This)->lpVtbl -> put_Channel(This,lChannel,lVideoSubChannel,lAudioSubChannel)

#define IAMTVTuner_get_Channel(This,plChannel,plVideoSubChannel,plAudioSubChannel)	\
    (This)->lpVtbl -> get_Channel(This,plChannel,plVideoSubChannel,plAudioSubChannel)

#define IAMTVTuner_ChannelMinMax(This,lChannelMin,lChannelMax)	\
    (This)->lpVtbl -> ChannelMinMax(This,lChannelMin,lChannelMax)

#define IAMTVTuner_put_CountryCode(This,lCountryCode)	\
    (This)->lpVtbl -> put_CountryCode(This,lCountryCode)

#define IAMTVTuner_get_CountryCode(This,plCountryCode)	\
    (This)->lpVtbl -> get_CountryCode(This,plCountryCode)

#define IAMTVTuner_put_TuningSpace(This,lTuningSpace)	\
    (This)->lpVtbl -> put_TuningSpace(This,lTuningSpace)

#define IAMTVTuner_get_TuningSpace(This,plTuningSpace)	\
    (This)->lpVtbl -> get_TuningSpace(This,plTuningSpace)

#define IAMTVTuner_Logon(This,hCurrentUser)	\
    (This)->lpVtbl -> Logon(This,hCurrentUser)

#define IAMTVTuner_Logout(This)	\
    (This)->lpVtbl -> Logout(This)

#define IAMTVTuner_SignalPresent(This,plSignalStrength)	\
    (This)->lpVtbl -> SignalPresent(This,plSignalStrength)

#define IAMTVTuner_put_Mode(This,lMode)	\
    (This)->lpVtbl -> put_Mode(This,lMode)

#define IAMTVTuner_get_Mode(This,plMode)	\
    (This)->lpVtbl -> get_Mode(This,plMode)

#define IAMTVTuner_GetAvailableModes(This,plModes)	\
    (This)->lpVtbl -> GetAvailableModes(This,plModes)

#define IAMTVTuner_RegisterNotificationCallBack(This,pNotify,lEvents)	\
    (This)->lpVtbl -> RegisterNotificationCallBack(This,pNotify,lEvents)

#define IAMTVTuner_UnRegisterNotificationCallBack(This,pNotify)	\
    (This)->lpVtbl -> UnRegisterNotificationCallBack(This,pNotify)


#define IAMTVTuner_get_AvailableTVFormats(This,lAnalogVideoStandard)	\
    (This)->lpVtbl -> get_AvailableTVFormats(This,lAnalogVideoStandard)

#define IAMTVTuner_get_TVFormat(This,plAnalogVideoStandard)	\
    (This)->lpVtbl -> get_TVFormat(This,plAnalogVideoStandard)

#define IAMTVTuner_AutoTune(This,lChannel,plFoundSignal)	\
    (This)->lpVtbl -> AutoTune(This,lChannel,plFoundSignal)

#define IAMTVTuner_StoreAutoTune(This)	\
    (This)->lpVtbl -> StoreAutoTune(This)

#define IAMTVTuner_get_NumInputConnections(This,plNumInputConnections)	\
    (This)->lpVtbl -> get_NumInputConnections(This,plNumInputConnections)

#define IAMTVTuner_put_InputType(This,lIndex,InputType)	\
    (This)->lpVtbl -> put_InputType(This,lIndex,InputType)

#define IAMTVTuner_get_InputType(This,lIndex,pInputType)	\
    (This)->lpVtbl -> get_InputType(This,lIndex,pInputType)

#define IAMTVTuner_put_ConnectInput(This,lIndex)	\
    (This)->lpVtbl -> put_ConnectInput(This,lIndex)

#define IAMTVTuner_get_ConnectInput(This,plIndex)	\
    (This)->lpVtbl -> get_ConnectInput(This,plIndex)

#define IAMTVTuner_get_VideoFrequency(This,lFreq)	\
    (This)->lpVtbl -> get_VideoFrequency(This,lFreq)

#define IAMTVTuner_get_AudioFrequency(This,lFreq)	\
    (This)->lpVtbl -> get_AudioFrequency(This,lFreq)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAMTVTuner_get_AvailableTVFormats_Proxy( 
    IAMTVTuner * This,
    /* [out] */ long *lAnalogVideoStandard);


void __RPC_STUB IAMTVTuner_get_AvailableTVFormats_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTVTuner_get_TVFormat_Proxy( 
    IAMTVTuner * This,
    /* [out] */ long *plAnalogVideoStandard);


void __RPC_STUB IAMTVTuner_get_TVFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTVTuner_AutoTune_Proxy( 
    IAMTVTuner * This,
    /* [in] */ long lChannel,
    /* [out] */ long *plFoundSignal);


void __RPC_STUB IAMTVTuner_AutoTune_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTVTuner_StoreAutoTune_Proxy( 
    IAMTVTuner * This);


void __RPC_STUB IAMTVTuner_StoreAutoTune_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTVTuner_get_NumInputConnections_Proxy( 
    IAMTVTuner * This,
    /* [out] */ long *plNumInputConnections);


void __RPC_STUB IAMTVTuner_get_NumInputConnections_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTVTuner_put_InputType_Proxy( 
    IAMTVTuner * This,
    /* [in] */ long lIndex,
    /* [in] */ TunerInputType InputType);


void __RPC_STUB IAMTVTuner_put_InputType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTVTuner_get_InputType_Proxy( 
    IAMTVTuner * This,
    /* [in] */ long lIndex,
    /* [out] */ TunerInputType *pInputType);


void __RPC_STUB IAMTVTuner_get_InputType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTVTuner_put_ConnectInput_Proxy( 
    IAMTVTuner * This,
    /* [in] */ long lIndex);


void __RPC_STUB IAMTVTuner_put_ConnectInput_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTVTuner_get_ConnectInput_Proxy( 
    IAMTVTuner * This,
    /* [out] */ long *plIndex);


void __RPC_STUB IAMTVTuner_get_ConnectInput_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTVTuner_get_VideoFrequency_Proxy( 
    IAMTVTuner * This,
    /* [out] */ long *lFreq);


void __RPC_STUB IAMTVTuner_get_VideoFrequency_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTVTuner_get_AudioFrequency_Proxy( 
    IAMTVTuner * This,
    /* [out] */ long *lFreq);


void __RPC_STUB IAMTVTuner_get_AudioFrequency_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMTVTuner_INTERFACE_DEFINED__ */


#ifndef __IBPCSatelliteTuner_INTERFACE_DEFINED__
#define __IBPCSatelliteTuner_INTERFACE_DEFINED__

/* interface IBPCSatelliteTuner */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IBPCSatelliteTuner;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("211A8765-03AC-11d1-8D13-00AA00BD8339")
    IBPCSatelliteTuner : public IAMTuner
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE get_DefaultSubChannelTypes( 
            /* [out] */ long *plDefaultVideoType,
            /* [out] */ long *plDefaultAudioType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_DefaultSubChannelTypes( 
            /* [in] */ long lDefaultVideoType,
            /* [in] */ long lDefaultAudioType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsTapingPermitted( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBPCSatelliteTunerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBPCSatelliteTuner * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBPCSatelliteTuner * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBPCSatelliteTuner * This);
        
        HRESULT ( STDMETHODCALLTYPE *put_Channel )( 
            IBPCSatelliteTuner * This,
            /* [in] */ long lChannel,
            /* [in] */ long lVideoSubChannel,
            /* [in] */ long lAudioSubChannel);
        
        HRESULT ( STDMETHODCALLTYPE *get_Channel )( 
            IBPCSatelliteTuner * This,
            /* [out] */ long *plChannel,
            /* [out] */ long *plVideoSubChannel,
            /* [out] */ long *plAudioSubChannel);
        
        HRESULT ( STDMETHODCALLTYPE *ChannelMinMax )( 
            IBPCSatelliteTuner * This,
            /* [out] */ long *lChannelMin,
            /* [out] */ long *lChannelMax);
        
        HRESULT ( STDMETHODCALLTYPE *put_CountryCode )( 
            IBPCSatelliteTuner * This,
            /* [in] */ long lCountryCode);
        
        HRESULT ( STDMETHODCALLTYPE *get_CountryCode )( 
            IBPCSatelliteTuner * This,
            /* [out] */ long *plCountryCode);
        
        HRESULT ( STDMETHODCALLTYPE *put_TuningSpace )( 
            IBPCSatelliteTuner * This,
            /* [in] */ long lTuningSpace);
        
        HRESULT ( STDMETHODCALLTYPE *get_TuningSpace )( 
            IBPCSatelliteTuner * This,
            /* [out] */ long *plTuningSpace);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Logon )( 
            IBPCSatelliteTuner * This,
            /* [in] */ HANDLE hCurrentUser);
        
        HRESULT ( STDMETHODCALLTYPE *Logout )( 
            IBPCSatelliteTuner * This);
        
        HRESULT ( STDMETHODCALLTYPE *SignalPresent )( 
            IBPCSatelliteTuner * This,
            /* [out] */ long *plSignalStrength);
        
        HRESULT ( STDMETHODCALLTYPE *put_Mode )( 
            IBPCSatelliteTuner * This,
            /* [in] */ AMTunerModeType lMode);
        
        HRESULT ( STDMETHODCALLTYPE *get_Mode )( 
            IBPCSatelliteTuner * This,
            /* [out] */ AMTunerModeType *plMode);
        
        HRESULT ( STDMETHODCALLTYPE *GetAvailableModes )( 
            IBPCSatelliteTuner * This,
            /* [out] */ long *plModes);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterNotificationCallBack )( 
            IBPCSatelliteTuner * This,
            /* [in] */ IAMTunerNotification *pNotify,
            /* [in] */ long lEvents);
        
        HRESULT ( STDMETHODCALLTYPE *UnRegisterNotificationCallBack )( 
            IBPCSatelliteTuner * This,
            /* [in] */ IAMTunerNotification *pNotify);
        
        HRESULT ( STDMETHODCALLTYPE *get_DefaultSubChannelTypes )( 
            IBPCSatelliteTuner * This,
            /* [out] */ long *plDefaultVideoType,
            /* [out] */ long *plDefaultAudioType);
        
        HRESULT ( STDMETHODCALLTYPE *put_DefaultSubChannelTypes )( 
            IBPCSatelliteTuner * This,
            /* [in] */ long lDefaultVideoType,
            /* [in] */ long lDefaultAudioType);
        
        HRESULT ( STDMETHODCALLTYPE *IsTapingPermitted )( 
            IBPCSatelliteTuner * This);
        
        END_INTERFACE
    } IBPCSatelliteTunerVtbl;

    interface IBPCSatelliteTuner
    {
        CONST_VTBL struct IBPCSatelliteTunerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBPCSatelliteTuner_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBPCSatelliteTuner_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBPCSatelliteTuner_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBPCSatelliteTuner_put_Channel(This,lChannel,lVideoSubChannel,lAudioSubChannel)	\
    (This)->lpVtbl -> put_Channel(This,lChannel,lVideoSubChannel,lAudioSubChannel)

#define IBPCSatelliteTuner_get_Channel(This,plChannel,plVideoSubChannel,plAudioSubChannel)	\
    (This)->lpVtbl -> get_Channel(This,plChannel,plVideoSubChannel,plAudioSubChannel)

#define IBPCSatelliteTuner_ChannelMinMax(This,lChannelMin,lChannelMax)	\
    (This)->lpVtbl -> ChannelMinMax(This,lChannelMin,lChannelMax)

#define IBPCSatelliteTuner_put_CountryCode(This,lCountryCode)	\
    (This)->lpVtbl -> put_CountryCode(This,lCountryCode)

#define IBPCSatelliteTuner_get_CountryCode(This,plCountryCode)	\
    (This)->lpVtbl -> get_CountryCode(This,plCountryCode)

#define IBPCSatelliteTuner_put_TuningSpace(This,lTuningSpace)	\
    (This)->lpVtbl -> put_TuningSpace(This,lTuningSpace)

#define IBPCSatelliteTuner_get_TuningSpace(This,plTuningSpace)	\
    (This)->lpVtbl -> get_TuningSpace(This,plTuningSpace)

#define IBPCSatelliteTuner_Logon(This,hCurrentUser)	\
    (This)->lpVtbl -> Logon(This,hCurrentUser)

#define IBPCSatelliteTuner_Logout(This)	\
    (This)->lpVtbl -> Logout(This)

#define IBPCSatelliteTuner_SignalPresent(This,plSignalStrength)	\
    (This)->lpVtbl -> SignalPresent(This,plSignalStrength)

#define IBPCSatelliteTuner_put_Mode(This,lMode)	\
    (This)->lpVtbl -> put_Mode(This,lMode)

#define IBPCSatelliteTuner_get_Mode(This,plMode)	\
    (This)->lpVtbl -> get_Mode(This,plMode)

#define IBPCSatelliteTuner_GetAvailableModes(This,plModes)	\
    (This)->lpVtbl -> GetAvailableModes(This,plModes)

#define IBPCSatelliteTuner_RegisterNotificationCallBack(This,pNotify,lEvents)	\
    (This)->lpVtbl -> RegisterNotificationCallBack(This,pNotify,lEvents)

#define IBPCSatelliteTuner_UnRegisterNotificationCallBack(This,pNotify)	\
    (This)->lpVtbl -> UnRegisterNotificationCallBack(This,pNotify)


#define IBPCSatelliteTuner_get_DefaultSubChannelTypes(This,plDefaultVideoType,plDefaultAudioType)	\
    (This)->lpVtbl -> get_DefaultSubChannelTypes(This,plDefaultVideoType,plDefaultAudioType)

#define IBPCSatelliteTuner_put_DefaultSubChannelTypes(This,lDefaultVideoType,lDefaultAudioType)	\
    (This)->lpVtbl -> put_DefaultSubChannelTypes(This,lDefaultVideoType,lDefaultAudioType)

#define IBPCSatelliteTuner_IsTapingPermitted(This)	\
    (This)->lpVtbl -> IsTapingPermitted(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IBPCSatelliteTuner_get_DefaultSubChannelTypes_Proxy( 
    IBPCSatelliteTuner * This,
    /* [out] */ long *plDefaultVideoType,
    /* [out] */ long *plDefaultAudioType);


void __RPC_STUB IBPCSatelliteTuner_get_DefaultSubChannelTypes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBPCSatelliteTuner_put_DefaultSubChannelTypes_Proxy( 
    IBPCSatelliteTuner * This,
    /* [in] */ long lDefaultVideoType,
    /* [in] */ long lDefaultAudioType);


void __RPC_STUB IBPCSatelliteTuner_put_DefaultSubChannelTypes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBPCSatelliteTuner_IsTapingPermitted_Proxy( 
    IBPCSatelliteTuner * This);


void __RPC_STUB IBPCSatelliteTuner_IsTapingPermitted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBPCSatelliteTuner_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0178 */
/* [local] */ 

typedef 
enum tagTVAudioMode
    {	AMTVAUDIO_MODE_MONO	= 0x1,
	AMTVAUDIO_MODE_STEREO	= 0x2,
	AMTVAUDIO_MODE_LANG_A	= 0x10,
	AMTVAUDIO_MODE_LANG_B	= 0x20,
	AMTVAUDIO_MODE_LANG_C	= 0x40
    } 	TVAudioMode;

typedef 
enum tagAMTVAudioEventType
    {	AMTVAUDIO_EVENT_CHANGED	= 0x1
    } 	AMTVAudioEventType;




extern RPC_IF_HANDLE __MIDL_itf_strmif_0178_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0178_v0_0_s_ifspec;

#ifndef __IAMTVAudio_INTERFACE_DEFINED__
#define __IAMTVAudio_INTERFACE_DEFINED__

/* interface IAMTVAudio */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IAMTVAudio;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("83EC1C30-23D1-11d1-99E6-00A0C9560266")
    IAMTVAudio : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetHardwareSupportedTVAudioModes( 
            /* [out] */ long *plModes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAvailableTVAudioModes( 
            /* [out] */ long *plModes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_TVAudioMode( 
            /* [out] */ long *plMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_TVAudioMode( 
            /* [in] */ long lMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterNotificationCallBack( 
            /* [in] */ IAMTunerNotification *pNotify,
            /* [in] */ long lEvents) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnRegisterNotificationCallBack( 
            IAMTunerNotification *pNotify) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMTVAudioVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMTVAudio * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMTVAudio * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMTVAudio * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetHardwareSupportedTVAudioModes )( 
            IAMTVAudio * This,
            /* [out] */ long *plModes);
        
        HRESULT ( STDMETHODCALLTYPE *GetAvailableTVAudioModes )( 
            IAMTVAudio * This,
            /* [out] */ long *plModes);
        
        HRESULT ( STDMETHODCALLTYPE *get_TVAudioMode )( 
            IAMTVAudio * This,
            /* [out] */ long *plMode);
        
        HRESULT ( STDMETHODCALLTYPE *put_TVAudioMode )( 
            IAMTVAudio * This,
            /* [in] */ long lMode);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterNotificationCallBack )( 
            IAMTVAudio * This,
            /* [in] */ IAMTunerNotification *pNotify,
            /* [in] */ long lEvents);
        
        HRESULT ( STDMETHODCALLTYPE *UnRegisterNotificationCallBack )( 
            IAMTVAudio * This,
            IAMTunerNotification *pNotify);
        
        END_INTERFACE
    } IAMTVAudioVtbl;

    interface IAMTVAudio
    {
        CONST_VTBL struct IAMTVAudioVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMTVAudio_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMTVAudio_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMTVAudio_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMTVAudio_GetHardwareSupportedTVAudioModes(This,plModes)	\
    (This)->lpVtbl -> GetHardwareSupportedTVAudioModes(This,plModes)

#define IAMTVAudio_GetAvailableTVAudioModes(This,plModes)	\
    (This)->lpVtbl -> GetAvailableTVAudioModes(This,plModes)

#define IAMTVAudio_get_TVAudioMode(This,plMode)	\
    (This)->lpVtbl -> get_TVAudioMode(This,plMode)

#define IAMTVAudio_put_TVAudioMode(This,lMode)	\
    (This)->lpVtbl -> put_TVAudioMode(This,lMode)

#define IAMTVAudio_RegisterNotificationCallBack(This,pNotify,lEvents)	\
    (This)->lpVtbl -> RegisterNotificationCallBack(This,pNotify,lEvents)

#define IAMTVAudio_UnRegisterNotificationCallBack(This,pNotify)	\
    (This)->lpVtbl -> UnRegisterNotificationCallBack(This,pNotify)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAMTVAudio_GetHardwareSupportedTVAudioModes_Proxy( 
    IAMTVAudio * This,
    /* [out] */ long *plModes);


void __RPC_STUB IAMTVAudio_GetHardwareSupportedTVAudioModes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTVAudio_GetAvailableTVAudioModes_Proxy( 
    IAMTVAudio * This,
    /* [out] */ long *plModes);


void __RPC_STUB IAMTVAudio_GetAvailableTVAudioModes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTVAudio_get_TVAudioMode_Proxy( 
    IAMTVAudio * This,
    /* [out] */ long *plMode);


void __RPC_STUB IAMTVAudio_get_TVAudioMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTVAudio_put_TVAudioMode_Proxy( 
    IAMTVAudio * This,
    /* [in] */ long lMode);


void __RPC_STUB IAMTVAudio_put_TVAudioMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTVAudio_RegisterNotificationCallBack_Proxy( 
    IAMTVAudio * This,
    /* [in] */ IAMTunerNotification *pNotify,
    /* [in] */ long lEvents);


void __RPC_STUB IAMTVAudio_RegisterNotificationCallBack_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTVAudio_UnRegisterNotificationCallBack_Proxy( 
    IAMTVAudio * This,
    IAMTunerNotification *pNotify);


void __RPC_STUB IAMTVAudio_UnRegisterNotificationCallBack_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMTVAudio_INTERFACE_DEFINED__ */


#ifndef __IAMTVAudioNotification_INTERFACE_DEFINED__
#define __IAMTVAudioNotification_INTERFACE_DEFINED__

/* interface IAMTVAudioNotification */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IAMTVAudioNotification;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("83EC1C33-23D1-11d1-99E6-00A0C9560266")
    IAMTVAudioNotification : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnEvent( 
            /* [in] */ AMTVAudioEventType Event) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMTVAudioNotificationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMTVAudioNotification * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMTVAudioNotification * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMTVAudioNotification * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnEvent )( 
            IAMTVAudioNotification * This,
            /* [in] */ AMTVAudioEventType Event);
        
        END_INTERFACE
    } IAMTVAudioNotificationVtbl;

    interface IAMTVAudioNotification
    {
        CONST_VTBL struct IAMTVAudioNotificationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMTVAudioNotification_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMTVAudioNotification_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMTVAudioNotification_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMTVAudioNotification_OnEvent(This,Event)	\
    (This)->lpVtbl -> OnEvent(This,Event)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAMTVAudioNotification_OnEvent_Proxy( 
    IAMTVAudioNotification * This,
    /* [in] */ AMTVAudioEventType Event);


void __RPC_STUB IAMTVAudioNotification_OnEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMTVAudioNotification_INTERFACE_DEFINED__ */


#ifndef __IAMAnalogVideoEncoder_INTERFACE_DEFINED__
#define __IAMAnalogVideoEncoder_INTERFACE_DEFINED__

/* interface IAMAnalogVideoEncoder */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMAnalogVideoEncoder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C6E133B0-30AC-11d0-A18C-00A0C9118956")
    IAMAnalogVideoEncoder : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE get_AvailableTVFormats( 
            /* [out] */ long *lAnalogVideoStandard) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_TVFormat( 
            /* [in] */ long lAnalogVideoStandard) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_TVFormat( 
            /* [out] */ long *plAnalogVideoStandard) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_CopyProtection( 
            /* [in] */ long lVideoCopyProtection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_CopyProtection( 
            /* [out] */ long *lVideoCopyProtection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_CCEnable( 
            /* [in] */ long lCCEnable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_CCEnable( 
            /* [out] */ long *lCCEnable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMAnalogVideoEncoderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMAnalogVideoEncoder * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMAnalogVideoEncoder * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMAnalogVideoEncoder * This);
        
        HRESULT ( STDMETHODCALLTYPE *get_AvailableTVFormats )( 
            IAMAnalogVideoEncoder * This,
            /* [out] */ long *lAnalogVideoStandard);
        
        HRESULT ( STDMETHODCALLTYPE *put_TVFormat )( 
            IAMAnalogVideoEncoder * This,
            /* [in] */ long lAnalogVideoStandard);
        
        HRESULT ( STDMETHODCALLTYPE *get_TVFormat )( 
            IAMAnalogVideoEncoder * This,
            /* [out] */ long *plAnalogVideoStandard);
        
        HRESULT ( STDMETHODCALLTYPE *put_CopyProtection )( 
            IAMAnalogVideoEncoder * This,
            /* [in] */ long lVideoCopyProtection);
        
        HRESULT ( STDMETHODCALLTYPE *get_CopyProtection )( 
            IAMAnalogVideoEncoder * This,
            /* [out] */ long *lVideoCopyProtection);
        
        HRESULT ( STDMETHODCALLTYPE *put_CCEnable )( 
            IAMAnalogVideoEncoder * This,
            /* [in] */ long lCCEnable);
        
        HRESULT ( STDMETHODCALLTYPE *get_CCEnable )( 
            IAMAnalogVideoEncoder * This,
            /* [out] */ long *lCCEnable);
        
        END_INTERFACE
    } IAMAnalogVideoEncoderVtbl;

    interface IAMAnalogVideoEncoder
    {
        CONST_VTBL struct IAMAnalogVideoEncoderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMAnalogVideoEncoder_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMAnalogVideoEncoder_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMAnalogVideoEncoder_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMAnalogVideoEncoder_get_AvailableTVFormats(This,lAnalogVideoStandard)	\
    (This)->lpVtbl -> get_AvailableTVFormats(This,lAnalogVideoStandard)

#define IAMAnalogVideoEncoder_put_TVFormat(This,lAnalogVideoStandard)	\
    (This)->lpVtbl -> put_TVFormat(This,lAnalogVideoStandard)

#define IAMAnalogVideoEncoder_get_TVFormat(This,plAnalogVideoStandard)	\
    (This)->lpVtbl -> get_TVFormat(This,plAnalogVideoStandard)

#define IAMAnalogVideoEncoder_put_CopyProtection(This,lVideoCopyProtection)	\
    (This)->lpVtbl -> put_CopyProtection(This,lVideoCopyProtection)

#define IAMAnalogVideoEncoder_get_CopyProtection(This,lVideoCopyProtection)	\
    (This)->lpVtbl -> get_CopyProtection(This,lVideoCopyProtection)

#define IAMAnalogVideoEncoder_put_CCEnable(This,lCCEnable)	\
    (This)->lpVtbl -> put_CCEnable(This,lCCEnable)

#define IAMAnalogVideoEncoder_get_CCEnable(This,lCCEnable)	\
    (This)->lpVtbl -> get_CCEnable(This,lCCEnable)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAMAnalogVideoEncoder_get_AvailableTVFormats_Proxy( 
    IAMAnalogVideoEncoder * This,
    /* [out] */ long *lAnalogVideoStandard);


void __RPC_STUB IAMAnalogVideoEncoder_get_AvailableTVFormats_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMAnalogVideoEncoder_put_TVFormat_Proxy( 
    IAMAnalogVideoEncoder * This,
    /* [in] */ long lAnalogVideoStandard);


void __RPC_STUB IAMAnalogVideoEncoder_put_TVFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMAnalogVideoEncoder_get_TVFormat_Proxy( 
    IAMAnalogVideoEncoder * This,
    /* [out] */ long *plAnalogVideoStandard);


void __RPC_STUB IAMAnalogVideoEncoder_get_TVFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMAnalogVideoEncoder_put_CopyProtection_Proxy( 
    IAMAnalogVideoEncoder * This,
    /* [in] */ long lVideoCopyProtection);


void __RPC_STUB IAMAnalogVideoEncoder_put_CopyProtection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMAnalogVideoEncoder_get_CopyProtection_Proxy( 
    IAMAnalogVideoEncoder * This,
    /* [out] */ long *lVideoCopyProtection);


void __RPC_STUB IAMAnalogVideoEncoder_get_CopyProtection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMAnalogVideoEncoder_put_CCEnable_Proxy( 
    IAMAnalogVideoEncoder * This,
    /* [in] */ long lCCEnable);


void __RPC_STUB IAMAnalogVideoEncoder_put_CCEnable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMAnalogVideoEncoder_get_CCEnable_Proxy( 
    IAMAnalogVideoEncoder * This,
    /* [out] */ long *lCCEnable);


void __RPC_STUB IAMAnalogVideoEncoder_get_CCEnable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMAnalogVideoEncoder_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0181 */
/* [local] */ 

typedef /* [public] */ 
enum __MIDL___MIDL_itf_strmif_0181_0001
    {	AMPROPERTY_PIN_CATEGORY	= 0,
	AMPROPERTY_PIN_MEDIUM	= AMPROPERTY_PIN_CATEGORY + 1
    } 	AMPROPERTY_PIN;

#ifndef _IKsPropertySet_
#define _IKsPropertySet_
#define KSPROPERTY_SUPPORT_GET  1
#define KSPROPERTY_SUPPORT_SET  2


extern RPC_IF_HANDLE __MIDL_itf_strmif_0181_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0181_v0_0_s_ifspec;

#ifndef __IKsPropertySet_INTERFACE_DEFINED__
#define __IKsPropertySet_INTERFACE_DEFINED__

/* interface IKsPropertySet */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IKsPropertySet;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("31EFAC30-515C-11d0-A9AA-00AA0061BE93")
    IKsPropertySet : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Set( 
            /* [in] */ REFGUID guidPropSet,
            /* [in] */ DWORD dwPropID,
            /* [size_is][in] */ LPVOID pInstanceData,
            /* [in] */ DWORD cbInstanceData,
            /* [size_is][in] */ LPVOID pPropData,
            /* [in] */ DWORD cbPropData) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Get( 
            /* [in] */ REFGUID guidPropSet,
            /* [in] */ DWORD dwPropID,
            /* [size_is][in] */ LPVOID pInstanceData,
            /* [in] */ DWORD cbInstanceData,
            /* [size_is][out] */ LPVOID pPropData,
            /* [in] */ DWORD cbPropData,
            /* [out] */ DWORD *pcbReturned) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QuerySupported( 
            /* [in] */ REFGUID guidPropSet,
            /* [in] */ DWORD dwPropID,
            /* [out] */ DWORD *pTypeSupport) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IKsPropertySetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IKsPropertySet * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IKsPropertySet * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IKsPropertySet * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Set )( 
            IKsPropertySet * This,
            /* [in] */ REFGUID guidPropSet,
            /* [in] */ DWORD dwPropID,
            /* [size_is][in] */ LPVOID pInstanceData,
            /* [in] */ DWORD cbInstanceData,
            /* [size_is][in] */ LPVOID pPropData,
            /* [in] */ DWORD cbPropData);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Get )( 
            IKsPropertySet * This,
            /* [in] */ REFGUID guidPropSet,
            /* [in] */ DWORD dwPropID,
            /* [size_is][in] */ LPVOID pInstanceData,
            /* [in] */ DWORD cbInstanceData,
            /* [size_is][out] */ LPVOID pPropData,
            /* [in] */ DWORD cbPropData,
            /* [out] */ DWORD *pcbReturned);
        
        HRESULT ( STDMETHODCALLTYPE *QuerySupported )( 
            IKsPropertySet * This,
            /* [in] */ REFGUID guidPropSet,
            /* [in] */ DWORD dwPropID,
            /* [out] */ DWORD *pTypeSupport);
        
        END_INTERFACE
    } IKsPropertySetVtbl;

    interface IKsPropertySet
    {
        CONST_VTBL struct IKsPropertySetVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IKsPropertySet_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IKsPropertySet_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IKsPropertySet_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IKsPropertySet_Set(This,guidPropSet,dwPropID,pInstanceData,cbInstanceData,pPropData,cbPropData)	\
    (This)->lpVtbl -> Set(This,guidPropSet,dwPropID,pInstanceData,cbInstanceData,pPropData,cbPropData)

#define IKsPropertySet_Get(This,guidPropSet,dwPropID,pInstanceData,cbInstanceData,pPropData,cbPropData,pcbReturned)	\
    (This)->lpVtbl -> Get(This,guidPropSet,dwPropID,pInstanceData,cbInstanceData,pPropData,cbPropData,pcbReturned)

#define IKsPropertySet_QuerySupported(This,guidPropSet,dwPropID,pTypeSupport)	\
    (This)->lpVtbl -> QuerySupported(This,guidPropSet,dwPropID,pTypeSupport)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IKsPropertySet_RemoteSet_Proxy( 
    IKsPropertySet * This,
    /* [in] */ REFGUID guidPropSet,
    /* [in] */ DWORD dwPropID,
    /* [size_is][in] */ byte *pInstanceData,
    /* [in] */ DWORD cbInstanceData,
    /* [size_is][in] */ byte *pPropData,
    /* [in] */ DWORD cbPropData);


void __RPC_STUB IKsPropertySet_RemoteSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IKsPropertySet_RemoteGet_Proxy( 
    IKsPropertySet * This,
    /* [in] */ REFGUID guidPropSet,
    /* [in] */ DWORD dwPropID,
    /* [size_is][in] */ byte *pInstanceData,
    /* [in] */ DWORD cbInstanceData,
    /* [size_is][out] */ byte *pPropData,
    /* [in] */ DWORD cbPropData,
    /* [out] */ DWORD *pcbReturned);


void __RPC_STUB IKsPropertySet_RemoteGet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IKsPropertySet_QuerySupported_Proxy( 
    IKsPropertySet * This,
    /* [in] */ REFGUID guidPropSet,
    /* [in] */ DWORD dwPropID,
    /* [out] */ DWORD *pTypeSupport);


void __RPC_STUB IKsPropertySet_QuerySupported_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IKsPropertySet_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0182 */
/* [local] */ 

#endif // _IKsPropertySet_


extern RPC_IF_HANDLE __MIDL_itf_strmif_0182_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0182_v0_0_s_ifspec;

#ifndef __IMediaPropertyBag_INTERFACE_DEFINED__
#define __IMediaPropertyBag_INTERFACE_DEFINED__

/* interface IMediaPropertyBag */
/* [unique][uuid][object] */ 

typedef IMediaPropertyBag *LPMEDIAPROPERTYBAG;


EXTERN_C const IID IID_IMediaPropertyBag;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6025A880-C0D5-11d0-BD4E-00A0C911CE86")
    IMediaPropertyBag : public IPropertyBag
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumProperty( 
            /* [in] */ ULONG iProperty,
            /* [out][in] */ VARIANT *pvarPropertyName,
            /* [out][in] */ VARIANT *pvarPropertyValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaPropertyBagVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaPropertyBag * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaPropertyBag * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaPropertyBag * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Read )( 
            IMediaPropertyBag * This,
            /* [in] */ LPCOLESTR pszPropName,
            /* [out][in] */ VARIANT *pVar,
            /* [in] */ IErrorLog *pErrorLog);
        
        HRESULT ( STDMETHODCALLTYPE *Write )( 
            IMediaPropertyBag * This,
            /* [in] */ LPCOLESTR pszPropName,
            /* [in] */ VARIANT *pVar);
        
        HRESULT ( STDMETHODCALLTYPE *EnumProperty )( 
            IMediaPropertyBag * This,
            /* [in] */ ULONG iProperty,
            /* [out][in] */ VARIANT *pvarPropertyName,
            /* [out][in] */ VARIANT *pvarPropertyValue);
        
        END_INTERFACE
    } IMediaPropertyBagVtbl;

    interface IMediaPropertyBag
    {
        CONST_VTBL struct IMediaPropertyBagVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaPropertyBag_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMediaPropertyBag_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMediaPropertyBag_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMediaPropertyBag_Read(This,pszPropName,pVar,pErrorLog)	\
    (This)->lpVtbl -> Read(This,pszPropName,pVar,pErrorLog)

#define IMediaPropertyBag_Write(This,pszPropName,pVar)	\
    (This)->lpVtbl -> Write(This,pszPropName,pVar)


#define IMediaPropertyBag_EnumProperty(This,iProperty,pvarPropertyName,pvarPropertyValue)	\
    (This)->lpVtbl -> EnumProperty(This,iProperty,pvarPropertyName,pvarPropertyValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMediaPropertyBag_EnumProperty_Proxy( 
    IMediaPropertyBag * This,
    /* [in] */ ULONG iProperty,
    /* [out][in] */ VARIANT *pvarPropertyName,
    /* [out][in] */ VARIANT *pvarPropertyValue);


void __RPC_STUB IMediaPropertyBag_EnumProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMediaPropertyBag_INTERFACE_DEFINED__ */


#ifndef __IPersistMediaPropertyBag_INTERFACE_DEFINED__
#define __IPersistMediaPropertyBag_INTERFACE_DEFINED__

/* interface IPersistMediaPropertyBag */
/* [unique][uuid][object] */ 

typedef IPersistMediaPropertyBag *LPPERSISTMEDIAPROPERTYBAG;


EXTERN_C const IID IID_IPersistMediaPropertyBag;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5738E040-B67F-11d0-BD4D-00A0C911CE86")
    IPersistMediaPropertyBag : public IPersist
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitNew( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Load( 
            /* [in] */ IMediaPropertyBag *pPropBag,
            /* [in] */ IErrorLog *pErrorLog) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Save( 
            /* [in] */ IMediaPropertyBag *pPropBag,
            /* [in] */ BOOL fClearDirty,
            /* [in] */ BOOL fSaveAllProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPersistMediaPropertyBagVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPersistMediaPropertyBag * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPersistMediaPropertyBag * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPersistMediaPropertyBag * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassID )( 
            IPersistMediaPropertyBag * This,
            /* [out] */ CLSID *pClassID);
        
        HRESULT ( STDMETHODCALLTYPE *InitNew )( 
            IPersistMediaPropertyBag * This);
        
        HRESULT ( STDMETHODCALLTYPE *Load )( 
            IPersistMediaPropertyBag * This,
            /* [in] */ IMediaPropertyBag *pPropBag,
            /* [in] */ IErrorLog *pErrorLog);
        
        HRESULT ( STDMETHODCALLTYPE *Save )( 
            IPersistMediaPropertyBag * This,
            /* [in] */ IMediaPropertyBag *pPropBag,
            /* [in] */ BOOL fClearDirty,
            /* [in] */ BOOL fSaveAllProperties);
        
        END_INTERFACE
    } IPersistMediaPropertyBagVtbl;

    interface IPersistMediaPropertyBag
    {
        CONST_VTBL struct IPersistMediaPropertyBagVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPersistMediaPropertyBag_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPersistMediaPropertyBag_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPersistMediaPropertyBag_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPersistMediaPropertyBag_GetClassID(This,pClassID)	\
    (This)->lpVtbl -> GetClassID(This,pClassID)


#define IPersistMediaPropertyBag_InitNew(This)	\
    (This)->lpVtbl -> InitNew(This)

#define IPersistMediaPropertyBag_Load(This,pPropBag,pErrorLog)	\
    (This)->lpVtbl -> Load(This,pPropBag,pErrorLog)

#define IPersistMediaPropertyBag_Save(This,pPropBag,fClearDirty,fSaveAllProperties)	\
    (This)->lpVtbl -> Save(This,pPropBag,fClearDirty,fSaveAllProperties)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPersistMediaPropertyBag_InitNew_Proxy( 
    IPersistMediaPropertyBag * This);


void __RPC_STUB IPersistMediaPropertyBag_InitNew_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPersistMediaPropertyBag_Load_Proxy( 
    IPersistMediaPropertyBag * This,
    /* [in] */ IMediaPropertyBag *pPropBag,
    /* [in] */ IErrorLog *pErrorLog);


void __RPC_STUB IPersistMediaPropertyBag_Load_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPersistMediaPropertyBag_Save_Proxy( 
    IPersistMediaPropertyBag * This,
    /* [in] */ IMediaPropertyBag *pPropBag,
    /* [in] */ BOOL fClearDirty,
    /* [in] */ BOOL fSaveAllProperties);


void __RPC_STUB IPersistMediaPropertyBag_Save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPersistMediaPropertyBag_INTERFACE_DEFINED__ */


#ifndef __IAMPhysicalPinInfo_INTERFACE_DEFINED__
#define __IAMPhysicalPinInfo_INTERFACE_DEFINED__

/* interface IAMPhysicalPinInfo */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMPhysicalPinInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F938C991-3029-11cf-8C44-00AA006B6814")
    IAMPhysicalPinInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPhysicalType( 
            /* [out] */ long *pType,
            /* [out] */ LPOLESTR *ppszType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMPhysicalPinInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMPhysicalPinInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMPhysicalPinInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMPhysicalPinInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPhysicalType )( 
            IAMPhysicalPinInfo * This,
            /* [out] */ long *pType,
            /* [out] */ LPOLESTR *ppszType);
        
        END_INTERFACE
    } IAMPhysicalPinInfoVtbl;

    interface IAMPhysicalPinInfo
    {
        CONST_VTBL struct IAMPhysicalPinInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMPhysicalPinInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMPhysicalPinInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMPhysicalPinInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMPhysicalPinInfo_GetPhysicalType(This,pType,ppszType)	\
    (This)->lpVtbl -> GetPhysicalType(This,pType,ppszType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAMPhysicalPinInfo_GetPhysicalType_Proxy( 
    IAMPhysicalPinInfo * This,
    /* [out] */ long *pType,
    /* [out] */ LPOLESTR *ppszType);


void __RPC_STUB IAMPhysicalPinInfo_GetPhysicalType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMPhysicalPinInfo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0329 */
/* [local] */ 

typedef IAMPhysicalPinInfo *PAMPHYSICALPININFO;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0329_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0329_v0_0_s_ifspec;

#ifndef __IAMExtDevice_INTERFACE_DEFINED__
#define __IAMExtDevice_INTERFACE_DEFINED__

/* interface IAMExtDevice */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMExtDevice;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B5730A90-1A2C-11cf-8C23-00AA006B6814")
    IAMExtDevice : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCapability( 
            /* [in] */ long Capability,
            /* [out] */ long *pValue,
            /* [out] */ double *pdblValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_ExternalDeviceID( 
            /* [out] */ LPOLESTR *ppszData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_ExternalDeviceVersion( 
            /* [out] */ LPOLESTR *ppszData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_DevicePower( 
            /* [in] */ long PowerMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_DevicePower( 
            /* [out] */ long *pPowerMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Calibrate( 
            /* [in] */ HEVENT hEvent,
            /* [in] */ long Mode,
            /* [out] */ long *pStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_DevicePort( 
            /* [in] */ long DevicePort) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_DevicePort( 
            /* [out] */ long *pDevicePort) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMExtDeviceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMExtDevice * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMExtDevice * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMExtDevice * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCapability )( 
            IAMExtDevice * This,
            /* [in] */ long Capability,
            /* [out] */ long *pValue,
            /* [out] */ double *pdblValue);
        
        HRESULT ( STDMETHODCALLTYPE *get_ExternalDeviceID )( 
            IAMExtDevice * This,
            /* [out] */ LPOLESTR *ppszData);
        
        HRESULT ( STDMETHODCALLTYPE *get_ExternalDeviceVersion )( 
            IAMExtDevice * This,
            /* [out] */ LPOLESTR *ppszData);
        
        HRESULT ( STDMETHODCALLTYPE *put_DevicePower )( 
            IAMExtDevice * This,
            /* [in] */ long PowerMode);
        
        HRESULT ( STDMETHODCALLTYPE *get_DevicePower )( 
            IAMExtDevice * This,
            /* [out] */ long *pPowerMode);
        
        HRESULT ( STDMETHODCALLTYPE *Calibrate )( 
            IAMExtDevice * This,
            /* [in] */ HEVENT hEvent,
            /* [in] */ long Mode,
            /* [out] */ long *pStatus);
        
        HRESULT ( STDMETHODCALLTYPE *put_DevicePort )( 
            IAMExtDevice * This,
            /* [in] */ long DevicePort);
        
        HRESULT ( STDMETHODCALLTYPE *get_DevicePort )( 
            IAMExtDevice * This,
            /* [out] */ long *pDevicePort);
        
        END_INTERFACE
    } IAMExtDeviceVtbl;

    interface IAMExtDevice
    {
        CONST_VTBL struct IAMExtDeviceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMExtDevice_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMExtDevice_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMExtDevice_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMExtDevice_GetCapability(This,Capability,pValue,pdblValue)	\
    (This)->lpVtbl -> GetCapability(This,Capability,pValue,pdblValue)

#define IAMExtDevice_get_ExternalDeviceID(This,ppszData)	\
    (This)->lpVtbl -> get_ExternalDeviceID(This,ppszData)

#define IAMExtDevice_get_ExternalDeviceVersion(This,ppszData)	\
    (This)->lpVtbl -> get_ExternalDeviceVersion(This,ppszData)

#define IAMExtDevice_put_DevicePower(This,PowerMode)	\
    (This)->lpVtbl -> put_DevicePower(This,PowerMode)

#define IAMExtDevice_get_DevicePower(This,pPowerMode)	\
    (This)->lpVtbl -> get_DevicePower(This,pPowerMode)

#define IAMExtDevice_Calibrate(This,hEvent,Mode,pStatus)	\
    (This)->lpVtbl -> Calibrate(This,hEvent,Mode,pStatus)

#define IAMExtDevice_put_DevicePort(This,DevicePort)	\
    (This)->lpVtbl -> put_DevicePort(This,DevicePort)

#define IAMExtDevice_get_DevicePort(This,pDevicePort)	\
    (This)->lpVtbl -> get_DevicePort(This,pDevicePort)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAMExtDevice_GetCapability_Proxy( 
    IAMExtDevice * This,
    /* [in] */ long Capability,
    /* [out] */ long *pValue,
    /* [out] */ double *pdblValue);


void __RPC_STUB IAMExtDevice_GetCapability_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMExtDevice_get_ExternalDeviceID_Proxy( 
    IAMExtDevice * This,
    /* [out] */ LPOLESTR *ppszData);


void __RPC_STUB IAMExtDevice_get_ExternalDeviceID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMExtDevice_get_ExternalDeviceVersion_Proxy( 
    IAMExtDevice * This,
    /* [out] */ LPOLESTR *ppszData);


void __RPC_STUB IAMExtDevice_get_ExternalDeviceVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMExtDevice_put_DevicePower_Proxy( 
    IAMExtDevice * This,
    /* [in] */ long PowerMode);


void __RPC_STUB IAMExtDevice_put_DevicePower_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMExtDevice_get_DevicePower_Proxy( 
    IAMExtDevice * This,
    /* [out] */ long *pPowerMode);


void __RPC_STUB IAMExtDevice_get_DevicePower_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMExtDevice_Calibrate_Proxy( 
    IAMExtDevice * This,
    /* [in] */ HEVENT hEvent,
    /* [in] */ long Mode,
    /* [out] */ long *pStatus);


void __RPC_STUB IAMExtDevice_Calibrate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMExtDevice_put_DevicePort_Proxy( 
    IAMExtDevice * This,
    /* [in] */ long DevicePort);


void __RPC_STUB IAMExtDevice_put_DevicePort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMExtDevice_get_DevicePort_Proxy( 
    IAMExtDevice * This,
    /* [out] */ long *pDevicePort);


void __RPC_STUB IAMExtDevice_get_DevicePort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMExtDevice_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0330 */
/* [local] */ 

typedef IAMExtDevice *PEXTDEVICE;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0330_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0330_v0_0_s_ifspec;

#ifndef __IAMExtTransport_INTERFACE_DEFINED__
#define __IAMExtTransport_INTERFACE_DEFINED__

/* interface IAMExtTransport */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMExtTransport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A03CD5F0-3045-11cf-8C44-00AA006B6814")
    IAMExtTransport : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCapability( 
            /* [in] */ long Capability,
            /* [out] */ long *pValue,
            /* [out] */ double *pdblValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_MediaState( 
            /* [in] */ long State) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_MediaState( 
            /* [out] */ long *pState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_LocalControl( 
            /* [in] */ long State) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_LocalControl( 
            /* [out] */ long *pState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [in] */ long StatusItem,
            /* [out] */ long *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTransportBasicParameters( 
            /* [in] */ long Param,
            /* [out] */ long *pValue,
            /* [out] */ LPOLESTR *ppszData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTransportBasicParameters( 
            /* [in] */ long Param,
            /* [in] */ long Value,
            /* [in] */ LPCOLESTR pszData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTransportVideoParameters( 
            /* [in] */ long Param,
            /* [out] */ long *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTransportVideoParameters( 
            /* [in] */ long Param,
            /* [in] */ long Value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTransportAudioParameters( 
            /* [in] */ long Param,
            /* [out] */ long *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTransportAudioParameters( 
            /* [in] */ long Param,
            /* [in] */ long Value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_Mode( 
            /* [in] */ long Mode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_Mode( 
            /* [out] */ long *pMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_Rate( 
            /* [in] */ double dblRate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_Rate( 
            /* [out] */ double *pdblRate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetChase( 
            /* [out] */ long *pEnabled,
            /* [out] */ long *pOffset,
            /* [out] */ HEVENT *phEvent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetChase( 
            /* [in] */ long Enable,
            /* [in] */ long Offset,
            /* [in] */ HEVENT hEvent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBump( 
            /* [out] */ long *pSpeed,
            /* [out] */ long *pDuration) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBump( 
            /* [in] */ long Speed,
            /* [in] */ long Duration) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_AntiClogControl( 
            /* [out] */ long *pEnabled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_AntiClogControl( 
            /* [in] */ long Enable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEditPropertySet( 
            /* [in] */ long EditID,
            /* [out] */ long *pState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEditPropertySet( 
            /* [out][in] */ long *pEditID,
            /* [in] */ long State) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEditProperty( 
            /* [in] */ long EditID,
            /* [in] */ long Param,
            /* [out] */ long *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEditProperty( 
            /* [in] */ long EditID,
            /* [in] */ long Param,
            /* [in] */ long Value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_EditStart( 
            /* [out] */ long *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_EditStart( 
            /* [in] */ long Value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMExtTransportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMExtTransport * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMExtTransport * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMExtTransport * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCapability )( 
            IAMExtTransport * This,
            /* [in] */ long Capability,
            /* [out] */ long *pValue,
            /* [out] */ double *pdblValue);
        
        HRESULT ( STDMETHODCALLTYPE *put_MediaState )( 
            IAMExtTransport * This,
            /* [in] */ long State);
        
        HRESULT ( STDMETHODCALLTYPE *get_MediaState )( 
            IAMExtTransport * This,
            /* [out] */ long *pState);
        
        HRESULT ( STDMETHODCALLTYPE *put_LocalControl )( 
            IAMExtTransport * This,
            /* [in] */ long State);
        
        HRESULT ( STDMETHODCALLTYPE *get_LocalControl )( 
            IAMExtTransport * This,
            /* [out] */ long *pState);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            IAMExtTransport * This,
            /* [in] */ long StatusItem,
            /* [out] */ long *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransportBasicParameters )( 
            IAMExtTransport * This,
            /* [in] */ long Param,
            /* [out] */ long *pValue,
            /* [out] */ LPOLESTR *ppszData);
        
        HRESULT ( STDMETHODCALLTYPE *SetTransportBasicParameters )( 
            IAMExtTransport * This,
            /* [in] */ long Param,
            /* [in] */ long Value,
            /* [in] */ LPCOLESTR pszData);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransportVideoParameters )( 
            IAMExtTransport * This,
            /* [in] */ long Param,
            /* [out] */ long *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetTransportVideoParameters )( 
            IAMExtTransport * This,
            /* [in] */ long Param,
            /* [in] */ long Value);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransportAudioParameters )( 
            IAMExtTransport * This,
            /* [in] */ long Param,
            /* [out] */ long *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetTransportAudioParameters )( 
            IAMExtTransport * This,
            /* [in] */ long Param,
            /* [in] */ long Value);
        
        HRESULT ( STDMETHODCALLTYPE *put_Mode )( 
            IAMExtTransport * This,
            /* [in] */ long Mode);
        
        HRESULT ( STDMETHODCALLTYPE *get_Mode )( 
            IAMExtTransport * This,
            /* [out] */ long *pMode);
        
        HRESULT ( STDMETHODCALLTYPE *put_Rate )( 
            IAMExtTransport * This,
            /* [in] */ double dblRate);
        
        HRESULT ( STDMETHODCALLTYPE *get_Rate )( 
            IAMExtTransport * This,
            /* [out] */ double *pdblRate);
        
        HRESULT ( STDMETHODCALLTYPE *GetChase )( 
            IAMExtTransport * This,
            /* [out] */ long *pEnabled,
            /* [out] */ long *pOffset,
            /* [out] */ HEVENT *phEvent);
        
        HRESULT ( STDMETHODCALLTYPE *SetChase )( 
            IAMExtTransport * This,
            /* [in] */ long Enable,
            /* [in] */ long Offset,
            /* [in] */ HEVENT hEvent);
        
        HRESULT ( STDMETHODCALLTYPE *GetBump )( 
            IAMExtTransport * This,
            /* [out] */ long *pSpeed,
            /* [out] */ long *pDuration);
        
        HRESULT ( STDMETHODCALLTYPE *SetBump )( 
            IAMExtTransport * This,
            /* [in] */ long Speed,
            /* [in] */ long Duration);
        
        HRESULT ( STDMETHODCALLTYPE *get_AntiClogControl )( 
            IAMExtTransport * This,
            /* [out] */ long *pEnabled);
        
        HRESULT ( STDMETHODCALLTYPE *put_AntiClogControl )( 
            IAMExtTransport * This,
            /* [in] */ long Enable);
        
        HRESULT ( STDMETHODCALLTYPE *GetEditPropertySet )( 
            IAMExtTransport * This,
            /* [in] */ long EditID,
            /* [out] */ long *pState);
        
        HRESULT ( STDMETHODCALLTYPE *SetEditPropertySet )( 
            IAMExtTransport * This,
            /* [out][in] */ long *pEditID,
            /* [in] */ long State);
        
        HRESULT ( STDMETHODCALLTYPE *GetEditProperty )( 
            IAMExtTransport * This,
            /* [in] */ long EditID,
            /* [in] */ long Param,
            /* [out] */ long *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetEditProperty )( 
            IAMExtTransport * This,
            /* [in] */ long EditID,
            /* [in] */ long Param,
            /* [in] */ long Value);
        
        HRESULT ( STDMETHODCALLTYPE *get_EditStart )( 
            IAMExtTransport * This,
            /* [out] */ long *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *put_EditStart )( 
            IAMExtTransport * This,
            /* [in] */ long Value);
        
        END_INTERFACE
    } IAMExtTransportVtbl;

    interface IAMExtTransport
    {
        CONST_VTBL struct IAMExtTransportVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMExtTransport_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMExtTransport_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMExtTransport_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMExtTransport_GetCapability(This,Capability,pValue,pdblValue)	\
    (This)->lpVtbl -> GetCapability(This,Capability,pValue,pdblValue)

#define IAMExtTransport_put_MediaState(This,State)	\
    (This)->lpVtbl -> put_MediaState(This,State)

#define IAMExtTransport_get_MediaState(This,pState)	\
    (This)->lpVtbl -> get_MediaState(This,pState)

#define IAMExtTransport_put_LocalControl(This,State)	\
    (This)->lpVtbl -> put_LocalControl(This,State)

#define IAMExtTransport_get_LocalControl(This,pState)	\
    (This)->lpVtbl -> get_LocalControl(This,pState)

#define IAMExtTransport_GetStatus(This,StatusItem,pValue)	\
    (This)->lpVtbl -> GetStatus(This,StatusItem,pValue)

#define IAMExtTransport_GetTransportBasicParameters(This,Param,pValue,ppszData)	\
    (This)->lpVtbl -> GetTransportBasicParameters(This,Param,pValue,ppszData)

#define IAMExtTransport_SetTransportBasicParameters(This,Param,Value,pszData)	\
    (This)->lpVtbl -> SetTransportBasicParameters(This,Param,Value,pszData)

#define IAMExtTransport_GetTransportVideoParameters(This,Param,pValue)	\
    (This)->lpVtbl -> GetTransportVideoParameters(This,Param,pValue)

#define IAMExtTransport_SetTransportVideoParameters(This,Param,Value)	\
    (This)->lpVtbl -> SetTransportVideoParameters(This,Param,Value)

#define IAMExtTransport_GetTransportAudioParameters(This,Param,pValue)	\
    (This)->lpVtbl -> GetTransportAudioParameters(This,Param,pValue)

#define IAMExtTransport_SetTransportAudioParameters(This,Param,Value)	\
    (This)->lpVtbl -> SetTransportAudioParameters(This,Param,Value)

#define IAMExtTransport_put_Mode(This,Mode)	\
    (This)->lpVtbl -> put_Mode(This,Mode)

#define IAMExtTransport_get_Mode(This,pMode)	\
    (This)->lpVtbl -> get_Mode(This,pMode)

#define IAMExtTransport_put_Rate(This,dblRate)	\
    (This)->lpVtbl -> put_Rate(This,dblRate)

#define IAMExtTransport_get_Rate(This,pdblRate)	\
    (This)->lpVtbl -> get_Rate(This,pdblRate)

#define IAMExtTransport_GetChase(This,pEnabled,pOffset,phEvent)	\
    (This)->lpVtbl -> GetChase(This,pEnabled,pOffset,phEvent)

#define IAMExtTransport_SetChase(This,Enable,Offset,hEvent)	\
    (This)->lpVtbl -> SetChase(This,Enable,Offset,hEvent)

#define IAMExtTransport_GetBump(This,pSpeed,pDuration)	\
    (This)->lpVtbl -> GetBump(This,pSpeed,pDuration)

#define IAMExtTransport_SetBump(This,Speed,Duration)	\
    (This)->lpVtbl -> SetBump(This,Speed,Duration)

#define IAMExtTransport_get_AntiClogControl(This,pEnabled)	\
    (This)->lpVtbl -> get_AntiClogControl(This,pEnabled)

#define IAMExtTransport_put_AntiClogControl(This,Enable)	\
    (This)->lpVtbl -> put_AntiClogControl(This,Enable)

#define IAMExtTransport_GetEditPropertySet(This,EditID,pState)	\
    (This)->lpVtbl -> GetEditPropertySet(This,EditID,pState)

#define IAMExtTransport_SetEditPropertySet(This,pEditID,State)	\
    (This)->lpVtbl -> SetEditPropertySet(This,pEditID,State)

#define IAMExtTransport_GetEditProperty(This,EditID,Param,pValue)	\
    (This)->lpVtbl -> GetEditProperty(This,EditID,Param,pValue)

#define IAMExtTransport_SetEditProperty(This,EditID,Param,Value)	\
    (This)->lpVtbl -> SetEditProperty(This,EditID,Param,Value)

#define IAMExtTransport_get_EditStart(This,pValue)	\
    (This)->lpVtbl -> get_EditStart(This,pValue)

#define IAMExtTransport_put_EditStart(This,Value)	\
    (This)->lpVtbl -> put_EditStart(This,Value)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAMExtTransport_GetCapability_Proxy( 
    IAMExtTransport * This,
    /* [in] */ long Capability,
    /* [out] */ long *pValue,
    /* [out] */ double *pdblValue);


void __RPC_STUB IAMExtTransport_GetCapability_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMExtTransport_put_MediaState_Proxy( 
    IAMExtTransport * This,
    /* [in] */ long State);


void __RPC_STUB IAMExtTransport_put_MediaState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMExtTransport_get_MediaState_Proxy( 
    IAMExtTransport * This,
    /* [out] */ long *pState);


void __RPC_STUB IAMExtTransport_get_MediaState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMExtTransport_put_LocalControl_Proxy( 
    IAMExtTransport * This,
    /* [in] */ long State);


void __RPC_STUB IAMExtTransport_put_LocalControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMExtTransport_get_LocalControl_Proxy( 
    IAMExtTransport * This,
    /* [out] */ long *pState);


void __RPC_STUB IAMExtTransport_get_LocalControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMExtTransport_GetStatus_Proxy( 
    IAMExtTransport * This,
    /* [in] */ long StatusItem,
    /* [out] */ long *pValue);


void __RPC_STUB IAMExtTransport_GetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMExtTransport_GetTransportBasicParameters_Proxy( 
    IAMExtTransport * This,
    /* [in] */ long Param,
    /* [out] */ long *pValue,
    /* [out] */ LPOLESTR *ppszData);


void __RPC_STUB IAMExtTransport_GetTransportBasicParameters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMExtTransport_SetTransportBasicParameters_Proxy( 
    IAMExtTransport * This,
    /* [in] */ long Param,
    /* [in] */ long Value,
    /* [in] */ LPCOLESTR pszData);


void __RPC_STUB IAMExtTransport_SetTransportBasicParameters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMExtTransport_GetTransportVideoParameters_Proxy( 
    IAMExtTransport * This,
    /* [in] */ long Param,
    /* [out] */ long *pValue);


void __RPC_STUB IAMExtTransport_GetTransportVideoParameters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMExtTransport_SetTransportVideoParameters_Proxy( 
    IAMExtTransport * This,
    /* [in] */ long Param,
    /* [in] */ long Value);


void __RPC_STUB IAMExtTransport_SetTransportVideoParameters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMExtTransport_GetTransportAudioParameters_Proxy( 
    IAMExtTransport * This,
    /* [in] */ long Param,
    /* [out] */ long *pValue);


void __RPC_STUB IAMExtTransport_GetTransportAudioParameters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMExtTransport_SetTransportAudioParameters_Proxy( 
    IAMExtTransport * This,
    /* [in] */ long Param,
    /* [in] */ long Value);


void __RPC_STUB IAMExtTransport_SetTransportAudioParameters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMExtTransport_put_Mode_Proxy( 
    IAMExtTransport * This,
    /* [in] */ long Mode);


void __RPC_STUB IAMExtTransport_put_Mode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMExtTransport_get_Mode_Proxy( 
    IAMExtTransport * This,
    /* [out] */ long *pMode);


void __RPC_STUB IAMExtTransport_get_Mode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMExtTransport_put_Rate_Proxy( 
    IAMExtTransport * This,
    /* [in] */ double dblRate);


void __RPC_STUB IAMExtTransport_put_Rate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMExtTransport_get_Rate_Proxy( 
    IAMExtTransport * This,
    /* [out] */ double *pdblRate);


void __RPC_STUB IAMExtTransport_get_Rate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMExtTransport_GetChase_Proxy( 
    IAMExtTransport * This,
    /* [out] */ long *pEnabled,
    /* [out] */ long *pOffset,
    /* [out] */ HEVENT *phEvent);


void __RPC_STUB IAMExtTransport_GetChase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMExtTransport_SetChase_Proxy( 
    IAMExtTransport * This,
    /* [in] */ long Enable,
    /* [in] */ long Offset,
    /* [in] */ HEVENT hEvent);


void __RPC_STUB IAMExtTransport_SetChase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMExtTransport_GetBump_Proxy( 
    IAMExtTransport * This,
    /* [out] */ long *pSpeed,
    /* [out] */ long *pDuration);


void __RPC_STUB IAMExtTransport_GetBump_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMExtTransport_SetBump_Proxy( 
    IAMExtTransport * This,
    /* [in] */ long Speed,
    /* [in] */ long Duration);


void __RPC_STUB IAMExtTransport_SetBump_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMExtTransport_get_AntiClogControl_Proxy( 
    IAMExtTransport * This,
    /* [out] */ long *pEnabled);


void __RPC_STUB IAMExtTransport_get_AntiClogControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMExtTransport_put_AntiClogControl_Proxy( 
    IAMExtTransport * This,
    /* [in] */ long Enable);


void __RPC_STUB IAMExtTransport_put_AntiClogControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMExtTransport_GetEditPropertySet_Proxy( 
    IAMExtTransport * This,
    /* [in] */ long EditID,
    /* [out] */ long *pState);


void __RPC_STUB IAMExtTransport_GetEditPropertySet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMExtTransport_SetEditPropertySet_Proxy( 
    IAMExtTransport * This,
    /* [out][in] */ long *pEditID,
    /* [in] */ long State);


void __RPC_STUB IAMExtTransport_SetEditPropertySet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMExtTransport_GetEditProperty_Proxy( 
    IAMExtTransport * This,
    /* [in] */ long EditID,
    /* [in] */ long Param,
    /* [out] */ long *pValue);


void __RPC_STUB IAMExtTransport_GetEditProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMExtTransport_SetEditProperty_Proxy( 
    IAMExtTransport * This,
    /* [in] */ long EditID,
    /* [in] */ long Param,
    /* [in] */ long Value);


void __RPC_STUB IAMExtTransport_SetEditProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMExtTransport_get_EditStart_Proxy( 
    IAMExtTransport * This,
    /* [out] */ long *pValue);


void __RPC_STUB IAMExtTransport_get_EditStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMExtTransport_put_EditStart_Proxy( 
    IAMExtTransport * This,
    /* [in] */ long Value);


void __RPC_STUB IAMExtTransport_put_EditStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMExtTransport_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0331 */
/* [local] */ 

typedef IAMExtTransport *PIAMEXTTRANSPORT;

#if 0
/* the following is what MIDL knows how to remote */
typedef struct tagTIMECODE
    {
    WORD wFrameRate;
    WORD wFrameFract;
    DWORD dwFrames;
    } 	TIMECODE;

#else /* 0 */
#ifndef TIMECODE_DEFINED
#define TIMECODE_DEFINED
typedef union _timecode {
   struct {
	 WORD   wFrameRate;
	 WORD   wFrameFract;
	 DWORD  dwFrames;
	 };
   DWORDLONG  qw;
   } TIMECODE;

#endif /* TIMECODE_DEFINED */
#endif /* 0 */
typedef TIMECODE *PTIMECODE;

typedef struct tagTIMECODE_SAMPLE
    {
    LONGLONG qwTick;
    TIMECODE timecode;
    DWORD dwUser;
    DWORD dwFlags;
    } 	TIMECODE_SAMPLE;

typedef TIMECODE_SAMPLE *PTIMECODE_SAMPLE;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0331_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0331_v0_0_s_ifspec;

#ifndef __IAMTimecodeReader_INTERFACE_DEFINED__
#define __IAMTimecodeReader_INTERFACE_DEFINED__

/* interface IAMTimecodeReader */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMTimecodeReader;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9B496CE1-811B-11cf-8C77-00AA006B6814")
    IAMTimecodeReader : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTCRMode( 
            /* [in] */ long Param,
            /* [out] */ long *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTCRMode( 
            /* [in] */ long Param,
            /* [in] */ long Value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_VITCLine( 
            /* [in] */ long Line) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_VITCLine( 
            /* [out] */ long *pLine) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTimecode( 
            /* [out] */ PTIMECODE_SAMPLE pTimecodeSample) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMTimecodeReaderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMTimecodeReader * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMTimecodeReader * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMTimecodeReader * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTCRMode )( 
            IAMTimecodeReader * This,
            /* [in] */ long Param,
            /* [out] */ long *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetTCRMode )( 
            IAMTimecodeReader * This,
            /* [in] */ long Param,
            /* [in] */ long Value);
        
        HRESULT ( STDMETHODCALLTYPE *put_VITCLine )( 
            IAMTimecodeReader * This,
            /* [in] */ long Line);
        
        HRESULT ( STDMETHODCALLTYPE *get_VITCLine )( 
            IAMTimecodeReader * This,
            /* [out] */ long *pLine);
        
        HRESULT ( STDMETHODCALLTYPE *GetTimecode )( 
            IAMTimecodeReader * This,
            /* [out] */ PTIMECODE_SAMPLE pTimecodeSample);
        
        END_INTERFACE
    } IAMTimecodeReaderVtbl;

    interface IAMTimecodeReader
    {
        CONST_VTBL struct IAMTimecodeReaderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMTimecodeReader_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMTimecodeReader_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMTimecodeReader_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMTimecodeReader_GetTCRMode(This,Param,pValue)	\
    (This)->lpVtbl -> GetTCRMode(This,Param,pValue)

#define IAMTimecodeReader_SetTCRMode(This,Param,Value)	\
    (This)->lpVtbl -> SetTCRMode(This,Param,Value)

#define IAMTimecodeReader_put_VITCLine(This,Line)	\
    (This)->lpVtbl -> put_VITCLine(This,Line)

#define IAMTimecodeReader_get_VITCLine(This,pLine)	\
    (This)->lpVtbl -> get_VITCLine(This,pLine)

#define IAMTimecodeReader_GetTimecode(This,pTimecodeSample)	\
    (This)->lpVtbl -> GetTimecode(This,pTimecodeSample)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAMTimecodeReader_GetTCRMode_Proxy( 
    IAMTimecodeReader * This,
    /* [in] */ long Param,
    /* [out] */ long *pValue);


void __RPC_STUB IAMTimecodeReader_GetTCRMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimecodeReader_SetTCRMode_Proxy( 
    IAMTimecodeReader * This,
    /* [in] */ long Param,
    /* [in] */ long Value);


void __RPC_STUB IAMTimecodeReader_SetTCRMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimecodeReader_put_VITCLine_Proxy( 
    IAMTimecodeReader * This,
    /* [in] */ long Line);


void __RPC_STUB IAMTimecodeReader_put_VITCLine_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimecodeReader_get_VITCLine_Proxy( 
    IAMTimecodeReader * This,
    /* [out] */ long *pLine);


void __RPC_STUB IAMTimecodeReader_get_VITCLine_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimecodeReader_GetTimecode_Proxy( 
    IAMTimecodeReader * This,
    /* [out] */ PTIMECODE_SAMPLE pTimecodeSample);


void __RPC_STUB IAMTimecodeReader_GetTimecode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMTimecodeReader_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0332 */
/* [local] */ 

typedef IAMTimecodeReader *PIAMTIMECODEREADER;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0332_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0332_v0_0_s_ifspec;

#ifndef __IAMTimecodeGenerator_INTERFACE_DEFINED__
#define __IAMTimecodeGenerator_INTERFACE_DEFINED__

/* interface IAMTimecodeGenerator */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMTimecodeGenerator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9B496CE0-811B-11cf-8C77-00AA006B6814")
    IAMTimecodeGenerator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTCGMode( 
            /* [in] */ long Param,
            /* [out] */ long *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTCGMode( 
            /* [in] */ long Param,
            /* [in] */ long Value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_VITCLine( 
            /* [in] */ long Line) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_VITCLine( 
            /* [out] */ long *pLine) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTimecode( 
            /* [in] */ PTIMECODE_SAMPLE pTimecodeSample) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTimecode( 
            /* [out] */ PTIMECODE_SAMPLE pTimecodeSample) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMTimecodeGeneratorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMTimecodeGenerator * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMTimecodeGenerator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMTimecodeGenerator * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTCGMode )( 
            IAMTimecodeGenerator * This,
            /* [in] */ long Param,
            /* [out] */ long *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetTCGMode )( 
            IAMTimecodeGenerator * This,
            /* [in] */ long Param,
            /* [in] */ long Value);
        
        HRESULT ( STDMETHODCALLTYPE *put_VITCLine )( 
            IAMTimecodeGenerator * This,
            /* [in] */ long Line);
        
        HRESULT ( STDMETHODCALLTYPE *get_VITCLine )( 
            IAMTimecodeGenerator * This,
            /* [out] */ long *pLine);
        
        HRESULT ( STDMETHODCALLTYPE *SetTimecode )( 
            IAMTimecodeGenerator * This,
            /* [in] */ PTIMECODE_SAMPLE pTimecodeSample);
        
        HRESULT ( STDMETHODCALLTYPE *GetTimecode )( 
            IAMTimecodeGenerator * This,
            /* [out] */ PTIMECODE_SAMPLE pTimecodeSample);
        
        END_INTERFACE
    } IAMTimecodeGeneratorVtbl;

    interface IAMTimecodeGenerator
    {
        CONST_VTBL struct IAMTimecodeGeneratorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMTimecodeGenerator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMTimecodeGenerator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMTimecodeGenerator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMTimecodeGenerator_GetTCGMode(This,Param,pValue)	\
    (This)->lpVtbl -> GetTCGMode(This,Param,pValue)

#define IAMTimecodeGenerator_SetTCGMode(This,Param,Value)	\
    (This)->lpVtbl -> SetTCGMode(This,Param,Value)

#define IAMTimecodeGenerator_put_VITCLine(This,Line)	\
    (This)->lpVtbl -> put_VITCLine(This,Line)

#define IAMTimecodeGenerator_get_VITCLine(This,pLine)	\
    (This)->lpVtbl -> get_VITCLine(This,pLine)

#define IAMTimecodeGenerator_SetTimecode(This,pTimecodeSample)	\
    (This)->lpVtbl -> SetTimecode(This,pTimecodeSample)

#define IAMTimecodeGenerator_GetTimecode(This,pTimecodeSample)	\
    (This)->lpVtbl -> GetTimecode(This,pTimecodeSample)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAMTimecodeGenerator_GetTCGMode_Proxy( 
    IAMTimecodeGenerator * This,
    /* [in] */ long Param,
    /* [out] */ long *pValue);


void __RPC_STUB IAMTimecodeGenerator_GetTCGMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimecodeGenerator_SetTCGMode_Proxy( 
    IAMTimecodeGenerator * This,
    /* [in] */ long Param,
    /* [in] */ long Value);


void __RPC_STUB IAMTimecodeGenerator_SetTCGMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimecodeGenerator_put_VITCLine_Proxy( 
    IAMTimecodeGenerator * This,
    /* [in] */ long Line);


void __RPC_STUB IAMTimecodeGenerator_put_VITCLine_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimecodeGenerator_get_VITCLine_Proxy( 
    IAMTimecodeGenerator * This,
    /* [out] */ long *pLine);


void __RPC_STUB IAMTimecodeGenerator_get_VITCLine_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimecodeGenerator_SetTimecode_Proxy( 
    IAMTimecodeGenerator * This,
    /* [in] */ PTIMECODE_SAMPLE pTimecodeSample);


void __RPC_STUB IAMTimecodeGenerator_SetTimecode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimecodeGenerator_GetTimecode_Proxy( 
    IAMTimecodeGenerator * This,
    /* [out] */ PTIMECODE_SAMPLE pTimecodeSample);


void __RPC_STUB IAMTimecodeGenerator_GetTimecode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMTimecodeGenerator_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0333 */
/* [local] */ 

typedef IAMTimecodeGenerator *PIAMTIMECODEGENERATOR;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0333_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0333_v0_0_s_ifspec;

#ifndef __IAMTimecodeDisplay_INTERFACE_DEFINED__
#define __IAMTimecodeDisplay_INTERFACE_DEFINED__

/* interface IAMTimecodeDisplay */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMTimecodeDisplay;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9B496CE2-811B-11cf-8C77-00AA006B6814")
    IAMTimecodeDisplay : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTCDisplayEnable( 
            /* [out] */ long *pState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTCDisplayEnable( 
            /* [in] */ long State) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTCDisplay( 
            /* [in] */ long Param,
            /* [out] */ long *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTCDisplay( 
            /* [in] */ long Param,
            /* [in] */ long Value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMTimecodeDisplayVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMTimecodeDisplay * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMTimecodeDisplay * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMTimecodeDisplay * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTCDisplayEnable )( 
            IAMTimecodeDisplay * This,
            /* [out] */ long *pState);
        
        HRESULT ( STDMETHODCALLTYPE *SetTCDisplayEnable )( 
            IAMTimecodeDisplay * This,
            /* [in] */ long State);
        
        HRESULT ( STDMETHODCALLTYPE *GetTCDisplay )( 
            IAMTimecodeDisplay * This,
            /* [in] */ long Param,
            /* [out] */ long *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetTCDisplay )( 
            IAMTimecodeDisplay * This,
            /* [in] */ long Param,
            /* [in] */ long Value);
        
        END_INTERFACE
    } IAMTimecodeDisplayVtbl;

    interface IAMTimecodeDisplay
    {
        CONST_VTBL struct IAMTimecodeDisplayVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMTimecodeDisplay_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMTimecodeDisplay_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMTimecodeDisplay_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMTimecodeDisplay_GetTCDisplayEnable(This,pState)	\
    (This)->lpVtbl -> GetTCDisplayEnable(This,pState)

#define IAMTimecodeDisplay_SetTCDisplayEnable(This,State)	\
    (This)->lpVtbl -> SetTCDisplayEnable(This,State)

#define IAMTimecodeDisplay_GetTCDisplay(This,Param,pValue)	\
    (This)->lpVtbl -> GetTCDisplay(This,Param,pValue)

#define IAMTimecodeDisplay_SetTCDisplay(This,Param,Value)	\
    (This)->lpVtbl -> SetTCDisplay(This,Param,Value)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAMTimecodeDisplay_GetTCDisplayEnable_Proxy( 
    IAMTimecodeDisplay * This,
    /* [out] */ long *pState);


void __RPC_STUB IAMTimecodeDisplay_GetTCDisplayEnable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimecodeDisplay_SetTCDisplayEnable_Proxy( 
    IAMTimecodeDisplay * This,
    /* [in] */ long State);


void __RPC_STUB IAMTimecodeDisplay_SetTCDisplayEnable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimecodeDisplay_GetTCDisplay_Proxy( 
    IAMTimecodeDisplay * This,
    /* [in] */ long Param,
    /* [out] */ long *pValue);


void __RPC_STUB IAMTimecodeDisplay_GetTCDisplay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMTimecodeDisplay_SetTCDisplay_Proxy( 
    IAMTimecodeDisplay * This,
    /* [in] */ long Param,
    /* [in] */ long Value);


void __RPC_STUB IAMTimecodeDisplay_SetTCDisplay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMTimecodeDisplay_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0334 */
/* [local] */ 

typedef IAMTimecodeDisplay *PIAMTIMECODEDISPLAY;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0334_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0334_v0_0_s_ifspec;

#ifndef __IAMDevMemoryAllocator_INTERFACE_DEFINED__
#define __IAMDevMemoryAllocator_INTERFACE_DEFINED__

/* interface IAMDevMemoryAllocator */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMDevMemoryAllocator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c6545bf0-e76b-11d0-bd52-00a0c911ce86")
    IAMDevMemoryAllocator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetInfo( 
            /* [out] */ DWORD *pdwcbTotalFree,
            /* [out] */ DWORD *pdwcbLargestFree,
            /* [out] */ DWORD *pdwcbTotalMemory,
            /* [out] */ DWORD *pdwcbMinimumChunk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CheckMemory( 
            /* [in] */ const BYTE *pBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Alloc( 
            /* [out] */ BYTE **ppBuffer,
            /* [out][in] */ DWORD *pdwcbBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Free( 
            /* [in] */ BYTE *pBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDevMemoryObject( 
            /* [out] */ IUnknown **ppUnkInnner,
            /* [in] */ IUnknown *pUnkOuter) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMDevMemoryAllocatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMDevMemoryAllocator * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMDevMemoryAllocator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMDevMemoryAllocator * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            IAMDevMemoryAllocator * This,
            /* [out] */ DWORD *pdwcbTotalFree,
            /* [out] */ DWORD *pdwcbLargestFree,
            /* [out] */ DWORD *pdwcbTotalMemory,
            /* [out] */ DWORD *pdwcbMinimumChunk);
        
        HRESULT ( STDMETHODCALLTYPE *CheckMemory )( 
            IAMDevMemoryAllocator * This,
            /* [in] */ const BYTE *pBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *Alloc )( 
            IAMDevMemoryAllocator * This,
            /* [out] */ BYTE **ppBuffer,
            /* [out][in] */ DWORD *pdwcbBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *Free )( 
            IAMDevMemoryAllocator * This,
            /* [in] */ BYTE *pBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *GetDevMemoryObject )( 
            IAMDevMemoryAllocator * This,
            /* [out] */ IUnknown **ppUnkInnner,
            /* [in] */ IUnknown *pUnkOuter);
        
        END_INTERFACE
    } IAMDevMemoryAllocatorVtbl;

    interface IAMDevMemoryAllocator
    {
        CONST_VTBL struct IAMDevMemoryAllocatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMDevMemoryAllocator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMDevMemoryAllocator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMDevMemoryAllocator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMDevMemoryAllocator_GetInfo(This,pdwcbTotalFree,pdwcbLargestFree,pdwcbTotalMemory,pdwcbMinimumChunk)	\
    (This)->lpVtbl -> GetInfo(This,pdwcbTotalFree,pdwcbLargestFree,pdwcbTotalMemory,pdwcbMinimumChunk)

#define IAMDevMemoryAllocator_CheckMemory(This,pBuffer)	\
    (This)->lpVtbl -> CheckMemory(This,pBuffer)

#define IAMDevMemoryAllocator_Alloc(This,ppBuffer,pdwcbBuffer)	\
    (This)->lpVtbl -> Alloc(This,ppBuffer,pdwcbBuffer)

#define IAMDevMemoryAllocator_Free(This,pBuffer)	\
    (This)->lpVtbl -> Free(This,pBuffer)

#define IAMDevMemoryAllocator_GetDevMemoryObject(This,ppUnkInnner,pUnkOuter)	\
    (This)->lpVtbl -> GetDevMemoryObject(This,ppUnkInnner,pUnkOuter)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAMDevMemoryAllocator_GetInfo_Proxy( 
    IAMDevMemoryAllocator * This,
    /* [out] */ DWORD *pdwcbTotalFree,
    /* [out] */ DWORD *pdwcbLargestFree,
    /* [out] */ DWORD *pdwcbTotalMemory,
    /* [out] */ DWORD *pdwcbMinimumChunk);


void __RPC_STUB IAMDevMemoryAllocator_GetInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMDevMemoryAllocator_CheckMemory_Proxy( 
    IAMDevMemoryAllocator * This,
    /* [in] */ const BYTE *pBuffer);


void __RPC_STUB IAMDevMemoryAllocator_CheckMemory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMDevMemoryAllocator_Alloc_Proxy( 
    IAMDevMemoryAllocator * This,
    /* [out] */ BYTE **ppBuffer,
    /* [out][in] */ DWORD *pdwcbBuffer);


void __RPC_STUB IAMDevMemoryAllocator_Alloc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMDevMemoryAllocator_Free_Proxy( 
    IAMDevMemoryAllocator * This,
    /* [in] */ BYTE *pBuffer);


void __RPC_STUB IAMDevMemoryAllocator_Free_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMDevMemoryAllocator_GetDevMemoryObject_Proxy( 
    IAMDevMemoryAllocator * This,
    /* [out] */ IUnknown **ppUnkInnner,
    /* [in] */ IUnknown *pUnkOuter);


void __RPC_STUB IAMDevMemoryAllocator_GetDevMemoryObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMDevMemoryAllocator_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0335 */
/* [local] */ 

typedef IAMDevMemoryAllocator *PAMDEVMEMORYALLOCATOR;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0335_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0335_v0_0_s_ifspec;

#ifndef __IAMDevMemoryControl_INTERFACE_DEFINED__
#define __IAMDevMemoryControl_INTERFACE_DEFINED__

/* interface IAMDevMemoryControl */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMDevMemoryControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c6545bf1-e76b-11d0-bd52-00a0c911ce86")
    IAMDevMemoryControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryWriteSync( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteSync( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDevId( 
            /* [out] */ DWORD *pdwDevId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMDevMemoryControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMDevMemoryControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMDevMemoryControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMDevMemoryControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryWriteSync )( 
            IAMDevMemoryControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *WriteSync )( 
            IAMDevMemoryControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDevId )( 
            IAMDevMemoryControl * This,
            /* [out] */ DWORD *pdwDevId);
        
        END_INTERFACE
    } IAMDevMemoryControlVtbl;

    interface IAMDevMemoryControl
    {
        CONST_VTBL struct IAMDevMemoryControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMDevMemoryControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMDevMemoryControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMDevMemoryControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMDevMemoryControl_QueryWriteSync(This)	\
    (This)->lpVtbl -> QueryWriteSync(This)

#define IAMDevMemoryControl_WriteSync(This)	\
    (This)->lpVtbl -> WriteSync(This)

#define IAMDevMemoryControl_GetDevId(This,pdwDevId)	\
    (This)->lpVtbl -> GetDevId(This,pdwDevId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAMDevMemoryControl_QueryWriteSync_Proxy( 
    IAMDevMemoryControl * This);


void __RPC_STUB IAMDevMemoryControl_QueryWriteSync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMDevMemoryControl_WriteSync_Proxy( 
    IAMDevMemoryControl * This);


void __RPC_STUB IAMDevMemoryControl_WriteSync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMDevMemoryControl_GetDevId_Proxy( 
    IAMDevMemoryControl * This,
    /* [out] */ DWORD *pdwDevId);


void __RPC_STUB IAMDevMemoryControl_GetDevId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMDevMemoryControl_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0336 */
/* [local] */ 

typedef IAMDevMemoryControl *PAMDEVMEMORYCONTROL;


enum _AMSTREAMSELECTINFOFLAGS
    {	AMSTREAMSELECTINFO_ENABLED	= 0x1,
	AMSTREAMSELECTINFO_EXCLUSIVE	= 0x2
    } ;

enum _AMSTREAMSELECTENABLEFLAGS
    {	AMSTREAMSELECTENABLE_ENABLE	= 0x1,
	AMSTREAMSELECTENABLE_ENABLEALL	= 0x2
    } ;


extern RPC_IF_HANDLE __MIDL_itf_strmif_0336_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0336_v0_0_s_ifspec;

#ifndef __IAMStreamSelect_INTERFACE_DEFINED__
#define __IAMStreamSelect_INTERFACE_DEFINED__

/* interface IAMStreamSelect */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMStreamSelect;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c1960960-17f5-11d1-abe1-00a0c905f375")
    IAMStreamSelect : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Count( 
            /* [out] */ DWORD *pcStreams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Info( 
            /* [in] */ long lIndex,
            /* [out] */ AM_MEDIA_TYPE **ppmt,
            /* [out] */ DWORD *pdwFlags,
            /* [out] */ LCID *plcid,
            /* [out] */ DWORD *pdwGroup,
            /* [out] */ WCHAR **ppszName,
            /* [out] */ IUnknown **ppObject,
            /* [out] */ IUnknown **ppUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Enable( 
            /* [in] */ long lIndex,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMStreamSelectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMStreamSelect * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMStreamSelect * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMStreamSelect * This);
        
        HRESULT ( STDMETHODCALLTYPE *Count )( 
            IAMStreamSelect * This,
            /* [out] */ DWORD *pcStreams);
        
        HRESULT ( STDMETHODCALLTYPE *Info )( 
            IAMStreamSelect * This,
            /* [in] */ long lIndex,
            /* [out] */ AM_MEDIA_TYPE **ppmt,
            /* [out] */ DWORD *pdwFlags,
            /* [out] */ LCID *plcid,
            /* [out] */ DWORD *pdwGroup,
            /* [out] */ WCHAR **ppszName,
            /* [out] */ IUnknown **ppObject,
            /* [out] */ IUnknown **ppUnk);
        
        HRESULT ( STDMETHODCALLTYPE *Enable )( 
            IAMStreamSelect * This,
            /* [in] */ long lIndex,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IAMStreamSelectVtbl;

    interface IAMStreamSelect
    {
        CONST_VTBL struct IAMStreamSelectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMStreamSelect_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMStreamSelect_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMStreamSelect_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMStreamSelect_Count(This,pcStreams)	\
    (This)->lpVtbl -> Count(This,pcStreams)

#define IAMStreamSelect_Info(This,lIndex,ppmt,pdwFlags,plcid,pdwGroup,ppszName,ppObject,ppUnk)	\
    (This)->lpVtbl -> Info(This,lIndex,ppmt,pdwFlags,plcid,pdwGroup,ppszName,ppObject,ppUnk)

#define IAMStreamSelect_Enable(This,lIndex,dwFlags)	\
    (This)->lpVtbl -> Enable(This,lIndex,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAMStreamSelect_Count_Proxy( 
    IAMStreamSelect * This,
    /* [out] */ DWORD *pcStreams);


void __RPC_STUB IAMStreamSelect_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMStreamSelect_Info_Proxy( 
    IAMStreamSelect * This,
    /* [in] */ long lIndex,
    /* [out] */ AM_MEDIA_TYPE **ppmt,
    /* [out] */ DWORD *pdwFlags,
    /* [out] */ LCID *plcid,
    /* [out] */ DWORD *pdwGroup,
    /* [out] */ WCHAR **ppszName,
    /* [out] */ IUnknown **ppObject,
    /* [out] */ IUnknown **ppUnk);


void __RPC_STUB IAMStreamSelect_Info_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMStreamSelect_Enable_Proxy( 
    IAMStreamSelect * This,
    /* [in] */ long lIndex,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IAMStreamSelect_Enable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMStreamSelect_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0337 */
/* [local] */ 

typedef IAMStreamSelect *PAMSTREAMSELECT;


enum _AMRESCTL_RESERVEFLAGS
    {	AMRESCTL_RESERVEFLAGS_RESERVE	= 0,
	AMRESCTL_RESERVEFLAGS_UNRESERVE	= 0x1
    } ;


extern RPC_IF_HANDLE __MIDL_itf_strmif_0337_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0337_v0_0_s_ifspec;

#ifndef __IAMResourceControl_INTERFACE_DEFINED__
#define __IAMResourceControl_INTERFACE_DEFINED__

/* interface IAMResourceControl */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IAMResourceControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8389d2d0-77d7-11d1-abe6-00a0c905f375")
    IAMResourceControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Reserve( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ PVOID pvReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMResourceControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMResourceControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMResourceControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMResourceControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *Reserve )( 
            IAMResourceControl * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ PVOID pvReserved);
        
        END_INTERFACE
    } IAMResourceControlVtbl;

    interface IAMResourceControl
    {
        CONST_VTBL struct IAMResourceControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMResourceControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMResourceControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMResourceControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMResourceControl_Reserve(This,dwFlags,pvReserved)	\
    (This)->lpVtbl -> Reserve(This,dwFlags,pvReserved)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAMResourceControl_Reserve_Proxy( 
    IAMResourceControl * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ PVOID pvReserved);


void __RPC_STUB IAMResourceControl_Reserve_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMResourceControl_INTERFACE_DEFINED__ */


#ifndef __IAMClockAdjust_INTERFACE_DEFINED__
#define __IAMClockAdjust_INTERFACE_DEFINED__

/* interface IAMClockAdjust */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IAMClockAdjust;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4d5466b0-a49c-11d1-abe8-00a0c905f375")
    IAMClockAdjust : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetClockDelta( 
            /* [in] */ REFERENCE_TIME rtDelta) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMClockAdjustVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMClockAdjust * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMClockAdjust * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMClockAdjust * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetClockDelta )( 
            IAMClockAdjust * This,
            /* [in] */ REFERENCE_TIME rtDelta);
        
        END_INTERFACE
    } IAMClockAdjustVtbl;

    interface IAMClockAdjust
    {
        CONST_VTBL struct IAMClockAdjustVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMClockAdjust_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMClockAdjust_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMClockAdjust_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMClockAdjust_SetClockDelta(This,rtDelta)	\
    (This)->lpVtbl -> SetClockDelta(This,rtDelta)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAMClockAdjust_SetClockDelta_Proxy( 
    IAMClockAdjust * This,
    /* [in] */ REFERENCE_TIME rtDelta);


void __RPC_STUB IAMClockAdjust_SetClockDelta_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMClockAdjust_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0339 */
/* [local] */ 


enum _AM_FILTER_MISC_FLAGS
    {	AM_FILTER_MISC_FLAGS_IS_RENDERER	= 0x1,
	AM_FILTER_MISC_FLAGS_IS_SOURCE	= 0x2
    } ;


extern RPC_IF_HANDLE __MIDL_itf_strmif_0339_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0339_v0_0_s_ifspec;

#ifndef __IAMFilterMiscFlags_INTERFACE_DEFINED__
#define __IAMFilterMiscFlags_INTERFACE_DEFINED__

/* interface IAMFilterMiscFlags */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IAMFilterMiscFlags;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2dd74950-a890-11d1-abe8-00a0c905f375")
    IAMFilterMiscFlags : public IUnknown
    {
    public:
        virtual ULONG STDMETHODCALLTYPE GetMiscFlags( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMFilterMiscFlagsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMFilterMiscFlags * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMFilterMiscFlags * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMFilterMiscFlags * This);
        
        ULONG ( STDMETHODCALLTYPE *GetMiscFlags )( 
            IAMFilterMiscFlags * This);
        
        END_INTERFACE
    } IAMFilterMiscFlagsVtbl;

    interface IAMFilterMiscFlags
    {
        CONST_VTBL struct IAMFilterMiscFlagsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMFilterMiscFlags_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMFilterMiscFlags_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMFilterMiscFlags_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMFilterMiscFlags_GetMiscFlags(This)	\
    (This)->lpVtbl -> GetMiscFlags(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



ULONG STDMETHODCALLTYPE IAMFilterMiscFlags_GetMiscFlags_Proxy( 
    IAMFilterMiscFlags * This);


void __RPC_STUB IAMFilterMiscFlags_GetMiscFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMFilterMiscFlags_INTERFACE_DEFINED__ */


#ifndef __IDrawVideoImage_INTERFACE_DEFINED__
#define __IDrawVideoImage_INTERFACE_DEFINED__

/* interface IDrawVideoImage */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IDrawVideoImage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("48efb120-ab49-11d2-aed2-00a0c995e8d5")
    IDrawVideoImage : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DrawVideoImageBegin( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DrawVideoImageEnd( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DrawVideoImageDraw( 
            /* [in] */ HDC hdc,
            /* [in] */ LPRECT lprcSrc,
            /* [in] */ LPRECT lprcDst) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDrawVideoImageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDrawVideoImage * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDrawVideoImage * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDrawVideoImage * This);
        
        HRESULT ( STDMETHODCALLTYPE *DrawVideoImageBegin )( 
            IDrawVideoImage * This);
        
        HRESULT ( STDMETHODCALLTYPE *DrawVideoImageEnd )( 
            IDrawVideoImage * This);
        
        HRESULT ( STDMETHODCALLTYPE *DrawVideoImageDraw )( 
            IDrawVideoImage * This,
            /* [in] */ HDC hdc,
            /* [in] */ LPRECT lprcSrc,
            /* [in] */ LPRECT lprcDst);
        
        END_INTERFACE
    } IDrawVideoImageVtbl;

    interface IDrawVideoImage
    {
        CONST_VTBL struct IDrawVideoImageVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDrawVideoImage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDrawVideoImage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDrawVideoImage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDrawVideoImage_DrawVideoImageBegin(This)	\
    (This)->lpVtbl -> DrawVideoImageBegin(This)

#define IDrawVideoImage_DrawVideoImageEnd(This)	\
    (This)->lpVtbl -> DrawVideoImageEnd(This)

#define IDrawVideoImage_DrawVideoImageDraw(This,hdc,lprcSrc,lprcDst)	\
    (This)->lpVtbl -> DrawVideoImageDraw(This,hdc,lprcSrc,lprcDst)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDrawVideoImage_DrawVideoImageBegin_Proxy( 
    IDrawVideoImage * This);


void __RPC_STUB IDrawVideoImage_DrawVideoImageBegin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDrawVideoImage_DrawVideoImageEnd_Proxy( 
    IDrawVideoImage * This);


void __RPC_STUB IDrawVideoImage_DrawVideoImageEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDrawVideoImage_DrawVideoImageDraw_Proxy( 
    IDrawVideoImage * This,
    /* [in] */ HDC hdc,
    /* [in] */ LPRECT lprcSrc,
    /* [in] */ LPRECT lprcDst);


void __RPC_STUB IDrawVideoImage_DrawVideoImageDraw_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDrawVideoImage_INTERFACE_DEFINED__ */


#ifndef __IDecimateVideoImage_INTERFACE_DEFINED__
#define __IDecimateVideoImage_INTERFACE_DEFINED__

/* interface IDecimateVideoImage */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IDecimateVideoImage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2e5ea3e0-e924-11d2-b6da-00a0c995e8df")
    IDecimateVideoImage : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetDecimationImageSize( 
            /* [in] */ long lWidth,
            /* [in] */ long lHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResetDecimationImageSize( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDecimateVideoImageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDecimateVideoImage * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDecimateVideoImage * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDecimateVideoImage * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetDecimationImageSize )( 
            IDecimateVideoImage * This,
            /* [in] */ long lWidth,
            /* [in] */ long lHeight);
        
        HRESULT ( STDMETHODCALLTYPE *ResetDecimationImageSize )( 
            IDecimateVideoImage * This);
        
        END_INTERFACE
    } IDecimateVideoImageVtbl;

    interface IDecimateVideoImage
    {
        CONST_VTBL struct IDecimateVideoImageVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDecimateVideoImage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDecimateVideoImage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDecimateVideoImage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDecimateVideoImage_SetDecimationImageSize(This,lWidth,lHeight)	\
    (This)->lpVtbl -> SetDecimationImageSize(This,lWidth,lHeight)

#define IDecimateVideoImage_ResetDecimationImageSize(This)	\
    (This)->lpVtbl -> ResetDecimationImageSize(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDecimateVideoImage_SetDecimationImageSize_Proxy( 
    IDecimateVideoImage * This,
    /* [in] */ long lWidth,
    /* [in] */ long lHeight);


void __RPC_STUB IDecimateVideoImage_SetDecimationImageSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDecimateVideoImage_ResetDecimationImageSize_Proxy( 
    IDecimateVideoImage * This);


void __RPC_STUB IDecimateVideoImage_ResetDecimationImageSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDecimateVideoImage_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0342 */
/* [local] */ 

typedef 
enum _DECIMATION_USAGE
    {	DECIMATION_LEGACY	= 0,
	DECIMATION_USE_DECODER_ONLY	= DECIMATION_LEGACY + 1,
	DECIMATION_USE_VIDEOPORT_ONLY	= DECIMATION_USE_DECODER_ONLY + 1,
	DECIMATION_USE_OVERLAY_ONLY	= DECIMATION_USE_VIDEOPORT_ONLY + 1,
	DECIMATION_DEFAULT	= DECIMATION_USE_OVERLAY_ONLY + 1
    } 	DECIMATION_USAGE;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0342_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0342_v0_0_s_ifspec;

#ifndef __IAMVideoDecimationProperties_INTERFACE_DEFINED__
#define __IAMVideoDecimationProperties_INTERFACE_DEFINED__

/* interface IAMVideoDecimationProperties */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IAMVideoDecimationProperties;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("60d32930-13da-11d3-9ec6-c4fcaef5c7be")
    IAMVideoDecimationProperties : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryDecimationUsage( 
            /* [out] */ DECIMATION_USAGE *lpUsage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDecimationUsage( 
            /* [in] */ DECIMATION_USAGE Usage) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMVideoDecimationPropertiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMVideoDecimationProperties * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMVideoDecimationProperties * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMVideoDecimationProperties * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryDecimationUsage )( 
            IAMVideoDecimationProperties * This,
            /* [out] */ DECIMATION_USAGE *lpUsage);
        
        HRESULT ( STDMETHODCALLTYPE *SetDecimationUsage )( 
            IAMVideoDecimationProperties * This,
            /* [in] */ DECIMATION_USAGE Usage);
        
        END_INTERFACE
    } IAMVideoDecimationPropertiesVtbl;

    interface IAMVideoDecimationProperties
    {
        CONST_VTBL struct IAMVideoDecimationPropertiesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMVideoDecimationProperties_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMVideoDecimationProperties_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMVideoDecimationProperties_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMVideoDecimationProperties_QueryDecimationUsage(This,lpUsage)	\
    (This)->lpVtbl -> QueryDecimationUsage(This,lpUsage)

#define IAMVideoDecimationProperties_SetDecimationUsage(This,Usage)	\
    (This)->lpVtbl -> SetDecimationUsage(This,Usage)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAMVideoDecimationProperties_QueryDecimationUsage_Proxy( 
    IAMVideoDecimationProperties * This,
    /* [out] */ DECIMATION_USAGE *lpUsage);


void __RPC_STUB IAMVideoDecimationProperties_QueryDecimationUsage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMVideoDecimationProperties_SetDecimationUsage_Proxy( 
    IAMVideoDecimationProperties * This,
    /* [in] */ DECIMATION_USAGE Usage);


void __RPC_STUB IAMVideoDecimationProperties_SetDecimationUsage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMVideoDecimationProperties_INTERFACE_DEFINED__ */


#ifndef __IVideoFrameStep_INTERFACE_DEFINED__
#define __IVideoFrameStep_INTERFACE_DEFINED__

/* interface IVideoFrameStep */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVideoFrameStep;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e46a9787-2b71-444d-a4b5-1fab7b708d6a")
    IVideoFrameStep : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Step( 
            DWORD dwFrames,
            /* [unique] */ IUnknown *pStepObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CanStep( 
            long bMultiple,
            /* [unique] */ IUnknown *pStepObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelStep( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVideoFrameStepVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVideoFrameStep * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVideoFrameStep * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVideoFrameStep * This);
        
        HRESULT ( STDMETHODCALLTYPE *Step )( 
            IVideoFrameStep * This,
            DWORD dwFrames,
            /* [unique] */ IUnknown *pStepObject);
        
        HRESULT ( STDMETHODCALLTYPE *CanStep )( 
            IVideoFrameStep * This,
            long bMultiple,
            /* [unique] */ IUnknown *pStepObject);
        
        HRESULT ( STDMETHODCALLTYPE *CancelStep )( 
            IVideoFrameStep * This);
        
        END_INTERFACE
    } IVideoFrameStepVtbl;

    interface IVideoFrameStep
    {
        CONST_VTBL struct IVideoFrameStepVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVideoFrameStep_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVideoFrameStep_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVideoFrameStep_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVideoFrameStep_Step(This,dwFrames,pStepObject)	\
    (This)->lpVtbl -> Step(This,dwFrames,pStepObject)

#define IVideoFrameStep_CanStep(This,bMultiple,pStepObject)	\
    (This)->lpVtbl -> CanStep(This,bMultiple,pStepObject)

#define IVideoFrameStep_CancelStep(This)	\
    (This)->lpVtbl -> CancelStep(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IVideoFrameStep_Step_Proxy( 
    IVideoFrameStep * This,
    DWORD dwFrames,
    /* [unique] */ IUnknown *pStepObject);


void __RPC_STUB IVideoFrameStep_Step_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVideoFrameStep_CanStep_Proxy( 
    IVideoFrameStep * This,
    long bMultiple,
    /* [unique] */ IUnknown *pStepObject);


void __RPC_STUB IVideoFrameStep_CanStep_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVideoFrameStep_CancelStep_Proxy( 
    IVideoFrameStep * This);


void __RPC_STUB IVideoFrameStep_CancelStep_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVideoFrameStep_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0344 */
/* [local] */ 


enum _AM_PUSHSOURCE_FLAGS
    {	AM_PUSHSOURCECAPS_INTERNAL_RM	= 0x1,
	AM_PUSHSOURCECAPS_NOT_LIVE	= 0x2,
	AM_PUSHSOURCECAPS_PRIVATE_CLOCK	= 0x4,
	AM_PUSHSOURCEREQS_USE_STREAM_CLOCK	= 0x10000
    } ;


extern RPC_IF_HANDLE __MIDL_itf_strmif_0344_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0344_v0_0_s_ifspec;

#ifndef __IAMLatency_INTERFACE_DEFINED__
#define __IAMLatency_INTERFACE_DEFINED__

/* interface IAMLatency */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMLatency;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("62EA93BA-EC62-11d2-B770-00C04FB6BD3D")
    IAMLatency : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetLatency( 
            /* [in] */ REFERENCE_TIME *prtLatency) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMLatencyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMLatency * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMLatency * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMLatency * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetLatency )( 
            IAMLatency * This,
            /* [in] */ REFERENCE_TIME *prtLatency);
        
        END_INTERFACE
    } IAMLatencyVtbl;

    interface IAMLatency
    {
        CONST_VTBL struct IAMLatencyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMLatency_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMLatency_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMLatency_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMLatency_GetLatency(This,prtLatency)	\
    (This)->lpVtbl -> GetLatency(This,prtLatency)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAMLatency_GetLatency_Proxy( 
    IAMLatency * This,
    /* [in] */ REFERENCE_TIME *prtLatency);


void __RPC_STUB IAMLatency_GetLatency_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMLatency_INTERFACE_DEFINED__ */


#ifndef __IAMPushSource_INTERFACE_DEFINED__
#define __IAMPushSource_INTERFACE_DEFINED__

/* interface IAMPushSource */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMPushSource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F185FE76-E64E-11d2-B76E-00C04FB6BD3D")
    IAMPushSource : public IAMLatency
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPushSourceFlags( 
            /* [out] */ ULONG *pFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPushSourceFlags( 
            /* [in] */ ULONG Flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStreamOffset( 
            /* [in] */ REFERENCE_TIME rtOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamOffset( 
            /* [out] */ REFERENCE_TIME *prtOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaxStreamOffset( 
            /* [out] */ REFERENCE_TIME *prtMaxOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMaxStreamOffset( 
            /* [in] */ REFERENCE_TIME rtMaxOffset) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMPushSourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMPushSource * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMPushSource * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMPushSource * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetLatency )( 
            IAMPushSource * This,
            /* [in] */ REFERENCE_TIME *prtLatency);
        
        HRESULT ( STDMETHODCALLTYPE *GetPushSourceFlags )( 
            IAMPushSource * This,
            /* [out] */ ULONG *pFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetPushSourceFlags )( 
            IAMPushSource * This,
            /* [in] */ ULONG Flags);
        
        HRESULT ( STDMETHODCALLTYPE *SetStreamOffset )( 
            IAMPushSource * This,
            /* [in] */ REFERENCE_TIME rtOffset);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamOffset )( 
            IAMPushSource * This,
            /* [out] */ REFERENCE_TIME *prtOffset);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxStreamOffset )( 
            IAMPushSource * This,
            /* [out] */ REFERENCE_TIME *prtMaxOffset);
        
        HRESULT ( STDMETHODCALLTYPE *SetMaxStreamOffset )( 
            IAMPushSource * This,
            /* [in] */ REFERENCE_TIME rtMaxOffset);
        
        END_INTERFACE
    } IAMPushSourceVtbl;

    interface IAMPushSource
    {
        CONST_VTBL struct IAMPushSourceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMPushSource_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMPushSource_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMPushSource_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMPushSource_GetLatency(This,prtLatency)	\
    (This)->lpVtbl -> GetLatency(This,prtLatency)


#define IAMPushSource_GetPushSourceFlags(This,pFlags)	\
    (This)->lpVtbl -> GetPushSourceFlags(This,pFlags)

#define IAMPushSource_SetPushSourceFlags(This,Flags)	\
    (This)->lpVtbl -> SetPushSourceFlags(This,Flags)

#define IAMPushSource_SetStreamOffset(This,rtOffset)	\
    (This)->lpVtbl -> SetStreamOffset(This,rtOffset)

#define IAMPushSource_GetStreamOffset(This,prtOffset)	\
    (This)->lpVtbl -> GetStreamOffset(This,prtOffset)

#define IAMPushSource_GetMaxStreamOffset(This,prtMaxOffset)	\
    (This)->lpVtbl -> GetMaxStreamOffset(This,prtMaxOffset)

#define IAMPushSource_SetMaxStreamOffset(This,rtMaxOffset)	\
    (This)->lpVtbl -> SetMaxStreamOffset(This,rtMaxOffset)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAMPushSource_GetPushSourceFlags_Proxy( 
    IAMPushSource * This,
    /* [out] */ ULONG *pFlags);


void __RPC_STUB IAMPushSource_GetPushSourceFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMPushSource_SetPushSourceFlags_Proxy( 
    IAMPushSource * This,
    /* [in] */ ULONG Flags);


void __RPC_STUB IAMPushSource_SetPushSourceFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMPushSource_SetStreamOffset_Proxy( 
    IAMPushSource * This,
    /* [in] */ REFERENCE_TIME rtOffset);


void __RPC_STUB IAMPushSource_SetStreamOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMPushSource_GetStreamOffset_Proxy( 
    IAMPushSource * This,
    /* [out] */ REFERENCE_TIME *prtOffset);


void __RPC_STUB IAMPushSource_GetStreamOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMPushSource_GetMaxStreamOffset_Proxy( 
    IAMPushSource * This,
    /* [out] */ REFERENCE_TIME *prtMaxOffset);


void __RPC_STUB IAMPushSource_GetMaxStreamOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMPushSource_SetMaxStreamOffset_Proxy( 
    IAMPushSource * This,
    /* [in] */ REFERENCE_TIME rtMaxOffset);


void __RPC_STUB IAMPushSource_SetMaxStreamOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMPushSource_INTERFACE_DEFINED__ */


#ifndef __IAMDeviceRemoval_INTERFACE_DEFINED__
#define __IAMDeviceRemoval_INTERFACE_DEFINED__

/* interface IAMDeviceRemoval */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMDeviceRemoval;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f90a6130-b658-11d2-ae49-0000f8754b99")
    IAMDeviceRemoval : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DeviceInfo( 
            /* [out] */ CLSID *pclsidInterfaceClass,
            /* [out] */ WCHAR **pwszSymbolicLink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reassociate( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Disassociate( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMDeviceRemovalVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMDeviceRemoval * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMDeviceRemoval * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMDeviceRemoval * This);
        
        HRESULT ( STDMETHODCALLTYPE *DeviceInfo )( 
            IAMDeviceRemoval * This,
            /* [out] */ CLSID *pclsidInterfaceClass,
            /* [out] */ WCHAR **pwszSymbolicLink);
        
        HRESULT ( STDMETHODCALLTYPE *Reassociate )( 
            IAMDeviceRemoval * This);
        
        HRESULT ( STDMETHODCALLTYPE *Disassociate )( 
            IAMDeviceRemoval * This);
        
        END_INTERFACE
    } IAMDeviceRemovalVtbl;

    interface IAMDeviceRemoval
    {
        CONST_VTBL struct IAMDeviceRemovalVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMDeviceRemoval_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMDeviceRemoval_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMDeviceRemoval_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMDeviceRemoval_DeviceInfo(This,pclsidInterfaceClass,pwszSymbolicLink)	\
    (This)->lpVtbl -> DeviceInfo(This,pclsidInterfaceClass,pwszSymbolicLink)

#define IAMDeviceRemoval_Reassociate(This)	\
    (This)->lpVtbl -> Reassociate(This)

#define IAMDeviceRemoval_Disassociate(This)	\
    (This)->lpVtbl -> Disassociate(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAMDeviceRemoval_DeviceInfo_Proxy( 
    IAMDeviceRemoval * This,
    /* [out] */ CLSID *pclsidInterfaceClass,
    /* [out] */ WCHAR **pwszSymbolicLink);


void __RPC_STUB IAMDeviceRemoval_DeviceInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMDeviceRemoval_Reassociate_Proxy( 
    IAMDeviceRemoval * This);


void __RPC_STUB IAMDeviceRemoval_Reassociate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMDeviceRemoval_Disassociate_Proxy( 
    IAMDeviceRemoval * This);


void __RPC_STUB IAMDeviceRemoval_Disassociate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMDeviceRemoval_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0346 */
/* [local] */ 

typedef /* [public][public][public] */ struct __MIDL___MIDL_itf_strmif_0346_0001
    {
    DWORD dwDVAAuxSrc;
    DWORD dwDVAAuxCtl;
    DWORD dwDVAAuxSrc1;
    DWORD dwDVAAuxCtl1;
    DWORD dwDVVAuxSrc;
    DWORD dwDVVAuxCtl;
    DWORD dwDVReserved[ 2 ];
    } 	DVINFO;

typedef struct __MIDL___MIDL_itf_strmif_0346_0001 *PDVINFO;


enum _DVENCODERRESOLUTION
    {	DVENCODERRESOLUTION_720x480	= 2012,
	DVENCODERRESOLUTION_360x240	= 2013,
	DVENCODERRESOLUTION_180x120	= 2014,
	DVENCODERRESOLUTION_88x60	= 2015
    } ;

enum _DVENCODERVIDEOFORMAT
    {	DVENCODERVIDEOFORMAT_NTSC	= 2000,
	DVENCODERVIDEOFORMAT_PAL	= 2001
    } ;

enum _DVENCODERFORMAT
    {	DVENCODERFORMAT_DVSD	= 2007,
	DVENCODERFORMAT_DVHD	= 2008,
	DVENCODERFORMAT_DVSL	= 2009
    } ;


extern RPC_IF_HANDLE __MIDL_itf_strmif_0346_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0346_v0_0_s_ifspec;

#ifndef __IDVEnc_INTERFACE_DEFINED__
#define __IDVEnc_INTERFACE_DEFINED__

/* interface IDVEnc */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDVEnc;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d18e17a0-aacb-11d0-afb0-00aa00b67a42")
    IDVEnc : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE get_IFormatResolution( 
            /* [out] */ int *VideoFormat,
            /* [out] */ int *DVFormat,
            /* [out] */ int *Resolution,
            /* [in] */ BYTE fDVInfo,
            /* [out] */ DVINFO *sDVInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_IFormatResolution( 
            /* [in] */ int VideoFormat,
            /* [in] */ int DVFormat,
            /* [in] */ int Resolution,
            /* [in] */ BYTE fDVInfo,
            /* [in] */ DVINFO *sDVInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDVEncVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDVEnc * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDVEnc * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDVEnc * This);
        
        HRESULT ( STDMETHODCALLTYPE *get_IFormatResolution )( 
            IDVEnc * This,
            /* [out] */ int *VideoFormat,
            /* [out] */ int *DVFormat,
            /* [out] */ int *Resolution,
            /* [in] */ BYTE fDVInfo,
            /* [out] */ DVINFO *sDVInfo);
        
        HRESULT ( STDMETHODCALLTYPE *put_IFormatResolution )( 
            IDVEnc * This,
            /* [in] */ int VideoFormat,
            /* [in] */ int DVFormat,
            /* [in] */ int Resolution,
            /* [in] */ BYTE fDVInfo,
            /* [in] */ DVINFO *sDVInfo);
        
        END_INTERFACE
    } IDVEncVtbl;

    interface IDVEnc
    {
        CONST_VTBL struct IDVEncVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDVEnc_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDVEnc_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDVEnc_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDVEnc_get_IFormatResolution(This,VideoFormat,DVFormat,Resolution,fDVInfo,sDVInfo)	\
    (This)->lpVtbl -> get_IFormatResolution(This,VideoFormat,DVFormat,Resolution,fDVInfo,sDVInfo)

#define IDVEnc_put_IFormatResolution(This,VideoFormat,DVFormat,Resolution,fDVInfo,sDVInfo)	\
    (This)->lpVtbl -> put_IFormatResolution(This,VideoFormat,DVFormat,Resolution,fDVInfo,sDVInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDVEnc_get_IFormatResolution_Proxy( 
    IDVEnc * This,
    /* [out] */ int *VideoFormat,
    /* [out] */ int *DVFormat,
    /* [out] */ int *Resolution,
    /* [in] */ BYTE fDVInfo,
    /* [out] */ DVINFO *sDVInfo);


void __RPC_STUB IDVEnc_get_IFormatResolution_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDVEnc_put_IFormatResolution_Proxy( 
    IDVEnc * This,
    /* [in] */ int VideoFormat,
    /* [in] */ int DVFormat,
    /* [in] */ int Resolution,
    /* [in] */ BYTE fDVInfo,
    /* [in] */ DVINFO *sDVInfo);


void __RPC_STUB IDVEnc_put_IFormatResolution_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDVEnc_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0347 */
/* [local] */ 


enum _DVDECODERRESOLUTION
    {	DVDECODERRESOLUTION_720x480	= 1000,
	DVDECODERRESOLUTION_360x240	= 1001,
	DVDECODERRESOLUTION_180x120	= 1002,
	DVDECODERRESOLUTION_88x60	= 1003
    } ;

enum _DVRESOLUTION
    {	DVRESOLUTION_FULL	= 1000,
	DVRESOLUTION_HALF	= 1001,
	DVRESOLUTION_QUARTER	= 1002,
	DVRESOLUTION_DC	= 1003
    } ;


extern RPC_IF_HANDLE __MIDL_itf_strmif_0347_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0347_v0_0_s_ifspec;

#ifndef __IIPDVDec_INTERFACE_DEFINED__
#define __IIPDVDec_INTERFACE_DEFINED__

/* interface IIPDVDec */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IIPDVDec;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b8e8bd60-0bfe-11d0-af91-00aa00b67a42")
    IIPDVDec : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE get_IPDisplay( 
            /* [out] */ int *displayPix) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_IPDisplay( 
            /* [in] */ int displayPix) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IIPDVDecVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IIPDVDec * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IIPDVDec * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IIPDVDec * This);
        
        HRESULT ( STDMETHODCALLTYPE *get_IPDisplay )( 
            IIPDVDec * This,
            /* [out] */ int *displayPix);
        
        HRESULT ( STDMETHODCALLTYPE *put_IPDisplay )( 
            IIPDVDec * This,
            /* [in] */ int displayPix);
        
        END_INTERFACE
    } IIPDVDecVtbl;

    interface IIPDVDec
    {
        CONST_VTBL struct IIPDVDecVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IIPDVDec_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IIPDVDec_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IIPDVDec_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IIPDVDec_get_IPDisplay(This,displayPix)	\
    (This)->lpVtbl -> get_IPDisplay(This,displayPix)

#define IIPDVDec_put_IPDisplay(This,displayPix)	\
    (This)->lpVtbl -> put_IPDisplay(This,displayPix)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IIPDVDec_get_IPDisplay_Proxy( 
    IIPDVDec * This,
    /* [out] */ int *displayPix);


void __RPC_STUB IIPDVDec_get_IPDisplay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIPDVDec_put_IPDisplay_Proxy( 
    IIPDVDec * This,
    /* [in] */ int displayPix);


void __RPC_STUB IIPDVDec_put_IPDisplay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IIPDVDec_INTERFACE_DEFINED__ */


#ifndef __IDVRGB219_INTERFACE_DEFINED__
#define __IDVRGB219_INTERFACE_DEFINED__

/* interface IDVRGB219 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDVRGB219;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("58473A19-2BC8-4663-8012-25F81BABDDD1")
    IDVRGB219 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetRGB219( 
            /* [in] */ BOOL bState) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDVRGB219Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDVRGB219 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDVRGB219 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDVRGB219 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetRGB219 )( 
            IDVRGB219 * This,
            /* [in] */ BOOL bState);
        
        END_INTERFACE
    } IDVRGB219Vtbl;

    interface IDVRGB219
    {
        CONST_VTBL struct IDVRGB219Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDVRGB219_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDVRGB219_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDVRGB219_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDVRGB219_SetRGB219(This,bState)	\
    (This)->lpVtbl -> SetRGB219(This,bState)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDVRGB219_SetRGB219_Proxy( 
    IDVRGB219 * This,
    /* [in] */ BOOL bState);


void __RPC_STUB IDVRGB219_SetRGB219_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDVRGB219_INTERFACE_DEFINED__ */


#ifndef __IDVSplitter_INTERFACE_DEFINED__
#define __IDVSplitter_INTERFACE_DEFINED__

/* interface IDVSplitter */
/* [uuid][object] */ 


EXTERN_C const IID IID_IDVSplitter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("92a3a302-da7c-4a1f-ba7e-1802bb5d2d02")
    IDVSplitter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DiscardAlternateVideoFrames( 
            /* [in] */ int nDiscard) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDVSplitterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDVSplitter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDVSplitter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDVSplitter * This);
        
        HRESULT ( STDMETHODCALLTYPE *DiscardAlternateVideoFrames )( 
            IDVSplitter * This,
            /* [in] */ int nDiscard);
        
        END_INTERFACE
    } IDVSplitterVtbl;

    interface IDVSplitter
    {
        CONST_VTBL struct IDVSplitterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDVSplitter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDVSplitter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDVSplitter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDVSplitter_DiscardAlternateVideoFrames(This,nDiscard)	\
    (This)->lpVtbl -> DiscardAlternateVideoFrames(This,nDiscard)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDVSplitter_DiscardAlternateVideoFrames_Proxy( 
    IDVSplitter * This,
    /* [in] */ int nDiscard);


void __RPC_STUB IDVSplitter_DiscardAlternateVideoFrames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDVSplitter_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0350 */
/* [local] */ 


enum _AM_AUDIO_RENDERER_STAT_PARAM
    {	AM_AUDREND_STAT_PARAM_BREAK_COUNT	= 1,
	AM_AUDREND_STAT_PARAM_SLAVE_MODE	= AM_AUDREND_STAT_PARAM_BREAK_COUNT + 1,
	AM_AUDREND_STAT_PARAM_SILENCE_DUR	= AM_AUDREND_STAT_PARAM_SLAVE_MODE + 1,
	AM_AUDREND_STAT_PARAM_LAST_BUFFER_DUR	= AM_AUDREND_STAT_PARAM_SILENCE_DUR + 1,
	AM_AUDREND_STAT_PARAM_DISCONTINUITIES	= AM_AUDREND_STAT_PARAM_LAST_BUFFER_DUR + 1,
	AM_AUDREND_STAT_PARAM_SLAVE_RATE	= AM_AUDREND_STAT_PARAM_DISCONTINUITIES + 1,
	AM_AUDREND_STAT_PARAM_SLAVE_DROPWRITE_DUR	= AM_AUDREND_STAT_PARAM_SLAVE_RATE + 1,
	AM_AUDREND_STAT_PARAM_SLAVE_HIGHLOWERROR	= AM_AUDREND_STAT_PARAM_SLAVE_DROPWRITE_DUR + 1,
	AM_AUDREND_STAT_PARAM_SLAVE_LASTHIGHLOWERROR	= AM_AUDREND_STAT_PARAM_SLAVE_HIGHLOWERROR + 1,
	AM_AUDREND_STAT_PARAM_SLAVE_ACCUMERROR	= AM_AUDREND_STAT_PARAM_SLAVE_LASTHIGHLOWERROR + 1,
	AM_AUDREND_STAT_PARAM_BUFFERFULLNESS	= AM_AUDREND_STAT_PARAM_SLAVE_ACCUMERROR + 1,
	AM_AUDREND_STAT_PARAM_JITTER	= AM_AUDREND_STAT_PARAM_BUFFERFULLNESS + 1
    } ;


extern RPC_IF_HANDLE __MIDL_itf_strmif_0350_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0350_v0_0_s_ifspec;

#ifndef __IAMAudioRendererStats_INTERFACE_DEFINED__
#define __IAMAudioRendererStats_INTERFACE_DEFINED__

/* interface IAMAudioRendererStats */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMAudioRendererStats;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("22320CB2-D41A-11d2-BF7C-D7CB9DF0BF93")
    IAMAudioRendererStats : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStatParam( 
            /* [in] */ DWORD dwParam,
            /* [out] */ DWORD *pdwParam1,
            /* [out] */ DWORD *pdwParam2) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMAudioRendererStatsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMAudioRendererStats * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMAudioRendererStats * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMAudioRendererStats * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatParam )( 
            IAMAudioRendererStats * This,
            /* [in] */ DWORD dwParam,
            /* [out] */ DWORD *pdwParam1,
            /* [out] */ DWORD *pdwParam2);
        
        END_INTERFACE
    } IAMAudioRendererStatsVtbl;

    interface IAMAudioRendererStats
    {
        CONST_VTBL struct IAMAudioRendererStatsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMAudioRendererStats_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMAudioRendererStats_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMAudioRendererStats_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMAudioRendererStats_GetStatParam(This,dwParam,pdwParam1,pdwParam2)	\
    (This)->lpVtbl -> GetStatParam(This,dwParam,pdwParam1,pdwParam2)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAMAudioRendererStats_GetStatParam_Proxy( 
    IAMAudioRendererStats * This,
    /* [in] */ DWORD dwParam,
    /* [out] */ DWORD *pdwParam1,
    /* [out] */ DWORD *pdwParam2);


void __RPC_STUB IAMAudioRendererStats_GetStatParam_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMAudioRendererStats_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0352 */
/* [local] */ 


enum _AM_INTF_SEARCH_FLAGS
    {	AM_INTF_SEARCH_INPUT_PIN	= 0x1,
	AM_INTF_SEARCH_OUTPUT_PIN	= 0x2,
	AM_INTF_SEARCH_FILTER	= 0x4
    } ;


extern RPC_IF_HANDLE __MIDL_itf_strmif_0352_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0352_v0_0_s_ifspec;

#ifndef __IAMGraphStreams_INTERFACE_DEFINED__
#define __IAMGraphStreams_INTERFACE_DEFINED__

/* interface IAMGraphStreams */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMGraphStreams;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("632105FA-072E-11d3-8AF9-00C04FB6BD3D")
    IAMGraphStreams : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FindUpstreamInterface( 
            /* [in] */ IPin *pPin,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvInterface,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SyncUsingStreamOffset( 
            /* [in] */ BOOL bUseStreamOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMaxGraphLatency( 
            /* [in] */ REFERENCE_TIME rtMaxGraphLatency) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMGraphStreamsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMGraphStreams * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMGraphStreams * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMGraphStreams * This);
        
        HRESULT ( STDMETHODCALLTYPE *FindUpstreamInterface )( 
            IAMGraphStreams * This,
            /* [in] */ IPin *pPin,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvInterface,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SyncUsingStreamOffset )( 
            IAMGraphStreams * This,
            /* [in] */ BOOL bUseStreamOffset);
        
        HRESULT ( STDMETHODCALLTYPE *SetMaxGraphLatency )( 
            IAMGraphStreams * This,
            /* [in] */ REFERENCE_TIME rtMaxGraphLatency);
        
        END_INTERFACE
    } IAMGraphStreamsVtbl;

    interface IAMGraphStreams
    {
        CONST_VTBL struct IAMGraphStreamsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMGraphStreams_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMGraphStreams_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMGraphStreams_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMGraphStreams_FindUpstreamInterface(This,pPin,riid,ppvInterface,dwFlags)	\
    (This)->lpVtbl -> FindUpstreamInterface(This,pPin,riid,ppvInterface,dwFlags)

#define IAMGraphStreams_SyncUsingStreamOffset(This,bUseStreamOffset)	\
    (This)->lpVtbl -> SyncUsingStreamOffset(This,bUseStreamOffset)

#define IAMGraphStreams_SetMaxGraphLatency(This,rtMaxGraphLatency)	\
    (This)->lpVtbl -> SetMaxGraphLatency(This,rtMaxGraphLatency)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAMGraphStreams_FindUpstreamInterface_Proxy( 
    IAMGraphStreams * This,
    /* [in] */ IPin *pPin,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void **ppvInterface,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IAMGraphStreams_FindUpstreamInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMGraphStreams_SyncUsingStreamOffset_Proxy( 
    IAMGraphStreams * This,
    /* [in] */ BOOL bUseStreamOffset);


void __RPC_STUB IAMGraphStreams_SyncUsingStreamOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMGraphStreams_SetMaxGraphLatency_Proxy( 
    IAMGraphStreams * This,
    /* [in] */ REFERENCE_TIME rtMaxGraphLatency);


void __RPC_STUB IAMGraphStreams_SetMaxGraphLatency_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMGraphStreams_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0353 */
/* [local] */ 


enum AMOVERLAYFX
    {	AMOVERFX_NOFX	= 0,
	AMOVERFX_MIRRORLEFTRIGHT	= 0x2,
	AMOVERFX_MIRRORUPDOWN	= 0x4,
	AMOVERFX_DEINTERLACE	= 0x8
    } ;


extern RPC_IF_HANDLE __MIDL_itf_strmif_0353_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0353_v0_0_s_ifspec;

#ifndef __IAMOverlayFX_INTERFACE_DEFINED__
#define __IAMOverlayFX_INTERFACE_DEFINED__

/* interface IAMOverlayFX */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMOverlayFX;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("62fae250-7e65-4460-bfc9-6398b322073c")
    IAMOverlayFX : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryOverlayFXCaps( 
            /* [out] */ DWORD *lpdwOverlayFXCaps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOverlayFX( 
            /* [in] */ DWORD dwOverlayFX) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOverlayFX( 
            /* [out] */ DWORD *lpdwOverlayFX) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMOverlayFXVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMOverlayFX * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMOverlayFX * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMOverlayFX * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryOverlayFXCaps )( 
            IAMOverlayFX * This,
            /* [out] */ DWORD *lpdwOverlayFXCaps);
        
        HRESULT ( STDMETHODCALLTYPE *SetOverlayFX )( 
            IAMOverlayFX * This,
            /* [in] */ DWORD dwOverlayFX);
        
        HRESULT ( STDMETHODCALLTYPE *GetOverlayFX )( 
            IAMOverlayFX * This,
            /* [out] */ DWORD *lpdwOverlayFX);
        
        END_INTERFACE
    } IAMOverlayFXVtbl;

    interface IAMOverlayFX
    {
        CONST_VTBL struct IAMOverlayFXVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMOverlayFX_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMOverlayFX_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMOverlayFX_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMOverlayFX_QueryOverlayFXCaps(This,lpdwOverlayFXCaps)	\
    (This)->lpVtbl -> QueryOverlayFXCaps(This,lpdwOverlayFXCaps)

#define IAMOverlayFX_SetOverlayFX(This,dwOverlayFX)	\
    (This)->lpVtbl -> SetOverlayFX(This,dwOverlayFX)

#define IAMOverlayFX_GetOverlayFX(This,lpdwOverlayFX)	\
    (This)->lpVtbl -> GetOverlayFX(This,lpdwOverlayFX)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAMOverlayFX_QueryOverlayFXCaps_Proxy( 
    IAMOverlayFX * This,
    /* [out] */ DWORD *lpdwOverlayFXCaps);


void __RPC_STUB IAMOverlayFX_QueryOverlayFXCaps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMOverlayFX_SetOverlayFX_Proxy( 
    IAMOverlayFX * This,
    /* [in] */ DWORD dwOverlayFX);


void __RPC_STUB IAMOverlayFX_SetOverlayFX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMOverlayFX_GetOverlayFX_Proxy( 
    IAMOverlayFX * This,
    /* [out] */ DWORD *lpdwOverlayFX);


void __RPC_STUB IAMOverlayFX_GetOverlayFX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMOverlayFX_INTERFACE_DEFINED__ */


#ifndef __IAMOpenProgress_INTERFACE_DEFINED__
#define __IAMOpenProgress_INTERFACE_DEFINED__

/* interface IAMOpenProgress */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMOpenProgress;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8E1C39A1-DE53-11cf-AA63-0080C744528D")
    IAMOpenProgress : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryProgress( 
            /* [out] */ LONGLONG *pllTotal,
            /* [out] */ LONGLONG *pllCurrent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AbortOperation( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMOpenProgressVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMOpenProgress * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMOpenProgress * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMOpenProgress * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryProgress )( 
            IAMOpenProgress * This,
            /* [out] */ LONGLONG *pllTotal,
            /* [out] */ LONGLONG *pllCurrent);
        
        HRESULT ( STDMETHODCALLTYPE *AbortOperation )( 
            IAMOpenProgress * This);
        
        END_INTERFACE
    } IAMOpenProgressVtbl;

    interface IAMOpenProgress
    {
        CONST_VTBL struct IAMOpenProgressVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMOpenProgress_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMOpenProgress_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMOpenProgress_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMOpenProgress_QueryProgress(This,pllTotal,pllCurrent)	\
    (This)->lpVtbl -> QueryProgress(This,pllTotal,pllCurrent)

#define IAMOpenProgress_AbortOperation(This)	\
    (This)->lpVtbl -> AbortOperation(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAMOpenProgress_QueryProgress_Proxy( 
    IAMOpenProgress * This,
    /* [out] */ LONGLONG *pllTotal,
    /* [out] */ LONGLONG *pllCurrent);


void __RPC_STUB IAMOpenProgress_QueryProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMOpenProgress_AbortOperation_Proxy( 
    IAMOpenProgress * This);


void __RPC_STUB IAMOpenProgress_AbortOperation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMOpenProgress_INTERFACE_DEFINED__ */


#ifndef __IMpeg2Demultiplexer_INTERFACE_DEFINED__
#define __IMpeg2Demultiplexer_INTERFACE_DEFINED__

/* interface IMpeg2Demultiplexer */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IMpeg2Demultiplexer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("436eee9c-264f-4242-90e1-4e330c107512")
    IMpeg2Demultiplexer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateOutputPin( 
            /* [in] */ AM_MEDIA_TYPE *pMediaType,
            /* [in] */ LPWSTR pszPinName,
            /* [out] */ IPin **ppIPin) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOutputPinMediaType( 
            /* [in] */ LPWSTR pszPinName,
            /* [in] */ AM_MEDIA_TYPE *pMediaType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteOutputPin( 
            /* [in] */ LPWSTR pszPinName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMpeg2DemultiplexerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMpeg2Demultiplexer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMpeg2Demultiplexer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMpeg2Demultiplexer * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateOutputPin )( 
            IMpeg2Demultiplexer * This,
            /* [in] */ AM_MEDIA_TYPE *pMediaType,
            /* [in] */ LPWSTR pszPinName,
            /* [out] */ IPin **ppIPin);
        
        HRESULT ( STDMETHODCALLTYPE *SetOutputPinMediaType )( 
            IMpeg2Demultiplexer * This,
            /* [in] */ LPWSTR pszPinName,
            /* [in] */ AM_MEDIA_TYPE *pMediaType);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteOutputPin )( 
            IMpeg2Demultiplexer * This,
            /* [in] */ LPWSTR pszPinName);
        
        END_INTERFACE
    } IMpeg2DemultiplexerVtbl;

    interface IMpeg2Demultiplexer
    {
        CONST_VTBL struct IMpeg2DemultiplexerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMpeg2Demultiplexer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMpeg2Demultiplexer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMpeg2Demultiplexer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMpeg2Demultiplexer_CreateOutputPin(This,pMediaType,pszPinName,ppIPin)	\
    (This)->lpVtbl -> CreateOutputPin(This,pMediaType,pszPinName,ppIPin)

#define IMpeg2Demultiplexer_SetOutputPinMediaType(This,pszPinName,pMediaType)	\
    (This)->lpVtbl -> SetOutputPinMediaType(This,pszPinName,pMediaType)

#define IMpeg2Demultiplexer_DeleteOutputPin(This,pszPinName)	\
    (This)->lpVtbl -> DeleteOutputPin(This,pszPinName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMpeg2Demultiplexer_CreateOutputPin_Proxy( 
    IMpeg2Demultiplexer * This,
    /* [in] */ AM_MEDIA_TYPE *pMediaType,
    /* [in] */ LPWSTR pszPinName,
    /* [out] */ IPin **ppIPin);


void __RPC_STUB IMpeg2Demultiplexer_CreateOutputPin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMpeg2Demultiplexer_SetOutputPinMediaType_Proxy( 
    IMpeg2Demultiplexer * This,
    /* [in] */ LPWSTR pszPinName,
    /* [in] */ AM_MEDIA_TYPE *pMediaType);


void __RPC_STUB IMpeg2Demultiplexer_SetOutputPinMediaType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMpeg2Demultiplexer_DeleteOutputPin_Proxy( 
    IMpeg2Demultiplexer * This,
    /* [in] */ LPWSTR pszPinName);


void __RPC_STUB IMpeg2Demultiplexer_DeleteOutputPin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMpeg2Demultiplexer_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0356 */
/* [local] */ 

#define MPEG2_PROGRAM_STREAM_MAP                 0x00000000
#define MPEG2_PROGRAM_ELEMENTARY_STREAM          0x00000001
#define MPEG2_PROGRAM_DIRECTORY_PES_PACKET       0x00000002
#define MPEG2_PROGRAM_PACK_HEADER                0x00000003
#define MPEG2_PROGRAM_PES_STREAM                 0x00000004
#define MPEG2_PROGRAM_SYSTEM_HEADER              0x00000005
#define SUBSTREAM_FILTER_VAL_NONE                0x10000000
typedef /* [public][public] */ struct __MIDL___MIDL_itf_strmif_0356_0001
    {
    ULONG stream_id;
    DWORD dwMediaSampleContent;
    ULONG ulSubstreamFilterValue;
    int iDataOffset;
    } 	STREAM_ID_MAP;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0356_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0356_v0_0_s_ifspec;

#ifndef __IEnumStreamIdMap_INTERFACE_DEFINED__
#define __IEnumStreamIdMap_INTERFACE_DEFINED__

/* interface IEnumStreamIdMap */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IEnumStreamIdMap;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("945C1566-6202-46fc-96C7-D87F289C6534")
    IEnumStreamIdMap : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG cRequest,
            /* [size_is][out][in] */ STREAM_ID_MAP *pStreamIdMap,
            /* [out] */ ULONG *pcReceived) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cRecords) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumStreamIdMap **ppIEnumStreamIdMap) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumStreamIdMapVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumStreamIdMap * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumStreamIdMap * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumStreamIdMap * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumStreamIdMap * This,
            /* [in] */ ULONG cRequest,
            /* [size_is][out][in] */ STREAM_ID_MAP *pStreamIdMap,
            /* [out] */ ULONG *pcReceived);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumStreamIdMap * This,
            /* [in] */ ULONG cRecords);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumStreamIdMap * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumStreamIdMap * This,
            /* [out] */ IEnumStreamIdMap **ppIEnumStreamIdMap);
        
        END_INTERFACE
    } IEnumStreamIdMapVtbl;

    interface IEnumStreamIdMap
    {
        CONST_VTBL struct IEnumStreamIdMapVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumStreamIdMap_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumStreamIdMap_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumStreamIdMap_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumStreamIdMap_Next(This,cRequest,pStreamIdMap,pcReceived)	\
    (This)->lpVtbl -> Next(This,cRequest,pStreamIdMap,pcReceived)

#define IEnumStreamIdMap_Skip(This,cRecords)	\
    (This)->lpVtbl -> Skip(This,cRecords)

#define IEnumStreamIdMap_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumStreamIdMap_Clone(This,ppIEnumStreamIdMap)	\
    (This)->lpVtbl -> Clone(This,ppIEnumStreamIdMap)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumStreamIdMap_Next_Proxy( 
    IEnumStreamIdMap * This,
    /* [in] */ ULONG cRequest,
    /* [size_is][out][in] */ STREAM_ID_MAP *pStreamIdMap,
    /* [out] */ ULONG *pcReceived);


void __RPC_STUB IEnumStreamIdMap_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumStreamIdMap_Skip_Proxy( 
    IEnumStreamIdMap * This,
    /* [in] */ ULONG cRecords);


void __RPC_STUB IEnumStreamIdMap_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumStreamIdMap_Reset_Proxy( 
    IEnumStreamIdMap * This);


void __RPC_STUB IEnumStreamIdMap_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumStreamIdMap_Clone_Proxy( 
    IEnumStreamIdMap * This,
    /* [out] */ IEnumStreamIdMap **ppIEnumStreamIdMap);


void __RPC_STUB IEnumStreamIdMap_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumStreamIdMap_INTERFACE_DEFINED__ */


#ifndef __IMPEG2StreamIdMap_INTERFACE_DEFINED__
#define __IMPEG2StreamIdMap_INTERFACE_DEFINED__

/* interface IMPEG2StreamIdMap */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IMPEG2StreamIdMap;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D0E04C47-25B8-4369-925A-362A01D95444")
    IMPEG2StreamIdMap : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE MapStreamId( 
            /* [in] */ ULONG ulStreamId,
            /* [in] */ DWORD MediaSampleContent,
            /* [in] */ ULONG ulSubstreamFilterValue,
            /* [in] */ int iDataOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnmapStreamId( 
            /* [in] */ ULONG culStreamId,
            /* [in] */ ULONG *pulStreamId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumStreamIdMap( 
            /* [out] */ IEnumStreamIdMap **ppIEnumStreamIdMap) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMPEG2StreamIdMapVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMPEG2StreamIdMap * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMPEG2StreamIdMap * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMPEG2StreamIdMap * This);
        
        HRESULT ( STDMETHODCALLTYPE *MapStreamId )( 
            IMPEG2StreamIdMap * This,
            /* [in] */ ULONG ulStreamId,
            /* [in] */ DWORD MediaSampleContent,
            /* [in] */ ULONG ulSubstreamFilterValue,
            /* [in] */ int iDataOffset);
        
        HRESULT ( STDMETHODCALLTYPE *UnmapStreamId )( 
            IMPEG2StreamIdMap * This,
            /* [in] */ ULONG culStreamId,
            /* [in] */ ULONG *pulStreamId);
        
        HRESULT ( STDMETHODCALLTYPE *EnumStreamIdMap )( 
            IMPEG2StreamIdMap * This,
            /* [out] */ IEnumStreamIdMap **ppIEnumStreamIdMap);
        
        END_INTERFACE
    } IMPEG2StreamIdMapVtbl;

    interface IMPEG2StreamIdMap
    {
        CONST_VTBL struct IMPEG2StreamIdMapVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMPEG2StreamIdMap_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMPEG2StreamIdMap_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMPEG2StreamIdMap_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMPEG2StreamIdMap_MapStreamId(This,ulStreamId,MediaSampleContent,ulSubstreamFilterValue,iDataOffset)	\
    (This)->lpVtbl -> MapStreamId(This,ulStreamId,MediaSampleContent,ulSubstreamFilterValue,iDataOffset)

#define IMPEG2StreamIdMap_UnmapStreamId(This,culStreamId,pulStreamId)	\
    (This)->lpVtbl -> UnmapStreamId(This,culStreamId,pulStreamId)

#define IMPEG2StreamIdMap_EnumStreamIdMap(This,ppIEnumStreamIdMap)	\
    (This)->lpVtbl -> EnumStreamIdMap(This,ppIEnumStreamIdMap)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMPEG2StreamIdMap_MapStreamId_Proxy( 
    IMPEG2StreamIdMap * This,
    /* [in] */ ULONG ulStreamId,
    /* [in] */ DWORD MediaSampleContent,
    /* [in] */ ULONG ulSubstreamFilterValue,
    /* [in] */ int iDataOffset);


void __RPC_STUB IMPEG2StreamIdMap_MapStreamId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMPEG2StreamIdMap_UnmapStreamId_Proxy( 
    IMPEG2StreamIdMap * This,
    /* [in] */ ULONG culStreamId,
    /* [in] */ ULONG *pulStreamId);


void __RPC_STUB IMPEG2StreamIdMap_UnmapStreamId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMPEG2StreamIdMap_EnumStreamIdMap_Proxy( 
    IMPEG2StreamIdMap * This,
    /* [out] */ IEnumStreamIdMap **ppIEnumStreamIdMap);


void __RPC_STUB IMPEG2StreamIdMap_EnumStreamIdMap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMPEG2StreamIdMap_INTERFACE_DEFINED__ */


#ifndef __IRegisterServiceProvider_INTERFACE_DEFINED__
#define __IRegisterServiceProvider_INTERFACE_DEFINED__

/* interface IRegisterServiceProvider */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IRegisterServiceProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7B3A2F01-0751-48DD-B556-004785171C54")
    IRegisterServiceProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterService( 
            /* [in] */ REFGUID guidService,
            /* [in] */ IUnknown *pUnkObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRegisterServiceProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRegisterServiceProvider * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRegisterServiceProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRegisterServiceProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterService )( 
            IRegisterServiceProvider * This,
            /* [in] */ REFGUID guidService,
            /* [in] */ IUnknown *pUnkObject);
        
        END_INTERFACE
    } IRegisterServiceProviderVtbl;

    interface IRegisterServiceProvider
    {
        CONST_VTBL struct IRegisterServiceProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRegisterServiceProvider_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRegisterServiceProvider_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRegisterServiceProvider_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRegisterServiceProvider_RegisterService(This,guidService,pUnkObject)	\
    (This)->lpVtbl -> RegisterService(This,guidService,pUnkObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRegisterServiceProvider_RegisterService_Proxy( 
    IRegisterServiceProvider * This,
    /* [in] */ REFGUID guidService,
    /* [in] */ IUnknown *pUnkObject);


void __RPC_STUB IRegisterServiceProvider_RegisterService_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRegisterServiceProvider_INTERFACE_DEFINED__ */


#ifndef __IAMClockSlave_INTERFACE_DEFINED__
#define __IAMClockSlave_INTERFACE_DEFINED__

/* interface IAMClockSlave */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMClockSlave;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9FD52741-176D-4b36-8F51-CA8F933223BE")
    IAMClockSlave : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetErrorTolerance( 
            /* [in] */ DWORD dwTolerance) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetErrorTolerance( 
            /* [out] */ DWORD *pdwTolerance) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMClockSlaveVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMClockSlave * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMClockSlave * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMClockSlave * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetErrorTolerance )( 
            IAMClockSlave * This,
            /* [in] */ DWORD dwTolerance);
        
        HRESULT ( STDMETHODCALLTYPE *GetErrorTolerance )( 
            IAMClockSlave * This,
            /* [out] */ DWORD *pdwTolerance);
        
        END_INTERFACE
    } IAMClockSlaveVtbl;

    interface IAMClockSlave
    {
        CONST_VTBL struct IAMClockSlaveVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMClockSlave_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMClockSlave_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMClockSlave_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMClockSlave_SetErrorTolerance(This,dwTolerance)	\
    (This)->lpVtbl -> SetErrorTolerance(This,dwTolerance)

#define IAMClockSlave_GetErrorTolerance(This,pdwTolerance)	\
    (This)->lpVtbl -> GetErrorTolerance(This,pdwTolerance)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAMClockSlave_SetErrorTolerance_Proxy( 
    IAMClockSlave * This,
    /* [in] */ DWORD dwTolerance);


void __RPC_STUB IAMClockSlave_SetErrorTolerance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMClockSlave_GetErrorTolerance_Proxy( 
    IAMClockSlave * This,
    /* [out] */ DWORD *pdwTolerance);


void __RPC_STUB IAMClockSlave_GetErrorTolerance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMClockSlave_INTERFACE_DEFINED__ */


#ifndef __IAMGraphBuilderCallback_INTERFACE_DEFINED__
#define __IAMGraphBuilderCallback_INTERFACE_DEFINED__

/* interface IAMGraphBuilderCallback */
/* [unique][local][uuid][object] */ 


EXTERN_C const IID IID_IAMGraphBuilderCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4995f511-9ddb-4f12-bd3b-f04611807b79")
    IAMGraphBuilderCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SelectedFilter( 
            /* [in] */ IMoniker *pMon) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreatedFilter( 
            /* [in] */ IBaseFilter *pFil) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMGraphBuilderCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMGraphBuilderCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMGraphBuilderCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMGraphBuilderCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *SelectedFilter )( 
            IAMGraphBuilderCallback * This,
            /* [in] */ IMoniker *pMon);
        
        HRESULT ( STDMETHODCALLTYPE *CreatedFilter )( 
            IAMGraphBuilderCallback * This,
            /* [in] */ IBaseFilter *pFil);
        
        END_INTERFACE
    } IAMGraphBuilderCallbackVtbl;

    interface IAMGraphBuilderCallback
    {
        CONST_VTBL struct IAMGraphBuilderCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMGraphBuilderCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMGraphBuilderCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMGraphBuilderCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMGraphBuilderCallback_SelectedFilter(This,pMon)	\
    (This)->lpVtbl -> SelectedFilter(This,pMon)

#define IAMGraphBuilderCallback_CreatedFilter(This,pFil)	\
    (This)->lpVtbl -> CreatedFilter(This,pFil)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAMGraphBuilderCallback_SelectedFilter_Proxy( 
    IAMGraphBuilderCallback * This,
    /* [in] */ IMoniker *pMon);


void __RPC_STUB IAMGraphBuilderCallback_SelectedFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMGraphBuilderCallback_CreatedFilter_Proxy( 
    IAMGraphBuilderCallback * This,
    /* [in] */ IBaseFilter *pFil);


void __RPC_STUB IAMGraphBuilderCallback_CreatedFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMGraphBuilderCallback_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0361 */
/* [local] */ 

#ifdef __cplusplus
#ifndef _IAMFilterGraphCallback_
#define _IAMFilterGraphCallback_
// Note: Because this interface was not defined as a proper interface it is
//       supported under C++ only. Methods aren't stdcall.
EXTERN_GUID(IID_IAMFilterGraphCallback,0x56a868fd,0x0ad4,0x11ce,0xb0,0xa3,0x0,0x20,0xaf,0x0b,0xa7,0x70);
interface IAMFilterGraphCallback : public IUnknown
{
    // S_OK means rendering complete, S_FALSE means retry now.
    virtual HRESULT UnableToRender(IPin *pPin) = 0;
 
};
#endif // _IAMFilterGraphCallback_
#endif
struct CodecAPIEventData
    {
    GUID guid;
    DWORD dataLength;
    DWORD reserved[ 3 ];
    } ;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0361_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0361_v0_0_s_ifspec;

#ifndef __ICodecAPI_INTERFACE_DEFINED__
#define __ICodecAPI_INTERFACE_DEFINED__

/* interface ICodecAPI */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICodecAPI;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("901db4c7-31ce-41a2-85dc-8fa0bf41b8da")
    ICodecAPI : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsSupported( 
            /* [in] */ const GUID *Api) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsModifiable( 
            /* [in] */ const GUID *Api) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParameterRange( 
            /* [in] */ const GUID *Api,
            /* [out] */ VARIANT *ValueMin,
            /* [out] */ VARIANT *ValueMax,
            /* [out] */ VARIANT *SteppingDelta) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParameterValues( 
            /* [in] */ const GUID *Api,
            /* [size_is][size_is][out] */ VARIANT **Values,
            /* [out] */ ULONG *ValuesCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultValue( 
            /* [in] */ const GUID *Api,
            /* [out] */ VARIANT *Value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [in] */ const GUID *Api,
            /* [out] */ VARIANT *Value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            /* [in] */ const GUID *Api,
            /* [in] */ VARIANT *Value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterForEvent( 
            /* [in] */ const GUID *Api,
            /* [in] */ LONG_PTR userData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterForEvent( 
            /* [in] */ const GUID *Api) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAllDefaults( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValueWithNotify( 
            /* [in] */ const GUID *Api,
            /* [in] */ VARIANT *Value,
            /* [size_is][size_is][out] */ GUID **ChangedParam,
            /* [out] */ ULONG *ChangedParamCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAllDefaultsWithNotify( 
            /* [size_is][size_is][out] */ GUID **ChangedParam,
            /* [out] */ ULONG *ChangedParamCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAllSettings( 
            /* [in] */ IStream *__MIDL_0016) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAllSettings( 
            /* [in] */ IStream *__MIDL_0017) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAllSettingsWithNotify( 
            IStream *__MIDL_0018,
            /* [size_is][size_is][out] */ GUID **ChangedParam,
            /* [out] */ ULONG *ChangedParamCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICodecAPIVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICodecAPI * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICodecAPI * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICodecAPI * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsSupported )( 
            ICodecAPI * This,
            /* [in] */ const GUID *Api);
        
        HRESULT ( STDMETHODCALLTYPE *IsModifiable )( 
            ICodecAPI * This,
            /* [in] */ const GUID *Api);
        
        HRESULT ( STDMETHODCALLTYPE *GetParameterRange )( 
            ICodecAPI * This,
            /* [in] */ const GUID *Api,
            /* [out] */ VARIANT *ValueMin,
            /* [out] */ VARIANT *ValueMax,
            /* [out] */ VARIANT *SteppingDelta);
        
        HRESULT ( STDMETHODCALLTYPE *GetParameterValues )( 
            ICodecAPI * This,
            /* [in] */ const GUID *Api,
            /* [size_is][size_is][out] */ VARIANT **Values,
            /* [out] */ ULONG *ValuesCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultValue )( 
            ICodecAPI * This,
            /* [in] */ const GUID *Api,
            /* [out] */ VARIANT *Value);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            ICodecAPI * This,
            /* [in] */ const GUID *Api,
            /* [out] */ VARIANT *Value);
        
        HRESULT ( STDMETHODCALLTYPE *SetValue )( 
            ICodecAPI * This,
            /* [in] */ const GUID *Api,
            /* [in] */ VARIANT *Value);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterForEvent )( 
            ICodecAPI * This,
            /* [in] */ const GUID *Api,
            /* [in] */ LONG_PTR userData);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterForEvent )( 
            ICodecAPI * This,
            /* [in] */ const GUID *Api);
        
        HRESULT ( STDMETHODCALLTYPE *SetAllDefaults )( 
            ICodecAPI * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetValueWithNotify )( 
            ICodecAPI * This,
            /* [in] */ const GUID *Api,
            /* [in] */ VARIANT *Value,
            /* [size_is][size_is][out] */ GUID **ChangedParam,
            /* [out] */ ULONG *ChangedParamCount);
        
        HRESULT ( STDMETHODCALLTYPE *SetAllDefaultsWithNotify )( 
            ICodecAPI * This,
            /* [size_is][size_is][out] */ GUID **ChangedParam,
            /* [out] */ ULONG *ChangedParamCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllSettings )( 
            ICodecAPI * This,
            /* [in] */ IStream *__MIDL_0016);
        
        HRESULT ( STDMETHODCALLTYPE *SetAllSettings )( 
            ICodecAPI * This,
            /* [in] */ IStream *__MIDL_0017);
        
        HRESULT ( STDMETHODCALLTYPE *SetAllSettingsWithNotify )( 
            ICodecAPI * This,
            IStream *__MIDL_0018,
            /* [size_is][size_is][out] */ GUID **ChangedParam,
            /* [out] */ ULONG *ChangedParamCount);
        
        END_INTERFACE
    } ICodecAPIVtbl;

    interface ICodecAPI
    {
        CONST_VTBL struct ICodecAPIVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICodecAPI_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICodecAPI_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICodecAPI_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICodecAPI_IsSupported(This,Api)	\
    (This)->lpVtbl -> IsSupported(This,Api)

#define ICodecAPI_IsModifiable(This,Api)	\
    (This)->lpVtbl -> IsModifiable(This,Api)

#define ICodecAPI_GetParameterRange(This,Api,ValueMin,ValueMax,SteppingDelta)	\
    (This)->lpVtbl -> GetParameterRange(This,Api,ValueMin,ValueMax,SteppingDelta)

#define ICodecAPI_GetParameterValues(This,Api,Values,ValuesCount)	\
    (This)->lpVtbl -> GetParameterValues(This,Api,Values,ValuesCount)

#define ICodecAPI_GetDefaultValue(This,Api,Value)	\
    (This)->lpVtbl -> GetDefaultValue(This,Api,Value)

#define ICodecAPI_GetValue(This,Api,Value)	\
    (This)->lpVtbl -> GetValue(This,Api,Value)

#define ICodecAPI_SetValue(This,Api,Value)	\
    (This)->lpVtbl -> SetValue(This,Api,Value)

#define ICodecAPI_RegisterForEvent(This,Api,userData)	\
    (This)->lpVtbl -> RegisterForEvent(This,Api,userData)

#define ICodecAPI_UnregisterForEvent(This,Api)	\
    (This)->lpVtbl -> UnregisterForEvent(This,Api)

#define ICodecAPI_SetAllDefaults(This)	\
    (This)->lpVtbl -> SetAllDefaults(This)

#define ICodecAPI_SetValueWithNotify(This,Api,Value,ChangedParam,ChangedParamCount)	\
    (This)->lpVtbl -> SetValueWithNotify(This,Api,Value,ChangedParam,ChangedParamCount)

#define ICodecAPI_SetAllDefaultsWithNotify(This,ChangedParam,ChangedParamCount)	\
    (This)->lpVtbl -> SetAllDefaultsWithNotify(This,ChangedParam,ChangedParamCount)

#define ICodecAPI_GetAllSettings(This,__MIDL_0016)	\
    (This)->lpVtbl -> GetAllSettings(This,__MIDL_0016)

#define ICodecAPI_SetAllSettings(This,__MIDL_0017)	\
    (This)->lpVtbl -> SetAllSettings(This,__MIDL_0017)

#define ICodecAPI_SetAllSettingsWithNotify(This,__MIDL_0018,ChangedParam,ChangedParamCount)	\
    (This)->lpVtbl -> SetAllSettingsWithNotify(This,__MIDL_0018,ChangedParam,ChangedParamCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICodecAPI_IsSupported_Proxy( 
    ICodecAPI * This,
    /* [in] */ const GUID *Api);


void __RPC_STUB ICodecAPI_IsSupported_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodecAPI_IsModifiable_Proxy( 
    ICodecAPI * This,
    /* [in] */ const GUID *Api);


void __RPC_STUB ICodecAPI_IsModifiable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodecAPI_GetParameterRange_Proxy( 
    ICodecAPI * This,
    /* [in] */ const GUID *Api,
    /* [out] */ VARIANT *ValueMin,
    /* [out] */ VARIANT *ValueMax,
    /* [out] */ VARIANT *SteppingDelta);


void __RPC_STUB ICodecAPI_GetParameterRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodecAPI_GetParameterValues_Proxy( 
    ICodecAPI * This,
    /* [in] */ const GUID *Api,
    /* [size_is][size_is][out] */ VARIANT **Values,
    /* [out] */ ULONG *ValuesCount);


void __RPC_STUB ICodecAPI_GetParameterValues_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodecAPI_GetDefaultValue_Proxy( 
    ICodecAPI * This,
    /* [in] */ const GUID *Api,
    /* [out] */ VARIANT *Value);


void __RPC_STUB ICodecAPI_GetDefaultValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodecAPI_GetValue_Proxy( 
    ICodecAPI * This,
    /* [in] */ const GUID *Api,
    /* [out] */ VARIANT *Value);


void __RPC_STUB ICodecAPI_GetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodecAPI_SetValue_Proxy( 
    ICodecAPI * This,
    /* [in] */ const GUID *Api,
    /* [in] */ VARIANT *Value);


void __RPC_STUB ICodecAPI_SetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodecAPI_RegisterForEvent_Proxy( 
    ICodecAPI * This,
    /* [in] */ const GUID *Api,
    /* [in] */ LONG_PTR userData);


void __RPC_STUB ICodecAPI_RegisterForEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodecAPI_UnregisterForEvent_Proxy( 
    ICodecAPI * This,
    /* [in] */ const GUID *Api);


void __RPC_STUB ICodecAPI_UnregisterForEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodecAPI_SetAllDefaults_Proxy( 
    ICodecAPI * This);


void __RPC_STUB ICodecAPI_SetAllDefaults_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodecAPI_SetValueWithNotify_Proxy( 
    ICodecAPI * This,
    /* [in] */ const GUID *Api,
    /* [in] */ VARIANT *Value,
    /* [size_is][size_is][out] */ GUID **ChangedParam,
    /* [out] */ ULONG *ChangedParamCount);


void __RPC_STUB ICodecAPI_SetValueWithNotify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodecAPI_SetAllDefaultsWithNotify_Proxy( 
    ICodecAPI * This,
    /* [size_is][size_is][out] */ GUID **ChangedParam,
    /* [out] */ ULONG *ChangedParamCount);


void __RPC_STUB ICodecAPI_SetAllDefaultsWithNotify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodecAPI_GetAllSettings_Proxy( 
    ICodecAPI * This,
    /* [in] */ IStream *__MIDL_0016);


void __RPC_STUB ICodecAPI_GetAllSettings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodecAPI_SetAllSettings_Proxy( 
    ICodecAPI * This,
    /* [in] */ IStream *__MIDL_0017);


void __RPC_STUB ICodecAPI_SetAllSettings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodecAPI_SetAllSettingsWithNotify_Proxy( 
    ICodecAPI * This,
    IStream *__MIDL_0018,
    /* [size_is][size_is][out] */ GUID **ChangedParam,
    /* [out] */ ULONG *ChangedParamCount);


void __RPC_STUB ICodecAPI_SetAllSettingsWithNotify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICodecAPI_INTERFACE_DEFINED__ */


#ifndef __IGetCapabilitiesKey_INTERFACE_DEFINED__
#define __IGetCapabilitiesKey_INTERFACE_DEFINED__

/* interface IGetCapabilitiesKey */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IGetCapabilitiesKey;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a8809222-07bb-48ea-951c-33158100625b")
    IGetCapabilitiesKey : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCapabilitiesKey( 
            /* [out] */ HKEY *pHKey) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGetCapabilitiesKeyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGetCapabilitiesKey * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGetCapabilitiesKey * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGetCapabilitiesKey * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCapabilitiesKey )( 
            IGetCapabilitiesKey * This,
            /* [out] */ HKEY *pHKey);
        
        END_INTERFACE
    } IGetCapabilitiesKeyVtbl;

    interface IGetCapabilitiesKey
    {
        CONST_VTBL struct IGetCapabilitiesKeyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGetCapabilitiesKey_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGetCapabilitiesKey_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGetCapabilitiesKey_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGetCapabilitiesKey_GetCapabilitiesKey(This,pHKey)	\
    (This)->lpVtbl -> GetCapabilitiesKey(This,pHKey)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IGetCapabilitiesKey_GetCapabilitiesKey_Proxy( 
    IGetCapabilitiesKey * This,
    /* [out] */ HKEY *pHKey);


void __RPC_STUB IGetCapabilitiesKey_GetCapabilitiesKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGetCapabilitiesKey_INTERFACE_DEFINED__ */


#ifndef __IEncoderAPI_INTERFACE_DEFINED__
#define __IEncoderAPI_INTERFACE_DEFINED__

/* interface IEncoderAPI */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEncoderAPI;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("70423839-6ACC-4b23-B079-21DBF08156A5")
    IEncoderAPI : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsSupported( 
            /* [in] */ const GUID *Api) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsAvailable( 
            /* [in] */ const GUID *Api) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParameterRange( 
            /* [in] */ const GUID *Api,
            /* [out] */ VARIANT *ValueMin,
            /* [out] */ VARIANT *ValueMax,
            /* [out] */ VARIANT *SteppingDelta) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParameterValues( 
            /* [in] */ const GUID *Api,
            /* [size_is][size_is][out] */ VARIANT **Values,
            /* [out] */ ULONG *ValuesCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultValue( 
            /* [in] */ const GUID *Api,
            /* [out] */ VARIANT *Value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [in] */ const GUID *Api,
            /* [out] */ VARIANT *Value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            /* [in] */ const GUID *Api,
            /* [in] */ VARIANT *Value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEncoderAPIVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEncoderAPI * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEncoderAPI * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEncoderAPI * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsSupported )( 
            IEncoderAPI * This,
            /* [in] */ const GUID *Api);
        
        HRESULT ( STDMETHODCALLTYPE *IsAvailable )( 
            IEncoderAPI * This,
            /* [in] */ const GUID *Api);
        
        HRESULT ( STDMETHODCALLTYPE *GetParameterRange )( 
            IEncoderAPI * This,
            /* [in] */ const GUID *Api,
            /* [out] */ VARIANT *ValueMin,
            /* [out] */ VARIANT *ValueMax,
            /* [out] */ VARIANT *SteppingDelta);
        
        HRESULT ( STDMETHODCALLTYPE *GetParameterValues )( 
            IEncoderAPI * This,
            /* [in] */ const GUID *Api,
            /* [size_is][size_is][out] */ VARIANT **Values,
            /* [out] */ ULONG *ValuesCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultValue )( 
            IEncoderAPI * This,
            /* [in] */ const GUID *Api,
            /* [out] */ VARIANT *Value);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            IEncoderAPI * This,
            /* [in] */ const GUID *Api,
            /* [out] */ VARIANT *Value);
        
        HRESULT ( STDMETHODCALLTYPE *SetValue )( 
            IEncoderAPI * This,
            /* [in] */ const GUID *Api,
            /* [in] */ VARIANT *Value);
        
        END_INTERFACE
    } IEncoderAPIVtbl;

    interface IEncoderAPI
    {
        CONST_VTBL struct IEncoderAPIVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEncoderAPI_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEncoderAPI_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEncoderAPI_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEncoderAPI_IsSupported(This,Api)	\
    (This)->lpVtbl -> IsSupported(This,Api)

#define IEncoderAPI_IsAvailable(This,Api)	\
    (This)->lpVtbl -> IsAvailable(This,Api)

#define IEncoderAPI_GetParameterRange(This,Api,ValueMin,ValueMax,SteppingDelta)	\
    (This)->lpVtbl -> GetParameterRange(This,Api,ValueMin,ValueMax,SteppingDelta)

#define IEncoderAPI_GetParameterValues(This,Api,Values,ValuesCount)	\
    (This)->lpVtbl -> GetParameterValues(This,Api,Values,ValuesCount)

#define IEncoderAPI_GetDefaultValue(This,Api,Value)	\
    (This)->lpVtbl -> GetDefaultValue(This,Api,Value)

#define IEncoderAPI_GetValue(This,Api,Value)	\
    (This)->lpVtbl -> GetValue(This,Api,Value)

#define IEncoderAPI_SetValue(This,Api,Value)	\
    (This)->lpVtbl -> SetValue(This,Api,Value)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEncoderAPI_IsSupported_Proxy( 
    IEncoderAPI * This,
    /* [in] */ const GUID *Api);


void __RPC_STUB IEncoderAPI_IsSupported_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEncoderAPI_IsAvailable_Proxy( 
    IEncoderAPI * This,
    /* [in] */ const GUID *Api);


void __RPC_STUB IEncoderAPI_IsAvailable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEncoderAPI_GetParameterRange_Proxy( 
    IEncoderAPI * This,
    /* [in] */ const GUID *Api,
    /* [out] */ VARIANT *ValueMin,
    /* [out] */ VARIANT *ValueMax,
    /* [out] */ VARIANT *SteppingDelta);


void __RPC_STUB IEncoderAPI_GetParameterRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEncoderAPI_GetParameterValues_Proxy( 
    IEncoderAPI * This,
    /* [in] */ const GUID *Api,
    /* [size_is][size_is][out] */ VARIANT **Values,
    /* [out] */ ULONG *ValuesCount);


void __RPC_STUB IEncoderAPI_GetParameterValues_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEncoderAPI_GetDefaultValue_Proxy( 
    IEncoderAPI * This,
    /* [in] */ const GUID *Api,
    /* [out] */ VARIANT *Value);


void __RPC_STUB IEncoderAPI_GetDefaultValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEncoderAPI_GetValue_Proxy( 
    IEncoderAPI * This,
    /* [in] */ const GUID *Api,
    /* [out] */ VARIANT *Value);


void __RPC_STUB IEncoderAPI_GetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEncoderAPI_SetValue_Proxy( 
    IEncoderAPI * This,
    /* [in] */ const GUID *Api,
    /* [in] */ VARIANT *Value);


void __RPC_STUB IEncoderAPI_SetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEncoderAPI_INTERFACE_DEFINED__ */


#ifndef __IVideoEncoder_INTERFACE_DEFINED__
#define __IVideoEncoder_INTERFACE_DEFINED__

/* interface IVideoEncoder */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVideoEncoder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("02997C3B-8E1B-460e-9270-545E0DE9563E")
    IVideoEncoder : public IEncoderAPI
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IVideoEncoderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVideoEncoder * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVideoEncoder * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVideoEncoder * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsSupported )( 
            IVideoEncoder * This,
            /* [in] */ const GUID *Api);
        
        HRESULT ( STDMETHODCALLTYPE *IsAvailable )( 
            IVideoEncoder * This,
            /* [in] */ const GUID *Api);
        
        HRESULT ( STDMETHODCALLTYPE *GetParameterRange )( 
            IVideoEncoder * This,
            /* [in] */ const GUID *Api,
            /* [out] */ VARIANT *ValueMin,
            /* [out] */ VARIANT *ValueMax,
            /* [out] */ VARIANT *SteppingDelta);
        
        HRESULT ( STDMETHODCALLTYPE *GetParameterValues )( 
            IVideoEncoder * This,
            /* [in] */ const GUID *Api,
            /* [size_is][size_is][out] */ VARIANT **Values,
            /* [out] */ ULONG *ValuesCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultValue )( 
            IVideoEncoder * This,
            /* [in] */ const GUID *Api,
            /* [out] */ VARIANT *Value);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            IVideoEncoder * This,
            /* [in] */ const GUID *Api,
            /* [out] */ VARIANT *Value);
        
        HRESULT ( STDMETHODCALLTYPE *SetValue )( 
            IVideoEncoder * This,
            /* [in] */ const GUID *Api,
            /* [in] */ VARIANT *Value);
        
        END_INTERFACE
    } IVideoEncoderVtbl;

    interface IVideoEncoder
    {
        CONST_VTBL struct IVideoEncoderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVideoEncoder_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVideoEncoder_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVideoEncoder_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVideoEncoder_IsSupported(This,Api)	\
    (This)->lpVtbl -> IsSupported(This,Api)

#define IVideoEncoder_IsAvailable(This,Api)	\
    (This)->lpVtbl -> IsAvailable(This,Api)

#define IVideoEncoder_GetParameterRange(This,Api,ValueMin,ValueMax,SteppingDelta)	\
    (This)->lpVtbl -> GetParameterRange(This,Api,ValueMin,ValueMax,SteppingDelta)

#define IVideoEncoder_GetParameterValues(This,Api,Values,ValuesCount)	\
    (This)->lpVtbl -> GetParameterValues(This,Api,Values,ValuesCount)

#define IVideoEncoder_GetDefaultValue(This,Api,Value)	\
    (This)->lpVtbl -> GetDefaultValue(This,Api,Value)

#define IVideoEncoder_GetValue(This,Api,Value)	\
    (This)->lpVtbl -> GetValue(This,Api,Value)

#define IVideoEncoder_SetValue(This,Api,Value)	\
    (This)->lpVtbl -> SetValue(This,Api,Value)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVideoEncoder_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0365 */
/* [local] */ 

#ifndef __ENCODER_API_DEFINES__
#define __ENCODER_API_DEFINES__
typedef /* [public] */ 
enum __MIDL___MIDL_itf_strmif_0365_0001
    {	ConstantBitRate	= 0,
	VariableBitRateAverage	= ConstantBitRate + 1,
	VariableBitRatePeak	= VariableBitRateAverage + 1
    } 	VIDEOENCODER_BITRATE_MODE;

#endif // __ENCODER_API_DEFINES__
#define AM_GETDECODERCAP_QUERY_VMR_SUPPORT   0x00000001
#define      VMR_NOTSUPPORTED                0x00000000
#define      VMR_SUPPORTED                   0x00000001
#define AM_QUERY_DECODER_VMR_SUPPORT         0x00000001
#define AM_QUERY_DECODER_DXVA_1_SUPPORT      0x00000002
#define AM_QUERY_DECODER_DVD_SUPPORT         0x00000003
#define AM_QUERY_DECODER_ATSC_SD_SUPPORT     0x00000004
#define AM_QUERY_DECODER_ATSC_HD_SUPPORT     0x00000005
#define AM_GETDECODERCAP_QUERY_VMR9_SUPPORT  0x00000006
#define      DECODER_CAP_NOTSUPPORTED        0x00000000
#define      DECODER_CAP_SUPPORTED           0x00000001


extern RPC_IF_HANDLE __MIDL_itf_strmif_0365_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0365_v0_0_s_ifspec;

#ifndef __IAMDecoderCaps_INTERFACE_DEFINED__
#define __IAMDecoderCaps_INTERFACE_DEFINED__

/* interface IAMDecoderCaps */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IAMDecoderCaps;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c0dff467-d499-4986-972b-e1d9090fa941")
    IAMDecoderCaps : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDecoderCaps( 
            /* [in] */ DWORD dwCapIndex,
            /* [out] */ DWORD *lpdwCap) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMDecoderCapsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMDecoderCaps * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMDecoderCaps * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMDecoderCaps * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDecoderCaps )( 
            IAMDecoderCaps * This,
            /* [in] */ DWORD dwCapIndex,
            /* [out] */ DWORD *lpdwCap);
        
        END_INTERFACE
    } IAMDecoderCapsVtbl;

    interface IAMDecoderCaps
    {
        CONST_VTBL struct IAMDecoderCapsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMDecoderCaps_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMDecoderCaps_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMDecoderCaps_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMDecoderCaps_GetDecoderCaps(This,dwCapIndex,lpdwCap)	\
    (This)->lpVtbl -> GetDecoderCaps(This,dwCapIndex,lpdwCap)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAMDecoderCaps_GetDecoderCaps_Proxy( 
    IAMDecoderCaps * This,
    /* [in] */ DWORD dwCapIndex,
    /* [out] */ DWORD *lpdwCap);


void __RPC_STUB IAMDecoderCaps_GetDecoderCaps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMDecoderCaps_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0366 */
/* [local] */ 

#include <ddraw.h>









typedef 
enum tagDVD_DOMAIN
    {	DVD_DOMAIN_FirstPlay	= 1,
	DVD_DOMAIN_VideoManagerMenu	= DVD_DOMAIN_FirstPlay + 1,
	DVD_DOMAIN_VideoTitleSetMenu	= DVD_DOMAIN_VideoManagerMenu + 1,
	DVD_DOMAIN_Title	= DVD_DOMAIN_VideoTitleSetMenu + 1,
	DVD_DOMAIN_Stop	= DVD_DOMAIN_Title + 1
    } 	DVD_DOMAIN;

typedef 
enum tagDVD_MENU_ID
    {	DVD_MENU_Title	= 2,
	DVD_MENU_Root	= 3,
	DVD_MENU_Subpicture	= 4,
	DVD_MENU_Audio	= 5,
	DVD_MENU_Angle	= 6,
	DVD_MENU_Chapter	= 7
    } 	DVD_MENU_ID;

typedef 
enum tagDVD_DISC_SIDE
    {	DVD_SIDE_A	= 1,
	DVD_SIDE_B	= 2
    } 	DVD_DISC_SIDE;

typedef 
enum tagDVD_PREFERRED_DISPLAY_MODE
    {	DISPLAY_CONTENT_DEFAULT	= 0,
	DISPLAY_16x9	= 1,
	DISPLAY_4x3_PANSCAN_PREFERRED	= 2,
	DISPLAY_4x3_LETTERBOX_PREFERRED	= 3
    } 	DVD_PREFERRED_DISPLAY_MODE;

typedef WORD DVD_REGISTER;

typedef DVD_REGISTER GPRMARRAY[ 16 ];

typedef DVD_REGISTER SPRMARRAY[ 24 ];

typedef struct tagDVD_ATR
    {
    ULONG ulCAT;
    BYTE pbATRI[ 768 ];
    } 	DVD_ATR;

typedef BYTE DVD_VideoATR[ 2 ];

typedef BYTE DVD_AudioATR[ 8 ];

typedef BYTE DVD_SubpictureATR[ 6 ];

typedef 
enum tagDVD_FRAMERATE
    {	DVD_FPS_25	= 1,
	DVD_FPS_30NonDrop	= 3
    } 	DVD_FRAMERATE;

typedef struct tagDVD_TIMECODE
{
   ULONG Hours1    :4; // Hours
   ULONG Hours10  :4; // Tens of Hours 

   ULONG Minutes1  :4; // Minutes 
   ULONG Minutes10:4; // Tens of Minutes 

   ULONG Seconds1  :4; // Seconds 
   ULONG Seconds10:4; // Tens of Seconds 

   ULONG Frames1   :4; // Frames 
   ULONG Frames10 :2; // Tens of Frames 

   ULONG FrameRateCode: 2; // use DVD_FRAMERATE to indicate frames/sec and drop/non-drop
} DVD_TIMECODE;
typedef 
enum tagDVD_TIMECODE_FLAGS
    {	DVD_TC_FLAG_25fps	= 0x1,
	DVD_TC_FLAG_30fps	= 0x2,
	DVD_TC_FLAG_DropFrame	= 0x4,
	DVD_TC_FLAG_Interpolated	= 0x8
    } 	DVD_TIMECODE_FLAGS;

typedef struct tagDVD_HMSF_TIMECODE
    {
    BYTE bHours;
    BYTE bMinutes;
    BYTE bSeconds;
    BYTE bFrames;
    } 	DVD_HMSF_TIMECODE;

typedef struct tagDVD_PLAYBACK_LOCATION2
    {
    ULONG TitleNum;
    ULONG ChapterNum;
    DVD_HMSF_TIMECODE TimeCode;
    ULONG TimeCodeFlags;
    } 	DVD_PLAYBACK_LOCATION2;

typedef struct tagDVD_PLAYBACK_LOCATION
    {
    ULONG TitleNum;
    ULONG ChapterNum;
    ULONG TimeCode;
    } 	DVD_PLAYBACK_LOCATION;

typedef DWORD VALID_UOP_SOMTHING_OR_OTHER;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_strmif_0366_0001
    {	UOP_FLAG_Play_Title_Or_AtTime	= 0x1,
	UOP_FLAG_Play_Chapter	= 0x2,
	UOP_FLAG_Play_Title	= 0x4,
	UOP_FLAG_Stop	= 0x8,
	UOP_FLAG_ReturnFromSubMenu	= 0x10,
	UOP_FLAG_Play_Chapter_Or_AtTime	= 0x20,
	UOP_FLAG_PlayPrev_Or_Replay_Chapter	= 0x40,
	UOP_FLAG_PlayNext_Chapter	= 0x80,
	UOP_FLAG_Play_Forwards	= 0x100,
	UOP_FLAG_Play_Backwards	= 0x200,
	UOP_FLAG_ShowMenu_Title	= 0x400,
	UOP_FLAG_ShowMenu_Root	= 0x800,
	UOP_FLAG_ShowMenu_SubPic	= 0x1000,
	UOP_FLAG_ShowMenu_Audio	= 0x2000,
	UOP_FLAG_ShowMenu_Angle	= 0x4000,
	UOP_FLAG_ShowMenu_Chapter	= 0x8000,
	UOP_FLAG_Resume	= 0x10000,
	UOP_FLAG_Select_Or_Activate_Button	= 0x20000,
	UOP_FLAG_Still_Off	= 0x40000,
	UOP_FLAG_Pause_On	= 0x80000,
	UOP_FLAG_Select_Audio_Stream	= 0x100000,
	UOP_FLAG_Select_SubPic_Stream	= 0x200000,
	UOP_FLAG_Select_Angle	= 0x400000,
	UOP_FLAG_Select_Karaoke_Audio_Presentation_Mode	= 0x800000,
	UOP_FLAG_Select_Video_Mode_Preference	= 0x1000000
    } 	VALID_UOP_FLAG;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_strmif_0366_0002
    {	DVD_CMD_FLAG_None	= 0,
	DVD_CMD_FLAG_Flush	= 0x1,
	DVD_CMD_FLAG_SendEvents	= 0x2,
	DVD_CMD_FLAG_Block	= 0x4,
	DVD_CMD_FLAG_StartWhenRendered	= 0x8,
	DVD_CMD_FLAG_EndAfterRendered	= 0x10
    } 	DVD_CMD_FLAGS;

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_strmif_0366_0003
    {	DVD_ResetOnStop	= 1,
	DVD_NotifyParentalLevelChange	= 2,
	DVD_HMSF_TimeCodeEvents	= 3,
	DVD_AudioDuringFFwdRew	= 4
    } 	DVD_OPTION_FLAG;

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_strmif_0366_0004
    {	DVD_Relative_Upper	= 1,
	DVD_Relative_Lower	= 2,
	DVD_Relative_Left	= 3,
	DVD_Relative_Right	= 4
    } 	DVD_RELATIVE_BUTTON;

typedef 
enum tagDVD_PARENTAL_LEVEL
    {	DVD_PARENTAL_LEVEL_8	= 0x8000,
	DVD_PARENTAL_LEVEL_7	= 0x4000,
	DVD_PARENTAL_LEVEL_6	= 0x2000,
	DVD_PARENTAL_LEVEL_5	= 0x1000,
	DVD_PARENTAL_LEVEL_4	= 0x800,
	DVD_PARENTAL_LEVEL_3	= 0x400,
	DVD_PARENTAL_LEVEL_2	= 0x200,
	DVD_PARENTAL_LEVEL_1	= 0x100
    } 	DVD_PARENTAL_LEVEL;

typedef 
enum tagDVD_AUDIO_LANG_EXT
    {	DVD_AUD_EXT_NotSpecified	= 0,
	DVD_AUD_EXT_Captions	= 1,
	DVD_AUD_EXT_VisuallyImpaired	= 2,
	DVD_AUD_EXT_DirectorComments1	= 3,
	DVD_AUD_EXT_DirectorComments2	= 4
    } 	DVD_AUDIO_LANG_EXT;

typedef 
enum tagDVD_SUBPICTURE_LANG_EXT
    {	DVD_SP_EXT_NotSpecified	= 0,
	DVD_SP_EXT_Caption_Normal	= 1,
	DVD_SP_EXT_Caption_Big	= 2,
	DVD_SP_EXT_Caption_Children	= 3,
	DVD_SP_EXT_CC_Normal	= 5,
	DVD_SP_EXT_CC_Big	= 6,
	DVD_SP_EXT_CC_Children	= 7,
	DVD_SP_EXT_Forced	= 9,
	DVD_SP_EXT_DirectorComments_Normal	= 13,
	DVD_SP_EXT_DirectorComments_Big	= 14,
	DVD_SP_EXT_DirectorComments_Children	= 15
    } 	DVD_SUBPICTURE_LANG_EXT;

typedef 
enum tagDVD_AUDIO_APPMODE
    {	DVD_AudioMode_None	= 0,
	DVD_AudioMode_Karaoke	= 1,
	DVD_AudioMode_Surround	= 2,
	DVD_AudioMode_Other	= 3
    } 	DVD_AUDIO_APPMODE;

typedef 
enum tagDVD_AUDIO_FORMAT
    {	DVD_AudioFormat_AC3	= 0,
	DVD_AudioFormat_MPEG1	= 1,
	DVD_AudioFormat_MPEG1_DRC	= 2,
	DVD_AudioFormat_MPEG2	= 3,
	DVD_AudioFormat_MPEG2_DRC	= 4,
	DVD_AudioFormat_LPCM	= 5,
	DVD_AudioFormat_DTS	= 6,
	DVD_AudioFormat_SDDS	= 7,
	DVD_AudioFormat_Other	= 8
    } 	DVD_AUDIO_FORMAT;

typedef 
enum tagDVD_KARAOKE_DOWNMIX
    {	DVD_Mix_0to0	= 0x1,
	DVD_Mix_1to0	= 0x2,
	DVD_Mix_2to0	= 0x4,
	DVD_Mix_3to0	= 0x8,
	DVD_Mix_4to0	= 0x10,
	DVD_Mix_Lto0	= 0x20,
	DVD_Mix_Rto0	= 0x40,
	DVD_Mix_0to1	= 0x100,
	DVD_Mix_1to1	= 0x200,
	DVD_Mix_2to1	= 0x400,
	DVD_Mix_3to1	= 0x800,
	DVD_Mix_4to1	= 0x1000,
	DVD_Mix_Lto1	= 0x2000,
	DVD_Mix_Rto1	= 0x4000
    } 	DVD_KARAOKE_DOWNMIX;

typedef struct tagDVD_AudioAttributes
    {
    DVD_AUDIO_APPMODE AppMode;
    BYTE AppModeData;
    DVD_AUDIO_FORMAT AudioFormat;
    LCID Language;
    DVD_AUDIO_LANG_EXT LanguageExtension;
    BOOL fHasMultichannelInfo;
    DWORD dwFrequency;
    BYTE bQuantization;
    BYTE bNumberOfChannels;
    DWORD dwReserved[ 2 ];
    } 	DVD_AudioAttributes;

typedef struct tagDVD_MUA_MixingInfo
    {
    BOOL fMixTo0;
    BOOL fMixTo1;
    BOOL fMix0InPhase;
    BOOL fMix1InPhase;
    DWORD dwSpeakerPosition;
    } 	DVD_MUA_MixingInfo;

typedef struct tagDVD_MUA_Coeff
    {
    double log2_alpha;
    double log2_beta;
    } 	DVD_MUA_Coeff;

typedef struct tagDVD_MultichannelAudioAttributes
    {
    DVD_MUA_MixingInfo Info[ 8 ];
    DVD_MUA_Coeff Coeff[ 8 ];
    } 	DVD_MultichannelAudioAttributes;

typedef 
enum tagDVD_KARAOKE_CONTENTS
    {	DVD_Karaoke_GuideVocal1	= 0x1,
	DVD_Karaoke_GuideVocal2	= 0x2,
	DVD_Karaoke_GuideMelody1	= 0x4,
	DVD_Karaoke_GuideMelody2	= 0x8,
	DVD_Karaoke_GuideMelodyA	= 0x10,
	DVD_Karaoke_GuideMelodyB	= 0x20,
	DVD_Karaoke_SoundEffectA	= 0x40,
	DVD_Karaoke_SoundEffectB	= 0x80
    } 	DVD_KARAOKE_CONTENTS;

typedef 
enum tagDVD_KARAOKE_ASSIGNMENT
    {	DVD_Assignment_reserved0	= 0,
	DVD_Assignment_reserved1	= 1,
	DVD_Assignment_LR	= 2,
	DVD_Assignment_LRM	= 3,
	DVD_Assignment_LR1	= 4,
	DVD_Assignment_LRM1	= 5,
	DVD_Assignment_LR12	= 6,
	DVD_Assignment_LRM12	= 7
    } 	DVD_KARAOKE_ASSIGNMENT;

typedef struct tagDVD_KaraokeAttributes
    {
    BYTE bVersion;
    BOOL fMasterOfCeremoniesInGuideVocal1;
    BOOL fDuet;
    DVD_KARAOKE_ASSIGNMENT ChannelAssignment;
    WORD wChannelContents[ 8 ];
    } 	DVD_KaraokeAttributes;

typedef 
enum tagDVD_VIDEO_COMPRESSION
    {	DVD_VideoCompression_Other	= 0,
	DVD_VideoCompression_MPEG1	= 1,
	DVD_VideoCompression_MPEG2	= 2
    } 	DVD_VIDEO_COMPRESSION;

typedef struct tagDVD_VideoAttributes
    {
    BOOL fPanscanPermitted;
    BOOL fLetterboxPermitted;
    ULONG ulAspectX;
    ULONG ulAspectY;
    ULONG ulFrameRate;
    ULONG ulFrameHeight;
    DVD_VIDEO_COMPRESSION Compression;
    BOOL fLine21Field1InGOP;
    BOOL fLine21Field2InGOP;
    ULONG ulSourceResolutionX;
    ULONG ulSourceResolutionY;
    BOOL fIsSourceLetterboxed;
    BOOL fIsFilmMode;
    } 	DVD_VideoAttributes;

typedef 
enum tagDVD_SUBPICTURE_TYPE
    {	DVD_SPType_NotSpecified	= 0,
	DVD_SPType_Language	= 1,
	DVD_SPType_Other	= 2
    } 	DVD_SUBPICTURE_TYPE;

typedef 
enum tagDVD_SUBPICTURE_CODING
    {	DVD_SPCoding_RunLength	= 0,
	DVD_SPCoding_Extended	= 1,
	DVD_SPCoding_Other	= 2
    } 	DVD_SUBPICTURE_CODING;

typedef struct tagDVD_SubpictureAttributes
    {
    DVD_SUBPICTURE_TYPE Type;
    DVD_SUBPICTURE_CODING CodingMode;
    LCID Language;
    DVD_SUBPICTURE_LANG_EXT LanguageExtension;
    } 	DVD_SubpictureAttributes;

typedef 
enum tagDVD_TITLE_APPMODE
    {	DVD_AppMode_Not_Specified	= 0,
	DVD_AppMode_Karaoke	= 1,
	DVD_AppMode_Other	= 3
    } 	DVD_TITLE_APPMODE;

typedef struct tagDVD_TitleMainAttributes
    {
    DVD_TITLE_APPMODE AppMode;
    DVD_VideoAttributes VideoAttributes;
    ULONG ulNumberOfAudioStreams;
    DVD_AudioAttributes AudioAttributes[ 8 ];
    DVD_MultichannelAudioAttributes MultichannelAudioAttributes[ 8 ];
    ULONG ulNumberOfSubpictureStreams;
    DVD_SubpictureAttributes SubpictureAttributes[ 32 ];
    } 	DVD_TitleAttributes;

typedef struct tagDVD_MenuAttributes
    {
    BOOL fCompatibleRegion[ 8 ];
    DVD_VideoAttributes VideoAttributes;
    BOOL fAudioPresent;
    DVD_AudioAttributes AudioAttributes;
    BOOL fSubpicturePresent;
    DVD_SubpictureAttributes SubpictureAttributes;
    } 	DVD_MenuAttributes;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0366_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0366_v0_0_s_ifspec;

#ifndef __IDvdControl_INTERFACE_DEFINED__
#define __IDvdControl_INTERFACE_DEFINED__

/* interface IDvdControl */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDvdControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A70EFE61-E2A3-11d0-A9BE-00AA0061BE93")
    IDvdControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE TitlePlay( 
            /* [in] */ ULONG ulTitle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ChapterPlay( 
            /* [in] */ ULONG ulTitle,
            /* [in] */ ULONG ulChapter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TimePlay( 
            /* [in] */ ULONG ulTitle,
            /* [in] */ ULONG bcdTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StopForResume( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GoUp( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TimeSearch( 
            /* [in] */ ULONG bcdTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ChapterSearch( 
            /* [in] */ ULONG ulChapter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PrevPGSearch( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TopPGSearch( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NextPGSearch( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ForwardScan( 
            /* [in] */ double dwSpeed) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BackwardScan( 
            /* [in] */ double dwSpeed) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MenuCall( 
            /* [in] */ DVD_MENU_ID MenuID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpperButtonSelect( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LowerButtonSelect( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LeftButtonSelect( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RightButtonSelect( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ButtonActivate( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ButtonSelectAndActivate( 
            /* [in] */ ULONG ulButton) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StillOff( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PauseOn( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PauseOff( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MenuLanguageSelect( 
            /* [in] */ LCID Language) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AudioStreamChange( 
            /* [in] */ ULONG ulAudio) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SubpictureStreamChange( 
            /* [in] */ ULONG ulSubPicture,
            /* [in] */ BOOL bDisplay) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AngleChange( 
            /* [in] */ ULONG ulAngle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ParentalLevelSelect( 
            /* [in] */ ULONG ulParentalLevel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ParentalCountrySelect( 
            /* [in] */ WORD wCountry) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE KaraokeAudioPresentationModeChange( 
            /* [in] */ ULONG ulMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE VideoModePreferrence( 
            /* [in] */ ULONG ulPreferredDisplayMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRoot( 
            /* [in] */ LPCWSTR pszPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MouseActivate( 
            /* [in] */ POINT point) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MouseSelect( 
            /* [in] */ POINT point) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ChapterPlayAutoStop( 
            /* [in] */ ULONG ulTitle,
            /* [in] */ ULONG ulChapter,
            /* [in] */ ULONG ulChaptersToPlay) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDvdControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDvdControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDvdControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDvdControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *TitlePlay )( 
            IDvdControl * This,
            /* [in] */ ULONG ulTitle);
        
        HRESULT ( STDMETHODCALLTYPE *ChapterPlay )( 
            IDvdControl * This,
            /* [in] */ ULONG ulTitle,
            /* [in] */ ULONG ulChapter);
        
        HRESULT ( STDMETHODCALLTYPE *TimePlay )( 
            IDvdControl * This,
            /* [in] */ ULONG ulTitle,
            /* [in] */ ULONG bcdTime);
        
        HRESULT ( STDMETHODCALLTYPE *StopForResume )( 
            IDvdControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GoUp )( 
            IDvdControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *TimeSearch )( 
            IDvdControl * This,
            /* [in] */ ULONG bcdTime);
        
        HRESULT ( STDMETHODCALLTYPE *ChapterSearch )( 
            IDvdControl * This,
            /* [in] */ ULONG ulChapter);
        
        HRESULT ( STDMETHODCALLTYPE *PrevPGSearch )( 
            IDvdControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *TopPGSearch )( 
            IDvdControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *NextPGSearch )( 
            IDvdControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *ForwardScan )( 
            IDvdControl * This,
            /* [in] */ double dwSpeed);
        
        HRESULT ( STDMETHODCALLTYPE *BackwardScan )( 
            IDvdControl * This,
            /* [in] */ double dwSpeed);
        
        HRESULT ( STDMETHODCALLTYPE *MenuCall )( 
            IDvdControl * This,
            /* [in] */ DVD_MENU_ID MenuID);
        
        HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IDvdControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *UpperButtonSelect )( 
            IDvdControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *LowerButtonSelect )( 
            IDvdControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *LeftButtonSelect )( 
            IDvdControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *RightButtonSelect )( 
            IDvdControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *ButtonActivate )( 
            IDvdControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *ButtonSelectAndActivate )( 
            IDvdControl * This,
            /* [in] */ ULONG ulButton);
        
        HRESULT ( STDMETHODCALLTYPE *StillOff )( 
            IDvdControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *PauseOn )( 
            IDvdControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *PauseOff )( 
            IDvdControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *MenuLanguageSelect )( 
            IDvdControl * This,
            /* [in] */ LCID Language);
        
        HRESULT ( STDMETHODCALLTYPE *AudioStreamChange )( 
            IDvdControl * This,
            /* [in] */ ULONG ulAudio);
        
        HRESULT ( STDMETHODCALLTYPE *SubpictureStreamChange )( 
            IDvdControl * This,
            /* [in] */ ULONG ulSubPicture,
            /* [in] */ BOOL bDisplay);
        
        HRESULT ( STDMETHODCALLTYPE *AngleChange )( 
            IDvdControl * This,
            /* [in] */ ULONG ulAngle);
        
        HRESULT ( STDMETHODCALLTYPE *ParentalLevelSelect )( 
            IDvdControl * This,
            /* [in] */ ULONG ulParentalLevel);
        
        HRESULT ( STDMETHODCALLTYPE *ParentalCountrySelect )( 
            IDvdControl * This,
            /* [in] */ WORD wCountry);
        
        HRESULT ( STDMETHODCALLTYPE *KaraokeAudioPresentationModeChange )( 
            IDvdControl * This,
            /* [in] */ ULONG ulMode);
        
        HRESULT ( STDMETHODCALLTYPE *VideoModePreferrence )( 
            IDvdControl * This,
            /* [in] */ ULONG ulPreferredDisplayMode);
        
        HRESULT ( STDMETHODCALLTYPE *SetRoot )( 
            IDvdControl * This,
            /* [in] */ LPCWSTR pszPath);
        
        HRESULT ( STDMETHODCALLTYPE *MouseActivate )( 
            IDvdControl * This,
            /* [in] */ POINT point);
        
        HRESULT ( STDMETHODCALLTYPE *MouseSelect )( 
            IDvdControl * This,
            /* [in] */ POINT point);
        
        HRESULT ( STDMETHODCALLTYPE *ChapterPlayAutoStop )( 
            IDvdControl * This,
            /* [in] */ ULONG ulTitle,
            /* [in] */ ULONG ulChapter,
            /* [in] */ ULONG ulChaptersToPlay);
        
        END_INTERFACE
    } IDvdControlVtbl;

    interface IDvdControl
    {
        CONST_VTBL struct IDvdControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDvdControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDvdControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDvdControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDvdControl_TitlePlay(This,ulTitle)	\
    (This)->lpVtbl -> TitlePlay(This,ulTitle)

#define IDvdControl_ChapterPlay(This,ulTitle,ulChapter)	\
    (This)->lpVtbl -> ChapterPlay(This,ulTitle,ulChapter)

#define IDvdControl_TimePlay(This,ulTitle,bcdTime)	\
    (This)->lpVtbl -> TimePlay(This,ulTitle,bcdTime)

#define IDvdControl_StopForResume(This)	\
    (This)->lpVtbl -> StopForResume(This)

#define IDvdControl_GoUp(This)	\
    (This)->lpVtbl -> GoUp(This)

#define IDvdControl_TimeSearch(This,bcdTime)	\
    (This)->lpVtbl -> TimeSearch(This,bcdTime)

#define IDvdControl_ChapterSearch(This,ulChapter)	\
    (This)->lpVtbl -> ChapterSearch(This,ulChapter)

#define IDvdControl_PrevPGSearch(This)	\
    (This)->lpVtbl -> PrevPGSearch(This)

#define IDvdControl_TopPGSearch(This)	\
    (This)->lpVtbl -> TopPGSearch(This)

#define IDvdControl_NextPGSearch(This)	\
    (This)->lpVtbl -> NextPGSearch(This)

#define IDvdControl_ForwardScan(This,dwSpeed)	\
    (This)->lpVtbl -> ForwardScan(This,dwSpeed)

#define IDvdControl_BackwardScan(This,dwSpeed)	\
    (This)->lpVtbl -> BackwardScan(This,dwSpeed)

#define IDvdControl_MenuCall(This,MenuID)	\
    (This)->lpVtbl -> MenuCall(This,MenuID)

#define IDvdControl_Resume(This)	\
    (This)->lpVtbl -> Resume(This)

#define IDvdControl_UpperButtonSelect(This)	\
    (This)->lpVtbl -> UpperButtonSelect(This)

#define IDvdControl_LowerButtonSelect(This)	\
    (This)->lpVtbl -> LowerButtonSelect(This)

#define IDvdControl_LeftButtonSelect(This)	\
    (This)->lpVtbl -> LeftButtonSelect(This)

#define IDvdControl_RightButtonSelect(This)	\
    (This)->lpVtbl -> RightButtonSelect(This)

#define IDvdControl_ButtonActivate(This)	\
    (This)->lpVtbl -> ButtonActivate(This)

#define IDvdControl_ButtonSelectAndActivate(This,ulButton)	\
    (This)->lpVtbl -> ButtonSelectAndActivate(This,ulButton)

#define IDvdControl_StillOff(This)	\
    (This)->lpVtbl -> StillOff(This)

#define IDvdControl_PauseOn(This)	\
    (This)->lpVtbl -> PauseOn(This)

#define IDvdControl_PauseOff(This)	\
    (This)->lpVtbl -> PauseOff(This)

#define IDvdControl_MenuLanguageSelect(This,Language)	\
    (This)->lpVtbl -> MenuLanguageSelect(This,Language)

#define IDvdControl_AudioStreamChange(This,ulAudio)	\
    (This)->lpVtbl -> AudioStreamChange(This,ulAudio)

#define IDvdControl_SubpictureStreamChange(This,ulSubPicture,bDisplay)	\
    (This)->lpVtbl -> SubpictureStreamChange(This,ulSubPicture,bDisplay)

#define IDvdControl_AngleChange(This,ulAngle)	\
    (This)->lpVtbl -> AngleChange(This,ulAngle)

#define IDvdControl_ParentalLevelSelect(This,ulParentalLevel)	\
    (This)->lpVtbl -> ParentalLevelSelect(This,ulParentalLevel)

#define IDvdControl_ParentalCountrySelect(This,wCountry)	\
    (This)->lpVtbl -> ParentalCountrySelect(This,wCountry)

#define IDvdControl_KaraokeAudioPresentationModeChange(This,ulMode)	\
    (This)->lpVtbl -> KaraokeAudioPresentationModeChange(This,ulMode)

#define IDvdControl_VideoModePreferrence(This,ulPreferredDisplayMode)	\
    (This)->lpVtbl -> VideoModePreferrence(This,ulPreferredDisplayMode)

#define IDvdControl_SetRoot(This,pszPath)	\
    (This)->lpVtbl -> SetRoot(This,pszPath)

#define IDvdControl_MouseActivate(This,point)	\
    (This)->lpVtbl -> MouseActivate(This,point)

#define IDvdControl_MouseSelect(This,point)	\
    (This)->lpVtbl -> MouseSelect(This,point)

#define IDvdControl_ChapterPlayAutoStop(This,ulTitle,ulChapter,ulChaptersToPlay)	\
    (This)->lpVtbl -> ChapterPlayAutoStop(This,ulTitle,ulChapter,ulChaptersToPlay)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDvdControl_TitlePlay_Proxy( 
    IDvdControl * This,
    /* [in] */ ULONG ulTitle);


void __RPC_STUB IDvdControl_TitlePlay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl_ChapterPlay_Proxy( 
    IDvdControl * This,
    /* [in] */ ULONG ulTitle,
    /* [in] */ ULONG ulChapter);


void __RPC_STUB IDvdControl_ChapterPlay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl_TimePlay_Proxy( 
    IDvdControl * This,
    /* [in] */ ULONG ulTitle,
    /* [in] */ ULONG bcdTime);


void __RPC_STUB IDvdControl_TimePlay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl_StopForResume_Proxy( 
    IDvdControl * This);


void __RPC_STUB IDvdControl_StopForResume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl_GoUp_Proxy( 
    IDvdControl * This);


void __RPC_STUB IDvdControl_GoUp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl_TimeSearch_Proxy( 
    IDvdControl * This,
    /* [in] */ ULONG bcdTime);


void __RPC_STUB IDvdControl_TimeSearch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl_ChapterSearch_Proxy( 
    IDvdControl * This,
    /* [in] */ ULONG ulChapter);


void __RPC_STUB IDvdControl_ChapterSearch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl_PrevPGSearch_Proxy( 
    IDvdControl * This);


void __RPC_STUB IDvdControl_PrevPGSearch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl_TopPGSearch_Proxy( 
    IDvdControl * This);


void __RPC_STUB IDvdControl_TopPGSearch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl_NextPGSearch_Proxy( 
    IDvdControl * This);


void __RPC_STUB IDvdControl_NextPGSearch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl_ForwardScan_Proxy( 
    IDvdControl * This,
    /* [in] */ double dwSpeed);


void __RPC_STUB IDvdControl_ForwardScan_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl_BackwardScan_Proxy( 
    IDvdControl * This,
    /* [in] */ double dwSpeed);


void __RPC_STUB IDvdControl_BackwardScan_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl_MenuCall_Proxy( 
    IDvdControl * This,
    /* [in] */ DVD_MENU_ID MenuID);


void __RPC_STUB IDvdControl_MenuCall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl_Resume_Proxy( 
    IDvdControl * This);


void __RPC_STUB IDvdControl_Resume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl_UpperButtonSelect_Proxy( 
    IDvdControl * This);


void __RPC_STUB IDvdControl_UpperButtonSelect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl_LowerButtonSelect_Proxy( 
    IDvdControl * This);


void __RPC_STUB IDvdControl_LowerButtonSelect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl_LeftButtonSelect_Proxy( 
    IDvdControl * This);


void __RPC_STUB IDvdControl_LeftButtonSelect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl_RightButtonSelect_Proxy( 
    IDvdControl * This);


void __RPC_STUB IDvdControl_RightButtonSelect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl_ButtonActivate_Proxy( 
    IDvdControl * This);


void __RPC_STUB IDvdControl_ButtonActivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl_ButtonSelectAndActivate_Proxy( 
    IDvdControl * This,
    /* [in] */ ULONG ulButton);


void __RPC_STUB IDvdControl_ButtonSelectAndActivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl_StillOff_Proxy( 
    IDvdControl * This);


void __RPC_STUB IDvdControl_StillOff_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl_PauseOn_Proxy( 
    IDvdControl * This);


void __RPC_STUB IDvdControl_PauseOn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl_PauseOff_Proxy( 
    IDvdControl * This);


void __RPC_STUB IDvdControl_PauseOff_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl_MenuLanguageSelect_Proxy( 
    IDvdControl * This,
    /* [in] */ LCID Language);


void __RPC_STUB IDvdControl_MenuLanguageSelect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl_AudioStreamChange_Proxy( 
    IDvdControl * This,
    /* [in] */ ULONG ulAudio);


void __RPC_STUB IDvdControl_AudioStreamChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl_SubpictureStreamChange_Proxy( 
    IDvdControl * This,
    /* [in] */ ULONG ulSubPicture,
    /* [in] */ BOOL bDisplay);


void __RPC_STUB IDvdControl_SubpictureStreamChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl_AngleChange_Proxy( 
    IDvdControl * This,
    /* [in] */ ULONG ulAngle);


void __RPC_STUB IDvdControl_AngleChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl_ParentalLevelSelect_Proxy( 
    IDvdControl * This,
    /* [in] */ ULONG ulParentalLevel);


void __RPC_STUB IDvdControl_ParentalLevelSelect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl_ParentalCountrySelect_Proxy( 
    IDvdControl * This,
    /* [in] */ WORD wCountry);


void __RPC_STUB IDvdControl_ParentalCountrySelect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl_KaraokeAudioPresentationModeChange_Proxy( 
    IDvdControl * This,
    /* [in] */ ULONG ulMode);


void __RPC_STUB IDvdControl_KaraokeAudioPresentationModeChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl_VideoModePreferrence_Proxy( 
    IDvdControl * This,
    /* [in] */ ULONG ulPreferredDisplayMode);


void __RPC_STUB IDvdControl_VideoModePreferrence_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl_SetRoot_Proxy( 
    IDvdControl * This,
    /* [in] */ LPCWSTR pszPath);


void __RPC_STUB IDvdControl_SetRoot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl_MouseActivate_Proxy( 
    IDvdControl * This,
    /* [in] */ POINT point);


void __RPC_STUB IDvdControl_MouseActivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl_MouseSelect_Proxy( 
    IDvdControl * This,
    /* [in] */ POINT point);


void __RPC_STUB IDvdControl_MouseSelect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl_ChapterPlayAutoStop_Proxy( 
    IDvdControl * This,
    /* [in] */ ULONG ulTitle,
    /* [in] */ ULONG ulChapter,
    /* [in] */ ULONG ulChaptersToPlay);


void __RPC_STUB IDvdControl_ChapterPlayAutoStop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDvdControl_INTERFACE_DEFINED__ */


#ifndef __IDvdInfo_INTERFACE_DEFINED__
#define __IDvdInfo_INTERFACE_DEFINED__

/* interface IDvdInfo */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDvdInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A70EFE60-E2A3-11d0-A9BE-00AA0061BE93")
    IDvdInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCurrentDomain( 
            /* [out] */ DVD_DOMAIN *pDomain) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentLocation( 
            /* [out] */ DVD_PLAYBACK_LOCATION *pLocation) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTotalTitleTime( 
            /* [out] */ ULONG *pulTotalTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentButton( 
            /* [out] */ ULONG *pulButtonsAvailable,
            /* [out] */ ULONG *pulCurrentButton) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentAngle( 
            /* [out] */ ULONG *pulAnglesAvailable,
            /* [out] */ ULONG *pulCurrentAngle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentAudio( 
            /* [out] */ ULONG *pulStreamsAvailable,
            /* [out] */ ULONG *pulCurrentStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentSubpicture( 
            /* [out] */ ULONG *pulStreamsAvailable,
            /* [out] */ ULONG *pulCurrentStream,
            /* [out] */ BOOL *pIsDisabled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentUOPS( 
            /* [out] */ VALID_UOP_SOMTHING_OR_OTHER *pUOP) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAllSPRMs( 
            /* [out] */ SPRMARRAY *pRegisterArray) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAllGPRMs( 
            /* [out] */ GPRMARRAY *pRegisterArray) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAudioLanguage( 
            /* [in] */ ULONG ulStream,
            /* [out] */ LCID *pLanguage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSubpictureLanguage( 
            /* [in] */ ULONG ulStream,
            /* [out] */ LCID *pLanguage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTitleAttributes( 
            /* [in] */ ULONG ulTitle,
            /* [out] */ DVD_ATR *pATR) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVMGAttributes( 
            /* [out] */ DVD_ATR *pATR) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentVideoAttributes( 
            /* [out] */ DVD_VideoATR *pATR) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentAudioAttributes( 
            /* [out] */ DVD_AudioATR *pATR) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentSubpictureAttributes( 
            /* [out] */ DVD_SubpictureATR *pATR) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentVolumeInfo( 
            /* [out] */ ULONG *pulNumOfVol,
            /* [out] */ ULONG *pulThisVolNum,
            /* [out] */ DVD_DISC_SIDE *pSide,
            /* [out] */ ULONG *pulNumOfTitles) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDVDTextInfo( 
            /* [size_is][out] */ BYTE *pTextManager,
            /* [in] */ ULONG ulBufSize,
            /* [out] */ ULONG *pulActualSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPlayerParentalLevel( 
            /* [out] */ ULONG *pulParentalLevel,
            /* [out] */ ULONG *pulCountryCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNumberOfChapters( 
            /* [in] */ ULONG ulTitle,
            /* [out] */ ULONG *pulNumberOfChapters) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTitleParentalLevels( 
            /* [in] */ ULONG ulTitle,
            /* [out] */ ULONG *pulParentalLevels) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRoot( 
            /* [size_is][out] */ LPSTR pRoot,
            /* [in] */ ULONG ulBufSize,
            /* [out] */ ULONG *pulActualSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDvdInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDvdInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDvdInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDvdInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentDomain )( 
            IDvdInfo * This,
            /* [out] */ DVD_DOMAIN *pDomain);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentLocation )( 
            IDvdInfo * This,
            /* [out] */ DVD_PLAYBACK_LOCATION *pLocation);
        
        HRESULT ( STDMETHODCALLTYPE *GetTotalTitleTime )( 
            IDvdInfo * This,
            /* [out] */ ULONG *pulTotalTime);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentButton )( 
            IDvdInfo * This,
            /* [out] */ ULONG *pulButtonsAvailable,
            /* [out] */ ULONG *pulCurrentButton);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentAngle )( 
            IDvdInfo * This,
            /* [out] */ ULONG *pulAnglesAvailable,
            /* [out] */ ULONG *pulCurrentAngle);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentAudio )( 
            IDvdInfo * This,
            /* [out] */ ULONG *pulStreamsAvailable,
            /* [out] */ ULONG *pulCurrentStream);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentSubpicture )( 
            IDvdInfo * This,
            /* [out] */ ULONG *pulStreamsAvailable,
            /* [out] */ ULONG *pulCurrentStream,
            /* [out] */ BOOL *pIsDisabled);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentUOPS )( 
            IDvdInfo * This,
            /* [out] */ VALID_UOP_SOMTHING_OR_OTHER *pUOP);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllSPRMs )( 
            IDvdInfo * This,
            /* [out] */ SPRMARRAY *pRegisterArray);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllGPRMs )( 
            IDvdInfo * This,
            /* [out] */ GPRMARRAY *pRegisterArray);
        
        HRESULT ( STDMETHODCALLTYPE *GetAudioLanguage )( 
            IDvdInfo * This,
            /* [in] */ ULONG ulStream,
            /* [out] */ LCID *pLanguage);
        
        HRESULT ( STDMETHODCALLTYPE *GetSubpictureLanguage )( 
            IDvdInfo * This,
            /* [in] */ ULONG ulStream,
            /* [out] */ LCID *pLanguage);
        
        HRESULT ( STDMETHODCALLTYPE *GetTitleAttributes )( 
            IDvdInfo * This,
            /* [in] */ ULONG ulTitle,
            /* [out] */ DVD_ATR *pATR);
        
        HRESULT ( STDMETHODCALLTYPE *GetVMGAttributes )( 
            IDvdInfo * This,
            /* [out] */ DVD_ATR *pATR);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentVideoAttributes )( 
            IDvdInfo * This,
            /* [out] */ DVD_VideoATR *pATR);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentAudioAttributes )( 
            IDvdInfo * This,
            /* [out] */ DVD_AudioATR *pATR);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentSubpictureAttributes )( 
            IDvdInfo * This,
            /* [out] */ DVD_SubpictureATR *pATR);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentVolumeInfo )( 
            IDvdInfo * This,
            /* [out] */ ULONG *pulNumOfVol,
            /* [out] */ ULONG *pulThisVolNum,
            /* [out] */ DVD_DISC_SIDE *pSide,
            /* [out] */ ULONG *pulNumOfTitles);
        
        HRESULT ( STDMETHODCALLTYPE *GetDVDTextInfo )( 
            IDvdInfo * This,
            /* [size_is][out] */ BYTE *pTextManager,
            /* [in] */ ULONG ulBufSize,
            /* [out] */ ULONG *pulActualSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetPlayerParentalLevel )( 
            IDvdInfo * This,
            /* [out] */ ULONG *pulParentalLevel,
            /* [out] */ ULONG *pulCountryCode);
        
        HRESULT ( STDMETHODCALLTYPE *GetNumberOfChapters )( 
            IDvdInfo * This,
            /* [in] */ ULONG ulTitle,
            /* [out] */ ULONG *pulNumberOfChapters);
        
        HRESULT ( STDMETHODCALLTYPE *GetTitleParentalLevels )( 
            IDvdInfo * This,
            /* [in] */ ULONG ulTitle,
            /* [out] */ ULONG *pulParentalLevels);
        
        HRESULT ( STDMETHODCALLTYPE *GetRoot )( 
            IDvdInfo * This,
            /* [size_is][out] */ LPSTR pRoot,
            /* [in] */ ULONG ulBufSize,
            /* [out] */ ULONG *pulActualSize);
        
        END_INTERFACE
    } IDvdInfoVtbl;

    interface IDvdInfo
    {
        CONST_VTBL struct IDvdInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDvdInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDvdInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDvdInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDvdInfo_GetCurrentDomain(This,pDomain)	\
    (This)->lpVtbl -> GetCurrentDomain(This,pDomain)

#define IDvdInfo_GetCurrentLocation(This,pLocation)	\
    (This)->lpVtbl -> GetCurrentLocation(This,pLocation)

#define IDvdInfo_GetTotalTitleTime(This,pulTotalTime)	\
    (This)->lpVtbl -> GetTotalTitleTime(This,pulTotalTime)

#define IDvdInfo_GetCurrentButton(This,pulButtonsAvailable,pulCurrentButton)	\
    (This)->lpVtbl -> GetCurrentButton(This,pulButtonsAvailable,pulCurrentButton)

#define IDvdInfo_GetCurrentAngle(This,pulAnglesAvailable,pulCurrentAngle)	\
    (This)->lpVtbl -> GetCurrentAngle(This,pulAnglesAvailable,pulCurrentAngle)

#define IDvdInfo_GetCurrentAudio(This,pulStreamsAvailable,pulCurrentStream)	\
    (This)->lpVtbl -> GetCurrentAudio(This,pulStreamsAvailable,pulCurrentStream)

#define IDvdInfo_GetCurrentSubpicture(This,pulStreamsAvailable,pulCurrentStream,pIsDisabled)	\
    (This)->lpVtbl -> GetCurrentSubpicture(This,pulStreamsAvailable,pulCurrentStream,pIsDisabled)

#define IDvdInfo_GetCurrentUOPS(This,pUOP)	\
    (This)->lpVtbl -> GetCurrentUOPS(This,pUOP)

#define IDvdInfo_GetAllSPRMs(This,pRegisterArray)	\
    (This)->lpVtbl -> GetAllSPRMs(This,pRegisterArray)

#define IDvdInfo_GetAllGPRMs(This,pRegisterArray)	\
    (This)->lpVtbl -> GetAllGPRMs(This,pRegisterArray)

#define IDvdInfo_GetAudioLanguage(This,ulStream,pLanguage)	\
    (This)->lpVtbl -> GetAudioLanguage(This,ulStream,pLanguage)

#define IDvdInfo_GetSubpictureLanguage(This,ulStream,pLanguage)	\
    (This)->lpVtbl -> GetSubpictureLanguage(This,ulStream,pLanguage)

#define IDvdInfo_GetTitleAttributes(This,ulTitle,pATR)	\
    (This)->lpVtbl -> GetTitleAttributes(This,ulTitle,pATR)

#define IDvdInfo_GetVMGAttributes(This,pATR)	\
    (This)->lpVtbl -> GetVMGAttributes(This,pATR)

#define IDvdInfo_GetCurrentVideoAttributes(This,pATR)	\
    (This)->lpVtbl -> GetCurrentVideoAttributes(This,pATR)

#define IDvdInfo_GetCurrentAudioAttributes(This,pATR)	\
    (This)->lpVtbl -> GetCurrentAudioAttributes(This,pATR)

#define IDvdInfo_GetCurrentSubpictureAttributes(This,pATR)	\
    (This)->lpVtbl -> GetCurrentSubpictureAttributes(This,pATR)

#define IDvdInfo_GetCurrentVolumeInfo(This,pulNumOfVol,pulThisVolNum,pSide,pulNumOfTitles)	\
    (This)->lpVtbl -> GetCurrentVolumeInfo(This,pulNumOfVol,pulThisVolNum,pSide,pulNumOfTitles)

#define IDvdInfo_GetDVDTextInfo(This,pTextManager,ulBufSize,pulActualSize)	\
    (This)->lpVtbl -> GetDVDTextInfo(This,pTextManager,ulBufSize,pulActualSize)

#define IDvdInfo_GetPlayerParentalLevel(This,pulParentalLevel,pulCountryCode)	\
    (This)->lpVtbl -> GetPlayerParentalLevel(This,pulParentalLevel,pulCountryCode)

#define IDvdInfo_GetNumberOfChapters(This,ulTitle,pulNumberOfChapters)	\
    (This)->lpVtbl -> GetNumberOfChapters(This,ulTitle,pulNumberOfChapters)

#define IDvdInfo_GetTitleParentalLevels(This,ulTitle,pulParentalLevels)	\
    (This)->lpVtbl -> GetTitleParentalLevels(This,ulTitle,pulParentalLevels)

#define IDvdInfo_GetRoot(This,pRoot,ulBufSize,pulActualSize)	\
    (This)->lpVtbl -> GetRoot(This,pRoot,ulBufSize,pulActualSize)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDvdInfo_GetCurrentDomain_Proxy( 
    IDvdInfo * This,
    /* [out] */ DVD_DOMAIN *pDomain);


void __RPC_STUB IDvdInfo_GetCurrentDomain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo_GetCurrentLocation_Proxy( 
    IDvdInfo * This,
    /* [out] */ DVD_PLAYBACK_LOCATION *pLocation);


void __RPC_STUB IDvdInfo_GetCurrentLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo_GetTotalTitleTime_Proxy( 
    IDvdInfo * This,
    /* [out] */ ULONG *pulTotalTime);


void __RPC_STUB IDvdInfo_GetTotalTitleTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo_GetCurrentButton_Proxy( 
    IDvdInfo * This,
    /* [out] */ ULONG *pulButtonsAvailable,
    /* [out] */ ULONG *pulCurrentButton);


void __RPC_STUB IDvdInfo_GetCurrentButton_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo_GetCurrentAngle_Proxy( 
    IDvdInfo * This,
    /* [out] */ ULONG *pulAnglesAvailable,
    /* [out] */ ULONG *pulCurrentAngle);


void __RPC_STUB IDvdInfo_GetCurrentAngle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo_GetCurrentAudio_Proxy( 
    IDvdInfo * This,
    /* [out] */ ULONG *pulStreamsAvailable,
    /* [out] */ ULONG *pulCurrentStream);


void __RPC_STUB IDvdInfo_GetCurrentAudio_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo_GetCurrentSubpicture_Proxy( 
    IDvdInfo * This,
    /* [out] */ ULONG *pulStreamsAvailable,
    /* [out] */ ULONG *pulCurrentStream,
    /* [out] */ BOOL *pIsDisabled);


void __RPC_STUB IDvdInfo_GetCurrentSubpicture_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo_GetCurrentUOPS_Proxy( 
    IDvdInfo * This,
    /* [out] */ VALID_UOP_SOMTHING_OR_OTHER *pUOP);


void __RPC_STUB IDvdInfo_GetCurrentUOPS_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo_GetAllSPRMs_Proxy( 
    IDvdInfo * This,
    /* [out] */ SPRMARRAY *pRegisterArray);


void __RPC_STUB IDvdInfo_GetAllSPRMs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo_GetAllGPRMs_Proxy( 
    IDvdInfo * This,
    /* [out] */ GPRMARRAY *pRegisterArray);


void __RPC_STUB IDvdInfo_GetAllGPRMs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo_GetAudioLanguage_Proxy( 
    IDvdInfo * This,
    /* [in] */ ULONG ulStream,
    /* [out] */ LCID *pLanguage);


void __RPC_STUB IDvdInfo_GetAudioLanguage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo_GetSubpictureLanguage_Proxy( 
    IDvdInfo * This,
    /* [in] */ ULONG ulStream,
    /* [out] */ LCID *pLanguage);


void __RPC_STUB IDvdInfo_GetSubpictureLanguage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo_GetTitleAttributes_Proxy( 
    IDvdInfo * This,
    /* [in] */ ULONG ulTitle,
    /* [out] */ DVD_ATR *pATR);


void __RPC_STUB IDvdInfo_GetTitleAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo_GetVMGAttributes_Proxy( 
    IDvdInfo * This,
    /* [out] */ DVD_ATR *pATR);


void __RPC_STUB IDvdInfo_GetVMGAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo_GetCurrentVideoAttributes_Proxy( 
    IDvdInfo * This,
    /* [out] */ DVD_VideoATR *pATR);


void __RPC_STUB IDvdInfo_GetCurrentVideoAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo_GetCurrentAudioAttributes_Proxy( 
    IDvdInfo * This,
    /* [out] */ DVD_AudioATR *pATR);


void __RPC_STUB IDvdInfo_GetCurrentAudioAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo_GetCurrentSubpictureAttributes_Proxy( 
    IDvdInfo * This,
    /* [out] */ DVD_SubpictureATR *pATR);


void __RPC_STUB IDvdInfo_GetCurrentSubpictureAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo_GetCurrentVolumeInfo_Proxy( 
    IDvdInfo * This,
    /* [out] */ ULONG *pulNumOfVol,
    /* [out] */ ULONG *pulThisVolNum,
    /* [out] */ DVD_DISC_SIDE *pSide,
    /* [out] */ ULONG *pulNumOfTitles);


void __RPC_STUB IDvdInfo_GetCurrentVolumeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo_GetDVDTextInfo_Proxy( 
    IDvdInfo * This,
    /* [size_is][out] */ BYTE *pTextManager,
    /* [in] */ ULONG ulBufSize,
    /* [out] */ ULONG *pulActualSize);


void __RPC_STUB IDvdInfo_GetDVDTextInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo_GetPlayerParentalLevel_Proxy( 
    IDvdInfo * This,
    /* [out] */ ULONG *pulParentalLevel,
    /* [out] */ ULONG *pulCountryCode);


void __RPC_STUB IDvdInfo_GetPlayerParentalLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo_GetNumberOfChapters_Proxy( 
    IDvdInfo * This,
    /* [in] */ ULONG ulTitle,
    /* [out] */ ULONG *pulNumberOfChapters);


void __RPC_STUB IDvdInfo_GetNumberOfChapters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo_GetTitleParentalLevels_Proxy( 
    IDvdInfo * This,
    /* [in] */ ULONG ulTitle,
    /* [out] */ ULONG *pulParentalLevels);


void __RPC_STUB IDvdInfo_GetTitleParentalLevels_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo_GetRoot_Proxy( 
    IDvdInfo * This,
    /* [size_is][out] */ LPSTR pRoot,
    /* [in] */ ULONG ulBufSize,
    /* [out] */ ULONG *pulActualSize);


void __RPC_STUB IDvdInfo_GetRoot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDvdInfo_INTERFACE_DEFINED__ */


#ifndef __IDvdCmd_INTERFACE_DEFINED__
#define __IDvdCmd_INTERFACE_DEFINED__

/* interface IDvdCmd */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDvdCmd;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5a4a97e4-94ee-4a55-9751-74b5643aa27d")
    IDvdCmd : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE WaitForStart( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WaitForEnd( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDvdCmdVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDvdCmd * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDvdCmd * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDvdCmd * This);
        
        HRESULT ( STDMETHODCALLTYPE *WaitForStart )( 
            IDvdCmd * This);
        
        HRESULT ( STDMETHODCALLTYPE *WaitForEnd )( 
            IDvdCmd * This);
        
        END_INTERFACE
    } IDvdCmdVtbl;

    interface IDvdCmd
    {
        CONST_VTBL struct IDvdCmdVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDvdCmd_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDvdCmd_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDvdCmd_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDvdCmd_WaitForStart(This)	\
    (This)->lpVtbl -> WaitForStart(This)

#define IDvdCmd_WaitForEnd(This)	\
    (This)->lpVtbl -> WaitForEnd(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDvdCmd_WaitForStart_Proxy( 
    IDvdCmd * This);


void __RPC_STUB IDvdCmd_WaitForStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdCmd_WaitForEnd_Proxy( 
    IDvdCmd * This);


void __RPC_STUB IDvdCmd_WaitForEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDvdCmd_INTERFACE_DEFINED__ */


#ifndef __IDvdState_INTERFACE_DEFINED__
#define __IDvdState_INTERFACE_DEFINED__

/* interface IDvdState */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDvdState;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("86303d6d-1c4a-4087-ab42-f711167048ef")
    IDvdState : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDiscID( 
            /* [out] */ ULONGLONG *pullUniqueID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParentalLevel( 
            /* [out] */ ULONG *pulParentalLevel) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDvdStateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDvdState * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDvdState * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDvdState * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDiscID )( 
            IDvdState * This,
            /* [out] */ ULONGLONG *pullUniqueID);
        
        HRESULT ( STDMETHODCALLTYPE *GetParentalLevel )( 
            IDvdState * This,
            /* [out] */ ULONG *pulParentalLevel);
        
        END_INTERFACE
    } IDvdStateVtbl;

    interface IDvdState
    {
        CONST_VTBL struct IDvdStateVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDvdState_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDvdState_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDvdState_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDvdState_GetDiscID(This,pullUniqueID)	\
    (This)->lpVtbl -> GetDiscID(This,pullUniqueID)

#define IDvdState_GetParentalLevel(This,pulParentalLevel)	\
    (This)->lpVtbl -> GetParentalLevel(This,pulParentalLevel)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDvdState_GetDiscID_Proxy( 
    IDvdState * This,
    /* [out] */ ULONGLONG *pullUniqueID);


void __RPC_STUB IDvdState_GetDiscID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdState_GetParentalLevel_Proxy( 
    IDvdState * This,
    /* [out] */ ULONG *pulParentalLevel);


void __RPC_STUB IDvdState_GetParentalLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDvdState_INTERFACE_DEFINED__ */


#ifndef __IDvdControl2_INTERFACE_DEFINED__
#define __IDvdControl2_INTERFACE_DEFINED__

/* interface IDvdControl2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDvdControl2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("33BC7430-EEC0-11D2-8201-00A0C9D74842")
    IDvdControl2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE PlayTitle( 
            /* [in] */ ULONG ulTitle,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PlayChapterInTitle( 
            /* [in] */ ULONG ulTitle,
            /* [in] */ ULONG ulChapter,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PlayAtTimeInTitle( 
            /* [in] */ ULONG ulTitle,
            /* [in] */ DVD_HMSF_TIMECODE *pStartTime,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReturnFromSubmenu( 
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PlayAtTime( 
            /* [in] */ DVD_HMSF_TIMECODE *pTime,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PlayChapter( 
            /* [in] */ ULONG ulChapter,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PlayPrevChapter( 
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReplayChapter( 
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PlayNextChapter( 
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PlayForwards( 
            /* [in] */ double dSpeed,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PlayBackwards( 
            /* [in] */ double dSpeed,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShowMenu( 
            /* [in] */ DVD_MENU_ID MenuID,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( 
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectRelativeButton( 
            DVD_RELATIVE_BUTTON buttonDir) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ActivateButton( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectButton( 
            /* [in] */ ULONG ulButton) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectAndActivateButton( 
            /* [in] */ ULONG ulButton) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StillOff( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pause( 
            /* [in] */ BOOL bState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectAudioStream( 
            /* [in] */ ULONG ulAudio,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectSubpictureStream( 
            /* [in] */ ULONG ulSubPicture,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSubpictureState( 
            /* [in] */ BOOL bState,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectAngle( 
            /* [in] */ ULONG ulAngle,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectParentalLevel( 
            /* [in] */ ULONG ulParentalLevel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectParentalCountry( 
            /* [in] */ BYTE bCountry[ 2 ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectKaraokeAudioPresentationMode( 
            /* [in] */ ULONG ulMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectVideoModePreference( 
            /* [in] */ ULONG ulPreferredDisplayMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDVDDirectory( 
            /* [in] */ LPCWSTR pszwPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ActivateAtPosition( 
            /* [in] */ POINT point) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectAtPosition( 
            /* [in] */ POINT point) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PlayChaptersAutoStop( 
            /* [in] */ ULONG ulTitle,
            /* [in] */ ULONG ulChapter,
            /* [in] */ ULONG ulChaptersToPlay,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AcceptParentalLevelChange( 
            /* [in] */ BOOL bAccept) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOption( 
            /* [in] */ DVD_OPTION_FLAG flag,
            /* [in] */ BOOL fState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetState( 
            /* [in] */ IDvdState *pState,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PlayPeriodInTitleAutoStop( 
            /* [in] */ ULONG ulTitle,
            /* [in] */ DVD_HMSF_TIMECODE *pStartTime,
            /* [in] */ DVD_HMSF_TIMECODE *pEndTime,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetGPRM( 
            /* [in] */ ULONG ulIndex,
            /* [in] */ WORD wValue,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectDefaultMenuLanguage( 
            /* [in] */ LCID Language) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectDefaultAudioLanguage( 
            /* [in] */ LCID Language,
            /* [in] */ DVD_AUDIO_LANG_EXT audioExtension) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectDefaultSubpictureLanguage( 
            /* [in] */ LCID Language,
            /* [in] */ DVD_SUBPICTURE_LANG_EXT subpictureExtension) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDvdControl2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDvdControl2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDvdControl2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDvdControl2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *PlayTitle )( 
            IDvdControl2 * This,
            /* [in] */ ULONG ulTitle,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *PlayChapterInTitle )( 
            IDvdControl2 * This,
            /* [in] */ ULONG ulTitle,
            /* [in] */ ULONG ulChapter,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *PlayAtTimeInTitle )( 
            IDvdControl2 * This,
            /* [in] */ ULONG ulTitle,
            /* [in] */ DVD_HMSF_TIMECODE *pStartTime,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IDvdControl2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *ReturnFromSubmenu )( 
            IDvdControl2 * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *PlayAtTime )( 
            IDvdControl2 * This,
            /* [in] */ DVD_HMSF_TIMECODE *pTime,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *PlayChapter )( 
            IDvdControl2 * This,
            /* [in] */ ULONG ulChapter,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *PlayPrevChapter )( 
            IDvdControl2 * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *ReplayChapter )( 
            IDvdControl2 * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *PlayNextChapter )( 
            IDvdControl2 * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *PlayForwards )( 
            IDvdControl2 * This,
            /* [in] */ double dSpeed,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *PlayBackwards )( 
            IDvdControl2 * This,
            /* [in] */ double dSpeed,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *ShowMenu )( 
            IDvdControl2 * This,
            /* [in] */ DVD_MENU_ID MenuID,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IDvdControl2 * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *SelectRelativeButton )( 
            IDvdControl2 * This,
            DVD_RELATIVE_BUTTON buttonDir);
        
        HRESULT ( STDMETHODCALLTYPE *ActivateButton )( 
            IDvdControl2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SelectButton )( 
            IDvdControl2 * This,
            /* [in] */ ULONG ulButton);
        
        HRESULT ( STDMETHODCALLTYPE *SelectAndActivateButton )( 
            IDvdControl2 * This,
            /* [in] */ ULONG ulButton);
        
        HRESULT ( STDMETHODCALLTYPE *StillOff )( 
            IDvdControl2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IDvdControl2 * This,
            /* [in] */ BOOL bState);
        
        HRESULT ( STDMETHODCALLTYPE *SelectAudioStream )( 
            IDvdControl2 * This,
            /* [in] */ ULONG ulAudio,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *SelectSubpictureStream )( 
            IDvdControl2 * This,
            /* [in] */ ULONG ulSubPicture,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *SetSubpictureState )( 
            IDvdControl2 * This,
            /* [in] */ BOOL bState,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *SelectAngle )( 
            IDvdControl2 * This,
            /* [in] */ ULONG ulAngle,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *SelectParentalLevel )( 
            IDvdControl2 * This,
            /* [in] */ ULONG ulParentalLevel);
        
        HRESULT ( STDMETHODCALLTYPE *SelectParentalCountry )( 
            IDvdControl2 * This,
            /* [in] */ BYTE bCountry[ 2 ]);
        
        HRESULT ( STDMETHODCALLTYPE *SelectKaraokeAudioPresentationMode )( 
            IDvdControl2 * This,
            /* [in] */ ULONG ulMode);
        
        HRESULT ( STDMETHODCALLTYPE *SelectVideoModePreference )( 
            IDvdControl2 * This,
            /* [in] */ ULONG ulPreferredDisplayMode);
        
        HRESULT ( STDMETHODCALLTYPE *SetDVDDirectory )( 
            IDvdControl2 * This,
            /* [in] */ LPCWSTR pszwPath);
        
        HRESULT ( STDMETHODCALLTYPE *ActivateAtPosition )( 
            IDvdControl2 * This,
            /* [in] */ POINT point);
        
        HRESULT ( STDMETHODCALLTYPE *SelectAtPosition )( 
            IDvdControl2 * This,
            /* [in] */ POINT point);
        
        HRESULT ( STDMETHODCALLTYPE *PlayChaptersAutoStop )( 
            IDvdControl2 * This,
            /* [in] */ ULONG ulTitle,
            /* [in] */ ULONG ulChapter,
            /* [in] */ ULONG ulChaptersToPlay,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *AcceptParentalLevelChange )( 
            IDvdControl2 * This,
            /* [in] */ BOOL bAccept);
        
        HRESULT ( STDMETHODCALLTYPE *SetOption )( 
            IDvdControl2 * This,
            /* [in] */ DVD_OPTION_FLAG flag,
            /* [in] */ BOOL fState);
        
        HRESULT ( STDMETHODCALLTYPE *SetState )( 
            IDvdControl2 * This,
            /* [in] */ IDvdState *pState,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *PlayPeriodInTitleAutoStop )( 
            IDvdControl2 * This,
            /* [in] */ ULONG ulTitle,
            /* [in] */ DVD_HMSF_TIMECODE *pStartTime,
            /* [in] */ DVD_HMSF_TIMECODE *pEndTime,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *SetGPRM )( 
            IDvdControl2 * This,
            /* [in] */ ULONG ulIndex,
            /* [in] */ WORD wValue,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *SelectDefaultMenuLanguage )( 
            IDvdControl2 * This,
            /* [in] */ LCID Language);
        
        HRESULT ( STDMETHODCALLTYPE *SelectDefaultAudioLanguage )( 
            IDvdControl2 * This,
            /* [in] */ LCID Language,
            /* [in] */ DVD_AUDIO_LANG_EXT audioExtension);
        
        HRESULT ( STDMETHODCALLTYPE *SelectDefaultSubpictureLanguage )( 
            IDvdControl2 * This,
            /* [in] */ LCID Language,
            /* [in] */ DVD_SUBPICTURE_LANG_EXT subpictureExtension);
        
        END_INTERFACE
    } IDvdControl2Vtbl;

    interface IDvdControl2
    {
        CONST_VTBL struct IDvdControl2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDvdControl2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDvdControl2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDvdControl2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDvdControl2_PlayTitle(This,ulTitle,dwFlags,ppCmd)	\
    (This)->lpVtbl -> PlayTitle(This,ulTitle,dwFlags,ppCmd)

#define IDvdControl2_PlayChapterInTitle(This,ulTitle,ulChapter,dwFlags,ppCmd)	\
    (This)->lpVtbl -> PlayChapterInTitle(This,ulTitle,ulChapter,dwFlags,ppCmd)

#define IDvdControl2_PlayAtTimeInTitle(This,ulTitle,pStartTime,dwFlags,ppCmd)	\
    (This)->lpVtbl -> PlayAtTimeInTitle(This,ulTitle,pStartTime,dwFlags,ppCmd)

#define IDvdControl2_Stop(This)	\
    (This)->lpVtbl -> Stop(This)

#define IDvdControl2_ReturnFromSubmenu(This,dwFlags,ppCmd)	\
    (This)->lpVtbl -> ReturnFromSubmenu(This,dwFlags,ppCmd)

#define IDvdControl2_PlayAtTime(This,pTime,dwFlags,ppCmd)	\
    (This)->lpVtbl -> PlayAtTime(This,pTime,dwFlags,ppCmd)

#define IDvdControl2_PlayChapter(This,ulChapter,dwFlags,ppCmd)	\
    (This)->lpVtbl -> PlayChapter(This,ulChapter,dwFlags,ppCmd)

#define IDvdControl2_PlayPrevChapter(This,dwFlags,ppCmd)	\
    (This)->lpVtbl -> PlayPrevChapter(This,dwFlags,ppCmd)

#define IDvdControl2_ReplayChapter(This,dwFlags,ppCmd)	\
    (This)->lpVtbl -> ReplayChapter(This,dwFlags,ppCmd)

#define IDvdControl2_PlayNextChapter(This,dwFlags,ppCmd)	\
    (This)->lpVtbl -> PlayNextChapter(This,dwFlags,ppCmd)

#define IDvdControl2_PlayForwards(This,dSpeed,dwFlags,ppCmd)	\
    (This)->lpVtbl -> PlayForwards(This,dSpeed,dwFlags,ppCmd)

#define IDvdControl2_PlayBackwards(This,dSpeed,dwFlags,ppCmd)	\
    (This)->lpVtbl -> PlayBackwards(This,dSpeed,dwFlags,ppCmd)

#define IDvdControl2_ShowMenu(This,MenuID,dwFlags,ppCmd)	\
    (This)->lpVtbl -> ShowMenu(This,MenuID,dwFlags,ppCmd)

#define IDvdControl2_Resume(This,dwFlags,ppCmd)	\
    (This)->lpVtbl -> Resume(This,dwFlags,ppCmd)

#define IDvdControl2_SelectRelativeButton(This,buttonDir)	\
    (This)->lpVtbl -> SelectRelativeButton(This,buttonDir)

#define IDvdControl2_ActivateButton(This)	\
    (This)->lpVtbl -> ActivateButton(This)

#define IDvdControl2_SelectButton(This,ulButton)	\
    (This)->lpVtbl -> SelectButton(This,ulButton)

#define IDvdControl2_SelectAndActivateButton(This,ulButton)	\
    (This)->lpVtbl -> SelectAndActivateButton(This,ulButton)

#define IDvdControl2_StillOff(This)	\
    (This)->lpVtbl -> StillOff(This)

#define IDvdControl2_Pause(This,bState)	\
    (This)->lpVtbl -> Pause(This,bState)

#define IDvdControl2_SelectAudioStream(This,ulAudio,dwFlags,ppCmd)	\
    (This)->lpVtbl -> SelectAudioStream(This,ulAudio,dwFlags,ppCmd)

#define IDvdControl2_SelectSubpictureStream(This,ulSubPicture,dwFlags,ppCmd)	\
    (This)->lpVtbl -> SelectSubpictureStream(This,ulSubPicture,dwFlags,ppCmd)

#define IDvdControl2_SetSubpictureState(This,bState,dwFlags,ppCmd)	\
    (This)->lpVtbl -> SetSubpictureState(This,bState,dwFlags,ppCmd)

#define IDvdControl2_SelectAngle(This,ulAngle,dwFlags,ppCmd)	\
    (This)->lpVtbl -> SelectAngle(This,ulAngle,dwFlags,ppCmd)

#define IDvdControl2_SelectParentalLevel(This,ulParentalLevel)	\
    (This)->lpVtbl -> SelectParentalLevel(This,ulParentalLevel)

#define IDvdControl2_SelectParentalCountry(This,bCountry)	\
    (This)->lpVtbl -> SelectParentalCountry(This,bCountry)

#define IDvdControl2_SelectKaraokeAudioPresentationMode(This,ulMode)	\
    (This)->lpVtbl -> SelectKaraokeAudioPresentationMode(This,ulMode)

#define IDvdControl2_SelectVideoModePreference(This,ulPreferredDisplayMode)	\
    (This)->lpVtbl -> SelectVideoModePreference(This,ulPreferredDisplayMode)

#define IDvdControl2_SetDVDDirectory(This,pszwPath)	\
    (This)->lpVtbl -> SetDVDDirectory(This,pszwPath)

#define IDvdControl2_ActivateAtPosition(This,point)	\
    (This)->lpVtbl -> ActivateAtPosition(This,point)

#define IDvdControl2_SelectAtPosition(This,point)	\
    (This)->lpVtbl -> SelectAtPosition(This,point)

#define IDvdControl2_PlayChaptersAutoStop(This,ulTitle,ulChapter,ulChaptersToPlay,dwFlags,ppCmd)	\
    (This)->lpVtbl -> PlayChaptersAutoStop(This,ulTitle,ulChapter,ulChaptersToPlay,dwFlags,ppCmd)

#define IDvdControl2_AcceptParentalLevelChange(This,bAccept)	\
    (This)->lpVtbl -> AcceptParentalLevelChange(This,bAccept)

#define IDvdControl2_SetOption(This,flag,fState)	\
    (This)->lpVtbl -> SetOption(This,flag,fState)

#define IDvdControl2_SetState(This,pState,dwFlags,ppCmd)	\
    (This)->lpVtbl -> SetState(This,pState,dwFlags,ppCmd)

#define IDvdControl2_PlayPeriodInTitleAutoStop(This,ulTitle,pStartTime,pEndTime,dwFlags,ppCmd)	\
    (This)->lpVtbl -> PlayPeriodInTitleAutoStop(This,ulTitle,pStartTime,pEndTime,dwFlags,ppCmd)

#define IDvdControl2_SetGPRM(This,ulIndex,wValue,dwFlags,ppCmd)	\
    (This)->lpVtbl -> SetGPRM(This,ulIndex,wValue,dwFlags,ppCmd)

#define IDvdControl2_SelectDefaultMenuLanguage(This,Language)	\
    (This)->lpVtbl -> SelectDefaultMenuLanguage(This,Language)

#define IDvdControl2_SelectDefaultAudioLanguage(This,Language,audioExtension)	\
    (This)->lpVtbl -> SelectDefaultAudioLanguage(This,Language,audioExtension)

#define IDvdControl2_SelectDefaultSubpictureLanguage(This,Language,subpictureExtension)	\
    (This)->lpVtbl -> SelectDefaultSubpictureLanguage(This,Language,subpictureExtension)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDvdControl2_PlayTitle_Proxy( 
    IDvdControl2 * This,
    /* [in] */ ULONG ulTitle,
    /* [in] */ DWORD dwFlags,
    /* [out] */ IDvdCmd **ppCmd);


void __RPC_STUB IDvdControl2_PlayTitle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl2_PlayChapterInTitle_Proxy( 
    IDvdControl2 * This,
    /* [in] */ ULONG ulTitle,
    /* [in] */ ULONG ulChapter,
    /* [in] */ DWORD dwFlags,
    /* [out] */ IDvdCmd **ppCmd);


void __RPC_STUB IDvdControl2_PlayChapterInTitle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl2_PlayAtTimeInTitle_Proxy( 
    IDvdControl2 * This,
    /* [in] */ ULONG ulTitle,
    /* [in] */ DVD_HMSF_TIMECODE *pStartTime,
    /* [in] */ DWORD dwFlags,
    /* [out] */ IDvdCmd **ppCmd);


void __RPC_STUB IDvdControl2_PlayAtTimeInTitle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl2_Stop_Proxy( 
    IDvdControl2 * This);


void __RPC_STUB IDvdControl2_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl2_ReturnFromSubmenu_Proxy( 
    IDvdControl2 * This,
    /* [in] */ DWORD dwFlags,
    /* [out] */ IDvdCmd **ppCmd);


void __RPC_STUB IDvdControl2_ReturnFromSubmenu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl2_PlayAtTime_Proxy( 
    IDvdControl2 * This,
    /* [in] */ DVD_HMSF_TIMECODE *pTime,
    /* [in] */ DWORD dwFlags,
    /* [out] */ IDvdCmd **ppCmd);


void __RPC_STUB IDvdControl2_PlayAtTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl2_PlayChapter_Proxy( 
    IDvdControl2 * This,
    /* [in] */ ULONG ulChapter,
    /* [in] */ DWORD dwFlags,
    /* [out] */ IDvdCmd **ppCmd);


void __RPC_STUB IDvdControl2_PlayChapter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl2_PlayPrevChapter_Proxy( 
    IDvdControl2 * This,
    /* [in] */ DWORD dwFlags,
    /* [out] */ IDvdCmd **ppCmd);


void __RPC_STUB IDvdControl2_PlayPrevChapter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl2_ReplayChapter_Proxy( 
    IDvdControl2 * This,
    /* [in] */ DWORD dwFlags,
    /* [out] */ IDvdCmd **ppCmd);


void __RPC_STUB IDvdControl2_ReplayChapter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl2_PlayNextChapter_Proxy( 
    IDvdControl2 * This,
    /* [in] */ DWORD dwFlags,
    /* [out] */ IDvdCmd **ppCmd);


void __RPC_STUB IDvdControl2_PlayNextChapter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl2_PlayForwards_Proxy( 
    IDvdControl2 * This,
    /* [in] */ double dSpeed,
    /* [in] */ DWORD dwFlags,
    /* [out] */ IDvdCmd **ppCmd);


void __RPC_STUB IDvdControl2_PlayForwards_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl2_PlayBackwards_Proxy( 
    IDvdControl2 * This,
    /* [in] */ double dSpeed,
    /* [in] */ DWORD dwFlags,
    /* [out] */ IDvdCmd **ppCmd);


void __RPC_STUB IDvdControl2_PlayBackwards_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl2_ShowMenu_Proxy( 
    IDvdControl2 * This,
    /* [in] */ DVD_MENU_ID MenuID,
    /* [in] */ DWORD dwFlags,
    /* [out] */ IDvdCmd **ppCmd);


void __RPC_STUB IDvdControl2_ShowMenu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl2_Resume_Proxy( 
    IDvdControl2 * This,
    /* [in] */ DWORD dwFlags,
    /* [out] */ IDvdCmd **ppCmd);


void __RPC_STUB IDvdControl2_Resume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl2_SelectRelativeButton_Proxy( 
    IDvdControl2 * This,
    DVD_RELATIVE_BUTTON buttonDir);


void __RPC_STUB IDvdControl2_SelectRelativeButton_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl2_ActivateButton_Proxy( 
    IDvdControl2 * This);


void __RPC_STUB IDvdControl2_ActivateButton_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl2_SelectButton_Proxy( 
    IDvdControl2 * This,
    /* [in] */ ULONG ulButton);


void __RPC_STUB IDvdControl2_SelectButton_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl2_SelectAndActivateButton_Proxy( 
    IDvdControl2 * This,
    /* [in] */ ULONG ulButton);


void __RPC_STUB IDvdControl2_SelectAndActivateButton_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl2_StillOff_Proxy( 
    IDvdControl2 * This);


void __RPC_STUB IDvdControl2_StillOff_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl2_Pause_Proxy( 
    IDvdControl2 * This,
    /* [in] */ BOOL bState);


void __RPC_STUB IDvdControl2_Pause_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl2_SelectAudioStream_Proxy( 
    IDvdControl2 * This,
    /* [in] */ ULONG ulAudio,
    /* [in] */ DWORD dwFlags,
    /* [out] */ IDvdCmd **ppCmd);


void __RPC_STUB IDvdControl2_SelectAudioStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl2_SelectSubpictureStream_Proxy( 
    IDvdControl2 * This,
    /* [in] */ ULONG ulSubPicture,
    /* [in] */ DWORD dwFlags,
    /* [out] */ IDvdCmd **ppCmd);


void __RPC_STUB IDvdControl2_SelectSubpictureStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl2_SetSubpictureState_Proxy( 
    IDvdControl2 * This,
    /* [in] */ BOOL bState,
    /* [in] */ DWORD dwFlags,
    /* [out] */ IDvdCmd **ppCmd);


void __RPC_STUB IDvdControl2_SetSubpictureState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl2_SelectAngle_Proxy( 
    IDvdControl2 * This,
    /* [in] */ ULONG ulAngle,
    /* [in] */ DWORD dwFlags,
    /* [out] */ IDvdCmd **ppCmd);


void __RPC_STUB IDvdControl2_SelectAngle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl2_SelectParentalLevel_Proxy( 
    IDvdControl2 * This,
    /* [in] */ ULONG ulParentalLevel);


void __RPC_STUB IDvdControl2_SelectParentalLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl2_SelectParentalCountry_Proxy( 
    IDvdControl2 * This,
    /* [in] */ BYTE bCountry[ 2 ]);


void __RPC_STUB IDvdControl2_SelectParentalCountry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl2_SelectKaraokeAudioPresentationMode_Proxy( 
    IDvdControl2 * This,
    /* [in] */ ULONG ulMode);


void __RPC_STUB IDvdControl2_SelectKaraokeAudioPresentationMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl2_SelectVideoModePreference_Proxy( 
    IDvdControl2 * This,
    /* [in] */ ULONG ulPreferredDisplayMode);


void __RPC_STUB IDvdControl2_SelectVideoModePreference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl2_SetDVDDirectory_Proxy( 
    IDvdControl2 * This,
    /* [in] */ LPCWSTR pszwPath);


void __RPC_STUB IDvdControl2_SetDVDDirectory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl2_ActivateAtPosition_Proxy( 
    IDvdControl2 * This,
    /* [in] */ POINT point);


void __RPC_STUB IDvdControl2_ActivateAtPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl2_SelectAtPosition_Proxy( 
    IDvdControl2 * This,
    /* [in] */ POINT point);


void __RPC_STUB IDvdControl2_SelectAtPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl2_PlayChaptersAutoStop_Proxy( 
    IDvdControl2 * This,
    /* [in] */ ULONG ulTitle,
    /* [in] */ ULONG ulChapter,
    /* [in] */ ULONG ulChaptersToPlay,
    /* [in] */ DWORD dwFlags,
    /* [out] */ IDvdCmd **ppCmd);


void __RPC_STUB IDvdControl2_PlayChaptersAutoStop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl2_AcceptParentalLevelChange_Proxy( 
    IDvdControl2 * This,
    /* [in] */ BOOL bAccept);


void __RPC_STUB IDvdControl2_AcceptParentalLevelChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl2_SetOption_Proxy( 
    IDvdControl2 * This,
    /* [in] */ DVD_OPTION_FLAG flag,
    /* [in] */ BOOL fState);


void __RPC_STUB IDvdControl2_SetOption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl2_SetState_Proxy( 
    IDvdControl2 * This,
    /* [in] */ IDvdState *pState,
    /* [in] */ DWORD dwFlags,
    /* [out] */ IDvdCmd **ppCmd);


void __RPC_STUB IDvdControl2_SetState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl2_PlayPeriodInTitleAutoStop_Proxy( 
    IDvdControl2 * This,
    /* [in] */ ULONG ulTitle,
    /* [in] */ DVD_HMSF_TIMECODE *pStartTime,
    /* [in] */ DVD_HMSF_TIMECODE *pEndTime,
    /* [in] */ DWORD dwFlags,
    /* [out] */ IDvdCmd **ppCmd);


void __RPC_STUB IDvdControl2_PlayPeriodInTitleAutoStop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl2_SetGPRM_Proxy( 
    IDvdControl2 * This,
    /* [in] */ ULONG ulIndex,
    /* [in] */ WORD wValue,
    /* [in] */ DWORD dwFlags,
    /* [out] */ IDvdCmd **ppCmd);


void __RPC_STUB IDvdControl2_SetGPRM_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl2_SelectDefaultMenuLanguage_Proxy( 
    IDvdControl2 * This,
    /* [in] */ LCID Language);


void __RPC_STUB IDvdControl2_SelectDefaultMenuLanguage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl2_SelectDefaultAudioLanguage_Proxy( 
    IDvdControl2 * This,
    /* [in] */ LCID Language,
    /* [in] */ DVD_AUDIO_LANG_EXT audioExtension);


void __RPC_STUB IDvdControl2_SelectDefaultAudioLanguage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdControl2_SelectDefaultSubpictureLanguage_Proxy( 
    IDvdControl2 * This,
    /* [in] */ LCID Language,
    /* [in] */ DVD_SUBPICTURE_LANG_EXT subpictureExtension);


void __RPC_STUB IDvdControl2_SelectDefaultSubpictureLanguage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDvdControl2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0377 */
/* [local] */ 


enum DVD_TextStringType
    {	DVD_Struct_Volume	= 0x1,
	DVD_Struct_Title	= 0x2,
	DVD_Struct_ParentalID	= 0x3,
	DVD_Struct_PartOfTitle	= 0x4,
	DVD_Struct_Cell	= 0x5,
	DVD_Stream_Audio	= 0x10,
	DVD_Stream_Subpicture	= 0x11,
	DVD_Stream_Angle	= 0x12,
	DVD_Channel_Audio	= 0x20,
	DVD_General_Name	= 0x30,
	DVD_General_Comments	= 0x31,
	DVD_Title_Series	= 0x38,
	DVD_Title_Movie	= 0x39,
	DVD_Title_Video	= 0x3a,
	DVD_Title_Album	= 0x3b,
	DVD_Title_Song	= 0x3c,
	DVD_Title_Other	= 0x3f,
	DVD_Title_Sub_Series	= 0x40,
	DVD_Title_Sub_Movie	= 0x41,
	DVD_Title_Sub_Video	= 0x42,
	DVD_Title_Sub_Album	= 0x43,
	DVD_Title_Sub_Song	= 0x44,
	DVD_Title_Sub_Other	= 0x47,
	DVD_Title_Orig_Series	= 0x48,
	DVD_Title_Orig_Movie	= 0x49,
	DVD_Title_Orig_Video	= 0x4a,
	DVD_Title_Orig_Album	= 0x4b,
	DVD_Title_Orig_Song	= 0x4c,
	DVD_Title_Orig_Other	= 0x4f,
	DVD_Other_Scene	= 0x50,
	DVD_Other_Cut	= 0x51,
	DVD_Other_Take	= 0x52
    } ;

enum DVD_TextCharSet
    {	DVD_CharSet_Unicode	= 0,
	DVD_CharSet_ISO646	= 1,
	DVD_CharSet_JIS_Roman_Kanji	= 2,
	DVD_CharSet_ISO8859_1	= 3,
	DVD_CharSet_ShiftJIS_Kanji_Roman_Katakana	= 4
    } ;
#define DVD_TITLE_MENU				0x000
#define DVD_STREAM_DATA_CURRENT     0x800
#define DVD_STREAM_DATA_VMGM        0x400
#define DVD_STREAM_DATA_VTSM        0x401
#define DVD_DEFAULT_AUDIO_STREAM	0x0f
typedef struct tagDVD_DECODER_CAPS
    {
    DWORD dwSize;
    DWORD dwAudioCaps;
    double dFwdMaxRateVideo;
    double dFwdMaxRateAudio;
    double dFwdMaxRateSP;
    double dBwdMaxRateVideo;
    double dBwdMaxRateAudio;
    double dBwdMaxRateSP;
    DWORD dwRes1;
    DWORD dwRes2;
    DWORD dwRes3;
    DWORD dwRes4;
    } 	DVD_DECODER_CAPS;

#define DVD_AUDIO_CAPS_AC3		0x00000001
#define DVD_AUDIO_CAPS_MPEG2	0x00000002
#define DVD_AUDIO_CAPS_LPCM		0x00000004
#define DVD_AUDIO_CAPS_DTS		0x00000008
#define DVD_AUDIO_CAPS_SDDS		0x00000010


extern RPC_IF_HANDLE __MIDL_itf_strmif_0377_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0377_v0_0_s_ifspec;

#ifndef __IDvdInfo2_INTERFACE_DEFINED__
#define __IDvdInfo2_INTERFACE_DEFINED__

/* interface IDvdInfo2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDvdInfo2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("34151510-EEC0-11D2-8201-00A0C9D74842")
    IDvdInfo2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCurrentDomain( 
            /* [out] */ DVD_DOMAIN *pDomain) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentLocation( 
            /* [out] */ DVD_PLAYBACK_LOCATION2 *pLocation) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTotalTitleTime( 
            /* [out] */ DVD_HMSF_TIMECODE *pTotalTime,
            /* [out] */ ULONG *ulTimeCodeFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentButton( 
            /* [out] */ ULONG *pulButtonsAvailable,
            /* [out] */ ULONG *pulCurrentButton) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentAngle( 
            /* [out] */ ULONG *pulAnglesAvailable,
            /* [out] */ ULONG *pulCurrentAngle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentAudio( 
            /* [out] */ ULONG *pulStreamsAvailable,
            /* [out] */ ULONG *pulCurrentStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentSubpicture( 
            /* [out] */ ULONG *pulStreamsAvailable,
            /* [out] */ ULONG *pulCurrentStream,
            /* [out] */ BOOL *pbIsDisabled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentUOPS( 
            /* [out] */ ULONG *pulUOPs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAllSPRMs( 
            /* [out] */ SPRMARRAY *pRegisterArray) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAllGPRMs( 
            /* [out] */ GPRMARRAY *pRegisterArray) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAudioLanguage( 
            /* [in] */ ULONG ulStream,
            /* [out] */ LCID *pLanguage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSubpictureLanguage( 
            /* [in] */ ULONG ulStream,
            /* [out] */ LCID *pLanguage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTitleAttributes( 
            /* [in] */ ULONG ulTitle,
            /* [out] */ DVD_MenuAttributes *pMenu,
            /* [out] */ DVD_TitleAttributes *pTitle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVMGAttributes( 
            /* [out] */ DVD_MenuAttributes *pATR) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentVideoAttributes( 
            /* [out] */ DVD_VideoAttributes *pATR) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAudioAttributes( 
            /* [in] */ ULONG ulStream,
            /* [out] */ DVD_AudioAttributes *pATR) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetKaraokeAttributes( 
            /* [in] */ ULONG ulStream,
            /* [out] */ DVD_KaraokeAttributes *pAttributes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSubpictureAttributes( 
            /* [in] */ ULONG ulStream,
            /* [out] */ DVD_SubpictureAttributes *pATR) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDVDVolumeInfo( 
            /* [out] */ ULONG *pulNumOfVolumes,
            /* [out] */ ULONG *pulVolume,
            /* [out] */ DVD_DISC_SIDE *pSide,
            /* [out] */ ULONG *pulNumOfTitles) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDVDTextNumberOfLanguages( 
            /* [out] */ ULONG *pulNumOfLangs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDVDTextLanguageInfo( 
            /* [in] */ ULONG ulLangIndex,
            /* [out] */ ULONG *pulNumOfStrings,
            /* [out] */ LCID *pLangCode,
            /* [out] */ enum DVD_TextCharSet *pbCharacterSet) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDVDTextStringAsNative( 
            /* [in] */ ULONG ulLangIndex,
            /* [in] */ ULONG ulStringIndex,
            /* [out] */ BYTE *pbBuffer,
            /* [in] */ ULONG ulMaxBufferSize,
            /* [out] */ ULONG *pulActualSize,
            /* [out] */ enum DVD_TextStringType *pType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDVDTextStringAsUnicode( 
            /* [in] */ ULONG ulLangIndex,
            /* [in] */ ULONG ulStringIndex,
            /* [out] */ WCHAR *pchwBuffer,
            /* [in] */ ULONG ulMaxBufferSize,
            /* [out] */ ULONG *pulActualSize,
            /* [out] */ enum DVD_TextStringType *pType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPlayerParentalLevel( 
            /* [out] */ ULONG *pulParentalLevel,
            /* [out] */ BYTE pbCountryCode[ 2 ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNumberOfChapters( 
            /* [in] */ ULONG ulTitle,
            /* [out] */ ULONG *pulNumOfChapters) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTitleParentalLevels( 
            /* [in] */ ULONG ulTitle,
            /* [out] */ ULONG *pulParentalLevels) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDVDDirectory( 
            /* [size_is][out] */ LPWSTR pszwPath,
            /* [in] */ ULONG ulMaxSize,
            /* [out] */ ULONG *pulActualSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsAudioStreamEnabled( 
            /* [in] */ ULONG ulStreamNum,
            /* [out] */ BOOL *pbEnabled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDiscID( 
            /* [in] */ LPCWSTR pszwPath,
            /* [out] */ ULONGLONG *pullDiscID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetState( 
            /* [out] */ IDvdState **pStateData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMenuLanguages( 
            /* [out] */ LCID *pLanguages,
            /* [in] */ ULONG ulMaxLanguages,
            /* [out] */ ULONG *pulActualLanguages) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetButtonAtPosition( 
            /* [in] */ POINT point,
            /* [out] */ ULONG *pulButtonIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCmdFromEvent( 
            /* [in] */ LONG_PTR lParam1,
            /* [out] */ IDvdCmd **pCmdObj) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultMenuLanguage( 
            /* [out] */ LCID *pLanguage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultAudioLanguage( 
            /* [out] */ LCID *pLanguage,
            /* [out] */ DVD_AUDIO_LANG_EXT *pAudioExtension) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultSubpictureLanguage( 
            /* [out] */ LCID *pLanguage,
            /* [out] */ DVD_SUBPICTURE_LANG_EXT *pSubpictureExtension) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDecoderCaps( 
            /* [out] */ DVD_DECODER_CAPS *pCaps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetButtonRect( 
            /* [in] */ ULONG ulButton,
            /* [out] */ RECT *pRect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsSubpictureStreamEnabled( 
            /* [in] */ ULONG ulStreamNum,
            /* [out] */ BOOL *pbEnabled) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDvdInfo2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDvdInfo2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDvdInfo2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDvdInfo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentDomain )( 
            IDvdInfo2 * This,
            /* [out] */ DVD_DOMAIN *pDomain);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentLocation )( 
            IDvdInfo2 * This,
            /* [out] */ DVD_PLAYBACK_LOCATION2 *pLocation);
        
        HRESULT ( STDMETHODCALLTYPE *GetTotalTitleTime )( 
            IDvdInfo2 * This,
            /* [out] */ DVD_HMSF_TIMECODE *pTotalTime,
            /* [out] */ ULONG *ulTimeCodeFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentButton )( 
            IDvdInfo2 * This,
            /* [out] */ ULONG *pulButtonsAvailable,
            /* [out] */ ULONG *pulCurrentButton);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentAngle )( 
            IDvdInfo2 * This,
            /* [out] */ ULONG *pulAnglesAvailable,
            /* [out] */ ULONG *pulCurrentAngle);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentAudio )( 
            IDvdInfo2 * This,
            /* [out] */ ULONG *pulStreamsAvailable,
            /* [out] */ ULONG *pulCurrentStream);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentSubpicture )( 
            IDvdInfo2 * This,
            /* [out] */ ULONG *pulStreamsAvailable,
            /* [out] */ ULONG *pulCurrentStream,
            /* [out] */ BOOL *pbIsDisabled);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentUOPS )( 
            IDvdInfo2 * This,
            /* [out] */ ULONG *pulUOPs);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllSPRMs )( 
            IDvdInfo2 * This,
            /* [out] */ SPRMARRAY *pRegisterArray);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllGPRMs )( 
            IDvdInfo2 * This,
            /* [out] */ GPRMARRAY *pRegisterArray);
        
        HRESULT ( STDMETHODCALLTYPE *GetAudioLanguage )( 
            IDvdInfo2 * This,
            /* [in] */ ULONG ulStream,
            /* [out] */ LCID *pLanguage);
        
        HRESULT ( STDMETHODCALLTYPE *GetSubpictureLanguage )( 
            IDvdInfo2 * This,
            /* [in] */ ULONG ulStream,
            /* [out] */ LCID *pLanguage);
        
        HRESULT ( STDMETHODCALLTYPE *GetTitleAttributes )( 
            IDvdInfo2 * This,
            /* [in] */ ULONG ulTitle,
            /* [out] */ DVD_MenuAttributes *pMenu,
            /* [out] */ DVD_TitleAttributes *pTitle);
        
        HRESULT ( STDMETHODCALLTYPE *GetVMGAttributes )( 
            IDvdInfo2 * This,
            /* [out] */ DVD_MenuAttributes *pATR);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentVideoAttributes )( 
            IDvdInfo2 * This,
            /* [out] */ DVD_VideoAttributes *pATR);
        
        HRESULT ( STDMETHODCALLTYPE *GetAudioAttributes )( 
            IDvdInfo2 * This,
            /* [in] */ ULONG ulStream,
            /* [out] */ DVD_AudioAttributes *pATR);
        
        HRESULT ( STDMETHODCALLTYPE *GetKaraokeAttributes )( 
            IDvdInfo2 * This,
            /* [in] */ ULONG ulStream,
            /* [out] */ DVD_KaraokeAttributes *pAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *GetSubpictureAttributes )( 
            IDvdInfo2 * This,
            /* [in] */ ULONG ulStream,
            /* [out] */ DVD_SubpictureAttributes *pATR);
        
        HRESULT ( STDMETHODCALLTYPE *GetDVDVolumeInfo )( 
            IDvdInfo2 * This,
            /* [out] */ ULONG *pulNumOfVolumes,
            /* [out] */ ULONG *pulVolume,
            /* [out] */ DVD_DISC_SIDE *pSide,
            /* [out] */ ULONG *pulNumOfTitles);
        
        HRESULT ( STDMETHODCALLTYPE *GetDVDTextNumberOfLanguages )( 
            IDvdInfo2 * This,
            /* [out] */ ULONG *pulNumOfLangs);
        
        HRESULT ( STDMETHODCALLTYPE *GetDVDTextLanguageInfo )( 
            IDvdInfo2 * This,
            /* [in] */ ULONG ulLangIndex,
            /* [out] */ ULONG *pulNumOfStrings,
            /* [out] */ LCID *pLangCode,
            /* [out] */ enum DVD_TextCharSet *pbCharacterSet);
        
        HRESULT ( STDMETHODCALLTYPE *GetDVDTextStringAsNative )( 
            IDvdInfo2 * This,
            /* [in] */ ULONG ulLangIndex,
            /* [in] */ ULONG ulStringIndex,
            /* [out] */ BYTE *pbBuffer,
            /* [in] */ ULONG ulMaxBufferSize,
            /* [out] */ ULONG *pulActualSize,
            /* [out] */ enum DVD_TextStringType *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetDVDTextStringAsUnicode )( 
            IDvdInfo2 * This,
            /* [in] */ ULONG ulLangIndex,
            /* [in] */ ULONG ulStringIndex,
            /* [out] */ WCHAR *pchwBuffer,
            /* [in] */ ULONG ulMaxBufferSize,
            /* [out] */ ULONG *pulActualSize,
            /* [out] */ enum DVD_TextStringType *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetPlayerParentalLevel )( 
            IDvdInfo2 * This,
            /* [out] */ ULONG *pulParentalLevel,
            /* [out] */ BYTE pbCountryCode[ 2 ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetNumberOfChapters )( 
            IDvdInfo2 * This,
            /* [in] */ ULONG ulTitle,
            /* [out] */ ULONG *pulNumOfChapters);
        
        HRESULT ( STDMETHODCALLTYPE *GetTitleParentalLevels )( 
            IDvdInfo2 * This,
            /* [in] */ ULONG ulTitle,
            /* [out] */ ULONG *pulParentalLevels);
        
        HRESULT ( STDMETHODCALLTYPE *GetDVDDirectory )( 
            IDvdInfo2 * This,
            /* [size_is][out] */ LPWSTR pszwPath,
            /* [in] */ ULONG ulMaxSize,
            /* [out] */ ULONG *pulActualSize);
        
        HRESULT ( STDMETHODCALLTYPE *IsAudioStreamEnabled )( 
            IDvdInfo2 * This,
            /* [in] */ ULONG ulStreamNum,
            /* [out] */ BOOL *pbEnabled);
        
        HRESULT ( STDMETHODCALLTYPE *GetDiscID )( 
            IDvdInfo2 * This,
            /* [in] */ LPCWSTR pszwPath,
            /* [out] */ ULONGLONG *pullDiscID);
        
        HRESULT ( STDMETHODCALLTYPE *GetState )( 
            IDvdInfo2 * This,
            /* [out] */ IDvdState **pStateData);
        
        HRESULT ( STDMETHODCALLTYPE *GetMenuLanguages )( 
            IDvdInfo2 * This,
            /* [out] */ LCID *pLanguages,
            /* [in] */ ULONG ulMaxLanguages,
            /* [out] */ ULONG *pulActualLanguages);
        
        HRESULT ( STDMETHODCALLTYPE *GetButtonAtPosition )( 
            IDvdInfo2 * This,
            /* [in] */ POINT point,
            /* [out] */ ULONG *pulButtonIndex);
        
        HRESULT ( STDMETHODCALLTYPE *GetCmdFromEvent )( 
            IDvdInfo2 * This,
            /* [in] */ LONG_PTR lParam1,
            /* [out] */ IDvdCmd **pCmdObj);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultMenuLanguage )( 
            IDvdInfo2 * This,
            /* [out] */ LCID *pLanguage);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultAudioLanguage )( 
            IDvdInfo2 * This,
            /* [out] */ LCID *pLanguage,
            /* [out] */ DVD_AUDIO_LANG_EXT *pAudioExtension);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultSubpictureLanguage )( 
            IDvdInfo2 * This,
            /* [out] */ LCID *pLanguage,
            /* [out] */ DVD_SUBPICTURE_LANG_EXT *pSubpictureExtension);
        
        HRESULT ( STDMETHODCALLTYPE *GetDecoderCaps )( 
            IDvdInfo2 * This,
            /* [out] */ DVD_DECODER_CAPS *pCaps);
        
        HRESULT ( STDMETHODCALLTYPE *GetButtonRect )( 
            IDvdInfo2 * This,
            /* [in] */ ULONG ulButton,
            /* [out] */ RECT *pRect);
        
        HRESULT ( STDMETHODCALLTYPE *IsSubpictureStreamEnabled )( 
            IDvdInfo2 * This,
            /* [in] */ ULONG ulStreamNum,
            /* [out] */ BOOL *pbEnabled);
        
        END_INTERFACE
    } IDvdInfo2Vtbl;

    interface IDvdInfo2
    {
        CONST_VTBL struct IDvdInfo2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDvdInfo2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDvdInfo2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDvdInfo2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDvdInfo2_GetCurrentDomain(This,pDomain)	\
    (This)->lpVtbl -> GetCurrentDomain(This,pDomain)

#define IDvdInfo2_GetCurrentLocation(This,pLocation)	\
    (This)->lpVtbl -> GetCurrentLocation(This,pLocation)

#define IDvdInfo2_GetTotalTitleTime(This,pTotalTime,ulTimeCodeFlags)	\
    (This)->lpVtbl -> GetTotalTitleTime(This,pTotalTime,ulTimeCodeFlags)

#define IDvdInfo2_GetCurrentButton(This,pulButtonsAvailable,pulCurrentButton)	\
    (This)->lpVtbl -> GetCurrentButton(This,pulButtonsAvailable,pulCurrentButton)

#define IDvdInfo2_GetCurrentAngle(This,pulAnglesAvailable,pulCurrentAngle)	\
    (This)->lpVtbl -> GetCurrentAngle(This,pulAnglesAvailable,pulCurrentAngle)

#define IDvdInfo2_GetCurrentAudio(This,pulStreamsAvailable,pulCurrentStream)	\
    (This)->lpVtbl -> GetCurrentAudio(This,pulStreamsAvailable,pulCurrentStream)

#define IDvdInfo2_GetCurrentSubpicture(This,pulStreamsAvailable,pulCurrentStream,pbIsDisabled)	\
    (This)->lpVtbl -> GetCurrentSubpicture(This,pulStreamsAvailable,pulCurrentStream,pbIsDisabled)

#define IDvdInfo2_GetCurrentUOPS(This,pulUOPs)	\
    (This)->lpVtbl -> GetCurrentUOPS(This,pulUOPs)

#define IDvdInfo2_GetAllSPRMs(This,pRegisterArray)	\
    (This)->lpVtbl -> GetAllSPRMs(This,pRegisterArray)

#define IDvdInfo2_GetAllGPRMs(This,pRegisterArray)	\
    (This)->lpVtbl -> GetAllGPRMs(This,pRegisterArray)

#define IDvdInfo2_GetAudioLanguage(This,ulStream,pLanguage)	\
    (This)->lpVtbl -> GetAudioLanguage(This,ulStream,pLanguage)

#define IDvdInfo2_GetSubpictureLanguage(This,ulStream,pLanguage)	\
    (This)->lpVtbl -> GetSubpictureLanguage(This,ulStream,pLanguage)

#define IDvdInfo2_GetTitleAttributes(This,ulTitle,pMenu,pTitle)	\
    (This)->lpVtbl -> GetTitleAttributes(This,ulTitle,pMenu,pTitle)

#define IDvdInfo2_GetVMGAttributes(This,pATR)	\
    (This)->lpVtbl -> GetVMGAttributes(This,pATR)

#define IDvdInfo2_GetCurrentVideoAttributes(This,pATR)	\
    (This)->lpVtbl -> GetCurrentVideoAttributes(This,pATR)

#define IDvdInfo2_GetAudioAttributes(This,ulStream,pATR)	\
    (This)->lpVtbl -> GetAudioAttributes(This,ulStream,pATR)

#define IDvdInfo2_GetKaraokeAttributes(This,ulStream,pAttributes)	\
    (This)->lpVtbl -> GetKaraokeAttributes(This,ulStream,pAttributes)

#define IDvdInfo2_GetSubpictureAttributes(This,ulStream,pATR)	\
    (This)->lpVtbl -> GetSubpictureAttributes(This,ulStream,pATR)

#define IDvdInfo2_GetDVDVolumeInfo(This,pulNumOfVolumes,pulVolume,pSide,pulNumOfTitles)	\
    (This)->lpVtbl -> GetDVDVolumeInfo(This,pulNumOfVolumes,pulVolume,pSide,pulNumOfTitles)

#define IDvdInfo2_GetDVDTextNumberOfLanguages(This,pulNumOfLangs)	\
    (This)->lpVtbl -> GetDVDTextNumberOfLanguages(This,pulNumOfLangs)

#define IDvdInfo2_GetDVDTextLanguageInfo(This,ulLangIndex,pulNumOfStrings,pLangCode,pbCharacterSet)	\
    (This)->lpVtbl -> GetDVDTextLanguageInfo(This,ulLangIndex,pulNumOfStrings,pLangCode,pbCharacterSet)

#define IDvdInfo2_GetDVDTextStringAsNative(This,ulLangIndex,ulStringIndex,pbBuffer,ulMaxBufferSize,pulActualSize,pType)	\
    (This)->lpVtbl -> GetDVDTextStringAsNative(This,ulLangIndex,ulStringIndex,pbBuffer,ulMaxBufferSize,pulActualSize,pType)

#define IDvdInfo2_GetDVDTextStringAsUnicode(This,ulLangIndex,ulStringIndex,pchwBuffer,ulMaxBufferSize,pulActualSize,pType)	\
    (This)->lpVtbl -> GetDVDTextStringAsUnicode(This,ulLangIndex,ulStringIndex,pchwBuffer,ulMaxBufferSize,pulActualSize,pType)

#define IDvdInfo2_GetPlayerParentalLevel(This,pulParentalLevel,pbCountryCode)	\
    (This)->lpVtbl -> GetPlayerParentalLevel(This,pulParentalLevel,pbCountryCode)

#define IDvdInfo2_GetNumberOfChapters(This,ulTitle,pulNumOfChapters)	\
    (This)->lpVtbl -> GetNumberOfChapters(This,ulTitle,pulNumOfChapters)

#define IDvdInfo2_GetTitleParentalLevels(This,ulTitle,pulParentalLevels)	\
    (This)->lpVtbl -> GetTitleParentalLevels(This,ulTitle,pulParentalLevels)

#define IDvdInfo2_GetDVDDirectory(This,pszwPath,ulMaxSize,pulActualSize)	\
    (This)->lpVtbl -> GetDVDDirectory(This,pszwPath,ulMaxSize,pulActualSize)

#define IDvdInfo2_IsAudioStreamEnabled(This,ulStreamNum,pbEnabled)	\
    (This)->lpVtbl -> IsAudioStreamEnabled(This,ulStreamNum,pbEnabled)

#define IDvdInfo2_GetDiscID(This,pszwPath,pullDiscID)	\
    (This)->lpVtbl -> GetDiscID(This,pszwPath,pullDiscID)

#define IDvdInfo2_GetState(This,pStateData)	\
    (This)->lpVtbl -> GetState(This,pStateData)

#define IDvdInfo2_GetMenuLanguages(This,pLanguages,ulMaxLanguages,pulActualLanguages)	\
    (This)->lpVtbl -> GetMenuLanguages(This,pLanguages,ulMaxLanguages,pulActualLanguages)

#define IDvdInfo2_GetButtonAtPosition(This,point,pulButtonIndex)	\
    (This)->lpVtbl -> GetButtonAtPosition(This,point,pulButtonIndex)

#define IDvdInfo2_GetCmdFromEvent(This,lParam1,pCmdObj)	\
    (This)->lpVtbl -> GetCmdFromEvent(This,lParam1,pCmdObj)

#define IDvdInfo2_GetDefaultMenuLanguage(This,pLanguage)	\
    (This)->lpVtbl -> GetDefaultMenuLanguage(This,pLanguage)

#define IDvdInfo2_GetDefaultAudioLanguage(This,pLanguage,pAudioExtension)	\
    (This)->lpVtbl -> GetDefaultAudioLanguage(This,pLanguage,pAudioExtension)

#define IDvdInfo2_GetDefaultSubpictureLanguage(This,pLanguage,pSubpictureExtension)	\
    (This)->lpVtbl -> GetDefaultSubpictureLanguage(This,pLanguage,pSubpictureExtension)

#define IDvdInfo2_GetDecoderCaps(This,pCaps)	\
    (This)->lpVtbl -> GetDecoderCaps(This,pCaps)

#define IDvdInfo2_GetButtonRect(This,ulButton,pRect)	\
    (This)->lpVtbl -> GetButtonRect(This,ulButton,pRect)

#define IDvdInfo2_IsSubpictureStreamEnabled(This,ulStreamNum,pbEnabled)	\
    (This)->lpVtbl -> IsSubpictureStreamEnabled(This,ulStreamNum,pbEnabled)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDvdInfo2_GetCurrentDomain_Proxy( 
    IDvdInfo2 * This,
    /* [out] */ DVD_DOMAIN *pDomain);


void __RPC_STUB IDvdInfo2_GetCurrentDomain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo2_GetCurrentLocation_Proxy( 
    IDvdInfo2 * This,
    /* [out] */ DVD_PLAYBACK_LOCATION2 *pLocation);


void __RPC_STUB IDvdInfo2_GetCurrentLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo2_GetTotalTitleTime_Proxy( 
    IDvdInfo2 * This,
    /* [out] */ DVD_HMSF_TIMECODE *pTotalTime,
    /* [out] */ ULONG *ulTimeCodeFlags);


void __RPC_STUB IDvdInfo2_GetTotalTitleTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo2_GetCurrentButton_Proxy( 
    IDvdInfo2 * This,
    /* [out] */ ULONG *pulButtonsAvailable,
    /* [out] */ ULONG *pulCurrentButton);


void __RPC_STUB IDvdInfo2_GetCurrentButton_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo2_GetCurrentAngle_Proxy( 
    IDvdInfo2 * This,
    /* [out] */ ULONG *pulAnglesAvailable,
    /* [out] */ ULONG *pulCurrentAngle);


void __RPC_STUB IDvdInfo2_GetCurrentAngle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo2_GetCurrentAudio_Proxy( 
    IDvdInfo2 * This,
    /* [out] */ ULONG *pulStreamsAvailable,
    /* [out] */ ULONG *pulCurrentStream);


void __RPC_STUB IDvdInfo2_GetCurrentAudio_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo2_GetCurrentSubpicture_Proxy( 
    IDvdInfo2 * This,
    /* [out] */ ULONG *pulStreamsAvailable,
    /* [out] */ ULONG *pulCurrentStream,
    /* [out] */ BOOL *pbIsDisabled);


void __RPC_STUB IDvdInfo2_GetCurrentSubpicture_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo2_GetCurrentUOPS_Proxy( 
    IDvdInfo2 * This,
    /* [out] */ ULONG *pulUOPs);


void __RPC_STUB IDvdInfo2_GetCurrentUOPS_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo2_GetAllSPRMs_Proxy( 
    IDvdInfo2 * This,
    /* [out] */ SPRMARRAY *pRegisterArray);


void __RPC_STUB IDvdInfo2_GetAllSPRMs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo2_GetAllGPRMs_Proxy( 
    IDvdInfo2 * This,
    /* [out] */ GPRMARRAY *pRegisterArray);


void __RPC_STUB IDvdInfo2_GetAllGPRMs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo2_GetAudioLanguage_Proxy( 
    IDvdInfo2 * This,
    /* [in] */ ULONG ulStream,
    /* [out] */ LCID *pLanguage);


void __RPC_STUB IDvdInfo2_GetAudioLanguage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo2_GetSubpictureLanguage_Proxy( 
    IDvdInfo2 * This,
    /* [in] */ ULONG ulStream,
    /* [out] */ LCID *pLanguage);


void __RPC_STUB IDvdInfo2_GetSubpictureLanguage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo2_GetTitleAttributes_Proxy( 
    IDvdInfo2 * This,
    /* [in] */ ULONG ulTitle,
    /* [out] */ DVD_MenuAttributes *pMenu,
    /* [out] */ DVD_TitleAttributes *pTitle);


void __RPC_STUB IDvdInfo2_GetTitleAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo2_GetVMGAttributes_Proxy( 
    IDvdInfo2 * This,
    /* [out] */ DVD_MenuAttributes *pATR);


void __RPC_STUB IDvdInfo2_GetVMGAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo2_GetCurrentVideoAttributes_Proxy( 
    IDvdInfo2 * This,
    /* [out] */ DVD_VideoAttributes *pATR);


void __RPC_STUB IDvdInfo2_GetCurrentVideoAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo2_GetAudioAttributes_Proxy( 
    IDvdInfo2 * This,
    /* [in] */ ULONG ulStream,
    /* [out] */ DVD_AudioAttributes *pATR);


void __RPC_STUB IDvdInfo2_GetAudioAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo2_GetKaraokeAttributes_Proxy( 
    IDvdInfo2 * This,
    /* [in] */ ULONG ulStream,
    /* [out] */ DVD_KaraokeAttributes *pAttributes);


void __RPC_STUB IDvdInfo2_GetKaraokeAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo2_GetSubpictureAttributes_Proxy( 
    IDvdInfo2 * This,
    /* [in] */ ULONG ulStream,
    /* [out] */ DVD_SubpictureAttributes *pATR);


void __RPC_STUB IDvdInfo2_GetSubpictureAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo2_GetDVDVolumeInfo_Proxy( 
    IDvdInfo2 * This,
    /* [out] */ ULONG *pulNumOfVolumes,
    /* [out] */ ULONG *pulVolume,
    /* [out] */ DVD_DISC_SIDE *pSide,
    /* [out] */ ULONG *pulNumOfTitles);


void __RPC_STUB IDvdInfo2_GetDVDVolumeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo2_GetDVDTextNumberOfLanguages_Proxy( 
    IDvdInfo2 * This,
    /* [out] */ ULONG *pulNumOfLangs);


void __RPC_STUB IDvdInfo2_GetDVDTextNumberOfLanguages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo2_GetDVDTextLanguageInfo_Proxy( 
    IDvdInfo2 * This,
    /* [in] */ ULONG ulLangIndex,
    /* [out] */ ULONG *pulNumOfStrings,
    /* [out] */ LCID *pLangCode,
    /* [out] */ enum DVD_TextCharSet *pbCharacterSet);


void __RPC_STUB IDvdInfo2_GetDVDTextLanguageInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo2_GetDVDTextStringAsNative_Proxy( 
    IDvdInfo2 * This,
    /* [in] */ ULONG ulLangIndex,
    /* [in] */ ULONG ulStringIndex,
    /* [out] */ BYTE *pbBuffer,
    /* [in] */ ULONG ulMaxBufferSize,
    /* [out] */ ULONG *pulActualSize,
    /* [out] */ enum DVD_TextStringType *pType);


void __RPC_STUB IDvdInfo2_GetDVDTextStringAsNative_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo2_GetDVDTextStringAsUnicode_Proxy( 
    IDvdInfo2 * This,
    /* [in] */ ULONG ulLangIndex,
    /* [in] */ ULONG ulStringIndex,
    /* [out] */ WCHAR *pchwBuffer,
    /* [in] */ ULONG ulMaxBufferSize,
    /* [out] */ ULONG *pulActualSize,
    /* [out] */ enum DVD_TextStringType *pType);


void __RPC_STUB IDvdInfo2_GetDVDTextStringAsUnicode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo2_GetPlayerParentalLevel_Proxy( 
    IDvdInfo2 * This,
    /* [out] */ ULONG *pulParentalLevel,
    /* [out] */ BYTE pbCountryCode[ 2 ]);


void __RPC_STUB IDvdInfo2_GetPlayerParentalLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo2_GetNumberOfChapters_Proxy( 
    IDvdInfo2 * This,
    /* [in] */ ULONG ulTitle,
    /* [out] */ ULONG *pulNumOfChapters);


void __RPC_STUB IDvdInfo2_GetNumberOfChapters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo2_GetTitleParentalLevels_Proxy( 
    IDvdInfo2 * This,
    /* [in] */ ULONG ulTitle,
    /* [out] */ ULONG *pulParentalLevels);


void __RPC_STUB IDvdInfo2_GetTitleParentalLevels_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo2_GetDVDDirectory_Proxy( 
    IDvdInfo2 * This,
    /* [size_is][out] */ LPWSTR pszwPath,
    /* [in] */ ULONG ulMaxSize,
    /* [out] */ ULONG *pulActualSize);


void __RPC_STUB IDvdInfo2_GetDVDDirectory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo2_IsAudioStreamEnabled_Proxy( 
    IDvdInfo2 * This,
    /* [in] */ ULONG ulStreamNum,
    /* [out] */ BOOL *pbEnabled);


void __RPC_STUB IDvdInfo2_IsAudioStreamEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo2_GetDiscID_Proxy( 
    IDvdInfo2 * This,
    /* [in] */ LPCWSTR pszwPath,
    /* [out] */ ULONGLONG *pullDiscID);


void __RPC_STUB IDvdInfo2_GetDiscID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo2_GetState_Proxy( 
    IDvdInfo2 * This,
    /* [out] */ IDvdState **pStateData);


void __RPC_STUB IDvdInfo2_GetState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo2_GetMenuLanguages_Proxy( 
    IDvdInfo2 * This,
    /* [out] */ LCID *pLanguages,
    /* [in] */ ULONG ulMaxLanguages,
    /* [out] */ ULONG *pulActualLanguages);


void __RPC_STUB IDvdInfo2_GetMenuLanguages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo2_GetButtonAtPosition_Proxy( 
    IDvdInfo2 * This,
    /* [in] */ POINT point,
    /* [out] */ ULONG *pulButtonIndex);


void __RPC_STUB IDvdInfo2_GetButtonAtPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo2_GetCmdFromEvent_Proxy( 
    IDvdInfo2 * This,
    /* [in] */ LONG_PTR lParam1,
    /* [out] */ IDvdCmd **pCmdObj);


void __RPC_STUB IDvdInfo2_GetCmdFromEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo2_GetDefaultMenuLanguage_Proxy( 
    IDvdInfo2 * This,
    /* [out] */ LCID *pLanguage);


void __RPC_STUB IDvdInfo2_GetDefaultMenuLanguage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo2_GetDefaultAudioLanguage_Proxy( 
    IDvdInfo2 * This,
    /* [out] */ LCID *pLanguage,
    /* [out] */ DVD_AUDIO_LANG_EXT *pAudioExtension);


void __RPC_STUB IDvdInfo2_GetDefaultAudioLanguage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo2_GetDefaultSubpictureLanguage_Proxy( 
    IDvdInfo2 * This,
    /* [out] */ LCID *pLanguage,
    /* [out] */ DVD_SUBPICTURE_LANG_EXT *pSubpictureExtension);


void __RPC_STUB IDvdInfo2_GetDefaultSubpictureLanguage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo2_GetDecoderCaps_Proxy( 
    IDvdInfo2 * This,
    /* [out] */ DVD_DECODER_CAPS *pCaps);


void __RPC_STUB IDvdInfo2_GetDecoderCaps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo2_GetButtonRect_Proxy( 
    IDvdInfo2 * This,
    /* [in] */ ULONG ulButton,
    /* [out] */ RECT *pRect);


void __RPC_STUB IDvdInfo2_GetButtonRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdInfo2_IsSubpictureStreamEnabled_Proxy( 
    IDvdInfo2 * This,
    /* [in] */ ULONG ulStreamNum,
    /* [out] */ BOOL *pbEnabled);


void __RPC_STUB IDvdInfo2_IsSubpictureStreamEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDvdInfo2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0379 */
/* [local] */ 

typedef 
enum _AM_DVD_GRAPH_FLAGS
    {	AM_DVD_HWDEC_PREFER	= 0x1,
	AM_DVD_HWDEC_ONLY	= 0x2,
	AM_DVD_SWDEC_PREFER	= 0x4,
	AM_DVD_SWDEC_ONLY	= 0x8,
	AM_DVD_NOVPE	= 0x100,
	AM_DVD_VMR9_ONLY	= 0x800
    } 	AM_DVD_GRAPH_FLAGS;

typedef 
enum _AM_DVD_STREAM_FLAGS
    {	AM_DVD_STREAM_VIDEO	= 0x1,
	AM_DVD_STREAM_AUDIO	= 0x2,
	AM_DVD_STREAM_SUBPIC	= 0x4
    } 	AM_DVD_STREAM_FLAGS;

typedef /* [public][public] */ struct __MIDL___MIDL_itf_strmif_0379_0001
    {
    HRESULT hrVPEStatus;
    BOOL bDvdVolInvalid;
    BOOL bDvdVolUnknown;
    BOOL bNoLine21In;
    BOOL bNoLine21Out;
    int iNumStreams;
    int iNumStreamsFailed;
    DWORD dwFailedStreamsFlag;
    } 	AM_DVD_RENDERSTATUS;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0379_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0379_v0_0_s_ifspec;

#ifndef __IDvdGraphBuilder_INTERFACE_DEFINED__
#define __IDvdGraphBuilder_INTERFACE_DEFINED__

/* interface IDvdGraphBuilder */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IDvdGraphBuilder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FCC152B6-F372-11d0-8E00-00C04FD7C08B")
    IDvdGraphBuilder : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFiltergraph( 
            /* [out] */ IGraphBuilder **ppGB) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDvdInterface( 
            /* [in] */ REFIID riid,
            /* [out] */ void **ppvIF) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RenderDvdVideoVolume( 
            /* [in] */ LPCWSTR lpcwszPathName,
            /* [in] */ DWORD dwFlags,
            /* [out] */ AM_DVD_RENDERSTATUS *pStatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDvdGraphBuilderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDvdGraphBuilder * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDvdGraphBuilder * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDvdGraphBuilder * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetFiltergraph )( 
            IDvdGraphBuilder * This,
            /* [out] */ IGraphBuilder **ppGB);
        
        HRESULT ( STDMETHODCALLTYPE *GetDvdInterface )( 
            IDvdGraphBuilder * This,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppvIF);
        
        HRESULT ( STDMETHODCALLTYPE *RenderDvdVideoVolume )( 
            IDvdGraphBuilder * This,
            /* [in] */ LPCWSTR lpcwszPathName,
            /* [in] */ DWORD dwFlags,
            /* [out] */ AM_DVD_RENDERSTATUS *pStatus);
        
        END_INTERFACE
    } IDvdGraphBuilderVtbl;

    interface IDvdGraphBuilder
    {
        CONST_VTBL struct IDvdGraphBuilderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDvdGraphBuilder_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDvdGraphBuilder_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDvdGraphBuilder_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDvdGraphBuilder_GetFiltergraph(This,ppGB)	\
    (This)->lpVtbl -> GetFiltergraph(This,ppGB)

#define IDvdGraphBuilder_GetDvdInterface(This,riid,ppvIF)	\
    (This)->lpVtbl -> GetDvdInterface(This,riid,ppvIF)

#define IDvdGraphBuilder_RenderDvdVideoVolume(This,lpcwszPathName,dwFlags,pStatus)	\
    (This)->lpVtbl -> RenderDvdVideoVolume(This,lpcwszPathName,dwFlags,pStatus)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDvdGraphBuilder_GetFiltergraph_Proxy( 
    IDvdGraphBuilder * This,
    /* [out] */ IGraphBuilder **ppGB);


void __RPC_STUB IDvdGraphBuilder_GetFiltergraph_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdGraphBuilder_GetDvdInterface_Proxy( 
    IDvdGraphBuilder * This,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppvIF);


void __RPC_STUB IDvdGraphBuilder_GetDvdInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDvdGraphBuilder_RenderDvdVideoVolume_Proxy( 
    IDvdGraphBuilder * This,
    /* [in] */ LPCWSTR lpcwszPathName,
    /* [in] */ DWORD dwFlags,
    /* [out] */ AM_DVD_RENDERSTATUS *pStatus);


void __RPC_STUB IDvdGraphBuilder_RenderDvdVideoVolume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDvdGraphBuilder_INTERFACE_DEFINED__ */


#ifndef __IDDrawExclModeVideo_INTERFACE_DEFINED__
#define __IDDrawExclModeVideo_INTERFACE_DEFINED__

/* interface IDDrawExclModeVideo */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IDDrawExclModeVideo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("153ACC21-D83B-11d1-82BF-00A0C9696C8F")
    IDDrawExclModeVideo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetDDrawObject( 
            /* [in] */ IDirectDraw *pDDrawObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDDrawObject( 
            /* [out] */ IDirectDraw **ppDDrawObject,
            /* [out] */ BOOL *pbUsingExternal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDDrawSurface( 
            /* [in] */ IDirectDrawSurface *pDDrawSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDDrawSurface( 
            /* [out] */ IDirectDrawSurface **ppDDrawSurface,
            /* [out] */ BOOL *pbUsingExternal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDrawParameters( 
            /* [in] */ const RECT *prcSource,
            /* [in] */ const RECT *prcTarget) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNativeVideoProps( 
            /* [out] */ DWORD *pdwVideoWidth,
            /* [out] */ DWORD *pdwVideoHeight,
            /* [out] */ DWORD *pdwPictAspectRatioX,
            /* [out] */ DWORD *pdwPictAspectRatioY) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCallbackInterface( 
            /* [in] */ IDDrawExclModeVideoCallback *pCallback,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDDrawExclModeVideoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDDrawExclModeVideo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDDrawExclModeVideo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDDrawExclModeVideo * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetDDrawObject )( 
            IDDrawExclModeVideo * This,
            /* [in] */ IDirectDraw *pDDrawObject);
        
        HRESULT ( STDMETHODCALLTYPE *GetDDrawObject )( 
            IDDrawExclModeVideo * This,
            /* [out] */ IDirectDraw **ppDDrawObject,
            /* [out] */ BOOL *pbUsingExternal);
        
        HRESULT ( STDMETHODCALLTYPE *SetDDrawSurface )( 
            IDDrawExclModeVideo * This,
            /* [in] */ IDirectDrawSurface *pDDrawSurface);
        
        HRESULT ( STDMETHODCALLTYPE *GetDDrawSurface )( 
            IDDrawExclModeVideo * This,
            /* [out] */ IDirectDrawSurface **ppDDrawSurface,
            /* [out] */ BOOL *pbUsingExternal);
        
        HRESULT ( STDMETHODCALLTYPE *SetDrawParameters )( 
            IDDrawExclModeVideo * This,
            /* [in] */ const RECT *prcSource,
            /* [in] */ const RECT *prcTarget);
        
        HRESULT ( STDMETHODCALLTYPE *GetNativeVideoProps )( 
            IDDrawExclModeVideo * This,
            /* [out] */ DWORD *pdwVideoWidth,
            /* [out] */ DWORD *pdwVideoHeight,
            /* [out] */ DWORD *pdwPictAspectRatioX,
            /* [out] */ DWORD *pdwPictAspectRatioY);
        
        HRESULT ( STDMETHODCALLTYPE *SetCallbackInterface )( 
            IDDrawExclModeVideo * This,
            /* [in] */ IDDrawExclModeVideoCallback *pCallback,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IDDrawExclModeVideoVtbl;

    interface IDDrawExclModeVideo
    {
        CONST_VTBL struct IDDrawExclModeVideoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDDrawExclModeVideo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDDrawExclModeVideo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDDrawExclModeVideo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDDrawExclModeVideo_SetDDrawObject(This,pDDrawObject)	\
    (This)->lpVtbl -> SetDDrawObject(This,pDDrawObject)

#define IDDrawExclModeVideo_GetDDrawObject(This,ppDDrawObject,pbUsingExternal)	\
    (This)->lpVtbl -> GetDDrawObject(This,ppDDrawObject,pbUsingExternal)

#define IDDrawExclModeVideo_SetDDrawSurface(This,pDDrawSurface)	\
    (This)->lpVtbl -> SetDDrawSurface(This,pDDrawSurface)

#define IDDrawExclModeVideo_GetDDrawSurface(This,ppDDrawSurface,pbUsingExternal)	\
    (This)->lpVtbl -> GetDDrawSurface(This,ppDDrawSurface,pbUsingExternal)

#define IDDrawExclModeVideo_SetDrawParameters(This,prcSource,prcTarget)	\
    (This)->lpVtbl -> SetDrawParameters(This,prcSource,prcTarget)

#define IDDrawExclModeVideo_GetNativeVideoProps(This,pdwVideoWidth,pdwVideoHeight,pdwPictAspectRatioX,pdwPictAspectRatioY)	\
    (This)->lpVtbl -> GetNativeVideoProps(This,pdwVideoWidth,pdwVideoHeight,pdwPictAspectRatioX,pdwPictAspectRatioY)

#define IDDrawExclModeVideo_SetCallbackInterface(This,pCallback,dwFlags)	\
    (This)->lpVtbl -> SetCallbackInterface(This,pCallback,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDDrawExclModeVideo_SetDDrawObject_Proxy( 
    IDDrawExclModeVideo * This,
    /* [in] */ IDirectDraw *pDDrawObject);


void __RPC_STUB IDDrawExclModeVideo_SetDDrawObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDDrawExclModeVideo_GetDDrawObject_Proxy( 
    IDDrawExclModeVideo * This,
    /* [out] */ IDirectDraw **ppDDrawObject,
    /* [out] */ BOOL *pbUsingExternal);


void __RPC_STUB IDDrawExclModeVideo_GetDDrawObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDDrawExclModeVideo_SetDDrawSurface_Proxy( 
    IDDrawExclModeVideo * This,
    /* [in] */ IDirectDrawSurface *pDDrawSurface);


void __RPC_STUB IDDrawExclModeVideo_SetDDrawSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDDrawExclModeVideo_GetDDrawSurface_Proxy( 
    IDDrawExclModeVideo * This,
    /* [out] */ IDirectDrawSurface **ppDDrawSurface,
    /* [out] */ BOOL *pbUsingExternal);


void __RPC_STUB IDDrawExclModeVideo_GetDDrawSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDDrawExclModeVideo_SetDrawParameters_Proxy( 
    IDDrawExclModeVideo * This,
    /* [in] */ const RECT *prcSource,
    /* [in] */ const RECT *prcTarget);


void __RPC_STUB IDDrawExclModeVideo_SetDrawParameters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDDrawExclModeVideo_GetNativeVideoProps_Proxy( 
    IDDrawExclModeVideo * This,
    /* [out] */ DWORD *pdwVideoWidth,
    /* [out] */ DWORD *pdwVideoHeight,
    /* [out] */ DWORD *pdwPictAspectRatioX,
    /* [out] */ DWORD *pdwPictAspectRatioY);


void __RPC_STUB IDDrawExclModeVideo_GetNativeVideoProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDDrawExclModeVideo_SetCallbackInterface_Proxy( 
    IDDrawExclModeVideo * This,
    /* [in] */ IDDrawExclModeVideoCallback *pCallback,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IDDrawExclModeVideo_SetCallbackInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDDrawExclModeVideo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0381 */
/* [local] */ 


enum _AM_OVERLAY_NOTIFY_FLAGS
    {	AM_OVERLAY_NOTIFY_VISIBLE_CHANGE	= 0x1,
	AM_OVERLAY_NOTIFY_SOURCE_CHANGE	= 0x2,
	AM_OVERLAY_NOTIFY_DEST_CHANGE	= 0x4
    } ;


extern RPC_IF_HANDLE __MIDL_itf_strmif_0381_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0381_v0_0_s_ifspec;

#ifndef __IDDrawExclModeVideoCallback_INTERFACE_DEFINED__
#define __IDDrawExclModeVideoCallback_INTERFACE_DEFINED__

/* interface IDDrawExclModeVideoCallback */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IDDrawExclModeVideoCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("913c24a0-20ab-11d2-9038-00a0c9697298")
    IDDrawExclModeVideoCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnUpdateOverlay( 
            /* [in] */ BOOL bBefore,
            /* [in] */ DWORD dwFlags,
            /* [in] */ BOOL bOldVisible,
            /* [in] */ const RECT *prcOldSrc,
            /* [in] */ const RECT *prcOldDest,
            /* [in] */ BOOL bNewVisible,
            /* [in] */ const RECT *prcNewSrc,
            /* [in] */ const RECT *prcNewDest) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnUpdateColorKey( 
            /* [in] */ const COLORKEY *pKey,
            /* [in] */ DWORD dwColor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnUpdateSize( 
            /* [in] */ DWORD dwWidth,
            /* [in] */ DWORD dwHeight,
            /* [in] */ DWORD dwARWidth,
            /* [in] */ DWORD dwARHeight) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDDrawExclModeVideoCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDDrawExclModeVideoCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDDrawExclModeVideoCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDDrawExclModeVideoCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnUpdateOverlay )( 
            IDDrawExclModeVideoCallback * This,
            /* [in] */ BOOL bBefore,
            /* [in] */ DWORD dwFlags,
            /* [in] */ BOOL bOldVisible,
            /* [in] */ const RECT *prcOldSrc,
            /* [in] */ const RECT *prcOldDest,
            /* [in] */ BOOL bNewVisible,
            /* [in] */ const RECT *prcNewSrc,
            /* [in] */ const RECT *prcNewDest);
        
        HRESULT ( STDMETHODCALLTYPE *OnUpdateColorKey )( 
            IDDrawExclModeVideoCallback * This,
            /* [in] */ const COLORKEY *pKey,
            /* [in] */ DWORD dwColor);
        
        HRESULT ( STDMETHODCALLTYPE *OnUpdateSize )( 
            IDDrawExclModeVideoCallback * This,
            /* [in] */ DWORD dwWidth,
            /* [in] */ DWORD dwHeight,
            /* [in] */ DWORD dwARWidth,
            /* [in] */ DWORD dwARHeight);
        
        END_INTERFACE
    } IDDrawExclModeVideoCallbackVtbl;

    interface IDDrawExclModeVideoCallback
    {
        CONST_VTBL struct IDDrawExclModeVideoCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDDrawExclModeVideoCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDDrawExclModeVideoCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDDrawExclModeVideoCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDDrawExclModeVideoCallback_OnUpdateOverlay(This,bBefore,dwFlags,bOldVisible,prcOldSrc,prcOldDest,bNewVisible,prcNewSrc,prcNewDest)	\
    (This)->lpVtbl -> OnUpdateOverlay(This,bBefore,dwFlags,bOldVisible,prcOldSrc,prcOldDest,bNewVisible,prcNewSrc,prcNewDest)

#define IDDrawExclModeVideoCallback_OnUpdateColorKey(This,pKey,dwColor)	\
    (This)->lpVtbl -> OnUpdateColorKey(This,pKey,dwColor)

#define IDDrawExclModeVideoCallback_OnUpdateSize(This,dwWidth,dwHeight,dwARWidth,dwARHeight)	\
    (This)->lpVtbl -> OnUpdateSize(This,dwWidth,dwHeight,dwARWidth,dwARHeight)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDDrawExclModeVideoCallback_OnUpdateOverlay_Proxy( 
    IDDrawExclModeVideoCallback * This,
    /* [in] */ BOOL bBefore,
    /* [in] */ DWORD dwFlags,
    /* [in] */ BOOL bOldVisible,
    /* [in] */ const RECT *prcOldSrc,
    /* [in] */ const RECT *prcOldDest,
    /* [in] */ BOOL bNewVisible,
    /* [in] */ const RECT *prcNewSrc,
    /* [in] */ const RECT *prcNewDest);


void __RPC_STUB IDDrawExclModeVideoCallback_OnUpdateOverlay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDDrawExclModeVideoCallback_OnUpdateColorKey_Proxy( 
    IDDrawExclModeVideoCallback * This,
    /* [in] */ const COLORKEY *pKey,
    /* [in] */ DWORD dwColor);


void __RPC_STUB IDDrawExclModeVideoCallback_OnUpdateColorKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDDrawExclModeVideoCallback_OnUpdateSize_Proxy( 
    IDDrawExclModeVideoCallback * This,
    /* [in] */ DWORD dwWidth,
    /* [in] */ DWORD dwHeight,
    /* [in] */ DWORD dwARWidth,
    /* [in] */ DWORD dwARHeight);


void __RPC_STUB IDDrawExclModeVideoCallback_OnUpdateSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDDrawExclModeVideoCallback_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0382 */
/* [local] */ 







extern RPC_IF_HANDLE __MIDL_itf_strmif_0382_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0382_v0_0_s_ifspec;

#ifndef __IPinConnection_INTERFACE_DEFINED__
#define __IPinConnection_INTERFACE_DEFINED__

/* interface IPinConnection */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IPinConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4a9a62d3-27d4-403d-91e9-89f540e55534")
    IPinConnection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DynamicQueryAccept( 
            /* [in] */ const AM_MEDIA_TYPE *pmt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyEndOfStream( 
            /* [in] */ HANDLE hNotifyEvent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsEndPin( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DynamicDisconnect( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPinConnectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPinConnection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPinConnection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPinConnection * This);
        
        HRESULT ( STDMETHODCALLTYPE *DynamicQueryAccept )( 
            IPinConnection * This,
            /* [in] */ const AM_MEDIA_TYPE *pmt);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyEndOfStream )( 
            IPinConnection * This,
            /* [in] */ HANDLE hNotifyEvent);
        
        HRESULT ( STDMETHODCALLTYPE *IsEndPin )( 
            IPinConnection * This);
        
        HRESULT ( STDMETHODCALLTYPE *DynamicDisconnect )( 
            IPinConnection * This);
        
        END_INTERFACE
    } IPinConnectionVtbl;

    interface IPinConnection
    {
        CONST_VTBL struct IPinConnectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPinConnection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPinConnection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPinConnection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPinConnection_DynamicQueryAccept(This,pmt)	\
    (This)->lpVtbl -> DynamicQueryAccept(This,pmt)

#define IPinConnection_NotifyEndOfStream(This,hNotifyEvent)	\
    (This)->lpVtbl -> NotifyEndOfStream(This,hNotifyEvent)

#define IPinConnection_IsEndPin(This)	\
    (This)->lpVtbl -> IsEndPin(This)

#define IPinConnection_DynamicDisconnect(This)	\
    (This)->lpVtbl -> DynamicDisconnect(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPinConnection_DynamicQueryAccept_Proxy( 
    IPinConnection * This,
    /* [in] */ const AM_MEDIA_TYPE *pmt);


void __RPC_STUB IPinConnection_DynamicQueryAccept_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPinConnection_NotifyEndOfStream_Proxy( 
    IPinConnection * This,
    /* [in] */ HANDLE hNotifyEvent);


void __RPC_STUB IPinConnection_NotifyEndOfStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPinConnection_IsEndPin_Proxy( 
    IPinConnection * This);


void __RPC_STUB IPinConnection_IsEndPin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPinConnection_DynamicDisconnect_Proxy( 
    IPinConnection * This);


void __RPC_STUB IPinConnection_DynamicDisconnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPinConnection_INTERFACE_DEFINED__ */


#ifndef __IPinFlowControl_INTERFACE_DEFINED__
#define __IPinFlowControl_INTERFACE_DEFINED__

/* interface IPinFlowControl */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IPinFlowControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c56e9858-dbf3-4f6b-8119-384af2060deb")
    IPinFlowControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Block( 
            /* [in] */ DWORD dwBlockFlags,
            /* [in] */ HANDLE hEvent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPinFlowControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPinFlowControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPinFlowControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPinFlowControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *Block )( 
            IPinFlowControl * This,
            /* [in] */ DWORD dwBlockFlags,
            /* [in] */ HANDLE hEvent);
        
        END_INTERFACE
    } IPinFlowControlVtbl;

    interface IPinFlowControl
    {
        CONST_VTBL struct IPinFlowControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPinFlowControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPinFlowControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPinFlowControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPinFlowControl_Block(This,dwBlockFlags,hEvent)	\
    (This)->lpVtbl -> Block(This,dwBlockFlags,hEvent)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPinFlowControl_Block_Proxy( 
    IPinFlowControl * This,
    /* [in] */ DWORD dwBlockFlags,
    /* [in] */ HANDLE hEvent);


void __RPC_STUB IPinFlowControl_Block_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPinFlowControl_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0384 */
/* [local] */ 


enum _AM_PIN_FLOW_CONTROL_BLOCK_FLAGS
    {	AM_PIN_FLOW_CONTROL_BLOCK	= 0x1
    } ;
typedef 
enum _AM_GRAPH_CONFIG_RECONNECT_FLAGS
    {	AM_GRAPH_CONFIG_RECONNECT_DIRECTCONNECT	= 0x1,
	AM_GRAPH_CONFIG_RECONNECT_CACHE_REMOVED_FILTERS	= 0x2,
	AM_GRAPH_CONFIG_RECONNECT_USE_ONLY_CACHED_FILTERS	= 0x4
    } 	AM_GRAPH_CONFIG_RECONNECT_FLAGS;


enum _REM_FILTER_FLAGS
    {	REMFILTERF_LEAVECONNECTED	= 0x1
    } ;
typedef 
enum _AM_FILTER_FLAGS
    {	AM_FILTER_FLAGS_REMOVABLE	= 0x1
    } 	AM_FILTER_FLAGS;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0384_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0384_v0_0_s_ifspec;

#ifndef __IGraphConfig_INTERFACE_DEFINED__
#define __IGraphConfig_INTERFACE_DEFINED__

/* interface IGraphConfig */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IGraphConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("03A1EB8E-32BF-4245-8502-114D08A9CB88")
    IGraphConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Reconnect( 
            /* [in] */ IPin *pOutputPin,
            /* [in] */ IPin *pInputPin,
            /* [in] */ const AM_MEDIA_TYPE *pmtFirstConnection,
            /* [in] */ IBaseFilter *pUsingFilter,
            /* [in] */ HANDLE hAbortEvent,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reconfigure( 
            /* [in] */ IGraphConfigCallback *pCallback,
            /* [in] */ PVOID pvContext,
            /* [in] */ DWORD dwFlags,
            /* [in] */ HANDLE hAbortEvent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddFilterToCache( 
            /* [in] */ IBaseFilter *pFilter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumCacheFilter( 
            /* [out] */ IEnumFilters **pEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveFilterFromCache( 
            /* [in] */ IBaseFilter *pFilter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStartTime( 
            /* [out] */ REFERENCE_TIME *prtStart) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PushThroughData( 
            /* [in] */ IPin *pOutputPin,
            /* [in] */ IPinConnection *pConnection,
            /* [in] */ HANDLE hEventAbort) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFilterFlags( 
            /* [in] */ IBaseFilter *pFilter,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFilterFlags( 
            /* [in] */ IBaseFilter *pFilter,
            /* [out] */ DWORD *pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveFilterEx( 
            /* [in] */ IBaseFilter *pFilter,
            DWORD Flags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGraphConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGraphConfig * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGraphConfig * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGraphConfig * This);
        
        HRESULT ( STDMETHODCALLTYPE *Reconnect )( 
            IGraphConfig * This,
            /* [in] */ IPin *pOutputPin,
            /* [in] */ IPin *pInputPin,
            /* [in] */ const AM_MEDIA_TYPE *pmtFirstConnection,
            /* [in] */ IBaseFilter *pUsingFilter,
            /* [in] */ HANDLE hAbortEvent,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Reconfigure )( 
            IGraphConfig * This,
            /* [in] */ IGraphConfigCallback *pCallback,
            /* [in] */ PVOID pvContext,
            /* [in] */ DWORD dwFlags,
            /* [in] */ HANDLE hAbortEvent);
        
        HRESULT ( STDMETHODCALLTYPE *AddFilterToCache )( 
            IGraphConfig * This,
            /* [in] */ IBaseFilter *pFilter);
        
        HRESULT ( STDMETHODCALLTYPE *EnumCacheFilter )( 
            IGraphConfig * This,
            /* [out] */ IEnumFilters **pEnum);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveFilterFromCache )( 
            IGraphConfig * This,
            /* [in] */ IBaseFilter *pFilter);
        
        HRESULT ( STDMETHODCALLTYPE *GetStartTime )( 
            IGraphConfig * This,
            /* [out] */ REFERENCE_TIME *prtStart);
        
        HRESULT ( STDMETHODCALLTYPE *PushThroughData )( 
            IGraphConfig * This,
            /* [in] */ IPin *pOutputPin,
            /* [in] */ IPinConnection *pConnection,
            /* [in] */ HANDLE hEventAbort);
        
        HRESULT ( STDMETHODCALLTYPE *SetFilterFlags )( 
            IGraphConfig * This,
            /* [in] */ IBaseFilter *pFilter,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetFilterFlags )( 
            IGraphConfig * This,
            /* [in] */ IBaseFilter *pFilter,
            /* [out] */ DWORD *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveFilterEx )( 
            IGraphConfig * This,
            /* [in] */ IBaseFilter *pFilter,
            DWORD Flags);
        
        END_INTERFACE
    } IGraphConfigVtbl;

    interface IGraphConfig
    {
        CONST_VTBL struct IGraphConfigVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGraphConfig_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGraphConfig_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGraphConfig_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGraphConfig_Reconnect(This,pOutputPin,pInputPin,pmtFirstConnection,pUsingFilter,hAbortEvent,dwFlags)	\
    (This)->lpVtbl -> Reconnect(This,pOutputPin,pInputPin,pmtFirstConnection,pUsingFilter,hAbortEvent,dwFlags)

#define IGraphConfig_Reconfigure(This,pCallback,pvContext,dwFlags,hAbortEvent)	\
    (This)->lpVtbl -> Reconfigure(This,pCallback,pvContext,dwFlags,hAbortEvent)

#define IGraphConfig_AddFilterToCache(This,pFilter)	\
    (This)->lpVtbl -> AddFilterToCache(This,pFilter)

#define IGraphConfig_EnumCacheFilter(This,pEnum)	\
    (This)->lpVtbl -> EnumCacheFilter(This,pEnum)

#define IGraphConfig_RemoveFilterFromCache(This,pFilter)	\
    (This)->lpVtbl -> RemoveFilterFromCache(This,pFilter)

#define IGraphConfig_GetStartTime(This,prtStart)	\
    (This)->lpVtbl -> GetStartTime(This,prtStart)

#define IGraphConfig_PushThroughData(This,pOutputPin,pConnection,hEventAbort)	\
    (This)->lpVtbl -> PushThroughData(This,pOutputPin,pConnection,hEventAbort)

#define IGraphConfig_SetFilterFlags(This,pFilter,dwFlags)	\
    (This)->lpVtbl -> SetFilterFlags(This,pFilter,dwFlags)

#define IGraphConfig_GetFilterFlags(This,pFilter,pdwFlags)	\
    (This)->lpVtbl -> GetFilterFlags(This,pFilter,pdwFlags)

#define IGraphConfig_RemoveFilterEx(This,pFilter,Flags)	\
    (This)->lpVtbl -> RemoveFilterEx(This,pFilter,Flags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IGraphConfig_Reconnect_Proxy( 
    IGraphConfig * This,
    /* [in] */ IPin *pOutputPin,
    /* [in] */ IPin *pInputPin,
    /* [in] */ const AM_MEDIA_TYPE *pmtFirstConnection,
    /* [in] */ IBaseFilter *pUsingFilter,
    /* [in] */ HANDLE hAbortEvent,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IGraphConfig_Reconnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IGraphConfig_Reconfigure_Proxy( 
    IGraphConfig * This,
    /* [in] */ IGraphConfigCallback *pCallback,
    /* [in] */ PVOID pvContext,
    /* [in] */ DWORD dwFlags,
    /* [in] */ HANDLE hAbortEvent);


void __RPC_STUB IGraphConfig_Reconfigure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IGraphConfig_AddFilterToCache_Proxy( 
    IGraphConfig * This,
    /* [in] */ IBaseFilter *pFilter);


void __RPC_STUB IGraphConfig_AddFilterToCache_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IGraphConfig_EnumCacheFilter_Proxy( 
    IGraphConfig * This,
    /* [out] */ IEnumFilters **pEnum);


void __RPC_STUB IGraphConfig_EnumCacheFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IGraphConfig_RemoveFilterFromCache_Proxy( 
    IGraphConfig * This,
    /* [in] */ IBaseFilter *pFilter);


void __RPC_STUB IGraphConfig_RemoveFilterFromCache_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IGraphConfig_GetStartTime_Proxy( 
    IGraphConfig * This,
    /* [out] */ REFERENCE_TIME *prtStart);


void __RPC_STUB IGraphConfig_GetStartTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IGraphConfig_PushThroughData_Proxy( 
    IGraphConfig * This,
    /* [in] */ IPin *pOutputPin,
    /* [in] */ IPinConnection *pConnection,
    /* [in] */ HANDLE hEventAbort);


void __RPC_STUB IGraphConfig_PushThroughData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IGraphConfig_SetFilterFlags_Proxy( 
    IGraphConfig * This,
    /* [in] */ IBaseFilter *pFilter,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IGraphConfig_SetFilterFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IGraphConfig_GetFilterFlags_Proxy( 
    IGraphConfig * This,
    /* [in] */ IBaseFilter *pFilter,
    /* [out] */ DWORD *pdwFlags);


void __RPC_STUB IGraphConfig_GetFilterFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IGraphConfig_RemoveFilterEx_Proxy( 
    IGraphConfig * This,
    /* [in] */ IBaseFilter *pFilter,
    DWORD Flags);


void __RPC_STUB IGraphConfig_RemoveFilterEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGraphConfig_INTERFACE_DEFINED__ */


#ifndef __IGraphConfigCallback_INTERFACE_DEFINED__
#define __IGraphConfigCallback_INTERFACE_DEFINED__

/* interface IGraphConfigCallback */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IGraphConfigCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ade0fd60-d19d-11d2-abf6-00a0c905f375")
    IGraphConfigCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Reconfigure( 
            PVOID pvContext,
            DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGraphConfigCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGraphConfigCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGraphConfigCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGraphConfigCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *Reconfigure )( 
            IGraphConfigCallback * This,
            PVOID pvContext,
            DWORD dwFlags);
        
        END_INTERFACE
    } IGraphConfigCallbackVtbl;

    interface IGraphConfigCallback
    {
        CONST_VTBL struct IGraphConfigCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGraphConfigCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGraphConfigCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGraphConfigCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGraphConfigCallback_Reconfigure(This,pvContext,dwFlags)	\
    (This)->lpVtbl -> Reconfigure(This,pvContext,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IGraphConfigCallback_Reconfigure_Proxy( 
    IGraphConfigCallback * This,
    PVOID pvContext,
    DWORD dwFlags);


void __RPC_STUB IGraphConfigCallback_Reconfigure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGraphConfigCallback_INTERFACE_DEFINED__ */


#ifndef __IFilterChain_INTERFACE_DEFINED__
#define __IFilterChain_INTERFACE_DEFINED__

/* interface IFilterChain */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IFilterChain;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DCFBDCF6-0DC2-45f5-9AB2-7C330EA09C29")
    IFilterChain : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE StartChain( 
            /* [in] */ IBaseFilter *pStartFilter,
            /* [in] */ IBaseFilter *pEndFilter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PauseChain( 
            /* [in] */ IBaseFilter *pStartFilter,
            /* [in] */ IBaseFilter *pEndFilter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StopChain( 
            /* [in] */ IBaseFilter *pStartFilter,
            /* [in] */ IBaseFilter *pEndFilter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveChain( 
            /* [in] */ IBaseFilter *pStartFilter,
            /* [in] */ IBaseFilter *pEndFilter) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFilterChainVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFilterChain * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFilterChain * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFilterChain * This);
        
        HRESULT ( STDMETHODCALLTYPE *StartChain )( 
            IFilterChain * This,
            /* [in] */ IBaseFilter *pStartFilter,
            /* [in] */ IBaseFilter *pEndFilter);
        
        HRESULT ( STDMETHODCALLTYPE *PauseChain )( 
            IFilterChain * This,
            /* [in] */ IBaseFilter *pStartFilter,
            /* [in] */ IBaseFilter *pEndFilter);
        
        HRESULT ( STDMETHODCALLTYPE *StopChain )( 
            IFilterChain * This,
            /* [in] */ IBaseFilter *pStartFilter,
            /* [in] */ IBaseFilter *pEndFilter);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveChain )( 
            IFilterChain * This,
            /* [in] */ IBaseFilter *pStartFilter,
            /* [in] */ IBaseFilter *pEndFilter);
        
        END_INTERFACE
    } IFilterChainVtbl;

    interface IFilterChain
    {
        CONST_VTBL struct IFilterChainVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFilterChain_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFilterChain_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFilterChain_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFilterChain_StartChain(This,pStartFilter,pEndFilter)	\
    (This)->lpVtbl -> StartChain(This,pStartFilter,pEndFilter)

#define IFilterChain_PauseChain(This,pStartFilter,pEndFilter)	\
    (This)->lpVtbl -> PauseChain(This,pStartFilter,pEndFilter)

#define IFilterChain_StopChain(This,pStartFilter,pEndFilter)	\
    (This)->lpVtbl -> StopChain(This,pStartFilter,pEndFilter)

#define IFilterChain_RemoveChain(This,pStartFilter,pEndFilter)	\
    (This)->lpVtbl -> RemoveChain(This,pStartFilter,pEndFilter)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IFilterChain_StartChain_Proxy( 
    IFilterChain * This,
    /* [in] */ IBaseFilter *pStartFilter,
    /* [in] */ IBaseFilter *pEndFilter);


void __RPC_STUB IFilterChain_StartChain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IFilterChain_PauseChain_Proxy( 
    IFilterChain * This,
    /* [in] */ IBaseFilter *pStartFilter,
    /* [in] */ IBaseFilter *pEndFilter);


void __RPC_STUB IFilterChain_PauseChain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IFilterChain_StopChain_Proxy( 
    IFilterChain * This,
    /* [in] */ IBaseFilter *pStartFilter,
    /* [in] */ IBaseFilter *pEndFilter);


void __RPC_STUB IFilterChain_StopChain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IFilterChain_RemoveChain_Proxy( 
    IFilterChain * This,
    /* [in] */ IBaseFilter *pStartFilter,
    /* [in] */ IBaseFilter *pEndFilter);


void __RPC_STUB IFilterChain_RemoveChain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFilterChain_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0387 */
/* [local] */ 

#if 0
typedef DWORD *LPDIRECTDRAW7;

typedef DWORD *LPDIRECTDRAWSURFACE7;

typedef DWORD *LPDDPIXELFORMAT;

typedef DWORD *LPBITMAPINFOHEADER;

typedef /* [public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_strmif_0387_0001
    {
    DWORD dw1;
    DWORD dw2;
    } 	DDCOLORKEY;

typedef DDCOLORKEY *LPDDCOLORKEY;

#endif
#include <ddraw.h>














typedef /* [public] */ 
enum __MIDL___MIDL_itf_strmif_0387_0002
    {	VMRSample_SyncPoint	= 0x1,
	VMRSample_Preroll	= 0x2,
	VMRSample_Discontinuity	= 0x4,
	VMRSample_TimeValid	= 0x8
    } 	VMRPresentationFlags;

typedef struct tagVMRPRESENTATIONINFO
    {
    DWORD dwFlags;
    LPDIRECTDRAWSURFACE7 lpSurf;
    REFERENCE_TIME rtStart;
    REFERENCE_TIME rtEnd;
    SIZE szAspectRatio;
    RECT rcSrc;
    RECT rcDst;
    DWORD dwTypeSpecificFlags;
    DWORD dwInterlaceFlags;
    } 	VMRPRESENTATIONINFO;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0387_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0387_v0_0_s_ifspec;

#ifndef __IVMRImagePresenter_INTERFACE_DEFINED__
#define __IVMRImagePresenter_INTERFACE_DEFINED__

/* interface IVMRImagePresenter */
/* [unique][helpstring][uuid][local][object][local] */ 


EXTERN_C const IID IID_IVMRImagePresenter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CE704FE7-E71E-41fb-BAA2-C4403E1182F5")
    IVMRImagePresenter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE StartPresenting( 
            /* [in] */ DWORD_PTR dwUserID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StopPresenting( 
            /* [in] */ DWORD_PTR dwUserID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PresentImage( 
            /* [in] */ DWORD_PTR dwUserID,
            /* [in] */ VMRPRESENTATIONINFO *lpPresInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRImagePresenterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRImagePresenter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRImagePresenter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRImagePresenter * This);
        
        HRESULT ( STDMETHODCALLTYPE *StartPresenting )( 
            IVMRImagePresenter * This,
            /* [in] */ DWORD_PTR dwUserID);
        
        HRESULT ( STDMETHODCALLTYPE *StopPresenting )( 
            IVMRImagePresenter * This,
            /* [in] */ DWORD_PTR dwUserID);
        
        HRESULT ( STDMETHODCALLTYPE *PresentImage )( 
            IVMRImagePresenter * This,
            /* [in] */ DWORD_PTR dwUserID,
            /* [in] */ VMRPRESENTATIONINFO *lpPresInfo);
        
        END_INTERFACE
    } IVMRImagePresenterVtbl;

    interface IVMRImagePresenter
    {
        CONST_VTBL struct IVMRImagePresenterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRImagePresenter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVMRImagePresenter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVMRImagePresenter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVMRImagePresenter_StartPresenting(This,dwUserID)	\
    (This)->lpVtbl -> StartPresenting(This,dwUserID)

#define IVMRImagePresenter_StopPresenting(This,dwUserID)	\
    (This)->lpVtbl -> StopPresenting(This,dwUserID)

#define IVMRImagePresenter_PresentImage(This,dwUserID,lpPresInfo)	\
    (This)->lpVtbl -> PresentImage(This,dwUserID,lpPresInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IVMRImagePresenter_StartPresenting_Proxy( 
    IVMRImagePresenter * This,
    /* [in] */ DWORD_PTR dwUserID);


void __RPC_STUB IVMRImagePresenter_StartPresenting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRImagePresenter_StopPresenting_Proxy( 
    IVMRImagePresenter * This,
    /* [in] */ DWORD_PTR dwUserID);


void __RPC_STUB IVMRImagePresenter_StopPresenting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRImagePresenter_PresentImage_Proxy( 
    IVMRImagePresenter * This,
    /* [in] */ DWORD_PTR dwUserID,
    /* [in] */ VMRPRESENTATIONINFO *lpPresInfo);


void __RPC_STUB IVMRImagePresenter_PresentImage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVMRImagePresenter_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0388 */
/* [local] */ 

typedef /* [public] */ 
enum __MIDL___MIDL_itf_strmif_0388_0001
    {	AMAP_PIXELFORMAT_VALID	= 0x1,
	AMAP_3D_TARGET	= 0x2,
	AMAP_ALLOW_SYSMEM	= 0x4,
	AMAP_FORCE_SYSMEM	= 0x8,
	AMAP_DIRECTED_FLIP	= 0x10,
	AMAP_DXVA_TARGET	= 0x20
    } 	VMRSurfaceAllocationFlags;

typedef struct tagVMRALLOCATIONINFO
    {
    DWORD dwFlags;
    LPBITMAPINFOHEADER lpHdr;
    LPDDPIXELFORMAT lpPixFmt;
    SIZE szAspectRatio;
    DWORD dwMinBuffers;
    DWORD dwMaxBuffers;
    DWORD dwInterlaceFlags;
    SIZE szNativeSize;
    } 	VMRALLOCATIONINFO;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0388_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0388_v0_0_s_ifspec;

#ifndef __IVMRSurfaceAllocator_INTERFACE_DEFINED__
#define __IVMRSurfaceAllocator_INTERFACE_DEFINED__

/* interface IVMRSurfaceAllocator */
/* [unique][helpstring][uuid][local][object][local] */ 


EXTERN_C const IID IID_IVMRSurfaceAllocator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("31ce832e-4484-458b-8cca-f4d7e3db0b52")
    IVMRSurfaceAllocator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AllocateSurface( 
            /* [in] */ DWORD_PTR dwUserID,
            /* [in] */ VMRALLOCATIONINFO *lpAllocInfo,
            /* [out][in] */ DWORD *lpdwActualBuffers,
            /* [out] */ LPDIRECTDRAWSURFACE7 *lplpSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FreeSurface( 
            /* [in] */ DWORD_PTR dwID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PrepareSurface( 
            /* [in] */ DWORD_PTR dwUserID,
            /* [in] */ LPDIRECTDRAWSURFACE7 lpSurface,
            /* [in] */ DWORD dwSurfaceFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AdviseNotify( 
            /* [in] */ IVMRSurfaceAllocatorNotify *lpIVMRSurfAllocNotify) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRSurfaceAllocatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRSurfaceAllocator * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRSurfaceAllocator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRSurfaceAllocator * This);
        
        HRESULT ( STDMETHODCALLTYPE *AllocateSurface )( 
            IVMRSurfaceAllocator * This,
            /* [in] */ DWORD_PTR dwUserID,
            /* [in] */ VMRALLOCATIONINFO *lpAllocInfo,
            /* [out][in] */ DWORD *lpdwActualBuffers,
            /* [out] */ LPDIRECTDRAWSURFACE7 *lplpSurface);
        
        HRESULT ( STDMETHODCALLTYPE *FreeSurface )( 
            IVMRSurfaceAllocator * This,
            /* [in] */ DWORD_PTR dwID);
        
        HRESULT ( STDMETHODCALLTYPE *PrepareSurface )( 
            IVMRSurfaceAllocator * This,
            /* [in] */ DWORD_PTR dwUserID,
            /* [in] */ LPDIRECTDRAWSURFACE7 lpSurface,
            /* [in] */ DWORD dwSurfaceFlags);
        
        HRESULT ( STDMETHODCALLTYPE *AdviseNotify )( 
            IVMRSurfaceAllocator * This,
            /* [in] */ IVMRSurfaceAllocatorNotify *lpIVMRSurfAllocNotify);
        
        END_INTERFACE
    } IVMRSurfaceAllocatorVtbl;

    interface IVMRSurfaceAllocator
    {
        CONST_VTBL struct IVMRSurfaceAllocatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRSurfaceAllocator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVMRSurfaceAllocator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVMRSurfaceAllocator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVMRSurfaceAllocator_AllocateSurface(This,dwUserID,lpAllocInfo,lpdwActualBuffers,lplpSurface)	\
    (This)->lpVtbl -> AllocateSurface(This,dwUserID,lpAllocInfo,lpdwActualBuffers,lplpSurface)

#define IVMRSurfaceAllocator_FreeSurface(This,dwID)	\
    (This)->lpVtbl -> FreeSurface(This,dwID)

#define IVMRSurfaceAllocator_PrepareSurface(This,dwUserID,lpSurface,dwSurfaceFlags)	\
    (This)->lpVtbl -> PrepareSurface(This,dwUserID,lpSurface,dwSurfaceFlags)

#define IVMRSurfaceAllocator_AdviseNotify(This,lpIVMRSurfAllocNotify)	\
    (This)->lpVtbl -> AdviseNotify(This,lpIVMRSurfAllocNotify)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IVMRSurfaceAllocator_AllocateSurface_Proxy( 
    IVMRSurfaceAllocator * This,
    /* [in] */ DWORD_PTR dwUserID,
    /* [in] */ VMRALLOCATIONINFO *lpAllocInfo,
    /* [out][in] */ DWORD *lpdwActualBuffers,
    /* [out] */ LPDIRECTDRAWSURFACE7 *lplpSurface);


void __RPC_STUB IVMRSurfaceAllocator_AllocateSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRSurfaceAllocator_FreeSurface_Proxy( 
    IVMRSurfaceAllocator * This,
    /* [in] */ DWORD_PTR dwID);


void __RPC_STUB IVMRSurfaceAllocator_FreeSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRSurfaceAllocator_PrepareSurface_Proxy( 
    IVMRSurfaceAllocator * This,
    /* [in] */ DWORD_PTR dwUserID,
    /* [in] */ LPDIRECTDRAWSURFACE7 lpSurface,
    /* [in] */ DWORD dwSurfaceFlags);


void __RPC_STUB IVMRSurfaceAllocator_PrepareSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRSurfaceAllocator_AdviseNotify_Proxy( 
    IVMRSurfaceAllocator * This,
    /* [in] */ IVMRSurfaceAllocatorNotify *lpIVMRSurfAllocNotify);


void __RPC_STUB IVMRSurfaceAllocator_AdviseNotify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVMRSurfaceAllocator_INTERFACE_DEFINED__ */


#ifndef __IVMRSurfaceAllocatorNotify_INTERFACE_DEFINED__
#define __IVMRSurfaceAllocatorNotify_INTERFACE_DEFINED__

/* interface IVMRSurfaceAllocatorNotify */
/* [unique][helpstring][uuid][local][object][local] */ 


EXTERN_C const IID IID_IVMRSurfaceAllocatorNotify;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aada05a8-5a4e-4729-af0b-cea27aed51e2")
    IVMRSurfaceAllocatorNotify : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AdviseSurfaceAllocator( 
            /* [in] */ DWORD_PTR dwUserID,
            /* [in] */ IVMRSurfaceAllocator *lpIVRMSurfaceAllocator) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDDrawDevice( 
            /* [in] */ LPDIRECTDRAW7 lpDDrawDevice,
            /* [in] */ HMONITOR hMonitor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ChangeDDrawDevice( 
            /* [in] */ LPDIRECTDRAW7 lpDDrawDevice,
            /* [in] */ HMONITOR hMonitor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RestoreDDrawSurfaces( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyEvent( 
            /* [in] */ LONG EventCode,
            /* [in] */ LONG_PTR Param1,
            /* [in] */ LONG_PTR Param2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBorderColor( 
            /* [in] */ COLORREF clrBorder) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRSurfaceAllocatorNotifyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRSurfaceAllocatorNotify * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRSurfaceAllocatorNotify * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRSurfaceAllocatorNotify * This);
        
        HRESULT ( STDMETHODCALLTYPE *AdviseSurfaceAllocator )( 
            IVMRSurfaceAllocatorNotify * This,
            /* [in] */ DWORD_PTR dwUserID,
            /* [in] */ IVMRSurfaceAllocator *lpIVRMSurfaceAllocator);
        
        HRESULT ( STDMETHODCALLTYPE *SetDDrawDevice )( 
            IVMRSurfaceAllocatorNotify * This,
            /* [in] */ LPDIRECTDRAW7 lpDDrawDevice,
            /* [in] */ HMONITOR hMonitor);
        
        HRESULT ( STDMETHODCALLTYPE *ChangeDDrawDevice )( 
            IVMRSurfaceAllocatorNotify * This,
            /* [in] */ LPDIRECTDRAW7 lpDDrawDevice,
            /* [in] */ HMONITOR hMonitor);
        
        HRESULT ( STDMETHODCALLTYPE *RestoreDDrawSurfaces )( 
            IVMRSurfaceAllocatorNotify * This);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyEvent )( 
            IVMRSurfaceAllocatorNotify * This,
            /* [in] */ LONG EventCode,
            /* [in] */ LONG_PTR Param1,
            /* [in] */ LONG_PTR Param2);
        
        HRESULT ( STDMETHODCALLTYPE *SetBorderColor )( 
            IVMRSurfaceAllocatorNotify * This,
            /* [in] */ COLORREF clrBorder);
        
        END_INTERFACE
    } IVMRSurfaceAllocatorNotifyVtbl;

    interface IVMRSurfaceAllocatorNotify
    {
        CONST_VTBL struct IVMRSurfaceAllocatorNotifyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRSurfaceAllocatorNotify_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVMRSurfaceAllocatorNotify_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVMRSurfaceAllocatorNotify_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVMRSurfaceAllocatorNotify_AdviseSurfaceAllocator(This,dwUserID,lpIVRMSurfaceAllocator)	\
    (This)->lpVtbl -> AdviseSurfaceAllocator(This,dwUserID,lpIVRMSurfaceAllocator)

#define IVMRSurfaceAllocatorNotify_SetDDrawDevice(This,lpDDrawDevice,hMonitor)	\
    (This)->lpVtbl -> SetDDrawDevice(This,lpDDrawDevice,hMonitor)

#define IVMRSurfaceAllocatorNotify_ChangeDDrawDevice(This,lpDDrawDevice,hMonitor)	\
    (This)->lpVtbl -> ChangeDDrawDevice(This,lpDDrawDevice,hMonitor)

#define IVMRSurfaceAllocatorNotify_RestoreDDrawSurfaces(This)	\
    (This)->lpVtbl -> RestoreDDrawSurfaces(This)

#define IVMRSurfaceAllocatorNotify_NotifyEvent(This,EventCode,Param1,Param2)	\
    (This)->lpVtbl -> NotifyEvent(This,EventCode,Param1,Param2)

#define IVMRSurfaceAllocatorNotify_SetBorderColor(This,clrBorder)	\
    (This)->lpVtbl -> SetBorderColor(This,clrBorder)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IVMRSurfaceAllocatorNotify_AdviseSurfaceAllocator_Proxy( 
    IVMRSurfaceAllocatorNotify * This,
    /* [in] */ DWORD_PTR dwUserID,
    /* [in] */ IVMRSurfaceAllocator *lpIVRMSurfaceAllocator);


void __RPC_STUB IVMRSurfaceAllocatorNotify_AdviseSurfaceAllocator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRSurfaceAllocatorNotify_SetDDrawDevice_Proxy( 
    IVMRSurfaceAllocatorNotify * This,
    /* [in] */ LPDIRECTDRAW7 lpDDrawDevice,
    /* [in] */ HMONITOR hMonitor);


void __RPC_STUB IVMRSurfaceAllocatorNotify_SetDDrawDevice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRSurfaceAllocatorNotify_ChangeDDrawDevice_Proxy( 
    IVMRSurfaceAllocatorNotify * This,
    /* [in] */ LPDIRECTDRAW7 lpDDrawDevice,
    /* [in] */ HMONITOR hMonitor);


void __RPC_STUB IVMRSurfaceAllocatorNotify_ChangeDDrawDevice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRSurfaceAllocatorNotify_RestoreDDrawSurfaces_Proxy( 
    IVMRSurfaceAllocatorNotify * This);


void __RPC_STUB IVMRSurfaceAllocatorNotify_RestoreDDrawSurfaces_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRSurfaceAllocatorNotify_NotifyEvent_Proxy( 
    IVMRSurfaceAllocatorNotify * This,
    /* [in] */ LONG EventCode,
    /* [in] */ LONG_PTR Param1,
    /* [in] */ LONG_PTR Param2);


void __RPC_STUB IVMRSurfaceAllocatorNotify_NotifyEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRSurfaceAllocatorNotify_SetBorderColor_Proxy( 
    IVMRSurfaceAllocatorNotify * This,
    /* [in] */ COLORREF clrBorder);


void __RPC_STUB IVMRSurfaceAllocatorNotify_SetBorderColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVMRSurfaceAllocatorNotify_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0390 */
/* [local] */ 

typedef /* [public] */ 
enum __MIDL___MIDL_itf_strmif_0390_0001
    {	VMR_ARMODE_NONE	= 0,
	VMR_ARMODE_LETTER_BOX	= VMR_ARMODE_NONE + 1
    } 	VMR_ASPECT_RATIO_MODE;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0390_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0390_v0_0_s_ifspec;

#ifndef __IVMRWindowlessControl_INTERFACE_DEFINED__
#define __IVMRWindowlessControl_INTERFACE_DEFINED__

/* interface IVMRWindowlessControl */
/* [unique][helpstring][uuid][local][object][local] */ 


EXTERN_C const IID IID_IVMRWindowlessControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0eb1088c-4dcd-46f0-878f-39dae86a51b7")
    IVMRWindowlessControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNativeVideoSize( 
            /* [out] */ LONG *lpWidth,
            /* [out] */ LONG *lpHeight,
            /* [out] */ LONG *lpARWidth,
            /* [out] */ LONG *lpARHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMinIdealVideoSize( 
            /* [out] */ LONG *lpWidth,
            /* [out] */ LONG *lpHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaxIdealVideoSize( 
            /* [out] */ LONG *lpWidth,
            /* [out] */ LONG *lpHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetVideoPosition( 
            /* [in] */ const LPRECT lpSRCRect,
            /* [in] */ const LPRECT lpDSTRect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVideoPosition( 
            /* [out] */ LPRECT lpSRCRect,
            /* [out] */ LPRECT lpDSTRect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAspectRatioMode( 
            /* [out] */ DWORD *lpAspectRatioMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAspectRatioMode( 
            /* [in] */ DWORD AspectRatioMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetVideoClippingWindow( 
            /* [in] */ HWND hwnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RepaintVideo( 
            /* [in] */ HWND hwnd,
            /* [in] */ HDC hdc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DisplayModeChanged( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentImage( 
            /* [out] */ BYTE **lpDib) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBorderColor( 
            /* [in] */ COLORREF Clr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBorderColor( 
            /* [out] */ COLORREF *lpClr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetColorKey( 
            /* [in] */ COLORREF Clr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetColorKey( 
            /* [out] */ COLORREF *lpClr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRWindowlessControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRWindowlessControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRWindowlessControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRWindowlessControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetNativeVideoSize )( 
            IVMRWindowlessControl * This,
            /* [out] */ LONG *lpWidth,
            /* [out] */ LONG *lpHeight,
            /* [out] */ LONG *lpARWidth,
            /* [out] */ LONG *lpARHeight);
        
        HRESULT ( STDMETHODCALLTYPE *GetMinIdealVideoSize )( 
            IVMRWindowlessControl * This,
            /* [out] */ LONG *lpWidth,
            /* [out] */ LONG *lpHeight);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxIdealVideoSize )( 
            IVMRWindowlessControl * This,
            /* [out] */ LONG *lpWidth,
            /* [out] */ LONG *lpHeight);
        
        HRESULT ( STDMETHODCALLTYPE *SetVideoPosition )( 
            IVMRWindowlessControl * This,
            /* [in] */ const LPRECT lpSRCRect,
            /* [in] */ const LPRECT lpDSTRect);
        
        HRESULT ( STDMETHODCALLTYPE *GetVideoPosition )( 
            IVMRWindowlessControl * This,
            /* [out] */ LPRECT lpSRCRect,
            /* [out] */ LPRECT lpDSTRect);
        
        HRESULT ( STDMETHODCALLTYPE *GetAspectRatioMode )( 
            IVMRWindowlessControl * This,
            /* [out] */ DWORD *lpAspectRatioMode);
        
        HRESULT ( STDMETHODCALLTYPE *SetAspectRatioMode )( 
            IVMRWindowlessControl * This,
            /* [in] */ DWORD AspectRatioMode);
        
        HRESULT ( STDMETHODCALLTYPE *SetVideoClippingWindow )( 
            IVMRWindowlessControl * This,
            /* [in] */ HWND hwnd);
        
        HRESULT ( STDMETHODCALLTYPE *RepaintVideo )( 
            IVMRWindowlessControl * This,
            /* [in] */ HWND hwnd,
            /* [in] */ HDC hdc);
        
        HRESULT ( STDMETHODCALLTYPE *DisplayModeChanged )( 
            IVMRWindowlessControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentImage )( 
            IVMRWindowlessControl * This,
            /* [out] */ BYTE **lpDib);
        
        HRESULT ( STDMETHODCALLTYPE *SetBorderColor )( 
            IVMRWindowlessControl * This,
            /* [in] */ COLORREF Clr);
        
        HRESULT ( STDMETHODCALLTYPE *GetBorderColor )( 
            IVMRWindowlessControl * This,
            /* [out] */ COLORREF *lpClr);
        
        HRESULT ( STDMETHODCALLTYPE *SetColorKey )( 
            IVMRWindowlessControl * This,
            /* [in] */ COLORREF Clr);
        
        HRESULT ( STDMETHODCALLTYPE *GetColorKey )( 
            IVMRWindowlessControl * This,
            /* [out] */ COLORREF *lpClr);
        
        END_INTERFACE
    } IVMRWindowlessControlVtbl;

    interface IVMRWindowlessControl
    {
        CONST_VTBL struct IVMRWindowlessControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRWindowlessControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVMRWindowlessControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVMRWindowlessControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVMRWindowlessControl_GetNativeVideoSize(This,lpWidth,lpHeight,lpARWidth,lpARHeight)	\
    (This)->lpVtbl -> GetNativeVideoSize(This,lpWidth,lpHeight,lpARWidth,lpARHeight)

#define IVMRWindowlessControl_GetMinIdealVideoSize(This,lpWidth,lpHeight)	\
    (This)->lpVtbl -> GetMinIdealVideoSize(This,lpWidth,lpHeight)

#define IVMRWindowlessControl_GetMaxIdealVideoSize(This,lpWidth,lpHeight)	\
    (This)->lpVtbl -> GetMaxIdealVideoSize(This,lpWidth,lpHeight)

#define IVMRWindowlessControl_SetVideoPosition(This,lpSRCRect,lpDSTRect)	\
    (This)->lpVtbl -> SetVideoPosition(This,lpSRCRect,lpDSTRect)

#define IVMRWindowlessControl_GetVideoPosition(This,lpSRCRect,lpDSTRect)	\
    (This)->lpVtbl -> GetVideoPosition(This,lpSRCRect,lpDSTRect)

#define IVMRWindowlessControl_GetAspectRatioMode(This,lpAspectRatioMode)	\
    (This)->lpVtbl -> GetAspectRatioMode(This,lpAspectRatioMode)

#define IVMRWindowlessControl_SetAspectRatioMode(This,AspectRatioMode)	\
    (This)->lpVtbl -> SetAspectRatioMode(This,AspectRatioMode)

#define IVMRWindowlessControl_SetVideoClippingWindow(This,hwnd)	\
    (This)->lpVtbl -> SetVideoClippingWindow(This,hwnd)

#define IVMRWindowlessControl_RepaintVideo(This,hwnd,hdc)	\
    (This)->lpVtbl -> RepaintVideo(This,hwnd,hdc)

#define IVMRWindowlessControl_DisplayModeChanged(This)	\
    (This)->lpVtbl -> DisplayModeChanged(This)

#define IVMRWindowlessControl_GetCurrentImage(This,lpDib)	\
    (This)->lpVtbl -> GetCurrentImage(This,lpDib)

#define IVMRWindowlessControl_SetBorderColor(This,Clr)	\
    (This)->lpVtbl -> SetBorderColor(This,Clr)

#define IVMRWindowlessControl_GetBorderColor(This,lpClr)	\
    (This)->lpVtbl -> GetBorderColor(This,lpClr)

#define IVMRWindowlessControl_SetColorKey(This,Clr)	\
    (This)->lpVtbl -> SetColorKey(This,Clr)

#define IVMRWindowlessControl_GetColorKey(This,lpClr)	\
    (This)->lpVtbl -> GetColorKey(This,lpClr)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IVMRWindowlessControl_GetNativeVideoSize_Proxy( 
    IVMRWindowlessControl * This,
    /* [out] */ LONG *lpWidth,
    /* [out] */ LONG *lpHeight,
    /* [out] */ LONG *lpARWidth,
    /* [out] */ LONG *lpARHeight);


void __RPC_STUB IVMRWindowlessControl_GetNativeVideoSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRWindowlessControl_GetMinIdealVideoSize_Proxy( 
    IVMRWindowlessControl * This,
    /* [out] */ LONG *lpWidth,
    /* [out] */ LONG *lpHeight);


void __RPC_STUB IVMRWindowlessControl_GetMinIdealVideoSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRWindowlessControl_GetMaxIdealVideoSize_Proxy( 
    IVMRWindowlessControl * This,
    /* [out] */ LONG *lpWidth,
    /* [out] */ LONG *lpHeight);


void __RPC_STUB IVMRWindowlessControl_GetMaxIdealVideoSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRWindowlessControl_SetVideoPosition_Proxy( 
    IVMRWindowlessControl * This,
    /* [in] */ const LPRECT lpSRCRect,
    /* [in] */ const LPRECT lpDSTRect);


void __RPC_STUB IVMRWindowlessControl_SetVideoPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRWindowlessControl_GetVideoPosition_Proxy( 
    IVMRWindowlessControl * This,
    /* [out] */ LPRECT lpSRCRect,
    /* [out] */ LPRECT lpDSTRect);


void __RPC_STUB IVMRWindowlessControl_GetVideoPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRWindowlessControl_GetAspectRatioMode_Proxy( 
    IVMRWindowlessControl * This,
    /* [out] */ DWORD *lpAspectRatioMode);


void __RPC_STUB IVMRWindowlessControl_GetAspectRatioMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRWindowlessControl_SetAspectRatioMode_Proxy( 
    IVMRWindowlessControl * This,
    /* [in] */ DWORD AspectRatioMode);


void __RPC_STUB IVMRWindowlessControl_SetAspectRatioMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRWindowlessControl_SetVideoClippingWindow_Proxy( 
    IVMRWindowlessControl * This,
    /* [in] */ HWND hwnd);


void __RPC_STUB IVMRWindowlessControl_SetVideoClippingWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRWindowlessControl_RepaintVideo_Proxy( 
    IVMRWindowlessControl * This,
    /* [in] */ HWND hwnd,
    /* [in] */ HDC hdc);


void __RPC_STUB IVMRWindowlessControl_RepaintVideo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRWindowlessControl_DisplayModeChanged_Proxy( 
    IVMRWindowlessControl * This);


void __RPC_STUB IVMRWindowlessControl_DisplayModeChanged_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRWindowlessControl_GetCurrentImage_Proxy( 
    IVMRWindowlessControl * This,
    /* [out] */ BYTE **lpDib);


void __RPC_STUB IVMRWindowlessControl_GetCurrentImage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRWindowlessControl_SetBorderColor_Proxy( 
    IVMRWindowlessControl * This,
    /* [in] */ COLORREF Clr);


void __RPC_STUB IVMRWindowlessControl_SetBorderColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRWindowlessControl_GetBorderColor_Proxy( 
    IVMRWindowlessControl * This,
    /* [out] */ COLORREF *lpClr);


void __RPC_STUB IVMRWindowlessControl_GetBorderColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRWindowlessControl_SetColorKey_Proxy( 
    IVMRWindowlessControl * This,
    /* [in] */ COLORREF Clr);


void __RPC_STUB IVMRWindowlessControl_SetColorKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRWindowlessControl_GetColorKey_Proxy( 
    IVMRWindowlessControl * This,
    /* [out] */ COLORREF *lpClr);


void __RPC_STUB IVMRWindowlessControl_GetColorKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVMRWindowlessControl_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0391 */
/* [local] */ 

typedef /* [public] */ 
enum __MIDL___MIDL_itf_strmif_0391_0001
    {	MixerPref_NoDecimation	= 0x1,
	MixerPref_DecimateOutput	= 0x2,
	MixerPref_DecimateMask	= 0xf,
	MixerPref_BiLinearFiltering	= 0x10,
	MixerPref_PointFiltering	= 0x20,
	MixerPref_FilteringMask	= 0xf0,
	MixerPref_RenderTargetRGB	= 0x100,
	MixerPref_RenderTargetYUV420	= 0x200,
	MixerPref_RenderTargetYUV422	= 0x400,
	MixerPref_RenderTargetYUV444	= 0x800,
	MixerPref_RenderTargetReserved	= 0xf000,
	MixerPref_RenderTargetMask	= 0xff00
    } 	VMRMixerPrefs;

typedef struct _NORMALIZEDRECT
    {
    float left;
    float top;
    float right;
    float bottom;
    } 	NORMALIZEDRECT;

typedef struct _NORMALIZEDRECT *PNORMALIZEDRECT;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0391_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0391_v0_0_s_ifspec;

#ifndef __IVMRMixerControl_INTERFACE_DEFINED__
#define __IVMRMixerControl_INTERFACE_DEFINED__

/* interface IVMRMixerControl */
/* [unique][helpstring][uuid][local][object][local] */ 


EXTERN_C const IID IID_IVMRMixerControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1c1a17b0-bed0-415d-974b-dc6696131599")
    IVMRMixerControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetAlpha( 
            /* [in] */ DWORD dwStreamID,
            /* [in] */ float Alpha) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAlpha( 
            /* [in] */ DWORD dwStreamID,
            /* [out] */ float *pAlpha) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetZOrder( 
            /* [in] */ DWORD dwStreamID,
            /* [in] */ DWORD dwZ) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetZOrder( 
            /* [in] */ DWORD dwStreamID,
            /* [out] */ DWORD *pZ) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOutputRect( 
            /* [in] */ DWORD dwStreamID,
            /* [in] */ const NORMALIZEDRECT *pRect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputRect( 
            /* [in] */ DWORD dwStreamID,
            /* [out] */ NORMALIZEDRECT *pRect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBackgroundClr( 
            /* [in] */ COLORREF ClrBkg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBackgroundClr( 
            /* [in] */ COLORREF *lpClrBkg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMixingPrefs( 
            /* [in] */ DWORD dwMixerPrefs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMixingPrefs( 
            /* [out] */ DWORD *pdwMixerPrefs) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRMixerControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRMixerControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRMixerControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRMixerControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetAlpha )( 
            IVMRMixerControl * This,
            /* [in] */ DWORD dwStreamID,
            /* [in] */ float Alpha);
        
        HRESULT ( STDMETHODCALLTYPE *GetAlpha )( 
            IVMRMixerControl * This,
            /* [in] */ DWORD dwStreamID,
            /* [out] */ float *pAlpha);
        
        HRESULT ( STDMETHODCALLTYPE *SetZOrder )( 
            IVMRMixerControl * This,
            /* [in] */ DWORD dwStreamID,
            /* [in] */ DWORD dwZ);
        
        HRESULT ( STDMETHODCALLTYPE *GetZOrder )( 
            IVMRMixerControl * This,
            /* [in] */ DWORD dwStreamID,
            /* [out] */ DWORD *pZ);
        
        HRESULT ( STDMETHODCALLTYPE *SetOutputRect )( 
            IVMRMixerControl * This,
            /* [in] */ DWORD dwStreamID,
            /* [in] */ const NORMALIZEDRECT *pRect);
        
        HRESULT ( STDMETHODCALLTYPE *GetOutputRect )( 
            IVMRMixerControl * This,
            /* [in] */ DWORD dwStreamID,
            /* [out] */ NORMALIZEDRECT *pRect);
        
        HRESULT ( STDMETHODCALLTYPE *SetBackgroundClr )( 
            IVMRMixerControl * This,
            /* [in] */ COLORREF ClrBkg);
        
        HRESULT ( STDMETHODCALLTYPE *GetBackgroundClr )( 
            IVMRMixerControl * This,
            /* [in] */ COLORREF *lpClrBkg);
        
        HRESULT ( STDMETHODCALLTYPE *SetMixingPrefs )( 
            IVMRMixerControl * This,
            /* [in] */ DWORD dwMixerPrefs);
        
        HRESULT ( STDMETHODCALLTYPE *GetMixingPrefs )( 
            IVMRMixerControl * This,
            /* [out] */ DWORD *pdwMixerPrefs);
        
        END_INTERFACE
    } IVMRMixerControlVtbl;

    interface IVMRMixerControl
    {
        CONST_VTBL struct IVMRMixerControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRMixerControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVMRMixerControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVMRMixerControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVMRMixerControl_SetAlpha(This,dwStreamID,Alpha)	\
    (This)->lpVtbl -> SetAlpha(This,dwStreamID,Alpha)

#define IVMRMixerControl_GetAlpha(This,dwStreamID,pAlpha)	\
    (This)->lpVtbl -> GetAlpha(This,dwStreamID,pAlpha)

#define IVMRMixerControl_SetZOrder(This,dwStreamID,dwZ)	\
    (This)->lpVtbl -> SetZOrder(This,dwStreamID,dwZ)

#define IVMRMixerControl_GetZOrder(This,dwStreamID,pZ)	\
    (This)->lpVtbl -> GetZOrder(This,dwStreamID,pZ)

#define IVMRMixerControl_SetOutputRect(This,dwStreamID,pRect)	\
    (This)->lpVtbl -> SetOutputRect(This,dwStreamID,pRect)

#define IVMRMixerControl_GetOutputRect(This,dwStreamID,pRect)	\
    (This)->lpVtbl -> GetOutputRect(This,dwStreamID,pRect)

#define IVMRMixerControl_SetBackgroundClr(This,ClrBkg)	\
    (This)->lpVtbl -> SetBackgroundClr(This,ClrBkg)

#define IVMRMixerControl_GetBackgroundClr(This,lpClrBkg)	\
    (This)->lpVtbl -> GetBackgroundClr(This,lpClrBkg)

#define IVMRMixerControl_SetMixingPrefs(This,dwMixerPrefs)	\
    (This)->lpVtbl -> SetMixingPrefs(This,dwMixerPrefs)

#define IVMRMixerControl_GetMixingPrefs(This,pdwMixerPrefs)	\
    (This)->lpVtbl -> GetMixingPrefs(This,pdwMixerPrefs)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IVMRMixerControl_SetAlpha_Proxy( 
    IVMRMixerControl * This,
    /* [in] */ DWORD dwStreamID,
    /* [in] */ float Alpha);


void __RPC_STUB IVMRMixerControl_SetAlpha_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRMixerControl_GetAlpha_Proxy( 
    IVMRMixerControl * This,
    /* [in] */ DWORD dwStreamID,
    /* [out] */ float *pAlpha);


void __RPC_STUB IVMRMixerControl_GetAlpha_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRMixerControl_SetZOrder_Proxy( 
    IVMRMixerControl * This,
    /* [in] */ DWORD dwStreamID,
    /* [in] */ DWORD dwZ);


void __RPC_STUB IVMRMixerControl_SetZOrder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRMixerControl_GetZOrder_Proxy( 
    IVMRMixerControl * This,
    /* [in] */ DWORD dwStreamID,
    /* [out] */ DWORD *pZ);


void __RPC_STUB IVMRMixerControl_GetZOrder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRMixerControl_SetOutputRect_Proxy( 
    IVMRMixerControl * This,
    /* [in] */ DWORD dwStreamID,
    /* [in] */ const NORMALIZEDRECT *pRect);


void __RPC_STUB IVMRMixerControl_SetOutputRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRMixerControl_GetOutputRect_Proxy( 
    IVMRMixerControl * This,
    /* [in] */ DWORD dwStreamID,
    /* [out] */ NORMALIZEDRECT *pRect);


void __RPC_STUB IVMRMixerControl_GetOutputRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRMixerControl_SetBackgroundClr_Proxy( 
    IVMRMixerControl * This,
    /* [in] */ COLORREF ClrBkg);


void __RPC_STUB IVMRMixerControl_SetBackgroundClr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRMixerControl_GetBackgroundClr_Proxy( 
    IVMRMixerControl * This,
    /* [in] */ COLORREF *lpClrBkg);


void __RPC_STUB IVMRMixerControl_GetBackgroundClr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRMixerControl_SetMixingPrefs_Proxy( 
    IVMRMixerControl * This,
    /* [in] */ DWORD dwMixerPrefs);


void __RPC_STUB IVMRMixerControl_SetMixingPrefs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRMixerControl_GetMixingPrefs_Proxy( 
    IVMRMixerControl * This,
    /* [out] */ DWORD *pdwMixerPrefs);


void __RPC_STUB IVMRMixerControl_GetMixingPrefs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVMRMixerControl_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0392 */
/* [local] */ 

typedef struct tagVMRGUID
    {
    GUID *pGUID;
    GUID GUID;
    } 	VMRGUID;

typedef struct tagVMRMONITORINFO
    {
    VMRGUID guid;
    RECT rcMonitor;
    HMONITOR hMon;
    DWORD dwFlags;
    wchar_t szDevice[ 32 ];
    wchar_t szDescription[ 256 ];
    LARGE_INTEGER liDriverVersion;
    DWORD dwVendorId;
    DWORD dwDeviceId;
    DWORD dwSubSysId;
    DWORD dwRevision;
    } 	VMRMONITORINFO;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0392_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0392_v0_0_s_ifspec;

#ifndef __IVMRMonitorConfig_INTERFACE_DEFINED__
#define __IVMRMonitorConfig_INTERFACE_DEFINED__

/* interface IVMRMonitorConfig */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IVMRMonitorConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9cf0b1b6-fbaa-4b7f-88cf-cf1f130a0dce")
    IVMRMonitorConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetMonitor( 
            /* [in] */ const VMRGUID *pGUID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMonitor( 
            /* [out] */ VMRGUID *pGUID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDefaultMonitor( 
            /* [in] */ const VMRGUID *pGUID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultMonitor( 
            /* [out] */ VMRGUID *pGUID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAvailableMonitors( 
            /* [size_is][out] */ VMRMONITORINFO *pInfo,
            /* [in] */ DWORD dwMaxInfoArraySize,
            /* [out] */ DWORD *pdwNumDevices) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRMonitorConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRMonitorConfig * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRMonitorConfig * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRMonitorConfig * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetMonitor )( 
            IVMRMonitorConfig * This,
            /* [in] */ const VMRGUID *pGUID);
        
        HRESULT ( STDMETHODCALLTYPE *GetMonitor )( 
            IVMRMonitorConfig * This,
            /* [out] */ VMRGUID *pGUID);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultMonitor )( 
            IVMRMonitorConfig * This,
            /* [in] */ const VMRGUID *pGUID);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultMonitor )( 
            IVMRMonitorConfig * This,
            /* [out] */ VMRGUID *pGUID);
        
        HRESULT ( STDMETHODCALLTYPE *GetAvailableMonitors )( 
            IVMRMonitorConfig * This,
            /* [size_is][out] */ VMRMONITORINFO *pInfo,
            /* [in] */ DWORD dwMaxInfoArraySize,
            /* [out] */ DWORD *pdwNumDevices);
        
        END_INTERFACE
    } IVMRMonitorConfigVtbl;

    interface IVMRMonitorConfig
    {
        CONST_VTBL struct IVMRMonitorConfigVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRMonitorConfig_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVMRMonitorConfig_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVMRMonitorConfig_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVMRMonitorConfig_SetMonitor(This,pGUID)	\
    (This)->lpVtbl -> SetMonitor(This,pGUID)

#define IVMRMonitorConfig_GetMonitor(This,pGUID)	\
    (This)->lpVtbl -> GetMonitor(This,pGUID)

#define IVMRMonitorConfig_SetDefaultMonitor(This,pGUID)	\
    (This)->lpVtbl -> SetDefaultMonitor(This,pGUID)

#define IVMRMonitorConfig_GetDefaultMonitor(This,pGUID)	\
    (This)->lpVtbl -> GetDefaultMonitor(This,pGUID)

#define IVMRMonitorConfig_GetAvailableMonitors(This,pInfo,dwMaxInfoArraySize,pdwNumDevices)	\
    (This)->lpVtbl -> GetAvailableMonitors(This,pInfo,dwMaxInfoArraySize,pdwNumDevices)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IVMRMonitorConfig_SetMonitor_Proxy( 
    IVMRMonitorConfig * This,
    /* [in] */ const VMRGUID *pGUID);


void __RPC_STUB IVMRMonitorConfig_SetMonitor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRMonitorConfig_GetMonitor_Proxy( 
    IVMRMonitorConfig * This,
    /* [out] */ VMRGUID *pGUID);


void __RPC_STUB IVMRMonitorConfig_GetMonitor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRMonitorConfig_SetDefaultMonitor_Proxy( 
    IVMRMonitorConfig * This,
    /* [in] */ const VMRGUID *pGUID);


void __RPC_STUB IVMRMonitorConfig_SetDefaultMonitor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRMonitorConfig_GetDefaultMonitor_Proxy( 
    IVMRMonitorConfig * This,
    /* [out] */ VMRGUID *pGUID);


void __RPC_STUB IVMRMonitorConfig_GetDefaultMonitor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRMonitorConfig_GetAvailableMonitors_Proxy( 
    IVMRMonitorConfig * This,
    /* [size_is][out] */ VMRMONITORINFO *pInfo,
    /* [in] */ DWORD dwMaxInfoArraySize,
    /* [out] */ DWORD *pdwNumDevices);


void __RPC_STUB IVMRMonitorConfig_GetAvailableMonitors_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVMRMonitorConfig_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0393 */
/* [local] */ 

typedef /* [public] */ 
enum __MIDL___MIDL_itf_strmif_0393_0001
    {	RenderPrefs_RestrictToInitialMonitor	= 0,
	RenderPrefs_ForceOffscreen	= 0x1,
	RenderPrefs_ForceOverlays	= 0x2,
	RenderPrefs_AllowOverlays	= 0,
	RenderPrefs_AllowOffscreen	= 0,
	RenderPrefs_DoNotRenderColorKeyAndBorder	= 0x8,
	RenderPrefs_Reserved	= 0x10,
	RenderPrefs_PreferAGPMemWhenMixing	= 0x20,
	RenderPrefs_Mask	= 0x3f
    } 	VMRRenderPrefs;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_strmif_0393_0002
    {	VMRMode_Windowed	= 0x1,
	VMRMode_Windowless	= 0x2,
	VMRMode_Renderless	= 0x4,
	VMRMode_Mask	= 0x7
    } 	VMRMode;


enum __MIDL___MIDL_itf_strmif_0393_0003
    {	MAX_NUMBER_OF_STREAMS	= 16
    } ;


extern RPC_IF_HANDLE __MIDL_itf_strmif_0393_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0393_v0_0_s_ifspec;

#ifndef __IVMRFilterConfig_INTERFACE_DEFINED__
#define __IVMRFilterConfig_INTERFACE_DEFINED__

/* interface IVMRFilterConfig */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IVMRFilterConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9e5530c5-7034-48b4-bb46-0b8a6efc8e36")
    IVMRFilterConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetImageCompositor( 
            /* [in] */ IVMRImageCompositor *lpVMRImgCompositor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNumberOfStreams( 
            /* [in] */ DWORD dwMaxStreams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNumberOfStreams( 
            /* [out] */ DWORD *pdwMaxStreams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRenderingPrefs( 
            /* [in] */ DWORD dwRenderFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRenderingPrefs( 
            /* [out] */ DWORD *pdwRenderFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRenderingMode( 
            /* [in] */ DWORD Mode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRenderingMode( 
            /* [out] */ DWORD *pMode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRFilterConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRFilterConfig * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRFilterConfig * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRFilterConfig * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetImageCompositor )( 
            IVMRFilterConfig * This,
            /* [in] */ IVMRImageCompositor *lpVMRImgCompositor);
        
        HRESULT ( STDMETHODCALLTYPE *SetNumberOfStreams )( 
            IVMRFilterConfig * This,
            /* [in] */ DWORD dwMaxStreams);
        
        HRESULT ( STDMETHODCALLTYPE *GetNumberOfStreams )( 
            IVMRFilterConfig * This,
            /* [out] */ DWORD *pdwMaxStreams);
        
        HRESULT ( STDMETHODCALLTYPE *SetRenderingPrefs )( 
            IVMRFilterConfig * This,
            /* [in] */ DWORD dwRenderFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetRenderingPrefs )( 
            IVMRFilterConfig * This,
            /* [out] */ DWORD *pdwRenderFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetRenderingMode )( 
            IVMRFilterConfig * This,
            /* [in] */ DWORD Mode);
        
        HRESULT ( STDMETHODCALLTYPE *GetRenderingMode )( 
            IVMRFilterConfig * This,
            /* [out] */ DWORD *pMode);
        
        END_INTERFACE
    } IVMRFilterConfigVtbl;

    interface IVMRFilterConfig
    {
        CONST_VTBL struct IVMRFilterConfigVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRFilterConfig_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVMRFilterConfig_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVMRFilterConfig_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVMRFilterConfig_SetImageCompositor(This,lpVMRImgCompositor)	\
    (This)->lpVtbl -> SetImageCompositor(This,lpVMRImgCompositor)

#define IVMRFilterConfig_SetNumberOfStreams(This,dwMaxStreams)	\
    (This)->lpVtbl -> SetNumberOfStreams(This,dwMaxStreams)

#define IVMRFilterConfig_GetNumberOfStreams(This,pdwMaxStreams)	\
    (This)->lpVtbl -> GetNumberOfStreams(This,pdwMaxStreams)

#define IVMRFilterConfig_SetRenderingPrefs(This,dwRenderFlags)	\
    (This)->lpVtbl -> SetRenderingPrefs(This,dwRenderFlags)

#define IVMRFilterConfig_GetRenderingPrefs(This,pdwRenderFlags)	\
    (This)->lpVtbl -> GetRenderingPrefs(This,pdwRenderFlags)

#define IVMRFilterConfig_SetRenderingMode(This,Mode)	\
    (This)->lpVtbl -> SetRenderingMode(This,Mode)

#define IVMRFilterConfig_GetRenderingMode(This,pMode)	\
    (This)->lpVtbl -> GetRenderingMode(This,pMode)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IVMRFilterConfig_SetImageCompositor_Proxy( 
    IVMRFilterConfig * This,
    /* [in] */ IVMRImageCompositor *lpVMRImgCompositor);


void __RPC_STUB IVMRFilterConfig_SetImageCompositor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRFilterConfig_SetNumberOfStreams_Proxy( 
    IVMRFilterConfig * This,
    /* [in] */ DWORD dwMaxStreams);


void __RPC_STUB IVMRFilterConfig_SetNumberOfStreams_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRFilterConfig_GetNumberOfStreams_Proxy( 
    IVMRFilterConfig * This,
    /* [out] */ DWORD *pdwMaxStreams);


void __RPC_STUB IVMRFilterConfig_GetNumberOfStreams_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRFilterConfig_SetRenderingPrefs_Proxy( 
    IVMRFilterConfig * This,
    /* [in] */ DWORD dwRenderFlags);


void __RPC_STUB IVMRFilterConfig_SetRenderingPrefs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRFilterConfig_GetRenderingPrefs_Proxy( 
    IVMRFilterConfig * This,
    /* [out] */ DWORD *pdwRenderFlags);


void __RPC_STUB IVMRFilterConfig_GetRenderingPrefs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRFilterConfig_SetRenderingMode_Proxy( 
    IVMRFilterConfig * This,
    /* [in] */ DWORD Mode);


void __RPC_STUB IVMRFilterConfig_SetRenderingMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRFilterConfig_GetRenderingMode_Proxy( 
    IVMRFilterConfig * This,
    /* [out] */ DWORD *pMode);


void __RPC_STUB IVMRFilterConfig_GetRenderingMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVMRFilterConfig_INTERFACE_DEFINED__ */


#ifndef __IVMRAspectRatioControl_INTERFACE_DEFINED__
#define __IVMRAspectRatioControl_INTERFACE_DEFINED__

/* interface IVMRAspectRatioControl */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IVMRAspectRatioControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ede80b5c-bad6-4623-b537-65586c9f8dfd")
    IVMRAspectRatioControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAspectRatioMode( 
            /* [out] */ LPDWORD lpdwARMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAspectRatioMode( 
            /* [in] */ DWORD dwARMode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRAspectRatioControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRAspectRatioControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRAspectRatioControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRAspectRatioControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetAspectRatioMode )( 
            IVMRAspectRatioControl * This,
            /* [out] */ LPDWORD lpdwARMode);
        
        HRESULT ( STDMETHODCALLTYPE *SetAspectRatioMode )( 
            IVMRAspectRatioControl * This,
            /* [in] */ DWORD dwARMode);
        
        END_INTERFACE
    } IVMRAspectRatioControlVtbl;

    interface IVMRAspectRatioControl
    {
        CONST_VTBL struct IVMRAspectRatioControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRAspectRatioControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVMRAspectRatioControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVMRAspectRatioControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVMRAspectRatioControl_GetAspectRatioMode(This,lpdwARMode)	\
    (This)->lpVtbl -> GetAspectRatioMode(This,lpdwARMode)

#define IVMRAspectRatioControl_SetAspectRatioMode(This,dwARMode)	\
    (This)->lpVtbl -> SetAspectRatioMode(This,dwARMode)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IVMRAspectRatioControl_GetAspectRatioMode_Proxy( 
    IVMRAspectRatioControl * This,
    /* [out] */ LPDWORD lpdwARMode);


void __RPC_STUB IVMRAspectRatioControl_GetAspectRatioMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRAspectRatioControl_SetAspectRatioMode_Proxy( 
    IVMRAspectRatioControl * This,
    /* [in] */ DWORD dwARMode);


void __RPC_STUB IVMRAspectRatioControl_SetAspectRatioMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVMRAspectRatioControl_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0395 */
/* [local] */ 

typedef /* [public] */ 
enum __MIDL___MIDL_itf_strmif_0395_0001
    {	DeinterlacePref_NextBest	= 0x1,
	DeinterlacePref_BOB	= 0x2,
	DeinterlacePref_Weave	= 0x4,
	DeinterlacePref_Mask	= 0x7
    } 	VMRDeinterlacePrefs;

typedef /* [public][public][public] */ 
enum __MIDL___MIDL_itf_strmif_0395_0002
    {	DeinterlaceTech_Unknown	= 0,
	DeinterlaceTech_BOBLineReplicate	= 0x1,
	DeinterlaceTech_BOBVerticalStretch	= 0x2,
	DeinterlaceTech_MedianFiltering	= 0x4,
	DeinterlaceTech_EdgeFiltering	= 0x10,
	DeinterlaceTech_FieldAdaptive	= 0x20,
	DeinterlaceTech_PixelAdaptive	= 0x40,
	DeinterlaceTech_MotionVectorSteered	= 0x80
    } 	VMRDeinterlaceTech;

typedef struct _VMRFrequency
    {
    DWORD dwNumerator;
    DWORD dwDenominator;
    } 	VMRFrequency;

typedef struct _VMRVideoDesc
    {
    DWORD dwSize;
    DWORD dwSampleWidth;
    DWORD dwSampleHeight;
    BOOL SingleFieldPerSample;
    DWORD dwFourCC;
    VMRFrequency InputSampleFreq;
    VMRFrequency OutputFrameFreq;
    } 	VMRVideoDesc;

typedef struct _VMRDeinterlaceCaps
    {
    DWORD dwSize;
    DWORD dwNumPreviousOutputFrames;
    DWORD dwNumForwardRefSamples;
    DWORD dwNumBackwardRefSamples;
    VMRDeinterlaceTech DeinterlaceTechnology;
    } 	VMRDeinterlaceCaps;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0395_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0395_v0_0_s_ifspec;

#ifndef __IVMRDeinterlaceControl_INTERFACE_DEFINED__
#define __IVMRDeinterlaceControl_INTERFACE_DEFINED__

/* interface IVMRDeinterlaceControl */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IVMRDeinterlaceControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("bb057577-0db8-4e6a-87a7-1a8c9a505a0f")
    IVMRDeinterlaceControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNumberOfDeinterlaceModes( 
            /* [in] */ VMRVideoDesc *lpVideoDescription,
            /* [out][in] */ LPDWORD lpdwNumDeinterlaceModes,
            /* [out] */ LPGUID lpDeinterlaceModes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDeinterlaceModeCaps( 
            /* [in] */ LPGUID lpDeinterlaceMode,
            /* [in] */ VMRVideoDesc *lpVideoDescription,
            /* [out][in] */ VMRDeinterlaceCaps *lpDeinterlaceCaps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDeinterlaceMode( 
            /* [in] */ DWORD dwStreamID,
            /* [out] */ LPGUID lpDeinterlaceMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDeinterlaceMode( 
            /* [in] */ DWORD dwStreamID,
            /* [in] */ LPGUID lpDeinterlaceMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDeinterlacePrefs( 
            /* [out] */ LPDWORD lpdwDeinterlacePrefs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDeinterlacePrefs( 
            /* [in] */ DWORD dwDeinterlacePrefs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetActualDeinterlaceMode( 
            /* [in] */ DWORD dwStreamID,
            /* [out] */ LPGUID lpDeinterlaceMode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRDeinterlaceControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRDeinterlaceControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRDeinterlaceControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRDeinterlaceControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetNumberOfDeinterlaceModes )( 
            IVMRDeinterlaceControl * This,
            /* [in] */ VMRVideoDesc *lpVideoDescription,
            /* [out][in] */ LPDWORD lpdwNumDeinterlaceModes,
            /* [out] */ LPGUID lpDeinterlaceModes);
        
        HRESULT ( STDMETHODCALLTYPE *GetDeinterlaceModeCaps )( 
            IVMRDeinterlaceControl * This,
            /* [in] */ LPGUID lpDeinterlaceMode,
            /* [in] */ VMRVideoDesc *lpVideoDescription,
            /* [out][in] */ VMRDeinterlaceCaps *lpDeinterlaceCaps);
        
        HRESULT ( STDMETHODCALLTYPE *GetDeinterlaceMode )( 
            IVMRDeinterlaceControl * This,
            /* [in] */ DWORD dwStreamID,
            /* [out] */ LPGUID lpDeinterlaceMode);
        
        HRESULT ( STDMETHODCALLTYPE *SetDeinterlaceMode )( 
            IVMRDeinterlaceControl * This,
            /* [in] */ DWORD dwStreamID,
            /* [in] */ LPGUID lpDeinterlaceMode);
        
        HRESULT ( STDMETHODCALLTYPE *GetDeinterlacePrefs )( 
            IVMRDeinterlaceControl * This,
            /* [out] */ LPDWORD lpdwDeinterlacePrefs);
        
        HRESULT ( STDMETHODCALLTYPE *SetDeinterlacePrefs )( 
            IVMRDeinterlaceControl * This,
            /* [in] */ DWORD dwDeinterlacePrefs);
        
        HRESULT ( STDMETHODCALLTYPE *GetActualDeinterlaceMode )( 
            IVMRDeinterlaceControl * This,
            /* [in] */ DWORD dwStreamID,
            /* [out] */ LPGUID lpDeinterlaceMode);
        
        END_INTERFACE
    } IVMRDeinterlaceControlVtbl;

    interface IVMRDeinterlaceControl
    {
        CONST_VTBL struct IVMRDeinterlaceControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRDeinterlaceControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVMRDeinterlaceControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVMRDeinterlaceControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVMRDeinterlaceControl_GetNumberOfDeinterlaceModes(This,lpVideoDescription,lpdwNumDeinterlaceModes,lpDeinterlaceModes)	\
    (This)->lpVtbl -> GetNumberOfDeinterlaceModes(This,lpVideoDescription,lpdwNumDeinterlaceModes,lpDeinterlaceModes)

#define IVMRDeinterlaceControl_GetDeinterlaceModeCaps(This,lpDeinterlaceMode,lpVideoDescription,lpDeinterlaceCaps)	\
    (This)->lpVtbl -> GetDeinterlaceModeCaps(This,lpDeinterlaceMode,lpVideoDescription,lpDeinterlaceCaps)

#define IVMRDeinterlaceControl_GetDeinterlaceMode(This,dwStreamID,lpDeinterlaceMode)	\
    (This)->lpVtbl -> GetDeinterlaceMode(This,dwStreamID,lpDeinterlaceMode)

#define IVMRDeinterlaceControl_SetDeinterlaceMode(This,dwStreamID,lpDeinterlaceMode)	\
    (This)->lpVtbl -> SetDeinterlaceMode(This,dwStreamID,lpDeinterlaceMode)

#define IVMRDeinterlaceControl_GetDeinterlacePrefs(This,lpdwDeinterlacePrefs)	\
    (This)->lpVtbl -> GetDeinterlacePrefs(This,lpdwDeinterlacePrefs)

#define IVMRDeinterlaceControl_SetDeinterlacePrefs(This,dwDeinterlacePrefs)	\
    (This)->lpVtbl -> SetDeinterlacePrefs(This,dwDeinterlacePrefs)

#define IVMRDeinterlaceControl_GetActualDeinterlaceMode(This,dwStreamID,lpDeinterlaceMode)	\
    (This)->lpVtbl -> GetActualDeinterlaceMode(This,dwStreamID,lpDeinterlaceMode)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IVMRDeinterlaceControl_GetNumberOfDeinterlaceModes_Proxy( 
    IVMRDeinterlaceControl * This,
    /* [in] */ VMRVideoDesc *lpVideoDescription,
    /* [out][in] */ LPDWORD lpdwNumDeinterlaceModes,
    /* [out] */ LPGUID lpDeinterlaceModes);


void __RPC_STUB IVMRDeinterlaceControl_GetNumberOfDeinterlaceModes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRDeinterlaceControl_GetDeinterlaceModeCaps_Proxy( 
    IVMRDeinterlaceControl * This,
    /* [in] */ LPGUID lpDeinterlaceMode,
    /* [in] */ VMRVideoDesc *lpVideoDescription,
    /* [out][in] */ VMRDeinterlaceCaps *lpDeinterlaceCaps);


void __RPC_STUB IVMRDeinterlaceControl_GetDeinterlaceModeCaps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRDeinterlaceControl_GetDeinterlaceMode_Proxy( 
    IVMRDeinterlaceControl * This,
    /* [in] */ DWORD dwStreamID,
    /* [out] */ LPGUID lpDeinterlaceMode);


void __RPC_STUB IVMRDeinterlaceControl_GetDeinterlaceMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRDeinterlaceControl_SetDeinterlaceMode_Proxy( 
    IVMRDeinterlaceControl * This,
    /* [in] */ DWORD dwStreamID,
    /* [in] */ LPGUID lpDeinterlaceMode);


void __RPC_STUB IVMRDeinterlaceControl_SetDeinterlaceMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRDeinterlaceControl_GetDeinterlacePrefs_Proxy( 
    IVMRDeinterlaceControl * This,
    /* [out] */ LPDWORD lpdwDeinterlacePrefs);


void __RPC_STUB IVMRDeinterlaceControl_GetDeinterlacePrefs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRDeinterlaceControl_SetDeinterlacePrefs_Proxy( 
    IVMRDeinterlaceControl * This,
    /* [in] */ DWORD dwDeinterlacePrefs);


void __RPC_STUB IVMRDeinterlaceControl_SetDeinterlacePrefs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRDeinterlaceControl_GetActualDeinterlaceMode_Proxy( 
    IVMRDeinterlaceControl * This,
    /* [in] */ DWORD dwStreamID,
    /* [out] */ LPGUID lpDeinterlaceMode);


void __RPC_STUB IVMRDeinterlaceControl_GetActualDeinterlaceMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVMRDeinterlaceControl_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0396 */
/* [local] */ 

typedef struct _VMRALPHABITMAP
    {
    DWORD dwFlags;
    HDC hdc;
    LPDIRECTDRAWSURFACE7 pDDS;
    RECT rSrc;
    NORMALIZEDRECT rDest;
    FLOAT fAlpha;
    COLORREF clrSrcKey;
    } 	VMRALPHABITMAP;

typedef struct _VMRALPHABITMAP *PVMRALPHABITMAP;

#define VMRBITMAP_DISABLE            0x00000001
#define VMRBITMAP_HDC                0x00000002
#define VMRBITMAP_ENTIREDDS          0x00000004
#define VMRBITMAP_SRCCOLORKEY        0x00000008
#define VMRBITMAP_SRCRECT            0x00000010


extern RPC_IF_HANDLE __MIDL_itf_strmif_0396_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0396_v0_0_s_ifspec;

#ifndef __IVMRMixerBitmap_INTERFACE_DEFINED__
#define __IVMRMixerBitmap_INTERFACE_DEFINED__

/* interface IVMRMixerBitmap */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IVMRMixerBitmap;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1E673275-0257-40aa-AF20-7C608D4A0428")
    IVMRMixerBitmap : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetAlphaBitmap( 
            /* [in] */ const VMRALPHABITMAP *pBmpParms) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateAlphaBitmapParameters( 
            /* [in] */ PVMRALPHABITMAP pBmpParms) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAlphaBitmapParameters( 
            /* [out] */ PVMRALPHABITMAP pBmpParms) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRMixerBitmapVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRMixerBitmap * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRMixerBitmap * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRMixerBitmap * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetAlphaBitmap )( 
            IVMRMixerBitmap * This,
            /* [in] */ const VMRALPHABITMAP *pBmpParms);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateAlphaBitmapParameters )( 
            IVMRMixerBitmap * This,
            /* [in] */ PVMRALPHABITMAP pBmpParms);
        
        HRESULT ( STDMETHODCALLTYPE *GetAlphaBitmapParameters )( 
            IVMRMixerBitmap * This,
            /* [out] */ PVMRALPHABITMAP pBmpParms);
        
        END_INTERFACE
    } IVMRMixerBitmapVtbl;

    interface IVMRMixerBitmap
    {
        CONST_VTBL struct IVMRMixerBitmapVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRMixerBitmap_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVMRMixerBitmap_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVMRMixerBitmap_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVMRMixerBitmap_SetAlphaBitmap(This,pBmpParms)	\
    (This)->lpVtbl -> SetAlphaBitmap(This,pBmpParms)

#define IVMRMixerBitmap_UpdateAlphaBitmapParameters(This,pBmpParms)	\
    (This)->lpVtbl -> UpdateAlphaBitmapParameters(This,pBmpParms)

#define IVMRMixerBitmap_GetAlphaBitmapParameters(This,pBmpParms)	\
    (This)->lpVtbl -> GetAlphaBitmapParameters(This,pBmpParms)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IVMRMixerBitmap_SetAlphaBitmap_Proxy( 
    IVMRMixerBitmap * This,
    /* [in] */ const VMRALPHABITMAP *pBmpParms);


void __RPC_STUB IVMRMixerBitmap_SetAlphaBitmap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRMixerBitmap_UpdateAlphaBitmapParameters_Proxy( 
    IVMRMixerBitmap * This,
    /* [in] */ PVMRALPHABITMAP pBmpParms);


void __RPC_STUB IVMRMixerBitmap_UpdateAlphaBitmapParameters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRMixerBitmap_GetAlphaBitmapParameters_Proxy( 
    IVMRMixerBitmap * This,
    /* [out] */ PVMRALPHABITMAP pBmpParms);


void __RPC_STUB IVMRMixerBitmap_GetAlphaBitmapParameters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVMRMixerBitmap_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0397 */
/* [local] */ 

typedef struct _VMRVIDEOSTREAMINFO
    {
    LPDIRECTDRAWSURFACE7 pddsVideoSurface;
    DWORD dwWidth;
    DWORD dwHeight;
    DWORD dwStrmID;
    FLOAT fAlpha;
    DDCOLORKEY ddClrKey;
    NORMALIZEDRECT rNormal;
    } 	VMRVIDEOSTREAMINFO;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0397_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0397_v0_0_s_ifspec;

#ifndef __IVMRImageCompositor_INTERFACE_DEFINED__
#define __IVMRImageCompositor_INTERFACE_DEFINED__

/* interface IVMRImageCompositor */
/* [unique][helpstring][uuid][local][object][local] */ 


EXTERN_C const IID IID_IVMRImageCompositor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7a4fb5af-479f-4074-bb40-ce6722e43c82")
    IVMRImageCompositor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitCompositionTarget( 
            /* [in] */ IUnknown *pD3DDevice,
            /* [in] */ LPDIRECTDRAWSURFACE7 pddsRenderTarget) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TermCompositionTarget( 
            /* [in] */ IUnknown *pD3DDevice,
            /* [in] */ LPDIRECTDRAWSURFACE7 pddsRenderTarget) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStreamMediaType( 
            /* [in] */ DWORD dwStrmID,
            /* [in] */ AM_MEDIA_TYPE *pmt,
            /* [in] */ BOOL fTexture) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CompositeImage( 
            /* [in] */ IUnknown *pD3DDevice,
            /* [in] */ LPDIRECTDRAWSURFACE7 pddsRenderTarget,
            /* [in] */ AM_MEDIA_TYPE *pmtRenderTarget,
            /* [in] */ REFERENCE_TIME rtStart,
            /* [in] */ REFERENCE_TIME rtEnd,
            /* [in] */ DWORD dwClrBkGnd,
            /* [in] */ VMRVIDEOSTREAMINFO *pVideoStreamInfo,
            /* [in] */ UINT cStreams) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRImageCompositorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRImageCompositor * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRImageCompositor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRImageCompositor * This);
        
        HRESULT ( STDMETHODCALLTYPE *InitCompositionTarget )( 
            IVMRImageCompositor * This,
            /* [in] */ IUnknown *pD3DDevice,
            /* [in] */ LPDIRECTDRAWSURFACE7 pddsRenderTarget);
        
        HRESULT ( STDMETHODCALLTYPE *TermCompositionTarget )( 
            IVMRImageCompositor * This,
            /* [in] */ IUnknown *pD3DDevice,
            /* [in] */ LPDIRECTDRAWSURFACE7 pddsRenderTarget);
        
        HRESULT ( STDMETHODCALLTYPE *SetStreamMediaType )( 
            IVMRImageCompositor * This,
            /* [in] */ DWORD dwStrmID,
            /* [in] */ AM_MEDIA_TYPE *pmt,
            /* [in] */ BOOL fTexture);
        
        HRESULT ( STDMETHODCALLTYPE *CompositeImage )( 
            IVMRImageCompositor * This,
            /* [in] */ IUnknown *pD3DDevice,
            /* [in] */ LPDIRECTDRAWSURFACE7 pddsRenderTarget,
            /* [in] */ AM_MEDIA_TYPE *pmtRenderTarget,
            /* [in] */ REFERENCE_TIME rtStart,
            /* [in] */ REFERENCE_TIME rtEnd,
            /* [in] */ DWORD dwClrBkGnd,
            /* [in] */ VMRVIDEOSTREAMINFO *pVideoStreamInfo,
            /* [in] */ UINT cStreams);
        
        END_INTERFACE
    } IVMRImageCompositorVtbl;

    interface IVMRImageCompositor
    {
        CONST_VTBL struct IVMRImageCompositorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRImageCompositor_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVMRImageCompositor_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVMRImageCompositor_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVMRImageCompositor_InitCompositionTarget(This,pD3DDevice,pddsRenderTarget)	\
    (This)->lpVtbl -> InitCompositionTarget(This,pD3DDevice,pddsRenderTarget)

#define IVMRImageCompositor_TermCompositionTarget(This,pD3DDevice,pddsRenderTarget)	\
    (This)->lpVtbl -> TermCompositionTarget(This,pD3DDevice,pddsRenderTarget)

#define IVMRImageCompositor_SetStreamMediaType(This,dwStrmID,pmt,fTexture)	\
    (This)->lpVtbl -> SetStreamMediaType(This,dwStrmID,pmt,fTexture)

#define IVMRImageCompositor_CompositeImage(This,pD3DDevice,pddsRenderTarget,pmtRenderTarget,rtStart,rtEnd,dwClrBkGnd,pVideoStreamInfo,cStreams)	\
    (This)->lpVtbl -> CompositeImage(This,pD3DDevice,pddsRenderTarget,pmtRenderTarget,rtStart,rtEnd,dwClrBkGnd,pVideoStreamInfo,cStreams)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IVMRImageCompositor_InitCompositionTarget_Proxy( 
    IVMRImageCompositor * This,
    /* [in] */ IUnknown *pD3DDevice,
    /* [in] */ LPDIRECTDRAWSURFACE7 pddsRenderTarget);


void __RPC_STUB IVMRImageCompositor_InitCompositionTarget_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRImageCompositor_TermCompositionTarget_Proxy( 
    IVMRImageCompositor * This,
    /* [in] */ IUnknown *pD3DDevice,
    /* [in] */ LPDIRECTDRAWSURFACE7 pddsRenderTarget);


void __RPC_STUB IVMRImageCompositor_TermCompositionTarget_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRImageCompositor_SetStreamMediaType_Proxy( 
    IVMRImageCompositor * This,
    /* [in] */ DWORD dwStrmID,
    /* [in] */ AM_MEDIA_TYPE *pmt,
    /* [in] */ BOOL fTexture);


void __RPC_STUB IVMRImageCompositor_SetStreamMediaType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRImageCompositor_CompositeImage_Proxy( 
    IVMRImageCompositor * This,
    /* [in] */ IUnknown *pD3DDevice,
    /* [in] */ LPDIRECTDRAWSURFACE7 pddsRenderTarget,
    /* [in] */ AM_MEDIA_TYPE *pmtRenderTarget,
    /* [in] */ REFERENCE_TIME rtStart,
    /* [in] */ REFERENCE_TIME rtEnd,
    /* [in] */ DWORD dwClrBkGnd,
    /* [in] */ VMRVIDEOSTREAMINFO *pVideoStreamInfo,
    /* [in] */ UINT cStreams);


void __RPC_STUB IVMRImageCompositor_CompositeImage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVMRImageCompositor_INTERFACE_DEFINED__ */


#ifndef __IVMRVideoStreamControl_INTERFACE_DEFINED__
#define __IVMRVideoStreamControl_INTERFACE_DEFINED__

/* interface IVMRVideoStreamControl */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IVMRVideoStreamControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("058d1f11-2a54-4bef-bd54-df706626b727")
    IVMRVideoStreamControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetColorKey( 
            /* [in] */ LPDDCOLORKEY lpClrKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetColorKey( 
            /* [out] */ LPDDCOLORKEY lpClrKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStreamActiveState( 
            /* [in] */ BOOL fActive) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamActiveState( 
            /* [out] */ BOOL *lpfActive) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRVideoStreamControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRVideoStreamControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRVideoStreamControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRVideoStreamControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetColorKey )( 
            IVMRVideoStreamControl * This,
            /* [in] */ LPDDCOLORKEY lpClrKey);
        
        HRESULT ( STDMETHODCALLTYPE *GetColorKey )( 
            IVMRVideoStreamControl * This,
            /* [out] */ LPDDCOLORKEY lpClrKey);
        
        HRESULT ( STDMETHODCALLTYPE *SetStreamActiveState )( 
            IVMRVideoStreamControl * This,
            /* [in] */ BOOL fActive);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamActiveState )( 
            IVMRVideoStreamControl * This,
            /* [out] */ BOOL *lpfActive);
        
        END_INTERFACE
    } IVMRVideoStreamControlVtbl;

    interface IVMRVideoStreamControl
    {
        CONST_VTBL struct IVMRVideoStreamControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRVideoStreamControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVMRVideoStreamControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVMRVideoStreamControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVMRVideoStreamControl_SetColorKey(This,lpClrKey)	\
    (This)->lpVtbl -> SetColorKey(This,lpClrKey)

#define IVMRVideoStreamControl_GetColorKey(This,lpClrKey)	\
    (This)->lpVtbl -> GetColorKey(This,lpClrKey)

#define IVMRVideoStreamControl_SetStreamActiveState(This,fActive)	\
    (This)->lpVtbl -> SetStreamActiveState(This,fActive)

#define IVMRVideoStreamControl_GetStreamActiveState(This,lpfActive)	\
    (This)->lpVtbl -> GetStreamActiveState(This,lpfActive)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IVMRVideoStreamControl_SetColorKey_Proxy( 
    IVMRVideoStreamControl * This,
    /* [in] */ LPDDCOLORKEY lpClrKey);


void __RPC_STUB IVMRVideoStreamControl_SetColorKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRVideoStreamControl_GetColorKey_Proxy( 
    IVMRVideoStreamControl * This,
    /* [out] */ LPDDCOLORKEY lpClrKey);


void __RPC_STUB IVMRVideoStreamControl_GetColorKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRVideoStreamControl_SetStreamActiveState_Proxy( 
    IVMRVideoStreamControl * This,
    /* [in] */ BOOL fActive);


void __RPC_STUB IVMRVideoStreamControl_SetStreamActiveState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRVideoStreamControl_GetStreamActiveState_Proxy( 
    IVMRVideoStreamControl * This,
    /* [out] */ BOOL *lpfActive);


void __RPC_STUB IVMRVideoStreamControl_GetStreamActiveState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVMRVideoStreamControl_INTERFACE_DEFINED__ */


#ifndef __IVMRSurface_INTERFACE_DEFINED__
#define __IVMRSurface_INTERFACE_DEFINED__

/* interface IVMRSurface */
/* [unique][helpstring][uuid][local][object][local] */ 


EXTERN_C const IID IID_IVMRSurface;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a9849bbe-9ec8-4263-b764-62730f0d15d0")
    IVMRSurface : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsSurfaceLocked( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LockSurface( 
            /* [out] */ BYTE **lpSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnlockSurface( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSurface( 
            /* [out] */ LPDIRECTDRAWSURFACE7 *lplpSurface) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRSurfaceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRSurface * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRSurface * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRSurface * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsSurfaceLocked )( 
            IVMRSurface * This);
        
        HRESULT ( STDMETHODCALLTYPE *LockSurface )( 
            IVMRSurface * This,
            /* [out] */ BYTE **lpSurface);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockSurface )( 
            IVMRSurface * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSurface )( 
            IVMRSurface * This,
            /* [out] */ LPDIRECTDRAWSURFACE7 *lplpSurface);
        
        END_INTERFACE
    } IVMRSurfaceVtbl;

    interface IVMRSurface
    {
        CONST_VTBL struct IVMRSurfaceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRSurface_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVMRSurface_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVMRSurface_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVMRSurface_IsSurfaceLocked(This)	\
    (This)->lpVtbl -> IsSurfaceLocked(This)

#define IVMRSurface_LockSurface(This,lpSurface)	\
    (This)->lpVtbl -> LockSurface(This,lpSurface)

#define IVMRSurface_UnlockSurface(This)	\
    (This)->lpVtbl -> UnlockSurface(This)

#define IVMRSurface_GetSurface(This,lplpSurface)	\
    (This)->lpVtbl -> GetSurface(This,lplpSurface)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IVMRSurface_IsSurfaceLocked_Proxy( 
    IVMRSurface * This);


void __RPC_STUB IVMRSurface_IsSurfaceLocked_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRSurface_LockSurface_Proxy( 
    IVMRSurface * This,
    /* [out] */ BYTE **lpSurface);


void __RPC_STUB IVMRSurface_LockSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRSurface_UnlockSurface_Proxy( 
    IVMRSurface * This);


void __RPC_STUB IVMRSurface_UnlockSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRSurface_GetSurface_Proxy( 
    IVMRSurface * This,
    /* [out] */ LPDIRECTDRAWSURFACE7 *lplpSurface);


void __RPC_STUB IVMRSurface_GetSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVMRSurface_INTERFACE_DEFINED__ */


#ifndef __IVMRImagePresenterConfig_INTERFACE_DEFINED__
#define __IVMRImagePresenterConfig_INTERFACE_DEFINED__

/* interface IVMRImagePresenterConfig */
/* [unique][helpstring][uuid][local][object][local] */ 


EXTERN_C const IID IID_IVMRImagePresenterConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9f3a1c85-8555-49ba-935f-be5b5b29d178")
    IVMRImagePresenterConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetRenderingPrefs( 
            /* [in] */ DWORD dwRenderFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRenderingPrefs( 
            /* [out] */ DWORD *dwRenderFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRImagePresenterConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRImagePresenterConfig * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRImagePresenterConfig * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRImagePresenterConfig * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetRenderingPrefs )( 
            IVMRImagePresenterConfig * This,
            /* [in] */ DWORD dwRenderFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetRenderingPrefs )( 
            IVMRImagePresenterConfig * This,
            /* [out] */ DWORD *dwRenderFlags);
        
        END_INTERFACE
    } IVMRImagePresenterConfigVtbl;

    interface IVMRImagePresenterConfig
    {
        CONST_VTBL struct IVMRImagePresenterConfigVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRImagePresenterConfig_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVMRImagePresenterConfig_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVMRImagePresenterConfig_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVMRImagePresenterConfig_SetRenderingPrefs(This,dwRenderFlags)	\
    (This)->lpVtbl -> SetRenderingPrefs(This,dwRenderFlags)

#define IVMRImagePresenterConfig_GetRenderingPrefs(This,dwRenderFlags)	\
    (This)->lpVtbl -> GetRenderingPrefs(This,dwRenderFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IVMRImagePresenterConfig_SetRenderingPrefs_Proxy( 
    IVMRImagePresenterConfig * This,
    /* [in] */ DWORD dwRenderFlags);


void __RPC_STUB IVMRImagePresenterConfig_SetRenderingPrefs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRImagePresenterConfig_GetRenderingPrefs_Proxy( 
    IVMRImagePresenterConfig * This,
    /* [out] */ DWORD *dwRenderFlags);


void __RPC_STUB IVMRImagePresenterConfig_GetRenderingPrefs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVMRImagePresenterConfig_INTERFACE_DEFINED__ */


#ifndef __IVMRImagePresenterExclModeConfig_INTERFACE_DEFINED__
#define __IVMRImagePresenterExclModeConfig_INTERFACE_DEFINED__

/* interface IVMRImagePresenterExclModeConfig */
/* [unique][helpstring][uuid][local][object][local] */ 


EXTERN_C const IID IID_IVMRImagePresenterExclModeConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e6f7ce40-4673-44f1-8f77-5499d68cb4ea")
    IVMRImagePresenterExclModeConfig : public IVMRImagePresenterConfig
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetXlcModeDDObjAndPrimarySurface( 
            /* [in] */ LPDIRECTDRAW7 lpDDObj,
            /* [in] */ LPDIRECTDRAWSURFACE7 lpPrimarySurf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetXlcModeDDObjAndPrimarySurface( 
            /* [out] */ LPDIRECTDRAW7 *lpDDObj,
            /* [out] */ LPDIRECTDRAWSURFACE7 *lpPrimarySurf) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRImagePresenterExclModeConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRImagePresenterExclModeConfig * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRImagePresenterExclModeConfig * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRImagePresenterExclModeConfig * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetRenderingPrefs )( 
            IVMRImagePresenterExclModeConfig * This,
            /* [in] */ DWORD dwRenderFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetRenderingPrefs )( 
            IVMRImagePresenterExclModeConfig * This,
            /* [out] */ DWORD *dwRenderFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetXlcModeDDObjAndPrimarySurface )( 
            IVMRImagePresenterExclModeConfig * This,
            /* [in] */ LPDIRECTDRAW7 lpDDObj,
            /* [in] */ LPDIRECTDRAWSURFACE7 lpPrimarySurf);
        
        HRESULT ( STDMETHODCALLTYPE *GetXlcModeDDObjAndPrimarySurface )( 
            IVMRImagePresenterExclModeConfig * This,
            /* [out] */ LPDIRECTDRAW7 *lpDDObj,
            /* [out] */ LPDIRECTDRAWSURFACE7 *lpPrimarySurf);
        
        END_INTERFACE
    } IVMRImagePresenterExclModeConfigVtbl;

    interface IVMRImagePresenterExclModeConfig
    {
        CONST_VTBL struct IVMRImagePresenterExclModeConfigVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRImagePresenterExclModeConfig_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVMRImagePresenterExclModeConfig_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVMRImagePresenterExclModeConfig_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVMRImagePresenterExclModeConfig_SetRenderingPrefs(This,dwRenderFlags)	\
    (This)->lpVtbl -> SetRenderingPrefs(This,dwRenderFlags)

#define IVMRImagePresenterExclModeConfig_GetRenderingPrefs(This,dwRenderFlags)	\
    (This)->lpVtbl -> GetRenderingPrefs(This,dwRenderFlags)


#define IVMRImagePresenterExclModeConfig_SetXlcModeDDObjAndPrimarySurface(This,lpDDObj,lpPrimarySurf)	\
    (This)->lpVtbl -> SetXlcModeDDObjAndPrimarySurface(This,lpDDObj,lpPrimarySurf)

#define IVMRImagePresenterExclModeConfig_GetXlcModeDDObjAndPrimarySurface(This,lpDDObj,lpPrimarySurf)	\
    (This)->lpVtbl -> GetXlcModeDDObjAndPrimarySurface(This,lpDDObj,lpPrimarySurf)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IVMRImagePresenterExclModeConfig_SetXlcModeDDObjAndPrimarySurface_Proxy( 
    IVMRImagePresenterExclModeConfig * This,
    /* [in] */ LPDIRECTDRAW7 lpDDObj,
    /* [in] */ LPDIRECTDRAWSURFACE7 lpPrimarySurf);


void __RPC_STUB IVMRImagePresenterExclModeConfig_SetXlcModeDDObjAndPrimarySurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVMRImagePresenterExclModeConfig_GetXlcModeDDObjAndPrimarySurface_Proxy( 
    IVMRImagePresenterExclModeConfig * This,
    /* [out] */ LPDIRECTDRAW7 *lpDDObj,
    /* [out] */ LPDIRECTDRAWSURFACE7 *lpPrimarySurf);


void __RPC_STUB IVMRImagePresenterExclModeConfig_GetXlcModeDDObjAndPrimarySurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVMRImagePresenterExclModeConfig_INTERFACE_DEFINED__ */


#ifndef __IVPManager_INTERFACE_DEFINED__
#define __IVPManager_INTERFACE_DEFINED__

/* interface IVPManager */
/* [unique][helpstring][uuid][local][object][local] */ 


EXTERN_C const IID IID_IVPManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aac18c18-e186-46d2-825d-a1f8dc8e395a")
    IVPManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetVideoPortIndex( 
            /* [in] */ DWORD dwVideoPortIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVideoPortIndex( 
            /* [out] */ DWORD *pdwVideoPortIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVPManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVPManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVPManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVPManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetVideoPortIndex )( 
            IVPManager * This,
            /* [in] */ DWORD dwVideoPortIndex);
        
        HRESULT ( STDMETHODCALLTYPE *GetVideoPortIndex )( 
            IVPManager * This,
            /* [out] */ DWORD *pdwVideoPortIndex);
        
        END_INTERFACE
    } IVPManagerVtbl;

    interface IVPManager
    {
        CONST_VTBL struct IVPManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVPManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVPManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVPManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVPManager_SetVideoPortIndex(This,dwVideoPortIndex)	\
    (This)->lpVtbl -> SetVideoPortIndex(This,dwVideoPortIndex)

#define IVPManager_GetVideoPortIndex(This,pdwVideoPortIndex)	\
    (This)->lpVtbl -> GetVideoPortIndex(This,pdwVideoPortIndex)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IVPManager_SetVideoPortIndex_Proxy( 
    IVPManager * This,
    /* [in] */ DWORD dwVideoPortIndex);


void __RPC_STUB IVPManager_SetVideoPortIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVPManager_GetVideoPortIndex_Proxy( 
    IVPManager * This,
    /* [out] */ DWORD *pdwVideoPortIndex);


void __RPC_STUB IVPManager_GetVideoPortIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVPManager_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0403 */
/* [local] */ 

// Restore the previous setting for C4201 compiler warning
#pragma warning(pop)


extern RPC_IF_HANDLE __MIDL_itf_strmif_0403_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0403_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

/* [local] */ HRESULT STDMETHODCALLTYPE ICaptureGraphBuilder_FindInterface_Proxy( 
    ICaptureGraphBuilder * This,
    /* [unique][in] */ const GUID *pCategory,
    /* [in] */ IBaseFilter *pf,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppint);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ICaptureGraphBuilder_FindInterface_Stub( 
    ICaptureGraphBuilder * This,
    /* [unique][in] */ const GUID *pCategory,
    /* [in] */ IBaseFilter *pf,
    /* [in] */ REFIID riid,
    /* [out] */ IUnknown **ppint);

/* [local] */ HRESULT STDMETHODCALLTYPE ICaptureGraphBuilder2_FindInterface_Proxy( 
    ICaptureGraphBuilder2 * This,
    /* [in] */ const GUID *pCategory,
    /* [in] */ const GUID *pType,
    /* [in] */ IBaseFilter *pf,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppint);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ICaptureGraphBuilder2_FindInterface_Stub( 
    ICaptureGraphBuilder2 * This,
    /* [in] */ const GUID *pCategory,
    /* [in] */ const GUID *pType,
    /* [in] */ IBaseFilter *pf,
    /* [in] */ REFIID riid,
    /* [out] */ IUnknown **ppint);

/* [local] */ HRESULT STDMETHODCALLTYPE IKsPropertySet_Set_Proxy( 
    IKsPropertySet * This,
    /* [in] */ REFGUID guidPropSet,
    /* [in] */ DWORD dwPropID,
    /* [size_is][in] */ LPVOID pInstanceData,
    /* [in] */ DWORD cbInstanceData,
    /* [size_is][in] */ LPVOID pPropData,
    /* [in] */ DWORD cbPropData);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IKsPropertySet_Set_Stub( 
    IKsPropertySet * This,
    /* [in] */ REFGUID guidPropSet,
    /* [in] */ DWORD dwPropID,
    /* [size_is][in] */ byte *pInstanceData,
    /* [in] */ DWORD cbInstanceData,
    /* [size_is][in] */ byte *pPropData,
    /* [in] */ DWORD cbPropData);

/* [local] */ HRESULT STDMETHODCALLTYPE IKsPropertySet_Get_Proxy( 
    IKsPropertySet * This,
    /* [in] */ REFGUID guidPropSet,
    /* [in] */ DWORD dwPropID,
    /* [size_is][in] */ LPVOID pInstanceData,
    /* [in] */ DWORD cbInstanceData,
    /* [size_is][out] */ LPVOID pPropData,
    /* [in] */ DWORD cbPropData,
    /* [out] */ DWORD *pcbReturned);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IKsPropertySet_Get_Stub( 
    IKsPropertySet * This,
    /* [in] */ REFGUID guidPropSet,
    /* [in] */ DWORD dwPropID,
    /* [size_is][in] */ byte *pInstanceData,
    /* [in] */ DWORD cbInstanceData,
    /* [size_is][out] */ byte *pPropData,
    /* [in] */ DWORD cbPropData,
    /* [out] */ DWORD *pcbReturned);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DirectX\9c\Include\uuids.h ===
//------------------------------------------------------------------------------
// File: uuids.h
//
// Desc: Contains the GUIDs for the MediaType type, subtype fields and format
//       types for standard media types, and also class ids for well-known
//       components.
//
// Copyright (c) 1992 - 2002, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


//
//  We want to use this list for generating strings for debugging too
//  so we redefine OUR_GUID_ENTRY depending on what we want to do
//
//  It is imperative that all entries in this file are declared using
//  OUR_GUID_ENTRY as that macro might have been defined in advance of
//  including this file.  See wxdebug.cpp in sdk\classes\base.
//

#ifndef OUR_GUID_ENTRY
    #define OUR_GUID_ENTRY(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8);
#endif


// -- to allow consistent labeling of Media types and subtypes --

#define MEDIATYPE_NULL       GUID_NULL
#define MEDIASUBTYPE_NULL    GUID_NULL

// -- Use this subtype if you don't have a use for a subtype for your type
// e436eb8e-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_None
OUR_GUID_ENTRY(MEDIASUBTYPE_None,
0xe436eb8e, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)


// -- major types ---


// 73646976-0000-0010-8000-00AA00389B71  'vids' == MEDIATYPE_Video
OUR_GUID_ENTRY(MEDIATYPE_Video,
0x73646976, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 73647561-0000-0010-8000-00AA00389B71  'auds' == MEDIATYPE_Audio
OUR_GUID_ENTRY(MEDIATYPE_Audio,
0x73647561, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 73747874-0000-0010-8000-00AA00389B71  'txts' == MEDIATYPE_Text
OUR_GUID_ENTRY(MEDIATYPE_Text,
0x73747874, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 7364696D-0000-0010-8000-00AA00389B71  'mids' == MEDIATYPE_Midi
OUR_GUID_ENTRY(MEDIATYPE_Midi,
0x7364696D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// e436eb83-524f-11ce-9f53-0020af0ba770            MEDIATYPE_Stream
OUR_GUID_ENTRY(MEDIATYPE_Stream,
0xe436eb83, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// 73(s)76(v)61(a)69(i)-0000-0010-8000-00AA00389B71  'iavs' == MEDIATYPE_Interleaved
OUR_GUID_ENTRY(MEDIATYPE_Interleaved,
0x73766169, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 656c6966-0000-0010-8000-00AA00389B71  'file' == MEDIATYPE_File
OUR_GUID_ENTRY(MEDIATYPE_File,
0x656c6966, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 73636d64-0000-0010-8000-00AA00389B71  'scmd' == MEDIATYPE_ScriptCommand
OUR_GUID_ENTRY(MEDIATYPE_ScriptCommand,
0x73636d64, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 670AEA80-3A82-11d0-B79B-00AA003767A7            MEDIATYPE_AUXLine21Data
OUR_GUID_ENTRY(MEDIATYPE_AUXLine21Data,
0x670aea80, 0x3a82, 0x11d0, 0xb7, 0x9b, 0x0, 0xaa, 0x0, 0x37, 0x67, 0xa7)

// F72A76E1-EB0A-11D0-ACE4-0000C0CC16BA            MEDIATYPE_VBI
OUR_GUID_ENTRY(MEDIATYPE_VBI,
0xf72a76e1, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// 0482DEE3-7817-11cf-8a03-00aa006ecb65            MEDIATYPE_Timecode
OUR_GUID_ENTRY(MEDIATYPE_Timecode,
0x482dee3, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 74726c6d-0000-0010-8000-00AA00389B71  'lmrt' == MEDIATYPE_LMRT
OUR_GUID_ENTRY(MEDIATYPE_LMRT,
0x74726c6d, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 74726c6d-0000-0010-8000-00AA00389B71  'urls' == MEDIATYPE_URL_STREAM
OUR_GUID_ENTRY(MEDIATYPE_URL_STREAM,
0x736c7275, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// -- sub types ---

// 4C504C43-0000-0010-8000-00AA00389B71  'CLPL' == MEDIASUBTYPE_CLPL
OUR_GUID_ENTRY(MEDIASUBTYPE_CLPL,
0x4C504C43, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 56595559-0000-0010-8000-00AA00389B71  'YUYV' == MEDIASUBTYPE_YUYV
OUR_GUID_ENTRY(MEDIASUBTYPE_YUYV,
0x56595559, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 56555949-0000-0010-8000-00AA00389B71  'IYUV' == MEDIASUBTYPE_IYUV
OUR_GUID_ENTRY(MEDIASUBTYPE_IYUV,
0x56555949, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 39555659-0000-0010-8000-00AA00389B71  'YVU9' == MEDIASUBTYPE_YVU9
OUR_GUID_ENTRY(MEDIASUBTYPE_YVU9,
0x39555659, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 31313459-0000-0010-8000-00AA00389B71  'Y411' == MEDIASUBTYPE_Y411
OUR_GUID_ENTRY(MEDIASUBTYPE_Y411,
0x31313459, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 50313459-0000-0010-8000-00AA00389B71  'Y41P' == MEDIASUBTYPE_Y41P
OUR_GUID_ENTRY(MEDIASUBTYPE_Y41P,
0x50313459, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 32595559-0000-0010-8000-00AA00389B71  'YUY2' == MEDIASUBTYPE_YUY2
OUR_GUID_ENTRY(MEDIASUBTYPE_YUY2,
0x32595559, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 55595659-0000-0010-8000-00AA00389B71  'YVYU' == MEDIASUBTYPE_YVYU
OUR_GUID_ENTRY(MEDIASUBTYPE_YVYU,
0x55595659, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 59565955-0000-0010-8000-00AA00389B71  'UYVY' ==  MEDIASUBTYPE_UYVY
OUR_GUID_ENTRY(MEDIASUBTYPE_UYVY,
0x59565955, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 31313259-0000-0010-8000-00AA00389B71  'Y211' ==  MEDIASUBTYPE_Y211
OUR_GUID_ENTRY(MEDIASUBTYPE_Y211,
0x31313259, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 524a4c43-0000-0010-8000-00AA00389B71  'CLJR' ==  MEDIASUBTYPE_CLJR
OUR_GUID_ENTRY(MEDIASUBTYPE_CLJR,
0x524a4c43, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 39304649-0000-0010-8000-00AA00389B71  'IF09' ==  MEDIASUBTYPE_IF09
OUR_GUID_ENTRY(MEDIASUBTYPE_IF09,
0x39304649, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 414c5043-0000-0010-8000-00AA00389B71  'CPLA' ==  MEDIASUBTYPE_CPLA
OUR_GUID_ENTRY(MEDIASUBTYPE_CPLA,
0x414c5043, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 47504A4D-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_MJPG
OUR_GUID_ENTRY(MEDIASUBTYPE_MJPG,
0x47504A4D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 4A4D5654-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_TVMJ
OUR_GUID_ENTRY(MEDIASUBTYPE_TVMJ,
0x4A4D5654, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 454B4157-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_WAKE
OUR_GUID_ENTRY(MEDIASUBTYPE_WAKE,
0x454B4157, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 43434643-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_CFCC
OUR_GUID_ENTRY(MEDIASUBTYPE_CFCC,
0x43434643, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 47504A49-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_IJPG
OUR_GUID_ENTRY(MEDIASUBTYPE_IJPG,
0x47504A49, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 6D756C50-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_Plum
OUR_GUID_ENTRY(MEDIASUBTYPE_Plum,
0x6D756C50, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// FAST DV-Master
// 53435644-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_DVCS
OUR_GUID_ENTRY(MEDIASUBTYPE_DVCS,
0x53435644, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// FAST DV-Master
// 44535644-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_DVSD
OUR_GUID_ENTRY(MEDIASUBTYPE_DVSD,
0x44535644, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// MIROVideo DV
// 4656444D-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_MDVF
OUR_GUID_ENTRY(MEDIASUBTYPE_MDVF,
0x4656444D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// e436eb78-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB1
// e436eb78-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB1
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB1,
0xe436eb78, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb79-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB4
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB4,
0xe436eb79, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb7a-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB8
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB8,
0xe436eb7a, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb7b-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB565
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB565,
0xe436eb7b, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb7c-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB555
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB555,
0xe436eb7c, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb7d-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB24
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB24,
0xe436eb7d, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb7e-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB32
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB32,
0xe436eb7e, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)


//
// RGB surfaces that contain per pixel alpha values.
//

// 297C55AF-E209-4cb3-B757-C76D6B9C88A8            MEDIASUBTYPE_ARGB1555
OUR_GUID_ENTRY(MEDIASUBTYPE_ARGB1555,
0x297c55af, 0xe209, 0x4cb3, 0xb7, 0x57, 0xc7, 0x6d, 0x6b, 0x9c, 0x88, 0xa8)

// 6E6415E6-5C24-425f-93CD-80102B3D1CCA            MEDIASUBTYPE_ARGB4444
OUR_GUID_ENTRY(MEDIASUBTYPE_ARGB4444,
0x6e6415e6, 0x5c24, 0x425f, 0x93, 0xcd, 0x80, 0x10, 0x2b, 0x3d, 0x1c, 0xca)

// 773c9ac0-3274-11d0-B724-00aa006c1A01            MEDIASUBTYPE_ARGB32
OUR_GUID_ENTRY(MEDIASUBTYPE_ARGB32,
0x773c9ac0, 0x3274, 0x11d0, 0xb7, 0x24, 0x0, 0xaa, 0x0, 0x6c, 0x1a, 0x1 )


// 2f8bb76d-b644-4550-acf3-d30caa65d5c5            MEDIASUBTYPE_A2R10G10B10
OUR_GUID_ENTRY(MEDIASUBTYPE_A2R10G10B10,
0x2f8bb76d, 0xb644, 0x4550, 0xac, 0xf3, 0xd3, 0x0c, 0xaa, 0x65, 0xd5, 0xc5)

// 576f7893-bdf6-48c4-875f-ae7b81834567            MEDIASUBTYPE_A2B10G10R10
OUR_GUID_ENTRY(MEDIASUBTYPE_A2B10G10R10,
0x576f7893, 0xbdf6, 0x48c4, 0x87, 0x5f, 0xae, 0x7b, 0x81, 0x83, 0x45, 0x67)


// 56555941-0000-0010-8000-00AA00389B71  'AYUV' == MEDIASUBTYPE_AYUV
//
// See the DX-VA header and documentation for a description of this format.
//
OUR_GUID_ENTRY(MEDIASUBTYPE_AYUV,
0x56555941, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 34344941-0000-0010-8000-00AA00389B71  'AI44' == MEDIASUBTYPE_AI44
//
// See the DX-VA header and documentation for a description of this format.
//
OUR_GUID_ENTRY(MEDIASUBTYPE_AI44,
0x34344941, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 34344149-0000-0010-8000-00AA00389B71  'IA44' == MEDIASUBTYPE_IA44
//
// See the DX-VA header and documentation for a description of this format.
//
OUR_GUID_ENTRY(MEDIASUBTYPE_IA44,
0x34344149, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)


//
// DirectX7 D3D Render Target media subtypes.
//

// 32335237-0000-0010-8000-00AA00389B71  '7R32' == MEDIASUBTYPE_RGB32_D3D_DX7_RT
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB32_D3D_DX7_RT,
0x32335237, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 36315237-0000-0010-8000-00AA00389B71  '7R16' == MEDIASUBTYPE_RGB16_D3D_DX7_RT
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB16_D3D_DX7_RT,
0x36315237, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 38384137-0000-0010-8000-00AA00389B71  '7A88' == MEDIASUBTYPE_ARGB32_D3D_DX7_RT
OUR_GUID_ENTRY(MEDIASUBTYPE_ARGB32_D3D_DX7_RT,
0x38384137, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 34344137-0000-0010-8000-00AA00389B71  '7A44' == MEDIASUBTYPE_ARGB4444_D3D_DX7_RT
OUR_GUID_ENTRY(MEDIASUBTYPE_ARGB4444_D3D_DX7_RT,
0x34344137, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 35314137-0000-0010-8000-00AA00389B71  '7A15' == MEDIASUBTYPE_ARGB1555_D3D_DX7_RT
OUR_GUID_ENTRY(MEDIASUBTYPE_ARGB1555_D3D_DX7_RT,
0x35314137, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)


//
// DirectX9 D3D Render Target media subtypes.
//

// 32335239-0000-0010-8000-00AA00389B71  '9R32' == MEDIASUBTYPE_RGB32_D3D_DX9_RT
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB32_D3D_DX9_RT,
0x32335239, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 36315239-0000-0010-8000-00AA00389B71  '9R16' == MEDIASUBTYPE_RGB16_D3D_DX9_RT
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB16_D3D_DX9_RT,
0x36315239, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 38384139-0000-0010-8000-00AA00389B71  '9A88' == MEDIASUBTYPE_ARGB32_D3D_DX9_RT
OUR_GUID_ENTRY(MEDIASUBTYPE_ARGB32_D3D_DX9_RT,
0x38384139, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 34344139-0000-0010-8000-00AA00389B71  '9A44' == MEDIASUBTYPE_ARGB4444_D3D_DX9_RT
OUR_GUID_ENTRY(MEDIASUBTYPE_ARGB4444_D3D_DX9_RT,
0x34344139, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 35314139-0000-0010-8000-00AA00389B71  '9A15' == MEDIASUBTYPE_ARGB1555_D3D_DX9_RT
OUR_GUID_ENTRY(MEDIASUBTYPE_ARGB1555_D3D_DX9_RT,
0x35314139, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)


#define MEDIASUBTYPE_HASALPHA(mt) ( ((mt).subtype == MEDIASUBTYPE_ARGB4444)            || \
                                    ((mt).subtype == MEDIASUBTYPE_ARGB32)              || \
                                    ((mt).subtype == MEDIASUBTYPE_AYUV)                || \
                                    ((mt).subtype == MEDIASUBTYPE_AI44)                || \
                                    ((mt).subtype == MEDIASUBTYPE_IA44)                || \
                                    ((mt).subtype == MEDIASUBTYPE_ARGB1555)            || \
                                    ((mt).subtype == MEDIASUBTYPE_ARGB32_D3D_DX7_RT)   || \
                                    ((mt).subtype == MEDIASUBTYPE_ARGB4444_D3D_DX7_RT) || \
                                    ((mt).subtype == MEDIASUBTYPE_ARGB1555_D3D_DX7_RT) || \
                                    ((mt).subtype == MEDIASUBTYPE_ARGB32_D3D_DX9_RT)   || \
                                    ((mt).subtype == MEDIASUBTYPE_ARGB4444_D3D_DX9_RT) || \
                                    ((mt).subtype == MEDIASUBTYPE_ARGB1555_D3D_DX9_RT) )

#define MEDIASUBTYPE_HASALPHA7(mt) (((mt).subtype == MEDIASUBTYPE_ARGB32_D3D_DX7_RT)   || \
                                    ((mt).subtype == MEDIASUBTYPE_ARGB4444_D3D_DX7_RT) || \
                                    ((mt).subtype == MEDIASUBTYPE_ARGB1555_D3D_DX7_RT) )

#define MEDIASUBTYPE_D3D_DX7_RT(mt) (((mt).subtype == MEDIASUBTYPE_ARGB32_D3D_DX7_RT)   || \
                                     ((mt).subtype == MEDIASUBTYPE_ARGB4444_D3D_DX7_RT) || \
                                     ((mt).subtype == MEDIASUBTYPE_ARGB1555_D3D_DX7_RT) || \
                                     ((mt).subtype == MEDIASUBTYPE_RGB32_D3D_DX7_RT)    || \
                                     ((mt).subtype == MEDIASUBTYPE_RGB16_D3D_DX7_RT))

#define MEDIASUBTYPE_HASALPHA9(mt) (((mt).subtype == MEDIASUBTYPE_ARGB32_D3D_DX9_RT)   || \
                                    ((mt).subtype == MEDIASUBTYPE_ARGB4444_D3D_DX9_RT) || \
                                    ((mt).subtype == MEDIASUBTYPE_ARGB1555_D3D_DX9_RT) )


#define MEDIASUBTYPE_D3D_DX9_RT(mt) (((mt).subtype == MEDIASUBTYPE_ARGB32_D3D_DX9_RT)   || \
                                     ((mt).subtype == MEDIASUBTYPE_ARGB4444_D3D_DX9_RT) || \
                                     ((mt).subtype == MEDIASUBTYPE_ARGB1555_D3D_DX9_RT) || \
                                     ((mt).subtype == MEDIASUBTYPE_RGB32_D3D_DX9_RT)    || \
                                     ((mt).subtype == MEDIASUBTYPE_RGB16_D3D_DX9_RT))


//
// DX-VA uncompressed surface formats
//

// 32315659-0000-0010-8000-00AA00389B71  'YV12' ==  MEDIASUBTYPE_YV12
OUR_GUID_ENTRY(MEDIASUBTYPE_YV12,
0x32315659, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 3231564E-0000-0010-8000-00AA00389B71  'NV12' ==  MEDIASUBTYPE_NV12
OUR_GUID_ENTRY(MEDIASUBTYPE_NV12,
0x3231564E, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 31434D49-0000-0010-8000-00AA00389B71  'IMC1' ==  MEDIASUBTYPE_IMC1
OUR_GUID_ENTRY(MEDIASUBTYPE_IMC1,
0x31434D49, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 32434d49-0000-0010-8000-00AA00389B71  'IMC2' ==  MEDIASUBTYPE_IMC2
OUR_GUID_ENTRY(MEDIASUBTYPE_IMC2,
0x32434D49, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 33434d49-0000-0010-8000-00AA00389B71  'IMC3' ==  MEDIASUBTYPE_IMC3
OUR_GUID_ENTRY(MEDIASUBTYPE_IMC3,
0x33434D49, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 34434d49-0000-0010-8000-00AA00389B71  'IMC4' ==  MEDIASUBTYPE_IMC4
OUR_GUID_ENTRY(MEDIASUBTYPE_IMC4,
0x34434D49, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 30343353-0000-0010-8000-00AA00389B71  'S340' ==  MEDIASUBTYPE_S340
OUR_GUID_ENTRY(MEDIASUBTYPE_S340,
0x30343353, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 32343353-0000-0010-8000-00AA00389B71  'S342' ==  MEDIASUBTYPE_S342
OUR_GUID_ENTRY(MEDIASUBTYPE_S342,
0x32343353, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)


// e436eb7f-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_Overlay
OUR_GUID_ENTRY(MEDIASUBTYPE_Overlay,
0xe436eb7f, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb80-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEGPacket
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1Packet,
0xe436eb80, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb81-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEG1Payload
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1Payload,
0xe436eb81, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// 00000050-0000-0010-8000-00AA00389B71         MEDIASUBTYPE_MPEG1AudioPayload
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1AudioPayload,
0x00000050, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71)

// e436eb82-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEG1SystemStream
OUR_GUID_ENTRY(MEDIATYPE_MPEG1SystemStream,
0xe436eb82, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// the next consecutive number is assigned to MEDIATYPE_Stream and appears higher up
// e436eb84-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEG1System
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1System,
0xe436eb84, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb85-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEG1VideoCD
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1VideoCD,
0xe436eb85, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb86-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEG1Video
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1Video,
0xe436eb86, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb87-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEG1Audio
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1Audio,
0xe436eb87, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb88-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_Avi
OUR_GUID_ENTRY(MEDIASUBTYPE_Avi,
0xe436eb88, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// {3DB80F90-9412-11d1-ADED-0000F8754B99}          MEDIASUBTYPE_Asf
OUR_GUID_ENTRY(MEDIASUBTYPE_Asf,
0x3db80f90, 0x9412, 0x11d1, 0xad, 0xed, 0x0, 0x0, 0xf8, 0x75, 0x4b, 0x99)

// e436eb89-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_QTMovie
OUR_GUID_ENTRY(MEDIASUBTYPE_QTMovie,
0xe436eb89, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// 617a7072-0000-0010-8000-00AA00389B71         MEDIASUBTYPE_Rpza
OUR_GUID_ENTRY(MEDIASUBTYPE_QTRpza,
0x617a7072, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 20636d73-0000-0010-8000-00AA00389B71         MEDIASUBTYPE_Smc
OUR_GUID_ENTRY(MEDIASUBTYPE_QTSmc,
0x20636d73, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 20656c72-0000-0010-8000-00AA00389B71        MEDIASUBTYPE_Rle
OUR_GUID_ENTRY(MEDIASUBTYPE_QTRle,
0x20656c72, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 6765706a-0000-0010-8000-00AA00389B71        MEDIASUBTYPE_Jpeg
OUR_GUID_ENTRY(MEDIASUBTYPE_QTJpeg,
0x6765706a, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// e436eb8a-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_PCMAudio_Obsolete
OUR_GUID_ENTRY(MEDIASUBTYPE_PCMAudio_Obsolete,
0xe436eb8a, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// 00000001-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_PCM
OUR_GUID_ENTRY(MEDIASUBTYPE_PCM,
0x00000001, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71)

// e436eb8b-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_WAVE
OUR_GUID_ENTRY(MEDIASUBTYPE_WAVE,
0xe436eb8b, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb8c-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_AU
OUR_GUID_ENTRY(MEDIASUBTYPE_AU,
0xe436eb8c, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb8d-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_AIFF
OUR_GUID_ENTRY(MEDIASUBTYPE_AIFF,
0xe436eb8d, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// 64(d)73(s)76(v)64(d)-0000-0010-8000-00AA00389B71  'dvsd' == MEDIASUBTYPE_dvsd
OUR_GUID_ENTRY(MEDIASUBTYPE_dvsd,
0x64737664, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 64(d)68(h)76(v)64(d)-0000-0010-8000-00AA00389B71  'dvhd' == MEDIASUBTYPE_dvhd
OUR_GUID_ENTRY(MEDIASUBTYPE_dvhd,
0x64687664, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 6c(l)73(s)76(v)64(d)-0000-0010-8000-00AA00389B71  'dvsl' == MEDIASUBTYPE_dvsl
OUR_GUID_ENTRY(MEDIASUBTYPE_dvsl,
0x6c737664, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 35(5)32(2)76(v)64(d)-0000-0010-8000-00AA00389B71 'dv25' == MEDIASUBTYPE_dv25
OUR_GUID_ENTRY(MEDIASUBTYPE_dv25,
0x35327664, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 30(0)35(5)76(v)64(d)-0000-0010-8000-00AA00389B71 'dv50' == MEDIASUBTYPE_dv50
OUR_GUID_ENTRY(MEDIASUBTYPE_dv50,
0x30357664, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 31(1)68(h)76(v)64(d)-0000-0010-8000-00AA00389B71 'dvh1' == MEDIASUBTYPE_dvh1
OUR_GUID_ENTRY(MEDIASUBTYPE_dvh1,
0x31687664, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 6E8D4A22-310C-11d0-B79A-00AA003767A7         MEDIASUBTYPE_Line21_BytePair
OUR_GUID_ENTRY(MEDIASUBTYPE_Line21_BytePair,
0x6e8d4a22, 0x310c, 0x11d0, 0xb7, 0x9a, 0x0, 0xaa, 0x0, 0x37, 0x67, 0xa7)

// 6E8D4A23-310C-11d0-B79A-00AA003767A7         MEDIASUBTYPE_Line21_GOPPacket
OUR_GUID_ENTRY(MEDIASUBTYPE_Line21_GOPPacket,
0x6e8d4a23, 0x310c, 0x11d0, 0xb7, 0x9a, 0x0, 0xaa, 0x0, 0x37, 0x67, 0xa7)

// 6E8D4A24-310C-11d0-B79A-00AA003767A7         MEDIASUBTYPE_Line21_VBIRawData
OUR_GUID_ENTRY(MEDIASUBTYPE_Line21_VBIRawData,
0x6e8d4a24, 0x310c, 0x11d0, 0xb7, 0x9a, 0x0, 0xaa, 0x0, 0x37, 0x67, 0xa7)

// F72A76E3-EB0A-11D0-ACE4-0000C0CC16BA         MEDIASUBTYPE_TELETEXT
OUR_GUID_ENTRY(MEDIASUBTYPE_TELETEXT,
0xf72a76e3, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// 2791D576-8E7A-466F-9E90-5D3F3083738B        MEDIASUBTYPE_WSS
OUR_GUID_ENTRY(MEDIASUBTYPE_WSS,
0x2791D576, 0x8E7A, 0x466F, 0x9E, 0x90, 0x5D, 0x3F, 0x30, 0x83, 0x73, 0x8B)

// A1B3F620-9792-4d8d-81A4-86AF25772090        MEDIASUBTYPE_VPS
OUR_GUID_ENTRY(MEDIASUBTYPE_VPS,
0xa1b3f620, 0x9792, 0x4d8d, 0x81, 0xa4, 0x86, 0xaf, 0x25, 0x77, 0x20, 0x90)

// derived from WAVE_FORMAT_DRM
// 00000009-0000-0010-8000-00aa00389b71
OUR_GUID_ENTRY(MEDIASUBTYPE_DRM_Audio,
0x00000009, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// derived from WAVE_FORMAT_IEEE_FLOAT
// 00000003-0000-0010-8000-00aa00389b71
OUR_GUID_ENTRY(MEDIASUBTYPE_IEEE_FLOAT,
0x00000003, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// derived from WAVE_FORMAT_DOLBY_AC3_SPDIF
// 00000092-0000-0010-8000-00aa00389b71
OUR_GUID_ENTRY(MEDIASUBTYPE_DOLBY_AC3_SPDIF,
0x00000092, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// derived from WAVE_FORMAT_RAW_SPORT
// 00000240-0000-0010-8000-00aa00389b71
OUR_GUID_ENTRY(MEDIASUBTYPE_RAW_SPORT,
0x00000240, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// derived from wave format tag 0x241, call it SPDIF_TAG_241h for now
// 00000241-0000-0010-8000-00aa00389b71
OUR_GUID_ENTRY(MEDIASUBTYPE_SPDIF_TAG_241h,
0x00000241, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)



// DirectShow DSS definitions

// A0AF4F81-E163-11d0-BAD9-00609744111A
OUR_GUID_ENTRY(MEDIASUBTYPE_DssVideo,
0xa0af4f81, 0xe163, 0x11d0, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// A0AF4F82-E163-11d0-BAD9-00609744111A
OUR_GUID_ENTRY(MEDIASUBTYPE_DssAudio,
0xa0af4f82, 0xe163, 0x11d0, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// 5A9B6A40-1A22-11D1-BAD9-00609744111A
OUR_GUID_ENTRY(MEDIASUBTYPE_VPVideo,
0x5a9b6a40, 0x1a22, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// 5A9B6A41-1A22-11D1-BAD9-00609744111A
OUR_GUID_ENTRY(MEDIASUBTYPE_VPVBI,
0x5a9b6a41, 0x1a22, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// BF87B6E0-8C27-11d0-B3F0-00AA003761C5     Capture graph building
OUR_GUID_ENTRY(CLSID_CaptureGraphBuilder,
0xBF87B6E0, 0x8C27, 0x11d0, 0xB3, 0xF0, 0x0, 0xAA, 0x00, 0x37, 0x61, 0xC5)

// BF87B6E1-8C27-11d0-B3F0-00AA003761C5     New Capture graph building
OUR_GUID_ENTRY(CLSID_CaptureGraphBuilder2,
0xBF87B6E1, 0x8C27, 0x11d0, 0xB3, 0xF0, 0x0, 0xAA, 0x00, 0x37, 0x61, 0xC5)

// e436ebb0-524f-11ce-9f53-0020af0ba770            Prototype filtergraph
OUR_GUID_ENTRY(CLSID_ProtoFilterGraph,
0xe436ebb0, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436ebb1-524f-11ce-9f53-0020af0ba770            Reference clock
OUR_GUID_ENTRY(CLSID_SystemClock,
0xe436ebb1, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436ebb2-524f-11ce-9f53-0020af0ba770           Filter Mapper
OUR_GUID_ENTRY(CLSID_FilterMapper,
0xe436ebb2, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436ebb3-524f-11ce-9f53-0020af0ba770           Filter Graph
OUR_GUID_ENTRY(CLSID_FilterGraph,
0xe436ebb3, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436ebb8-524f-11ce-9f53-0020af0ba770           Filter Graph no thread
OUR_GUID_ENTRY(CLSID_FilterGraphNoThread,
0xe436ebb8, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e4bbd160-4269-11ce-838d-00aa0055595a           MPEG System stream
OUR_GUID_ENTRY(CLSID_MPEG1Doc,
0xe4bbd160, 0x4269, 0x11ce, 0x83, 0x8d, 0x0, 0xaa, 0x0, 0x55, 0x59, 0x5a)

// 701722e0-8ae3-11ce-a85c-00aa002feab5           MPEG file reader
OUR_GUID_ENTRY(CLSID_FileSource,
0x701722e0, 0x8ae3, 0x11ce, 0xa8, 0x5c, 0x00, 0xaa, 0x00, 0x2f, 0xea, 0xb5)

// 26C25940-4CA9-11ce-A828-00AA002FEAB5           Takes MPEG1 packets as input
OUR_GUID_ENTRY(CLSID_MPEG1PacketPlayer,
0x26c25940, 0x4ca9, 0x11ce, 0xa8, 0x28, 0x0, 0xaa, 0x0, 0x2f, 0xea, 0xb5)

// 336475d0-942a-11ce-a870-00aa002feab5           MPEG splitter
OUR_GUID_ENTRY(CLSID_MPEG1Splitter,
0x336475d0, 0x942a, 0x11ce, 0xa8, 0x70, 0x00, 0xaa, 0x00, 0x2f, 0xea, 0xb5)

// feb50740-7bef-11ce-9bd9-0000e202599c           MPEG video decoder
OUR_GUID_ENTRY(CLSID_CMpegVideoCodec,
0xfeb50740, 0x7bef, 0x11ce, 0x9b, 0xd9, 0x0, 0x0, 0xe2, 0x2, 0x59, 0x9c)

// 4a2286e0-7bef-11ce-9bd9-0000e202599c           MPEG audio decoder
OUR_GUID_ENTRY(CLSID_CMpegAudioCodec,
0x4a2286e0, 0x7bef, 0x11ce, 0x9b, 0xd9, 0x0, 0x0, 0xe2, 0x2, 0x59, 0x9c)

// e30629d3-27e5-11ce-875d-00608cb78066           Text renderer
OUR_GUID_ENTRY(CLSID_TextRender,
0xe30629d3, 0x27e5, 0x11ce, 0x87, 0x5d, 0x0, 0x60, 0x8c, 0xb7, 0x80, 0x66)



// {F8388A40-D5BB-11d0-BE5A-0080C706568E}
OUR_GUID_ENTRY(CLSID_InfTee,
0xf8388a40, 0xd5bb, 0x11d0, 0xbe, 0x5a, 0x0, 0x80, 0xc7, 0x6, 0x56, 0x8e)

// 1b544c20-fd0b-11ce-8c63-00aa0044b51e           Avi Stream Splitter
OUR_GUID_ENTRY(CLSID_AviSplitter,
0x1b544c20, 0xfd0b, 0x11ce, 0x8c, 0x63, 0x0, 0xaa, 0x00, 0x44, 0xb5, 0x1e)

// 1b544c21-fd0b-11ce-8c63-00aa0044b51e           Avi File Reader
OUR_GUID_ENTRY(CLSID_AviReader,
0x1b544c21, 0xfd0b, 0x11ce, 0x8c, 0x63, 0x0, 0xaa, 0x00, 0x44, 0xb5, 0x1e)

// 1b544c22-fd0b-11ce-8c63-00aa0044b51e           Vfw 2.0 Capture Driver
OUR_GUID_ENTRY(CLSID_VfwCapture,
0x1b544c22, 0xfd0b, 0x11ce, 0x8c, 0x63, 0x0, 0xaa, 0x00, 0x44, 0xb5, 0x1e)

OUR_GUID_ENTRY(CLSID_CaptureProperties,
0x1B544c22, 0xFD0B, 0x11ce, 0x8C, 0x63, 0x00, 0xAA, 0x00, 0x44, 0xB5, 0x1F)

//e436ebb4-524f-11ce-9f53-0020af0ba770            Control Distributor
OUR_GUID_ENTRY(CLSID_FGControl,
0xe436ebb4, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// 44584800-F8EE-11ce-B2D4-00DD01101B85           .MOV reader (old)
OUR_GUID_ENTRY(CLSID_MOVReader,
0x44584800, 0xf8ee, 0x11ce, 0xb2, 0xd4, 0x00, 0xdd, 0x1, 0x10, 0x1b, 0x85)

// D51BD5A0-7548-11cf-A520-0080C77EF58A           QT Splitter
OUR_GUID_ENTRY(CLSID_QuickTimeParser,
0xd51bd5a0, 0x7548, 0x11cf, 0xa5, 0x20, 0x0, 0x80, 0xc7, 0x7e, 0xf5, 0x8a)

// FDFE9681-74A3-11d0-AFA7-00AA00B67A42           QT Decoder
OUR_GUID_ENTRY(CLSID_QTDec,
0xfdfe9681, 0x74a3, 0x11d0, 0xaf, 0xa7, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)

// D3588AB0-0781-11ce-B03A-0020AF0BA770           AVIFile-based reader
OUR_GUID_ENTRY(CLSID_AVIDoc,
0xd3588ab0, 0x0781, 0x11ce, 0xb0, 0x3a, 0x00, 0x20, 0xaf, 0xb, 0xa7, 0x70)

// 70e102b0-5556-11ce-97c0-00aa0055595a           Video renderer
OUR_GUID_ENTRY(CLSID_VideoRenderer,
0x70e102b0, 0x5556, 0x11ce, 0x97, 0xc0, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 1643e180-90f5-11ce-97d5-00aa0055595a           Colour space convertor
OUR_GUID_ENTRY(CLSID_Colour,
0x1643e180, 0x90f5, 0x11ce, 0x97, 0xd5, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 1da08500-9edc-11cf-bc10-00aa00ac74f6           VGA 16 color ditherer
OUR_GUID_ENTRY(CLSID_Dither,
0x1da08500, 0x9edc, 0x11cf, 0xbc, 0x10, 0x00, 0xaa, 0x00, 0xac, 0x74, 0xf6)

// 07167665-5011-11cf-BF33-00AA0055595A           Modex video renderer
OUR_GUID_ENTRY(CLSID_ModexRenderer,
0x7167665, 0x5011, 0x11cf, 0xbf, 0x33, 0x0, 0xaa, 0x0, 0x55, 0x59, 0x5a)

// e30629d1-27e5-11ce-875d-00608cb78066           Waveout audio renderer
OUR_GUID_ENTRY(CLSID_AudioRender,
0xe30629d1, 0x27e5, 0x11ce, 0x87, 0x5d, 0x0, 0x60, 0x8c, 0xb7, 0x80, 0x66)

// 05589faf-c356-11ce-bf01-00aa0055595a           Audio Renderer Property Page
OUR_GUID_ENTRY(CLSID_AudioProperties,
0x05589faf, 0xc356, 0x11ce, 0xbf, 0x01, 0x0, 0xaa, 0x0, 0x55, 0x59, 0x5a)

// 79376820-07D0-11cf-A24D-0020AFD79767           DSound audio renderer
OUR_GUID_ENTRY(CLSID_DSoundRender,
0x79376820, 0x07D0, 0x11CF, 0xA2, 0x4D, 0x0, 0x20, 0xAF, 0xD7, 0x97, 0x67)

// e30629d2-27e5-11ce-875d-00608cb78066           Wavein audio recorder
OUR_GUID_ENTRY(CLSID_AudioRecord,
0xe30629d2, 0x27e5, 0x11ce, 0x87, 0x5d, 0x0, 0x60, 0x8c, 0xb7, 0x80, 0x66)

// {2CA8CA52-3C3F-11d2-B73D-00C04FB6BD3D}         IAMAudioInputMixer property page
OUR_GUID_ENTRY(CLSID_AudioInputMixerProperties,
0x2ca8ca52, 0x3c3f, 0x11d2, 0xb7, 0x3d, 0x0, 0xc0, 0x4f, 0xb6, 0xbd, 0x3d)

// {CF49D4E0-1115-11ce-B03A-0020AF0BA770}         AVI Decoder
OUR_GUID_ENTRY(CLSID_AVIDec,
0xcf49d4e0, 0x1115, 0x11ce, 0xb0, 0x3a, 0x0, 0x20, 0xaf, 0xb, 0xa7, 0x70)

// {A888DF60-1E90-11cf-AC98-00AA004C0FA9}         AVI ICDraw* wrapper
OUR_GUID_ENTRY(CLSID_AVIDraw,
0xa888df60, 0x1e90, 0x11cf, 0xac, 0x98, 0x0, 0xaa, 0x0, 0x4c, 0xf, 0xa9)

// 6a08cf80-0e18-11cf-a24d-0020afd79767       ACM Wrapper
OUR_GUID_ENTRY(CLSID_ACMWrapper,
0x6a08cf80, 0x0e18, 0x11cf, 0xa2, 0x4d, 0x0, 0x20, 0xaf, 0xd7, 0x97, 0x67)

// {e436ebb5-524f-11ce-9f53-0020af0ba770}    Async File Reader
OUR_GUID_ENTRY(CLSID_AsyncReader,
0xe436ebb5, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// {e436ebb6-524f-11ce-9f53-0020af0ba770}    Async URL Reader
OUR_GUID_ENTRY(CLSID_URLReader,
0xe436ebb6, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// {e436ebb7-524f-11ce-9f53-0020af0ba770}    IPersistMoniker PID
OUR_GUID_ENTRY(CLSID_PersistMonikerPID,
0xe436ebb7, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// {D76E2820-1563-11cf-AC98-00AA004C0FA9}
OUR_GUID_ENTRY(CLSID_AVICo,
0xd76e2820, 0x1563, 0x11cf, 0xac, 0x98, 0x0, 0xaa, 0x0, 0x4c, 0xf, 0xa9)

// {8596E5F0-0DA5-11d0-BD21-00A0C911CE86}
OUR_GUID_ENTRY(CLSID_FileWriter,
0x8596e5f0, 0xda5, 0x11d0, 0xbd, 0x21, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// {E2510970-F137-11CE-8B67-00AA00A3F1A6}     AVI mux filter
OUR_GUID_ENTRY(CLSID_AviDest,
0xe2510970, 0xf137, 0x11ce, 0x8b, 0x67, 0x0, 0xaa, 0x0, 0xa3, 0xf1, 0xa6)

// {C647B5C0-157C-11d0-BD23-00A0C911CE86}
OUR_GUID_ENTRY(CLSID_AviMuxProptyPage,
0xc647b5c0, 0x157c, 0x11d0, 0xbd, 0x23, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// {0A9AE910-85C0-11d0-BD42-00A0C911CE86}
OUR_GUID_ENTRY(CLSID_AviMuxProptyPage1,
0xa9ae910, 0x85c0, 0x11d0, 0xbd, 0x42, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// {07b65360-c445-11ce-afde-00aa006c14f4}
OUR_GUID_ENTRY(CLSID_AVIMIDIRender,
0x07b65360, 0xc445, 0x11ce, 0xaf, 0xde, 0x00, 0xaa, 0x00, 0x6c, 0x14, 0xf4)

// {187463A0-5BB7-11d3-ACBE-0080C75E246E}    WMSDK-based ASF reader
OUR_GUID_ENTRY(CLSID_WMAsfReader,
0x187463a0, 0x5bb7, 0x11d3, 0xac, 0xbe, 0x0, 0x80, 0xc7, 0x5e, 0x24, 0x6e)

// {7c23220e-55bb-11d3-8b16-00c04fb6bd3d}    WMSDK-based ASF writer
OUR_GUID_ENTRY(CLSID_WMAsfWriter,
0x7c23220e, 0x55bb, 0x11d3, 0x8b, 0x16, 0x0, 0xc0, 0x4f, 0xb6, 0xbd, 0x3d)

//  {afb6c280-2c41-11d3-8a60-0000f81e0e4a}
OUR_GUID_ENTRY(CLSID_MPEG2Demultiplexer,
0xafb6c280, 0x2c41, 0x11d3, 0x8a, 0x60, 0x00, 0x00, 0xf8, 0x1e, 0x0e, 0x4a)

// {3ae86b20-7be8-11d1-abe6-00a0c905f375}
OUR_GUID_ENTRY(CLSID_MMSPLITTER,
0x3ae86b20, 0x7be8, 0x11d1, 0xab, 0xe6, 0x00, 0xa0, 0xc9, 0x05, 0xf3, 0x75)

// {2DB47AE5-CF39-43c2-B4D6-0CD8D90946F4}
OUR_GUID_ENTRY(CLSID_StreamBufferSink,
0x2db47ae5, 0xcf39, 0x43c2, 0xb4, 0xd6, 0xc, 0xd8, 0xd9, 0x9, 0x46, 0xf4)

// {C9F5FE02-F851-4eb5-99EE-AD602AF1E619}
OUR_GUID_ENTRY(CLSID_StreamBufferSource,
0xc9f5fe02, 0xf851, 0x4eb5, 0x99, 0xee, 0xad, 0x60, 0x2a, 0xf1, 0xe6, 0x19)

// {FA8A68B2-C864-4ba2-AD53-D3876A87494B}
OUR_GUID_ENTRY(CLSID_StreamBufferConfig,
0xfa8a68b2, 0xc864, 0x4ba2, 0xad, 0x53, 0xd3, 0x87, 0x6a, 0x87, 0x49, 0x4b)

// {6CFAD761-735D-4aa5-8AFC-AF91A7D61EBA}
OUR_GUID_ENTRY(CLSID_Mpeg2VideoStreamAnalyzer,
0x6cfad761, 0x735d, 0x4aa5, 0x8a, 0xfc, 0xaf, 0x91, 0xa7, 0xd6, 0x1e, 0xba)

// {CCAA63AC-1057-4778-AE92-1206AB9ACEE6}
OUR_GUID_ENTRY(CLSID_StreamBufferRecordingAttributes,
0xccaa63ac, 0x1057, 0x4778, 0xae, 0x92, 0x12, 0x6, 0xab, 0x9a, 0xce, 0xe6)

// {D682C4BA-A90A-42fe-B9E1-03109849C423}
OUR_GUID_ENTRY(CLSID_StreamBufferComposeRecording,
0xd682c4ba, 0xa90a, 0x42fe, 0xb9, 0xe1, 0x3, 0x10, 0x98, 0x49, 0xc4, 0x23)

// {B1B77C00-C3E4-11cf-AF79-00AA00B67A42}               DV video decoder
OUR_GUID_ENTRY(CLSID_DVVideoCodec,
0xb1b77c00, 0xc3e4, 0x11cf, 0xaf, 0x79, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)

// {13AA3650-BB6F-11d0-AFB9-00AA00B67A42}               DV video encoder
OUR_GUID_ENTRY(CLSID_DVVideoEnc,
0x13aa3650, 0xbb6f, 0x11d0, 0xaf, 0xb9, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)

// {4EB31670-9FC6-11cf-AF6E-00AA00B67A42}               DV splitter
OUR_GUID_ENTRY(CLSID_DVSplitter,
0x4eb31670, 0x9fc6, 0x11cf, 0xaf, 0x6e, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)

// {129D7E40-C10D-11d0-AFB9-00AA00B67A42}               DV muxer
OUR_GUID_ENTRY(CLSID_DVMux,
0x129d7e40, 0xc10d, 0x11d0, 0xaf, 0xb9, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)

// {060AF76C-68DD-11d0-8FC1-00C04FD9189D}
OUR_GUID_ENTRY(CLSID_SeekingPassThru,
0x60af76c, 0x68dd, 0x11d0, 0x8f, 0xc1, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d)

// 6E8D4A20-310C-11d0-B79A-00AA003767A7                 Line21 (CC) Decoder
OUR_GUID_ENTRY(CLSID_Line21Decoder,
0x6e8d4a20, 0x310c, 0x11d0, 0xb7, 0x9a, 0x0, 0xaa, 0x0, 0x37, 0x67, 0xa7)

// E4206432-01A1-4BEE-B3E1-3702C8EDC574                 Line21 (CC) Decoder v2
OUR_GUID_ENTRY(CLSID_Line21Decoder2,
0xe4206432, 0x01a1, 0x4bee, 0xb3, 0xe1, 0x37, 0x02, 0xc8, 0xed, 0xc5, 0x74)

// {CD8743A1-3736-11d0-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(CLSID_OverlayMixer,
0xcd8743a1, 0x3736, 0x11d0, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)

// {814B9800-1C88-11d1-BAD9-00609744111A}
OUR_GUID_ENTRY(CLSID_VBISurfaces,
0x814b9800, 0x1c88, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// {70BC06E0-5666-11d3-A184-00105AEF9F33}               WST Teletext Decoder
OUR_GUID_ENTRY(CLSID_WSTDecoder,
0x70bc06e0, 0x5666, 0x11d3, 0xa1, 0x84, 0x0, 0x10, 0x5a, 0xef, 0x9f, 0x33)

// {301056D0-6DFF-11d2-9EEB-006008039E37}
OUR_GUID_ENTRY(CLSID_MjpegDec,
0x301056d0, 0x6dff, 0x11d2, 0x9e, 0xeb, 0x0, 0x60, 0x8, 0x3, 0x9e, 0x37)

// {B80AB0A0-7416-11d2-9EEB-006008039E37}
OUR_GUID_ENTRY(CLSID_MJPGEnc,
0xb80ab0a0, 0x7416, 0x11d2, 0x9e, 0xeb, 0x0, 0x60, 0x8, 0x3, 0x9e, 0x37)



// pnp objects and categories
// 62BE5D10-60EB-11d0-BD3B-00A0C911CE86                 ICreateDevEnum
OUR_GUID_ENTRY(CLSID_SystemDeviceEnum,
0x62BE5D10,0x60EB,0x11d0,0xBD,0x3B,0x00,0xA0,0xC9,0x11,0xCE,0x86)

// 4315D437-5B8C-11d0-BD3B-00A0C911CE86
OUR_GUID_ENTRY(CLSID_CDeviceMoniker,
0x4315D437,0x5B8C,0x11d0,0xBD,0x3B,0x00,0xA0,0xC9,0x11,0xCE,0x86)

// 860BB310-5D01-11d0-BD3B-00A0C911CE86                 Video capture category
OUR_GUID_ENTRY(CLSID_VideoInputDeviceCategory,
0x860BB310,0x5D01,0x11d0,0xBD,0x3B,0x00,0xA0,0xC9,0x11,0xCE,0x86)
OUR_GUID_ENTRY(CLSID_CVidCapClassManager,
0x860BB310,0x5D01,0x11d0,0xBD,0x3B,0x00,0xA0,0xC9,0x11,0xCE,0x86)

// 083863F1-70DE-11d0-BD40-00A0C911CE86                 Filter category
OUR_GUID_ENTRY(CLSID_LegacyAmFilterCategory,
0x083863F1,0x70DE,0x11d0,0xBD,0x40,0x00,0xA0,0xC9,0x11,0xCE,0x86)
OUR_GUID_ENTRY(CLSID_CQzFilterClassManager,
0x083863F1,0x70DE,0x11d0,0xBD,0x40,0x00,0xA0,0xC9,0x11,0xCE,0x86)

// 33D9A760-90C8-11d0-BD43-00A0C911CE86
OUR_GUID_ENTRY(CLSID_VideoCompressorCategory,
0x33d9a760, 0x90c8, 0x11d0, 0xbd, 0x43, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)
OUR_GUID_ENTRY(CLSID_CIcmCoClassManager,
0x33d9a760, 0x90c8, 0x11d0, 0xbd, 0x43, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// 33D9A761-90C8-11d0-BD43-00A0C911CE86
OUR_GUID_ENTRY(CLSID_AudioCompressorCategory,
0x33d9a761, 0x90c8, 0x11d0, 0xbd, 0x43, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)
OUR_GUID_ENTRY(CLSID_CAcmCoClassManager,
0x33d9a761, 0x90c8, 0x11d0, 0xbd, 0x43, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// 33D9A762-90C8-11d0-BD43-00A0C911CE86                 Audio source cateogry
OUR_GUID_ENTRY(CLSID_AudioInputDeviceCategory,
0x33d9a762, 0x90c8, 0x11d0, 0xbd, 0x43, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)
OUR_GUID_ENTRY(CLSID_CWaveinClassManager,
0x33d9a762, 0x90c8, 0x11d0, 0xbd, 0x43, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// E0F158E1-CB04-11d0-BD4E-00A0C911CE86                 Audio renderer category
OUR_GUID_ENTRY(CLSID_AudioRendererCategory,
0xe0f158e1, 0xcb04, 0x11d0, 0xbd, 0x4e, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)
OUR_GUID_ENTRY(CLSID_CWaveOutClassManager,
0xe0f158e1, 0xcb04, 0x11d0, 0xbd, 0x4e, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// 4EFE2452-168A-11d1-BC76-00C04FB9453B                 Midi renderer category
OUR_GUID_ENTRY(CLSID_MidiRendererCategory,
0x4EfE2452, 0x168A, 0x11d1, 0xBC, 0x76, 0x0, 0xc0, 0x4F, 0xB9, 0x45, 0x3B)
OUR_GUID_ENTRY(CLSID_CMidiOutClassManager,
0x4EfE2452, 0x168A, 0x11d1, 0xBC, 0x76, 0x0, 0xc0, 0x4F, 0xB9, 0x45, 0x3B)

// CC7BFB41-F175-11d1-A392-00E0291F3959     External Renderers Category
OUR_GUID_ENTRY(CLSID_TransmitCategory,
0xcc7bfb41, 0xf175, 0x11d1, 0xa3, 0x92, 0x0, 0xe0, 0x29, 0x1f, 0x39, 0x59)

// CC7BFB46-F175-11d1-A392-00E0291F3959     Device Control Filters
OUR_GUID_ENTRY(CLSID_DeviceControlCategory,
0xcc7bfb46, 0xf175, 0x11d1, 0xa3, 0x92, 0x0, 0xe0, 0x29, 0x1f, 0x39, 0x59)

// DA4E3DA0-D07D-11d0-BD50-00A0C911CE86
OUR_GUID_ENTRY(CLSID_ActiveMovieCategories,
0xda4e3da0, 0xd07d, 0x11d0, 0xbd, 0x50, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// 2721AE20-7E70-11D0-A5D6-28DB04C10000
OUR_GUID_ENTRY(CLSID_DVDHWDecodersCategory,
0x2721AE20, 0x7E70, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00)

// 7D22E920-5CA9-4787-8C2B-A6779BD11781     Encoder API encoder category
OUR_GUID_ENTRY(CLSID_MediaEncoderCategory,
0x7D22E920, 0x5CA9, 0x4787, 0x8C, 0x2B, 0xA6, 0x77, 0x9B, 0xD1, 0x17, 0x81)

// 236C9559-ADCE-4736-BF72-BAB34E392196     Encoder API multiplexer category
OUR_GUID_ENTRY(CLSID_MediaMultiplexerCategory,
0x236C9559, 0xADCE, 0x4736, 0xBF, 0x72, 0xBA, 0xB3, 0x4E, 0x39, 0x21, 0x96)

// CDA42200-BD88-11d0-BD4E-00A0C911CE86
OUR_GUID_ENTRY(CLSID_FilterMapper2,
0xcda42200, 0xbd88, 0x11d0, 0xbd, 0x4e, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)


// 1e651cc0-b199-11d0-8212-00c04fc32c45
OUR_GUID_ENTRY(CLSID_MemoryAllocator,
0x1e651cc0, 0xb199, 0x11d0, 0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45)

// CDBD8D00-C193-11d0-BD4E-00A0C911CE86
OUR_GUID_ENTRY(CLSID_MediaPropertyBag,
0xcdbd8d00, 0xc193, 0x11d0, 0xbd, 0x4e, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// FCC152B7-F372-11d0-8E00-00C04FD7C08B
OUR_GUID_ENTRY(CLSID_DvdGraphBuilder,
0xFCC152B7, 0xF372, 0x11d0, 0x8E, 0x00, 0x00, 0xC0, 0x4F, 0xD7, 0xC0, 0x8B)

// 9B8C4620-2C1A-11d0-8493-00A02438AD48
OUR_GUID_ENTRY(CLSID_DVDNavigator,
0x9b8c4620, 0x2c1a, 0x11d0, 0x84, 0x93, 0x0, 0xa0, 0x24, 0x38, 0xad, 0x48)

// f963c5cf-a659-4a93-9638-caf3cd277d13
OUR_GUID_ENTRY(CLSID_DVDState,
0xf963c5cf, 0xa659, 0x4a93, 0x96, 0x38, 0xca, 0xf3, 0xcd, 0x27, 0x7d, 0x13)

// CC58E280-8AA1-11d1-B3F1-00AA003761C5
OUR_GUID_ENTRY(CLSID_SmartTee,
0xcc58e280, 0x8aa1, 0x11d1, 0xb3, 0xf1, 0x0, 0xaa, 0x0, 0x37, 0x61, 0xc5)

// -- format types ---

// 0F6417D6-C318-11D0-A43F-00A0C9223196        FORMAT_None
OUR_GUID_ENTRY(FORMAT_None,
0x0F6417D6, 0xc318, 0x11d0, 0xa4, 0x3f, 0x00, 0xa0, 0xc9, 0x22, 0x31, 0x96)

// 05589f80-c356-11ce-bf01-00aa0055595a        FORMAT_VideoInfo
OUR_GUID_ENTRY(FORMAT_VideoInfo,
0x05589f80, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// F72A76A0-EB0A-11d0-ACE4-0000C0CC16BA        FORMAT_VideoInfo2
OUR_GUID_ENTRY(FORMAT_VideoInfo2,
0xf72a76A0, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// 05589f81-c356-11ce-bf01-00aa0055595a        FORMAT_WaveFormatEx
OUR_GUID_ENTRY(FORMAT_WaveFormatEx,
0x05589f81, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 05589f82-c356-11ce-bf01-00aa0055595a        FORMAT_MPEGVideo
OUR_GUID_ENTRY(FORMAT_MPEGVideo,
0x05589f82, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 05589f83-c356-11ce-bf01-00aa0055595a        FORMAT_MPEGStreams
OUR_GUID_ENTRY(FORMAT_MPEGStreams,
0x05589f83, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 05589f84-c356-11ce-bf01-00aa0055595a        FORMAT_DvInfo, DVINFO
OUR_GUID_ENTRY(FORMAT_DvInfo,
0x05589f84, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)


// -- Video related GUIDs ---


// 944d4c00-dd52-11ce-bf0e-00aa0055595a
OUR_GUID_ENTRY(CLSID_DirectDrawProperties,
0x944d4c00, 0xdd52, 0x11ce, 0xbf, 0x0e, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 59ce6880-acf8-11cf-b56e-0080c7c4b68a
OUR_GUID_ENTRY(CLSID_PerformanceProperties,
0x59ce6880, 0xacf8, 0x11cf, 0xb5, 0x6e, 0x00, 0x80, 0xc7, 0xc4, 0xb6, 0x8a)

// 418afb70-f8b8-11ce-aac6-0020af0b99a3
OUR_GUID_ENTRY(CLSID_QualityProperties,
0x418afb70, 0xf8b8, 0x11ce, 0xaa, 0xc6, 0x00, 0x20, 0xaf, 0x0b, 0x99, 0xa3)

// 61ded640-e912-11ce-a099-00aa00479a58
OUR_GUID_ENTRY(IID_IBaseVideoMixer,
0x61ded640, 0xe912, 0x11ce, 0xa0, 0x99, 0x00, 0xaa, 0x00, 0x47, 0x9a, 0x58)

// 36d39eb0-dd75-11ce-bf0e-00aa0055595a
OUR_GUID_ENTRY(IID_IDirectDrawVideo,
0x36d39eb0, 0xdd75, 0x11ce, 0xbf, 0x0e, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// bd0ecb0-f8e2-11ce-aac6-0020af0b99a3
OUR_GUID_ENTRY(IID_IQualProp,
0x1bd0ecb0, 0xf8e2, 0x11ce, 0xaa, 0xc6, 0x00, 0x20, 0xaf, 0x0b, 0x99, 0xa3)

// {CE292861-FC88-11d0-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(CLSID_VPObject,
0xce292861, 0xfc88, 0x11d0, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)

// {CE292862-FC88-11d0-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(IID_IVPObject,
0xce292862, 0xfc88, 0x11d0, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)

// {25DF12C1-3DE0-11d1-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(IID_IVPControl,
0x25df12c1, 0x3de0, 0x11d1, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)

// {814B9801-1C88-11d1-BAD9-00609744111A}
OUR_GUID_ENTRY(CLSID_VPVBIObject,
0x814b9801, 0x1c88, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// {814B9802-1C88-11d1-BAD9-00609744111A}
OUR_GUID_ENTRY(IID_IVPVBIObject,
0x814b9802, 0x1c88, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// {BC29A660-30E3-11d0-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(IID_IVPConfig,
0xbc29a660, 0x30e3, 0x11d0, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)

// {C76794A1-D6C5-11d0-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(IID_IVPNotify,
0xc76794a1, 0xd6c5, 0x11d0, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)

// {EBF47183-8764-11d1-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(IID_IVPNotify2,
0xebf47183, 0x8764, 0x11d1, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)


// {EC529B00-1A1F-11D1-BAD9-00609744111A}
OUR_GUID_ENTRY(IID_IVPVBIConfig,
0xec529b00, 0x1a1f, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// {EC529B01-1A1F-11D1-BAD9-00609744111A}
OUR_GUID_ENTRY(IID_IVPVBINotify,
0xec529b01, 0x1a1f, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// {593CDDE1-0759-11d1-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(IID_IMixerPinConfig,
0x593cdde1, 0x759, 0x11d1, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)

// {EBF47182-8764-11d1-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(IID_IMixerPinConfig2,
0xebf47182, 0x8764, 0x11d1, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)


// This is a real pain in the neck. The OLE GUIDs are separated out into a
// different file from the main header files. The header files can then be
// included multiple times and are protected with the following statements,
//
//      #ifndef __SOMETHING_DEFINED__
//      #define __SOMETHING_DEFINED__
//          all the header contents
//      #endif // __SOMETHING_DEFINED__
//
// When the actual GUIDs are to be defined (using initguid) the GUID header
// file can then be included to really define them just once. Unfortunately
// DirectDraw has the GUIDs defined in the main header file. So if the base
// classes bring in ddraw.h to get at the DirectDraw structures and so on
// nobody would then be able to really include ddraw.h to allocate the GUID
// memory structures because of the aforementioned header file protection
// Therefore the DirectDraw GUIDs are defined and allocated for real here

#ifndef __DDRAW_INCLUDED__
OUR_GUID_ENTRY(CLSID_DirectDraw,            0xD7B70EE0,0x4340,0x11CF,0xB0,0x63,0x00,0x20,0xAF,0xC2,0xCD,0x35)
OUR_GUID_ENTRY(CLSID_DirectDrawClipper,     0x593817A0,0x7DB3,0x11CF,0xA2,0xDE,0x00,0xAA,0x00,0xb9,0x33,0x56)
OUR_GUID_ENTRY(IID_IDirectDraw,             0x6C14DB80,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60)
OUR_GUID_ENTRY(IID_IDirectDraw2,            0xB3A6F3E0,0x2B43,0x11CF,0xA2,0xDE,0x00,0xAA,0x00,0xB9,0x33,0x56)
OUR_GUID_ENTRY(IID_IDirectDrawSurface,      0x6C14DB81,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60)
OUR_GUID_ENTRY(IID_IDirectDrawSurface2,     0x57805885,0x6eec,0x11cf,0x94,0x41,0xa8,0x23,0x03,0xc1,0x0e,0x27)
OUR_GUID_ENTRY(IID_IDirectDrawSurface3,     0xDA044E00,0x69B2,0x11D0,0xA1,0xD5,0x00,0xAA,0x00,0xB8,0xDF,0xBB)
OUR_GUID_ENTRY(IID_IDirectDrawSurface4,     0x0B2B8630,0xAD35,0x11D0,0x8E,0xA6,0x00,0x60,0x97,0x97,0xEA,0x5B)
OUR_GUID_ENTRY(IID_IDirectDrawSurface7,     0x06675a80,0x3b9b,0x11d2,0xb9,0x2f,0x00,0x60,0x97,0x97,0xea,0x5b)
OUR_GUID_ENTRY(IID_IDirectDrawPalette,      0x6C14DB84,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60)
OUR_GUID_ENTRY(IID_IDirectDrawClipper,      0x6C14DB85,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60)
OUR_GUID_ENTRY(IID_IDirectDrawColorControl, 0x4B9F0EE0,0x0D7E,0x11D0,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8)
#endif

#ifndef __DVP_INCLUDED__
OUR_GUID_ENTRY(IID_IDDVideoPortContainer,    0x6C142760,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60)
#endif

#ifndef __DDKM_INCLUDED__
OUR_GUID_ENTRY(IID_IDirectDrawKernel,        0x8D56C120,0x6A08,0x11D0,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8)
OUR_GUID_ENTRY(IID_IDirectDrawSurfaceKernel, 0x60755DA0,0x6A40,0x11D0,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8)
#endif

// 0618aa30-6bc4-11cf-bf36-00aa0055595a
OUR_GUID_ENTRY(CLSID_ModexProperties,
0x0618aa30, 0x6bc4, 0x11cf, 0xbf, 0x36, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// dd1d7110-7836-11cf-bf47-00aa0055595a
OUR_GUID_ENTRY(IID_IFullScreenVideo,
0xdd1d7110, 0x7836, 0x11cf, 0xbf, 0x47, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 53479470-f1dd-11cf-bc42-00aa00ac74f6
OUR_GUID_ENTRY(IID_IFullScreenVideoEx,
0x53479470, 0xf1dd, 0x11cf, 0xbc, 0x42, 0x00, 0xaa, 0x00, 0xac, 0x74, 0xf6)

// {101193C0-0BFE-11d0-AF91-00AA00B67A42}           DV decoder property
OUR_GUID_ENTRY(CLSID_DVDecPropertiesPage,
0x101193c0, 0xbfe, 0x11d0, 0xaf, 0x91, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)

// {4150F050-BB6F-11d0-AFB9-00AA00B67A42}           DV encoder property
OUR_GUID_ENTRY(CLSID_DVEncPropertiesPage,
0x4150f050, 0xbb6f, 0x11d0, 0xaf, 0xb9, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)

// {4DB880E0-C10D-11d0-AFB9-00AA00B67A42}           DV Muxer property
OUR_GUID_ENTRY(CLSID_DVMuxPropertyPage,
0x4db880e0, 0xc10d, 0x11d0, 0xaf, 0xb9, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)


// -- Direct Sound Audio related GUID ---

// 546F4260-D53E-11cf-B3F0-00AA003761C5
OUR_GUID_ENTRY(IID_IAMDirectSound,
0x546f4260, 0xd53e, 0x11cf, 0xb3, 0xf0, 0x0, 0xaa, 0x0, 0x37, 0x61, 0xc5)

// -- MPEG audio decoder properties

// {b45dd570-3c77-11d1-abe1-00a0c905f375}
OUR_GUID_ENTRY(IID_IMpegAudioDecoder,
0xb45dd570, 0x3c77, 0x11d1, 0xab, 0xe1, 0x00, 0xa0, 0xc9, 0x05, 0xf3, 0x75)

// --- Line21 Decoder interface GUID ---

// 6E8D4A21-310C-11d0-B79A-00AA003767A7            IID_IAMLine21Decoder
OUR_GUID_ENTRY(IID_IAMLine21Decoder,
0x6e8d4a21, 0x310c, 0x11d0, 0xb7, 0x9a, 0x0, 0xaa, 0x0, 0x37, 0x67, 0xa7)

// --- WST Decoder interface GUID ---

// C056DE21-75C2-11d3-A184-00105AEF9F33            IID_IAMWstDecoder
OUR_GUID_ENTRY(IID_IAMWstDecoder,
0xc056de21, 0x75c2, 0x11d3, 0xa1, 0x84, 0x0, 0x10, 0x5a, 0xef, 0x9f, 0x33)

// --- WST Decoder Property Page ---

// 04E27F80-91E4-11d3-A184-00105AEF9F33            WST Decoder Property Page
OUR_GUID_ENTRY(CLSID_WstDecoderPropertyPage,
0x4e27f80, 0x91e4, 0x11d3, 0xa1, 0x84, 0x0, 0x10, 0x5a, 0xef, 0x9f, 0x33)


// -- Analog video related GUIDs ---


// -- format types ---
// 0482DDE0-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(FORMAT_AnalogVideo,
0x482dde0, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)


// -- major type, Analog Video

// 0482DDE1-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIATYPE_AnalogVideo,
0x482dde1, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)


// -- Analog Video subtypes, NTSC

// 0482DDE2-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_NTSC_M,
0x482dde2, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// -- Analog Video subtypes, PAL

// 0482DDE5-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_B,
0x482dde5, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDE6-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_D,
0x482dde6, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDE7-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_G,
0x482dde7, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDE8-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_H,
0x482dde8, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDE9-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_I,
0x482dde9, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDEA-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_M,
0x482ddea, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDEB-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_N,
0x482ddeb, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDEC-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_N_COMBO,
0x482ddec, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// -- Analog Video subtypes, SECAM

// 0482DDF0-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_B,
0x482ddf0, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDF1-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_D,
0x482ddf1, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDF2-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_G,
0x482ddf2, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDF3-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_H,
0x482ddf3, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDF4-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_K,
0x482ddf4, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDF5-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_K1,
0x482ddf5, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDF6-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_L,
0x482ddf6, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)


// --  External audio related GUIDs ---

// -- major types, Analog Audio

// 0482DEE1-7817-11cf-8a03-00aa006ecb65
OUR_GUID_ENTRY(MEDIATYPE_AnalogAudio,
0x482dee1, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

//
// DirectShow's include file based on ksmedia.h from WDM DDK
//
#include "ksuuids.h"


// -- Well known time format GUIDs ---


// 00000000-0000-0000-0000-000000000000
OUR_GUID_ENTRY(TIME_FORMAT_NONE,
0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)

// 7b785570-8c82-11cf-bc0c-00aa00ac74f6
OUR_GUID_ENTRY(TIME_FORMAT_FRAME,
0x7b785570, 0x8c82, 0x11cf, 0xbc, 0xc, 0x0, 0xaa, 0x0, 0xac, 0x74, 0xf6)

// 7b785571-8c82-11cf-bc0c-00aa00ac74f6
OUR_GUID_ENTRY(TIME_FORMAT_BYTE,
0x7b785571, 0x8c82, 0x11cf, 0xbc, 0xc, 0x0, 0xaa, 0x0, 0xac, 0x74, 0xf6)

// 7b785572-8c82-11cf-bc0c-00aa00ac74f6
OUR_GUID_ENTRY(TIME_FORMAT_SAMPLE,
0x7b785572, 0x8c82, 0x11cf, 0xbc, 0xc, 0x0, 0xaa, 0x0, 0xac, 0x74, 0xf6)

// 7b785573-8c82-11cf-bc0c-00aa00ac74f6
OUR_GUID_ENTRY(TIME_FORMAT_FIELD,
0x7b785573, 0x8c82, 0x11cf, 0xbc, 0xc, 0x0, 0xaa, 0x0, 0xac, 0x74, 0xf6)


// 7b785574-8c82-11cf-bc0c-00aa00ac74f6
OUR_GUID_ENTRY(TIME_FORMAT_MEDIA_TIME,
0x7b785574, 0x8c82, 0x11cf, 0xbc, 0xc, 0x0, 0xaa, 0x0, 0xac, 0x74, 0xf6)


// for IKsPropertySet

// 9B00F101-1567-11d1-B3F1-00AA003761C5
OUR_GUID_ENTRY(AMPROPSETID_Pin,
0x9b00f101, 0x1567, 0x11d1, 0xb3, 0xf1, 0x0, 0xaa, 0x0, 0x37, 0x61, 0xc5)

// fb6c4281-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_CAPTURE,
0xfb6c4281, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4282-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_PREVIEW,
0xfb6c4282, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4283-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_ANALOGVIDEOIN,
0xfb6c4283, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4284-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_VBI,
0xfb6c4284, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4285-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_VIDEOPORT,
0xfb6c4285, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4286-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_NABTS,
0xfb6c4286, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4287-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_EDS,
0xfb6c4287, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4288-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_TELETEXT,
0xfb6c4288, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4289-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_CC,
0xfb6c4289, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c428a-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_STILL,
0xfb6c428a, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c428b-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_TIMECODE,
0xfb6c428b, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c428c-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_VIDEOPORT_VBI,
0xfb6c428c, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)


// the following special GUIDS are used by ICaptureGraphBuilder::FindInterface

// {AC798BE0-98E3-11d1-B3F1-00AA003761C5}
OUR_GUID_ENTRY(LOOK_UPSTREAM_ONLY,
0xac798be0, 0x98e3, 0x11d1, 0xb3, 0xf1, 0x0, 0xaa, 0x0, 0x37, 0x61, 0xc5)

// {AC798BE1-98E3-11d1-B3F1-00AA003761C5}
OUR_GUID_ENTRY(LOOK_DOWNSTREAM_ONLY,
0xac798be1, 0x98e3, 0x11d1, 0xb3, 0xf1, 0x0, 0xaa, 0x0, 0x37, 0x61, 0xc5)

// -------------------------------------------------------------------------
// KSProxy GUIDS
// -------------------------------------------------------------------------

// {266EEE41-6C63-11cf-8A03-00AA006ECB65}
OUR_GUID_ENTRY(CLSID_TVTunerFilterPropertyPage,
0x266eee41, 0x6c63, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// {71F96461-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_CrossbarFilterPropertyPage,
0x71f96461, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56)

// {71F96463-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_TVAudioFilterPropertyPage,
0x71f96463, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56)

// {71F96464-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_VideoProcAmpPropertyPage,
0x71f96464, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56)

// {71F96465-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_CameraControlPropertyPage,
0x71f96465, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56)

// {71F96466-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_AnalogVideoDecoderPropertyPage,
0x71f96466, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56)

// {71F96467-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_VideoStreamConfigPropertyPage,
0x71f96467, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56)

// {37E92A92-D9AA-11d2-BF84-8EF2B1555AED} Audio Renderer Advanced Property Page
OUR_GUID_ENTRY(CLSID_AudioRendererAdvancedProperties,
0x37e92a92, 0xd9aa, 0x11d2, 0xbf, 0x84, 0x8e, 0xf2, 0xb1, 0x55, 0x5a, 0xed)


// -------------------------------------------------------------------------
// VMR GUIDS
// -------------------------------------------------------------------------

// {B87BEB7B-8D29-423f-AE4D-6582C10175AC}
OUR_GUID_ENTRY(CLSID_VideoMixingRenderer,
0xB87BEB7B, 0x8D29, 0x423f, 0xAE, 0x4D, 0x65, 0x82, 0xC1, 0x01, 0x75, 0xAC)

// {6BC1CFFA-8FC1-4261-AC22-CFB4CC38DB50}
OUR_GUID_ENTRY(CLSID_VideoRendererDefault,
0x6BC1CFFA, 0x8FC1, 0x4261, 0xAC, 0x22, 0xCF, 0xB4, 0xCC, 0x38, 0xDB, 0x50)

// {99d54f63-1a69-41ae-aa4d-c976eb3f0713}
OUR_GUID_ENTRY(CLSID_AllocPresenter,
0x99d54f63, 0x1a69, 0x41ae, 0xaa, 0x4d, 0xc9, 0x76, 0xeb, 0x3f, 0x07, 0x13)

// {4444ac9e-242e-471b-a3c7-45dcd46352bc}
OUR_GUID_ENTRY(CLSID_AllocPresenterDDXclMode,
0x4444ac9e, 0x242e, 0x471b, 0xa3, 0xc7, 0x45, 0xdc, 0xd4, 0x63, 0x52, 0xbc)

// {6f26a6cd-967b-47fd-874a-7aed2c9d25a2}
OUR_GUID_ENTRY(CLSID_VideoPortManager,
0x6f26a6cd, 0x967b, 0x47fd, 0x87, 0x4a, 0x7a, 0xed, 0x2c, 0x9d, 0x25, 0xa2)


// -------------------------------------------------------------------------
// VMR GUIDS for DX9
// -------------------------------------------------------------------------

// {51b4abf3-748f-4e3b-a276-c828330e926a}
OUR_GUID_ENTRY(CLSID_VideoMixingRenderer9,
0x51b4abf3, 0x748f, 0x4e3b, 0xa2, 0x76, 0xc8, 0x28, 0x33, 0x0e, 0x92, 0x6a)




// -------------------------------------------------------------------------
// BDA Network Provider GUIDS
// -------------------------------------------------------------------------

// {0DAD2FDD-5FD7-11D3-8F50-00C04F7971E2}
OUR_GUID_ENTRY(CLSID_ATSCNetworkProvider,
0x0dad2fdd, 0x5fd7, 0x11d3, 0x8f, 0x50, 0x00, 0xc0, 0x4f, 0x79, 0x71, 0xe2)

// {E3444D16-5AC4-4386-88DF-13FD230E1DDA}
OUR_GUID_ENTRY(CLSID_ATSCNetworkPropertyPage,
0xe3444d16, 0x5ac4, 0x4386, 0x88, 0xdf, 0x13, 0xfd, 0x23, 0x0e, 0x1d, 0xda)

// {FA4B375A-45B4-4d45-8440-263957B11623}
OUR_GUID_ENTRY(CLSID_DVBSNetworkProvider,
0xfa4b375a, 0x45b4, 0x4d45, 0x84, 0x40, 0x26, 0x39, 0x57, 0xb1, 0x16, 0x23)

// {216C62DF-6D7F-4e9a-8571-05F14EDB766A}
OUR_GUID_ENTRY(CLSID_DVBTNetworkProvider,
0x216c62df, 0x6d7f, 0x4e9a, 0x85, 0x71, 0x5, 0xf1, 0x4e, 0xdb, 0x76, 0x6a)

// {DC0C0FE7-0485-4266-B93F-68FBF80ED834}
OUR_GUID_ENTRY(CLSID_DVBCNetworkProvider,
0xdc0c0fe7, 0x485, 0x4266, 0xb9, 0x3f, 0x68, 0xfb, 0xf8, 0xe, 0xd8, 0x34)




// -------------------------------------------------------------------------
// TVE Receiver filter guids
// -------------------------------------------------------------------------

// The CLSID used by the TVE Receiver filter
// {05500280-FAA5-4DF9-8246-BFC23AC5CEA8}
OUR_GUID_ENTRY(CLSID_DShowTVEFilter,
0x05500280, 0xFAA5, 0x4DF9, 0x82, 0x46, 0xBF, 0xC2, 0x3A, 0xC5, 0xCE, 0xA8)

// {05500281-FAA5-4DF9-8246-BFC23AC5CEA8}
OUR_GUID_ENTRY(CLSID_TVEFilterTuneProperties,
0x05500281, 0xFAA5, 0x4DF9, 0x82, 0x46, 0xBF, 0xC2, 0x3A, 0xC5, 0xCE, 0xA8)


// {05500282-FAA5-4DF9-8246-BFC23AC5CEA8}
OUR_GUID_ENTRY(CLSID_TVEFilterCCProperties,
0x05500282, 0xFAA5, 0x4DF9, 0x82, 0x46, 0xBF, 0xC2, 0x3A, 0xC5, 0xCE, 0xA8)

// {05500283-FAA5-4DF9-8246-BFC23AC5CEA8}
OUR_GUID_ENTRY(CLSID_TVEFilterStatsProperties,
0x05500283, 0xFAA5, 0x4DF9, 0x82, 0x46, 0xBF, 0xC2, 0x3A, 0xC5, 0xCE, 0xA8)

// -------------------------------------------------------------------------
// Defined ENCAPI parameter GUIDs
// -------------------------------------------------------------------------

// The CLSID for the original IVideoEncoder proxy plug-in
// {B43C4EEC-8C32-4791-9102-508ADA5EE8E7}
OUR_GUID_ENTRY(CLSID_IVideoEncoderProxy,
0xb43c4eec, 0x8c32, 0x4791, 0x91, 0x2, 0x50, 0x8a, 0xda, 0x5e, 0xe8, 0xe7)

// The CLSID for the ICodecAPI proxy plug-in
// {7ff0997a-1999-4286-a73c-622b8814e7eb}
OUR_GUID_ENTRY(CLSID_ICodecAPIProxy,
0x7ff0997a, 0x1999, 0x4286, 0xa7, 0x3c, 0x62, 0x2b, 0x88, 0x14, 0xe7, 0xeb )

// The CLSID for the combination ICodecAPI/IVideoEncoder proxy plug-in
// {b05dabd9-56e5-4fdc-afa4-8a47e91f1c9c}
OUR_GUID_ENTRY(CLSID_IVideoEncoderCodecAPIProxy,
0xb05dabd9, 0x56e5, 0x4fdc, 0xaf, 0xa4, 0x8a, 0x47, 0xe9, 0x1f, 0x1c, 0x9c )

#ifndef __ENCODER_API_GUIDS__
#define __ENCODER_API_GUIDS__

// {49CC4C43-CA83-4ad4-A9AF-F3696AF666DF}
OUR_GUID_ENTRY(ENCAPIPARAM_BITRATE,
0x49cc4c43, 0xca83, 0x4ad4, 0xa9, 0xaf, 0xf3, 0x69, 0x6a, 0xf6, 0x66, 0xdf)

// {703F16A9-3D48-44a1-B077-018DFF915D19}
OUR_GUID_ENTRY(ENCAPIPARAM_PEAK_BITRATE,
0x703f16a9, 0x3d48, 0x44a1, 0xb0, 0x77, 0x1, 0x8d, 0xff, 0x91, 0x5d, 0x19)

// {EE5FB25C-C713-40d1-9D58-C0D7241E250F}
OUR_GUID_ENTRY(ENCAPIPARAM_BITRATE_MODE,
0xee5fb25c, 0xc713, 0x40d1, 0x9d, 0x58, 0xc0, 0xd7, 0x24, 0x1e, 0x25, 0xf)

// for kernel control

// {62b12acf-f6b0-47d9-9456-96f22c4e0b9d}
OUR_GUID_ENTRY(CODECAPI_CHANGELISTS,
0x62b12acf, 0xf6b0, 0x47d9, 0x94, 0x56, 0x96, 0xf2, 0x2c, 0x4e, 0x0b, 0x9d)

// {7112e8e1-3d03-47ef-8e60-03f1cf537301 }
OUR_GUID_ENTRY(CODECAPI_VIDEO_ENCODER,
0x7112e8e1, 0x3d03, 0x47ef, 0x8e, 0x60, 0x03, 0xf1, 0xcf, 0x53, 0x73, 0x01)

// {b9d19a3e-f897-429c-bc46-8138b7272b2d }
OUR_GUID_ENTRY(CODECAPI_AUDIO_ENCODER,
0xb9d19a3e, 0xf897, 0x429c, 0xbc, 0x46, 0x81, 0x38, 0xb7, 0x27, 0x2b, 0x2d)

// {6c5e6a7c-acf8-4f55-a999-1a628109051b }
OUR_GUID_ENTRY(CODECAPI_SETALLDEFAULTS,
0x6c5e6a7c, 0xacf8, 0x4f55, 0xa9, 0x99, 0x1a, 0x62, 0x81, 0x09, 0x05, 0x1b)

// {6a577e92-83e1-4113-adc2-4fcec32f83a1 }
OUR_GUID_ENTRY(CODECAPI_ALLSETTINGS,
0x6a577e92, 0x83e1, 0x4113, 0xad, 0xc2, 0x4f, 0xce, 0xc3, 0x2f, 0x83, 0xa1)

// {0581af97-7693-4dbd-9dca-3f9ebd6585a1 }
OUR_GUID_ENTRY(CODECAPI_SUPPORTSEVENTS,
0x0581af97, 0x7693, 0x4dbd, 0x9d, 0xca, 0x3f, 0x9e, 0xbd, 0x65, 0x85, 0xa1 )

// {1cb14e83-7d72-4657-83fd-47a2c5b9d13d }
OUR_GUID_ENTRY(CODECAPI_CURRENTCHANGELIST,
0x1cb14e83, 0x7d72, 0x4657, 0x83, 0xfd, 0x47, 0xa2, 0xc5, 0xb9, 0xd1, 0x3d )

#endif // __ENCODER_API_GUIDS__

#undef OUR_GUID_ENTRY
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DirectX\9c\Include\tvratings.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0357 */
/* Compiler settings for tvratings.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __tvratings_h__
#define __tvratings_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IXDSToRat_FWD_DEFINED__
#define __IXDSToRat_FWD_DEFINED__
typedef interface IXDSToRat IXDSToRat;
#endif 	/* __IXDSToRat_FWD_DEFINED__ */


#ifndef __IEvalRat_FWD_DEFINED__
#define __IEvalRat_FWD_DEFINED__
typedef interface IEvalRat IEvalRat;
#endif 	/* __IEvalRat_FWD_DEFINED__ */


#ifndef __XDSToRat_FWD_DEFINED__
#define __XDSToRat_FWD_DEFINED__

#ifdef __cplusplus
typedef class XDSToRat XDSToRat;
#else
typedef struct XDSToRat XDSToRat;
#endif /* __cplusplus */

#endif 	/* __XDSToRat_FWD_DEFINED__ */


#ifndef __EvalRat_FWD_DEFINED__
#define __EvalRat_FWD_DEFINED__

#ifdef __cplusplus
typedef class EvalRat EvalRat;
#else
typedef struct EvalRat EvalRat;
#endif /* __cplusplus */

#endif 	/* __EvalRat_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_tvratings_0000 */
/* [local] */ 

typedef /* [public][public][public][public][public][public][public][public] */ 
enum __MIDL___MIDL_itf_tvratings_0000_0001
    {	MPAA	= 0,
	US_TV	= 1,
	Canadian_English	= 2,
	Canadian_French	= 3,
	Reserved4	= 4,
	System5	= 5,
	System6	= 6,
	Reserved7	= 7,
	TvRat_kSystems	= 8,
	TvRat_SystemDontKnow	= 255
    } 	EnTvRat_System;

typedef /* [public][public][public][public][public][public][public][public] */ 
enum __MIDL___MIDL_itf_tvratings_0000_0002
    {	TvRat_0	= 0,
	TvRat_1	= 1,
	TvRat_2	= 2,
	TvRat_3	= 3,
	TvRat_4	= 4,
	TvRat_5	= 5,
	TvRat_6	= 6,
	TvRat_7	= 7,
	TvRat_kLevels	= 8,
	TvRat_LevelDontKnow	= 255
    } 	EnTvRat_GenericLevel;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_tvratings_0000_0003
    {	MPAA_NotApplicable	= TvRat_0,
	MPAA_G	= TvRat_1,
	MPAA_PG	= TvRat_2,
	MPAA_PG13	= TvRat_3,
	MPAA_R	= TvRat_4,
	MPAA_NC17	= TvRat_5,
	MPAA_X	= TvRat_6,
	MPAA_NotRated	= TvRat_7
    } 	EnTvRat_MPAA;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_tvratings_0000_0004
    {	US_TV_None	= TvRat_0,
	US_TV_Y	= TvRat_1,
	US_TV_Y7	= TvRat_2,
	US_TV_G	= TvRat_3,
	US_TV_PG	= TvRat_4,
	US_TV_14	= TvRat_5,
	US_TV_MA	= TvRat_6,
	US_TV_None7	= TvRat_7
    } 	EnTvRat_US_TV;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_tvratings_0000_0005
    {	CAE_TV_Exempt	= TvRat_0,
	CAE_TV_C	= TvRat_1,
	CAE_TV_C8	= TvRat_2,
	CAE_TV_G	= TvRat_3,
	CAE_TV_PG	= TvRat_4,
	CAE_TV_14	= TvRat_5,
	CAE_TV_18	= TvRat_6,
	CAE_TV_Reserved	= TvRat_7
    } 	EnTvRat_CAE_TV;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_tvratings_0000_0006
    {	CAF_TV_Exempt	= TvRat_0,
	CAF_TV_G	= TvRat_1,
	CAF_TV_8	= TvRat_2,
	CAF_TV_13	= TvRat_3,
	CAF_TV_16	= TvRat_4,
	CAF_TV_18	= TvRat_5,
	CAF_TV_Reserved6	= TvRat_6,
	CAF_TV_Reserved	= TvRat_7
    } 	EnTvRat_CAF_TV;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_tvratings_0000_0007
    {	BfAttrNone	= 0,
	BfIsBlocked	= 1,
	BfIsAttr_1	= 2,
	BfIsAttr_2	= 4,
	BfIsAttr_3	= 8,
	BfIsAttr_4	= 16,
	BfIsAttr_5	= 32,
	BfIsAttr_6	= 64,
	BfIsAttr_7	= 128,
	BfValidAttrSubmask	= 255
    } 	BfEnTvRat_GenericAttributes;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_tvratings_0000_0008
    {	US_TV_IsBlocked	= BfIsBlocked,
	US_TV_IsViolent	= BfIsAttr_1,
	US_TV_IsSexualSituation	= BfIsAttr_2,
	US_TV_IsAdultLanguage	= BfIsAttr_3,
	US_TV_IsSexuallySuggestiveDialog	= BfIsAttr_4,
	US_TV_ValidAttrSubmask	= 31
    } 	BfEnTvRat_Attributes_US_TV;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_tvratings_0000_0009
    {	MPAA_IsBlocked	= BfIsBlocked,
	MPAA_ValidAttrSubmask	= 1
    } 	BfEnTvRat_Attributes_MPAA;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_tvratings_0000_0010
    {	CAE_IsBlocked	= BfIsBlocked,
	CAE_ValidAttrSubmask	= 1
    } 	BfEnTvRat_Attributes_CAE_TV;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_tvratings_0000_0011
    {	CAF_IsBlocked	= BfIsBlocked,
	CAF_ValidAttrSubmask	= 1
    } 	BfEnTvRat_Attributes_CAF_TV;



extern RPC_IF_HANDLE __MIDL_itf_tvratings_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_tvratings_0000_v0_0_s_ifspec;

#ifndef __IXDSToRat_INTERFACE_DEFINED__
#define __IXDSToRat_INTERFACE_DEFINED__

/* interface IXDSToRat */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IXDSToRat;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C5C5C5B0-3ABC-11D6-B25B-00C04FA0C026")
    IXDSToRat : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Init( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ParseXDSBytePair( 
            /* [in] */ BYTE byte1,
            /* [in] */ BYTE byte2,
            /* [out] */ EnTvRat_System *pEnSystem,
            /* [out] */ EnTvRat_GenericLevel *pEnLevel,
            /* [out] */ LONG *plBfEnAttributes) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXDSToRatVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXDSToRat * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXDSToRat * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXDSToRat * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXDSToRat * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXDSToRat * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXDSToRat * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXDSToRat * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Init )( 
            IXDSToRat * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ParseXDSBytePair )( 
            IXDSToRat * This,
            /* [in] */ BYTE byte1,
            /* [in] */ BYTE byte2,
            /* [out] */ EnTvRat_System *pEnSystem,
            /* [out] */ EnTvRat_GenericLevel *pEnLevel,
            /* [out] */ LONG *plBfEnAttributes);
        
        END_INTERFACE
    } IXDSToRatVtbl;

    interface IXDSToRat
    {
        CONST_VTBL struct IXDSToRatVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXDSToRat_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXDSToRat_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXDSToRat_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXDSToRat_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXDSToRat_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXDSToRat_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXDSToRat_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXDSToRat_Init(This)	\
    (This)->lpVtbl -> Init(This)

#define IXDSToRat_ParseXDSBytePair(This,byte1,byte2,pEnSystem,pEnLevel,plBfEnAttributes)	\
    (This)->lpVtbl -> ParseXDSBytePair(This,byte1,byte2,pEnSystem,pEnLevel,plBfEnAttributes)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXDSToRat_Init_Proxy( 
    IXDSToRat * This);


void __RPC_STUB IXDSToRat_Init_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXDSToRat_ParseXDSBytePair_Proxy( 
    IXDSToRat * This,
    /* [in] */ BYTE byte1,
    /* [in] */ BYTE byte2,
    /* [out] */ EnTvRat_System *pEnSystem,
    /* [out] */ EnTvRat_GenericLevel *pEnLevel,
    /* [out] */ LONG *plBfEnAttributes);


void __RPC_STUB IXDSToRat_ParseXDSBytePair_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXDSToRat_INTERFACE_DEFINED__ */


#ifndef __IEvalRat_INTERFACE_DEFINED__
#define __IEvalRat_INTERFACE_DEFINED__

/* interface IEvalRat */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IEvalRat;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C5C5C5B1-3ABC-11D6-B25B-00C04FA0C026")
    IEvalRat : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BlockedRatingAttributes( 
            /* [in] */ EnTvRat_System enSystem,
            /* [in] */ EnTvRat_GenericLevel enLevel,
            /* [retval][out] */ LONG *plbfAttrs) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_BlockedRatingAttributes( 
            /* [in] */ EnTvRat_System enSystem,
            /* [in] */ EnTvRat_GenericLevel enLevel,
            /* [in] */ LONG lbfAttrs) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BlockUnRated( 
            /* [retval][out] */ BOOL *pfBlockUnRatedShows) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_BlockUnRated( 
            /* [in] */ BOOL fBlockUnRatedShows) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE MostRestrictiveRating( 
            /* [in] */ EnTvRat_System enSystem1,
            /* [in] */ EnTvRat_GenericLevel enEnLevel1,
            /* [in] */ LONG lbfEnAttr1,
            /* [in] */ EnTvRat_System enSystem2,
            /* [in] */ EnTvRat_GenericLevel enEnLevel2,
            /* [in] */ LONG lbfEnAttr2,
            /* [out] */ EnTvRat_System *penSystem,
            /* [out] */ EnTvRat_GenericLevel *penEnLevel,
            /* [out] */ LONG *plbfEnAttr) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE TestRating( 
            /* [in] */ EnTvRat_System enShowSystem,
            /* [in] */ EnTvRat_GenericLevel enShowLevel,
            /* [in] */ LONG lbfEnShowAttributes) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEvalRatVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEvalRat * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEvalRat * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEvalRat * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IEvalRat * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IEvalRat * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IEvalRat * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IEvalRat * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BlockedRatingAttributes )( 
            IEvalRat * This,
            /* [in] */ EnTvRat_System enSystem,
            /* [in] */ EnTvRat_GenericLevel enLevel,
            /* [retval][out] */ LONG *plbfAttrs);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BlockedRatingAttributes )( 
            IEvalRat * This,
            /* [in] */ EnTvRat_System enSystem,
            /* [in] */ EnTvRat_GenericLevel enLevel,
            /* [in] */ LONG lbfAttrs);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BlockUnRated )( 
            IEvalRat * This,
            /* [retval][out] */ BOOL *pfBlockUnRatedShows);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BlockUnRated )( 
            IEvalRat * This,
            /* [in] */ BOOL fBlockUnRatedShows);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *MostRestrictiveRating )( 
            IEvalRat * This,
            /* [in] */ EnTvRat_System enSystem1,
            /* [in] */ EnTvRat_GenericLevel enEnLevel1,
            /* [in] */ LONG lbfEnAttr1,
            /* [in] */ EnTvRat_System enSystem2,
            /* [in] */ EnTvRat_GenericLevel enEnLevel2,
            /* [in] */ LONG lbfEnAttr2,
            /* [out] */ EnTvRat_System *penSystem,
            /* [out] */ EnTvRat_GenericLevel *penEnLevel,
            /* [out] */ LONG *plbfEnAttr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *TestRating )( 
            IEvalRat * This,
            /* [in] */ EnTvRat_System enShowSystem,
            /* [in] */ EnTvRat_GenericLevel enShowLevel,
            /* [in] */ LONG lbfEnShowAttributes);
        
        END_INTERFACE
    } IEvalRatVtbl;

    interface IEvalRat
    {
        CONST_VTBL struct IEvalRatVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEvalRat_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEvalRat_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEvalRat_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEvalRat_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IEvalRat_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IEvalRat_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IEvalRat_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IEvalRat_get_BlockedRatingAttributes(This,enSystem,enLevel,plbfAttrs)	\
    (This)->lpVtbl -> get_BlockedRatingAttributes(This,enSystem,enLevel,plbfAttrs)

#define IEvalRat_put_BlockedRatingAttributes(This,enSystem,enLevel,lbfAttrs)	\
    (This)->lpVtbl -> put_BlockedRatingAttributes(This,enSystem,enLevel,lbfAttrs)

#define IEvalRat_get_BlockUnRated(This,pfBlockUnRatedShows)	\
    (This)->lpVtbl -> get_BlockUnRated(This,pfBlockUnRatedShows)

#define IEvalRat_put_BlockUnRated(This,fBlockUnRatedShows)	\
    (This)->lpVtbl -> put_BlockUnRated(This,fBlockUnRatedShows)

#define IEvalRat_MostRestrictiveRating(This,enSystem1,enEnLevel1,lbfEnAttr1,enSystem2,enEnLevel2,lbfEnAttr2,penSystem,penEnLevel,plbfEnAttr)	\
    (This)->lpVtbl -> MostRestrictiveRating(This,enSystem1,enEnLevel1,lbfEnAttr1,enSystem2,enEnLevel2,lbfEnAttr2,penSystem,penEnLevel,plbfEnAttr)

#define IEvalRat_TestRating(This,enShowSystem,enShowLevel,lbfEnShowAttributes)	\
    (This)->lpVtbl -> TestRating(This,enShowSystem,enShowLevel,lbfEnShowAttributes)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEvalRat_get_BlockedRatingAttributes_Proxy( 
    IEvalRat * This,
    /* [in] */ EnTvRat_System enSystem,
    /* [in] */ EnTvRat_GenericLevel enLevel,
    /* [retval][out] */ LONG *plbfAttrs);


void __RPC_STUB IEvalRat_get_BlockedRatingAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IEvalRat_put_BlockedRatingAttributes_Proxy( 
    IEvalRat * This,
    /* [in] */ EnTvRat_System enSystem,
    /* [in] */ EnTvRat_GenericLevel enLevel,
    /* [in] */ LONG lbfAttrs);


void __RPC_STUB IEvalRat_put_BlockedRatingAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEvalRat_get_BlockUnRated_Proxy( 
    IEvalRat * This,
    /* [retval][out] */ BOOL *pfBlockUnRatedShows);


void __RPC_STUB IEvalRat_get_BlockUnRated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IEvalRat_put_BlockUnRated_Proxy( 
    IEvalRat * This,
    /* [in] */ BOOL fBlockUnRatedShows);


void __RPC_STUB IEvalRat_put_BlockUnRated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IEvalRat_MostRestrictiveRating_Proxy( 
    IEvalRat * This,
    /* [in] */ EnTvRat_System enSystem1,
    /* [in] */ EnTvRat_GenericLevel enEnLevel1,
    /* [in] */ LONG lbfEnAttr1,
    /* [in] */ EnTvRat_System enSystem2,
    /* [in] */ EnTvRat_GenericLevel enEnLevel2,
    /* [in] */ LONG lbfEnAttr2,
    /* [out] */ EnTvRat_System *penSystem,
    /* [out] */ EnTvRat_GenericLevel *penEnLevel,
    /* [out] */ LONG *plbfEnAttr);


void __RPC_STUB IEvalRat_MostRestrictiveRating_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IEvalRat_TestRating_Proxy( 
    IEvalRat * This,
    /* [in] */ EnTvRat_System enShowSystem,
    /* [in] */ EnTvRat_GenericLevel enShowLevel,
    /* [in] */ LONG lbfEnShowAttributes);


void __RPC_STUB IEvalRat_TestRating_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEvalRat_INTERFACE_DEFINED__ */



#ifndef __TVRATINGSLib_LIBRARY_DEFINED__
#define __TVRATINGSLib_LIBRARY_DEFINED__

/* library TVRATINGSLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_TVRATINGSLib;

EXTERN_C const CLSID CLSID_XDSToRat;

#ifdef __cplusplus

class DECLSPEC_UUID("C5C5C5F0-3ABC-11D6-B25B-00C04FA0C026")
XDSToRat;
#endif

EXTERN_C const CLSID CLSID_EvalRat;

#ifdef __cplusplus

class DECLSPEC_UUID("C5C5C5F1-3ABC-11D6-B25B-00C04FA0C026")
EvalRat;
#endif
#endif /* __TVRATINGSLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DirectX\9c\Include\tune.h ===
//------------------------------------------------------------------------------
// File: Tune.h
//
// Desc: Additional infrastructure to extend the tuner.idl.  Works nicely
//       from C++.
//
// Copyright (c) 1999 - 2001, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#pragma once

#ifndef TUNE_H
#define TUNE_H

#include <tuner.h>

namespace BDATuningModel {

const long DEFAULT_MIN_CHANNEL = 2;
const long DEFAULT_MAX_CHANNEL = 999;
const long DEFAULT_MIN_FREQUENCY = 535;  //bottom us am
const long DEFAULT_MAX_FREQUENCY = 108000; // top us fm
const long DEFAULT_ANALOG_TUNER_COUNTRY_CODE = 1; //usa
const TunerInputType DEFAULT_ANALOG_TUNER_INPUT_TYPE = TunerInputCable; //usa

typedef CComQIPtr<ITuningSpaceContainer> PQTuningSpaceContainer;
typedef CComQIPtr<ITuningSpace> PQTuningSpace;
typedef CComQIPtr<IAnalogRadioTuningSpace> PQAnalogRadioTuningSpace;
typedef CComQIPtr<IAnalogTVTuningSpace> PQAnalogTVTuningSpace;
typedef CComQIPtr<IATSCTuningSpace> PQATSCTuningSpace;
typedef CComQIPtr<ITuneRequest> PQTuneRequest;
typedef CComQIPtr<IChannelTuneRequest> PQChannelTuneRequest;
typedef CComQIPtr<IATSCChannelTuneRequest> PQATSCChannelTuneRequest;
typedef CComQIPtr<ILocator> PQLocator;
typedef CComQIPtr<IATSCLocator> PQATSCLocator;
typedef CComQIPtr<IDVBTuningSpace> PQDVBTuningSpace;
typedef CComQIPtr<IDVBTuneRequest> PQDVBTuneRequest;
typedef CComQIPtr<IDVBSLocator> PQDVBSLocator;
typedef CComQIPtr<IDVBTLocator> PQDVBTLocator;
typedef CComQIPtr<IDVBCLocator> PQDVBCLocator;
typedef CComQIPtr<IAuxInTuningSpace> PQAuxInTuningSpace;

// tuning space container
class TNTuningSpaceContainer : public PQTuningSpaceContainer {
     TNTuningSpaceContainer() {}
     TNTuningSpaceContainer(const PQTuningSpaceContainer &a) : PQTuningSpaceContainer(a) {}
     TNTuningSpaceContainer(ITuningSpace *p) : PQTuningSpaceContainer(p) {}
     TNTuningSpaceContainer(IUnknown *p) : PQTuningSpaceContainer(p) {}
     TNTuningSpaceContainer(const TNTuningSpaceContainer &a) : PQTuningSpaceContainer(a) {}
     TNTuningSpaceContainer& operator=(TNTuningSpaceContainer& rhs) {
        PQTuningSpaceContainer::operator=(rhs);
        return *this;
    }

};

// tuning spaces
template<class TUNINGSPACETYPE, class TUNEREQUESTTYPE> class TNTuningSpaceHelper : public TUNINGSPACETYPE {
public:
    TNTuningSpaceHelper() {}
    TNTuningSpaceHelper(const TUNINGSPACETYPE &a) : TUNINGSPACETYPE(a) {}
    TNTuningSpaceHelper(ITuningSpace *p) : TUNINGSPACETYPE(p) {}
    TNTuningSpaceHelper(IUnknown *p) : TUNINGSPACETYPE(p) {}
    TNTuningSpaceHelper(const TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE> &a) : TUNINGSPACETYPE(a) {}
    TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& operator=(TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& rhs) {
        TUNINGSPACETYPE::operator=(rhs);
        return *this;
    }
    TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& operator=(TUNINGSPACETYPE& rhs) {
        TUNINGSPACETYPE::operator=(rhs);
        return *this;
    }
    TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& operator=(IUnknown *rhs) {
        TUNINGSPACETYPE::operator=(rhs);
        return *this;
    }
    TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& operator=(ITuningSpace *rhs) {
        TUNINGSPACETYPE::operator=(rhs);
        return *this;
    }
    bool  operator==(TUNINGSPACETYPE& rhs) {
        CComBSTR rhsname;
        HRESULT hr = rhs->get_UniqueName(&rhsname);
        if (FAILED(hr)) {
            return false;
        }
        CComBSTR name;
        hr = (*this)->get_UniqueName(&name);
        if (FAILED(hr)) {
            return false;
        }
        return name == rhsname;
    }
    bool  operator!=(TUNINGSPACETYPE& rhs) {
        return !operator==(rhs);
    }
    PQTuneRequest CreateTuneRequest() {
        PQTuneRequest p;
        HRESULT hr = (*this)->CreateTuneRequest(&p);
        if (FAILED(hr)) {
            return PQTuneRequest();
        }
        return p;
    }

    PQLocator Locator() {
        _ASSERT(*this);
        PQLocator ts;
        HRESULT hr = (*this)->get_DefaultLocator(&ts);
        if (FAILED(hr)) {
            return PQLocator();
        }
        return ts;
    }

    HRESULT Locator(PQLocator& l) {
        _ASSERT(*this);
        return (*this)->put_Locator(l);
    }

    void Clone() {
        PQTuningSpace t;
        HRESULT hr = (*this)->Clone(&t);
        if (FAILED(hr) || !t) {
            Release();  // clone failed, clear ourselves
            return;
        }
        TUNINGSPACETYPE::operator=(t);
    }

};

typedef TNTuningSpaceHelper<PQTuningSpace, PQTuneRequest> TNTuningSpace;

template<class TUNINGSPACETYPE, class TUNEREQUESTTYPE> class TNAnalogRadioTuningSpaceHelper : public TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE> {
public:
     TNAnalogRadioTuningSpaceHelper() {}
     TNAnalogRadioTuningSpaceHelper(const TUNINGSPACETYPE &a) : TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>(a) {}
     TNAnalogRadioTuningSpaceHelper(IUnknown *p) : TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>(p) {}
     TNAnalogRadioTuningSpaceHelper(const TNAnalogRadioTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE> &a) : TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>(a) {}
     TNAnalogRadioTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& operator=(TNAnalogRadioTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& rhs) {
        TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>::operator=(rhs);
        return *this;
     }
     template<class TS, class TR> TNAnalogRadioTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& operator=(TNTuningSpaceHelper<TS, TR>& rhs) {
        TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>::operator=(TUNINGSPACETYPE(rhs));
        return *this;
     }
     TNAnalogRadioTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& operator=(TUNINGSPACETYPE& rhs) {
        TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>::operator=(rhs);
        return *this;
    }
     TNAnalogRadioTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& operator=(IUnknown* rhs) {
        TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>::operator=(rhs);
        return *this;
    }
    long MaxFrequency() {
        _ASSERT(*this);
        long freq;
        HRESULT hr = (*this)->get_MaxFrequency(&freq);
        if (FAILED(hr)) {
            freq = DEFAULT_MAX_FREQUENCY;
        }
        return freq;
    }
    HRESULT MaxFrequency(long freq) {
        _ASSERT(*this);
        return (*this)->put_MaxFrequency(freq);
    }
    long MinFrequency() {
        _ASSERT(*this);
        long freq;
        HRESULT hr = (*this)->get_MinFrequency(&freq);
        if (FAILED(hr)) {
            freq = DEFAULT_MIN_FREQUENCY;
        }
        return freq;
    }
    HRESULT MinFrequency(long freq) {
        _ASSERT(*this);
        return (*this)->put_MinFrequency(freq);
    }
};
typedef TNAnalogRadioTuningSpaceHelper<PQAnalogRadioTuningSpace, PQChannelTuneRequest> TNAnalogRadioTuningSpace;

template<class TUNINGSPACETYPE, class TUNEREQUESTTYPE> class TNAnalogTVTuningSpaceHelper : public TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE> {
public:
    TNAnalogTVTuningSpaceHelper() {}
    TNAnalogTVTuningSpaceHelper(const TUNINGSPACETYPE &a) : TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>(a) {}
    TNAnalogTVTuningSpaceHelper(IUnknown *p) : TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>(p) {}
    TNAnalogTVTuningSpaceHelper(const TNAnalogTVTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE> &a) : TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>(a) {}
    TNAnalogTVTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& operator=(TNAnalogTVTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& rhs) {
        TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>::operator=(rhs);
        return *this;
    }
    template<class TS, class TR> TNAnalogTVTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& operator=(TNTuningSpaceHelper<TS, TR>& rhs) {
        TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>::operator=(TUNINGSPACETYPE(rhs));
        return *this;
    }
    TNAnalogTVTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& operator=(TUNINGSPACETYPE& rhs) {
        TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>::operator=(rhs);
        return *this;
    }
    TNAnalogTVTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& operator=(IUnknown* rhs) {
        TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>::operator=(rhs);
        return *this;
    }
    TunerInputType InputType() {
        _ASSERT(*this);
        TunerInputType ti;
        HRESULT hr = (*this)->get_InputType(&ti);
        if (FAILED(hr)) {
            ti = DEFAULT_ANALOG_TUNER_INPUT_TYPE;
        }
        return ti;
    }
    HRESULT InputType(TunerInputType ti) {
        _ASSERT(*this);
        return (*this)->put_InputType(&ti);
    }
    long CountryCode() {
        _ASSERT(*this);
        long cc;
        HRESULT hr = (*this)->get_CountryCode(&cc);
        if (FAILED(hr)) {
            cc = DEFAULT_ANALOG_TUNER_INPUT_TYPE;
        }
        return cc;
    }
    HRESULT CountryCode(long cc) {
        _ASSERT(*this);
        return (*this)->put_CountryCode(cc);
    }
    long MinChannel() {
        _ASSERT(*this);
        long chan;
        HRESULT hr = (*this)->get_MinChannel(&chan);
        if (FAILED(hr)) {
            chan = DEFAULT_MIN_CHANNEL;
        }
        return chan;
    }
    HRESULT MinChannel(long chan) {
        _ASSERT(*this);
        return (*this)->put_MinChannel(chan);
    }
    long MaxChannel() {
        _ASSERT(*this);
        long chan;
        HRESULT hr = (*this)->get_MaxChannel(&chan);
        if (FAILED(hr)) {
            chan = DEFAULT_MAX_CHANNEL;
        }
        return chan;
    }
    HRESULT MaxChannel(long chan) {
        _ASSERT(*this);
        return (*this)->put_MaxChannel(chan);
    }
};
typedef TNAnalogTVTuningSpaceHelper<PQAnalogTVTuningSpace, PQChannelTuneRequest> TNAnalogTVTuningSpace;

template<class TUNINGSPACETYPE, class TUNEREQUESTTYPE> class TNAuxInTuningSpaceHelper : public TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE> {
public:
    TNAuxInTuningSpaceHelper() {}
    TNAuxInTuningSpaceHelper(const TUNINGSPACETYPE &a) : TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>(a) {}
    TNAuxInTuningSpaceHelper(IUnknown *p) : TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>(p) {}
    TNAuxInTuningSpaceHelper(const TNAuxInTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE> &a) : TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>(a) {}
    TNAuxInTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& operator=(TNAuxInTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& rhs) {
        TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>::operator=(rhs);
        return *this;
    }
    template<class TS, class TR> TNAuxInTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& operator=(TNTuningSpaceHelper<TS, TR>& rhs) {
        TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>::operator=(TUNINGSPACETYPE(rhs));
        return *this;
    }
    TNAuxInTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& operator=(TUNINGSPACETYPE& rhs) {
        TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>::operator=(rhs);
        return *this;
    }
    TNAuxInTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& operator=(IUnknown* rhs) {
        TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>::operator=(rhs);
        return *this;
    }
};
typedef TNAuxInTuningSpaceHelper<PQAuxInTuningSpace, PQChannelTuneRequest> TNAuxInTuningSpace;

template<class TUNINGSPACETYPE, class TUNEREQUESTTYPE> class TNATSCTuningSpaceHelper : public TNAnalogTVTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE> {
public:
    TNATSCTuningSpaceHelper() {}
    TNATSCTuningSpaceHelper(const TUNINGSPACETYPE &a) : TNAnalogTVTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>(a) {}
    TNATSCTuningSpaceHelper(IUnknown *p) : TNAnalogTVTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>(p) {}
    TNATSCTuningSpaceHelper(const TNATSCTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE> &a) : TNAnalogTVTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>(a) {}

    TNATSCTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& operator=(TNATSCTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& rhs) {
        TNAnalogTVTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>::operator=(rhs);
        return *this;
    }
    template<class TS, class TR> TNATSCTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& operator=(TNTuningSpaceHelper<TS, TR>& rhs) {
        TNAnalogTVTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>::operator=(TUNINGSPACETYPE(rhs));
        return *this;
    }
    TNATSCTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& operator=(TUNINGSPACETYPE& rhs) {
        TNAnalogTVTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>::operator=(rhs);
        return *this;
    }
    TNATSCTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& operator=(IUnknown* rhs) {
        TNAnalogTVTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>::operator=(rhs);
        return *this;
    }
    long MinMinorChannel() {
        _ASSERT(*this);
        long chan;
        HRESULT hr = (*this)->get_MinMinorChannel(&chan);
        if (FAILED(hr)) {
            chan = DEFAULT_MIN_CHANNEL;
        }
        return chan;
    }
    HRESULT MinMinorChannel(long chan) {
        _ASSERT(*this);
        return (*this)->put_MinMinorChannel(chan);
    }

    long MaxMinorChannel() {
        _ASSERT(*this);
        long chan;
        HRESULT hr = (*this)->get_MaxMinorChannel(&chan);
        if (FAILED(hr)) {
            chan = DEFAULT_MAX_CHANNEL;
        }
        return chan;
    }
    HRESULT MaxMinorChannel(long chan) {
        _ASSERT(*this);
        return (*this)->put_MaxMinorChannel(chan);
    }
    long MinPhysicalChannel() {
        _ASSERT(*this);
        long chan;
        HRESULT hr = (*this)->get_MinPhysicalChannel(&chan);
        if (FAILED(hr)) {
            chan = DEFAULT_MIN_CHANNEL;
        }
        return chan;
    }
    HRESULT MinPhysicalChannel(long chan) {
        _ASSERT(*this);
        return (*this)->put_MinPhysicalChannel(chan);
    }

    long MaxPhysicalChannel() {
        _ASSERT(*this);
        long chan;
        HRESULT hr = (*this)->get_MaxPhysicalChannel(&chan);
        if (FAILED(hr)) {
            chan = DEFAULT_MAX_CHANNEL;
        }
        return chan;
    }

    HRESULT MaxPhysicalChannel(long chan) {
        _ASSERT(*this);
        return (*this)->put_MaxPhysicalChannel(chan);
    }
};
typedef TNATSCTuningSpaceHelper<PQATSCTuningSpace, PQATSCChannelTuneRequest> TNATSCTuningSpace;

// dvb tuning space
template<class TUNINGSPACETYPE, class TUNEREQUESTTYPE> class TNDVBTuningSpaceHelper : public TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE> {
public:
     TNDVBTuningSpaceHelper() {}
     TNDVBTuningSpaceHelper(const TUNINGSPACETYPE &a) : TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>(a) {}
     TNDVBTuningSpaceHelper(IUnknown *p) : TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>(p) {}
     TNDVBTuningSpaceHelper(const TNDVBTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE> &a) : TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>(a) {}
     TNDVBTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& operator=(TNDVBTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& rhs) {
        TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>::operator=(rhs);
        return *this;
     }
     template<class TS, class TR> TNDVBTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& operator=(TNTuningSpaceHelper<TS, TR>& rhs) {
        TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>::operator=(TUNINGSPACETYPE(rhs));
        return *this;
     }
     TNDVBTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& operator=(TUNINGSPACETYPE& rhs) {
        TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>::operator=(rhs);
        return *this;
    }
     TNDVBTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& operator=(IUnknown* rhs) {
        TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>::operator=(rhs);
        return *this;
    }
    DVBSystemType SystemType() const {
        DVBSystemType st;
        HRESULT hr = (*this)->get_SystemType(&st);
        if (FAILED(hr)) {
            return DVB_Cable;
        }
        return st;
    }
    HRESULT SystemType(DVBSystemType st) {
        _ASSERT(*this);
        return (*this)->put_SystemType(st);
    }
};
typedef TNDVBTuningSpaceHelper<PQDVBTuningSpace, PQDVBTuneRequest> TNDVBTuningSpace;

// locators
template<class LOCATORTYPE> class TNLocatorHelper : public LOCATORTYPE {
public:
     TNLocatorHelper() {}
     TNLocatorHelper(const LOCATORTYPE &a) : LOCATORTYPE(a) {}
     TNLocatorHelper(IUnknown *p) : LOCATORTYPE(p) {}
     TNLocatorHelper(const TNLocatorHelper<LOCATORTYPE> &a) : LOCATORTYPE(a) {}
     TNLocatorHelper(ILocator *p) : LOCATORTYPE(p) {}
     TNLocatorHelper<LOCATORTYPE>& operator=(TNLocatorHelper<LOCATORTYPE>& rhs) {
        LOCATORTYPE::operator=(rhs);
        return *this;
    }
     TNLocatorHelper<LOCATORTYPE>& operator=(LOCATORTYPE& rhs) {
        LOCATORTYPE::operator=(rhs);
        return *this;
    }
     TNLocatorHelper<LOCATORTYPE>& operator=(ILocator* rhs) {
        LOCATORTYPE::operator=(rhs);
        return *this;
    }
     TNLocatorHelper<LOCATORTYPE>& operator=(IUnknown* rhs) {
        LOCATORTYPE::operator=(rhs);
        return *this;
    }

    void Clone() {
        PQLocator t;
        HRESULT hr = (*this)->Clone(&t);
        if (FAILED(hr) || !t) {
            Release();  // clone failed, clear ourselves
            return;
        }
        LOCATORTYPE::operator=(t);
    }

    long CarrierFrequency() {
        _ASSERT(*this);
        long f;
        HRESULT hr = (*this)->get_CarrierFrequency(&f);
        if (FAILED(hr)) {
            return -1;
        }
        return f;
    }
    HRESULT CarrierFrequency(long f) {
        _ASSERT(*this);
        return (*this)->put_CarrierFrequency(f);
    }

    FECMethod InnerFEC() {
        _ASSERT(*this);
        FECMethod f;
        HRESULT hr = (*this)->get_InnerFEC(&f);
        if (FAILED(hr)) {
            return BDA_FEC_METHOD_NOT_SET;
        }
        return f;
    }
    HRESULT InnerFEC(FECMethod f) {
        _ASSERT(*this);
        return (*this)->put_InnerFEC(f);
    }
    BinaryConvolutionCodeRate InnerFECRate() {
        _ASSERT(*this);
        BinaryConvolutionCodeRate f;
        HRESULT hr = (*this)->get_InnerFECRate(&f);
        if (FAILED(hr)) {
            return BDA_BCC_RATE_NOT_SET;
        }
        return f;
    }
    HRESULT InnerFECRate(BinaryConvolutionCodeRate f) {
        _ASSERT(*this);
        return (*this)->put_InnerFECRate(f);
    }
    FECMethod OuterFEC() {
        _ASSERT(*this);
        FECMethod f;
        HRESULT hr = (*this)->get_OuterFEC(&f);
        if (FAILED(hr)) {
            return BDA_FEC_METHOD_NOT_SET;
        }
        return f;
    }
    HRESULT OuterFEC(FECMethod f) {
        _ASSERT(*this);
        return (*this)->put_OuterFEC(f);
    }
    BinaryConvolutionCodeRate OuterFECRate() {
        _ASSERT(*this);
        BinaryConvolutionCodeRate f;
        HRESULT hr = (*this)->get_OuterFECRate(&f);
        if (FAILED(hr)) {
            return BDA_BCC_RATE_NOT_SET;
        }
        return f;
    }
    HRESULT OuterFECRate(BinaryConvolutionCodeRate f) {
        _ASSERT(*this);
        return (*this)->put_OuterFECRate(f);
    }
    ModulationType Modulation() {
        _ASSERT(*this);
        ModulationType f;
        HRESULT hr = (*this)->get_Modulation(&f);
        if (FAILED(hr)) {
            return BDA_MOD_NOT_SET;
        }
        return f;
    }
    HRESULT Modulation(ModulationType f) {
        _ASSERT(*this);
        return (*this)->put_Modulation(f);
    }

    long SymbolRate() {
        _ASSERT(*this);
        long f;
        HRESULT hr = (*this)->get_SymbolRate(&f);
        if (FAILED(hr)) {
            return -1;
        }
        return f;
    }
    HRESULT SymbolRate(long f) {
        _ASSERT(*this);
        return (*this)->put_SymbolRate(f);
    }

};
typedef TNLocatorHelper<PQLocator> TNLocator;

template<class LOCATORTYPE> class TNATSCLocatorHelper : public TNLocatorHelper<LOCATORTYPE> {
public:
    TNATSCLocatorHelper() {}
    TNATSCLocatorHelper(const LOCATORTYPE &a) : TNLocatorHelper<LOCATORTYPE>(a) {}
    TNATSCLocatorHelper(IUnknown *p) : TNLocatorHelper<LOCATORTYPE>(p) {}
    TNATSCLocatorHelper(const TNATSCLocatorHelper<LOCATORTYPE> &a) : TNLocatorHelper<LOCATORTYPE>(a) {}
    TNATSCLocatorHelper(IATSCLocator *p) : TNLocatorHelper<LOCATORTYPE>(p) {}
    TNATSCLocatorHelper(const TNLocatorHelper<LOCATORTYPE> &a) : TNLocatorHelper<LOCATORTYPE>(a) {}
    TNATSCLocatorHelper<LOCATORTYPE>& operator=(TNATSCLocatorHelper<LOCATORTYPE>& rhs) {
        TNLocatorHelper<LOCATORTYPE>::operator=(rhs);
        return *this;
    }
    TNATSCLocatorHelper<LOCATORTYPE>& operator=(TNLocatorHelper<LOCATORTYPE>& rhs) {
        TNLocatorHelper<LOCATORTYPE>::operator=(rhs);
        return *this;
    }
    TNATSCLocatorHelper<LOCATORTYPE>& operator=(LOCATORTYPE& rhs) {
        TNLocatorHelper<LOCATORTYPE>::operator=(rhs);
        return *this;
    }
    TNATSCLocatorHelper<LOCATORTYPE>& operator=(IATSCLocator* rhs) {
        TNLocatorHelper<LOCATORTYPE>::operator=(rhs);
        return *this;
    }
    TNATSCLocatorHelper<LOCATORTYPE>& operator=(IUnknown* rhs) {
        TNLocatorHelper<LOCATORTYPE>::operator=(rhs);
        return *this;
    }

    long PhysicalChannel() {
        _ASSERT(*this);
        long pc;
        HRESULT hr = (*this)->get_PhysicalChannel(&pc);
        if (FAILED(hr)) {
            return -1;
        }
        return pc;
    }
    HRESULT PhysicalChannel(long pc) {
        _ASSERT(*this);
        return (*this)->put_PhysicalChannel(pc);
    }

    long TSID() {
        _ASSERT(*this);
        long pc;
        HRESULT hr = (*this)->get_TSID(&pc);
        if (FAILED(hr)) {
            return -1;
        }
        return pc;
    }
    HRESULT TSID(long pc) {
        _ASSERT(*this);
        return (*this)->put_TSID(pc);
    }

    long ProgramNumber() {
        _ASSERT(*this);
        long pc;
        HRESULT hr = (*this)->get_ProgramNumber(&pc);
        if (FAILED(hr)) {
            return -1;
        }
        return pc;
    }
    HRESULT ProgramNumber(long pc) {
        _ASSERT(*this);
        return (*this)->put_ProgramNumber(pc);
    }
};
typedef TNATSCLocatorHelper<PQATSCLocator> TNATSCLocator;

template<class LOCATORTYPE> class TNDVBSLocatorHelper : public TNLocatorHelper<LOCATORTYPE> {
public:
    TNDVBSLocatorHelper() {}
    TNDVBSLocatorHelper(const LOCATORTYPE &a) : TNLocatorHelper<LOCATORTYPE>(a) {}
    TNDVBSLocatorHelper(IUnknown *p) : TNLocatorHelper<LOCATORTYPE>(p) {}
    TNDVBSLocatorHelper(const TNDVBSLocatorHelper<LOCATORTYPE> &a) : TNLocatorHelper<LOCATORTYPE>(a) {}
    TNDVBSLocatorHelper(IDVBSLocator *p) : TNLocatorHelper<LOCATORTYPE>(p) {}
    TNDVBSLocatorHelper(const TNLocatorHelper<LOCATORTYPE> &a) : TNLocatorHelper<LOCATORTYPE>(a) {}
    TNDVBSLocatorHelper<LOCATORTYPE>& operator=(TNDVBSLocatorHelper<LOCATORTYPE>& rhs) {
        TNLocatorHelper<LOCATORTYPE>::operator=(rhs);
        return *this;
    }
    TNDVBSLocatorHelper<LOCATORTYPE>& operator=(TNLocatorHelper<LOCATORTYPE>& rhs) {
        TNLocatorHelper<LOCATORTYPE>::operator=(rhs);
        return *this;
    }
    TNDVBSLocatorHelper<LOCATORTYPE>& operator=(LOCATORTYPE& rhs) {
        TNLocatorHelper<LOCATORTYPE>::operator=(rhs);
        return *this;
    }
    TNDVBSLocatorHelper<LOCATORTYPE>& operator=(IDVBSLocator* rhs) {
        TNLocatorHelper<LOCATORTYPE>::operator=(rhs);
        return *this;
    }
    TNDVBSLocatorHelper<LOCATORTYPE>& operator=(IUnknown* rhs) {
        TNLocatorHelper<LOCATORTYPE>::operator=(rhs);
        return *this;
    }

    Polarisation SignalPolarisation() {
        _ASSERT(*this);
        Polarisation pc;
        HRESULT hr = (*this)->get_SignalPolarisation(&pc);
        if (FAILED(hr)) {
            return -1;
        }
        return pc;
    }
    HRESULT SignalPolarisation(Polarisation pc) {
        _ASSERT(*this);
        return (*this)->put_SignalPolarisation(pc);
    }

    VARIANT_BOOL WestPosition() {
        _ASSERT(*this);
        VARIANT_BOOL pc;
        HRESULT hr = (*this)->get_WestPosition(&pc);
        if (FAILED(hr)) {
            return -1;
        }
        return pc;
    }
    HRESULT WestPosition(VARIANT_BOOL pc) {
        _ASSERT(*this);
        return (*this)->put_WestPosition(pc);
    }

    long OrbitalPosition() {
        _ASSERT(*this);
        long pc;
        HRESULT hr = (*this)->get_OrbitalPosition(&pc);
        if (FAILED(hr)) {
            return -1;
        }
        return pc;
    }
    HRESULT OrbitalPosition(long pc) {
        _ASSERT(*this);
        return (*this)->put_OrbitalPosition(pc);
    }

    long Azimuth() {
        _ASSERT(*this);
        long pc;
        HRESULT hr = (*this)->get_Azimuth(&pc);
        if (FAILED(hr)) {
            return -1;
        }
        return pc;
    }
    HRESULT Azimuth(long pc) {
        _ASSERT(*this);
        return (*this)->put_Azimuth(pc);
    }

    long Elevation() {
        _ASSERT(*this);
        long pc;
        HRESULT hr = (*this)->get_Elevation(&pc);
        if (FAILED(hr)) {
            return -1;
        }
        return pc;
    }
    HRESULT Elevation(long pc) {
        _ASSERT(*this);
        return (*this)->put_Elevation(pc);
    }

};
typedef TNDVBSLocatorHelper<PQDVBSLocator> TNDVBSLocator;



template<class LOCATORTYPE> class TNDVBTLocatorHelper : public TNLocatorHelper<LOCATORTYPE> {
public:
    TNDVBTLocatorHelper() {}
    TNDVBTLocatorHelper(const LOCATORTYPE &a) : TNLocatorHelper<LOCATORTYPE>(a) {}
    TNDVBTLocatorHelper(IUnknown *p) : TNLocatorHelper<LOCATORTYPE>(p) {}
    TNDVBTLocatorHelper(const TNDVBTLocatorHelper<LOCATORTYPE> &a) : TNLocatorHelper<LOCATORTYPE>(a) {}
    TNDVBTLocatorHelper(IDVBTLocator *p) : TNLocatorHelper<LOCATORTYPE>(p) {}
    TNDVBTLocatorHelper(const TNLocatorHelper<LOCATORTYPE> &a) : TNLocatorHelper<LOCATORTYPE>(a) {}
    TNDVBTLocatorHelper<LOCATORTYPE>& operator=(TNDVBTLocatorHelper<LOCATORTYPE>& rhs) {
        TNLocatorHelper<LOCATORTYPE>::operator=(rhs);
        return *this;
    }
    TNDVBTLocatorHelper<LOCATORTYPE>& operator=(TNLocatorHelper<LOCATORTYPE>& rhs) {
        TNLocatorHelper<LOCATORTYPE>::operator=(rhs);
        return *this;
    }
    TNDVBTLocatorHelper<LOCATORTYPE>& operator=(LOCATORTYPE& rhs) {
        TNLocatorHelper<LOCATORTYPE>::operator=(rhs);
        return *this;
    }
    TNDVBTLocatorHelper<LOCATORTYPE>& operator=(IDVBTLocator* rhs) {
        TNLocatorHelper<LOCATORTYPE>::operator=(rhs);
        return *this;
    }
    TNDVBTLocatorHelper<LOCATORTYPE>& operator=(IUnknown* rhs) {
        TNLocatorHelper<LOCATORTYPE>::operator=(rhs);
        return *this;
    }

    long BandWidth() {
        _ASSERT(*this);
        long pc;
        HRESULT hr = (*this)->get_BandWidth(&pc);
        if (FAILED(hr)) {
            return -1;
        }
        return pc;
    }
    HRESULT BandWidth(long pc) {
        _ASSERT(*this);
        return (*this)->put_BandWidth(pc);
    }

    FECMethod LPInnerFec() {
        _ASSERT(*this);
        FECMethod pc;
        HRESULT hr = (*this)->get_LPInnerFec(&pc);
        if (FAILED(hr)) {
            return -1;
        }
        return pc;
    }
    HRESULT LPInnerFec(FECMethod pc) {
        _ASSERT(*this);
        return (*this)->put_LPInnerFec(pc);
    }

    BinaryConvolutionCodeRate LPInnerFecRate() {
        _ASSERT(*this);
        BinaryConvolutionCodeRate pc;
        HRESULT hr = (*this)->get_LPInnerFecRate(&pc);
        if (FAILED(hr)) {
            return -1;
        }
        return pc;
    }
    HRESULT LPInnerFecRate(BinaryConvolutionCodeRate pc) {
        _ASSERT(*this);
        return (*this)->put_LPInnerFecRate(pc);
    }

    HierarchyAlpha HAlpha() {
        _ASSERT(*this);
        HierarchyAlpha pc;
        HRESULT hr = (*this)->get_HAlpha(&pc);
        if (FAILED(hr)) {
            return -1;
        }
        return pc;
    }
    HRESULT HAlpha(HierarchyAlpha pc) {
        _ASSERT(*this);
        return (*this)->put_HAlpha(pc);
    }

    GuardInterval Guard() {
        _ASSERT(*this);
        GuardInterval pc;
        HRESULT hr = (*this)->get_Guard(&pc);
        if (FAILED(hr)) {
            return -1;
        }
        return pc;
    }
    HRESULT Guard(GuardInterval pc) {
        _ASSERT(*this);
        return (*this)->put_Guard(pc);
    }

    TransmissionMode Mode() {
        _ASSERT(*this);
        TransmissionMode pc;
        HRESULT hr = (*this)->get_Mode(&pc);
        if (FAILED(hr)) {
            return -1;
        }
        return pc;
    }
    HRESULT Mode(TransmissionMode pc) {
        _ASSERT(*this);
        return (*this)->put_Mode(pc);
    }

    VARIANT_BOOL OtherFrequencyInUse() {
        _ASSERT(*this);
        VARIANT_BOOL pc;
        HRESULT hr = (*this)->get_OtherFrequencyInUse(&pc);
        if (FAILED(hr)) {
            return -1;
        }
        return pc;
    }
    HRESULT OtherFrequencyInUse(VARIANT_BOOL pc) {
        _ASSERT(*this);
        return (*this)->put_OtherFrequencyInUse(pc);
    }
};
typedef TNDVBTLocatorHelper<PQDVBTLocator> TNDVBTLocator;

template<class LOCATORTYPE> class TNDVBCLocatorHelper : public TNLocatorHelper<LOCATORTYPE> {
public:
    TNDVBCLocatorHelper() {}
    TNDVBCLocatorHelper(const LOCATORTYPE &a) : TNLocatorHelper<LOCATORTYPE>(a) {}
    TNDVBCLocatorHelper(IUnknown *p) : TNLocatorHelper<LOCATORTYPE>(p) {}
    TNDVBCLocatorHelper(const TNDVBCLocatorHelper<LOCATORTYPE> &a) : TNLocatorHelper<LOCATORTYPE>(a) {}
    TNDVBCLocatorHelper(IDVBCLocator *p) : TNLocatorHelper<LOCATORTYPE>(p) {}
    TNDVBCLocatorHelper(const TNLocatorHelper<LOCATORTYPE> &a) : TNLocatorHelper<LOCATORTYPE>(a) {}
    TNDVBCLocatorHelper<LOCATORTYPE>& operator=(TNDVBCLocatorHelper<LOCATORTYPE>& rhs) {
        TNLocatorHelper<LOCATORTYPE>::operator=(rhs);
        return *this;
    }
    TNDVBCLocatorHelper<LOCATORTYPE>& operator=(TNLocatorHelper<LOCATORTYPE>& rhs) {
        TNLocatorHelper<LOCATORTYPE>::operator=(rhs);
        return *this;
    }
    TNDVBCLocatorHelper<LOCATORTYPE>& operator=(LOCATORTYPE& rhs) {
        TNLocatorHelper<LOCATORTYPE>::operator=(rhs);
        return *this;
    }
    TNDVBCLocatorHelper<LOCATORTYPE>& operator=(IDVBCLocator* rhs) {
        TNLocatorHelper<LOCATORTYPE>::operator=(rhs);
        return *this;
    }
    TNDVBCLocatorHelper<LOCATORTYPE>& operator=(IUnknown* rhs) {
        TNLocatorHelper<LOCATORTYPE>::operator=(rhs);
        return *this;
    }

};
typedef TNDVBCLocatorHelper<PQDVBCLocator> TNDVBCLocator;

// tune requests
template<class TUNEREQUESTTYPE, class LOCATORTYPE> class TNTuneRequestHelper : public TUNEREQUESTTYPE {
public:
     TNTuneRequestHelper() {}
     TNTuneRequestHelper(const TUNEREQUESTTYPE &a) : TUNEREQUESTTYPE(a) {}
     TNTuneRequestHelper(IUnknown *p) : TUNEREQUESTTYPE(p) {}
     TNTuneRequestHelper(const TNTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE> &a) : TUNEREQUESTTYPE(a) {}
     TNTuneRequestHelper(ITuneRequest *p) : TUNEREQUESTTYPE(p) {}
     TNTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>& operator=(TNTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>& rhs) {
        TUNEREQUESTTYPE::operator=(rhs);
        return *this;
    }
     TNTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>& operator=(TUNEREQUESTTYPE& rhs) {
        TUNEREQUESTTYPE::operator=(rhs);
        return *this;
    }
     TNTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>& operator=(ITuneRequest* rhs) {
        TUNEREQUESTTYPE::operator=(rhs);
        return *this;
    }
     TNTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>& operator=(IUnknown* rhs) {
        TUNEREQUESTTYPE::operator=(rhs);
        return *this;
    }
    // this function creates a new instance of the base ITuneRequest* and copies
    // all the values of the current ITuneRequest and sets this to the new one
    // this provides the value semantics needed by the network providers
    void Clone() {
        PQTuneRequest t;
        HRESULT hr = (*this)->Clone(&t);
        if (FAILED(hr) || !t) {
            Release();  // clone failed, clear ourselves
            return;
        }
        TUNEREQUESTTYPE::operator=(t);
    }

    PQTuningSpace TuningSpace() {
        _ASSERT(*this);
        PQTuningSpace ts;
        HRESULT hr = (*this)->get_TuningSpace(&ts);
        if (FAILED(hr)) {
            return PQTuningSpace();
        }
        return ts;
    }

    LOCATORTYPE Locator() {
        _ASSERT(*this);
        PQLocator pc;
        HRESULT hr = (*this)->get_Locator(&pc);
        if (FAILED(hr)) {
            return PQLocator().p;
        }
        return pc.p;
    }
    HRESULT Locator(LOCATORTYPE& pc) {
        _ASSERT(*this);
        return (*this)->put_Locator(pc);
    }
};

typedef TNTuneRequestHelper<PQTuneRequest, PQLocator> TNTuneRequest;

template<class TUNEREQUESTTYPE, class LOCATORTYPE> class TNChannelTuneRequestHelper : public TNTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE> {
public:
     TNChannelTuneRequestHelper() {}
     TNChannelTuneRequestHelper(const TNTuneRequest &a) : TNTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>(a) {}
     TNChannelTuneRequestHelper(IChannelTuneRequest *p) : TNTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>(p) {}
     TNChannelTuneRequestHelper(IUnknown *p) : TNTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>(p) {}
     TNChannelTuneRequestHelper(const TNTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE> &a) : TNTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>(a) {}
     TNChannelTuneRequestHelper(const TNChannelTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE> &a) : TNTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>(a) {}
     TNChannelTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>& operator=(TNChannelTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>& rhs) {
        TNTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>::operator=(rhs);
        return *this;
    }
    template<class TR, class LOC> TNChannelTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>& operator=(TNTuneRequestHelper<TR, LOC>& rhs) {
        TNTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>::operator=(TUNEREQUESTTYPE(rhs));
        return *this;
    }
     TNChannelTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>& operator=(TUNEREQUESTTYPE& rhs) {
        TNTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>::operator=(rhs);
        return *this;
    }
     TNChannelTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>& operator=(IChannelTuneRequest* rhs) {
        TNTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>::operator=(rhs);
        return *this;
    }
     TNChannelTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>& operator=(IUnknown* rhs) {
        TUNEREQUESTTYPE::operator=(rhs);
        return *this;
    }
    long Channel() {
        _ASSERT(*this);
        long c;
        HRESULT hr = (*this)->get_Channel(&c);
        if (FAILED(hr)) {
            return -1;
        }
        return c;
    }
    HRESULT Channel(long c) {
        _ASSERT(*this);
        return (*this)->put_Channel(c);
    }
};

typedef TNChannelTuneRequestHelper<PQChannelTuneRequest, PQLocator> TNChannelTuneRequest;

template<class TUNEREQUESTTYPE, class LOCATORTYPE> class TNATSCChannelTuneRequestHelper : public TNChannelTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE> {
public:
    TNATSCChannelTuneRequestHelper() {}
    TNATSCChannelTuneRequestHelper(const TNTuneRequest &a) : TNChannelTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>(a) {}
    TNATSCChannelTuneRequestHelper(IATSCChannelTuneRequest *p) : TNChannelTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>(p) {}
    TNATSCChannelTuneRequestHelper(IUnknown *p) : TNChannelTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>(p) {}
    TNATSCChannelTuneRequestHelper(const TNChannelTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE> &a) : TNChannelTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>(a) {}
    TNATSCChannelTuneRequestHelper(const TNATSCChannelTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE> &a) : TNChannelTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>(a) {}
    TNATSCChannelTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>& operator=(TNATSCChannelTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>& rhs) {
        TNChannelTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>::operator=(rhs);
        return *this;
    }
    template<class TR, class LOC>TNATSCChannelTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>& operator=(TNTuneRequestHelper<TR, LOC>& rhs) {
        TNChannelTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>::operator=(TR(rhs));
        return *this;
    }
    TNATSCChannelTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>& operator=(TUNEREQUESTTYPE& rhs) {
        TNChannelTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>::operator=(rhs);
        return *this;
    }
    TNATSCChannelTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>& operator=(IATSCChannelTuneRequest *rhs) {
        TNChannelTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>::operator=(rhs);
        return *this;
    }
    TNTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>& operator=(IUnknown* rhs) {
        TUNEREQUESTTYPE::operator=(rhs);
        return *this;
    }
    long MinorChannel() {
        _ASSERT(*this);
        long mc;
        HRESULT hr = (*this)->get_MinorChannel(&mc);
        if (FAILED(hr)) {
            return -1;
        }
        return mc;
    }
    HRESULT MinorChannel(long mc) {
        _ASSERT(*this);
        return (*this)->put_MinorChannel(mc);
    }
};
typedef TNATSCChannelTuneRequestHelper<PQATSCChannelTuneRequest, PQATSCLocator> TNATSCChannelTuneRequest;

template<class TUNEREQUESTTYPE, class LOCATORTYPE> class TNDVBTuneRequestHelper : public TNTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE> {
public:
     TNDVBTuneRequestHelper() {}
     TNDVBTuneRequestHelper(const TNTuneRequest &a) : TNTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>(a) {}
     TNDVBTuneRequestHelper(IDVBTuneRequest *p) : TNTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>(p) {}
     TNDVBTuneRequestHelper(IUnknown *p) : TNTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>(p) {}
     TNDVBTuneRequestHelper(const TNTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE> &a) : TNTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>(a) {}
     TNDVBTuneRequestHelper(const TNDVBTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE> &a) : TNTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>(a) {}
     TNDVBTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>& operator=(TNDVBTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>& rhs) {
        TNTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>::operator=(rhs);
        return *this;
    }
    template<class TR, class LOC> TNDVBTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>& operator=(TNTuneRequestHelper<TR, LOC>& rhs) {
        TNTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>::operator=(TUNEREQUESTTYPE(rhs));
        return *this;
    }
     TNDVBTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>& operator=(TUNEREQUESTTYPE& rhs) {
        TNTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>::operator=(rhs);
        return *this;
    }
     TNDVBTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>& operator=(IDVBTuneRequest* rhs) {
        TNTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>::operator=(rhs);
        return *this;
    }
     TNDVBTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>& operator=(IUnknown* rhs) {
        TUNEREQUESTTYPE::operator=(rhs);
        return *this;
    }
    long ONID() {
        _ASSERT(*this);
        long c;
        HRESULT hr = (*this)->get_ONID(&c);
        if (FAILED(hr)) {
            return -1;
        }
        return c;
    }
    HRESULT ONID(long c) {
        _ASSERT(*this);
        return (*this)->put_ONID(c);
    }
    long TSID() {
        _ASSERT(*this);
        long c;
        HRESULT hr = (*this)->get_TSID(&c);
        if (FAILED(hr)) {
            return -1;
        }
        return c;
    }
    HRESULT TSID(long c) {
        _ASSERT(*this);
        return (*this)->put_TSID(c);
    }
    long SID() {
        _ASSERT(*this);
        long c;
        HRESULT hr = (*this)->get_SID(&c);
        if (FAILED(hr)) {
            return -1;
        }
        return c;
    }
    HRESULT SID(long c) {
        _ASSERT(*this);
        return (*this)->put_SID(c);
    }
};
typedef TNDVBTuneRequestHelper<PQDVBTuneRequest, PQLocator> TNDVBTuneRequest;
}; // namespace

#ifndef NO_DEFAULT_BDATUNINGMODEL_NAMESPACE
using namespace BDATuningModel;
#endif

#endif
// end of file - tune.h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DirectX\9c\Include\strsafe.h ===
/******************************************************************
*                                                                 *
*  strsafe.h -- This module defines safer C library string        *
*               routine replacements. These are meant to make C   *
*               a bit more safe in reference to security and      *
*               robustness                                        *
*                                                                 *
*  Copyright (c) Microsoft Corp.  All rights reserved.            *
*                                                                 *
******************************************************************/
#ifndef _STRSAFE_H_INCLUDED_
#define _STRSAFE_H_INCLUDED_
#pragma once

#include <stdio.h>      // for _vsnprintf, _vsnwprintf, getc, getwc
#include <string.h>     // for memset
#include <stdarg.h>     // for va_start, etc.


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef __w64 unsigned int  size_t;
#endif  // !_WIN64
#define _SIZE_T_DEFINED
#endif  // !_SIZE_T_DEFINED

#if !defined(_WCHAR_T_DEFINED) && !defined(_NATIVE_WCHAR_T_DEFINED)
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _HRESULT_DEFINED
#define _HRESULT_DEFINED
typedef long HRESULT;
#endif // !_HRESULT_DEFINED

#ifndef SUCCEEDED
#define SUCCEEDED(hr)  ((HRESULT)(hr) >= 0)
#endif

#ifndef FAILED
#define FAILED(hr)  ((HRESULT)(hr) < 0)
#endif

#ifndef S_OK
#define S_OK  ((HRESULT)0x00000000L)
#endif

#ifdef __cplusplus
#define _STRSAFE_EXTERN_C    extern "C"
#else
#define _STRSAFE_EXTERN_C    extern
#endif

// If you do not want to use these functions inline (and instead want to link w/ strsafe.lib), then
// #define STRSAFE_LIB before including this header file.
#if defined(STRSAFE_LIB)
#define STRSAFEAPI  _STRSAFE_EXTERN_C HRESULT __stdcall
#pragma comment(lib, "strsafe.lib")
#elif defined(STRSAFE_LIB_IMPL)
#define STRSAFEAPI  _STRSAFE_EXTERN_C HRESULT __stdcall
#else
#define STRSAFEAPI  __inline HRESULT __stdcall
#define STRSAFE_INLINE
#endif

// Some functions always run inline because they use stdin and we want to avoid building multiple
// versions of strsafe lib depending on if you use msvcrt, libcmt, etc.
#define STRSAFE_INLINE_API  __inline HRESULT __stdcall

// The user can request no "Cb" or no "Cch" fuctions, but not both!
#if defined(STRSAFE_NO_CB_FUNCTIONS) && defined(STRSAFE_NO_CCH_FUNCTIONS)
#error cannot specify both STRSAFE_NO_CB_FUNCTIONS and STRSAFE_NO_CCH_FUNCTIONS !!
#endif

// This should only be defined when we are building strsafe.lib
#ifdef STRSAFE_LIB_IMPL
#define STRSAFE_INLINE
#endif


// If both strsafe.h and ntstrsafe.h are included, only use definitions from one.
#ifndef _NTSTRSAFE_H_INCLUDED_

#define STRSAFE_MAX_CCH  2147483647 // max # of characters we support (same as INT_MAX)

// Flags for controling the Ex functions
//
//      STRSAFE_FILL_BYTE(0xFF)     0x000000FF  // bottom byte specifies fill pattern
#define STRSAFE_IGNORE_NULLS        0x00000100  // treat null as TEXT("") -- don't fault on NULL buffers
#define STRSAFE_FILL_BEHIND_NULL    0x00000200  // fill in extra space behind the null terminator
#define STRSAFE_FILL_ON_FAILURE     0x00000400  // on failure, overwrite pszDest with fill pattern and null terminate it
#define STRSAFE_NULL_ON_FAILURE     0x00000800  // on failure, set *pszDest = TEXT('\0')
#define STRSAFE_NO_TRUNCATION       0x00001000  // instead of returning a truncated result, copy/append nothing to pszDest and null terminate it

#define STRSAFE_VALID_FLAGS         (0x000000FF | STRSAFE_IGNORE_NULLS | STRSAFE_FILL_BEHIND_NULL | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE | STRSAFE_NO_TRUNCATION)

// helper macro to set the fill character and specify buffer filling
#define STRSAFE_FILL_BYTE(x)        ((unsigned long)((x & 0x000000FF) | STRSAFE_FILL_BEHIND_NULL))
#define STRSAFE_FAILURE_BYTE(x)     ((unsigned long)((x & 0x000000FF) | STRSAFE_FILL_ON_FAILURE))

#define STRSAFE_GET_FILL_PATTERN(dwFlags)  ((int)(dwFlags & 0x000000FF))

#endif // _NTSTRSAFE_H_INCLUDED_

// STRSAFE error return codes
//
#define STRSAFE_E_INSUFFICIENT_BUFFER       ((HRESULT)0x8007007AL)  // 0x7A = 122L = ERROR_INSUFFICIENT_BUFFER
#define STRSAFE_E_INVALID_PARAMETER         ((HRESULT)0x80070057L)  // 0x57 =  87L = ERROR_INVALID_PARAMETER
#define STRSAFE_E_END_OF_FILE               ((HRESULT)0x80070026L)  // 0x26 =  38L = ERROR_HANDLE_EOF

// prototypes for the worker functions
#ifdef STRSAFE_INLINE
STRSAFEAPI StringCopyWorkerA(char* pszDest, size_t cchDest, const char* pszSrc);
STRSAFEAPI StringCopyWorkerW(wchar_t* pszDest, size_t cchDest, const wchar_t* pszSrc);
STRSAFEAPI StringCopyExWorkerA(char* pszDest, size_t cchDest, size_t cbDest, const char* pszSrc, char** ppszDestEnd, size_t* pcchRemaining, unsigned long dwFlags);
STRSAFEAPI StringCopyExWorkerW(wchar_t* pszDest, size_t cchDest, size_t cbDest, const wchar_t* pszSrc, wchar_t** ppszDestEnd, size_t* pcchRemaining, unsigned long dwFlags);
STRSAFEAPI StringCopyNWorkerA(char* pszDest, size_t cchDest, const char* pszSrc, size_t cchSrc);
STRSAFEAPI StringCopyNWorkerW(wchar_t* pszDest, size_t cchDest, const wchar_t* pszSrc, size_t cchSrc);
STRSAFEAPI StringCopyNExWorkerA(char* pszDest, size_t cchDest, size_t cbDest, const char* pszSrc, size_t cchSrc, char** ppszDestEnd, size_t* pcchRemaining, unsigned long dwFlags);
STRSAFEAPI StringCopyNExWorkerW(wchar_t* pszDest, size_t cchDest, size_t cbDest, const wchar_t* pszSrc, size_t cchSrc, wchar_t** ppszDestEnd, size_t* pcchRemaining, unsigned long dwFlags);
STRSAFEAPI StringCatWorkerA(char* pszDest, size_t cchDest, const char* pszSrc);
STRSAFEAPI StringCatWorkerW(wchar_t* pszDest, size_t cchDest, const wchar_t* pszSrc);
STRSAFEAPI StringCatExWorkerA(char* pszDest, size_t cchDest, size_t cbDest, const char* pszSrc, char** ppszDestEnd, size_t* pcchRemaining, unsigned long dwFlags);
STRSAFEAPI StringCatExWorkerW(wchar_t* pszDest, size_t cchDest, size_t cbDest, const wchar_t* pszSrc, wchar_t** ppszDestEnd, size_t* pcchRemaining, unsigned long dwFlags);
STRSAFEAPI StringCatNWorkerA(char* pszDest, size_t cchDest, const char* pszSrc, size_t cchMaxAppend);
STRSAFEAPI StringCatNWorkerW(wchar_t* pszDest, size_t cchDest, const wchar_t* pszSrc, size_t cchMaxAppend);
STRSAFEAPI StringCatNExWorkerA(char* pszDest, size_t cchDest, size_t cbDest, const char* pszSrc, size_t cchMaxAppend, char** ppszDestEnd, size_t* pcchRemaining, unsigned long dwFlags);
STRSAFEAPI StringCatNExWorkerW(wchar_t* pszDest, size_t cchDest, size_t cbDest, const wchar_t* pszSrc, size_t cchMaxAppend, wchar_t** ppszDestEnd, size_t* pcchRemaining, unsigned long dwFlags);
STRSAFEAPI StringVPrintfWorkerA(char* pszDest, size_t cchDest, const char* pszFormat, va_list argList);
STRSAFEAPI StringVPrintfWorkerW(wchar_t* pszDest, size_t cchDest, const wchar_t* pszFormat, va_list argList);
STRSAFEAPI StringVPrintfExWorkerA(char* pszDest, size_t cchDest, size_t cbDest, char** ppszDestEnd, size_t* pcchRemaining, unsigned long dwFlags, const char* pszFormat, va_list argList);
STRSAFEAPI StringVPrintfExWorkerW(wchar_t* pszDest, size_t cchDest, size_t cbDest, wchar_t** ppszDestEnd, size_t* pcchRemaining, unsigned long dwFlags, const wchar_t* pszFormat, va_list argList);
STRSAFEAPI StringLengthWorkerA(const char* psz, size_t cchMax, size_t* pcch);
STRSAFEAPI StringLengthWorkerW(const wchar_t* psz, size_t cchMax, size_t* pcch);
#endif  // STRSAFE_INLINE

#ifndef STRSAFE_LIB_IMPL
// these functions are always inline
STRSAFE_INLINE_API StringGetsExWorkerA(char* pszDest, size_t cchDest, size_t cbDest, char** ppszDestEnd, size_t* pcchRemaining, unsigned long dwFlags);
STRSAFE_INLINE_API StringGetsExWorkerW(wchar_t* pszDest, size_t cchDest, size_t cbDest, wchar_t** ppszDestEnd, size_t* pcchRemaining, unsigned long dwFlags);
#endif

#ifdef _NTSTRSAFE_H_INCLUDED_
#pragma warning(push)
#pragma warning(disable : 4995)
#endif // _NTSTRSAFE_H_INCLUDED_


#ifndef STRSAFE_NO_CCH_FUNCTIONS
/*++

STDAPI
StringCchCopy(
    OUT LPTSTR  pszDest,
    IN  size_t  cchDest,
    IN  LPCTSTR pszSrc
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strcpy'.
    The size of the destination buffer (in characters) is a parameter and
    this function will not write past the end of this buffer and it will
    ALWAYS null terminate the destination buffer (unless it is zero length).

    This routine is not a replacement for strncpy.  That function will pad the
    destination string with extra null termination characters if the count is
    greater than the length of the source string, and it will fail to null
    terminate the destination string if the source string length is greater
    than or equal to the count. You can not blindly use this instead of strncpy:
    it is common for code to use it to "patch" strings and you would introduce
    errors if the code started null terminating in the middle of the string.

    This function returns a hresult, and not a pointer.  It returns
    S_OK if the string was copied without truncation and null terminated,
    otherwise it will return a failure code. In failure cases as much of
    pszSrc will be copied to pszDest as possible, and pszDest will be null
    terminated.

Arguments:

    pszDest        -   destination string

    cchDest        -   size of destination buffer in characters.
                       length must be = (_tcslen(src) + 1) to hold all of the
                       source including the null terminator

    pszSrc         -   source string which must be null terminated

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL. See StringCchCopyEx if you require
    the handling of NULL values.

Return Value:

    S_OK           -   if there was source data and it was all copied and the
                       resultant dest string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the copy
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function.

--*/

STRSAFEAPI StringCchCopyA(char* pszDest, size_t cchDest, const char* pszSrc);
STRSAFEAPI StringCchCopyW(wchar_t* pszDest, size_t cchDest, const wchar_t* pszSrc);
#ifdef UNICODE
#define StringCchCopy  StringCchCopyW
#else
#define StringCchCopy  StringCchCopyA
#endif // !UNICODE

#ifdef STRSAFE_INLINE
STRSAFEAPI StringCchCopyA(char* pszDest, size_t cchDest, const char* pszSrc)
{
    HRESULT hr;

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringCopyWorkerA(pszDest, cchDest, pszSrc);
    }

    return hr;
}

STRSAFEAPI StringCchCopyW(wchar_t* pszDest, size_t cchDest, const wchar_t* pszSrc)
{
    HRESULT hr;

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringCopyWorkerW(pszDest, cchDest, pszSrc);
    }

    return hr;
}
#endif  // STRSAFE_INLINE
#endif  // !STRSAFE_NO_CCH_FUNCTIONS


#ifndef STRSAFE_NO_CB_FUNCTIONS
/*++

STDAPI
StringCbCopy(
    OUT LPTSTR pszDest,
    IN  size_t cbDest,
    IN  LPCTSTR pszSrc
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strcpy'.
    The size of the destination buffer (in bytes) is a parameter and this
    function will not write past the end of this buffer and it will ALWAYS
    null terminate the destination buffer (unless it is zero length).

    This routine is not a replacement for strncpy.  That function will pad the
    destination string with extra null termination characters if the count is
    greater than the length of the source string, and it will fail to null
    terminate the destination string if the source string length is greater
    than or equal to the count. You can not blindly use this instead of strncpy:
    it is common for code to use it to "patch" strings and you would introduce
    errors if the code started null terminating in the middle of the string.

    This function returns a hresult, and not a pointer.  It returns
    S_OK if the string was copied without truncation and null terminated,
    otherwise it will return a failure code. In failure cases as much of pszSrc
    will be copied to pszDest as possible, and pszDest will be null terminated.

Arguments:

    pszDest        -   destination string

    cbDest         -   size of destination buffer in bytes.
                       length must be = ((_tcslen(src) + 1) * sizeof(TCHAR)) to
                       hold all of the source including the null terminator

    pszSrc         -   source string which must be null terminated

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL.  See StringCbCopyEx if you require
    the handling of NULL values.

Return Value:

    S_OK           -   if there was source data and it was all copied and the
                       resultant dest string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the copy
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function.

--*/

STRSAFEAPI StringCbCopyA(char* pszDest, size_t cbDest, const char* pszSrc);
STRSAFEAPI StringCbCopyW(wchar_t* pszDest, size_t cbDest, const wchar_t* pszSrc);
#ifdef UNICODE
#define StringCbCopy  StringCbCopyW
#else
#define StringCbCopy  StringCbCopyA
#endif // !UNICODE

#ifdef STRSAFE_INLINE
STRSAFEAPI StringCbCopyA(char* pszDest, size_t cbDest, const char* pszSrc)
{
    HRESULT hr;
    size_t cchDest;

    // convert to count of characters
    cchDest = cbDest / sizeof(char);

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringCopyWorkerA(pszDest, cchDest, pszSrc);
    }

    return hr;
}

STRSAFEAPI StringCbCopyW(wchar_t* pszDest, size_t cbDest, const wchar_t* pszSrc)
{
    HRESULT hr;
    size_t cchDest;

    // convert to count of characters
    cchDest = cbDest / sizeof(wchar_t);

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringCopyWorkerW(pszDest, cchDest, pszSrc);
    }

    return hr;
}
#endif  // STRSAFE_INLINE
#endif  // !STRSAFE_NO_CB_FUNCTIONS


#ifndef STRSAFE_NO_CCH_FUNCTIONS
/*++

STDAPI
StringCchCopyEx(
    OUT LPTSTR  pszDest         OPTIONAL,
    IN  size_t  cchDest,
    IN  LPCTSTR pszSrc          OPTIONAL,
    OUT LPTSTR* ppszDestEnd     OPTIONAL,
    OUT size_t* pcchRemaining   OPTIONAL,
    IN  DWORD   dwFlags
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strcpy' with
    some additional parameters.  In addition to functionality provided by
    StringCchCopy, this routine also returns a pointer to the end of the
    destination string and the number of characters left in the destination string
    including the null terminator. The flags parameter allows additional controls.

Arguments:

    pszDest         -   destination string

    cchDest         -   size of destination buffer in characters.
                        length must be = (_tcslen(pszSrc) + 1) to hold all of
                        the source including the null terminator

    pszSrc          -   source string which must be null terminated

    ppszDestEnd     -   if ppszDestEnd is non-null, the function will return a
                        pointer to the end of the destination string.  If the
                        function copied any data, the result will point to the
                        null termination character

    pcchRemaining   -   if pcchRemaining is non-null, the function will return the
                        number of characters left in the destination string,
                        including the null terminator

    dwFlags         -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND_NULL
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer
                    behind the null terminator

        STRSAFE_IGNORE_NULLS
                    treat NULL string pointers like empty strings (TEXT("")).
                    this flag is useful for emulating functions like lstrcpy

        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer, and it will
                    be null terminated. This will overwrite any truncated
                    string returned when the failure is
                    STRSAFE_E_INSUFFICIENT_BUFFER

        STRSAFE_NO_TRUNCATION /
        STRSAFE_NULL_ON_FAILURE
                    if the function fails, the destination buffer will be set
                    to the empty string. This will overwrite any truncated string
                    returned when the failure is STRSAFE_E_INSUFFICIENT_BUFFER.

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL unless the STRSAFE_IGNORE_NULLS flag
    is specified.  If STRSAFE_IGNORE_NULLS is passed, both pszDest and pszSrc
    may be NULL.  An error may still be returned even though NULLS are ignored
    due to insufficient space.

Return Value:

    S_OK           -   if there was source data and it was all copied and the
                       resultant dest string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the copy
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/

STRSAFEAPI StringCchCopyExA(char* pszDest, size_t cchDest, const char* pszSrc, char** ppszDestEnd, size_t* pcchRemaining, unsigned long dwFlags);
STRSAFEAPI StringCchCopyExW(wchar_t* pszDest, size_t cchDest, const wchar_t* pszSrc, wchar_t** ppszDestEnd, size_t* pcchRemaining, unsigned long dwFlags);
#ifdef UNICODE
#define StringCchCopyEx  StringCchCopyExW
#else
#define StringCchCopyEx  StringCchCopyExA
#endif // !UNICODE

#ifdef STRSAFE_INLINE
STRSAFEAPI StringCchCopyExA(char* pszDest, size_t cchDest, const char* pszSrc, char** ppszDestEnd, size_t* pcchRemaining, unsigned long dwFlags)
{
    HRESULT hr;

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        size_t cbDest;

        // safe to multiply cchDest * sizeof(char) since cchDest < STRSAFE_MAX_CCH and sizeof(char) is 1
        cbDest = cchDest * sizeof(char);

        hr = StringCopyExWorkerA(pszDest, cchDest, cbDest, pszSrc, ppszDestEnd, pcchRemaining, dwFlags);
    }

    return hr;
}

STRSAFEAPI StringCchCopyExW(wchar_t* pszDest, size_t cchDest, const wchar_t* pszSrc, wchar_t** ppszDestEnd, size_t* pcchRemaining, unsigned long dwFlags)
{
    HRESULT hr;

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        size_t cbDest;

        // safe to multiply cchDest * sizeof(wchar_t) since cchDest < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
        cbDest = cchDest * sizeof(wchar_t);

        hr = StringCopyExWorkerW(pszDest, cchDest, cbDest, pszSrc, ppszDestEnd, pcchRemaining, dwFlags);
    }

    return hr;
}
#endif  // STRSAFE_INLINE
#endif  // !STRSAFE_NO_CCH_FUNCTIONS


#ifndef STRSAFE_NO_CB_FUNCTIONS
/*++

STDAPI
StringCbCopyEx(
    OUT LPTSTR  pszDest         OPTIONAL,
    IN  size_t  cbDest,
    IN  LPCTSTR pszSrc          OPTIONAL,
    OUT LPTSTR* ppszDestEnd     OPTIONAL,
    OUT size_t* pcbRemaining    OPTIONAL,
    IN  DWORD   dwFlags
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strcpy' with
    some additional parameters.  In addition to functionality provided by
    StringCbCopy, this routine also returns a pointer to the end of the
    destination string and the number of bytes left in the destination string
    including the null terminator. The flags parameter allows additional controls.

Arguments:

    pszDest         -   destination string

    cbDest          -   size of destination buffer in bytes.
                        length must be ((_tcslen(pszSrc) + 1) * sizeof(TCHAR)) to
                        hold all of the source including the null terminator

    pszSrc          -   source string which must be null terminated

    ppszDestEnd     -   if ppszDestEnd is non-null, the function will return a
                        pointer to the end of the destination string.  If the
                        function copied any data, the result will point to the
                        null termination character

    pcbRemaining    -   pcbRemaining is non-null,the function will return the
                        number of bytes left in the destination string,
                        including the null terminator

    dwFlags         -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND_NULL
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer
                    behind the null terminator

        STRSAFE_IGNORE_NULLS
                    treat NULL string pointers like empty strings (TEXT("")).
                    this flag is useful for emulating functions like lstrcpy

        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer, and it will
                    be null terminated. This will overwrite any truncated
                    string returned when the failure is
                    STRSAFE_E_INSUFFICIENT_BUFFER

        STRSAFE_NO_TRUNCATION /
        STRSAFE_NULL_ON_FAILURE
                    if the function fails, the destination buffer will be set
                    to the empty string. This will overwrite any truncated string
                    returned when the failure is STRSAFE_E_INSUFFICIENT_BUFFER.

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL unless the STRSAFE_IGNORE_NULLS flag
    is specified.  If STRSAFE_IGNORE_NULLS is passed, both pszDest and pszSrc
    may be NULL.  An error may still be returned even though NULLS are ignored
    due to insufficient space.

Return Value:

    S_OK           -   if there was source data and it was all copied and the
                       resultant dest string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the copy
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/

STRSAFEAPI StringCbCopyExA(char* pszDest, size_t cbDest, const char* pszSrc, char** ppszDestEnd, size_t* pcbRemaining, unsigned long dwFlags);
STRSAFEAPI StringCbCopyExW(wchar_t* pszDest, size_t cbDest, const wchar_t* pszSrc, wchar_t** ppszDestEnd, size_t* pcbRemaining, unsigned long dwFlags);
#ifdef UNICODE
#define StringCbCopyEx  StringCbCopyExW
#else
#define StringCbCopyEx  StringCbCopyExA
#endif // !UNICODE

#ifdef STRSAFE_INLINE
STRSAFEAPI StringCbCopyExA(char* pszDest, size_t cbDest, const char* pszSrc, char** ppszDestEnd, size_t* pcbRemaining, unsigned long dwFlags)
{
    HRESULT hr;
    size_t cchDest;
    size_t cchRemaining = 0;

    cchDest = cbDest / sizeof(char);

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringCopyExWorkerA(pszDest, cchDest, cbDest, pszSrc, ppszDestEnd, &cchRemaining, dwFlags);
    }

    if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
    {
        if (pcbRemaining)
        {
            // safe to multiply cchRemaining * sizeof(char) since cchRemaining < STRSAFE_MAX_CCH and sizeof(char) is 1
            *pcbRemaining = (cchRemaining * sizeof(char)) + (cbDest % sizeof(char));
        }
    }

    return hr;
}

STRSAFEAPI StringCbCopyExW(wchar_t* pszDest, size_t cbDest, const wchar_t* pszSrc, wchar_t** ppszDestEnd, size_t* pcbRemaining, unsigned long dwFlags)
{
    HRESULT hr;
    size_t cchDest;
    size_t cchRemaining = 0;

    cchDest = cbDest / sizeof(wchar_t);

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringCopyExWorkerW(pszDest, cchDest, cbDest, pszSrc, ppszDestEnd, &cchRemaining, dwFlags);
    }

    if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
    {
        if (pcbRemaining)
        {
            // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
            *pcbRemaining = (cchRemaining * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t));
        }
    }

    return hr;
}
#endif  // STRSAFE_INLINE
#endif  // !STRSAFE_NO_CB_FUNCTIONS


#ifndef STRSAFE_NO_CCH_FUNCTIONS
/*++

STDAPI
StringCchCopyN(
    OUT LPTSTR  pszDest,
    IN  size_t  cchDest,
    IN  LPCTSTR pszSrc,
    IN  size_t  cchSrc
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strncpy'.
    The size of the destination buffer (in characters) is a parameter and
    this function will not write past the end of this buffer and it will
    ALWAYS null terminate the destination buffer (unless it is zero length).

    This routine is meant as a replacement for strncpy, but it does behave
    differently. This function will not pad the destination buffer with extra
    null termination characters if cchSrc is greater than the length of pszSrc.

    This function returns a hresult, and not a pointer.  It returns
    S_OK if the entire string or the first cchSrc characters were copied
    without truncation and the resultant destination string was null terminated,
    otherwise it will return a failure code. In failure cases as much of pszSrc
    will be copied to pszDest as possible, and pszDest will be null terminated.

Arguments:

    pszDest        -   destination string

    cchDest        -   size of destination buffer in characters.
                       length must be = (_tcslen(src) + 1) to hold all of the
                       source including the null terminator

    pszSrc         -   source string

    cchSrc         -   maximum number of characters to copy from source string,
                       not including the null terminator.

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL. See StringCchCopyNEx if you require
    the handling of NULL values.

Return Value:

    S_OK           -   if there was source data and it was all copied and the
                       resultant dest string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the copy
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function.

--*/

STRSAFEAPI StringCchCopyNA(char* pszDest, size_t cchDest, const char* pszSrc, size_t cchSrc);
STRSAFEAPI StringCchCopyNW(wchar_t* pszDest, size_t cchDest, const wchar_t* pszSrc, size_t cchSrc);
#ifdef UNICODE
#define StringCchCopyN  StringCchCopyNW
#else
#define StringCchCopyN  StringCchCopyNA
#endif // !UNICODE

#ifdef STRSAFE_INLINE
STRSAFEAPI StringCchCopyNA(char* pszDest, size_t cchDest, const char* pszSrc, size_t cchSrc)
{
    HRESULT hr;

    if ((cchDest > STRSAFE_MAX_CCH) ||
        (cchSrc > STRSAFE_MAX_CCH))
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringCopyNWorkerA(pszDest, cchDest, pszSrc, cchSrc);
    }

    return hr;
}

STRSAFEAPI StringCchCopyNW(wchar_t* pszDest, size_t cchDest, const wchar_t* pszSrc, size_t cchSrc)
{
    HRESULT hr;

    if ((cchDest > STRSAFE_MAX_CCH) ||
        (cchSrc > STRSAFE_MAX_CCH))
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringCopyNWorkerW(pszDest, cchDest, pszSrc, cchSrc);
    }

    return hr;
}
#endif  // STRSAFE_INLINE
#endif  // !STRSAFE_NO_CCH_FUNCTIONS


#ifndef STRSAFE_NO_CB_FUNCTIONS
/*++

STDAPI
StringCbCopyN(
    OUT LPTSTR  pszDest,
    IN  size_t  cbDest,
    IN  LPCTSTR pszSrc,
    IN  size_t  cbSrc
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strncpy'.
    The size of the destination buffer (in bytes) is a parameter and this
    function will not write past the end of this buffer and it will ALWAYS
    null terminate the destination buffer (unless it is zero length).

    This routine is meant as a replacement for strncpy, but it does behave
    differently. This function will not pad the destination buffer with extra
    null termination characters if cbSrc is greater than the size of pszSrc.

    This function returns a hresult, and not a pointer.  It returns
    S_OK if the entire string or the first cbSrc characters were
    copied without truncation and the resultant destination string was null
    terminated, otherwise it will return a failure code. In failure cases as
    much of pszSrc will be copied to pszDest as possible, and pszDest will be
    null terminated.

Arguments:

    pszDest        -   destination string

    cbDest         -   size of destination buffer in bytes.
                       length must be = ((_tcslen(src) + 1) * sizeof(TCHAR)) to
                       hold all of the source including the null terminator

    pszSrc         -   source string

    cbSrc          -   maximum number of bytes to copy from source string,
                       not including the null terminator.

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL.  See StringCbCopyEx if you require
    the handling of NULL values.

Return Value:

    S_OK           -   if there was source data and it was all copied and the
                       resultant dest string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the copy
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function.

--*/

STRSAFEAPI StringCbCopyNA(char* pszDest, size_t cbDest, const char* pszSrc, size_t cbSrc);
STRSAFEAPI StringCbCopyNW(wchar_t* pszDest, size_t cbDest, const wchar_t* pszSrc, size_t cbSrc);
#ifdef UNICODE
#define StringCbCopyN  StringCbCopyNW
#else
#define StringCbCopyN  StringCbCopyNA
#endif // !UNICODE

#ifdef STRSAFE_INLINE
STRSAFEAPI StringCbCopyNA(char* pszDest, size_t cbDest, const char* pszSrc, size_t cbSrc)
{
    HRESULT hr;
    size_t cchDest;
    size_t cchSrc;

    // convert to count of characters
    cchDest = cbDest / sizeof(char);
    cchSrc = cbSrc / sizeof(char);

    if ((cchDest > STRSAFE_MAX_CCH) ||
        (cchSrc > STRSAFE_MAX_CCH))
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringCopyNWorkerA(pszDest, cchDest, pszSrc, cchSrc);
    }

    return hr;
}

STRSAFEAPI StringCbCopyNW(wchar_t* pszDest, size_t cbDest, const wchar_t* pszSrc, size_t cbSrc)
{
    HRESULT hr;
    size_t cchDest;
    size_t cchSrc;

    // convert to count of characters
    cchDest = cbDest / sizeof(wchar_t);
    cchSrc = cbSrc / sizeof(wchar_t);

    if ((cchDest > STRSAFE_MAX_CCH) ||
        (cchSrc > STRSAFE_MAX_CCH))
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringCopyNWorkerW(pszDest, cchDest, pszSrc, cchSrc);
    }

    return hr;
}
#endif  // STRSAFE_INLINE
#endif  // !STRSAFE_NO_CB_FUNCTIONS


#ifndef STRSAFE_NO_CCH_FUNCTIONS
/*++

STDAPI
StringCchCopyNEx(
    OUT LPTSTR  pszDest         OPTIONAL,
    IN  size_t  cchDest,
    IN  LPCTSTR pszSrc          OPTIONAL,
    IN  size_t  cchSrc,
    OUT LPTSTR* ppszDestEnd     OPTIONAL,
    OUT size_t* pcchRemaining   OPTIONAL,
    IN  DWORD   dwFlags
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strncpy' with
    some additional parameters.  In addition to functionality provided by
    StringCchCopyN, this routine also returns a pointer to the end of the
    destination string and the number of characters left in the destination
    string including the null terminator. The flags parameter allows
    additional controls.

    This routine is meant as a replacement for strncpy, but it does behave
    differently. This function will not pad the destination buffer with extra
    null termination characters if cchSrc is greater than the length of pszSrc.

Arguments:

    pszDest         -   destination string

    cchDest         -   size of destination buffer in characters.
                        length must be = (_tcslen(pszSrc) + 1) to hold all of
                        the source including the null terminator

    pszSrc          -   source string

    cchSrc          -   maximum number of characters to copy from the source
                        string

    ppszDestEnd     -   if ppszDestEnd is non-null, the function will return a
                        pointer to the end of the destination string.  If the
                        function copied any data, the result will point to the
                        null termination character

    pcchRemaining   -   if pcchRemaining is non-null, the function will return the
                        number of characters left in the destination string,
                        including the null terminator

    dwFlags         -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND_NULL
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer
                    behind the null terminator

        STRSAFE_IGNORE_NULLS
                    treat NULL string pointers like empty strings (TEXT("")).
                    this flag is useful for emulating functions like lstrcpy

        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer, and it will
                    be null terminated. This will overwrite any truncated
                    string returned when the failure is
                    STRSAFE_E_INSUFFICIENT_BUFFER

        STRSAFE_NO_TRUNCATION /
        STRSAFE_NULL_ON_FAILURE
                    if the function fails, the destination buffer will be set
                    to the empty string. This will overwrite any truncated string
                    returned when the failure is STRSAFE_E_INSUFFICIENT_BUFFER.

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL unless the STRSAFE_IGNORE_NULLS flag
    is specified. If STRSAFE_IGNORE_NULLS is passed, both pszDest and pszSrc
    may be NULL. An error may still be returned even though NULLS are ignored
    due to insufficient space.

Return Value:

    S_OK           -   if there was source data and it was all copied and the
                       resultant dest string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the copy
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/

STRSAFEAPI StringCchCopyNExA(char* pszDest, size_t cchDest, const char* pszSrc, size_t cchSrc, char** ppszDestEnd, size_t* pcchRemaining, unsigned long dwFlags);
STRSAFEAPI StringCchCopyNExW(wchar_t* pszDest, size_t cchDest, const wchar_t* pszSrc, size_t cchSrc, wchar_t** ppszDestEnd, size_t* pcchRemaining, unsigned long dwFlags);
#ifdef UNICODE
#define StringCchCopyNEx  StringCchCopyNExW
#else
#define StringCchCopyNEx  StringCchCopyNExA
#endif // !UNICODE

#ifdef STRSAFE_INLINE
STRSAFEAPI StringCchCopyNExA(char* pszDest, size_t cchDest, const char* pszSrc, size_t cchSrc, char** ppszDestEnd, size_t* pcchRemaining, unsigned long dwFlags)
{
    HRESULT hr;

    if ((cchDest > STRSAFE_MAX_CCH) ||
        (cchSrc > STRSAFE_MAX_CCH))
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        size_t cbDest;

        // safe to multiply cchDest * sizeof(char) since cchDest < STRSAFE_MAX_CCH and sizeof(char) is 1
        cbDest = cchDest * sizeof(char);

        hr = StringCopyNExWorkerA(pszDest, cchDest, cbDest, pszSrc, cchSrc, ppszDestEnd, pcchRemaining, dwFlags);
    }

    return hr;
}

STRSAFEAPI StringCchCopyNExW(wchar_t* pszDest, size_t cchDest, const wchar_t* pszSrc, size_t cchSrc, wchar_t** ppszDestEnd, size_t* pcchRemaining, unsigned long dwFlags)
{
    HRESULT hr;

    if ((cchDest > STRSAFE_MAX_CCH) ||
        (cchSrc > STRSAFE_MAX_CCH))
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        size_t cbDest;

        // safe to multiply cchDest * sizeof(wchar_t) since cchDest < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
        cbDest = cchDest * sizeof(wchar_t);

        hr = StringCopyNExWorkerW(pszDest, cchDest, cbDest, pszSrc, cchSrc, ppszDestEnd, pcchRemaining, dwFlags);
    }

    return hr;
}
#endif  // STRSAFE_INLINE
#endif  // !STRSAFE_NO_CCH_FUNCTIONS


#ifndef STRSAFE_NO_CB_FUNCTIONS
/*++

STDAPI
StringCbCopyNEx(
    OUT LPTSTR  pszDest         OPTIONAL,
    IN  size_t  cbDest,
    IN  LPCTSTR pszSrc          OPTIONAL,
    IN  size_t  cbSrc,
    OUT LPTSTR* ppszDestEnd     OPTIONAL,
    OUT size_t* pcbRemaining    OPTIONAL,
    IN  DWORD   dwFlags
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strncpy' with
    some additional parameters.  In addition to functionality provided by
    StringCbCopyN, this routine also returns a pointer to the end of the
    destination string and the number of bytes left in the destination string
    including the null terminator. The flags parameter allows additional controls.

    This routine is meant as a replacement for strncpy, but it does behave
    differently. This function will not pad the destination buffer with extra
    null termination characters if cbSrc is greater than the size of pszSrc.

Arguments:

    pszDest         -   destination string

    cbDest          -   size of destination buffer in bytes.
                        length must be ((_tcslen(pszSrc) + 1) * sizeof(TCHAR)) to
                        hold all of the source including the null terminator

    pszSrc          -   source string

    cbSrc           -   maximum number of bytes to copy from source string

    ppszDestEnd     -   if ppszDestEnd is non-null, the function will return a
                        pointer to the end of the destination string.  If the
                        function copied any data, the result will point to the
                        null termination character

    pcbRemaining    -   pcbRemaining is non-null,the function will return the
                        number of bytes left in the destination string,
                        including the null terminator

    dwFlags         -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND_NULL
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer
                    behind the null terminator

        STRSAFE_IGNORE_NULLS
                    treat NULL string pointers like empty strings (TEXT("")).
                    this flag is useful for emulating functions like lstrcpy

        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer, and it will
                    be null terminated. This will overwrite any truncated
                    string returned when the failure is
                    STRSAFE_E_INSUFFICIENT_BUFFER

        STRSAFE_NO_TRUNCATION /
        STRSAFE_NULL_ON_FAILURE
                    if the function fails, the destination buffer will be set
                    to the empty string. This will overwrite any truncated string
                    returned when the failure is STRSAFE_E_INSUFFICIENT_BUFFER.

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL unless the STRSAFE_IGNORE_NULLS flag
    is specified.  If STRSAFE_IGNORE_NULLS is passed, both pszDest and pszSrc
    may be NULL.  An error may still be returned even though NULLS are ignored
    due to insufficient space.

Return Value:

    S_OK           -   if there was source data and it was all copied and the
                       resultant dest string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the copy
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/

STRSAFEAPI StringCbCopyNExA(char* pszDest, size_t cbDest, const char* pszSrc, size_t cbSrc, char** ppszDestEnd, size_t* pcbRemaining, unsigned long dwFlags);
STRSAFEAPI StringCbCopyNExW(wchar_t* pszDest, size_t cbDest, const wchar_t* pszSrc, size_t cbSrc, wchar_t** ppszDestEnd, size_t* pcbRemaining, unsigned long dwFlags);
#ifdef UNICODE
#define StringCbCopyNEx  StringCbCopyNExW
#else
#define StringCbCopyNEx  StringCbCopyNExA
#endif // !UNICODE

#ifdef STRSAFE_INLINE
STRSAFEAPI StringCbCopyNExA(char* pszDest, size_t cbDest, const char* pszSrc, size_t cbSrc, char** ppszDestEnd, size_t* pcbRemaining, unsigned long dwFlags)
{
    HRESULT hr;
    size_t cchDest;
    size_t cchSrc;
    size_t cchRemaining = 0;

    cchDest = cbDest / sizeof(char);
    cchSrc = cbSrc / sizeof(char);

    if ((cchDest > STRSAFE_MAX_CCH) ||
        (cchSrc > STRSAFE_MAX_CCH))
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringCopyNExWorkerA(pszDest, cchDest, cbDest, pszSrc, cchSrc, ppszDestEnd, &cchRemaining, dwFlags);
    }

    if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
    {
        if (pcbRemaining)
        {
            // safe to multiply cchRemaining * sizeof(char) since cchRemaining < STRSAFE_MAX_CCH and sizeof(char) is 1
            *pcbRemaining = (cchRemaining * sizeof(char)) + (cbDest % sizeof(char));
        }
    }

    return hr;
}

STRSAFEAPI StringCbCopyNExW(wchar_t* pszDest, size_t cbDest, const wchar_t* pszSrc, size_t cbSrc, wchar_t** ppszDestEnd, size_t* pcbRemaining, unsigned long dwFlags)
{
    HRESULT hr;
    size_t cchDest;
    size_t cchSrc;
    size_t cchRemaining = 0;

    cchDest = cbDest / sizeof(wchar_t);
    cchSrc = cbSrc / sizeof(wchar_t);

    if ((cchDest > STRSAFE_MAX_CCH) ||
        (cchSrc > STRSAFE_MAX_CCH))
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringCopyNExWorkerW(pszDest, cchDest, cbDest, pszSrc, cchSrc, ppszDestEnd, &cchRemaining, dwFlags);
    }

    if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
    {
        if (pcbRemaining)
        {
            // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
            *pcbRemaining = (cchRemaining * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t));
        }
    }

    return hr;
}
#endif  // STRSAFE_INLINE
#endif  // !STRSAFE_NO_CB_FUNCTIONS


#ifndef STRSAFE_NO_CCH_FUNCTIONS
/*++

STDAPI
StringCchCat(
    IN OUT LPTSTR  pszDest,
    IN     size_t  cchDest,
    IN     LPCTSTR pszSrc
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strcat'.
    The size of the destination buffer (in characters) is a parameter and this
    function will not write past the end of this buffer and it will ALWAYS
    null terminate the destination buffer (unless it is zero length).

    This function returns a hresult, and not a pointer.  It returns
    S_OK if the string was concatenated without truncation and null terminated,
    otherwise it will return a failure code. In failure cases as much of pszSrc
    will be appended to pszDest as possible, and pszDest will be null
    terminated.

Arguments:

    pszDest     -  destination string which must be null terminated

    cchDest     -  size of destination buffer in characters.
                   length must be = (_tcslen(pszDest) + _tcslen(pszSrc) + 1)
                   to hold all of the combine string plus the null
                   terminator

    pszSrc      -  source string which must be null terminated

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL.  See StringCchCatEx if you require
    the handling of NULL values.

Return Value:

    S_OK           -   if there was source data and it was all concatenated and
                       the resultant dest string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the operation
                       failed due to insufficient space. When this error occurs,
                       the destination buffer is modified to contain a truncated
                       version of the ideal result and is null terminated. This
                       is useful for situations where truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/

STRSAFEAPI StringCchCatA(char* pszDest, size_t cchDest, const char* pszSrc);
STRSAFEAPI StringCchCatW(wchar_t* pszDest, size_t cchDest, const wchar_t* pszSrc);
#ifdef UNICODE
#define StringCchCat  StringCchCatW
#else
#define StringCchCat  StringCchCatA
#endif // !UNICODE

#ifdef STRSAFE_INLINE
STRSAFEAPI StringCchCatA(char* pszDest, size_t cchDest, const char* pszSrc)
{
    HRESULT hr;

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringCatWorkerA(pszDest, cchDest, pszSrc);
    }

    return hr;
}

STRSAFEAPI StringCchCatW(wchar_t* pszDest, size_t cchDest, const wchar_t* pszSrc)
{
    HRESULT hr;

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringCatWorkerW(pszDest, cchDest, pszSrc);
    }

    return hr;
}
#endif  // STRSAFE_INLINE
#endif  // !STRSAFE_NO_CCH_FUNCTIONS


#ifndef STRSAFE_NO_CB_FUNCTIONS
/*++

STDAPI
StringCbCat(
    IN OUT LPTSTR  pszDest,
    IN     size_t  cbDest,
    IN     LPCTSTR pszSrc
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strcat'.
    The size of the destination buffer (in bytes) is a parameter and this
    function will not write past the end of this buffer and it will ALWAYS
    null terminate the destination buffer (unless it is zero length).

    This function returns a hresult, and not a pointer.  It returns
    S_OK if the string was concatenated without truncation and null terminated,
    otherwise it will return a failure code. In failure cases as much of pszSrc
    will be appended to pszDest as possible, and pszDest will be null
    terminated.

Arguments:

    pszDest     -  destination string which must be null terminated

    cbDest      -  size of destination buffer in bytes.
                   length must be = ((_tcslen(pszDest) + _tcslen(pszSrc) + 1) * sizeof(TCHAR)
                   to hold all of the combine string plus the null
                   terminator

    pszSrc      -  source string which must be null terminated

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL.  See StringCbCatEx if you require
    the handling of NULL values.

Return Value:

    S_OK           -   if there was source data and it was all concatenated and
                       the resultant dest string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the operation
                       failed due to insufficient space. When this error occurs,
                       the destination buffer is modified to contain a truncated
                       version of the ideal result and is null terminated. This
                       is useful for situations where truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/

STRSAFEAPI StringCbCatA(char* pszDest, size_t cbDest, const char* pszSrc);
STRSAFEAPI StringCbCatW(wchar_t* pszDest, size_t cbDest, const wchar_t* pszSrc);
#ifdef UNICODE
#define StringCbCat  StringCbCatW
#else
#define StringCbCat  StringCbCatA
#endif // !UNICODE

#ifdef STRSAFE_INLINE
STRSAFEAPI StringCbCatA(char* pszDest, size_t cbDest, const char* pszSrc)
{
    HRESULT hr;
    size_t cchDest;

    cchDest = cbDest / sizeof(char);

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringCatWorkerA(pszDest, cchDest, pszSrc);
    }

    return hr;
}

STRSAFEAPI StringCbCatW(wchar_t* pszDest, size_t cbDest, const wchar_t* pszSrc)
{
    HRESULT hr;
    size_t cchDest;

    cchDest = cbDest / sizeof(wchar_t);

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringCatWorkerW(pszDest, cchDest, pszSrc);
    }

    return hr;
}
#endif  // STRSAFE_INLINE
#endif  // !STRSAFE_NO_CB_FUNCTIONS


#ifndef STRSAFE_NO_CCH_FUNCTIONS
/*++

STDAPI
StringCchCatEx(
    IN OUT LPTSTR  pszDest         OPTIONAL,
    IN     size_t  cchDest,
    IN     LPCTSTR pszSrc          OPTIONAL,
    OUT    LPTSTR* ppszDestEnd     OPTIONAL,
    OUT    size_t* pcchRemaining   OPTIONAL,
    IN     DWORD   dwFlags
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strcat' with
    some additional parameters.  In addition to functionality provided by
    StringCchCat, this routine also returns a pointer to the end of the
    destination string and the number of characters left in the destination string
    including the null terminator. The flags parameter allows additional controls.

Arguments:

    pszDest         -   destination string which must be null terminated

    cchDest         -   size of destination buffer in characters
                        length must be (_tcslen(pszDest) + _tcslen(pszSrc) + 1)
                        to hold all of the combine string plus the null
                        terminator.

    pszSrc          -   source string which must be null terminated

    ppszDestEnd     -   if ppszDestEnd is non-null, the function will return a
                        pointer to the end of the destination string.  If the
                        function appended any data, the result will point to the
                        null termination character

    pcchRemaining   -   if pcchRemaining is non-null, the function will return the
                        number of characters left in the destination string,
                        including the null terminator

    dwFlags         -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND_NULL
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer
                    behind the null terminator

        STRSAFE_IGNORE_NULLS
                    treat NULL string pointers like empty strings (TEXT("")).
                    this flag is useful for emulating functions like lstrcat

        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer, and it will
                    be null terminated. This will overwrite any pre-existing
                    or truncated string

        STRSAFE_NULL_ON_FAILURE
                    if the function fails, the destination buffer will be set
                    to the empty string. This will overwrite any pre-existing or
                    truncated string

        STRSAFE_NO_TRUNCATION
                    if the function returns STRSAFE_E_INSUFFICIENT_BUFFER, pszDest
                    will not contain a truncated string, it will remain unchanged.

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL unless the STRSAFE_IGNORE_NULLS flag
    is specified.  If STRSAFE_IGNORE_NULLS is passed, both pszDest and pszSrc
    may be NULL.  An error may still be returned even though NULLS are ignored
    due to insufficient space.

Return Value:

    S_OK           -   if there was source data and it was all concatenated and
                       the resultant dest string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the operation
                       failed due to insufficient space. When this error
                       occurs, the destination buffer is modified to contain
                       a truncated version of the ideal result and is null
                       terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/

STRSAFEAPI StringCchCatExA(char* pszDest, size_t cchDest, const char* pszSrc, char** ppszDestEnd, size_t* pcchRemaining, unsigned long dwFlags);
STRSAFEAPI StringCchCatExW(wchar_t* pszDest, size_t cchDest, const wchar_t* pszSrc, wchar_t** ppszDestEnd, size_t* pcchRemaining, unsigned long dwFlags);
#ifdef UNICODE
#define StringCchCatEx  StringCchCatExW
#else
#define StringCchCatEx  StringCchCatExA
#endif // !UNICODE

#ifdef STRSAFE_INLINE
STRSAFEAPI StringCchCatExA(char* pszDest, size_t cchDest, const char* pszSrc, char** ppszDestEnd, size_t* pcchRemaining, unsigned long dwFlags)
{
    HRESULT hr;

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        size_t cbDest;

        // safe to multiply cchDest * sizeof(char) since cchDest < STRSAFE_MAX_CCH and sizeof(char) is 1
        cbDest = cchDest * sizeof(char);

        hr = StringCatExWorkerA(pszDest, cchDest, cbDest, pszSrc, ppszDestEnd, pcchRemaining, dwFlags);
    }

    return hr;
}

STRSAFEAPI StringCchCatExW(wchar_t* pszDest, size_t cchDest, const wchar_t* pszSrc, wchar_t** ppszDestEnd, size_t* pcchRemaining, unsigned long dwFlags)
{
    HRESULT hr;

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        size_t cbDest;

        // safe to multiply cchDest * sizeof(wchar_t) since cchDest < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
        cbDest = cchDest * sizeof(wchar_t);

        hr = StringCatExWorkerW(pszDest, cchDest, cbDest, pszSrc, ppszDestEnd, pcchRemaining, dwFlags);
    }

    return hr;
}
#endif  // STRSAFE_INLINE
#endif  // !STRSAFE_NO_CCH_FUNCTIONS


#ifndef STRSAFE_NO_CB_FUNCTIONS
/*++

STDAPI
StringCbCatEx(
    IN OUT LPTSTR  pszDest         OPTIONAL,
    IN     size_t  cbDest,
    IN     LPCTSTR pszSrc          OPTIONAL,
    OUT    LPTSTR* ppszDestEnd     OPTIONAL,
    OUT    size_t* pcbRemaining    OPTIONAL,
    IN     DWORD   dwFlags
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strcat' with
    some additional parameters.  In addition to functionality provided by
    StringCbCat, this routine also returns a pointer to the end of the
    destination string and the number of bytes left in the destination string
    including the null terminator. The flags parameter allows additional controls.

Arguments:

    pszDest         -   destination string which must be null terminated

    cbDest          -   size of destination buffer in bytes.
                        length must be ((_tcslen(pszDest) + _tcslen(pszSrc) + 1) * sizeof(TCHAR)
                        to hold all of the combine string plus the null
                        terminator.

    pszSrc          -   source string which must be null terminated

    ppszDestEnd     -   if ppszDestEnd is non-null, the function will return a
                        pointer to the end of the destination string.  If the
                        function appended any data, the result will point to the
                        null termination character

    pcbRemaining    -   if pcbRemaining is non-null, the function will return
                        the number of bytes left in the destination string,
                        including the null terminator

    dwFlags         -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND_NULL
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer
                    behind the null terminator

        STRSAFE_IGNORE_NULLS
                    treat NULL string pointers like empty strings (TEXT("")).
                    this flag is useful for emulating functions like lstrcat

        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer, and it will
                    be null terminated. This will overwrite any pre-existing
                    or truncated string

        STRSAFE_NULL_ON_FAILURE
                    if the function fails, the destination buffer will be set
                    to the empty string. This will overwrite any pre-existing or
                    truncated string

        STRSAFE_NO_TRUNCATION
                    if the function returns STRSAFE_E_INSUFFICIENT_BUFFER, pszDest
                    will not contain a truncated string, it will remain unchanged.

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL unless the STRSAFE_IGNORE_NULLS flag
    is specified.  If STRSAFE_IGNORE_NULLS is passed, both pszDest and pszSrc
    may be NULL.  An error may still be returned even though NULLS are ignored
    due to insufficient space.

Return Value:

    S_OK           -   if there was source data and it was all concatenated
                       and the resultant dest string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the operation
                       failed due to insufficient space. When this error
                       occurs, the destination buffer is modified to contain
                       a truncated version of the ideal result and is null
                       terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/

STRSAFEAPI StringCbCatExA(char* pszDest, size_t cbDest, const char* pszSrc, char** ppszDestEnd, size_t* pcbRemaining, unsigned long dwFlags);
STRSAFEAPI StringCbCatExW(wchar_t* pszDest, size_t cbDest, const wchar_t* pszSrc, wchar_t** ppszDestEnd, size_t* pcbRemaining, unsigned long dwFlags);
#ifdef UNICODE
#define StringCbCatEx  StringCbCatExW
#else
#define StringCbCatEx  StringCbCatExA
#endif // !UNICODE

#ifdef STRSAFE_INLINE
STRSAFEAPI StringCbCatExA(char* pszDest, size_t cbDest, const char* pszSrc, char** ppszDestEnd, size_t* pcbRemaining, unsigned long dwFlags)
{
    HRESULT hr;
    size_t cchDest;
    size_t cchRemaining = 0;

    cchDest = cbDest / sizeof(char);

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringCatExWorkerA(pszDest, cchDest, cbDest, pszSrc, ppszDestEnd, &cchRemaining, dwFlags);
    }

    if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
    {
        if (pcbRemaining)
        {
            // safe to multiply cchRemaining * sizeof(char) since cchRemaining < STRSAFE_MAX_CCH and sizeof(char) is 1
            *pcbRemaining = (cchRemaining * sizeof(char)) + (cbDest % sizeof(char));
        }
    }

    return hr;
}

STRSAFEAPI StringCbCatExW(wchar_t* pszDest, size_t cbDest, const wchar_t* pszSrc, wchar_t** ppszDestEnd, size_t* pcbRemaining, unsigned long dwFlags)
{
    HRESULT hr;
    size_t cchDest;
    size_t cchRemaining = 0;

    cchDest = cbDest / sizeof(wchar_t);

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringCatExWorkerW(pszDest, cchDest, cbDest, pszSrc, ppszDestEnd, &cchRemaining, dwFlags);
    }

    if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
    {
        if (pcbRemaining)
        {
            // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
            *pcbRemaining = (cchRemaining * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t));
        }
    }

    return hr;
}
#endif  // STRSAFE_INLINE
#endif  // !STRSAFE_NO_CB_FUNCTIONS


#ifndef STRSAFE_NO_CCH_FUNCTIONS
/*++

STDAPI
StringCchCatN(
    IN OUT LPTSTR  pszDest,
    IN     size_t  cchDest,
    IN     LPCTSTR pszSrc,
    IN     size_t  cchMaxAppend
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strncat'.
    The size of the destination buffer (in characters) is a parameter as well as
    the maximum number of characters to append, excluding the null terminator.
    This function will not write past the end of the destination buffer and it will
    ALWAYS null terminate pszDest (unless it is zero length).

    This function returns a hresult, and not a pointer.  It returns
    S_OK if all of pszSrc or the first cchMaxAppend characters were appended
    to the destination string and it was null terminated, otherwise it will
    return a failure code. In failure cases as much of pszSrc will be appended
    to pszDest as possible, and pszDest will be null terminated.

Arguments:

    pszDest         -   destination string which must be null terminated

    cchDest         -   size of destination buffer in characters.
                        length must be (_tcslen(pszDest) + min(cchMaxAppend, _tcslen(pszSrc)) + 1)
                        to hold all of the combine string plus the null
                        terminator.

    pszSrc          -   source string

    cchMaxAppend    -   maximum number of characters to append

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL. See StringCchCatNEx if you require
    the handling of NULL values.

Return Value:

    S_OK           -   if all of pszSrc or the first cchMaxAppend characters
                       were concatenated to pszDest and the resultant dest
                       string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the operation
                       failed due to insufficient space. When this error
                       occurs, the destination buffer is modified to contain
                       a truncated version of the ideal result and is null
                       terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/

STRSAFEAPI StringCchCatNA(char* pszDest, size_t cchDest, const char* pszSrc, size_t cchMaxAppend);
STRSAFEAPI StringCchCatNW(wchar_t* pszDest, size_t cchDest, const wchar_t* pszSrc, size_t cchMaxAppend);
#ifdef UNICODE
#define StringCchCatN  StringCchCatNW
#else
#define StringCchCatN  StringCchCatNA
#endif // !UNICODE

#ifdef STRSAFE_INLINE
STRSAFEAPI StringCchCatNA(char* pszDest, size_t cchDest, const char* pszSrc, size_t cchMaxAppend)
{
    HRESULT hr;

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringCatNWorkerA(pszDest, cchDest, pszSrc, cchMaxAppend);
    }

    return hr;
}

STRSAFEAPI StringCchCatNW(wchar_t* pszDest, size_t cchDest, const wchar_t* pszSrc, size_t cchMaxAppend)
{
    HRESULT hr;

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringCatNWorkerW(pszDest, cchDest, pszSrc, cchMaxAppend);
    }

    return hr;
}
#endif  // STRSAFE_INLINE
#endif  // !STRSAFE_NO_CCH_FUNCTIONS


#ifndef STRSAFE_NO_CB_FUNCTIONS
/*++

STDAPI
StringCbCatN(
    IN OUT LPTSTR  pszDest,
    IN     size_t  cbDest,
    IN     LPCTSTR pszSrc,
    IN     size_t  cbMaxAppend
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strncat'.
    The size of the destination buffer (in bytes) is a parameter as well as
    the maximum number of bytes to append, excluding the null terminator.
    This function will not write past the end of the destination buffer and it will
    ALWAYS null terminate pszDest (unless it is zero length).

    This function returns a hresult, and not a pointer.  It returns
    S_OK if all of pszSrc or the first cbMaxAppend bytes were appended
    to the destination string and it was null terminated, otherwise it will
    return a failure code. In failure cases as much of pszSrc will be appended
    to pszDest as possible, and pszDest will be null terminated.

Arguments:

    pszDest         -   destination string which must be null terminated

    cbDest          -   size of destination buffer in bytes.
                        length must be ((_tcslen(pszDest) + min(cbMaxAppend / sizeof(TCHAR), _tcslen(pszSrc)) + 1) * sizeof(TCHAR)
                        to hold all of the combine string plus the null
                        terminator.

    pszSrc          -   source string

    cbMaxAppend     -   maximum number of bytes to append

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL. See StringCbCatNEx if you require
    the handling of NULL values.

Return Value:

    S_OK           -   if all of pszSrc or the first cbMaxAppend bytes were
                       concatenated to pszDest and the resultant dest string
                       was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the operation
                       failed due to insufficient space. When this error
                       occurs, the destination buffer is modified to contain
                       a truncated version of the ideal result and is null
                       terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/

STRSAFEAPI StringCbCatNA(char* pszDest, size_t cbDest, const char* pszSrc, size_t cbMaxAppend);
STRSAFEAPI StringCbCatNW(wchar_t* pszDest, size_t cbDest, const wchar_t* pszSrc, size_t cbMaxAppend);
#ifdef UNICODE
#define StringCbCatN  StringCbCatNW
#else
#define StringCbCatN  StringCbCatNA
#endif // !UNICODE

#ifdef STRSAFE_INLINE
STRSAFEAPI StringCbCatNA(char* pszDest, size_t cbDest, const char* pszSrc, size_t cbMaxAppend)
{
    HRESULT hr;
    size_t cchDest;

    cchDest = cbDest / sizeof(char);

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        size_t cchMaxAppend;

        cchMaxAppend = cbMaxAppend / sizeof(char);

        hr = StringCatNWorkerA(pszDest, cchDest, pszSrc, cchMaxAppend);
    }

    return hr;
}

STRSAFEAPI StringCbCatNW(wchar_t* pszDest, size_t cbDest, const wchar_t* pszSrc, size_t cbMaxAppend)
{
    HRESULT hr;
    size_t cchDest;

    cchDest = cbDest / sizeof(wchar_t);

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        size_t cchMaxAppend;

        cchMaxAppend = cbMaxAppend / sizeof(wchar_t);

        hr = StringCatNWorkerW(pszDest, cchDest, pszSrc, cchMaxAppend);
    }

    return hr;
}
#endif  // STRSAFE_INLINE
#endif  // !STRSAFE_NO_CB_FUNCTIONS


#ifndef STRSAFE_NO_CCH_FUNCTIONS
/*++

STDAPI
StringCchCatNEx(
    IN OUT LPTSTR  pszDest         OPTIONAL,
    IN     size_t  cchDest,
    IN     LPCTSTR pszSrc          OPTIONAL,
    IN     size_t  cchMaxAppend,
    OUT    LPTSTR* ppszDestEnd     OPTIONAL,
    OUT    size_t* pcchRemaining   OPTIONAL,
    IN     DWORD   dwFlags
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strncat', with
    some additional parameters.  In addition to functionality provided by
    StringCchCatN, this routine also returns a pointer to the end of the
    destination string and the number of characters left in the destination string
    including the null terminator. The flags parameter allows additional controls.

Arguments:

    pszDest         -   destination string which must be null terminated

    cchDest         -   size of destination buffer in characters.
                        length must be (_tcslen(pszDest) + min(cchMaxAppend, _tcslen(pszSrc)) + 1)
                        to hold all of the combine string plus the null
                        terminator.

    pszSrc          -   source string

    cchMaxAppend    -   maximum number of characters to append

    ppszDestEnd     -   if ppszDestEnd is non-null, the function will return a
                        pointer to the end of the destination string.  If the
                        function appended any data, the result will point to the
                        null termination character

    pcchRemaining   -   if pcchRemaining is non-null, the function will return the
                        number of characters left in the destination string,
                        including the null terminator

    dwFlags         -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND_NULL
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer
                    behind the null terminator

        STRSAFE_IGNORE_NULLS
                    treat NULL string pointers like empty strings (TEXT(""))

        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer, and it will
                    be null terminated. This will overwrite any pre-existing
                    or truncated string

        STRSAFE_NULL_ON_FAILURE
                    if the function fails, the destination buffer will be set
                    to the empty string. This will overwrite any pre-existing or
                    truncated string

        STRSAFE_NO_TRUNCATION
                    if the function returns STRSAFE_E_INSUFFICIENT_BUFFER, pszDest
                    will not contain a truncated string, it will remain unchanged.

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL unless the STRSAFE_IGNORE_NULLS flag
    is specified.  If STRSAFE_IGNORE_NULLS is passed, both pszDest and pszSrc
    may be NULL.  An error may still be returned even though NULLS are ignored
    due to insufficient space.

Return Value:

    S_OK           -   if all of pszSrc or the first cchMaxAppend characters
                       were concatenated to pszDest and the resultant dest
                       string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the operation
                       failed due to insufficient space. When this error
                       occurs, the destination buffer is modified to contain
                       a truncated version of the ideal result and is null
                       terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/

STRSAFEAPI StringCchCatNExA(char* pszDest, size_t cchDest, const char* pszSrc, size_t cchMaxAppend, char** ppszDestEnd, size_t* pcchRemaining, unsigned long dwFlags);
STRSAFEAPI StringCchCatNExW(wchar_t* pszDest, size_t cchDest, const wchar_t* pszSrc, size_t cchMaxAppend, wchar_t** ppszDestEnd, size_t* pcchRemaining, unsigned long dwFlags);
#ifdef UNICODE
#define StringCchCatNEx  StringCchCatNExW
#else
#define StringCchCatNEx  StringCchCatNExA
#endif // !UNICODE

#ifdef STRSAFE_INLINE
STRSAFEAPI StringCchCatNExA(char* pszDest, size_t cchDest, const char* pszSrc, size_t cchMaxAppend, char** ppszDestEnd, size_t* pcchRemaining, unsigned long dwFlags)
{
    HRESULT hr;

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        size_t cbDest;

        // safe to multiply cchDest * sizeof(char) since cchDest < STRSAFE_MAX_CCH and sizeof(char) is 1
        cbDest = cchDest * sizeof(char);

        hr = StringCatNExWorkerA(pszDest, cchDest, cbDest, pszSrc, cchMaxAppend, ppszDestEnd, pcchRemaining, dwFlags);
    }

    return hr;
}

STRSAFEAPI StringCchCatNExW(wchar_t* pszDest, size_t cchDest, const wchar_t* pszSrc, size_t cchMaxAppend, wchar_t** ppszDestEnd, size_t* pcchRemaining, unsigned long dwFlags)
{
    HRESULT hr;

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        size_t cbDest;

        // safe to multiply cchDest * sizeof(wchar_t) since cchDest < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
        cbDest = cchDest * sizeof(wchar_t);

        hr = StringCatNExWorkerW(pszDest, cchDest, cbDest, pszSrc, cchMaxAppend, ppszDestEnd, pcchRemaining, dwFlags);
    }

    return hr;
}
#endif  // STRSAFE_INLINE
#endif  // !STRSAFE_NO_CCH_FUNCTIONS


#ifndef STRSAFE_NO_CB_FUNCTIONS
/*++

STDAPI
StringCbCatNEx(
    IN OUT LPTSTR  pszDest         OPTIONAL,
    IN     size_t  cbDest,
    IN     LPCTSTR pszSrc          OPTIONAL,
    IN     size_t  cbMaxAppend,
    OUT    LPTSTR* ppszDestEnd     OPTIONAL,
    OUT    size_t* pcchRemaining   OPTIONAL,
    IN     DWORD   dwFlags
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strncat', with
    some additional parameters.  In addition to functionality provided by
    StringCbCatN, this routine also returns a pointer to the end of the
    destination string and the number of bytes left in the destination string
    including the null terminator. The flags parameter allows additional controls.

Arguments:

    pszDest         -   destination string which must be null terminated

    cbDest          -   size of destination buffer in bytes.
                        length must be ((_tcslen(pszDest) + min(cbMaxAppend / sizeof(TCHAR), _tcslen(pszSrc)) + 1) * sizeof(TCHAR)
                        to hold all of the combine string plus the null
                        terminator.

    pszSrc          -   source string

    cbMaxAppend     -   maximum number of bytes to append

    ppszDestEnd     -   if ppszDestEnd is non-null, the function will return a
                        pointer to the end of the destination string.  If the
                        function appended any data, the result will point to the
                        null termination character

    pcbRemaining    -   if pcbRemaining is non-null, the function will return the
                        number of bytes left in the destination string,
                        including the null terminator

    dwFlags         -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND_NULL
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer
                    behind the null terminator

        STRSAFE_IGNORE_NULLS
                    treat NULL string pointers like empty strings (TEXT(""))

        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer, and it will
                    be null terminated. This will overwrite any pre-existing
                    or truncated string

        STRSAFE_NULL_ON_FAILURE
                    if the function fails, the destination buffer will be set
                    to the empty string. This will overwrite any pre-existing or
                    truncated string

        STRSAFE_NO_TRUNCATION
                    if the function returns STRSAFE_E_INSUFFICIENT_BUFFER, pszDest
                    will not contain a truncated string, it will remain unchanged.

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL unless the STRSAFE_IGNORE_NULLS flag
    is specified.  If STRSAFE_IGNORE_NULLS is passed, both pszDest and pszSrc
    may be NULL.  An error may still be returned even though NULLS are ignored
    due to insufficient space.

Return Value:

    S_OK           -   if all of pszSrc or the first cbMaxAppend bytes were
                       concatenated to pszDest and the resultant dest string
                       was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the operation
                       failed due to insufficient space. When this error
                       occurs, the destination buffer is modified to contain
                       a truncated version of the ideal result and is null
                       terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/

STRSAFEAPI StringCbCatNExA(char* pszDest, size_t cbDest, const char* pszSrc, size_t cbMaxAppend, char** ppszDestEnd, size_t* pcbRemaining, unsigned long dwFlags);
STRSAFEAPI StringCbCatNExW(wchar_t* pszDest, size_t cbDest, const wchar_t* pszSrc, size_t cbMaxAppend, wchar_t** ppszDestEnd, size_t* pcbRemaining, unsigned long dwFlags);
#ifdef UNICODE
#define StringCbCatNEx  StringCbCatNExW
#else
#define StringCbCatNEx  StringCbCatNExA
#endif // !UNICODE

#ifdef STRSAFE_INLINE
STRSAFEAPI StringCbCatNExA(char* pszDest, size_t cbDest, const char* pszSrc, size_t cbMaxAppend, char** ppszDestEnd, size_t* pcbRemaining, unsigned long dwFlags)
{
    HRESULT hr;
    size_t cchDest;
    size_t cchRemaining = 0;

    cchDest = cbDest / sizeof(char);

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        size_t cchMaxAppend;

        cchMaxAppend = cbMaxAppend / sizeof(char);

        hr = StringCatNExWorkerA(pszDest, cchDest, cbDest, pszSrc, cchMaxAppend, ppszDestEnd, &cchRemaining, dwFlags);
    }

    if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
    {
        if (pcbRemaining)
        {
            // safe to multiply cchRemaining * sizeof(char) since cchRemaining < STRSAFE_MAX_CCH and sizeof(char) is 1
            *pcbRemaining = (cchRemaining * sizeof(char)) + (cbDest % sizeof(char));
        }
    }

    return hr;
}

STRSAFEAPI StringCbCatNExW(wchar_t* pszDest, size_t cbDest, const wchar_t* pszSrc, size_t cbMaxAppend, wchar_t** ppszDestEnd, size_t* pcbRemaining, unsigned long dwFlags)
{
    HRESULT hr;
    size_t cchDest;
    size_t cchRemaining = 0;

    cchDest = cbDest / sizeof(wchar_t);

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        size_t cchMaxAppend;

        cchMaxAppend = cbMaxAppend / sizeof(wchar_t);

        hr = StringCatNExWorkerW(pszDest, cchDest, cbDest, pszSrc, cchMaxAppend, ppszDestEnd, &cchRemaining, dwFlags);
    }

    if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
    {
        if (pcbRemaining)
        {
            // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
            *pcbRemaining = (cchRemaining * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t));
        }
    }

    return hr;
}
#endif  // STRSAFE_INLINE
#endif  // !STRSAFE_NO_CB_FUNCTIONS


#ifndef STRSAFE_NO_CCH_FUNCTIONS
/*++

STDAPI
StringCchVPrintf(
    OUT LPTSTR  pszDest,
    IN  size_t  cchDest,
    IN  LPCTSTR pszFormat,
    IN  va_list argList
    );

Routine Description:

    This routine is a safer version of the C built-in function 'vsprintf'.
    The size of the destination buffer (in characters) is a parameter and
    this function will not write past the end of this buffer and it will
    ALWAYS null terminate the destination buffer (unless it is zero length).

    This function returns a hresult, and not a pointer.  It returns
    S_OK if the string was printed without truncation and null terminated,
    otherwise it will return a failure code. In failure cases it will return
    a truncated version of the ideal result.

Arguments:

    pszDest     -  destination string

    cchDest     -  size of destination buffer in characters
                   length must be sufficient to hold the resulting formatted
                   string, including the null terminator.

    pszFormat   -  format string which must be null terminated

    argList     -  va_list from the variable arguments according to the
                   stdarg.h convention

Notes:
    Behavior is undefined if destination, format strings or any arguments
    strings overlap.

    pszDest and pszFormat should not be NULL.  See StringCchVPrintfEx if you
    require the handling of NULL values.

Return Value:

    S_OK           -   if there was sufficient space in the dest buffer for
                       the resultant string and it was null terminated.

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the print
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/

STRSAFEAPI StringCchVPrintfA(char* pszDest, size_t cchDest, const char* pszFormat, va_list argList);
STRSAFEAPI StringCchVPrintfW(wchar_t* pszDest, size_t cchDest, const wchar_t* pszFormat, va_list argList);
#ifdef UNICODE
#define StringCchVPrintf  StringCchVPrintfW
#else
#define StringCchVPrintf  StringCchVPrintfA
#endif // !UNICODE

#ifdef STRSAFE_INLINE
STRSAFEAPI StringCchVPrintfA(char* pszDest, size_t cchDest, const char* pszFormat, va_list argList)
{
    HRESULT hr;

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringVPrintfWorkerA(pszDest, cchDest, pszFormat, argList);
    }

    return hr;
}

STRSAFEAPI StringCchVPrintfW(wchar_t* pszDest, size_t cchDest, const wchar_t* pszFormat, va_list argList)
{
    HRESULT hr;

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringVPrintfWorkerW(pszDest, cchDest, pszFormat, argList);
    }

    return hr;
}
#endif  // STRSAFE_INLINE
#endif  // !STRSAFE_NO_CCH_FUNCTIONS


#ifndef STRSAFE_NO_CB_FUNCTIONS
/*++

STDAPI
StringCbVPrintf(
    OUT LPTSTR  pszDest,
    IN  size_t  cbDest,
    IN  LPCTSTR pszFormat,
    IN  va_list argList
    );

Routine Description:

    This routine is a safer version of the C built-in function 'vsprintf'.
    The size of the destination buffer (in bytes) is a parameter and
    this function will not write past the end of this buffer and it will
    ALWAYS null terminate the destination buffer (unless it is zero length).

    This function returns a hresult, and not a pointer.  It returns
    S_OK if the string was printed without truncation and null terminated,
    otherwise it will return a failure code. In failure cases it will return
    a truncated version of the ideal result.

Arguments:

    pszDest     -  destination string

    cbDest      -  size of destination buffer in bytes
                   length must be sufficient to hold the resulting formatted
                   string, including the null terminator.

    pszFormat   -  format string which must be null terminated

    argList     -  va_list from the variable arguments according to the
                   stdarg.h convention

Notes:
    Behavior is undefined if destination, format strings or any arguments
    strings overlap.

    pszDest and pszFormat should not be NULL.  See StringCbVPrintfEx if you
    require the handling of NULL values.


Return Value:

    S_OK           -   if there was sufficient space in the dest buffer for
                       the resultant string and it was null terminated.

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the print
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/

STRSAFEAPI StringCbVPrintfA(char* pszDest, size_t cbDest, const char* pszFormat, va_list argList);
STRSAFEAPI StringCbVPrintfW(wchar_t* pszDest, size_t cbDest, const wchar_t* pszFormat, va_list argList);
#ifdef UNICODE
#define StringCbVPrintf  StringCbVPrintfW
#else
#define StringCbVPrintf  StringCbVPrintfA
#endif // !UNICODE

#ifdef STRSAFE_INLINE
STRSAFEAPI StringCbVPrintfA(char* pszDest, size_t cbDest, const char* pszFormat, va_list argList)
{
    HRESULT hr;
    size_t cchDest;

    cchDest = cbDest / sizeof(char);

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringVPrintfWorkerA(pszDest, cchDest, pszFormat, argList);
    }

    return hr;
}

STRSAFEAPI StringCbVPrintfW(wchar_t* pszDest, size_t cbDest, const wchar_t* pszFormat, va_list argList)
{
    HRESULT hr;
    size_t cchDest;

    cchDest = cbDest / sizeof(wchar_t);

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringVPrintfWorkerW(pszDest, cchDest, pszFormat, argList);
    }

    return hr;
}
#endif  // STRSAFE_INLINE
#endif  // !STRSAFE_NO_CB_FUNCTIONS


#ifndef STRSAFE_NO_CCH_FUNCTIONS
/*++

STDAPI
StringCchPrintf(
    OUT LPTSTR  pszDest,
    IN  size_t  cchDest,
    IN  LPCTSTR pszFormat,
    ...
    );

Routine Description:

    This routine is a safer version of the C built-in function 'sprintf'.
    The size of the destination buffer (in characters) is a parameter and
    this function will not write past the end of this buffer and it will
    ALWAYS null terminate the destination buffer (unless it is zero length).

    This function returns a hresult, and not a pointer.  It returns
    S_OK if the string was printed without truncation and null terminated,
    otherwise it will return a failure code. In failure cases it will return
    a truncated version of the ideal result.

Arguments:

    pszDest     -  destination string

    cchDest     -  size of destination buffer in characters
                   length must be sufficient to hold the resulting formatted
                   string, including the null terminator.

    pszFormat   -  format string which must be null terminated

    ...         -  additional parameters to be formatted according to
                   the format string

Notes:
    Behavior is undefined if destination, format strings or any arguments
    strings overlap.

    pszDest and pszFormat should not be NULL.  See StringCchPrintfEx if you
    require the handling of NULL values.

Return Value:

    S_OK           -   if there was sufficient space in the dest buffer for
                       the resultant string and it was null terminated.

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the print
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/

STRSAFEAPI StringCchPrintfA(char* pszDest, size_t cchDest, const char* pszFormat, ...);
STRSAFEAPI StringCchPrintfW(wchar_t* pszDest, size_t cchDest, const wchar_t* pszFormat, ...);
#ifdef UNICODE
#define StringCchPrintf  StringCchPrintfW
#else
#define StringCchPrintf  StringCchPrintfA
#endif // !UNICODE

#ifdef STRSAFE_INLINE
STRSAFEAPI StringCchPrintfA(char* pszDest, size_t cchDest, const char* pszFormat, ...)
{
    HRESULT hr;

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        va_list argList;

        va_start(argList, pszFormat);

        hr = StringVPrintfWorkerA(pszDest, cchDest, pszFormat, argList);

        va_end(argList);
    }

    return hr;
}

STRSAFEAPI StringCchPrintfW(wchar_t* pszDest, size_t cchDest, const wchar_t* pszFormat, ...)
{
    HRESULT hr;

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        va_list argList;

        va_start(argList, pszFormat);

        hr = StringVPrintfWorkerW(pszDest, cchDest, pszFormat, argList);

        va_end(argList);
    }

    return hr;
}
#endif  // STRSAFE_INLINE
#endif  // !STRSAFE_NO_CCH_FUNCTIONS


#ifndef STRSAFE_NO_CB_FUNCTIONS
/*++

STDAPI
StringCbPrintf(
    OUT LPTSTR  pszDest,
    IN  size_t  cbDest,
    IN  LPCTSTR pszFormat,
    ...
    );

Routine Description:

    This routine is a safer version of the C built-in function 'sprintf'.
    The size of the destination buffer (in bytes) is a parameter and
    this function will not write past the end of this buffer and it will
    ALWAYS null terminate the destination buffer (unless it is zero length).

    This function returns a hresult, and not a pointer.  It returns
    S_OK if the string was printed without truncation and null terminated,
    otherwise it will return a failure code. In failure cases it will return
    a truncated version of the ideal result.

Arguments:

    pszDest     -  destination string

    cbDest      -  size of destination buffer in bytes
                   length must be sufficient to hold the resulting formatted
                   string, including the null terminator.

    pszFormat   -  format string which must be null terminated

    ...         -  additional parameters to be formatted according to
                   the format string

Notes:
    Behavior is undefined if destination, format strings or any arguments
    strings overlap.

    pszDest and pszFormat should not be NULL.  See StringCbPrintfEx if you
    require the handling of NULL values.


Return Value:

    S_OK           -   if there was sufficient space in the dest buffer for
                       the resultant string and it was null terminated.

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the print
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/

STRSAFEAPI StringCbPrintfA(char* pszDest, size_t cbDest, const char* pszFormat, ...);
STRSAFEAPI StringCbPrintfW(wchar_t* pszDest, size_t cbDest, const wchar_t* pszFormat, ...);
#ifdef UNICODE
#define StringCbPrintf  StringCbPrintfW
#else
#define StringCbPrintf  StringCbPrintfA
#endif // !UNICODE

#ifdef STRSAFE_INLINE
STRSAFEAPI StringCbPrintfA(char* pszDest, size_t cbDest, const char* pszFormat, ...)
{
    HRESULT hr;
    size_t cchDest;

    cchDest = cbDest / sizeof(char);

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        va_list argList;

        va_start(argList, pszFormat);

        hr = StringVPrintfWorkerA(pszDest, cchDest, pszFormat, argList);

        va_end(argList);
    }

    return hr;
}

STRSAFEAPI StringCbPrintfW(wchar_t* pszDest, size_t cbDest, const wchar_t* pszFormat, ...)
{
    HRESULT hr;
    size_t cchDest;

    cchDest = cbDest / sizeof(wchar_t);

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        va_list argList;

        va_start(argList, pszFormat);

        hr = StringVPrintfWorkerW(pszDest, cchDest, pszFormat, argList);

        va_end(argList);
    }

    return hr;
}
#endif  // STRSAFE_INLINE
#endif  // !STRSAFE_NO_CB_FUNCTIONS


#ifndef STRSAFE_NO_CCH_FUNCTIONS
/*++

STDAPI
StringCchPrintfEx(
    OUT LPTSTR  pszDest         OPTIONAL,
    IN  size_t  cchDest,
    OUT LPTSTR* ppszDestEnd     OPTIONAL,
    OUT size_t* pcchRemaining   OPTIONAL,
    IN  DWORD   dwFlags,
    IN  LPCTSTR pszFormat       OPTIONAL,
    ...
    );

Routine Description:

    This routine is a safer version of the C built-in function 'sprintf' with
    some additional parameters.  In addition to functionality provided by
    StringCchPrintf, this routine also returns a pointer to the end of the
    destination string and the number of characters left in the destination string
    including the null terminator. The flags parameter allows additional controls.

Arguments:

    pszDest         -   destination string

    cchDest         -   size of destination buffer in characters.
                        length must be sufficient to contain the resulting
                        formatted string plus the null terminator.

    ppszDestEnd     -   if ppszDestEnd is non-null, the function will return a
                        pointer to the end of the destination string.  If the
                        function printed any data, the result will point to the
                        null termination character

    pcchRemaining   -   if pcchRemaining is non-null, the function will return
                        the number of characters left in the destination string,
                        including the null terminator

    dwFlags         -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND_NULL
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer
                    behind the null terminator

        STRSAFE_IGNORE_NULLS
                    treat NULL string pointers like empty strings (TEXT(""))

        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer, and it will
                    be null terminated. This will overwrite any truncated
                    string returned when the failure is
                    STRSAFE_E_INSUFFICIENT_BUFFER

        STRSAFE_NO_TRUNCATION /
        STRSAFE_NULL_ON_FAILURE
                    if the function fails, the destination buffer will be set
                    to the empty string. This will overwrite any truncated string
                    returned when the failure is STRSAFE_E_INSUFFICIENT_BUFFER.

    pszFormat       -   format string which must be null terminated

    ...             -   additional parameters to be formatted according to
                        the format string

Notes:
    Behavior is undefined if destination, format strings or any arguments
    strings overlap.

    pszDest and pszFormat should not be NULL unless the STRSAFE_IGNORE_NULLS
    flag is specified.  If STRSAFE_IGNORE_NULLS is passed, both pszDest and
    pszFormat may be NULL.  An error may still be returned even though NULLS
    are ignored due to insufficient space.

Return Value:

    S_OK           -   if there was source data and it was all concatenated and
                       the resultant dest string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the print
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/

STRSAFEAPI StringCchPrintfExA(char* pszDest, size_t cchDest, char** ppszDestEnd, size_t* pcchRemaining, unsigned long dwFlags, const char* pszFormat, ...);
STRSAFEAPI StringCchPrintfExW(wchar_t* pszDest, size_t cchDest, wchar_t** ppszDestEnd, size_t* pcchRemaining, unsigned long dwFlags, const wchar_t* pszFormat, ...);
#ifdef UNICODE
#define StringCchPrintfEx  StringCchPrintfExW
#else
#define StringCchPrintfEx  StringCchPrintfExA
#endif // !UNICODE

#ifdef STRSAFE_INLINE
STRSAFEAPI StringCchPrintfExA(char* pszDest, size_t cchDest, char** ppszDestEnd, size_t* pcchRemaining, unsigned long dwFlags, const char* pszFormat, ...)
{
    HRESULT hr;

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        size_t cbDest;
        va_list argList;

        // safe to multiply cchDest * sizeof(char) since cchDest < STRSAFE_MAX_CCH and sizeof(char) is 1
        cbDest = cchDest * sizeof(char);
        va_start(argList, pszFormat);

        hr = StringVPrintfExWorkerA(pszDest, cchDest, cbDest, ppszDestEnd, pcchRemaining, dwFlags, pszFormat, argList);

        va_end(argList);
    }

    return hr;
}

STRSAFEAPI StringCchPrintfExW(wchar_t* pszDest, size_t cchDest, wchar_t** ppszDestEnd, size_t* pcchRemaining, unsigned long dwFlags, const wchar_t* pszFormat, ...)
{
    HRESULT hr;

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        size_t cbDest;
        va_list argList;

        // safe to multiply cchDest * sizeof(wchar_t) since cchDest < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
        cbDest = cchDest * sizeof(wchar_t);
        va_start(argList, pszFormat);

        hr = StringVPrintfExWorkerW(pszDest, cchDest, cbDest, ppszDestEnd, pcchRemaining, dwFlags, pszFormat, argList);

        va_end(argList);
    }

    return hr;
}
#endif  // STRSAFE_INLINE
#endif  // !STRSAFE_NO_CCH_FUNCTIONS


#ifndef STRSAFE_NO_CB_FUNCTIONS
/*++

STDAPI
StringCbPrintfEx(
    OUT LPTSTR  pszDest         OPTIONAL,
    IN  size_t  cbDest,
    OUT LPTSTR* ppszDestEnd     OPTIONAL,
    OUT size_t* pcbRemaining    OPTIONAL,
    IN  DWORD   dwFlags,
    IN  LPCTSTR pszFormat       OPTIONAL,
    ...
    );

Routine Description:

    This routine is a safer version of the C built-in function 'sprintf' with
    some additional parameters.  In addition to functionality provided by
    StringCbPrintf, this routine also returns a pointer to the end of the
    destination string and the number of bytes left in the destination string
    including the null terminator. The flags parameter allows additional controls.

Arguments:

    pszDest         -   destination string

    cbDest          -   size of destination buffer in bytes.
                        length must be sufficient to contain the resulting
                        formatted string plus the null terminator.

    ppszDestEnd     -   if ppszDestEnd is non-null, the function will return a
                        pointer to the end of the destination string.  If the
                        function printed any data, the result will point to the
                        null termination character

    pcbRemaining    -   if pcbRemaining is non-null, the function will return
                        the number of bytes left in the destination string,
                        including the null terminator

    dwFlags         -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND_NULL
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer
                    behind the null terminator

        STRSAFE_IGNORE_NULLS
                    treat NULL string pointers like empty strings (TEXT(""))

        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer, and it will
                    be null terminated. This will overwrite any truncated
                    string returned when the failure is
                    STRSAFE_E_INSUFFICIENT_BUFFER

        STRSAFE_NO_TRUNCATION /
        STRSAFE_NULL_ON_FAILURE
                    if the function fails, the destination buffer will be set
                    to the empty string. This will overwrite any truncated string
                    returned when the failure is STRSAFE_E_INSUFFICIENT_BUFFER.

    pszFormat       -   format string which must be null terminated

    ...             -   additional parameters to be formatted according to
                        the format string

Notes:
    Behavior is undefined if destination, format strings or any arguments
    strings overlap.

    pszDest and pszFormat should not be NULL unless the STRSAFE_IGNORE_NULLS
    flag is specified.  If STRSAFE_IGNORE_NULLS is passed, both pszDest and
    pszFormat may be NULL.  An error may still be returned even though NULLS
    are ignored due to insufficient space.

Return Value:

    S_OK           -   if there was source data and it was all concatenated and
                       the resultant dest string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the print
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/

STRSAFEAPI StringCbPrintfExA(char* pszDest, size_t cbDest, char** ppszDestEnd, size_t* pcbRemaining, unsigned long dwFlags, const char* pszFormat, ...);
STRSAFEAPI StringCbPrintfExW(wchar_t* pszDest, size_t cbDest, wchar_t** ppszDestEnd, size_t* pcbRemaining, unsigned long dwFlags, const wchar_t* pszFormat, ...);
#ifdef UNICODE
#define StringCbPrintfEx  StringCbPrintfExW
#else
#define StringCbPrintfEx  StringCbPrintfExA
#endif // !UNICODE

#ifdef STRSAFE_INLINE
STRSAFEAPI StringCbPrintfExA(char* pszDest, size_t cbDest, char** ppszDestEnd, size_t* pcbRemaining, unsigned long dwFlags, const char* pszFormat, ...)
{
    HRESULT hr;
    size_t cchDest;
    size_t cchRemaining = 0;

    cchDest = cbDest / sizeof(char);

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        va_list argList;

        va_start(argList, pszFormat);

        hr = StringVPrintfExWorkerA(pszDest, cchDest, cbDest, ppszDestEnd, &cchRemaining, dwFlags, pszFormat, argList);

        va_end(argList);
    }

    if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
    {
        if (pcbRemaining)
        {
            // safe to multiply cchRemaining * sizeof(char) since cchRemaining < STRSAFE_MAX_CCH and sizeof(char) is 1
            *pcbRemaining = (cchRemaining * sizeof(char)) + (cbDest % sizeof(char));
        }
    }

    return hr;
}

STRSAFEAPI StringCbPrintfExW(wchar_t* pszDest, size_t cbDest, wchar_t** ppszDestEnd, size_t* pcbRemaining, unsigned long dwFlags, const wchar_t* pszFormat, ...)
{
    HRESULT hr;
    size_t cchDest;
    size_t cchRemaining = 0;

    cchDest = cbDest / sizeof(wchar_t);

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        va_list argList;

        va_start(argList, pszFormat);

        hr = StringVPrintfExWorkerW(pszDest, cchDest, cbDest, ppszDestEnd, &cchRemaining, dwFlags, pszFormat, argList);

        va_end(argList);
    }

    if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
    {
        if (pcbRemaining)
        {
            // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
            *pcbRemaining = (cchRemaining * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t));
        }
    }

    return hr;
}
#endif  // STRSAFE_INLINE
#endif  // !STRSAFE_NO_CB_FUNCTIONS


#ifndef STRSAFE_NO_CCH_FUNCTIONS
/*++

STDAPI
StringCchVPrintfEx(
    OUT LPTSTR  pszDest         OPTIONAL,
    IN  size_t  cchDest,
    OUT LPTSTR* ppszDestEnd     OPTIONAL,
    OUT size_t* pcchRemaining   OPTIONAL,
    IN  DWORD   dwFlags,
    IN  LPCTSTR pszFormat       OPTIONAL,
    IN  va_list argList
    );

Routine Description:

    This routine is a safer version of the C built-in function 'vsprintf' with
    some additional parameters.  In addition to functionality provided by
    StringCchVPrintf, this routine also returns a pointer to the end of the
    destination string and the number of characters left in the destination string
    including the null terminator. The flags parameter allows additional controls.

Arguments:

    pszDest         -   destination string

    cchDest         -   size of destination buffer in characters.
                        length must be sufficient to contain the resulting
                        formatted string plus the null terminator.

    ppszDestEnd     -   if ppszDestEnd is non-null, the function will return a
                        pointer to the end of the destination string.  If the
                        function printed any data, the result will point to the
                        null termination character

    pcchRemaining   -   if pcchRemaining is non-null, the function will return
                        the number of characters left in the destination string,
                        including the null terminator

    dwFlags         -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND_NULL
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer
                    behind the null terminator

        STRSAFE_IGNORE_NULLS
                    treat NULL string pointers like empty strings (TEXT(""))

        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer, and it will
                    be null terminated. This will overwrite any truncated
                    string returned when the failure is
                    STRSAFE_E_INSUFFICIENT_BUFFER

        STRSAFE_NO_TRUNCATION /
        STRSAFE_NULL_ON_FAILURE
                    if the function fails, the destination buffer will be set
                    to the empty string. This will overwrite any truncated string
                    returned when the failure is STRSAFE_E_INSUFFICIENT_BUFFER.

    pszFormat       -   format string which must be null terminated

    argList         -   va_list from the variable arguments according to the
                        stdarg.h convention

Notes:
    Behavior is undefined if destination, format strings or any arguments
    strings overlap.

    pszDest and pszFormat should not be NULL unless the STRSAFE_IGNORE_NULLS
    flag is specified.  If STRSAFE_IGNORE_NULLS is passed, both pszDest and
    pszFormat may be NULL.  An error may still be returned even though NULLS
    are ignored due to insufficient space.

Return Value:

    S_OK           -   if there was source data and it was all concatenated and
                       the resultant dest string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the print
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/

STRSAFEAPI StringCchVPrintfExA(char* pszDest, size_t cchDest, char** ppszDestEnd, size_t* pcchRemaining, unsigned long dwFlags, const char* pszFormat, va_list argList);
STRSAFEAPI StringCchVPrintfExW(wchar_t* pszDest, size_t cchDest, wchar_t** ppszDestEnd, size_t* pcchRemaining, unsigned long dwFlags, const wchar_t* pszFormat, va_list argList);
#ifdef UNICODE
#define StringCchVPrintfEx  StringCchVPrintfExW
#else
#define StringCchVPrintfEx  StringCchVPrintfExA
#endif // !UNICODE

#ifdef STRSAFE_INLINE
STRSAFEAPI StringCchVPrintfExA(char* pszDest, size_t cchDest, char** ppszDestEnd, size_t* pcchRemaining, unsigned long dwFlags, const char* pszFormat, va_list argList)
{
    HRESULT hr;

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        size_t cbDest;

        // safe to multiply cchDest * sizeof(char) since cchDest < STRSAFE_MAX_CCH and sizeof(char) is 1
        cbDest = cchDest * sizeof(char);

        hr = StringVPrintfExWorkerA(pszDest, cchDest, cbDest, ppszDestEnd, pcchRemaining, dwFlags, pszFormat, argList);
    }

    return hr;
}

STRSAFEAPI StringCchVPrintfExW(wchar_t* pszDest, size_t cchDest, wchar_t** ppszDestEnd, size_t* pcchRemaining, unsigned long dwFlags, const wchar_t* pszFormat, va_list argList)
{
    HRESULT hr;

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        size_t cbDest;

        // safe to multiply cchDest * sizeof(wchar_t) since cchDest < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
        cbDest = cchDest * sizeof(wchar_t);

        hr = StringVPrintfExWorkerW(pszDest, cchDest, cbDest, ppszDestEnd, pcchRemaining, dwFlags, pszFormat, argList);
    }

    return hr;
}
#endif  // STRSAFE_INLINE
#endif  // !STRSAFE_NO_CCH_FUNCTIONS


#ifndef STRSAFE_NO_CB_FUNCTIONS
/*++

STDAPI
StringCbVPrintfEx(
    OUT LPTSTR  pszDest         OPTIONAL,
    IN  size_t  cbDest,
    OUT LPTSTR* ppszDestEnd     OPTIONAL,
    OUT size_t* pcbRemaining    OPTIONAL,
    IN  DWORD   dwFlags,
    IN  LPCTSTR pszFormat       OPTIONAL,
    IN  va_list argList
    );

Routine Description:

    This routine is a safer version of the C built-in function 'vsprintf' with
    some additional parameters.  In addition to functionality provided by
    StringCbVPrintf, this routine also returns a pointer to the end of the
    destination string and the number of characters left in the destination string
    including the null terminator. The flags parameter allows additional controls.

Arguments:

    pszDest         -   destination string

    cbDest          -   size of destination buffer in bytes.
                        length must be sufficient to contain the resulting
                        formatted string plus the null terminator.

    ppszDestEnd     -   if ppszDestEnd is non-null, the function will return
                        a pointer to the end of the destination string.  If the
                        function printed any data, the result will point to the
                        null termination character

    pcbRemaining    -   if pcbRemaining is non-null, the function will return
                        the number of bytes left in the destination string,
                        including the null terminator

    dwFlags         -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND_NULL
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer
                    behind the null terminator

        STRSAFE_IGNORE_NULLS
                    treat NULL string pointers like empty strings (TEXT(""))

        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer, and it will
                    be null terminated. This will overwrite any truncated
                    string returned when the failure is
                    STRSAFE_E_INSUFFICIENT_BUFFER

        STRSAFE_NO_TRUNCATION /
        STRSAFE_NULL_ON_FAILURE
                    if the function fails, the destination buffer will be set
                    to the empty string. This will overwrite any truncated string
                    returned when the failure is STRSAFE_E_INSUFFICIENT_BUFFER.

    pszFormat       -   format string which must be null terminated

    argList         -   va_list from the variable arguments according to the
                        stdarg.h convention

Notes:
    Behavior is undefined if destination, format strings or any arguments
    strings overlap.

    pszDest and pszFormat should not be NULL unless the STRSAFE_IGNORE_NULLS
    flag is specified.  If STRSAFE_IGNORE_NULLS is passed, both pszDest and
    pszFormat may be NULL.  An error may still be returned even though NULLS
    are ignored due to insufficient space.

Return Value:

    S_OK           -   if there was source data and it was all concatenated and
                       the resultant dest string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the print
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/

STRSAFEAPI StringCbVPrintfExA(char* pszDest, size_t cbDest, char** ppszDestEnd, size_t* pcbRemaining, unsigned long dwFlags, const char* pszFormat, va_list argList);
STRSAFEAPI StringCbVPrintfExW(wchar_t* pszDest, size_t cbDest, wchar_t** ppszDestEnd, size_t* pcbRemaining, unsigned long dwFlags, const wchar_t* pszFormat, va_list argList);
#ifdef UNICODE
#define StringCbVPrintfEx  StringCbVPrintfExW
#else
#define StringCbVPrintfEx  StringCbVPrintfExA
#endif // !UNICODE

#ifdef STRSAFE_INLINE
STRSAFEAPI StringCbVPrintfExA(char* pszDest, size_t cbDest, char** ppszDestEnd, size_t* pcbRemaining, unsigned long dwFlags, const char* pszFormat, va_list argList)
{
    HRESULT hr;
    size_t cchDest;
    size_t cchRemaining = 0;

    cchDest = cbDest / sizeof(char);

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringVPrintfExWorkerA(pszDest, cchDest, cbDest, ppszDestEnd, &cchRemaining, dwFlags, pszFormat, argList);
    }

    if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
    {
        if (pcbRemaining)
        {
            // safe to multiply cchRemaining * sizeof(char) since cchRemaining < STRSAFE_MAX_CCH and sizeof(char) is 1
            *pcbRemaining = (cchRemaining * sizeof(char)) + (cbDest % sizeof(char));
        }
    }

    return hr;
}

STRSAFEAPI StringCbVPrintfExW(wchar_t* pszDest, size_t cbDest, wchar_t** ppszDestEnd, size_t* pcbRemaining, unsigned long dwFlags, const wchar_t* pszFormat, va_list argList)
{
    HRESULT hr;
    size_t cchDest;
    size_t cchRemaining = 0;

    cchDest = cbDest / sizeof(wchar_t);

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringVPrintfExWorkerW(pszDest, cchDest, cbDest, ppszDestEnd, &cchRemaining, dwFlags, pszFormat, argList);
    }

    if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
    {
        if (pcbRemaining)
        {
            // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
            *pcbRemaining = (cchRemaining * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t));
        }
    }

    return hr;
}
#endif  // STRSAFE_INLINE
#endif  // !STRSAFE_NO_CB_FUNCTIONS


#ifndef STRSAFE_NO_CCH_FUNCTIONS
/*++

STDAPI
StringCchGets(
    OUT LPTSTR  pszDest,
    IN  size_t  cchDest
    );

Routine Description:

    This routine is a safer version of the C built-in function 'gets'.
    The size of the destination buffer (in characters) is a parameter and
    this function will not write past the end of this buffer and it will
    ALWAYS null terminate the destination buffer (unless it is zero length).

    This routine is not a replacement for fgets.  That function does not replace
    newline characters with a null terminator.

    This function returns a hresult, and not a pointer.  It returns
    S_OK if any characters were read from stdin and copied to pszDest and
    pszDest was null terminated, otherwise it will return a failure code.

Arguments:

    pszDest     -   destination string

    cchDest     -   size of destination buffer in characters.

Notes:
    pszDest should not be NULL. See StringCchGetsEx if you require the handling
    of NULL values.

    cchDest must be > 1 for this function to succeed.

Return Value:

    S_OK           -   data was read from stdin and copied, and the resultant
                       dest string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_END_OF_FILE /
      HRESULT_CODE(hr) == ERROR_HANDLE_EOF
                   -   this return value indicates an error or end-of-file
                       condition, use feof or ferror to determine which one has
                       occured.

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that there was
                       insufficient space in the destination buffer to copy any
                       data

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function.

--*/

#ifndef STRSAFE_LIB_IMPL
STRSAFE_INLINE_API StringCchGetsA(char* pszDest, size_t cchDest);
STRSAFE_INLINE_API StringCchGetsW(wchar_t* pszDest, size_t cchDest);
#ifdef UNICODE
#define StringCchGets  StringCchGetsW
#else
#define StringCchGets  StringCchGetsA
#endif // !UNICODE

STRSAFE_INLINE_API StringCchGetsA(char* pszDest, size_t cchDest)
{
    HRESULT hr;

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        size_t cbDest;

        // safe to multiply cchDest * sizeof(char) since cchDest < STRSAFE_MAX_CCH and sizeof(char) is 1
        cbDest = cchDest * sizeof(char);

        hr = StringGetsExWorkerA(pszDest, cchDest, cbDest, NULL, NULL, 0);
    }

    return hr;
}

STRSAFE_INLINE_API StringCchGetsW(wchar_t* pszDest, size_t cchDest)
{
    HRESULT hr;

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        size_t cbDest;

        // safe to multiply cchDest * sizeof(wchar_t) since cchDest < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
        cbDest = cchDest * sizeof(wchar_t);

        hr = StringGetsExWorkerW(pszDest, cchDest, cbDest, NULL, NULL, 0);
    }

    return hr;
}
#endif  // !STRSAFE_NO_CCH_FUNCTIONS
#endif  // !STRSAFE_LIB_IMPL

#ifndef STRSAFE_NO_CB_FUNCTIONS
/*++

STDAPI
StringCbGets(
    OUT LPTSTR  pszDest,
    IN  size_t  cbDest
    );

Routine Description:

    This routine is a safer version of the C built-in function 'gets'.
    The size of the destination buffer (in bytes) is a parameter and
    this function will not write past the end of this buffer and it will
    ALWAYS null terminate the destination buffer (unless it is zero length).

    This routine is not a replacement for fgets.  That function does not replace
    newline characters with a null terminator.

    This function returns a hresult, and not a pointer.  It returns
    S_OK if any characters were read from stdin and copied to pszDest
    and pszDest was null terminated, otherwise it will return a failure code.

Arguments:

    pszDest     -   destination string

    cbDest      -   size of destination buffer in bytes.

Notes:
    pszDest should not be NULL. See StringCbGetsEx if you require the handling
    of NULL values.

    cbDest must be > sizeof(TCHAR) for this function to succeed.

Return Value:

    S_OK           -   data was read from stdin and copied, and the resultant
                       dest string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_END_OF_FILE /
      HRESULT_CODE(hr) == ERROR_HANDLE_EOF
                   -   this return value indicates an error or end-of-file
                       condition, use feof or ferror to determine which one has
                       occured.

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that there was
                       insufficient space in the destination buffer to copy any
                       data

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function.

--*/

#ifndef STRSAFE_LIB_IMPL
STRSAFE_INLINE_API StringCbGetsA(char* pszDest, size_t cbDest);
STRSAFE_INLINE_API StringCbGetsW(wchar_t* pszDest, size_t cbDest);
#ifdef UNICODE
#define StringCbGets  StringCbGetsW
#else
#define StringCbGets  StringCbGetsA
#endif // !UNICODE

STRSAFE_INLINE_API StringCbGetsA(char* pszDest, size_t cbDest)
{
    HRESULT hr;
    size_t cchDest;

    // convert to count of characters
    cchDest = cbDest / sizeof(char);

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringGetsExWorkerA(pszDest, cchDest, cbDest, NULL, NULL, 0);
    }

    return hr;
}

STRSAFE_INLINE_API StringCbGetsW(wchar_t* pszDest, size_t cbDest)
{
    HRESULT hr;
    size_t cchDest;

    // convert to count of characters
    cchDest = cbDest / sizeof(wchar_t);

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringGetsExWorkerW(pszDest, cchDest, cbDest, NULL, NULL, 0);
    }

    return hr;
}
#endif  // !STRSAFE_NO_CB_FUNCTIONS
#endif  // !STRSAFE_LIB_IMPL

#ifndef STRSAFE_NO_CCH_FUNCTIONS
/*++

STDAPI
StringCchGetsEx(
    OUT LPTSTR  pszDest         OPTIONAL,
    IN  size_t  cchDest,
    OUT LPTSTR* ppszDestEnd     OPTIONAL,
    OUT size_t* pcchRemaining   OPTIONAL,
    IN  DWORD   dwFlags
    );

Routine Description:

    This routine is a safer version of the C built-in function 'gets' with
    some additional parameters. In addition to functionality provided by
    StringCchGets, this routine also returns a pointer to the end of the
    destination string and the number of characters left in the destination string
    including the null terminator. The flags parameter allows additional controls.

Arguments:

    pszDest         -   destination string

    cchDest         -   size of destination buffer in characters.

    ppszDestEnd     -   if ppszDestEnd is non-null, the function will return a
                        pointer to the end of the destination string.  If the
                        function copied any data, the result will point to the
                        null termination character

    pcchRemaining   -   if pcchRemaining is non-null, the function will return the
                        number of characters left in the destination string,
                        including the null terminator

    dwFlags         -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND_NULL
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer
                    behind the null terminator

        STRSAFE_IGNORE_NULLS
                    treat NULL string pointers like empty strings (TEXT("")).

        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer, and it will
                    be null terminated.

        STRSAFE_NO_TRUNCATION /
        STRSAFE_NULL_ON_FAILURE
                    if the function fails, the destination buffer will be set
                    to the empty string.

Notes:
    pszDest should not be NULL unless the STRSAFE_IGNORE_NULLS flag is specified.
    If STRSAFE_IGNORE_NULLS is passed and pszDest is NULL, an error may still be
    returned even though NULLS are ignored

    cchDest must be > 1 for this function to succeed.

Return Value:

    S_OK           -   data was read from stdin and copied, and the resultant
                       dest string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_END_OF_FILE /
      HRESULT_CODE(hr) == ERROR_HANDLE_EOF
                   -   this return value indicates an error or end-of-file
                       condition, use feof or ferror to determine which one has
                       occured.

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that there was
                       insufficient space in the destination buffer to copy any
                       data

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function.

--*/

#ifndef STRSAFE_LIB_IMPL
STRSAFE_INLINE_API StringCchGetsExA(char* pszDest, size_t cchDest, char** ppszDestEnd, size_t* pcchRemaining, unsigned long dwFlags);
STRSAFE_INLINE_API StringCchGetsExW(wchar_t* pszDest, size_t cchDest, wchar_t** ppszDestEnd, size_t* pcchRemaining, unsigned long dwFlags);
#ifdef UNICODE
#define StringCchGetsEx  StringCchGetsExW
#else
#define StringCchGetsEx  StringCchGetsExA
#endif // !UNICODE

STRSAFE_INLINE_API StringCchGetsExA(char* pszDest, size_t cchDest, char** ppszDestEnd, size_t* pcchRemaining, unsigned long dwFlags)
{
    HRESULT hr;

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        size_t cbDest;

        // safe to multiply cchDest * sizeof(char) since cchDest < STRSAFE_MAX_CCH and sizeof(char) is 1
        cbDest = cchDest * sizeof(char);

        hr = StringGetsExWorkerA(pszDest, cchDest, cbDest, ppszDestEnd, pcchRemaining, dwFlags);
    }

    return hr;
}

STRSAFE_INLINE_API StringCchGetsExW(wchar_t* pszDest, size_t cchDest, wchar_t** ppszDestEnd, size_t* pcchRemaining, unsigned long dwFlags)
{
    HRESULT hr;

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        size_t cbDest;

        // safe to multiply cchDest * sizeof(wchar_t) since cchDest < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
        cbDest = cchDest * sizeof(wchar_t);

        hr = StringGetsExWorkerW(pszDest, cchDest, cbDest, ppszDestEnd, pcchRemaining, dwFlags);
    }

    return hr;
}
#endif  // !STRSAFE_NO_CCH_FUNCTIONS
#endif  // !STRSAFE_LIB_IMPL

#ifndef STRSAFE_NO_CB_FUNCTIONS
/*++

STDAPI
StringCbGetsEx(
    OUT LPTSTR  pszDest         OPTIONAL,
    IN  size_t  cbDest,
    OUT LPTSTR* ppszDestEnd     OPTIONAL,
    OUT size_t* pcbRemaining    OPTIONAL,
    IN  DWORD   dwFlags
    );

Routine Description:

    This routine is a safer version of the C built-in function 'gets' with
    some additional parameters. In addition to functionality provided by
    StringCbGets, this routine also returns a pointer to the end of the
    destination string and the number of characters left in the destination string
    including the null terminator. The flags parameter allows additional controls.

Arguments:

    pszDest         -   destination string

    cbDest          -   size of destination buffer in bytes.

    ppszDestEnd     -   if ppszDestEnd is non-null, the function will return a
                        pointer to the end of the destination string.  If the
                        function copied any data, the result will point to the
                        null termination character

    pcbRemaining    -   if pbRemaining is non-null, the function will return the
                        number of bytes left in the destination string,
                        including the null terminator

    dwFlags         -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND_NULL
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer
                    behind the null terminator

        STRSAFE_IGNORE_NULLS
                    treat NULL string pointers like empty strings (TEXT("")).

        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer, and it will
                    be null terminated.

        STRSAFE_NO_TRUNCATION /
        STRSAFE_NULL_ON_FAILURE
                    if the function fails, the destination buffer will be set
                    to the empty string.

Notes:
    pszDest should not be NULL unless the STRSAFE_IGNORE_NULLS flag is specified.
    If STRSAFE_IGNORE_NULLS is passed and pszDest is NULL, an error may still be
    returned even though NULLS are ignored

    cbDest must be > sizeof(TCHAR) for this function to succeed

Return Value:

    S_OK           -   data was read from stdin and copied, and the resultant
                       dest string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_END_OF_FILE /
      HRESULT_CODE(hr) == ERROR_HANDLE_EOF
                   -   this return value indicates an error or end-of-file
                       condition, use feof or ferror to determine which one has
                       occured.

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that there was
                       insufficient space in the destination buffer to copy any
                       data

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function.

--*/

#ifndef STRSAFE_LIB_IMPL
STRSAFE_INLINE_API StringCbGetsExA(char* pszDest, size_t cbDest, char** ppszDestEnd, size_t* pbRemaining, unsigned long dwFlags);
STRSAFE_INLINE_API StringCbGetsExW(wchar_t* pszDest, size_t cbDest, wchar_t** ppszDestEnd, size_t* pcbRemaining, unsigned long dwFlags);
#ifdef UNICODE
#define StringCbGetsEx  StringCbGetsExW
#else
#define StringCbGetsEx  StringCbGetsExA
#endif // !UNICODE

STRSAFE_INLINE_API StringCbGetsExA(char* pszDest, size_t cbDest, char** ppszDestEnd, size_t* pcbRemaining, unsigned long dwFlags)
{
    HRESULT hr;
    size_t cchDest;
    size_t cchRemaining = 0;

    cchDest = cbDest / sizeof(char);

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringGetsExWorkerA(pszDest, cchDest, cbDest, ppszDestEnd, &cchRemaining, dwFlags);
    }

    if (SUCCEEDED(hr) ||
        (hr == STRSAFE_E_INSUFFICIENT_BUFFER) ||
        (hr == STRSAFE_E_END_OF_FILE))
    {
        if (pcbRemaining)
        {
            // safe to multiply cchRemaining * sizeof(char) since cchRemaining < STRSAFE_MAX_CCH and sizeof(char) is 1
            *pcbRemaining = (cchRemaining * sizeof(char)) + (cbDest % sizeof(char));
        }
    }

    return hr;
}

STRSAFE_INLINE_API StringCbGetsExW(wchar_t* pszDest, size_t cbDest, wchar_t** ppszDestEnd, size_t* pcbRemaining, unsigned long dwFlags)
{
    HRESULT hr;
    size_t cchDest;
    size_t cchRemaining = 0;

    cchDest = cbDest / sizeof(wchar_t);

    if (cchDest > STRSAFE_MAX_CCH)
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringGetsExWorkerW(pszDest, cchDest, cbDest, ppszDestEnd, &cchRemaining, dwFlags);
    }

    if (SUCCEEDED(hr) ||
        (hr == STRSAFE_E_INSUFFICIENT_BUFFER) ||
        (hr == STRSAFE_E_END_OF_FILE))
    {
        if (pcbRemaining)
        {
            // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
            *pcbRemaining = (cchRemaining * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t));
        }
    }

    return hr;
}
#endif  // !STRSAFE_NO_CB_FUNCTIONS
#endif  // !STRSAFE_LIB_IMPL

#ifndef STRSAFE_NO_CCH_FUNCTIONS
/*++

STDAPI
StringCchLength(
    IN  LPCTSTR psz,
    IN  size_t  cchMax,
    OUT size_t* pcch    OPTIONAL
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strlen'.
    It is used to make sure a string is not larger than a given length, and
    it optionally returns the current length in characters not including
    the null terminator.

    This function returns a hresult, and not a pointer.  It returns
    S_OK if the string is non-null and the length including the null
    terminator is less than or equal to cchMax characters.

Arguments:

    psz         -   string to check the length of

    cchMax      -   maximum number of characters including the null terminator
                    that psz is allowed to contain

    pcch        -   if the function succeeds and pcch is non-null, the current length
                    in characters of psz excluding the null terminator will be returned.
                    This out parameter is equivalent to the return value of strlen(psz)

Notes:
    psz can be null but the function will fail

    cchMax should be greater than zero or the function will fail

Return Value:

    S_OK           -   psz is non-null and the length including the null
                       terminator is less than or equal to cchMax characters

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function.

--*/

STRSAFEAPI StringCchLengthA(const char* psz, size_t cchMax, size_t* pcch);
STRSAFEAPI StringCchLengthW(const wchar_t* psz, size_t cchMax, size_t* pcch);
#ifdef UNICODE
#define StringCchLength  StringCchLengthW
#else
#define StringCchLength  StringCchLengthA
#endif // !UNICODE

#ifdef STRSAFE_INLINE
STRSAFEAPI StringCchLengthA(const char* psz, size_t cchMax, size_t* pcch)
{
    HRESULT hr;

    if ((psz == NULL) || (cchMax > STRSAFE_MAX_CCH))
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringLengthWorkerA(psz, cchMax, pcch);
    }

    return hr;
}

STRSAFEAPI StringCchLengthW(const wchar_t* psz, size_t cchMax, size_t* pcch)
{
    HRESULT hr;

    if ((psz == NULL) || (cchMax > STRSAFE_MAX_CCH))
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringLengthWorkerW(psz, cchMax, pcch);
    }

    return hr;
}
#endif  // STRSAFE_INLINE
#endif  // !STRSAFE_NO_CCH_FUNCTIONS


#ifndef STRSAFE_NO_CB_FUNCTIONS
/*++

STDAPI
StringCbLength(
    IN  LPCTSTR psz,
    IN  size_t  cbMax,
    OUT size_t* pcb     OPTIONAL
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strlen'.
    It is used to make sure a string is not larger than a given length, and
    it optionally returns the current length in bytes not including
    the null terminator.

    This function returns a hresult, and not a pointer.  It returns
    S_OK if the string is non-null and the length including the null
    terminator is less than or equal to cbMax bytes.

Arguments:

    psz         -   string to check the length of

    cbMax       -   maximum number of bytes including the null terminator
                    that psz is allowed to contain

    pcb         -   if the function succeeds and pcb is non-null, the current length
                    in bytes of psz excluding the null terminator will be returned.
                    This out parameter is equivalent to the return value of strlen(psz) * sizeof(TCHAR)

Notes:
    psz can be null but the function will fail

    cbMax should be greater than or equal to sizeof(TCHAR) or the function will fail

Return Value:

    S_OK           -   psz is non-null and the length including the null
                       terminator is less than or equal to cbMax bytes

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function.

--*/

STRSAFEAPI StringCbLengthA(const char* psz, size_t cchMax, size_t* pcch);
STRSAFEAPI StringCbLengthW(const wchar_t* psz, size_t cchMax, size_t* pcch);
#ifdef UNICODE
#define StringCbLength  StringCbLengthW
#else
#define StringCbLength  StringCbLengthA
#endif // !UNICODE

#ifdef STRSAFE_INLINE
STRSAFEAPI StringCbLengthA(const char* psz, size_t cbMax, size_t* pcb)
{
    HRESULT hr;
    size_t cchMax;
    size_t cch = 0;

    cchMax = cbMax / sizeof(char);

    if ((psz == NULL) || (cchMax > STRSAFE_MAX_CCH))
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringLengthWorkerA(psz, cchMax, &cch);
    }

    if (SUCCEEDED(hr) && pcb)
    {
        // safe to multiply cch * sizeof(char) since cch < STRSAFE_MAX_CCH and sizeof(char) is 1
        *pcb = cch * sizeof(char);
    }

    return hr;
}

STRSAFEAPI StringCbLengthW(const wchar_t* psz, size_t cbMax, size_t* pcb)
{
    HRESULT hr;
    size_t cchMax;
    size_t cch = 0;

    cchMax = cbMax / sizeof(wchar_t);

    if ((psz == NULL) || (cchMax > STRSAFE_MAX_CCH))
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringLengthWorkerW(psz, cchMax, &cch);
    }

    if (SUCCEEDED(hr) && pcb)
    {
        // safe to multiply cch * sizeof(wchar_t) since cch < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
        *pcb = cch * sizeof(wchar_t);
    }

    return hr;
}
#endif  // STRSAFE_INLINE
#endif  // !STRSAFE_NO_CB_FUNCTIONS


// these are the worker functions that actually do the work
#ifdef STRSAFE_INLINE
STRSAFEAPI StringCopyWorkerA(char* pszDest, size_t cchDest, const char* pszSrc)
{
    HRESULT hr = S_OK;

    if (cchDest == 0)
    {
        // can not null terminate a zero-byte dest buffer
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        while (cchDest && (*pszSrc != '\0'))
        {
            *pszDest++ = *pszSrc++;
            cchDest--;
        }

        if (cchDest == 0)
        {
            // we are going to truncate pszDest
            pszDest--;
            hr = STRSAFE_E_INSUFFICIENT_BUFFER;
        }

        *pszDest= '\0';
    }

    return hr;
}

STRSAFEAPI StringCopyWorkerW(wchar_t* pszDest, size_t cchDest, const wchar_t* pszSrc)
{
    HRESULT hr = S_OK;

    if (cchDest == 0)
    {
        // can not null terminate a zero-byte dest buffer
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        while (cchDest && (*pszSrc != L'\0'))
        {
            *pszDest++ = *pszSrc++;
            cchDest--;
        }

        if (cchDest == 0)
        {
            // we are going to truncate pszDest
            pszDest--;
            hr = STRSAFE_E_INSUFFICIENT_BUFFER;
        }

        *pszDest= L'\0';
    }

    return hr;
}

STRSAFEAPI StringCopyExWorkerA(char* pszDest, size_t cchDest, size_t cbDest, const char* pszSrc, char** ppszDestEnd, size_t* pcchRemaining, unsigned long dwFlags)
{
    HRESULT hr = S_OK;
    char* pszDestEnd = pszDest;
    size_t cchRemaining = 0;

    // ASSERT(cbDest == (cchDest * sizeof(char))    ||
    //        cbDest == (cchDest * sizeof(char)) + (cbDest % sizeof(char)));

    // only accept valid flags
    if (dwFlags & (~STRSAFE_VALID_FLAGS))
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        if (dwFlags & STRSAFE_IGNORE_NULLS)
        {
            if (pszDest == NULL)
            {
                if ((cchDest != 0) || (cbDest != 0))
                {
                    // NULL pszDest and non-zero cchDest/cbDest is invalid
                    hr = STRSAFE_E_INVALID_PARAMETER;
                }
            }

            if (pszSrc == NULL)
            {
                pszSrc = "";
            }
        }

        if (SUCCEEDED(hr))
        {
            if (cchDest == 0)
            {
                pszDestEnd = pszDest;
                cchRemaining = 0;

                // only fail if there was actually src data to copy
                if (*pszSrc != '\0')
                {
                    if (pszDest == NULL)
                    {
                        hr = STRSAFE_E_INVALID_PARAMETER;
                    }
                    else
                    {
                        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                    }
                }
            }
            else
            {
                pszDestEnd = pszDest;
                cchRemaining = cchDest;

                while (cchRemaining && (*pszSrc != '\0'))
                {
                    *pszDestEnd++= *pszSrc++;
                    cchRemaining--;
                }

                if (cchRemaining > 0)
                {
                    if (dwFlags & STRSAFE_FILL_BEHIND_NULL)
                    {
                        memset(pszDestEnd + 1, STRSAFE_GET_FILL_PATTERN(dwFlags), ((cchRemaining - 1) * sizeof(char)) + (cbDest % sizeof(char)));
                    }
                }
                else
                {
                    // we are going to truncate pszDest
                    pszDestEnd--;
                    cchRemaining++;

                    hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                }

                *pszDestEnd = '\0';
            }
        }
    }

    if (FAILED(hr))
    {
        if (pszDest)
        {
            if (dwFlags & STRSAFE_FILL_ON_FAILURE)
            {
                memset(pszDest, STRSAFE_GET_FILL_PATTERN(dwFlags), cbDest);

                if (STRSAFE_GET_FILL_PATTERN(dwFlags) == 0)
                {
                    pszDestEnd = pszDest;
                    cchRemaining = cchDest;
                }
                else if (cchDest > 0)
                {
                    pszDestEnd = pszDest + cchDest - 1;
                    cchRemaining = 1;

                    // null terminate the end of the string
                    *pszDestEnd = '\0';
                }
            }

            if (dwFlags & (STRSAFE_NULL_ON_FAILURE | STRSAFE_NO_TRUNCATION))
            {
                if (cchDest > 0)
                {
                    pszDestEnd = pszDest;
                    cchRemaining = cchDest;

                    // null terminate the beginning of the string
                    *pszDestEnd = '\0';
                }
            }
        }
    }

    if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
    {
        if (ppszDestEnd)
        {
            *ppszDestEnd = pszDestEnd;
        }

        if (pcchRemaining)
        {
            *pcchRemaining = cchRemaining;
        }
    }

    return hr;
}

STRSAFEAPI StringCopyExWorkerW(wchar_t* pszDest, size_t cchDest, size_t cbDest, const wchar_t* pszSrc, wchar_t** ppszDestEnd, size_t* pcchRemaining, unsigned long dwFlags)
{
    HRESULT hr = S_OK;
    wchar_t* pszDestEnd = pszDest;
    size_t cchRemaining = 0;

    // ASSERT(cbDest == (cchDest * sizeof(wchar_t)) ||
    //        cbDest == (cchDest * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t)));

    // only accept valid flags
    if (dwFlags & (~STRSAFE_VALID_FLAGS))
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        if (dwFlags & STRSAFE_IGNORE_NULLS)
        {
            if (pszDest == NULL)
            {
                if ((cchDest != 0) || (cbDest != 0))
                {
                    // NULL pszDest and non-zero cchDest/cbDest is invalid
                    hr = STRSAFE_E_INVALID_PARAMETER;
                }
            }

            if (pszSrc == NULL)
            {
                pszSrc = L"";
            }
        }

        if (SUCCEEDED(hr))
        {
            if (cchDest == 0)
            {
                pszDestEnd = pszDest;
                cchRemaining = 0;

                // only fail if there was actually src data to copy
                if (*pszSrc != L'\0')
                {
                    if (pszDest == NULL)
                    {
                        hr = STRSAFE_E_INVALID_PARAMETER;
                    }
                    else
                    {
                        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                    }
                }
            }
            else
            {
                pszDestEnd = pszDest;
                cchRemaining = cchDest;

                while (cchRemaining && (*pszSrc != L'\0'))
                {
                    *pszDestEnd++= *pszSrc++;
                    cchRemaining--;
                }

                if (cchRemaining > 0)
                {
                    if (dwFlags & STRSAFE_FILL_BEHIND_NULL)
                    {
                        memset(pszDestEnd + 1, STRSAFE_GET_FILL_PATTERN(dwFlags), ((cchRemaining - 1) * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t)));
                    }
                }
                else
                {
                    // we are going to truncate pszDest
                    pszDestEnd--;
                    cchRemaining++;

                    hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                }

                *pszDestEnd = L'\0';
            }
        }
    }

    if (FAILED(hr))
    {
        if (pszDest)
        {
            if (dwFlags & STRSAFE_FILL_ON_FAILURE)
            {
                memset(pszDest, STRSAFE_GET_FILL_PATTERN(dwFlags), cbDest);

                if (STRSAFE_GET_FILL_PATTERN(dwFlags) == 0)
                {
                    pszDestEnd = pszDest;
                    cchRemaining = cchDest;
                }
                else if (cchDest > 0)
                {
                    pszDestEnd = pszDest + cchDest - 1;
                    cchRemaining = 1;

                    // null terminate the end of the string
                    *pszDestEnd = L'\0';
                }
            }

            if (dwFlags & (STRSAFE_NULL_ON_FAILURE | STRSAFE_NO_TRUNCATION))
            {
                if (cchDest > 0)
                {
                    pszDestEnd = pszDest;
                    cchRemaining = cchDest;

                    // null terminate the beginning of the string
                    *pszDestEnd = L'\0';
                }
            }
        }
    }

    if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
    {
        if (ppszDestEnd)
        {
            *ppszDestEnd = pszDestEnd;
        }

        if (pcchRemaining)
        {
            *pcchRemaining = cchRemaining;
        }
    }

    return hr;
}

STRSAFEAPI StringCopyNWorkerA(char* pszDest, size_t cchDest, const char* pszSrc, size_t cchSrc)
{
    HRESULT hr = S_OK;

    if (cchDest == 0)
    {
        // can not null terminate a zero-byte dest buffer
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        while (cchDest && cchSrc && (*pszSrc != '\0'))
        {
            *pszDest++= *pszSrc++;
            cchDest--;
            cchSrc--;
        }

        if (cchDest == 0)
        {
            // we are going to truncate pszDest
            pszDest--;
            hr = STRSAFE_E_INSUFFICIENT_BUFFER;
        }

        *pszDest= '\0';
    }

    return hr;
}

STRSAFEAPI StringCopyNWorkerW(wchar_t* pszDest, size_t cchDest, const wchar_t* pszSrc, size_t cchSrc)
{
    HRESULT hr = S_OK;

    if (cchDest == 0)
    {
        // can not null terminate a zero-byte dest buffer
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        while (cchDest && cchSrc && (*pszSrc != L'\0'))
        {
            *pszDest++= *pszSrc++;
            cchDest--;
            cchSrc--;
        }

        if (cchDest == 0)
        {
            // we are going to truncate pszDest
            pszDest--;
            hr = STRSAFE_E_INSUFFICIENT_BUFFER;
        }

        *pszDest= L'\0';
    }

    return hr;
}

STRSAFEAPI StringCopyNExWorkerA(char* pszDest, size_t cchDest, size_t cbDest, const char* pszSrc, size_t cchSrc, char** ppszDestEnd, size_t* pcchRemaining, unsigned long dwFlags)
{
    HRESULT hr = S_OK;
    char* pszDestEnd = pszDest;
    size_t cchRemaining = 0;

    // ASSERT(cbDest == (cchDest * sizeof(char))    ||
    //        cbDest == (cchDest * sizeof(char)) + (cbDest % sizeof(char)));

    // only accept valid flags
    if (dwFlags & (~STRSAFE_VALID_FLAGS))
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        if (dwFlags & STRSAFE_IGNORE_NULLS)
        {
            if (pszDest == NULL)
            {
                if ((cchDest != 0) || (cbDest != 0))
                {
                    // NULL pszDest and non-zero cchDest/cbDest is invalid
                    hr = STRSAFE_E_INVALID_PARAMETER;
                }
            }

            if (pszSrc == NULL)
            {
                pszSrc = "";
            }
        }

        if (SUCCEEDED(hr))
        {
            if (cchDest == 0)
            {
                pszDestEnd = pszDest;
                cchRemaining = 0;

                // only fail if there was actually src data to copy
                if (*pszSrc != '\0')
                {
                    if (pszDest == NULL)
                    {
                        hr = STRSAFE_E_INVALID_PARAMETER;
                    }
                    else
                    {
                        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                    }
                }
            }
            else
            {
                pszDestEnd = pszDest;
                cchRemaining = cchDest;

                while (cchRemaining && cchSrc && (*pszSrc != '\0'))
                {
                    *pszDestEnd++= *pszSrc++;
                    cchRemaining--;
                    cchSrc--;
                }

                if (cchRemaining > 0)
                {
                    if (dwFlags & STRSAFE_FILL_BEHIND_NULL)
                    {
                        memset(pszDestEnd + 1, STRSAFE_GET_FILL_PATTERN(dwFlags), ((cchRemaining - 1) * sizeof(char)) + (cbDest % sizeof(char)));
                    }
                }
                else
                {
                    // we are going to truncate pszDest
                    pszDestEnd--;
                    cchRemaining++;

                    hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                }

                *pszDestEnd = '\0';
            }
        }
    }

    if (FAILED(hr))
    {
        if (pszDest)
        {
            if (dwFlags & STRSAFE_FILL_ON_FAILURE)
            {
                memset(pszDest, STRSAFE_GET_FILL_PATTERN(dwFlags), cbDest);

                if (STRSAFE_GET_FILL_PATTERN(dwFlags) == 0)
                {
                    pszDestEnd = pszDest;
                    cchRemaining = cchDest;
                }
                else if (cchDest > 0)
                {
                    pszDestEnd = pszDest + cchDest - 1;
                    cchRemaining = 1;

                    // null terminate the end of the string
                    *pszDestEnd = '\0';
                }
            }

            if (dwFlags & (STRSAFE_NULL_ON_FAILURE | STRSAFE_NO_TRUNCATION))
            {
                if (cchDest > 0)
                {
                    pszDestEnd = pszDest;
                    cchRemaining = cchDest;

                    // null terminate the beginning of the string
                    *pszDestEnd = '\0';
                }
            }
        }
    }

    if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
    {
        if (ppszDestEnd)
        {
            *ppszDestEnd = pszDestEnd;
        }

        if (pcchRemaining)
        {
            *pcchRemaining = cchRemaining;
        }
    }

    return hr;
}

STRSAFEAPI StringCopyNExWorkerW(wchar_t* pszDest, size_t cchDest, size_t cbDest, const wchar_t* pszSrc, size_t cchSrc, wchar_t** ppszDestEnd, size_t* pcchRemaining, unsigned long dwFlags)
{
    HRESULT hr = S_OK;
    wchar_t* pszDestEnd = pszDest;
    size_t cchRemaining = 0;

    // ASSERT(cbDest == (cchDest * sizeof(wchar_t)) ||
    //        cbDest == (cchDest * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t)));

    // only accept valid flags
    if (dwFlags & (~STRSAFE_VALID_FLAGS))
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        if (dwFlags & STRSAFE_IGNORE_NULLS)
        {
            if (pszDest == NULL)
            {
                if ((cchDest != 0) || (cbDest != 0))
                {
                    // NULL pszDest and non-zero cchDest/cbDest is invalid
                    hr = STRSAFE_E_INVALID_PARAMETER;
                }
            }

            if (pszSrc == NULL)
            {
                pszSrc = L"";
            }
        }

        if (SUCCEEDED(hr))
        {
            if (cchDest == 0)
            {
                pszDestEnd = pszDest;
                cchRemaining = 0;

                // only fail if there was actually src data to copy
                if (*pszSrc != L'\0')
                {
                    if (pszDest == NULL)
                    {
                        hr = STRSAFE_E_INVALID_PARAMETER;
                    }
                    else
                    {
                        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                    }
                }
            }
            else
            {
                pszDestEnd = pszDest;
                cchRemaining = cchDest;

                while (cchRemaining && cchSrc && (*pszSrc != L'\0'))
                {
                    *pszDestEnd++= *pszSrc++;
                    cchRemaining--;
                    cchSrc--;
                }

                if (cchRemaining > 0)
                {
                    if (dwFlags & STRSAFE_FILL_BEHIND_NULL)
                    {
                        memset(pszDestEnd + 1, STRSAFE_GET_FILL_PATTERN(dwFlags), ((cchRemaining - 1) * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t)));
                    }
                }
                else
                {
                    // we are going to truncate pszDest
                    pszDestEnd--;
                    cchRemaining++;

                    hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                }

                *pszDestEnd = L'\0';
            }
        }
    }

    if (FAILED(hr))
    {
        if (pszDest)
        {
            if (dwFlags & STRSAFE_FILL_ON_FAILURE)
            {
                memset(pszDest, STRSAFE_GET_FILL_PATTERN(dwFlags), cbDest);

                if (STRSAFE_GET_FILL_PATTERN(dwFlags) == 0)
                {
                    pszDestEnd = pszDest;
                    cchRemaining = cchDest;
                }
                else if (cchDest > 0)
                {
                    pszDestEnd = pszDest + cchDest - 1;
                    cchRemaining = 1;

                    // null terminate the end of the string
                    *pszDestEnd = L'\0';
                }
            }

            if (dwFlags & (STRSAFE_NULL_ON_FAILURE | STRSAFE_NO_TRUNCATION))
            {
                if (cchDest > 0)
                {
                    pszDestEnd = pszDest;
                    cchRemaining = cchDest;

                    // null terminate the beginning of the string
                    *pszDestEnd = L'\0';
                }
            }
        }
    }

    if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
    {
        if (ppszDestEnd)
        {
            *ppszDestEnd = pszDestEnd;
        }

        if (pcchRemaining)
        {
            *pcchRemaining = cchRemaining;
        }
    }

    return hr;
}

STRSAFEAPI StringCatWorkerA(char* pszDest, size_t cchDest, const char* pszSrc)
{
   HRESULT hr;
   size_t cchDestCurrent;

   hr = StringLengthWorkerA(pszDest, cchDest, &cchDestCurrent);

   if (SUCCEEDED(hr))
   {
       hr = StringCopyWorkerA(pszDest + cchDestCurrent,
                              cchDest - cchDestCurrent,
                              pszSrc);
   }

   return hr;
}

STRSAFEAPI StringCatWorkerW(wchar_t* pszDest, size_t cchDest, const wchar_t* pszSrc)
{
   HRESULT hr;
   size_t cchDestCurrent;

   hr = StringLengthWorkerW(pszDest, cchDest, &cchDestCurrent);

   if (SUCCEEDED(hr))
   {
       hr = StringCopyWorkerW(pszDest + cchDestCurrent,
                              cchDest - cchDestCurrent,
                              pszSrc);
   }

   return hr;
}

STRSAFEAPI StringCatExWorkerA(char* pszDest, size_t cchDest, size_t cbDest, const char* pszSrc, char** ppszDestEnd, size_t* pcchRemaining, unsigned long dwFlags)
{
    HRESULT hr = S_OK;
    char* pszDestEnd = pszDest;
    size_t cchRemaining = 0;

    // ASSERT(cbDest == (cchDest * sizeof(char))    ||
    //        cbDest == (cchDest * sizeof(char)) + (cbDest % sizeof(char)));

    // only accept valid flags
    if (dwFlags & (~STRSAFE_VALID_FLAGS))
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        size_t cchDestCurrent;

        if (dwFlags & STRSAFE_IGNORE_NULLS)
        {
            if (pszDest == NULL)
            {
                if ((cchDest == 0) && (cbDest == 0))
                {
                    cchDestCurrent = 0;
                }
                else
                {
                    // NULL pszDest and non-zero cchDest/cbDest is invalid
                    hr = STRSAFE_E_INVALID_PARAMETER;
                }
            }
            else
            {
                hr = StringLengthWorkerA(pszDest, cchDest, &cchDestCurrent);

                if (SUCCEEDED(hr))
                {
                    pszDestEnd = pszDest + cchDestCurrent;
                    cchRemaining = cchDest - cchDestCurrent;
                }
            }

            if (pszSrc == NULL)
            {
                pszSrc = "";
            }
        }
        else
        {
            hr = StringLengthWorkerA(pszDest, cchDest, &cchDestCurrent);

            if (SUCCEEDED(hr))
            {
                pszDestEnd = pszDest + cchDestCurrent;
                cchRemaining = cchDest - cchDestCurrent;
            }
        }

        if (SUCCEEDED(hr))
        {
            if (cchDest == 0)
            {
                // only fail if there was actually src data to append
                if (*pszSrc != '\0')
                {
                    if (pszDest == NULL)
                    {
                        hr = STRSAFE_E_INVALID_PARAMETER;
                    }
                    else
                    {
                        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                    }
                }
            }
            else
            {
                // we handle the STRSAFE_FILL_ON_FAILURE and STRSAFE_NULL_ON_FAILURE cases below, so do not pass
                // those flags through
                hr = StringCopyExWorkerA(pszDestEnd,
                                         cchRemaining,
                                         (cchRemaining * sizeof(char)) + (cbDest % sizeof(char)),
                                         pszSrc,
                                         &pszDestEnd,
                                         &cchRemaining,
                                         dwFlags & (~(STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)));
            }
        }
    }

    if (FAILED(hr))
    {
        if (pszDest)
        {
            // STRSAFE_NO_TRUNCATION is taken care of by StringCopyExWorkerA()

            if (dwFlags & STRSAFE_FILL_ON_FAILURE)
            {
                memset(pszDest, STRSAFE_GET_FILL_PATTERN(dwFlags), cbDest);

                if (STRSAFE_GET_FILL_PATTERN(dwFlags) == 0)
                {
                    pszDestEnd = pszDest;
                    cchRemaining = cchDest;
                }
                else
                if (cchDest > 0)
                {
                    pszDestEnd = pszDest + cchDest - 1;
                    cchRemaining = 1;

                    // null terminate the end of the string
                    *pszDestEnd = '\0';
                }
            }

            if (dwFlags & STRSAFE_NULL_ON_FAILURE)
            {
                if (cchDest > 0)
                {
                    pszDestEnd = pszDest;
                    cchRemaining = cchDest;

                    // null terminate the beginning of the string
                    *pszDestEnd = '\0';
                }
            }
        }
    }

    if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
    {
        if (ppszDestEnd)
        {
            *ppszDestEnd = pszDestEnd;
        }

        if (pcchRemaining)
        {
            *pcchRemaining = cchRemaining;
        }
    }

    return hr;
}

STRSAFEAPI StringCatExWorkerW(wchar_t* pszDest, size_t cchDest, size_t cbDest, const wchar_t* pszSrc, wchar_t** ppszDestEnd, size_t* pcchRemaining, unsigned long dwFlags)
{
    HRESULT hr = S_OK;
    wchar_t* pszDestEnd = pszDest;
    size_t cchRemaining = 0;

    // ASSERT(cbDest == (cchDest * sizeof(wchar_t)) ||
    //        cbDest == (cchDest * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t)));

    // only accept valid flags
    if (dwFlags & (~STRSAFE_VALID_FLAGS))
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        size_t cchDestCurrent;

        if (dwFlags & STRSAFE_IGNORE_NULLS)
        {
            if (pszDest == NULL)
            {
                if ((cchDest == 0) && (cbDest == 0))
                {
                    cchDestCurrent = 0;
                }
                else
                {
                    // NULL pszDest and non-zero cchDest/cbDest is invalid
                    hr = STRSAFE_E_INVALID_PARAMETER;
                }
            }
            else
            {
                hr = StringLengthWorkerW(pszDest, cchDest, &cchDestCurrent);

                if (SUCCEEDED(hr))
                {
                    pszDestEnd = pszDest + cchDestCurrent;
                    cchRemaining = cchDest - cchDestCurrent;
                }
            }

            if (pszSrc == NULL)
            {
                pszSrc = L"";
            }
        }
        else
        {
            hr = StringLengthWorkerW(pszDest, cchDest, &cchDestCurrent);

            if (SUCCEEDED(hr))
            {
                pszDestEnd = pszDest + cchDestCurrent;
                cchRemaining = cchDest - cchDestCurrent;
            }
        }

        if (SUCCEEDED(hr))
        {
            if (cchDest == 0)
            {
                // only fail if there was actually src data to append
                if (*pszSrc != L'\0')
                {
                    if (pszDest == NULL)
                    {
                        hr = STRSAFE_E_INVALID_PARAMETER;
                    }
                    else
                    {
                        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                    }
                }
            }
            else
            {
                // we handle the STRSAFE_FILL_ON_FAILURE and STRSAFE_NULL_ON_FAILURE cases below, so do not pass
                // those flags through
                hr = StringCopyExWorkerW(pszDestEnd,
                                         cchRemaining,
                                         (cchRemaining * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t)),
                                         pszSrc,
                                         &pszDestEnd,
                                         &cchRemaining,
                                         dwFlags & (~(STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)));
            }
        }
    }

    if (FAILED(hr))
    {
        if (pszDest)
        {
            // STRSAFE_NO_TRUNCATION is taken care of by StringCopyExWorkerW()

            if (dwFlags & STRSAFE_FILL_ON_FAILURE)
            {
                memset(pszDest, STRSAFE_GET_FILL_PATTERN(dwFlags), cbDest);

                if (STRSAFE_GET_FILL_PATTERN(dwFlags) == 0)
                {
                    pszDestEnd = pszDest;
                    cchRemaining = cchDest;
                }
                else if (cchDest > 0)
                {
                    pszDestEnd = pszDest + cchDest - 1;
                    cchRemaining = 1;

                    // null terminate the end of the string
                    *pszDestEnd = L'\0';
                }
            }

            if (dwFlags & STRSAFE_NULL_ON_FAILURE)
            {
                if (cchDest > 0)
                {
                    pszDestEnd = pszDest;
                    cchRemaining = cchDest;

                    // null terminate the beginning of the string
                    *pszDestEnd = L'\0';
                }
            }
        }
    }

    if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
    {
        if (ppszDestEnd)
        {
            *ppszDestEnd = pszDestEnd;
        }

        if (pcchRemaining)
        {
            *pcchRemaining = cchRemaining;
        }
    }

    return hr;
}

STRSAFEAPI StringCatNWorkerA(char* pszDest, size_t cchDest, const char* pszSrc, size_t cchMaxAppend)
{
    HRESULT hr;
    size_t cchDestCurrent;

    hr = StringLengthWorkerA(pszDest, cchDest, &cchDestCurrent);

    if (SUCCEEDED(hr))
    {
        hr = StringCopyNWorkerA(pszDest + cchDestCurrent,
                                cchDest - cchDestCurrent,
                                pszSrc,
                                cchMaxAppend);
    }

    return hr;
}

STRSAFEAPI StringCatNWorkerW(wchar_t* pszDest, size_t cchDest, const wchar_t* pszSrc, size_t cchMaxAppend)
{
    HRESULT hr;
    size_t cchDestCurrent;

    hr = StringLengthWorkerW(pszDest, cchDest, &cchDestCurrent);

    if (SUCCEEDED(hr))
    {
        hr = StringCopyNWorkerW(pszDest + cchDestCurrent,
                                cchDest - cchDestCurrent,
                                pszSrc,
                                cchMaxAppend);
    }

    return hr;
}

STRSAFEAPI StringCatNExWorkerA(char* pszDest, size_t cchDest, size_t cbDest, const char* pszSrc, size_t cchMaxAppend, char** ppszDestEnd, size_t* pcchRemaining, unsigned long dwFlags)
{
    HRESULT hr = S_OK;
    char* pszDestEnd = pszDest;
    size_t cchRemaining = 0;
    size_t cchDestCurrent = 0;

    // ASSERT(cbDest == (cchDest * sizeof(char))    ||
    //        cbDest == (cchDest * sizeof(char)) + (cbDest % sizeof(char)));

    // only accept valid flags
    if (dwFlags & (~STRSAFE_VALID_FLAGS))
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        if (dwFlags & STRSAFE_IGNORE_NULLS)
        {
            if (pszDest == NULL)
            {
                if ((cchDest == 0) && (cbDest == 0))
                {
                    cchDestCurrent = 0;
                }
                else
                {
                    // NULL pszDest and non-zero cchDest/cbDest is invalid
                    hr = STRSAFE_E_INVALID_PARAMETER;
                }
            }
            else
            {
                hr = StringLengthWorkerA(pszDest, cchDest, &cchDestCurrent);

                if (SUCCEEDED(hr))
                {
                    pszDestEnd = pszDest + cchDestCurrent;
                    cchRemaining = cchDest - cchDestCurrent;
                }
            }

            if (pszSrc == NULL)
            {
                pszSrc = "";
            }
        }
        else
        {
            hr = StringLengthWorkerA(pszDest, cchDest, &cchDestCurrent);

            if (SUCCEEDED(hr))
            {
                pszDestEnd = pszDest + cchDestCurrent;
                cchRemaining = cchDest - cchDestCurrent;
            }
        }

        if (SUCCEEDED(hr))
        {
            if (cchDest == 0)
            {
                // only fail if there was actually src data to append
                if (*pszSrc != '\0')
                {
                    if (pszDest == NULL)
                    {
                        hr = STRSAFE_E_INVALID_PARAMETER;
                    }
                    else
                    {
                        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                    }
                }
            }
            else
            {
                // we handle the STRSAFE_FILL_ON_FAILURE and STRSAFE_NULL_ON_FAILURE cases below, so do not pass
                // those flags through
                hr = StringCopyNExWorkerA(pszDestEnd,
                                          cchRemaining,
                                          (cchRemaining * sizeof(char)) + (cbDest % sizeof(char)),
                                          pszSrc,
                                          cchMaxAppend,
                                          &pszDestEnd,
                                          &cchRemaining,
                                          dwFlags & (~(STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)));
            }
        }
    }

    if (FAILED(hr))
    {
        if (pszDest)
        {
            // STRSAFE_NO_TRUNCATION is taken care of by StringCopyNExWorkerA()

            if (dwFlags & STRSAFE_FILL_ON_FAILURE)
            {
                memset(pszDest, STRSAFE_GET_FILL_PATTERN(dwFlags), cbDest);

                if (STRSAFE_GET_FILL_PATTERN(dwFlags) == 0)
                {
                    pszDestEnd = pszDest;
                    cchRemaining = cchDest;
                }
                else if (cchDest > 0)
                {
                    pszDestEnd = pszDest + cchDest - 1;
                    cchRemaining = 1;

                    // null terminate the end of the string
                    *pszDestEnd = '\0';
                }
            }

            if (dwFlags & (STRSAFE_NULL_ON_FAILURE))
            {
                if (cchDest > 0)
                {
                    pszDestEnd = pszDest;
                    cchRemaining = cchDest;

                    // null terminate the beginning of the string
                    *pszDestEnd = '\0';
                }
            }
        }
    }

    if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
    {
        if (ppszDestEnd)
        {
            *ppszDestEnd = pszDestEnd;
        }

        if (pcchRemaining)
        {
            *pcchRemaining = cchRemaining;
        }
    }

    return hr;
}

STRSAFEAPI StringCatNExWorkerW(wchar_t* pszDest, size_t cchDest, size_t cbDest, const wchar_t* pszSrc, size_t cchMaxAppend, wchar_t** ppszDestEnd, size_t* pcchRemaining, unsigned long dwFlags)
{
    HRESULT hr = S_OK;
    wchar_t* pszDestEnd = pszDest;
    size_t cchRemaining = 0;
    size_t cchDestCurrent = 0;


    // ASSERT(cbDest == (cchDest * sizeof(wchar_t)) ||
    //        cbDest == (cchDest * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t)));

    // only accept valid flags
    if (dwFlags & (~STRSAFE_VALID_FLAGS))
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        if (dwFlags & STRSAFE_IGNORE_NULLS)
        {
            if (pszDest == NULL)
            {
                if ((cchDest == 0) && (cbDest == 0))
                {
                    cchDestCurrent = 0;
                }
                else
                {
                    // NULL pszDest and non-zero cchDest/cbDest is invalid
                    hr = STRSAFE_E_INVALID_PARAMETER;
                }
            }
            else
            {
                hr = StringLengthWorkerW(pszDest, cchDest, &cchDestCurrent);

                if (SUCCEEDED(hr))
                {
                    pszDestEnd = pszDest + cchDestCurrent;
                    cchRemaining = cchDest - cchDestCurrent;
                }
            }

            if (pszSrc == NULL)
            {
                pszSrc = L"";
            }
        }
        else
        {
            hr = StringLengthWorkerW(pszDest, cchDest, &cchDestCurrent);

            if (SUCCEEDED(hr))
            {
                pszDestEnd = pszDest + cchDestCurrent;
                cchRemaining = cchDest - cchDestCurrent;
            }
        }

        if (SUCCEEDED(hr))
        {
            if (cchDest == 0)
            {
                // only fail if there was actually src data to append
                if (*pszSrc != L'\0')
                {
                    if (pszDest == NULL)
                    {
                        hr = STRSAFE_E_INVALID_PARAMETER;
                    }
                    else
                    {
                        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                    }
                }
            }
            else
            {
                // we handle the STRSAFE_FILL_ON_FAILURE and STRSAFE_NULL_ON_FAILURE cases below, so do not pass
                // those flags through
                hr = StringCopyNExWorkerW(pszDestEnd,
                                          cchRemaining,
                                          (cchRemaining * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t)),
                                          pszSrc,
                                          cchMaxAppend,
                                          &pszDestEnd,
                                          &cchRemaining,
                                          dwFlags & (~(STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)));
            }
        }
    }

    if (FAILED(hr))
    {
        if (pszDest)
        {
            // STRSAFE_NO_TRUNCATION is taken care of by StringCopyNExWorkerW()

            if (dwFlags & STRSAFE_FILL_ON_FAILURE)
            {
                memset(pszDest, STRSAFE_GET_FILL_PATTERN(dwFlags), cbDest);

                if (STRSAFE_GET_FILL_PATTERN(dwFlags) == 0)
                {
                    pszDestEnd = pszDest;
                    cchRemaining = cchDest;
                }
                else if (cchDest > 0)
                {
                    pszDestEnd = pszDest + cchDest - 1;
                    cchRemaining = 1;

                    // null terminate the end of the string
                    *pszDestEnd = L'\0';
                }
            }

            if (dwFlags & (STRSAFE_NULL_ON_FAILURE))
            {
                if (cchDest > 0)
                {
                    pszDestEnd = pszDest;
                    cchRemaining = cchDest;

                    // null terminate the beginning of the string
                    *pszDestEnd = L'\0';
                }
            }
        }
    }

    if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
    {
        if (ppszDestEnd)
        {
            *ppszDestEnd = pszDestEnd;
        }

        if (pcchRemaining)
        {
            *pcchRemaining = cchRemaining;
        }
    }

    return hr;
}

STRSAFEAPI StringVPrintfWorkerA(char* pszDest, size_t cchDest, const char* pszFormat, va_list argList)
{
    HRESULT hr = S_OK;

    if (cchDest == 0)
    {
        // can not null terminate a zero-byte dest buffer
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        int iRet;
        size_t cchMax;

        // leave the last space for the null terminator
        cchMax = cchDest - 1;

        iRet = _vsnprintf(pszDest, cchMax, pszFormat, argList);
        // ASSERT((iRet < 0) || (((size_t)iRet) <= cchMax));

        if ((iRet < 0) || (((size_t)iRet) > cchMax))
        {
            // need to null terminate the string
            pszDest += cchMax;
            *pszDest = '\0';

            // we have truncated pszDest
            hr = STRSAFE_E_INSUFFICIENT_BUFFER;
        }
        else if (((size_t)iRet) == cchMax)
        {
            // need to null terminate the string
            pszDest += cchMax;
            *pszDest = '\0';
        }
    }

    return hr;
}

STRSAFEAPI StringVPrintfWorkerW(wchar_t* pszDest, size_t cchDest, const wchar_t* pszFormat, va_list argList)
{
    HRESULT hr = S_OK;

    if (cchDest == 0)
    {
        // can not null terminate a zero-byte dest buffer
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        int iRet;
        size_t cchMax;

        // leave the last space for the null terminator
        cchMax = cchDest - 1;

        iRet = _vsnwprintf(pszDest, cchMax, pszFormat, argList);
        // ASSERT((iRet < 0) || (((size_t)iRet) <= cchMax));

        if ((iRet < 0) || (((size_t)iRet) > cchMax))
        {
            // need to null terminate the string
            pszDest += cchMax;
            *pszDest = L'\0';

            // we have truncated pszDest
            hr = STRSAFE_E_INSUFFICIENT_BUFFER;
        }
        else if (((size_t)iRet) == cchMax)
        {
            // need to null terminate the string
            pszDest += cchMax;
            *pszDest = L'\0';
        }
    }

    return hr;
}

STRSAFEAPI StringVPrintfExWorkerA(char* pszDest, size_t cchDest, size_t cbDest, char** ppszDestEnd, size_t* pcchRemaining, unsigned long dwFlags, const char* pszFormat, va_list argList)
{
    HRESULT hr = S_OK;
    char* pszDestEnd = pszDest;
    size_t cchRemaining = 0;

    // ASSERT(cbDest == (cchDest * sizeof(char))    ||
    //        cbDest == (cchDest * sizeof(char)) + (cbDest % sizeof(char)));

    // only accept valid flags
    if (dwFlags & (~STRSAFE_VALID_FLAGS))
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        if (dwFlags & STRSAFE_IGNORE_NULLS)
        {
            if (pszDest == NULL)
            {
                if ((cchDest != 0) || (cbDest != 0))
                {
                    // NULL pszDest and non-zero cchDest/cbDest is invalid
                    hr = STRSAFE_E_INVALID_PARAMETER;
                }
            }

            if (pszFormat == NULL)
            {
                pszFormat = "";
            }
        }

        if (SUCCEEDED(hr))
        {
            if (cchDest == 0)
            {
                pszDestEnd = pszDest;
                cchRemaining = 0;

                // only fail if there was actually a non-empty format string
                if (*pszFormat != '\0')
                {
                    if (pszDest == NULL)
                    {
                        hr = STRSAFE_E_INVALID_PARAMETER;
                    }
                    else
                    {
                        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                    }
                }
            }
            else
            {
                int iRet;
                size_t cchMax;

                // leave the last space for the null terminator
                cchMax = cchDest - 1;

                iRet = _vsnprintf(pszDest, cchMax, pszFormat, argList);
                // ASSERT((iRet < 0) || (((size_t)iRet) <= cchMax));

                if ((iRet < 0) || (((size_t)iRet) > cchMax))
                {
                    // we have truncated pszDest
                    pszDestEnd = pszDest + cchMax;
                    cchRemaining = 1;

                    // need to null terminate the string
                    *pszDestEnd = '\0';

                    hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                }
                else if (((size_t)iRet) == cchMax)
                {
                    // string fit perfectly
                    pszDestEnd = pszDest + cchMax;
                    cchRemaining = 1;

                    // need to null terminate the string
                    *pszDestEnd = '\0';
                }
                else if (((size_t)iRet) < cchMax)
                {
                    // there is extra room
                    pszDestEnd = pszDest + iRet;
                    cchRemaining = cchDest - iRet;

                    if (dwFlags & STRSAFE_FILL_BEHIND_NULL)
                    {
                        memset(pszDestEnd + 1, STRSAFE_GET_FILL_PATTERN(dwFlags), ((cchRemaining - 1) * sizeof(char)) + (cbDest % sizeof(char)));
                    }
                }
            }
        }
    }

    if (FAILED(hr))
    {
        if (pszDest)
        {
            if (dwFlags & STRSAFE_FILL_ON_FAILURE)
            {
                memset(pszDest, STRSAFE_GET_FILL_PATTERN(dwFlags), cbDest);

                if (STRSAFE_GET_FILL_PATTERN(dwFlags) == 0)
                {
                    pszDestEnd = pszDest;
                    cchRemaining = cchDest;
                }
                else if (cchDest > 0)
                {
                    pszDestEnd = pszDest + cchDest - 1;
                    cchRemaining = 1;

                    // null terminate the end of the string
                    *pszDestEnd = '\0';
                }
            }

            if (dwFlags & (STRSAFE_NULL_ON_FAILURE | STRSAFE_NO_TRUNCATION))
            {
                if (cchDest > 0)
                {
                    pszDestEnd = pszDest;
                    cchRemaining = cchDest;

                    // null terminate the beginning of the string
                    *pszDestEnd = '\0';
                }
            }
        }
    }

    if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
    {
        if (ppszDestEnd)
        {
            *ppszDestEnd = pszDestEnd;
        }

        if (pcchRemaining)
        {
            *pcchRemaining = cchRemaining;
        }
    }

    return hr;
}

STRSAFEAPI StringVPrintfExWorkerW(wchar_t* pszDest, size_t cchDest, size_t cbDest, wchar_t** ppszDestEnd, size_t* pcchRemaining, unsigned long dwFlags, const wchar_t* pszFormat, va_list argList)
{
    HRESULT hr = S_OK;
    wchar_t* pszDestEnd = pszDest;
    size_t cchRemaining = 0;

    // ASSERT(cbDest == (cchDest * sizeof(wchar_t)) ||
    //        cbDest == (cchDest * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t)));

    // only accept valid flags
    if (dwFlags & (~STRSAFE_VALID_FLAGS))
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        if (dwFlags & STRSAFE_IGNORE_NULLS)
        {
            if (pszDest == NULL)
            {
                if ((cchDest != 0) || (cbDest != 0))
                {
                    // NULL pszDest and non-zero cchDest/cbDest is invalid
                    hr = STRSAFE_E_INVALID_PARAMETER;
                }
            }

            if (pszFormat == NULL)
            {
                pszFormat = L"";
            }
        }

        if (SUCCEEDED(hr))
        {
            if (cchDest == 0)
            {
                pszDestEnd = pszDest;
                cchRemaining = 0;

                // only fail if there was actually a non-empty format string
                if (*pszFormat != L'\0')
                {
                    if (pszDest == NULL)
                    {
                        hr = STRSAFE_E_INVALID_PARAMETER;
                    }
                    else
                    {
                        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                    }
                }
            }
            else
            {
                int iRet;
                size_t cchMax;

                // leave the last space for the null terminator
                cchMax = cchDest - 1;

                iRet = _vsnwprintf(pszDest, cchMax, pszFormat, argList);
                // ASSERT((iRet < 0) || (((size_t)iRet) <= cchMax));

                if ((iRet < 0) || (((size_t)iRet) > cchMax))
                {
                    // we have truncated pszDest
                    pszDestEnd = pszDest + cchMax;
                    cchRemaining = 1;

                    // need to null terminate the string
                    *pszDestEnd = L'\0';

                    hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                }
                else if (((size_t)iRet) == cchMax)
                {
                    // string fit perfectly
                    pszDestEnd = pszDest + cchMax;
                    cchRemaining = 1;

                    // need to null terminate the string
                    *pszDestEnd = L'\0';
                }
                else if (((size_t)iRet) < cchMax)
                {
                    // there is extra room
                    pszDestEnd = pszDest + iRet;
                    cchRemaining = cchDest - iRet;

                    if (dwFlags & STRSAFE_FILL_BEHIND_NULL)
                    {
                        memset(pszDestEnd + 1, STRSAFE_GET_FILL_PATTERN(dwFlags), ((cchRemaining - 1) * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t)));
                    }
                }
            }
        }
    }

    if (FAILED(hr))
    {
        if (pszDest)
        {
            if (dwFlags & STRSAFE_FILL_ON_FAILURE)
            {
                memset(pszDest, STRSAFE_GET_FILL_PATTERN(dwFlags), cbDest);

                if (STRSAFE_GET_FILL_PATTERN(dwFlags) == 0)
                {
                    pszDestEnd = pszDest;
                    cchRemaining = cchDest;
                }
                else if (cchDest > 0)
                {
                    pszDestEnd = pszDest + cchDest - 1;
                    cchRemaining = 1;

                    // null terminate the end of the string
                    *pszDestEnd = L'\0';
                }
            }

            if (dwFlags & (STRSAFE_NULL_ON_FAILURE | STRSAFE_NO_TRUNCATION))
            {
                if (cchDest > 0)
                {
                    pszDestEnd = pszDest;
                    cchRemaining = cchDest;

                    // null terminate the beginning of the string
                    *pszDestEnd = L'\0';
                }
            }
        }
    }

    if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
    {
        if (ppszDestEnd)
        {
            *ppszDestEnd = pszDestEnd;
        }

        if (pcchRemaining)
        {
            *pcchRemaining = cchRemaining;
        }
    }

    return hr;
}

STRSAFEAPI StringLengthWorkerA(const char* psz, size_t cchMax, size_t* pcch)
{
    HRESULT hr = S_OK;
    size_t cchMaxPrev = cchMax;

    while (cchMax && (*psz != '\0'))
    {
        psz++;
        cchMax--;
    }

    if (cchMax == 0)
    {
        // the string is longer than cchMax
        hr = STRSAFE_E_INVALID_PARAMETER;
    }

    if (SUCCEEDED(hr) && pcch)
    {
        *pcch = cchMaxPrev - cchMax;
    }

    return hr;
}

STRSAFEAPI StringLengthWorkerW(const wchar_t* psz, size_t cchMax, size_t* pcch)
{
    HRESULT hr = S_OK;
    size_t cchMaxPrev = cchMax;

    while (cchMax && (*psz != L'\0'))
    {
        psz++;
        cchMax--;
    }

    if (cchMax == 0)
    {
        // the string is longer than cchMax
        hr = STRSAFE_E_INVALID_PARAMETER;
    }

    if (SUCCEEDED(hr) && pcch)
    {
        *pcch = cchMaxPrev - cchMax;
    }

    return hr;
}
#endif  // STRSAFE_INLINE

#ifndef STRSAFE_LIB_IMPL
STRSAFE_INLINE_API StringGetsExWorkerA(char* pszDest, size_t cchDest, size_t cbDest, char** ppszDestEnd, size_t* pcchRemaining, unsigned long dwFlags)
{
    HRESULT hr = S_OK;
    char* pszDestEnd = pszDest;
    size_t cchRemaining = 0;

    // ASSERT(cbDest == (cchDest * sizeof(char))    ||
    //        cbDest == (cchDest * sizeof(char)) + (cbDest % sizeof(char)));

    // only accept valid flags
    if (dwFlags & (~STRSAFE_VALID_FLAGS))
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        if (dwFlags & STRSAFE_IGNORE_NULLS)
        {
            if (pszDest == NULL)
            {
                if ((cchDest != 0) || (cbDest != 0))
                {
                    // NULL pszDest and non-zero cchDest/cbDest is invalid
                    hr = STRSAFE_E_INVALID_PARAMETER;
                }
            }
        }

        if (SUCCEEDED(hr))
        {
            if (cchDest <= 1)
            {
                pszDestEnd = pszDest;
                cchRemaining = cchDest;

                if (cchDest == 1)
                {
                    *pszDestEnd = '\0';
                }

                hr = STRSAFE_E_INSUFFICIENT_BUFFER;
            }
            else
            {
                char ch;

                pszDestEnd = pszDest;
                cchRemaining = cchDest;

                while ((cchRemaining > 1) && (ch = (char)getc(stdin)) != '\n')
                {
                    if (ch == EOF)
                    {
                        if (pszDestEnd == pszDest)
                        {
                            // we failed to read anything from stdin
                            hr = STRSAFE_E_END_OF_FILE;
                        }
                        break;
                    }

                    *pszDestEnd = ch;

                    pszDestEnd++;
                    cchRemaining--;
                }

                if (cchRemaining > 0)
                {
                    // there is extra room
                    if (dwFlags & STRSAFE_FILL_BEHIND_NULL)
                    {
                        memset(pszDestEnd + 1, STRSAFE_GET_FILL_PATTERN(dwFlags), ((cchRemaining - 1) * sizeof(char)) + (cbDest % sizeof(char)));
                    }
                }

                *pszDestEnd = '\0';
            }
        }
    }

    if (FAILED(hr))
    {
        if (pszDest)
        {
            if (dwFlags & STRSAFE_FILL_ON_FAILURE)
            {
                memset(pszDest, STRSAFE_GET_FILL_PATTERN(dwFlags), cbDest);

                if (STRSAFE_GET_FILL_PATTERN(dwFlags) == 0)
                {
                    pszDestEnd = pszDest;
                    cchRemaining = cchDest;
                }
                else if (cchDest > 0)
                {
                    pszDestEnd = pszDest + cchDest - 1;
                    cchRemaining = 1;

                    // null terminate the end of the string
                    *pszDestEnd = '\0';
                }
            }

            if (dwFlags & (STRSAFE_NULL_ON_FAILURE | STRSAFE_NO_TRUNCATION))
            {
                if (cchDest > 0)
                {
                    pszDestEnd = pszDest;
                    cchRemaining = cchDest;

                    // null terminate the beginning of the string
                    *pszDestEnd = '\0';
                }
            }
        }
    }

    if (SUCCEEDED(hr) ||
        (hr == STRSAFE_E_INSUFFICIENT_BUFFER) ||
        (hr == STRSAFE_E_END_OF_FILE))
    {
        if (ppszDestEnd)
        {
            *ppszDestEnd = pszDestEnd;
        }

        if (pcchRemaining)
        {
            *pcchRemaining = cchRemaining;
        }
    }

    return hr;
}

STRSAFE_INLINE_API StringGetsExWorkerW(wchar_t* pszDest, size_t cchDest, size_t cbDest, wchar_t** ppszDestEnd, size_t* pcchRemaining, unsigned long dwFlags)
{
    HRESULT hr = S_OK;
    wchar_t* pszDestEnd = pszDest;
    size_t cchRemaining = 0;

    // ASSERT(cbDest == (cchDest * sizeof(char))    ||
    //        cbDest == (cchDest * sizeof(char)) + (cbDest % sizeof(char)));

    // only accept valid flags
    if (dwFlags & (~STRSAFE_VALID_FLAGS))
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        if (dwFlags & STRSAFE_IGNORE_NULLS)
        {
            if (pszDest == NULL)
            {
                if ((cchDest != 0) || (cbDest != 0))
                {
                    // NULL pszDest and non-zero cchDest/cbDest is invalid
                    hr = STRSAFE_E_INVALID_PARAMETER;
                }
            }
        }

        if (SUCCEEDED(hr))
        {
            if (cchDest <= 1)
            {
                pszDestEnd = pszDest;
                cchRemaining = cchDest;

                if (cchDest == 1)
                {
                    *pszDestEnd = L'\0';
                }

                hr = STRSAFE_E_INSUFFICIENT_BUFFER;
            }
            else
            {
                wchar_t ch;

                pszDestEnd = pszDest;
                cchRemaining = cchDest;

                while ((cchRemaining > 1) && (ch = (wchar_t)getwc(stdin)) != L'\n')
                {
                    if (ch == EOF)
                    {
                        if (pszDestEnd == pszDest)
                        {
                            // we failed to read anything from stdin
                            hr = STRSAFE_E_END_OF_FILE;
                        }
                        break;
                    }

                    *pszDestEnd = ch;

                    pszDestEnd++;
                    cchRemaining--;
                }

                if (cchRemaining > 0)
                {
                    // there is extra room
                    if (dwFlags & STRSAFE_FILL_BEHIND_NULL)
                    {
                        memset(pszDestEnd + 1, STRSAFE_GET_FILL_PATTERN(dwFlags), ((cchRemaining - 1) * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t)));
                    }
                }

                *pszDestEnd = L'\0';
            }
        }
    }

    if (FAILED(hr))
    {
        if (pszDest)
        {
            if (dwFlags & STRSAFE_FILL_ON_FAILURE)
            {
                memset(pszDest, STRSAFE_GET_FILL_PATTERN(dwFlags), cbDest);

                if (STRSAFE_GET_FILL_PATTERN(dwFlags) == 0)
                {
                    pszDestEnd = pszDest;
                    cchRemaining = cchDest;
                }
                else if (cchDest > 0)
                {
                    pszDestEnd = pszDest + cchDest - 1;
                    cchRemaining = 1;

                    // null terminate the end of the string
                    *pszDestEnd = L'\0';
                }
            }

            if (dwFlags & (STRSAFE_NULL_ON_FAILURE | STRSAFE_NO_TRUNCATION))
            {
                if (cchDest > 0)
                {
                    pszDestEnd = pszDest;
                    cchRemaining = cchDest;

                    // null terminate the beginning of the string
                    *pszDestEnd = L'\0';
                }
            }
        }
    }

    if (SUCCEEDED(hr) ||
        (hr == STRSAFE_E_INSUFFICIENT_BUFFER) ||
        (hr == STRSAFE_E_END_OF_FILE))
    {
        if (ppszDestEnd)
        {
            *ppszDestEnd = pszDestEnd;
        }

        if (pcchRemaining)
        {
            *pcchRemaining = cchRemaining;
        }
    }

    return hr;
}
#endif  // !STRSAFE_LIB_IMPL


// Do not call these functions, they are worker functions for internal use within this file
#ifdef DEPRECATE_SUPPORTED
#pragma deprecated(StringCopyWorkerA)
#pragma deprecated(StringCopyWorkerW)
#pragma deprecated(StringCopyExWorkerA)
#pragma deprecated(StringCopyExWorkerW)
#pragma deprecated(StringCatWorkerA)
#pragma deprecated(StringCatWorkerW)
#pragma deprecated(StringCatExWorkerA)
#pragma deprecated(StringCatExWorkerW)
#pragma deprecated(StringCatNWorkerA)
#pragma deprecated(StringCatNWorkerW)
#pragma deprecated(StringCatNExWorkerA)
#pragma deprecated(StringCatNExWorkerW)
#pragma deprecated(StringVPrintfWorkerA)
#pragma deprecated(StringVPrintfWorkerW)
#pragma deprecated(StringVPrintfExWorkerA)
#pragma deprecated(StringVPrintfExWorkerW)
#pragma deprecated(StringLengthWorkerA)
#pragma deprecated(StringLengthWorkerW)
#else
#define StringCopyWorkerA        StringCopyWorkerA_instead_use_StringCchCopyA_or_StringCchCopyExA;
#define StringCopyWorkerW        StringCopyWorkerW_instead_use_StringCchCopyW_or_StringCchCopyExW;
#define StringCopyExWorkerA      StringCopyExWorkerA_instead_use_StringCchCopyA_or_StringCchCopyExA;
#define StringCopyExWorkerW      StringCopyExWorkerW_instead_use_StringCchCopyW_or_StringCchCopyExW;
#define StringCatWorkerA         StringCatWorkerA_instead_use_StringCchCatA_or_StringCchCatExA;
#define StringCatWorkerW         StringCatWorkerW_instead_use_StringCchCatW_or_StringCchCatExW;
#define StringCatExWorkerA       StringCatExWorkerA_instead_use_StringCchCatA_or_StringCchCatExA;
#define StringCatExWorkerW       StringCatExWorkerW_instead_use_StringCchCatW_or_StringCchCatExW;
#define StringCatNWorkerA        StringCatNWorkerA_instead_use_StringCchCatNA_or_StrincCbCatNA;
#define StringCatNWorkerW        StringCatNWorkerW_instead_use_StringCchCatNW_or_StringCbCatNW;
#define StringCatNExWorkerA      StringCatNExWorkerA_instead_use_StringCchCatNExA_or_StringCbCatNExA;
#define StringCatNExWorkerW      StringCatNExWorkerW_instead_use_StringCchCatNExW_or_StringCbCatNExW;
#define StringVPrintfWorkerA     StringVPrintfWorkerA_instead_use_StringCchVPrintfA_or_StringCchVPrintfExA;
#define StringVPrintfWorkerW     StringVPrintfWorkerW_instead_use_StringCchVPrintfW_or_StringCchVPrintfExW;
#define StringVPrintfExWorkerA   StringVPrintfExWorkerA_instead_use_StringCchVPrintfA_or_StringCchVPrintfExA;
#define StringVPrintfExWorkerW   StringVPrintfExWorkerW_instead_use_StringCchVPrintfW_or_StringCchVPrintfExW;
#define StringLengthWorkerA      StringLengthWorkerA_instead_use_StringCchLengthA_or_StringCbLengthA;
#define StringLengthWorkerW      StringLengthWorkerW_instead_use_StringCchLengthW_or_StringCbLengthW;
#endif // !DEPRECATE_SUPPORTED


#ifndef STRSAFE_NO_DEPRECATE
// Deprecate all of the unsafe functions to generate compiletime errors. If you do not want
// this then you can #define STRSAFE_NO_DEPRECATE before including this file.
#ifdef DEPRECATE_SUPPORTED

// First all the names that are a/w variants (or shouldn't be #defined by now anyway).
#pragma deprecated(lstrcpyA)
#pragma deprecated(lstrcpyW)
#pragma deprecated(lstrcatA)
#pragma deprecated(lstrcatW)
#pragma deprecated(wsprintfA)
#pragma deprecated(wsprintfW)

#pragma deprecated(StrCpyW)
#pragma deprecated(StrCatW)
#pragma deprecated(StrNCatA)
#pragma deprecated(StrNCatW)
#pragma deprecated(StrCatNA)
#pragma deprecated(StrCatNW)
#pragma deprecated(wvsprintfA)
#pragma deprecated(wvsprintfW)

#pragma deprecated(strcpy)
#pragma deprecated(wcscpy)
#pragma deprecated(strcat)
#pragma deprecated(wcscat)
#pragma deprecated(sprintf)
#pragma deprecated(swprintf)
#pragma deprecated(vsprintf)
#pragma deprecated(vswprintf)
#pragma deprecated(_snprintf)
#pragma deprecated(_snwprintf)
#pragma deprecated(_vsnprintf)
#pragma deprecated(_vsnwprintf)
#pragma deprecated(gets)
#pragma deprecated(_getws)

// Then all the windows.h names - we need to undef and redef based on UNICODE setting
#undef lstrcpy
#undef lstrcat
#undef wsprintf
#undef wvsprintf
#pragma deprecated(lstrcpy)
#pragma deprecated(lstrcat)
#pragma deprecated(wsprintf)
#pragma deprecated(wvsprintf)
#ifdef UNICODE
#define lstrcpy    lstrcpyW
#define lstrcat    lstrcatW
#define wsprintf   wsprintfW
#define wvsprintf  wvsprintfW
#else
#define lstrcpy    lstrcpyA
#define lstrcat    lstrcatA
#define wsprintf   wsprintfA
#define wvsprintf  wvsprintfA
#endif

// Then the shlwapi names - they key off UNICODE also.
#undef StrCpyA
#undef StrCpy
#undef StrCatA
#undef StrCat
#undef StrNCat
#undef StrCatN
#pragma deprecated(StrCpyA)
#pragma deprecated(StrCatA)
#pragma deprecated(StrCatN)
#pragma deprecated(StrCpy)
#pragma deprecated(StrCat)
#pragma deprecated(StrNCat)
#define StrCpyA lstrcpyA
#define StrCatA lstrcatA
#define StrCatN StrNCat
#ifdef UNICODE
#define StrCpy  StrCpyW
#define StrCat  StrCatW
#define StrNCat StrNCatW
#else
#define StrCpy  lstrcpyA
#define StrCat  lstrcatA
#define StrNCat StrNCatA
#endif

// Then all the CRT names - we need to undef/redef based on _UNICODE value.
#undef _tcscpy
#undef _ftcscpy
#undef _tcscat
#undef _ftcscat
#undef _stprintf
#undef _sntprintf
#undef _vstprintf
#undef _vsntprintf
#undef _getts
#pragma deprecated(_tcscpy)
#pragma deprecated(_ftcscpy)
#pragma deprecated(_tcscat)
#pragma deprecated(_ftcscat)
#pragma deprecated(_stprintf)
#pragma deprecated(_sntprintf)
#pragma deprecated(_vstprintf)
#pragma deprecated(_vsntprintf)
#pragma deprecated(_getts)
#ifdef _UNICODE
#define _tcscpy     wcscpy
#define _ftcscpy    wcscpy
#define _tcscat     wcscat
#define _ftcscat    wcscat
#define _stprintf   swprintf
#define _sntprintf  _snwprintf
#define _vstprintf  vswprintf
#define _vsntprintf _vsnwprintf
#define _getts      _getws
#else
#define _tcscpy     strcpy
#define _ftcscpy    strcpy
#define _tcscat     strcat
#define _ftcscat    strcat
#define _stprintf   sprintf
#define _sntprintf  _snprintf
#define _vstprintf  vsprintf
#define _vsntprintf _vsnprintf
#define _getts      gets
#endif

#else // DEPRECATE_SUPPORTED

#undef strcpy
#define strcpy      strcpy_instead_use_StringCbCopyA_or_StringCchCopyA;

#undef wcscpy
#define wcscpy      wcscpy_instead_use_StringCbCopyW_or_StringCchCopyW;

#undef strcat
#define strcat      strcat_instead_use_StringCbCatA_or_StringCchCatA;

#undef wcscat
#define wcscat      wcscat_instead_use_StringCbCatW_or_StringCchCatW;

#undef sprintf
#define sprintf     sprintf_instead_use_StringCbPrintfA_or_StringCchPrintfA;

#undef swprintf
#define swprintf    swprintf_instead_use_StringCbPrintfW_or_StringCchPrintfW;

#undef vsprintf
#define vsprintf    vsprintf_instead_use_StringCbVPrintfA_or_StringCchVPrintfA;

#undef vswprintf
#define vswprintf   vswprintf_instead_use_StringCbVPrintfW_or_StringCchVPrintfW;

#undef _snprintf
#define _snprintf   _snprintf_instead_use_StringCbPrintfA_or_StringCchPrintfA;

#undef _snwprintf
#define _snwprintf  _snwprintf_instead_use_StringCbPrintfW_or_StringCchPrintfW;

#undef _vsnprintf
#define _vsnprintf  _vsnprintf_instead_use_StringCbVPrintfA_or_StringCchVPrintfA;

#undef _vsnwprintf
#define _vsnwprintf _vsnwprintf_instead_use_StringCbVPrintfW_or_StringCchVPrintfW;

#undef strcpyA
#define strcpyA     strcpyA_instead_use_StringCbCopyA_or_StringCchCopyA;

#undef strcpyW
#define strcpyW     strcpyW_instead_use_StringCbCopyW_or_StringCchCopyW;

#undef lstrcpy
#define lstrcpy     lstrcpy_instead_use_StringCbCopy_or_StringCchCopy;

#undef lstrcpyA
#define lstrcpyA    lstrcpyA_instead_use_StringCbCopyA_or_StringCchCopyA;

#undef lstrcpyW
#define lstrcpyW    lstrcpyW_instead_use_StringCbCopyW_or_StringCchCopyW;

#undef StrCpy
#define StrCpy      StrCpy_instead_use_StringCbCopy_or_StringCchCopy;

#undef StrCpyA
#define StrCpyA     StrCpyA_instead_use_StringCbCopyA_or_StringCchCopyA;

#undef StrCpyW
#define StrCpyW     StrCpyW_instead_use_StringCbCopyW_or_StringCchCopyW;

#undef _tcscpy
#define _tcscpy     _tcscpy_instead_use_StringCbCopy_or_StringCchCopy;

#undef _ftcscpy
#define _ftcscpy    _ftcscpy_instead_use_StringCbCopy_or_StringCchCopy;

#undef lstrcat
#define lstrcat     lstrcat_instead_use_StringCbCat_or_StringCchCat;

#undef lstrcatA
#define lstrcatA    lstrcatA_instead_use_StringCbCatA_or_StringCchCatA;

#undef lstrcatW
#define lstrcatW    lstrcatW_instead_use_StringCbCatW_or_StringCchCatW;

#undef StrCat
#define StrCat      StrCat_instead_use_StringCbCat_or_StringCchCat;

#undef StrCatA
#define StrCatA     StrCatA_instead_use_StringCbCatA_or_StringCchCatA;

#undef StrCatW
#define StrCatW     StrCatW_instead_use_StringCbCatW_or_StringCchCatW;

#undef StrNCat
#define StrNCat     StrNCat_instead_use_StringCbCatN_or_StringCchCatN;

#undef StrNCatA
#define StrNCatA    StrNCatA_instead_use_StringCbCatNA_or_StringCchCatNA;

#undef StrNCatW
#define StrNCatW    StrNCatW_instead_use_StringCbCatNW_or_StringCchCatNW;

#undef StrCatN
#define StrCatN     StrCatN_instead_use_StringCbCatN_or_StringCchCatN;

#undef StrCatNA
#define StrCatNA    StrCatNA_instead_use_StringCbCatNA_or_StringCchCatNA;

#undef StrCatNW
#define StrCatNW    StrCatNW_instead_use_StringCbCatNW_or_StringCchCatNW;

#undef _tcscat
#define _tcscat     _tcscat_instead_use_StringCbCat_or_StringCchCat;

#undef _ftcscat
#define _ftcscat    _ftcscat_instead_use_StringCbCat_or_StringCchCat;

#undef wsprintf
#define wsprintf    wsprintf_instead_use_StringCbPrintf_or_StringCchPrintf;

#undef wsprintfA
#define wsprintfA   wsprintfA_instead_use_StringCbPrintfA_or_StringCchPrintfA;

#undef wsprintfW
#define wsprintfW   wsprintfW_instead_use_StringCbPrintfW_or_StringCchPrintfW;

#undef wvsprintf
#define wvsprintf   wvsprintf_instead_use_StringCbVPrintf_or_StringCchVPrintf;

#undef wvsprintfA
#define wvsprintfA  wvsprintfA_instead_use_StringCbVPrintfA_or_StringCchVPrintfA;

#undef wvsprintfW
#define wvsprintfW  wvsprintfW_instead_use_StringCbVPrintfW_or_StringCchVPrintfW;

#undef _vstprintf
#define _vstprintf  _vstprintf_instead_use_StringCbVPrintf_or_StringCchVPrintf;

#undef _vsntprintf
#define _vsntprintf _vsntprintf_instead_use_StringCbVPrintf_or_StringCchVPrintf;

#undef _stprintf
#define _stprintf   _stprintf_instead_use_StringCbPrintf_or_StringCchPrintf;

#undef _sntprintf
#define _sntprintf  _sntprintf_instead_use_StringCbPrintf_or_StringCchPrintf;

#undef _getts
#define _getts      _getts_instead_use_StringCbGets_or_StringCchGets;

#undef gets
#define gets        _gets_instead_use_StringCbGetsA_or_StringCchGetsA;

#undef _getws
#define _getws      _getws_instead_use_StringCbGetsW_or_StringCchGetsW;

#endif  // !DEPRECATE_SUPPORTED
#endif  // !STRSAFE_NO_DEPRECATE

#ifdef _NTSTRSAFE_H_INCLUDED_
#pragma warning(pop)
#endif // _NTSTRSAFE_H_INCLUDED_

#endif  // _STRSAFE_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DirectX\9c\Include\tuner.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0357 */
/* Compiler settings for tuner.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __tuner_h__
#define __tuner_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ITuningSpaces_FWD_DEFINED__
#define __ITuningSpaces_FWD_DEFINED__
typedef interface ITuningSpaces ITuningSpaces;
#endif 	/* __ITuningSpaces_FWD_DEFINED__ */


#ifndef __ITuningSpaceContainer_FWD_DEFINED__
#define __ITuningSpaceContainer_FWD_DEFINED__
typedef interface ITuningSpaceContainer ITuningSpaceContainer;
#endif 	/* __ITuningSpaceContainer_FWD_DEFINED__ */


#ifndef __ITuningSpace_FWD_DEFINED__
#define __ITuningSpace_FWD_DEFINED__
typedef interface ITuningSpace ITuningSpace;
#endif 	/* __ITuningSpace_FWD_DEFINED__ */


#ifndef __IEnumTuningSpaces_FWD_DEFINED__
#define __IEnumTuningSpaces_FWD_DEFINED__
typedef interface IEnumTuningSpaces IEnumTuningSpaces;
#endif 	/* __IEnumTuningSpaces_FWD_DEFINED__ */


#ifndef __IDVBTuningSpace_FWD_DEFINED__
#define __IDVBTuningSpace_FWD_DEFINED__
typedef interface IDVBTuningSpace IDVBTuningSpace;
#endif 	/* __IDVBTuningSpace_FWD_DEFINED__ */


#ifndef __IDVBTuningSpace2_FWD_DEFINED__
#define __IDVBTuningSpace2_FWD_DEFINED__
typedef interface IDVBTuningSpace2 IDVBTuningSpace2;
#endif 	/* __IDVBTuningSpace2_FWD_DEFINED__ */


#ifndef __IDVBSTuningSpace_FWD_DEFINED__
#define __IDVBSTuningSpace_FWD_DEFINED__
typedef interface IDVBSTuningSpace IDVBSTuningSpace;
#endif 	/* __IDVBSTuningSpace_FWD_DEFINED__ */


#ifndef __IAuxInTuningSpace_FWD_DEFINED__
#define __IAuxInTuningSpace_FWD_DEFINED__
typedef interface IAuxInTuningSpace IAuxInTuningSpace;
#endif 	/* __IAuxInTuningSpace_FWD_DEFINED__ */


#ifndef __IAnalogTVTuningSpace_FWD_DEFINED__
#define __IAnalogTVTuningSpace_FWD_DEFINED__
typedef interface IAnalogTVTuningSpace IAnalogTVTuningSpace;
#endif 	/* __IAnalogTVTuningSpace_FWD_DEFINED__ */


#ifndef __IATSCTuningSpace_FWD_DEFINED__
#define __IATSCTuningSpace_FWD_DEFINED__
typedef interface IATSCTuningSpace IATSCTuningSpace;
#endif 	/* __IATSCTuningSpace_FWD_DEFINED__ */


#ifndef __IAnalogRadioTuningSpace_FWD_DEFINED__
#define __IAnalogRadioTuningSpace_FWD_DEFINED__
typedef interface IAnalogRadioTuningSpace IAnalogRadioTuningSpace;
#endif 	/* __IAnalogRadioTuningSpace_FWD_DEFINED__ */


#ifndef __ITuneRequest_FWD_DEFINED__
#define __ITuneRequest_FWD_DEFINED__
typedef interface ITuneRequest ITuneRequest;
#endif 	/* __ITuneRequest_FWD_DEFINED__ */


#ifndef __IChannelTuneRequest_FWD_DEFINED__
#define __IChannelTuneRequest_FWD_DEFINED__
typedef interface IChannelTuneRequest IChannelTuneRequest;
#endif 	/* __IChannelTuneRequest_FWD_DEFINED__ */


#ifndef __IATSCChannelTuneRequest_FWD_DEFINED__
#define __IATSCChannelTuneRequest_FWD_DEFINED__
typedef interface IATSCChannelTuneRequest IATSCChannelTuneRequest;
#endif 	/* __IATSCChannelTuneRequest_FWD_DEFINED__ */


#ifndef __IDVBTuneRequest_FWD_DEFINED__
#define __IDVBTuneRequest_FWD_DEFINED__
typedef interface IDVBTuneRequest IDVBTuneRequest;
#endif 	/* __IDVBTuneRequest_FWD_DEFINED__ */


#ifndef __IMPEG2TuneRequest_FWD_DEFINED__
#define __IMPEG2TuneRequest_FWD_DEFINED__
typedef interface IMPEG2TuneRequest IMPEG2TuneRequest;
#endif 	/* __IMPEG2TuneRequest_FWD_DEFINED__ */


#ifndef __IMPEG2TuneRequestFactory_FWD_DEFINED__
#define __IMPEG2TuneRequestFactory_FWD_DEFINED__
typedef interface IMPEG2TuneRequestFactory IMPEG2TuneRequestFactory;
#endif 	/* __IMPEG2TuneRequestFactory_FWD_DEFINED__ */


#ifndef __IMPEG2TuneRequestSupport_FWD_DEFINED__
#define __IMPEG2TuneRequestSupport_FWD_DEFINED__
typedef interface IMPEG2TuneRequestSupport IMPEG2TuneRequestSupport;
#endif 	/* __IMPEG2TuneRequestSupport_FWD_DEFINED__ */


#ifndef __ITuner_FWD_DEFINED__
#define __ITuner_FWD_DEFINED__
typedef interface ITuner ITuner;
#endif 	/* __ITuner_FWD_DEFINED__ */


#ifndef __IScanningTuner_FWD_DEFINED__
#define __IScanningTuner_FWD_DEFINED__
typedef interface IScanningTuner IScanningTuner;
#endif 	/* __IScanningTuner_FWD_DEFINED__ */


#ifndef __IComponentType_FWD_DEFINED__
#define __IComponentType_FWD_DEFINED__
typedef interface IComponentType IComponentType;
#endif 	/* __IComponentType_FWD_DEFINED__ */


#ifndef __ILanguageComponentType_FWD_DEFINED__
#define __ILanguageComponentType_FWD_DEFINED__
typedef interface ILanguageComponentType ILanguageComponentType;
#endif 	/* __ILanguageComponentType_FWD_DEFINED__ */


#ifndef __IMPEG2ComponentType_FWD_DEFINED__
#define __IMPEG2ComponentType_FWD_DEFINED__
typedef interface IMPEG2ComponentType IMPEG2ComponentType;
#endif 	/* __IMPEG2ComponentType_FWD_DEFINED__ */


#ifndef __IATSCComponentType_FWD_DEFINED__
#define __IATSCComponentType_FWD_DEFINED__
typedef interface IATSCComponentType IATSCComponentType;
#endif 	/* __IATSCComponentType_FWD_DEFINED__ */


#ifndef __IEnumComponentTypes_FWD_DEFINED__
#define __IEnumComponentTypes_FWD_DEFINED__
typedef interface IEnumComponentTypes IEnumComponentTypes;
#endif 	/* __IEnumComponentTypes_FWD_DEFINED__ */


#ifndef __IComponentTypes_FWD_DEFINED__
#define __IComponentTypes_FWD_DEFINED__
typedef interface IComponentTypes IComponentTypes;
#endif 	/* __IComponentTypes_FWD_DEFINED__ */


#ifndef __IComponent_FWD_DEFINED__
#define __IComponent_FWD_DEFINED__
typedef interface IComponent IComponent;
#endif 	/* __IComponent_FWD_DEFINED__ */


#ifndef __IMPEG2Component_FWD_DEFINED__
#define __IMPEG2Component_FWD_DEFINED__
typedef interface IMPEG2Component IMPEG2Component;
#endif 	/* __IMPEG2Component_FWD_DEFINED__ */


#ifndef __IEnumComponents_FWD_DEFINED__
#define __IEnumComponents_FWD_DEFINED__
typedef interface IEnumComponents IEnumComponents;
#endif 	/* __IEnumComponents_FWD_DEFINED__ */


#ifndef __IComponents_FWD_DEFINED__
#define __IComponents_FWD_DEFINED__
typedef interface IComponents IComponents;
#endif 	/* __IComponents_FWD_DEFINED__ */


#ifndef __ILocator_FWD_DEFINED__
#define __ILocator_FWD_DEFINED__
typedef interface ILocator ILocator;
#endif 	/* __ILocator_FWD_DEFINED__ */


#ifndef __IATSCLocator_FWD_DEFINED__
#define __IATSCLocator_FWD_DEFINED__
typedef interface IATSCLocator IATSCLocator;
#endif 	/* __IATSCLocator_FWD_DEFINED__ */


#ifndef __IDVBTLocator_FWD_DEFINED__
#define __IDVBTLocator_FWD_DEFINED__
typedef interface IDVBTLocator IDVBTLocator;
#endif 	/* __IDVBTLocator_FWD_DEFINED__ */


#ifndef __IDVBSLocator_FWD_DEFINED__
#define __IDVBSLocator_FWD_DEFINED__
typedef interface IDVBSLocator IDVBSLocator;
#endif 	/* __IDVBSLocator_FWD_DEFINED__ */


#ifndef __IDVBCLocator_FWD_DEFINED__
#define __IDVBCLocator_FWD_DEFINED__
typedef interface IDVBCLocator IDVBCLocator;
#endif 	/* __IDVBCLocator_FWD_DEFINED__ */


#ifndef __IBroadcastEvent_FWD_DEFINED__
#define __IBroadcastEvent_FWD_DEFINED__
typedef interface IBroadcastEvent IBroadcastEvent;
#endif 	/* __IBroadcastEvent_FWD_DEFINED__ */


#ifndef __SystemTuningSpaces_FWD_DEFINED__
#define __SystemTuningSpaces_FWD_DEFINED__

#ifdef __cplusplus
typedef class SystemTuningSpaces SystemTuningSpaces;
#else
typedef struct SystemTuningSpaces SystemTuningSpaces;
#endif /* __cplusplus */

#endif 	/* __SystemTuningSpaces_FWD_DEFINED__ */


#ifndef __TuningSpace_FWD_DEFINED__
#define __TuningSpace_FWD_DEFINED__

#ifdef __cplusplus
typedef class TuningSpace TuningSpace;
#else
typedef struct TuningSpace TuningSpace;
#endif /* __cplusplus */

#endif 	/* __TuningSpace_FWD_DEFINED__ */


#ifndef __ATSCTuningSpace_FWD_DEFINED__
#define __ATSCTuningSpace_FWD_DEFINED__

#ifdef __cplusplus
typedef class ATSCTuningSpace ATSCTuningSpace;
#else
typedef struct ATSCTuningSpace ATSCTuningSpace;
#endif /* __cplusplus */

#endif 	/* __ATSCTuningSpace_FWD_DEFINED__ */


#ifndef __AnalogRadioTuningSpace_FWD_DEFINED__
#define __AnalogRadioTuningSpace_FWD_DEFINED__

#ifdef __cplusplus
typedef class AnalogRadioTuningSpace AnalogRadioTuningSpace;
#else
typedef struct AnalogRadioTuningSpace AnalogRadioTuningSpace;
#endif /* __cplusplus */

#endif 	/* __AnalogRadioTuningSpace_FWD_DEFINED__ */


#ifndef __AuxInTuningSpace_FWD_DEFINED__
#define __AuxInTuningSpace_FWD_DEFINED__

#ifdef __cplusplus
typedef class AuxInTuningSpace AuxInTuningSpace;
#else
typedef struct AuxInTuningSpace AuxInTuningSpace;
#endif /* __cplusplus */

#endif 	/* __AuxInTuningSpace_FWD_DEFINED__ */


#ifndef __AnalogTVTuningSpace_FWD_DEFINED__
#define __AnalogTVTuningSpace_FWD_DEFINED__

#ifdef __cplusplus
typedef class AnalogTVTuningSpace AnalogTVTuningSpace;
#else
typedef struct AnalogTVTuningSpace AnalogTVTuningSpace;
#endif /* __cplusplus */

#endif 	/* __AnalogTVTuningSpace_FWD_DEFINED__ */


#ifndef __DVBTuningSpace_FWD_DEFINED__
#define __DVBTuningSpace_FWD_DEFINED__

#ifdef __cplusplus
typedef class DVBTuningSpace DVBTuningSpace;
#else
typedef struct DVBTuningSpace DVBTuningSpace;
#endif /* __cplusplus */

#endif 	/* __DVBTuningSpace_FWD_DEFINED__ */


#ifndef __DVBSTuningSpace_FWD_DEFINED__
#define __DVBSTuningSpace_FWD_DEFINED__

#ifdef __cplusplus
typedef class DVBSTuningSpace DVBSTuningSpace;
#else
typedef struct DVBSTuningSpace DVBSTuningSpace;
#endif /* __cplusplus */

#endif 	/* __DVBSTuningSpace_FWD_DEFINED__ */


#ifndef __ComponentTypes_FWD_DEFINED__
#define __ComponentTypes_FWD_DEFINED__

#ifdef __cplusplus
typedef class ComponentTypes ComponentTypes;
#else
typedef struct ComponentTypes ComponentTypes;
#endif /* __cplusplus */

#endif 	/* __ComponentTypes_FWD_DEFINED__ */


#ifndef __ComponentType_FWD_DEFINED__
#define __ComponentType_FWD_DEFINED__

#ifdef __cplusplus
typedef class ComponentType ComponentType;
#else
typedef struct ComponentType ComponentType;
#endif /* __cplusplus */

#endif 	/* __ComponentType_FWD_DEFINED__ */


#ifndef __LanguageComponentType_FWD_DEFINED__
#define __LanguageComponentType_FWD_DEFINED__

#ifdef __cplusplus
typedef class LanguageComponentType LanguageComponentType;
#else
typedef struct LanguageComponentType LanguageComponentType;
#endif /* __cplusplus */

#endif 	/* __LanguageComponentType_FWD_DEFINED__ */


#ifndef __MPEG2ComponentType_FWD_DEFINED__
#define __MPEG2ComponentType_FWD_DEFINED__

#ifdef __cplusplus
typedef class MPEG2ComponentType MPEG2ComponentType;
#else
typedef struct MPEG2ComponentType MPEG2ComponentType;
#endif /* __cplusplus */

#endif 	/* __MPEG2ComponentType_FWD_DEFINED__ */


#ifndef __ATSCComponentType_FWD_DEFINED__
#define __ATSCComponentType_FWD_DEFINED__

#ifdef __cplusplus
typedef class ATSCComponentType ATSCComponentType;
#else
typedef struct ATSCComponentType ATSCComponentType;
#endif /* __cplusplus */

#endif 	/* __ATSCComponentType_FWD_DEFINED__ */


#ifndef __Components_FWD_DEFINED__
#define __Components_FWD_DEFINED__

#ifdef __cplusplus
typedef class Components Components;
#else
typedef struct Components Components;
#endif /* __cplusplus */

#endif 	/* __Components_FWD_DEFINED__ */


#ifndef __Component_FWD_DEFINED__
#define __Component_FWD_DEFINED__

#ifdef __cplusplus
typedef class Component Component;
#else
typedef struct Component Component;
#endif /* __cplusplus */

#endif 	/* __Component_FWD_DEFINED__ */


#ifndef __MPEG2Component_FWD_DEFINED__
#define __MPEG2Component_FWD_DEFINED__

#ifdef __cplusplus
typedef class MPEG2Component MPEG2Component;
#else
typedef struct MPEG2Component MPEG2Component;
#endif /* __cplusplus */

#endif 	/* __MPEG2Component_FWD_DEFINED__ */


#ifndef __TuneRequest_FWD_DEFINED__
#define __TuneRequest_FWD_DEFINED__

#ifdef __cplusplus
typedef class TuneRequest TuneRequest;
#else
typedef struct TuneRequest TuneRequest;
#endif /* __cplusplus */

#endif 	/* __TuneRequest_FWD_DEFINED__ */


#ifndef __ChannelTuneRequest_FWD_DEFINED__
#define __ChannelTuneRequest_FWD_DEFINED__

#ifdef __cplusplus
typedef class ChannelTuneRequest ChannelTuneRequest;
#else
typedef struct ChannelTuneRequest ChannelTuneRequest;
#endif /* __cplusplus */

#endif 	/* __ChannelTuneRequest_FWD_DEFINED__ */


#ifndef __ATSCChannelTuneRequest_FWD_DEFINED__
#define __ATSCChannelTuneRequest_FWD_DEFINED__

#ifdef __cplusplus
typedef class ATSCChannelTuneRequest ATSCChannelTuneRequest;
#else
typedef struct ATSCChannelTuneRequest ATSCChannelTuneRequest;
#endif /* __cplusplus */

#endif 	/* __ATSCChannelTuneRequest_FWD_DEFINED__ */


#ifndef __MPEG2TuneRequest_FWD_DEFINED__
#define __MPEG2TuneRequest_FWD_DEFINED__

#ifdef __cplusplus
typedef class MPEG2TuneRequest MPEG2TuneRequest;
#else
typedef struct MPEG2TuneRequest MPEG2TuneRequest;
#endif /* __cplusplus */

#endif 	/* __MPEG2TuneRequest_FWD_DEFINED__ */


#ifndef __MPEG2TuneRequestFactory_FWD_DEFINED__
#define __MPEG2TuneRequestFactory_FWD_DEFINED__

#ifdef __cplusplus
typedef class MPEG2TuneRequestFactory MPEG2TuneRequestFactory;
#else
typedef struct MPEG2TuneRequestFactory MPEG2TuneRequestFactory;
#endif /* __cplusplus */

#endif 	/* __MPEG2TuneRequestFactory_FWD_DEFINED__ */


#ifndef __Locator_FWD_DEFINED__
#define __Locator_FWD_DEFINED__

#ifdef __cplusplus
typedef class Locator Locator;
#else
typedef struct Locator Locator;
#endif /* __cplusplus */

#endif 	/* __Locator_FWD_DEFINED__ */


#ifndef __ATSCLocator_FWD_DEFINED__
#define __ATSCLocator_FWD_DEFINED__

#ifdef __cplusplus
typedef class ATSCLocator ATSCLocator;
#else
typedef struct ATSCLocator ATSCLocator;
#endif /* __cplusplus */

#endif 	/* __ATSCLocator_FWD_DEFINED__ */


#ifndef __DVBTLocator_FWD_DEFINED__
#define __DVBTLocator_FWD_DEFINED__

#ifdef __cplusplus
typedef class DVBTLocator DVBTLocator;
#else
typedef struct DVBTLocator DVBTLocator;
#endif /* __cplusplus */

#endif 	/* __DVBTLocator_FWD_DEFINED__ */


#ifndef __DVBSLocator_FWD_DEFINED__
#define __DVBSLocator_FWD_DEFINED__

#ifdef __cplusplus
typedef class DVBSLocator DVBSLocator;
#else
typedef struct DVBSLocator DVBSLocator;
#endif /* __cplusplus */

#endif 	/* __DVBSLocator_FWD_DEFINED__ */


#ifndef __DVBCLocator_FWD_DEFINED__
#define __DVBCLocator_FWD_DEFINED__

#ifdef __cplusplus
typedef class DVBCLocator DVBCLocator;
#else
typedef struct DVBCLocator DVBCLocator;
#endif /* __cplusplus */

#endif 	/* __DVBCLocator_FWD_DEFINED__ */


#ifndef __DVBTuneRequest_FWD_DEFINED__
#define __DVBTuneRequest_FWD_DEFINED__

#ifdef __cplusplus
typedef class DVBTuneRequest DVBTuneRequest;
#else
typedef struct DVBTuneRequest DVBTuneRequest;
#endif /* __cplusplus */

#endif 	/* __DVBTuneRequest_FWD_DEFINED__ */


#ifndef __CreatePropBagOnRegKey_FWD_DEFINED__
#define __CreatePropBagOnRegKey_FWD_DEFINED__

#ifdef __cplusplus
typedef class CreatePropBagOnRegKey CreatePropBagOnRegKey;
#else
typedef struct CreatePropBagOnRegKey CreatePropBagOnRegKey;
#endif /* __cplusplus */

#endif 	/* __CreatePropBagOnRegKey_FWD_DEFINED__ */


#ifndef __BroadcastEventService_FWD_DEFINED__
#define __BroadcastEventService_FWD_DEFINED__

#ifdef __cplusplus
typedef class BroadcastEventService BroadcastEventService;
#else
typedef struct BroadcastEventService BroadcastEventService;
#endif /* __cplusplus */

#endif 	/* __BroadcastEventService_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "comcat.h"
#include "strmif.h"
#include "bdatypes.h"
#include "regbag.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_tuner_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999-2000.
//
//--------------------------------------------------------------------------
#pragma once
#include <bdatypes.h>





















enum __MIDL___MIDL_itf_tuner_0000_0001
    {	DISPID_TUNER_TS_UNIQUENAME	= 1,
	DISPID_TUNER_TS_FRIENDLYNAME	= 2,
	DISPID_TUNER_TS_CLSID	= 3,
	DISPID_TUNER_TS_NETWORKTYPE	= 4,
	DISPID_TUNER_TS__NETWORKTYPE	= 5,
	DISPID_TUNER_TS_CREATETUNEREQUEST	= 6,
	DISPID_TUNER_TS_ENUMCATEGORYGUIDS	= 7,
	DISPID_TUNER_TS_ENUMDEVICEMONIKERS	= 8,
	DISPID_TUNER_TS_DEFAULTPREFERREDCOMPONENTTYPES	= 9,
	DISPID_TUNER_TS_FREQMAP	= 10,
	DISPID_TUNER_TS_DEFLOCATOR	= 11,
	DISPID_TUNER_TS_CLONE	= 12,
	DISPID_TUNER_TR_TUNINGSPACE	= 1,
	DISPID_TUNER_TR_COMPONENTS	= 2,
	DISPID_TUNER_TR_CLONE	= 3,
	DISPID_TUNER_TR_LOCATOR	= 4,
	DISPID_TUNER_CT_CATEGORY	= 1,
	DISPID_TUNER_CT_MEDIAMAJORTYPE	= 2,
	DISPID_TUNER_CT__MEDIAMAJORTYPE	= 3,
	DISPID_TUNER_CT_MEDIASUBTYPE	= 4,
	DISPID_TUNER_CT__MEDIASUBTYPE	= 5,
	DISPID_TUNER_CT_MEDIAFORMATTYPE	= 6,
	DISPID_TUNER_CT__MEDIAFORMATTYPE	= 7,
	DISPID_TUNER_CT_MEDIATYPE	= 8,
	DISPID_TUNER_CT_CLONE	= 9,
	DISPID_TUNER_LCT_LANGID	= 100,
	DISPID_TUNER_MP2CT_TYPE	= 200,
	DISPID_TUNER_ATSCCT_FLAGS	= 300,
	DISPID_TUNER_L_CARRFREQ	= 1,
	DISPID_TUNER_L_INNERFECMETHOD	= 2,
	DISPID_TUNER_L_INNERFECRATE	= 3,
	DISPID_TUNER_L_OUTERFECMETHOD	= 4,
	DISPID_TUNER_L_OUTERFECRATE	= 5,
	DISPID_TUNER_L_MOD	= 6,
	DISPID_TUNER_L_SYMRATE	= 7,
	DISPID_TUNER_L_CLONE	= 8,
	DISPID_TUNER_L_ATSC_PHYS_CHANNEL	= 201,
	DISPID_TUNER_L_ATSC_TSID	= 202,
	DISPID_TUNER_L_DVBT_BANDWIDTH	= 301,
	DISPID_TUNER_L_DVBT_LPINNERFECMETHOD	= 302,
	DISPID_TUNER_L_DVBT_LPINNERFECRATE	= 303,
	DISPID_TUNER_L_DVBT_GUARDINTERVAL	= 304,
	DISPID_TUNER_L_DVBT_HALPHA	= 305,
	DISPID_TUNER_L_DVBT_TRANSMISSIONMODE	= 306,
	DISPID_TUNER_L_DVBT_INUSE	= 307,
	DISPID_TUNER_L_DVBS_POLARISATION	= 401,
	DISPID_TUNER_L_DVBS_WEST	= 402,
	DISPID_TUNER_L_DVBS_ORBITAL	= 403,
	DISPID_TUNER_L_DVBS_AZIMUTH	= 404,
	DISPID_TUNER_L_DVBS_ELEVATION	= 405,
	DISPID_TUNER_C_TYPE	= 1,
	DISPID_TUNER_C_STATUS	= 2,
	DISPID_TUNER_C_LANGID	= 3,
	DISPID_TUNER_C_DESCRIPTION	= 4,
	DISPID_TUNER_C_CLONE	= 5,
	DISPID_TUNER_C_MP2_PID	= 101,
	DISPID_TUNER_C_MP2_PCRPID	= 102,
	DISPID_TUNER_C_MP2_PROGNO	= 103,
	DISPID_TUNER_TS_DVB_SYSTEMTYPE	= 101,
	DISPID_TUNER_TS_DVB2_NETWORK_ID	= 102,
	DISPID_TUNER_TS_DVBS_LOW_OSC_FREQ	= 1001,
	DISPID_TUNER_TS_DVBS_HI_OSC_FREQ	= 1002,
	DISPID_TUNER_TS_DVBS_LNB_SWITCH_FREQ	= 1003,
	DISPID_TUNER_TS_DVBS_INPUT_RANGE	= 1004,
	DISPID_TUNER_TS_DVBS_SPECTRAL_INVERSION	= 1005,
	DISPID_TUNER_TS_AR_MINFREQUENCY	= 101,
	DISPID_TUNER_TS_AR_MAXFREQUENCY	= 102,
	DISPID_TUNER_TS_AR_STEP	= 103,
	DISPID_TUNER_TS_ATV_MINCHANNEL	= 101,
	DISPID_TUNER_TS_ATV_MAXCHANNEL	= 102,
	DISPID_TUNER_TS_ATV_INPUTTYPE	= 103,
	DISPID_TUNER_TS_ATV_COUNTRYCODE	= 104,
	DISPID_TUNER_TS_ATSC_MINMINORCHANNEL	= 201,
	DISPID_TUNER_TS_ATSC_MAXMINORCHANNEL	= 202,
	DISPID_TUNER_TS_ATSC_MINPHYSCHANNEL	= 203,
	DISPID_TUNER_TS_ATSC_MAXPHYSCHANNEL	= 204,
	DISPID_CHTUNER_ATVAC_CHANNEL	= 101,
	DISPID_CHTUNER_ATVDC_SYSTEM	= 101,
	DISPID_CHTUNER_ATVDC_CONTENT	= 102,
	DISPID_CHTUNER_CTR_CHANNEL	= 101,
	DISPID_CHTUNER_ACTR_MINOR_CHANNEL	= 201,
	DISPID_DVBTUNER_DVBC_ATTRIBUTESVALID	= 101,
	DISPID_DVBTUNER_DVBC_PID	= 102,
	DISPID_DVBTUNER_DVBC_TAG	= 103,
	DISPID_DVBTUNER_DVBC_COMPONENTTYPE	= 104,
	DISPID_DVBTUNER_ONID	= 101,
	DISPID_DVBTUNER_TSID	= 102,
	DISPID_DVBTUNER_SID	= 103,
	DISPID_MP2TUNER_TSID	= 101,
	DISPID_MP2TUNER_PROGNO	= 102,
	DISPID_MP2TUNERFACTORY_CREATETUNEREQUEST	= 1
    } ;


extern RPC_IF_HANDLE __MIDL_itf_tuner_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_tuner_0000_v0_0_s_ifspec;

#ifndef __ITuningSpaces_INTERFACE_DEFINED__
#define __ITuningSpaces_INTERFACE_DEFINED__

/* interface ITuningSpaces */
/* [unique][helpstring][nonextensible][oleautomation][dual][uuid][object] */ 


EXTERN_C const IID IID_ITuningSpaces;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("901284E4-33FE-4b69-8D63-634A596F3756")
    ITuningSpaces : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *Count) = 0;
        
        virtual /* [restricted][hidden][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IEnumVARIANT **NewEnum) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT varIndex,
            /* [retval][out] */ ITuningSpace **TuningSpace) = 0;
        
        virtual /* [helpstring][restricted][hidden][propget] */ HRESULT STDMETHODCALLTYPE get_EnumTuningSpaces( 
            /* [retval][out] */ IEnumTuningSpaces **NewEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITuningSpacesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITuningSpaces * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITuningSpaces * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITuningSpaces * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITuningSpaces * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITuningSpaces * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITuningSpaces * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITuningSpaces * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            ITuningSpaces * This,
            /* [retval][out] */ long *Count);
        
        /* [restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            ITuningSpaces * This,
            /* [retval][out] */ IEnumVARIANT **NewEnum);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            ITuningSpaces * This,
            /* [in] */ VARIANT varIndex,
            /* [retval][out] */ ITuningSpace **TuningSpace);
        
        /* [helpstring][restricted][hidden][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnumTuningSpaces )( 
            ITuningSpaces * This,
            /* [retval][out] */ IEnumTuningSpaces **NewEnum);
        
        END_INTERFACE
    } ITuningSpacesVtbl;

    interface ITuningSpaces
    {
        CONST_VTBL struct ITuningSpacesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITuningSpaces_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITuningSpaces_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITuningSpaces_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITuningSpaces_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITuningSpaces_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITuningSpaces_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITuningSpaces_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITuningSpaces_get_Count(This,Count)	\
    (This)->lpVtbl -> get_Count(This,Count)

#define ITuningSpaces_get__NewEnum(This,NewEnum)	\
    (This)->lpVtbl -> get__NewEnum(This,NewEnum)

#define ITuningSpaces_get_Item(This,varIndex,TuningSpace)	\
    (This)->lpVtbl -> get_Item(This,varIndex,TuningSpace)

#define ITuningSpaces_get_EnumTuningSpaces(This,NewEnum)	\
    (This)->lpVtbl -> get_EnumTuningSpaces(This,NewEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ITuningSpaces_get_Count_Proxy( 
    ITuningSpaces * This,
    /* [retval][out] */ long *Count);


void __RPC_STUB ITuningSpaces_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id][propget] */ HRESULT STDMETHODCALLTYPE ITuningSpaces_get__NewEnum_Proxy( 
    ITuningSpaces * This,
    /* [retval][out] */ IEnumVARIANT **NewEnum);


void __RPC_STUB ITuningSpaces_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITuningSpaces_get_Item_Proxy( 
    ITuningSpaces * This,
    /* [in] */ VARIANT varIndex,
    /* [retval][out] */ ITuningSpace **TuningSpace);


void __RPC_STUB ITuningSpaces_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][restricted][hidden][propget] */ HRESULT STDMETHODCALLTYPE ITuningSpaces_get_EnumTuningSpaces_Proxy( 
    ITuningSpaces * This,
    /* [retval][out] */ IEnumTuningSpaces **NewEnum);


void __RPC_STUB ITuningSpaces_get_EnumTuningSpaces_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITuningSpaces_INTERFACE_DEFINED__ */


#ifndef __ITuningSpaceContainer_INTERFACE_DEFINED__
#define __ITuningSpaceContainer_INTERFACE_DEFINED__

/* interface ITuningSpaceContainer */
/* [unique][helpstring][nonextensible][hidden][oleautomation][dual][uuid][object] */ 


EXTERN_C const IID IID_ITuningSpaceContainer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5B692E84-E2F1-11d2-9493-00C04F72D980")
    ITuningSpaceContainer : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *Count) = 0;
        
        virtual /* [restricted][hidden][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IEnumVARIANT **NewEnum) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT varIndex,
            /* [retval][out] */ ITuningSpace **TuningSpace) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Item( 
            /* [in] */ VARIANT varIndex,
            /* [in] */ ITuningSpace *TuningSpace) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE TuningSpacesForCLSID( 
            /* [in] */ BSTR SpaceCLSID,
            /* [retval][out] */ ITuningSpaces **NewColl) = 0;
        
        virtual /* [helpstring][restricted][hidden] */ HRESULT STDMETHODCALLTYPE _TuningSpacesForCLSID( 
            /* [in] */ REFCLSID SpaceCLSID,
            /* [retval][out] */ ITuningSpaces **NewColl) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE TuningSpacesForName( 
            /* [in] */ BSTR Name,
            /* [retval][out] */ ITuningSpaces **NewColl) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FindID( 
            /* [in] */ ITuningSpace *TuningSpace,
            /* [retval][out] */ long *ID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ ITuningSpace *TuningSpace,
            /* [retval][out] */ VARIANT *NewIndex) = 0;
        
        virtual /* [helpstring][restricted][hidden][propget] */ HRESULT STDMETHODCALLTYPE get_EnumTuningSpaces( 
            /* [retval][out] */ IEnumTuningSpaces **ppEnum) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ VARIANT Index) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_MaxCount( 
            /* [retval][out] */ long *MaxCount) = 0;
        
        virtual /* [helpstring][restricted][hidden][propput] */ HRESULT STDMETHODCALLTYPE put_MaxCount( 
            /* [in] */ long MaxCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITuningSpaceContainerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITuningSpaceContainer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITuningSpaceContainer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITuningSpaceContainer * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITuningSpaceContainer * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITuningSpaceContainer * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITuningSpaceContainer * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITuningSpaceContainer * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            ITuningSpaceContainer * This,
            /* [retval][out] */ long *Count);
        
        /* [restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            ITuningSpaceContainer * This,
            /* [retval][out] */ IEnumVARIANT **NewEnum);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            ITuningSpaceContainer * This,
            /* [in] */ VARIANT varIndex,
            /* [retval][out] */ ITuningSpace **TuningSpace);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Item )( 
            ITuningSpaceContainer * This,
            /* [in] */ VARIANT varIndex,
            /* [in] */ ITuningSpace *TuningSpace);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *TuningSpacesForCLSID )( 
            ITuningSpaceContainer * This,
            /* [in] */ BSTR SpaceCLSID,
            /* [retval][out] */ ITuningSpaces **NewColl);
        
        /* [helpstring][restricted][hidden] */ HRESULT ( STDMETHODCALLTYPE *_TuningSpacesForCLSID )( 
            ITuningSpaceContainer * This,
            /* [in] */ REFCLSID SpaceCLSID,
            /* [retval][out] */ ITuningSpaces **NewColl);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *TuningSpacesForName )( 
            ITuningSpaceContainer * This,
            /* [in] */ BSTR Name,
            /* [retval][out] */ ITuningSpaces **NewColl);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FindID )( 
            ITuningSpaceContainer * This,
            /* [in] */ ITuningSpace *TuningSpace,
            /* [retval][out] */ long *ID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            ITuningSpaceContainer * This,
            /* [in] */ ITuningSpace *TuningSpace,
            /* [retval][out] */ VARIANT *NewIndex);
        
        /* [helpstring][restricted][hidden][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnumTuningSpaces )( 
            ITuningSpaceContainer * This,
            /* [retval][out] */ IEnumTuningSpaces **ppEnum);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            ITuningSpaceContainer * This,
            /* [in] */ VARIANT Index);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MaxCount )( 
            ITuningSpaceContainer * This,
            /* [retval][out] */ long *MaxCount);
        
        /* [helpstring][restricted][hidden][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MaxCount )( 
            ITuningSpaceContainer * This,
            /* [in] */ long MaxCount);
        
        END_INTERFACE
    } ITuningSpaceContainerVtbl;

    interface ITuningSpaceContainer
    {
        CONST_VTBL struct ITuningSpaceContainerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITuningSpaceContainer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITuningSpaceContainer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITuningSpaceContainer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITuningSpaceContainer_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITuningSpaceContainer_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITuningSpaceContainer_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITuningSpaceContainer_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITuningSpaceContainer_get_Count(This,Count)	\
    (This)->lpVtbl -> get_Count(This,Count)

#define ITuningSpaceContainer_get__NewEnum(This,NewEnum)	\
    (This)->lpVtbl -> get__NewEnum(This,NewEnum)

#define ITuningSpaceContainer_get_Item(This,varIndex,TuningSpace)	\
    (This)->lpVtbl -> get_Item(This,varIndex,TuningSpace)

#define ITuningSpaceContainer_put_Item(This,varIndex,TuningSpace)	\
    (This)->lpVtbl -> put_Item(This,varIndex,TuningSpace)

#define ITuningSpaceContainer_TuningSpacesForCLSID(This,SpaceCLSID,NewColl)	\
    (This)->lpVtbl -> TuningSpacesForCLSID(This,SpaceCLSID,NewColl)

#define ITuningSpaceContainer__TuningSpacesForCLSID(This,SpaceCLSID,NewColl)	\
    (This)->lpVtbl -> _TuningSpacesForCLSID(This,SpaceCLSID,NewColl)

#define ITuningSpaceContainer_TuningSpacesForName(This,Name,NewColl)	\
    (This)->lpVtbl -> TuningSpacesForName(This,Name,NewColl)

#define ITuningSpaceContainer_FindID(This,TuningSpace,ID)	\
    (This)->lpVtbl -> FindID(This,TuningSpace,ID)

#define ITuningSpaceContainer_Add(This,TuningSpace,NewIndex)	\
    (This)->lpVtbl -> Add(This,TuningSpace,NewIndex)

#define ITuningSpaceContainer_get_EnumTuningSpaces(This,ppEnum)	\
    (This)->lpVtbl -> get_EnumTuningSpaces(This,ppEnum)

#define ITuningSpaceContainer_Remove(This,Index)	\
    (This)->lpVtbl -> Remove(This,Index)

#define ITuningSpaceContainer_get_MaxCount(This,MaxCount)	\
    (This)->lpVtbl -> get_MaxCount(This,MaxCount)

#define ITuningSpaceContainer_put_MaxCount(This,MaxCount)	\
    (This)->lpVtbl -> put_MaxCount(This,MaxCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ITuningSpaceContainer_get_Count_Proxy( 
    ITuningSpaceContainer * This,
    /* [retval][out] */ long *Count);


void __RPC_STUB ITuningSpaceContainer_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id][propget] */ HRESULT STDMETHODCALLTYPE ITuningSpaceContainer_get__NewEnum_Proxy( 
    ITuningSpaceContainer * This,
    /* [retval][out] */ IEnumVARIANT **NewEnum);


void __RPC_STUB ITuningSpaceContainer_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITuningSpaceContainer_get_Item_Proxy( 
    ITuningSpaceContainer * This,
    /* [in] */ VARIANT varIndex,
    /* [retval][out] */ ITuningSpace **TuningSpace);


void __RPC_STUB ITuningSpaceContainer_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITuningSpaceContainer_put_Item_Proxy( 
    ITuningSpaceContainer * This,
    /* [in] */ VARIANT varIndex,
    /* [in] */ ITuningSpace *TuningSpace);


void __RPC_STUB ITuningSpaceContainer_put_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ITuningSpaceContainer_TuningSpacesForCLSID_Proxy( 
    ITuningSpaceContainer * This,
    /* [in] */ BSTR SpaceCLSID,
    /* [retval][out] */ ITuningSpaces **NewColl);


void __RPC_STUB ITuningSpaceContainer_TuningSpacesForCLSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][restricted][hidden] */ HRESULT STDMETHODCALLTYPE ITuningSpaceContainer__TuningSpacesForCLSID_Proxy( 
    ITuningSpaceContainer * This,
    /* [in] */ REFCLSID SpaceCLSID,
    /* [retval][out] */ ITuningSpaces **NewColl);


void __RPC_STUB ITuningSpaceContainer__TuningSpacesForCLSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ITuningSpaceContainer_TuningSpacesForName_Proxy( 
    ITuningSpaceContainer * This,
    /* [in] */ BSTR Name,
    /* [retval][out] */ ITuningSpaces **NewColl);


void __RPC_STUB ITuningSpaceContainer_TuningSpacesForName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ITuningSpaceContainer_FindID_Proxy( 
    ITuningSpaceContainer * This,
    /* [in] */ ITuningSpace *TuningSpace,
    /* [retval][out] */ long *ID);


void __RPC_STUB ITuningSpaceContainer_FindID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITuningSpaceContainer_Add_Proxy( 
    ITuningSpaceContainer * This,
    /* [in] */ ITuningSpace *TuningSpace,
    /* [retval][out] */ VARIANT *NewIndex);


void __RPC_STUB ITuningSpaceContainer_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][restricted][hidden][propget] */ HRESULT STDMETHODCALLTYPE ITuningSpaceContainer_get_EnumTuningSpaces_Proxy( 
    ITuningSpaceContainer * This,
    /* [retval][out] */ IEnumTuningSpaces **ppEnum);


void __RPC_STUB ITuningSpaceContainer_get_EnumTuningSpaces_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITuningSpaceContainer_Remove_Proxy( 
    ITuningSpaceContainer * This,
    /* [in] */ VARIANT Index);


void __RPC_STUB ITuningSpaceContainer_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ITuningSpaceContainer_get_MaxCount_Proxy( 
    ITuningSpaceContainer * This,
    /* [retval][out] */ long *MaxCount);


void __RPC_STUB ITuningSpaceContainer_get_MaxCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][restricted][hidden][propput] */ HRESULT STDMETHODCALLTYPE ITuningSpaceContainer_put_MaxCount_Proxy( 
    ITuningSpaceContainer * This,
    /* [in] */ long MaxCount);


void __RPC_STUB ITuningSpaceContainer_put_MaxCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITuningSpaceContainer_INTERFACE_DEFINED__ */


#ifndef __ITuningSpace_INTERFACE_DEFINED__
#define __ITuningSpace_INTERFACE_DEFINED__

/* interface ITuningSpace */
/* [unique][helpstring][nonextensible][oleautomation][dual][uuid][object] */ 


EXTERN_C const IID IID_ITuningSpace;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("061C6E30-E622-11d2-9493-00C04F72D980")
    ITuningSpace : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UniqueName( 
            /* [retval][out] */ BSTR *Name) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_UniqueName( 
            /* [in] */ BSTR Name) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FriendlyName( 
            /* [retval][out] */ BSTR *Name) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_FriendlyName( 
            /* [in] */ BSTR Name) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CLSID( 
            /* [retval][out] */ BSTR *SpaceCLSID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_NetworkType( 
            /* [retval][out] */ BSTR *NetworkTypeGuid) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_NetworkType( 
            /* [in] */ BSTR NetworkTypeGuid) = 0;
        
        virtual /* [restricted][hidden][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__NetworkType( 
            /* [retval][out] */ GUID *NetworkTypeGuid) = 0;
        
        virtual /* [restricted][hidden][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put__NetworkType( 
            /* [in] */ REFCLSID NetworkTypeGuid) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateTuneRequest( 
            /* [retval][out] */ ITuneRequest **TuneRequest) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE EnumCategoryGUIDs( 
            /* [retval][out] */ IEnumGUID **ppEnum) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE EnumDeviceMonikers( 
            /* [retval][out] */ IEnumMoniker **ppEnum) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_DefaultPreferredComponentTypes( 
            /* [retval][out] */ IComponentTypes **ComponentTypes) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_DefaultPreferredComponentTypes( 
            /* [in] */ IComponentTypes *NewComponentTypes) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_FrequencyMapping( 
            /* [retval][out] */ BSTR *pMapping) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_FrequencyMapping( 
            BSTR Mapping) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_DefaultLocator( 
            /* [retval][out] */ ILocator **LocatorVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_DefaultLocator( 
            /* [in] */ ILocator *LocatorVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ ITuningSpace **NewTS) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITuningSpaceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITuningSpace * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITuningSpace * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITuningSpace * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITuningSpace * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITuningSpace * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITuningSpace * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITuningSpace * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UniqueName )( 
            ITuningSpace * This,
            /* [retval][out] */ BSTR *Name);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_UniqueName )( 
            ITuningSpace * This,
            /* [in] */ BSTR Name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FriendlyName )( 
            ITuningSpace * This,
            /* [retval][out] */ BSTR *Name);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_FriendlyName )( 
            ITuningSpace * This,
            /* [in] */ BSTR Name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CLSID )( 
            ITuningSpace * This,
            /* [retval][out] */ BSTR *SpaceCLSID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_NetworkType )( 
            ITuningSpace * This,
            /* [retval][out] */ BSTR *NetworkTypeGuid);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_NetworkType )( 
            ITuningSpace * This,
            /* [in] */ BSTR NetworkTypeGuid);
        
        /* [restricted][hidden][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NetworkType )( 
            ITuningSpace * This,
            /* [retval][out] */ GUID *NetworkTypeGuid);
        
        /* [restricted][hidden][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put__NetworkType )( 
            ITuningSpace * This,
            /* [in] */ REFCLSID NetworkTypeGuid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateTuneRequest )( 
            ITuningSpace * This,
            /* [retval][out] */ ITuneRequest **TuneRequest);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumCategoryGUIDs )( 
            ITuningSpace * This,
            /* [retval][out] */ IEnumGUID **ppEnum);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumDeviceMonikers )( 
            ITuningSpace * This,
            /* [retval][out] */ IEnumMoniker **ppEnum);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DefaultPreferredComponentTypes )( 
            ITuningSpace * This,
            /* [retval][out] */ IComponentTypes **ComponentTypes);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DefaultPreferredComponentTypes )( 
            ITuningSpace * This,
            /* [in] */ IComponentTypes *NewComponentTypes);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FrequencyMapping )( 
            ITuningSpace * This,
            /* [retval][out] */ BSTR *pMapping);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_FrequencyMapping )( 
            ITuningSpace * This,
            BSTR Mapping);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DefaultLocator )( 
            ITuningSpace * This,
            /* [retval][out] */ ILocator **LocatorVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DefaultLocator )( 
            ITuningSpace * This,
            /* [in] */ ILocator *LocatorVal);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ITuningSpace * This,
            /* [retval][out] */ ITuningSpace **NewTS);
        
        END_INTERFACE
    } ITuningSpaceVtbl;

    interface ITuningSpace
    {
        CONST_VTBL struct ITuningSpaceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITuningSpace_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITuningSpace_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITuningSpace_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITuningSpace_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITuningSpace_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITuningSpace_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITuningSpace_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITuningSpace_get_UniqueName(This,Name)	\
    (This)->lpVtbl -> get_UniqueName(This,Name)

#define ITuningSpace_put_UniqueName(This,Name)	\
    (This)->lpVtbl -> put_UniqueName(This,Name)

#define ITuningSpace_get_FriendlyName(This,Name)	\
    (This)->lpVtbl -> get_FriendlyName(This,Name)

#define ITuningSpace_put_FriendlyName(This,Name)	\
    (This)->lpVtbl -> put_FriendlyName(This,Name)

#define ITuningSpace_get_CLSID(This,SpaceCLSID)	\
    (This)->lpVtbl -> get_CLSID(This,SpaceCLSID)

#define ITuningSpace_get_NetworkType(This,NetworkTypeGuid)	\
    (This)->lpVtbl -> get_NetworkType(This,NetworkTypeGuid)

#define ITuningSpace_put_NetworkType(This,NetworkTypeGuid)	\
    (This)->lpVtbl -> put_NetworkType(This,NetworkTypeGuid)

#define ITuningSpace_get__NetworkType(This,NetworkTypeGuid)	\
    (This)->lpVtbl -> get__NetworkType(This,NetworkTypeGuid)

#define ITuningSpace_put__NetworkType(This,NetworkTypeGuid)	\
    (This)->lpVtbl -> put__NetworkType(This,NetworkTypeGuid)

#define ITuningSpace_CreateTuneRequest(This,TuneRequest)	\
    (This)->lpVtbl -> CreateTuneRequest(This,TuneRequest)

#define ITuningSpace_EnumCategoryGUIDs(This,ppEnum)	\
    (This)->lpVtbl -> EnumCategoryGUIDs(This,ppEnum)

#define ITuningSpace_EnumDeviceMonikers(This,ppEnum)	\
    (This)->lpVtbl -> EnumDeviceMonikers(This,ppEnum)

#define ITuningSpace_get_DefaultPreferredComponentTypes(This,ComponentTypes)	\
    (This)->lpVtbl -> get_DefaultPreferredComponentTypes(This,ComponentTypes)

#define ITuningSpace_put_DefaultPreferredComponentTypes(This,NewComponentTypes)	\
    (This)->lpVtbl -> put_DefaultPreferredComponentTypes(This,NewComponentTypes)

#define ITuningSpace_get_FrequencyMapping(This,pMapping)	\
    (This)->lpVtbl -> get_FrequencyMapping(This,pMapping)

#define ITuningSpace_put_FrequencyMapping(This,Mapping)	\
    (This)->lpVtbl -> put_FrequencyMapping(This,Mapping)

#define ITuningSpace_get_DefaultLocator(This,LocatorVal)	\
    (This)->lpVtbl -> get_DefaultLocator(This,LocatorVal)

#define ITuningSpace_put_DefaultLocator(This,LocatorVal)	\
    (This)->lpVtbl -> put_DefaultLocat