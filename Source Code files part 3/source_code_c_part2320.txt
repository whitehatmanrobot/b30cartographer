          0x00000000 /* RWI-V */
#define NV_PFIFO_MODE_CHANNEL_8_DMA                      0x00000001 /* RW--V */
#define NV_PFIFO_MODE_CHANNEL_9                                 9:9 /* RWIVF */
#define NV_PFIFO_MODE_CHANNEL_9_PIO                      0x00000000 /* RWI-V */
#define NV_PFIFO_MODE_CHANNEL_9_DMA                      0x00000001 /* RW--V */
#define NV_PFIFO_MODE_CHANNEL_10                              10:10 /* RWIVF */
#define NV_PFIFO_MODE_CHANNEL_10_PIO                     0x00000000 /* RWI-V */
#define NV_PFIFO_MODE_CHANNEL_10_DMA                     0x00000001 /* RW--V */
#define NV_PFIFO_MODE_CHANNEL_11                              11:11 /* RWIVF */
#define NV_PFIFO_MODE_CHANNEL_11_PIO                     0x00000000 /* RWI-V */
#define NV_PFIFO_MODE_CHANNEL_11_DMA                     0x00000001 /* RW--V */
#define NV_PFIFO_MODE_CHANNEL_12                              12:12 /* RWIVF */
#define NV_PFIFO_MODE_CHANNEL_12_PIO                     0x00000000 /* RWI-V */
#define NV_PFIFO_MODE_CHANNEL_12_DMA                     0x00000001 /* RW--V */
#define NV_PFIFO_MODE_CHANNEL_13                              13:13 /* RWIVF */
#define NV_PFIFO_MODE_CHANNEL_13_PIO                     0x00000000 /* RWI-V */
#define NV_PFIFO_MODE_CHANNEL_13_DMA                     0x00000001 /* RW--V */
#define NV_PFIFO_MODE_CHANNEL_14                              14:14 /* RWIVF */
#define NV_PFIFO_MODE_CHANNEL_14_PIO                     0x00000000 /* RWI-V */
#define NV_PFIFO_MODE_CHANNEL_14_DMA                     0x00000001 /* RW--V */
#define NV_PFIFO_MODE_CHANNEL_15                              15:15 /* RWIVF */
#define NV_PFIFO_MODE_CHANNEL_15_PIO                     0x00000000 /* RWI-V */
#define NV_PFIFO_MODE_CHANNEL_15_DMA                     0x00000001 /* RW--V */
#define NV_PFIFO_DMA                                     0x00002508 /* RW-4R */
#define NV_PFIFO_DMA_CHANNEL_0                                  0:0 /* RWIVF */
#define NV_PFIFO_DMA_CHANNEL_0_NOT_PENDING               0x00000000 /* RWI-V */
#define NV_PFIFO_DMA_CHANNEL_0_PENDING                   0x00000001 /* RW--V */
#define NV_PFIFO_DMA_CHANNEL_1                                  1:1 /* RWIVF */
#define NV_PFIFO_DMA_CHANNEL_1_NOT_PENDING               0x00000000 /* RWI-V */
#define NV_PFIFO_DMA_CHANNEL_1_PENDING                   0x00000001 /* RW--V */
#define NV_PFIFO_DMA_CHANNEL_2                                  2:2 /* RWIVF */
#define NV_PFIFO_DMA_CHANNEL_2_NOT_PENDING               0x00000000 /* RWI-V */
#define NV_PFIFO_DMA_CHANNEL_2_PENDING                   0x00000001 /* RW--V */
#define NV_PFIFO_DMA_CHANNEL_3                                  3:3 /* RWIVF */
#define NV_PFIFO_DMA_CHANNEL_3_NOT_PENDING               0x00000000 /* RWI-V */
#define NV_PFIFO_DMA_CHANNEL_3_PENDING                   0x00000001 /* RW--V */
#define NV_PFIFO_DMA_CHANNEL_4                                  4:4 /* RWIVF */
#define NV_PFIFO_DMA_CHANNEL_4_NOT_PENDING               0x00000000 /* RWI-V */
#define NV_PFIFO_DMA_CHANNEL_4_PENDING                   0x00000001 /* RW--V */
#define NV_PFIFO_DMA_CHANNEL_5                                  5:5 /* RWIVF */
#define NV_PFIFO_DMA_CHANNEL_5_NOT_PENDING               0x00000000 /* RWI-V */
#define NV_PFIFO_DMA_CHANNEL_5_PENDING                   0x00000001 /* RW--V */
#define NV_PFIFO_DMA_CHANNEL_6                                  6:6 /* RWIVF */
#define NV_PFIFO_DMA_CHANNEL_6_NOT_PENDING               0x00000000 /* RWI-V */
#define NV_PFIFO_DMA_CHANNEL_6_PENDING                   0x00000001 /* RW--V */
#define NV_PFIFO_DMA_CHANNEL_7                                  7:7 /* RWIVF */
#define NV_PFIFO_DMA_CHANNEL_7_NOT_PENDING               0x00000000 /* RWI-V */
#define NV_PFIFO_DMA_CHANNEL_7_PENDING                   0x00000001 /* RW--V */
#define NV_PFIFO_DMA_CHANNEL_8                                  8:8 /* RWIVF */
#define NV_PFIFO_DMA_CHANNEL_8_NOT_PENDING               0x00000000 /* RWI-V */
#define NV_PFIFO_DMA_CHANNEL_8_PENDING                   0x00000001 /* RW--V */
#define NV_PFIFO_DMA_CHANNEL_9                                  9:9 /* RWIVF */
#define NV_PFIFO_DMA_CHANNEL_9_NOT_PENDING               0x00000000 /* RWI-V */
#define NV_PFIFO_DMA_CHANNEL_9_PENDING                   0x00000001 /* RW--V */
#define NV_PFIFO_DMA_CHANNEL_10                               10:10 /* RWIVF */
#define NV_PFIFO_DMA_CHANNEL_10_NOT_PENDING              0x00000000 /* RWI-V */
#define NV_PFIFO_DMA_CHANNEL_10_PENDING                  0x00000001 /* RW--V */
#define NV_PFIFO_DMA_CHANNEL_11                               11:11 /* RWIVF */
#define NV_PFIFO_DMA_CHANNEL_11_NOT_PENDING              0x00000000 /* RWI-V */
#define NV_PFIFO_DMA_CHANNEL_11_PENDING                  0x00000001 /* RW--V */
#define NV_PFIFO_DMA_CHANNEL_12                               12:12 /* RWIVF */
#define NV_PFIFO_DMA_CHANNEL_12_NOT_PENDING              0x00000000 /* RWI-V */
#define NV_PFIFO_DMA_CHANNEL_12_PENDING                  0x00000001 /* RW--V */
#define NV_PFIFO_DMA_CHANNEL_13                               13:13 /* RWIVF */
#define NV_PFIFO_DMA_CHANNEL_13_NOT_PENDING              0x00000000 /* RWI-V */
#define NV_PFIFO_DMA_CHANNEL_13_PENDING                  0x00000001 /* RW--V */
#define NV_PFIFO_DMA_CHANNEL_14                               14:14 /* RWIVF */
#define NV_PFIFO_DMA_CHANNEL_14_NOT_PENDING              0x00000000 /* RWI-V */
#define NV_PFIFO_DMA_CHANNEL_14_PENDING                  0x00000001 /* RW--V */
#define NV_PFIFO_DMA_CHANNEL_15                               15:15 /* RWIVF */
#define NV_PFIFO_DMA_CHANNEL_15_NOT_PENDING              0x00000000 /* RWI-V */
#define NV_PFIFO_DMA_CHANNEL_15_PENDING                  0x00000001 /* RW--V */
#define NV_PFIFO_SIZE                                    0x0000250C /* RW-4R */
#define NV_PFIFO_SIZE_CHANNEL_0                                 0:0 /* RWIVF */
#define NV_PFIFO_SIZE_CHANNEL_0_124_BYTES                0x00000000 /* RWI-V */
#define NV_PFIFO_SIZE_CHANNEL_0_512_BYTES                0x00000001 /* RW--V */
#define NV_PFIFO_SIZE_CHANNEL_1                                 1:1 /* RWIVF */
#define NV_PFIFO_SIZE_CHANNEL_1_124_BYTES                0x00000000 /* RWI-V */
#define NV_PFIFO_SIZE_CHANNEL_1_512_BYTES                0x00000001 /* RW--V */
#define NV_PFIFO_SIZE_CHANNEL_2                                 2:2 /* RWIVF */
#define NV_PFIFO_SIZE_CHANNEL_2_124_BYTES                0x00000000 /* RWI-V */
#define NV_PFIFO_SIZE_CHANNEL_2_512_BYTES                0x00000001 /* RW--V */
#define NV_PFIFO_SIZE_CHANNEL_3                                 3:3 /* RWIVF */
#define NV_PFIFO_SIZE_CHANNEL_3_124_BYTES                0x00000000 /* RWI-V */
#define NV_PFIFO_SIZE_CHANNEL_3_512_BYTES                0x00000001 /* RW--V */
#define NV_PFIFO_SIZE_CHANNEL_4                                 4:4 /* RWIVF */
#define NV_PFIFO_SIZE_CHANNEL_4_124_BYTES                0x00000000 /* RWI-V */
#define NV_PFIFO_SIZE_CHANNEL_4_512_BYTES                0x00000001 /* RW--V */
#define NV_PFIFO_SIZE_CHANNEL_5                                 5:5 /* RWIVF */
#define NV_PFIFO_SIZE_CHANNEL_5_124_BYTES                0x00000000 /* RWI-V */
#define NV_PFIFO_SIZE_CHANNEL_5_512_BYTES                0x00000001 /* RW--V */
#define NV_PFIFO_SIZE_CHANNEL_6                                 6:6 /* RWIVF */
#define NV_PFIFO_SIZE_CHANNEL_6_124_BYTES                0x00000000 /* RWI-V */
#define NV_PFIFO_SIZE_CHANNEL_6_512_BYTES                0x00000001 /* RW--V */
#define NV_PFIFO_SIZE_CHANNEL_7                                 7:7 /* RWIVF */
#define NV_PFIFO_SIZE_CHANNEL_7_124_BYTES                0x00000000 /* RWI-V */
#define NV_PFIFO_SIZE_CHANNEL_7_512_BYTES                0x00000001 /* RW--V */
#define NV_PFIFO_SIZE_CHANNEL_8                                 8:8 /* RWIVF */
#define NV_PFIFO_SIZE_CHANNEL_8_124_BYTES                0x00000000 /* RWI-V */
#define NV_PFIFO_SIZE_CHANNEL_8_512_BYTES                0x00000001 /* RW--V */
#define NV_PFIFO_SIZE_CHANNEL_9                                 9:9 /* RWIVF */
#define NV_PFIFO_SIZE_CHANNEL_9_124_BYTES                0x00000000 /* RWI-V */
#define NV_PFIFO_SIZE_CHANNEL_9_512_BYTES                0x00000001 /* RW--V */
#define NV_PFIFO_SIZE_CHANNEL_10                              10:10 /* RWIVF */
#define NV_PFIFO_SIZE_CHANNEL_10_124_BYTES               0x00000000 /* RWI-V */
#define NV_PFIFO_SIZE_CHANNEL_10_512_BYTES               0x00000001 /* RW--V */
#define NV_PFIFO_SIZE_CHANNEL_11                              11:11 /* RWIVF */
#define NV_PFIFO_SIZE_CHANNEL_11_124_BYTES               0x00000000 /* RWI-V */
#define NV_PFIFO_SIZE_CHANNEL_11_512_BYTES               0x00000001 /* RW--V */
#define NV_PFIFO_SIZE_CHANNEL_12                              12:12 /* RWIVF */
#define NV_PFIFO_SIZE_CHANNEL_12_124_BYTES               0x00000000 /* RWI-V */
#define NV_PFIFO_SIZE_CHANNEL_12_512_BYTES               0x00000001 /* RW--V */
#define NV_PFIFO_SIZE_CHANNEL_13                              13:13 /* RWIVF */
#define NV_PFIFO_SIZE_CHANNEL_13_124_BYTES               0x00000000 /* RWI-V */
#define NV_PFIFO_SIZE_CHANNEL_13_512_BYTES               0x00000001 /* RW--V */
#define NV_PFIFO_SIZE_CHANNEL_14                              14:14 /* RWIVF */
#define NV_PFIFO_SIZE_CHANNEL_14_124_BYTES               0x00000000 /* RWI-V */
#define NV_PFIFO_SIZE_CHANNEL_14_512_BYTES               0x00000001 /* RW--V */
#define NV_PFIFO_SIZE_CHANNEL_15                              15:15 /* RWIVF */
#define NV_PFIFO_SIZE_CHANNEL_15_124_BYTES               0x00000000 /* RWI-V */
#define NV_PFIFO_SIZE_CHANNEL_15_512_BYTES               0x00000001 /* RW--V */
#define NV_PFIFO_CACHE0_PUSH0                            0x00003000 /* RW-4R */
#define NV_PFIFO_CACHE0_PUSH0_ACCESS                            0:0 /* RWIVF */
#define NV_PFIFO_CACHE0_PUSH0_ACCESS_DISABLED            0x00000000 /* RWI-V */
#define NV_PFIFO_CACHE0_PUSH0_ACCESS_ENABLED             0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_PUSH0                            0x00003200 /* RW-4R */
#define NV_PFIFO_CACHE1_PUSH0_ACCESS                            0:0 /* RWIVF */
#define NV_PFIFO_CACHE1_PUSH0_ACCESS_DISABLED            0x00000000 /* RWI-V */
#define NV_PFIFO_CACHE1_PUSH0_ACCESS_ENABLED             0x00000001 /* RW--V */
#define NV_PFIFO_CACHE0_PUSH1                            0x00003004 /* RW-4R */
#define NV_PFIFO_CACHE0_PUSH1_CHID                              3:0 /* RWXUF */
#define NV_PFIFO_CACHE1_PUSH1                            0x00003204 /* RW-4R */
#define NV_PFIFO_CACHE1_PUSH1_CHID                              3:0 /* RWXUF */
#define NV_PFIFO_CACHE1_PUSH1_MODE                              8:8 /* RWIVF */
#define NV_PFIFO_CACHE1_PUSH1_MODE_PIO                   0x00000000 /* RWI-V */
#define NV_PFIFO_CACHE1_PUSH1_MODE_DMA                   0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_PUSH                         0x00003220 /* RW-4R */
#define NV_PFIFO_CACHE1_DMA_PUSH_ACCESS                         0:0 /* RWIVF */
#define NV_PFIFO_CACHE1_DMA_PUSH_ACCESS_DISABLED         0x00000000 /* RWI-V */
#define NV_PFIFO_CACHE1_DMA_PUSH_ACCESS_ENABLED          0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_PUSH_STATE                          4:4 /* R--VF */
#define NV_PFIFO_CACHE1_DMA_PUSH_STATE_IDLE              0x00000000 /* R---V */
#define NV_PFIFO_CACHE1_DMA_PUSH_STATE_BUSY              0x00000001 /* R---V */
#define NV_PFIFO_CACHE1_DMA_PUSH_BUFFER                         8:8 /* R--VF */
#define NV_PFIFO_CACHE1_DMA_PUSH_BUFFER_NOT_EMPTY        0x00000000 /* R---V */
#define NV_PFIFO_CACHE1_DMA_PUSH_BUFFER_EMPTY            0x00000001 /* R---V */
#define NV_PFIFO_CACHE1_DMA_PUSH_STATUS                       12:12 /* RWIVF */
#define NV_PFIFO_CACHE1_DMA_PUSH_STATUS_RUNNING          0x00000000 /* RWI-V */
#define NV_PFIFO_CACHE1_DMA_PUSH_STATUS_SUSPENDED        0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH                        0x00003224 /* RW-4R */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG                          7:3 /* RWIUF */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_8_BYTES           0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_16_BYTES          0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_24_BYTES          0x00000002 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_32_BYTES          0x00000003 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_40_BYTES          0x00000004 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_48_BYTES          0x00000005 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_56_BYTES          0x00000006 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_64_BYTES          0x00000007 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_72_BYTES          0x00000008 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_80_BYTES          0x00000009 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_88_BYTES          0x0000000A /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_96_BYTES          0x0000000B /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_104_BYTES         0x0000000C /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_112_BYTES         0x0000000D /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_120_BYTES         0x0000000E /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_128_BYTES         0x0000000F /* RWI-V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_136_BYTES         0x00000010 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_144_BYTES         0x00000011 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_152_BYTES         0x00000012 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_160_BYTES         0x00000013 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_168_BYTES         0x00000014 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_176_BYTES         0x00000015 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_184_BYTES         0x00000016 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_192_BYTES         0x00000017 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_200_BYTES         0x00000018 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_208_BYTES         0x00000019 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_216_BYTES         0x0000001A /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_224_BYTES         0x0000001B /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_232_BYTES         0x0000001C /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_240_BYTES         0x0000001D /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_248_BYTES         0x0000001E /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_256_BYTES         0x0000001F /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_SIZE                        15:13 /* RWIUF */
#define NV_PFIFO_CACHE1_DMA_FETCH_SIZE_32_BYTES          0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_SIZE_64_BYTES          0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_SIZE_96_BYTES          0x00000002 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_SIZE_128_BYTES         0x00000003 /* RWI-V */
#define NV_PFIFO_CACHE1_DMA_FETCH_SIZE_160_BYTES         0x00000004 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_SIZE_192_BYTES         0x00000005 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_SIZE_224_BYTES         0x00000006 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_SIZE_256_BYTES         0x00000007 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS                    19:16 /* RWIUF */
#define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_0             0x00000000 /* RWI-V */
#define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_1             0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_2             0x00000002 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_3             0x00000003 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_4             0x00000004 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_5             0x00000005 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_6             0x00000006 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_7             0x00000007 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_8             0x00000008 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_9             0x00000009 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_10            0x0000000A /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_11            0x0000000B /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_12            0x0000000C /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_13            0x0000000D /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_14            0x0000000E /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_15            0x0000000F /* RW--V */
#define NV_PFIFO_CACHE1_DMA_PUT                          0x00003240 /* RW-4R */
#define NV_PFIFO_CACHE1_DMA_PUT_OFFSET                         28:2 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_GET                          0x00003244 /* RW-4R */
#define NV_PFIFO_CACHE1_DMA_GET_OFFSET                         28:2 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_STATE                        0x00003228 /* RW-4R */
#define NV_PFIFO_CACHE1_DMA_STATE_METHOD                       12:2 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_STATE_SUBCHANNEL                  15:13 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_STATE_METHOD_COUNT                28:18 /* RWIUF */
#define NV_PFIFO_CACHE1_DMA_STATE_METHOD_COUNT_0         0x00000000 /* RWI-V */
#define NV_PFIFO_CACHE1_DMA_STATE_ERROR                       31:30 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_STATE_ERROR_NONE             0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_STATE_ERROR_NON_CACHE        0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_STATE_ERROR_RESERVED_CMD     0x00000002 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_STATE_ERROR_PROTECTION       0x00000003 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_INSTANCE                     0x0000322C /* RW-4R */
#define NV_PFIFO_CACHE1_DMA_INSTANCE_ADDRESS                   15:0 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_CTL                          0x00003230 /* RW-4R */
#define NV_PFIFO_CACHE1_DMA_CTL_ADJUST                         11:2 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_CTL_PAGE_TABLE                    12:12 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_CTL_PAGE_TABLE_NOT_PRESENT   0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_CTL_PAGE_TABLE_PRESENT       0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_CTL_PAGE_ENTRY                    13:13 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_CTL_PAGE_ENTRY_NOT_LINEAR    0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_CTL_PAGE_ENTRY_LINEAR        0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_CTL_TARGET_NODE                   17:16 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_CTL_TARGET_NODE_PCI          0x00000002 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_CTL_TARGET_NODE_AGP          0x00000003 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_CTL_AT_INFO                       31:31 /* RWIUF */
#define NV_PFIFO_CACHE1_DMA_CTL_AT_INFO_INVALID          0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_CTL_AT_INFO_VALID            0x00000001 /* RWI-V */
#define NV_PFIFO_CACHE1_DMA_LIMIT                        0x00003234 /* RW-4R */
#define NV_PFIFO_CACHE1_DMA_LIMIT_OFFSET                       28:2 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_TLB_TAG                      0x00003238 /* RW-4R */
#define NV_PFIFO_CACHE1_DMA_TLB_TAG_ADDRESS                   28:12 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_TLB_TAG_STATE                       0:0 /* RWIUF */
#define NV_PFIFO_CACHE1_DMA_TLB_TAG_STATE_INVALID        0x00000000 /* RWI-V */
#define NV_PFIFO_CACHE1_DMA_TLB_TAG_STATE_VALID          0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_TLB_PTE                      0x0000323C /* RW-4R */
#define NV_PFIFO_CACHE1_DMA_TLB_PTE_FRAME_ADDRESS             31:12 /* RWXUF */
#define NV_PFIFO_CACHE0_PULL0                            0x00003050 /* RW-4R */
#define NV_PFIFO_CACHE0_PULL0_ACCESS                            0:0 /* RWIVF */
#define NV_PFIFO_CACHE0_PULL0_ACCESS_DISABLED            0x00000000 /* RWI-V */
#define NV_PFIFO_CACHE0_PULL0_ACCESS_ENABLED             0x00000001 /* RW--V */
#define NV_PFIFO_CACHE0_PULL0_HASH                              4:4 /* R-XVF */
#define NV_PFIFO_CACHE0_PULL0_HASH_SUCCEEDED             0x00000000 /* R---V */
#define NV_PFIFO_CACHE0_PULL0_HASH_FAILED                0x00000001 /* R---V */
#define NV_PFIFO_CACHE0_PULL0_DEVICE                            8:8 /* R-XVF */
#define NV_PFIFO_CACHE0_PULL0_DEVICE_HARDWARE            0x00000000 /* R---V */
#define NV_PFIFO_CACHE0_PULL0_DEVICE_SOFTWARE            0x00000001 /* R---V */
#define NV_PFIFO_CACHE0_PULL0_HASH_STATE                      12:12 /* R-XVF */
#define NV_PFIFO_CACHE0_PULL0_HASH_STATE_IDLE            0x00000000 /* R---V */
#define NV_PFIFO_CACHE0_PULL0_HASH_STATE_BUSY            0x00000001 /* R---V */
#define NV_PFIFO_CACHE1_PULL0                            0x00003250 /* RW-4R */
#define NV_PFIFO_CACHE1_PULL0_ACCESS                            0:0 /* RWIVF */
#define NV_PFIFO_CACHE1_PULL0_ACCESS_DISABLED            0x00000000 /* RWI-V */
#define NV_PFIFO_CACHE1_PULL0_ACCESS_ENABLED             0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_PULL0_HASH                              4:4 /* R-XVF */
#define NV_PFIFO_CACHE1_PULL0_HASH_SUCCEEDED             0x00000000 /* R---V */
#define NV_PFIFO_CACHE1_PULL0_HASH_FAILED                0x00000001 /* R---V */
#define NV_PFIFO_CACHE1_PULL0_DEVICE                            8:8 /* R-XVF */
#define NV_PFIFO_CACHE1_PULL0_DEVICE_HARDWARE            0x00000000 /* R---V */
#define NV_PFIFO_CACHE1_PULL0_DEVICE_SOFTWARE            0x00000001 /* R---V */
#define NV_PFIFO_CACHE1_PULL0_HASH_STATE                      12:12 /* R-XVF */
#define NV_PFIFO_CACHE1_PULL0_HASH_STATE_IDLE            0x00000000 /* R---V */
#define NV_PFIFO_CACHE1_PULL0_HASH_STATE_BUSY            0x00000001 /* R---V */
#define NV_PFIFO_CACHE0_PULL1                            0x00003054 /* RW-4R */
#define NV_PFIFO_CACHE0_PULL1_ENGINE                            1:0 /* RWXUF */
#define NV_PFIFO_CACHE0_PULL1_ENGINE_SW                  0x00000000 /* RW--V */
#define NV_PFIFO_CACHE0_PULL1_ENGINE_GRAPHICS            0x00000001 /* RW--V */
#define NV_PFIFO_CACHE0_PULL1_ENGINE_DVD                 0x00000002 /* RW--V */
#define NV_PFIFO_CACHE1_PULL1                            0x00003254 /* RW-4R */
#define NV_PFIFO_CACHE1_PULL1_ENGINE                            1:0 /* RWXUF */
#define NV_PFIFO_CACHE1_PULL1_ENGINE_SW                  0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_PULL1_ENGINE_GRAPHICS            0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_PULL1_ENGINE_DVD                 0x00000002 /* RW--V */
#define NV_PFIFO_CACHE0_HASH                             0x00003058 /* RW-4R */
#define NV_PFIFO_CACHE0_HASH_INSTANCE                          15:0 /* RWXUF */
#define NV_PFIFO_CACHE0_HASH_VALID                            16:16 /* RWXVF */
#define NV_PFIFO_CACHE1_HASH                             0x00003258 /* RW-4R */
#define NV_PFIFO_CACHE1_HASH_INSTANCE                          15:0 /* RWXUF */
#define NV_PFIFO_CACHE1_HASH_VALID                            16:16 /* RWXVF */
#define NV_PFIFO_CACHE0_STATUS                           0x00003014 /* R--4R */
#define NV_PFIFO_CACHE0_STATUS_LOW_MARK                         4:4 /* R--VF */
#define NV_PFIFO_CACHE0_STATUS_LOW_MARK_NOT_EMPTY        0x00000000 /* R---V */
#define NV_PFIFO_CACHE0_STATUS_LOW_MARK_EMPTY            0x00000001 /* R---V */
#define NV_PFIFO_CACHE0_STATUS_HIGH_MARK                        8:8 /* R--VF */
#define NV_PFIFO_CACHE0_STATUS_HIGH_MARK_NOT_FULL        0x00000000 /* R---V */
#define NV_PFIFO_CACHE0_STATUS_HIGH_MARK_FULL            0x00000001 /* R---V */
#define NV_PFIFO_CACHE1_STATUS                           0x00003214 /* R--4R */
#define NV_PFIFO_CACHE1_STATUS_LOW_MARK                         4:4 /* R--VF */
#define NV_PFIFO_CACHE1_STATUS_LOW_MARK_NOT_EMPTY        0x00000000 /* R---V */
#define NV_PFIFO_CACHE1_STATUS_LOW_MARK_EMPTY            0x00000001 /* R---V */
#define NV_PFIFO_CACHE1_STATUS_HIGH_MARK                        8:8 /* R--VF */
#define NV_PFIFO_CACHE1_STATUS_HIGH_MARK_NOT_FULL        0x00000000 /* R---V */
#define NV_PFIFO_CACHE1_STATUS_HIGH_MARK_FULL            0x00000001 /* R---V */
#define NV_PFIFO_CACHE1_STATUS1                          0x00003218 /* R--4R */
#define NV_PFIFO_CACHE1_STATUS1_RANOUT                          0:0 /* R-XVF */
#define NV_PFIFO_CACHE1_STATUS1_RANOUT_FALSE             0x00000000 /* R---V */
#define NV_PFIFO_CACHE1_STATUS1_RANOUT_TRUE              0x00000001 /* R---V */
#define NV_PFIFO_CACHE0_PUT                              0x00003010 /* RW-4R */
#define NV_PFIFO_CACHE0_PUT_ADDRESS                             2:2 /* RWXUF */
#define NV_PFIFO_CACHE1_PUT                              0x00003210 /* RW-4R */
#define NV_PFIFO_CACHE1_PUT_ADDRESS                             9:2 /* RWXUF */
#define NV_PFIFO_CACHE0_GET                              0x00003070 /* RW-4R */
#define NV_PFIFO_CACHE0_GET_ADDRESS                             2:2 /* RWXUF */
#define NV_PFIFO_CACHE1_GET                              0x00003270 /* RW-4R */
#define NV_PFIFO_CACHE1_GET_ADDRESS                             9:2 /* RWXUF */
#define NV_PFIFO_CACHE0_ENGINE                           0x00003080 /* RW-4R */
#define NV_PFIFO_CACHE0_ENGINE_0                                1:0 /* RWXUF */
#define NV_PFIFO_CACHE0_ENGINE_0_SW                      0x00000000 /* RW--V */
#define NV_PFIFO_CACHE0_ENGINE_0_GRAPHICS                0x00000001 /* RW--V */
#define NV_PFIFO_CACHE0_ENGINE_0_DVD                     0x00000002 /* RW--V */
#define NV_PFIFO_CACHE0_ENGINE_1                                5:4 /* RWXUF */
#define NV_PFIFO_CACHE0_ENGINE_1_SW                      0x00000000 /* RW--V */
#define NV_PFIFO_CACHE0_ENGINE_1_GRAPHICS                0x00000001 /* RW--V */
#define NV_PFIFO_CACHE0_ENGINE_1_DVD                     0x00000002 /* RW--V */
#define NV_PFIFO_CACHE0_ENGINE_2                                9:8 /* RWXUF */
#define NV_PFIFO_CACHE0_ENGINE_2_SW                      0x00000000 /* RW--V */
#define NV_PFIFO_CACHE0_ENGINE_2_GRAPHICS                0x00000001 /* RW--V */
#define NV_PFIFO_CACHE0_ENGINE_2_DVD                     0x00000002 /* RW--V */
#define NV_PFIFO_CACHE0_ENGINE_3                              13:12 /* RWXUF */
#define NV_PFIFO_CACHE0_ENGINE_3_SW                      0x00000000 /* RW--V */
#define NV_PFIFO_CACHE0_ENGINE_3_GRAPHICS                0x00000001 /* RW--V */
#define NV_PFIFO_CACHE0_ENGINE_3_DVD                     0x00000002 /* RW--V */
#define NV_PFIFO_CACHE0_ENGINE_4                              17:16 /* RWXUF */
#define NV_PFIFO_CACHE0_ENGINE_4_SW                      0x00000000 /* RW--V */
#define NV_PFIFO_CACHE0_ENGINE_4_GRAPHICS                0x00000001 /* RW--V */
#define NV_PFIFO_CACHE0_ENGINE_4_DVD                     0x00000002 /* RW--V */
#define NV_PFIFO_CACHE0_ENGINE_5                              21:20 /* RWXUF */
#define NV_PFIFO_CACHE0_ENGINE_5_SW                      0x00000000 /* RW--V */
#define NV_PFIFO_CACHE0_ENGINE_5_GRAPHICS                0x00000001 /* RW--V */
#define NV_PFIFO_CACHE0_ENGINE_5_DVD                     0x00000002 /* RW--V */
#define NV_PFIFO_CACHE0_ENGINE_6                              25:24 /* RWXUF */
#define NV_PFIFO_CACHE0_ENGINE_6_SW                      0x00000000 /* RW--V */
#define NV_PFIFO_CACHE0_ENGINE_6_GRAPHICS                0x00000001 /* RW--V */
#define NV_PFIFO_CACHE0_ENGINE_6_DVD                     0x00000002 /* RW--V */
#define NV_PFIFO_CACHE0_ENGINE_7                              29:28 /* RWXUF */
#define NV_PFIFO_CACHE0_ENGINE_7_SW                      0x00000000 /* RW--V */
#define NV_PFIFO_CACHE0_ENGINE_7_GRAPHICS                0x00000001 /* RW--V */
#define NV_PFIFO_CACHE0_ENGINE_7_DVD                     0x00000002 /* RW--V */
#define NV_PFIFO_CACHE1_ENGINE                           0x00003280 /* RW-4R */
#define NV_PFIFO_CACHE1_ENGINE_0                                1:0 /* RWXUF */
#define NV_PFIFO_CACHE1_ENGINE_0_SW                      0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_ENGINE_0_GRAPHICS                0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_ENGINE_0_DVD                     0x00000002 /* RW--V */
#define NV_PFIFO_CACHE1_ENGINE_1                                5:4 /* RWXUF */
#define NV_PFIFO_CACHE1_ENGINE_1_SW                      0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_ENGINE_1_GRAPHICS                0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_ENGINE_1_DVD                     0x00000002 /* RW--V */
#define NV_PFIFO_CACHE1_ENGINE_2                                9:8 /* RWXUF */
#define NV_PFIFO_CACHE1_ENGINE_2_SW                      0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_ENGINE_2_GRAPHICS                0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_ENGINE_2_DVD                     0x00000002 /* RW--V */
#define NV_PFIFO_CACHE1_ENGINE_3                              13:12 /* RWXUF */
#define NV_PFIFO_CACHE1_ENGINE_3_SW                      0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_ENGINE_3_GRAPHICS                0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_ENGINE_3_DVD                     0x00000002 /* RW--V */
#define NV_PFIFO_CACHE1_ENGINE_4                              17:16 /* RWXUF */
#define NV_PFIFO_CACHE1_ENGINE_4_SW                      0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_ENGINE_4_GRAPHICS                0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_ENGINE_4_DVD                     0x00000002 /* RW--V */
#define NV_PFIFO_CACHE1_ENGINE_5                              21:20 /* RWXUF */
#define NV_PFIFO_CACHE1_ENGINE_5_SW                      0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_ENGINE_5_GRAPHICS                0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_ENGINE_5_DVD                     0x00000002 /* RW--V */
#define NV_PFIFO_CACHE1_ENGINE_6                              25:24 /* RWXUF */
#define NV_PFIFO_CACHE1_ENGINE_6_SW                      0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_ENGINE_6_GRAPHICS                0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_ENGINE_6_DVD                     0x00000002 /* RW--V */
#define NV_PFIFO_CACHE1_ENGINE_7                              29:28 /* RWXUF */
#define NV_PFIFO_CACHE1_ENGINE_7_SW                      0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_ENGINE_7_GRAPHICS                0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_ENGINE_7_DVD                     0x00000002 /* RW--V */
#define NV_PFIFO_CACHE0_METHOD(i)                (0x00003100+(i)*8) /* RW-4A */
#define NV_PFIFO_CACHE0_METHOD__SIZE_1                            1 /*       */
#define NV_PFIFO_CACHE0_METHOD_ADDRESS                         12:2 /* RWXUF */
#define NV_PFIFO_CACHE0_METHOD_SUBCHANNEL                     15:13 /* RWXUF */
#define NV_PFIFO_CACHE1_METHOD(i)                (0x00003800+(i)*8) /* RW-4A */
#define NV_PFIFO_CACHE1_METHOD__SIZE_1                          128 /*       */
#define NV_PFIFO_CACHE1_METHOD_ADDRESS                         12:2 /* RWXUF */
#define NV_PFIFO_CACHE1_METHOD_SUBCHANNEL                     15:13 /* RWXUF */
#define NV_PFIFO_CACHE1_METHOD_ALIAS(i)          (0x00003C00+(i)*8) /* RW-4A */
#define NV_PFIFO_CACHE1_METHOD_ALIAS__SIZE_1                    128 /*       */
#define NV_PFIFO_CACHE0_DATA(i)                  (0x00003104+(i)*8) /* RW-4A */
#define NV_PFIFO_CACHE0_DATA__SIZE_1                              1 /*       */
#define NV_PFIFO_CACHE0_DATA_VALUE                             31:0 /* RWXVF */
#define NV_PFIFO_CACHE1_DATA(i)                  (0x00003804+(i)*8) /* RW-4A */
#define NV_PFIFO_CACHE1_DATA__SIZE_1                            128 /*       */
#define NV_PFIFO_CACHE1_DATA_VALUE                             31:0 /* RWXVF */
#define NV_PFIFO_CACHE1_DATA_ALIAS(i)            (0x00003C04+(i)*8) /* RW-4A */
#define NV_PFIFO_CACHE1_DATA_ALIAS__SIZE_1                      128 /*       */
#define NV_PFIFO_DEVICE(i)                       (0x00002800+(i)*4) /* R--4A */
#define NV_PFIFO_DEVICE__SIZE_1                                 128 /*       */
#define NV_PFIFO_DEVICE_CHID                                    3:0 /* R--UF */
#define NV_PFIFO_DEVICE_SWITCH                                24:24 /* R--VF */
#define NV_PFIFO_DEVICE_SWITCH_UNAVAILABLE               0x00000000 /* R---V */
#define NV_PFIFO_DEVICE_SWITCH_AVAILABLE                 0x00000001 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS                           0x00002400 /* R--4R */
#define NV_PFIFO_RUNOUT_STATUS_RANOUT                           0:0 /* R--VF */
#define NV_PFIFO_RUNOUT_STATUS_RANOUT_FALSE              0x00000000 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS_RANOUT_TRUE               0x00000001 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS_LOW_MARK                         4:4 /* R--VF */
#define NV_PFIFO_RUNOUT_STATUS_LOW_MARK_NOT_EMPTY        0x00000000 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS_LOW_MARK_EMPTY            0x00000001 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS_HIGH_MARK                        8:8 /* R--VF */
#define NV_PFIFO_RUNOUT_STATUS_HIGH_MARK_NOT_FULL        0x00000000 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS_HIGH_MARK_FULL            0x00000001 /* R---V */
#define NV_PFIFO_RUNOUT_PUT                              0x00002410 /* RW-4R */
#define NV_PFIFO_RUNOUT_PUT_ADDRESS                            12:3 /* RWXUF */
#define NV_PFIFO_RUNOUT_PUT_ADDRESS__SIZE_0                     8:3 /* RWXUF */
#define NV_PFIFO_RUNOUT_PUT_ADDRESS__SIZE_1                    12:3 /* RWXUF */
#define NV_PFIFO_RUNOUT_GET                              0x00002420 /* RW-4R */
#define NV_PFIFO_RUNOUT_GET_ADDRESS                            13:3 /* RWXUF */
/* dev_graphics.ref */
#define NV_PGRAPH                             0x00401FFF:0x00400000 /* RW--D */
#define NV_PGRAPH_DEBUG_0                                0x00400080 /* RW-4R */
#define NV_PGRAPH_DEBUG_0_STATE                                 0:0 /* CWIVF */
#define NV_PGRAPH_DEBUG_0_STATE_NORMAL                   0x00000000 /* CWI-V */
#define NV_PGRAPH_DEBUG_0_STATE_RESET                    0x00000001 /* -W--T */
#define NV_PGRAPH_DEBUG_0_FE_STATE                              1:1 /* CWIVF */
#define NV_PGRAPH_DEBUG_0_FE_STATE_NORMAL                0x00000000 /* CWI-V */
#define NV_PGRAPH_DEBUG_0_FE_STATE_RESET                 0x00000001 /* -W--T */
#define NV_PGRAPH_DEBUG_0_CACHE_STATE                           2:2 /* CWIVF */
#define NV_PGRAPH_DEBUG_0_CACHE_STATE_NORMAL             0x00000000 /* CWI-V */
#define NV_PGRAPH_DEBUG_0_CACHE_STATE_RESET              0x00000001 /* -W--T */
#define NV_PGRAPH_DEBUG_0_D3D_PIPE_STATE                        3:3 /* CWIVF */
#define NV_PGRAPH_DEBUG_0_D3D_PIPE_STATE_NORMAL          0x00000000 /* CWI-V */
#define NV_PGRAPH_DEBUG_0_D3D_PIPE_STATE_RESET           0x00000001 /* -W--T */
#define NV_PGRAPH_DEBUG_0_PREROP_STATE                          4:4 /* CWIVF */
#define NV_PGRAPH_DEBUG_0_PREROP_STATE_NORMAL            0x00000000 /* CWI-V */
#define NV_PGRAPH_DEBUG_0_PREROP_STATE_RESET             0x00000001 /* -W--T */
#define NV_PGRAPH_DEBUG_0_ROP_STATE                             5:5 /* CWIVF */
#define NV_PGRAPH_DEBUG_0_ROP_STATE_NORMAL               0x00000000 /* CWI-V */
#define NV_PGRAPH_DEBUG_0_ROP_STATE_RESET                0x00000001 /* -W--T */
#define NV_PGRAPH_DEBUG_0_RSTR_STATE                            6:6 /* CWIVF */
#define NV_PGRAPH_DEBUG_0_RSTR_STATE_NORMAL              0x00000000 /* CWI-V */
#define NV_PGRAPH_DEBUG_0_RSTR_STATE_RESET               0x00000001 /* -W--T */
#define NV_PGRAPH_DEBUG_0_LIGHT_STATE                           7:7 /* CWIVF */
#define NV_PGRAPH_DEBUG_0_LIGHT_STATE_NORMAL             0x00000000 /* CWI-V */
#define NV_PGRAPH_DEBUG_0_LIGHT_STATE_RESET              0x00000001 /* -W--T */
#define NV_PGRAPH_DEBUG_0_DMA_STATE                             8:8 /* CWIVF */
#define NV_PGRAPH_DEBUG_0_DMA_STATE_NORMAL               0x00000000 /* CWI-V */
#define NV_PGRAPH_DEBUG_0_DMA_STATE_RESET                0x00000001 /* -W--T */
#define NV_PGRAPH_DEBUG_0_SPARE1                              12:12 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_SPARE1_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_SPARE1_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_SPARE2                              13:13 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_SPARE2_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_SPARE2_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_MINUSD5                             14:14 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_MINUSD5_DISABLED               0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_MINUSD5_ENABLED                0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_BLIT_DST_LIMIT                      15:15 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_BLIT_DST_LIMIT_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_BLIT_DST_LIMIT_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_LIMIT_CHECK                         16:16 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_LIMIT_CHECK_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_LIMIT_CHECK_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_LIMIT_INT                           17:17 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_LIMIT_INT_DISABLED             0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_LIMIT_INT_ENABLED              0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_OVRFLW_INT                          18:18 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_OVRFLW_INT_DISABLED            0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_OVRFLW_INT_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS_2D                  20:20 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS_2D_DISABLED    0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS_2D_ENABLED     0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS_3D                  21:21 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS_3D_DISABLED    0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS_3D_ENABLED     0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_DRAWDIR_AUTO                        24:24 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_DRAWDIR_AUTO_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_DRAWDIR_AUTO_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_DRAWDIR_Y                           25:25 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_DRAWDIR_Y_DECR                 0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_DRAWDIR_Y_INCR                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_ALPHA_ABORT                         28:28 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_ALPHA_ABORT_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_ALPHA_ABORT_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1                                0x00400084 /* RW-4R */
#define NV_PGRAPH_DEBUG_1_VOLATILE_RESET                        0:0 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_VOLATILE_RESET_NOT_LAST        0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_VOLATILE_RESET_LAST            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_DMA_ACTIVITY                          4:4 /* CWIVF */
#define NV_PGRAPH_DEBUG_1_DMA_ACTIVITY_IGNORE            0x00000000 /* CWI-V */
#define NV_PGRAPH_DEBUG_1_DMA_ACTIVITY_CANCEL            0x00000001 /* -W--T */
#define NV_PGRAPH_DEBUG_1_PATCH_INV                             8:8 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_PATCH_INV_DISABLED             0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_PATCH_INV_ENABLED              0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_TRI_OPTS                            12:12 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_TRI_OPTS_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_TRI_OPTS_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_TRICLIP_OPTS                        13:13 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_TRICLIP_OPTS_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_TRICLIP_OPTS_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_INSTANCE                            16:16 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_INSTANCE_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_INSTANCE_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_CTX                                 20:20 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_CTX_DISABLED                   0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_CTX_ENABLED                    0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_CACHE                               24:24 /* CWIVF */
#define NV_PGRAPH_DEBUG_1_CACHE_IGNORE                   0x00000000 /* CWI-V */
#define NV_PGRAPH_DEBUG_1_CACHE_FLUSH                    0x00000001 /* -W--T */
#define NV_PGRAPH_DEBUG_1_CACHE_MODE                          25:25 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_CACHE_MODE_DISABLED            0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_CACHE_MODE_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_ZCLAMP                              28:28 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_ZCLAMP_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_ZCLAMP_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_UCLAMP                              29:29 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_UCLAMP_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_UCLAMP_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_RCLAMP                              30:30 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_RCLAMP_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_RCLAMP_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2                                0x00400088 /* RW-4R */
#define NV_PGRAPH_DEBUG_2_PINGPONG                              0:0 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_PINGPONG_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_PINGPONG_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_SPARE1                                4:4 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_SPARE1_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_SPARE1_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_SPARE2                                5:5 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_SPARE2_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_SPARE2_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_SPARE3                                6:6 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_SPARE3_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_SPARE3_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_SPARE4                                7:7 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_SPARE4_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_SPARE4_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_SPARE5                                8:8 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_SPARE5_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_SPARE5_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_SPARE6                                9:9 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_SPARE6_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_SPARE6_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_SPARE7                              10:10 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_SPARE7_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_SPARE7_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_SPARE8                              11:11 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_SPARE8_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_SPARE8_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_BILINEAR_3D                         12:12 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_BILINEAR_3D_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_BILINEAR_3D_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_ANISOTROPIC_3D                      13:13 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_ANISOTROPIC_3D_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_ANISOTROPIC_3D_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_FOG_3D                              14:14 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_FOG_3D_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_FOG_3D_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_SPECULAR_3D                         15:15 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_SPECULAR_3D_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_SPECULAR_3D_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_ALPHA_3D                            16:16 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_ALPHA_3D_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_ALPHA_3D_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_ZBUF_SEQ                            18:17 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_ZBUF_SEQ_CRZRWCW               0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_ZBUF_SEQ_ZRWCRW                0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_ZBUF_SEQ_AUTO                  0x00000002 /* RW--V */
#define NV_PGRAPH_DEBUG_2_COELESCE_D3D                        20:20 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_COELESCE_D3D_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_COELESCE_D3D_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_COELESCE_2D                         22:22 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_COELESCE_2D_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_COELESCE_2D_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_FAST_VERTEX_LOAD                    23:23 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_FAST_VERTEX_LOAD1_DISABLED     0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_FAST_VERTEX_LOAD_ENABLED       0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_BLIT_MULTILINE                      24:24 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_BLIT_MULTILINE_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_BLIT_MULTILINE_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_VOLATILE_RESET                      28:28 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_VOLATILE_RESET_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_VOLATILE_RESET_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3                                0x0040008C /* RW-4R */
#define NV_PGRAPH_DEBUG_3_CULLING                               0:0 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_CULLING_DISABLED               0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_CULLING_ENABLED                0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_CULLING_TYPE                          1:1 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_CULLING_TYPE_DX3               0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_CULLING_TYPE_DX5               0x00000001 /* RW--V */  
#define NV_PGRAPH_DEBUG_3_FAST_DATA_STRTCH                      4:4 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_FAST_DATA_STRTCH_DISABLED      0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_FAST_DATA_STRTCH_ENABLED       0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_FAST_DATA_D3D                         5:5 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_FAST_DATA_D3D_DISABLED         0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_FAST_DATA_D3D_ENABLED          0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_ZFLUSH                                7:7 /* CWIVF */
#define NV_PGRAPH_DEBUG_3_ZFLUSH_IGNORE                  0x00000000 /* CWI-V */
#define NV_PGRAPH_DEBUG_3_ZFLUSH_ACTIVATE                0x00000001 /* -W--T */
#define NV_PGRAPH_DEBUG_3_AUTOZFLUSH_PTZ                        8:8 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_AUTOZFLUSH_PTZ_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_AUTOZFLUSH_PTZ_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_AUTOZFLUSH_D3D                        9:9 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_AUTOZFLUSH_D3D_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_AUTOZFLUSH_D3D_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_SLOT_CONFLICT_PTZ                   10:10 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_SLOT_CONFLICT_PTZ_DISABLED     0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_SLOT_CONFLICT_PTZ_ENABLED      0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_SLOT_CONFLICT_D3D                   11:11 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_SLOT_CONFLICT_D3D_DISABLED     0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_SLOT_CONFLICT_D3D_ENABLED      0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_POSTDITHER_2D                       12:12 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_POSTDITHER_2D_DISABLED         0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_POSTDITHER_2D_ENABLED          0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_POSTDITHER_3D                       13:13 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_POSTDITHER_3D_DISABLED         0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_POSTDITHER_3D_ENABLED          0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_PREDITHER_2D                        14:14 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_PREDITHER_2D_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_PREDITHER_2D_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_PREDITHER_3D                        15:15 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_PREDITHER_3D_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_PREDITHER_3D_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_FORCE_CREAD                         16:16 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_FORCE_CREAD_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_FORCE_CREAD_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_FORCE_ZREAD                         17:17 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_FORCE_ZREAD_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_FORCE_ZREAD_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_EARLYZ_ABORT                        18:18 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_EARLYZ_ABORT_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_EARLYZ_ABORT_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_TRIEND_FLUSH                        19:19 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_TRIEND_FLUSH_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_TRIEND_FLUSH_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_DATA_CHECK                          20:20 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_DATA_CHECK_DISABLED            0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_DATA_CHECK_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_DATA_CHECK_FAIL                     21:21 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_DATA_CHECK_FAIL_DISABLED       0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_DATA_CHECK_FAIL_ENABLED        0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_FORMAT_CHECK                        22:22 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_FORMAT_CHECK_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_FORMAT_CHECK_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_DMA_CHECK                           23:23 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_DMA_CHECK_DISABLED             0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_DMA_CHECK_ENABLED              0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_RAMREADBACK                         24:24 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_RAMREADBACK_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_RAMREADBACK_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_STATE_CHECK                         28:28 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_STATE_CHECK_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_STATE_CHECK_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_INTR                                   0x00400100 /* RW-4R */
#define NV_PGRAPH_INTR_NOTIFY                                   0:0 /* RWIVF */
#define NV_PGRAPH_INTR_NOTIFY_NOT_PENDING                0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_NOTIFY_PENDING                    0x00000001 /* R---V */
#define NV_PGRAPH_INTR_NOTIFY_RESET                      0x00000001 /* -W--C */
#define NV_PGRAPH_INTR_MISSING_HW                               4:4 /* RWIVF */
#define NV_PGRAPH_INTR_MISSING_HW_NOT_PENDING            0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_MISSING_HW_PENDING                0x00000001 /* R---V */
#define NV_PGRAPH_INTR_MISSING_HW_RESET                  0x00000001 /* -W--C */
#define NV_PGRAPH_INTR_TLB_PRESENT_A                            8:8 /* RWIVF */
#define NV_PGRAPH_INTR_TLB_PRESENT_A_NOT_PENDING         0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_TLB_PRESENT_A_PENDING             0x00000001 /* R---V */
#define NV_PGRAPH_INTR_TLB_PRESENT_A_RESET               0x00000001 /* -W--C */
#define NV_PGRAPH_INTR_TLB_PRESENT_B                            9:9 /* RWIVF */
#define NV_PGRAPH_INTR_TLB_PRESENT_B_NOT_PENDING         0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_TLB_PRESENT_B_PENDING             0x00000001 /* R---V */
#define NV_PGRAPH_INTR_TLB_PRESENT_B_RESET               0x00000001 /* -W--C */
#define NV_PGRAPH_INTR_CONTEXT_SWITCH                         12:12 /* RWIVF */
#define NV_PGRAPH_INTR_CONTEXT_SWITCH_NOT_PENDING        0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_CONTEXT_SWITCH_PENDING            0x00000001 /* R---V */
#define NV_PGRAPH_INTR_CONTEXT_SWITCH_RESET              0x00000001 /* -W--C */
#define NV_PGRAPH_INTR_BUFFER_NOTIFY                          16:16 /* RWIVF */
#define NV_PGRAPH_INTR_BUFFER_NOTIFY_NOT_PENDING         0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_BUFFER_NOTIFY_PENDING             0x00000001 /* R---V */
#define NV_PGRAPH_INTR_BUFFER_NOTIFY_RESET               0x00000001 /* -W--C */
#define NV_PGRAPH_NSTATUS                                0x00400104 /* RW-4R */
#define NV_PGRAPH_NSTATUS_STATE_IN_USE                        11:11 /* RWIVF */
#define NV_PGRAPH_NSTATUS_STATE_IN_USE_NOT_PENDING       0x00000000 /* RWI-V */
#define NV_PGRAPH_NSTATUS_STATE_IN_USE_PENDING           0x00000001 /* RW--V */
#define NV_PGRAPH_NSTATUS_INVALID_STATE                       12:12 /* RWIVF */
#define NV_PGRAPH_NSTATUS_INVALID_STATE_NOT_PENDING      0x00000000 /* RWI-V */
#define NV_PGRAPH_NSTATUS_INVALID_STATE_PENDING          0x00000001 /* RW--V */
#define NV_PGRAPH_NSTATUS_BAD_ARGUMENT                        13:13 /* RWIVF */
#define NV_PGRAPH_NSTATUS_BAD_ARGUMENT_NOT_PENDING       0x00000000 /* RWI-V */
#define NV_PGRAPH_NSTATUS_BAD_ARGUMENT_PENDING           0x00000001 /* RW--V */
#define NV_PGRAPH_NSTATUS_PROTECTION_FAULT                    14:14 /* RWIVF */
#define NV_PGRAPH_NSTATUS_PROTECTION_FAULT_NOT_PENDING   0x00000000 /* RWI-V */
#define NV_PGRAPH_NSTATUS_PROTECTION_FAULT_PENDING       0x00000001 /* RW--V */
#define NV_PGRAPH_NSOURCE                                0x00400108 /* R--4R */
#define NV_PGRAPH_NSOURCE_NOTIFICATION                          0:0 /* R-IVF */
#define NV_PGRAPH_NSOURCE_NOTIFICATION_NOT_PENDING       0x00000000 /* R-I-V */
#define NV_PGRAPH_NSOURCE_NOTIFICATION_PENDING           0x00000001 /* R---V */
#define NV_PGRAPH_NSOURCE_DATA_ERROR                            1:1 /* R-IVF */
#define NV_PGRAPH_NSOURCE_DATA_ERROR_NOT_PENDING         0x00000000 /* R-I-V */
#define NV_PGRAPH_NSOURCE_DATA_ERROR_PENDING             0x00000001 /* R---V */
#define NV_PGRAPH_NSOURCE_PROTECTION_ERROR                      2:2 /* R-IVF */
#define NV_PGRAPH_NSOURCE_PROTECTION_ERROR_NOT_PENDING   0x00000000 /* R-I-V */
#define NV_PGRAPH_NSOURCE_PROTECTION_ERROR_PENDING       0x00000001 /* R---V */
#define NV_PGRAPH_NSOURCE_RANGE_EXCEPTION                       3:3 /* R-IVF */
#define NV_PGRAPH_NSOURCE_RANGE_EXCEPTION_NOT_PENDING    0x00000000 /* R-I-V */
#define NV_PGRAPH_NSOURCE_RANGE_EXCEPTION_PENDING        0x00000001 /* R---V */
#define NV_PGRAPH_NSOURCE_LIMIT_COLOR                           4:4 /* R-IVF */
#define NV_PGRAPH_NSOURCE_LIMIT_COLOR_NOT_PENDING        0x00000000 /* R-I-V */
#define NV_PGRAPH_NSOURCE_LIMIT_COLOR_PENDING            0x00000001 /* R---V */
#define NV_PGRAPH_NSOURCE_LIMIT_ZETA_                           5:5 /* R-IVF */
#define NV_PGRAPH_NSOURCE_LIMIT_ZETA_NOT_PENDING         0x00000000 /* R-I-V */
#define NV_PGRAPH_NSOURCE_LIMIT_ZETA_PENDING             0x00000001 /* R---V */
#define NV_PGRAPH_NSOURCE_ILLEGAL_MTHD                          6:6 /* R-IVF */
#define NV_PGRAPH_NSOURCE_ILLEGAL_MTHD_NOT_PENDING       0x00000000 /* R-I-V */
#define NV_PGRAPH_NSOURCE_ILLEGAL_MTHD_PENDING           0x00000001 /* R---V */
#define NV_PGRAPH_NSOURCE_DMA_R_PROTECTION                      7:7 /* R-IVF */
#define NV_PGRAPH_NSOURCE_DMA_R_PROTECTION_NOT_PENDING   0x00000000 /* R-I-V */
#define NV_PGRAPH_NSOURCE_DMA_R_PROTECTION_PENDING       0x00000001 /* R---V */
#define NV_PGRAPH_NSOURCE_DMA_W_PROTECTION                      8:8 /* R-IVF */
#define NV_PGRAPH_NSOURCE_DMA_W_PROTECTION_NOT_PENDING   0x00000000 /* R-I-V */
#define NV_PGRAPH_NSOURCE_DMA_W_PROTECTION_PENDING       0x00000001 /* R---V */
#define NV_PGRAPH_NSOURCE_FORMAT_EXCEPTION                      9:9 /* R-IVF */
#define NV_PGRAPH_NSOURCE_FORMAT_EXCEPTION_NOT_PENDING   0x00000000 /* R-I-V */
#define NV_PGRAPH_NSOURCE_FORMAT_EXCEPTION_PENDING       0x00000001 /* R---V */
#define NV_PGRAPH_NSOURCE_PATCH_EXCEPTION                     10:10 /* R-IVF */
#define NV_PGRAPH_NSOURCE_PATCH_EXCEPTION_NOT_PENDING    0x00000000 /* R-I-V */
#define NV_PGRAPH_NSOURCE_PATCH_EXCEPTION_PENDING        0x00000001 /* R---V */
#define NV_PGRAPH_NSOURCE_STATE_INVALID                       11:11 /* R-IVF */
#define NV_PGRAPH_NSOURCE_STATE_INVALID_NOT_PENDING      0x00000000 /* R-I-V */
#define NV_PGRAPH_NSOURCE_STATE_INVALID_PENDING          0x00000001 /* R---V */
#define NV_PGRAPH_NSOURCE_DOUBLE_NOTIFY                       12:12 /* R-IVF */
#define NV_PGRAPH_NSOURCE_DOUBLE_NOTIFY_NOT_PENDING      0x00000000 /* R-I-V */
#define NV_PGRAPH_NSOURCE_DOUBLE_NOTIFY_PENDING          0x00000001 /* R---V */
#define NV_PGRAPH_NSOURCE_NOTIFY_IN_USE                       13:13 /* R-IVF */
#define NV_PGRAPH_NSOURCE_NOTIFY_IN_USE_NOT_PENDING      0x00000000 /* R-I-V */
#define NV_PGRAPH_NSOURCE_NOTIFY_IN_USE_PENDING          0x00000001 /* R---V */
#define NV_PGRAPH_NSOURCE_METHOD_CNT                          14:14 /* R-IVF */
#define NV_PGRAPH_NSOURCE_METHOD_CNT_NOT_PENDING         0x00000000 /* R-I-V */
#define NV_PGRAPH_NSOURCE_METHOD_CNT_PENDING             0x00000001 /* R---V */
#define NV_PGRAPH_NSOURCE_BFR_NOTIFICATION                    15:15 /* R-IVF */
#define NV_PGRAPH_NSOURCE_BFR_NOTIFICATION_NOT_PENDING   0x00000000 /* R-I-V */
#define NV_PGRAPH_NSOURCE_BFR_NOTIFICATION_PENDING       0x00000001 /* R---V */
#define NV_PGRAPH_INTR_EN                                0x00400140 /* RW-4R */
#define NV_PGRAPH_INTR_EN_NOTIFY                                0:0 /* RWIVF */
#define NV_PGRAPH_INTR_EN_NOTIFY_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_NOTIFY_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_MISSING_HW                            4:4 /* RWIVF */
#define NV_PGRAPH_INTR_EN_MISSING_HW_DISABLED            0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_MISSING_HW_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_TLB_PRESENT_A                         8:8 /* RWIVF */
#define NV_PGRAPH_INTR_EN_TLB_PRESENT_A_DISABLED         0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_TLB_PRESENT_A_ENABLED          0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_TLB_PRESENT_B                         9:9 /* RWIVF */
#define NV_PGRAPH_INTR_EN_TLB_PRESENT_B_DISABLED         0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_TLB_PRESENT_B_ENABLED          0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_CONTEXT_SWITCH                      12:12 /* RWIVF */
#define NV_PGRAPH_INTR_EN_CONTEXT_SWITCH_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_CONTEXT_SWITCH_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_BUFFER_NOTIFY                       16:16 /* RWIVF */
#define NV_PGRAPH_INTR_EN_BUFFER_NOTIFY_DISABLED         0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_BUFFER_NOTIFY_ENABLED          0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH1                            0x00400160 /* RW-4R */
#define NV_PGRAPH_CTX_SWITCH1_GRCLASS                           7:0 /* RWXVF */
#define NV_PGRAPH_CTX_SWITCH1_CHROMA_KEY                      12:12 /* RWXUF */
#define NV_PGRAPH_CTX_SWITCH1_CHROMA_KEY_DISABLE         0x00000000 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH1_CHROMA_KEY_ENABLE          0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH1_USER_CLIP                       13:13 /* RWXUF */
#define NV_PGRAPH_CTX_SWITCH1_USER_CLIP_DISABLE          0x00000000 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH1_USER_CLIP_ENABLE           0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH1_SWIZZLE                         14:14 /* RWXUF */
#define NV_PGRAPH_CTX_SWITCH1_SWIZZLE_DISABLE            0x00000000 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH1_SWIZZLE_ENABLE             0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG                    17:15 /* RWXUF */
#define NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG_SRCCOPY_AND   0x00000000 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG_ROP_AND       0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG_BLEND_AND     0x00000002 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG_SRCCOPY       0x00000003 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG_SRCCOPY_PRE   0x00000004 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG_BLEND_PRE     0x00000005 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH1_PATCH_STATUS                    24:24 /* RWXUF */
#define NV_PGRAPH_CTX_SWITCH1_PATCH_STATUS_INVALID       0x00000000 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH1_PATCH_STATUS_VALID         0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH1_CONTEXT_SURFACE                 25:25 /* RWXUF */
#define NV_PGRAPH_CTX_SWITCH1_CONTEXT_SURFACE_INVALID    0x00000000 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH1_CONTEXT_SURFACE_VALID      0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH1_VOLATILE_RESET                  31:31 /* CWIVF */
#define NV_PGRAPH_CTX_SWITCH1_VOLATILE_RESET_IGNORE      0x00000000 /* CWI-V */
#define NV_PGRAPH_CTX_SWITCH1_VOLATILE_RESET_ENABLED     0x00000001 /* -W--T */
#define NV_PGRAPH_CTX_SWITCH2                            0x00400164 /* RW-4R */
#define NV_PGRAPH_CTX_SWITCH2_MONO_FORMAT                       1:0 /* RWXUF */
#define NV_PGRAPH_CTX_SWITCH2_MONO_FORMAT_INVALID              0x00 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_MONO_FORMAT_CGA6_M1              0x01 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_MONO_FORMAT_LE_M1                0x02 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT                     13:8 /* RWXUF */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_INVALID             0x00 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_LE_Y8               0x01 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_LE_X16A8Y8          0x02 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_LE_X24Y8            0x03 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_LE_A1R5G5B5         0x06 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_LE_X1R5G5B5         0x07 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_LE_X16A1R5G5B5      0x08 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_LE_X17R5G5B5        0x09 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_LE_R5G6B5           0x0A /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_LE_A16R5G6B5        0x0B /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_LE_X16R5G6B5        0x0C /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_LE_A8R8G8B8         0x0D /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_LE_X8R8G8B8         0x0E /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_LE_Y16              0x0F /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_LE_A16Y16           0x10 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_LE_X16Y16           0x11 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_LE_V8YB8U8YA8       0x12 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_LE_YB8V8YA8U8       0x13 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_LE_Y32              0x14 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_NOTIFY_INSTANCE                 31:16 /* RWXUF */
#define NV_PGRAPH_CTX_SWITCH2_NOTIFY_INSTANCE_INVALID        0x0000 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH3                            0x00400168 /* RW-4R */
#define NV_PGRAPH_CTX_SWITCH3_DMA_INSTANCE_0                   15:0 /* RWXUF */
#define NV_PGRAPH_CTX_SWITCH3_DMA_INSTANCE_0_INVALID         0x0000 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH3_DMA_INSTANCE_1                  31:16 /* RWXUF */
#define NV_PGRAPH_CTX_SWITCH3_DMA_INSTANCE_1_INVALID         0x0000 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH4                            0x0040016C /* RW-4R */
#define NV_PGRAPH_CTX_SWITCH4_USER_INSTANCE                    15:0 /* RWXUF */
#define NV_PGRAPH_CTX_SWITCH4_USER_INSTANCE_INVALID          0x0000 /* RW--V */
#define NV_PGRAPH_CTX_CACHE1(i)                  (0x00400180+(i)*4) /* RW-4A */
#define NV_PGRAPH_CTX_CACHE1__SIZE_1                              8 /*       */
#define NV_PGRAPH_CTX_CACHE1_GRCLASS                            7:0 /* RWXVF */
#define NV_PGRAPH_CTX_CACHE1_CHROMA_KEY                       12:12 /* RWXVF */
#define NV_PGRAPH_CTX_CACHE1_USER_CLIP                        13:13 /* RWXVF */
#define NV_PGRAPH_CTX_CACHE1_SWIZZLE                          14:14 /* RWXVF */
#define NV_PGRAPH_CTX_CACHE1_PATCH_CONFIG                     19:15 /* RWXVF */
#define NV_PGRAPH_CTX_CACHE1_SPARE1                           20:20 /* RWXVF */
#define NV_PGRAPH_CTX_CACHE1_PATCH_STATUS                     24:24 /* RWXVF */
#define NV_PGRAPH_CTX_CACHE1_CONTEXT_SURFACE                  25:25 /* RWXVF */
#define NV_PGRAPH_CTX_CACHE2(i)                  (0x004001a0+(i)*4) /* RW-4A */
#define NV_PGRAPH_CTX_CACHE2__SIZE_1                              8 /*       */
#define NV_PGRAPH_CTX_CACHE2_MONO_FORMAT                        1:0 /* RWXVF */
#define NV_PGRAPH_CTX_CACHE2_COLOR_FORMAT                      13:8 /* RWXVF */
#define NV_PGRAPH_CTX_CACHE2_NOTIFY_INSTANCE                  31:16 /* RWXVF */
#define NV_PGRAPH_CTX_CACHE3(i)                  (0x004001c0+(i)*4) /* RW-4A */
#define NV_PGRAPH_CTX_CACHE3__SIZE_1                              8 /*       */
#define NV_PGRAPH_CTX_CACHE3_DMA_INSTANCE_0                    15:0 /* RWXVF */
#define NV_PGRAPH_CTX_CACHE3_DMA_INSTANCE_1                   31:16 /* RWXVF */
#define NV_PGRAPH_CTX_CACHE4(i)                  (0x004001e0+(i)*4) /* RW-4A */
#define NV_PGRAPH_CTX_CACHE4__SIZE_1                              8 /*       */
#define NV_PGRAPH_CTX_CACHE4_USER_INSTANCE                     15:0 /* RWXVF */
#define NV_PGRAPH_CTX_CONTROL                            0x00400170 /* RW-4R */
#define NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME                      1:0 /* RWIVF */
#define NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME_33US          0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME_262US         0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME_2MS           0x00000002 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME_17MS          0x00000003 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_TIME                              8:8 /* RWIVF */
#define NV_PGRAPH_CTX_CONTROL_TIME_EXPIRED               0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_CONTROL_TIME_NOT_EXPIRED           0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_CHID                            16:16 /* RWIVF */
#define NV_PGRAPH_CTX_CONTROL_CHID_INVALID               0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_CONTROL_CHID_VALID                 0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_CHANGE                          20:20 /* R--VF */
#define NV_PGRAPH_CTX_CONTROL_CHANGE_UNAVAILABLE         0x00000000 /* R---V */
#define NV_PGRAPH_CTX_CONTROL_CHANGE_AVAILABLE           0x00000001 /* R---V */
#define NV_PGRAPH_CTX_CONTROL_SWITCHING                       24:24 /* RWIVF */
#define NV_PGRAPH_CTX_CONTROL_SWITCHING_IDLE             0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_CONTROL_SWITCHING_BUSY             0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_DEVICE                          28:28 /* RWIVF */
#define NV_PGRAPH_CTX_CONTROL_DEVICE_DISABLED            0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_CONTROL_DEVICE_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_USER                               0x00400174 /* RW-4R */
#define NV_PGRAPH_CTX_USER_SUBCH                              15:13 /* RWIVF */
#define NV_PGRAPH_CTX_USER_SUBCH_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_USER_CHID                               27:24 /* RWIVF */
#define NV_PGRAPH_CTX_USER_CHID_0                        0x00000000 /* RWI-V */
#define NV_PGRAPH_FIFO                                   0x00400720 /* RW-4R */
#define NV_PGRAPH_FIFO_ACCESS                                   0:0 /* RWIVF */
#define NV_PGRAPH_FIFO_ACCESS_DISABLED                   0x00000000 /* RW--V */
#define NV_PGRAPH_FIFO_ACCESS_ENABLED                    0x00000001 /* RWI-V */
#define NV_PGRAPH_FFINTFC_FIFO_0(i)              (0x00400730+(i)*4) /* RW-4A */
#define NV_PGRAPH_FFINTFC_FIFO_0__SIZE_1                          4 /*       */
#define NV_PGRAPH_FFINTFC_FIFO_0_TAG                            0:0 /* RWXVF */
#define NV_PGRAPH_FFINTFC_FIFO_0_TAG_MTHD                0x00000000 /* RW--V */
#define NV_PGRAPH_FFINTFC_FIFO_0_TAG_CHSW                0x00000001 /* RW--V */
#define NV_PGRAPH_FFINTFC_FIFO_0_SUBCH                          3:1 /* RWXVF */
#define NV_PGRAPH_FFINTFC_FIFO_0_SUBCH_0                 0x00000000 /* RW--V */
#define NV_PGRAPH_FFINTFC_FIFO_0_SUBCH_1                 0x00000001 /* RW--V */
#define NV_PGRAPH_FFINTFC_FIFO_0_SUBCH_2                 0x00000002 /* RW--V */
#define NV_PGRAPH_FFINTFC_FIFO_0_SUBCH_3                 0x00000003 /* RW--V */
#define NV_PGRAPH_FFINTFC_FIFO_0_SUBCH_4                 0x00000004 /* RW--V */
#define NV_PGRAPH_FFINTFC_FIFO_0_SUBCH_5                 0x00000005 /* RW--V */
#define NV_PGRAPH_FFINTFC_FIFO_0_SUBCH_6                 0x00000006 /* RW--V */
#define NV_PGRAPH_FFINTFC_FIFO_0_SUBCH_7                 0x00000007 /* RW--V */
#define NV_PGRAPH_FFINTFC_FIFO_0_MTHD                          14:4 /* RWXVF */
#define NV_PGRAPH_FFINTFC_FIFO_0_MTHD_CTX_SWITCH         0x00000000 /* RW--V */
#define NV_PGRAPH_FFINTFC_FIFO_1(i)              (0x00400740+(i)*4) /* RW-4A */
#define NV_PGRAPH_FFINTFC_FIFO_1__SIZE_1                          4 /*       */
#define NV_PGRAPH_FFINTFC_FIFO_1_ARGUMENT                      31:0 /* RWXVF */
#define NV_PGRAPH_FFINTFC_FIFO_PTR                       0x00400750 /* RW-4R */
#define NV_PGRAPH_FFINTFC_FIFO_PTR_WRITE                        2:0 /* RWIVF */
#define NV_PGRAPH_FFINTFC_FIFO_PTR_WRITE_0               0x00000000 /* RWI-V */
#define NV_PGRAPH_FFINTFC_FIFO_PTR_READ                         6:4 /* RWIVF */
#define NV_PGRAPH_FFINTFC_FIFO_PTR_READ_0                0x00000000 /* RWI-V */
#define NV_PGRAPH_FFINTFC_ST2                            0x00400754 /* RW-4R */
#define NV_PGRAPH_FFINTFC_ST2_STATUS                            0:0 /* RWIVF */
#define NV_PGRAPH_FFINTFC_ST2_STATUS_INVALID             0x00000000 /* RWI-V */
#define NV_PGRAPH_FFINTFC_ST2_STATUS_VALID               0x00000001 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_MTHD                             11:1 /* RWIVF */
#define NV_PGRAPH_FFINTFC_ST2_MTHD_CTX_SWITCH            0x00000000 /* RWI-V */
#define NV_PGRAPH_FFINTFC_ST2_SUBCH                           14:12 /* RWIVF */
#define NV_PGRAPH_FFINTFC_ST2_SUBCH_0                    0x00000000 /* RWI-V */
#define NV_PGRAPH_FFINTFC_ST2_SUBCH_1                    0x00000001 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_SUBCH_2                    0x00000002 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_SUBCH_3                    0x00000003 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_SUBCH_4                    0x00000004 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_SUBCH_5                    0x00000005 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_SUBCH_6                    0x00000006 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_SUBCH_7                    0x00000007 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID                            18:15 /* RWIVF */
#define NV_PGRAPH_FFINTFC_ST2_CHID_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_1                     0x00000001 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_2                     0x00000002 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_3                     0x00000003 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_4                     0x00000004 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_5                     0x00000005 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_6                     0x00000006 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_7                     0x00000007 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_8                     0x00000008 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_9                     0x00000009 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_10                    0x0000000A /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_11                    0x0000000B /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_12                    0x0000000C /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_13                    0x0000000D /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_14                    0x0000000E /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_15                    0x0000000F /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_STATUS                     19:19 /* RWIVF */
#define NV_PGRAPH_FFINTFC_ST2_CHID_STATUS_INVALID        0x00000000 /* RWI-V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_STATUS_VALID          0x00000001 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_D                          0x00400758 /* RW-4R */
#define NV_PGRAPH_FFINTFC_ST2_D_ARGUMENT                       31:0 /* RWIVF */
#define NV_PGRAPH_FFINTFC_ST2_D_ARGUMENT_0               0x00000000 /* RWI-V */
#define NV_PGRAPH_STATUS                                 0x00400700 /* R--4R */
#define NV_PGRAPH_STATUS_STATE                                  0:0 /* R-IVF */
#define NV_PGRAPH_STATUS_STATE_IDLE                      0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_STATE_BUSY                      0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_XY_LOGIC                               4:4 /* R-IVF */
#define NV_PGRAPH_STATUS_XY_LOGIC_IDLE                   0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_XY_LOGIC_BUSY                   0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_FE                                     5:5 /* R-IVF */
#define NV_PGRAPH_STATUS_FE_IDLE                         0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_FE_BUSY                         0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_RASTERIZER                             6:6 /* R-IVF */
#define NV_PGRAPH_STATUS_RASTERIZER_IDLE                 0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_RASTERIZER_BUSY                 0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_PORT_NOTIFY                            8:8 /* R-IVF */
#define NV_PGRAPH_STATUS_PORT_NOTIFY_IDLE                0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_PORT_NOTIFY_BUSY                0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_PORT_REGISTER                        12:12 /* R-IVF */
#define NV_PGRAPH_STATUS_PORT_REGISTER_IDLE              0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_PORT_REGISTER_BUSY              0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_PORT_DMA                             16:16 /* R-IVF */
#define NV_PGRAPH_STATUS_PORT_DMA_IDLE                   0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_PORT_DMA_BUSY                   0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_DMA_ENGINE                           17:17 /* R-IVF */
#define NV_PGRAPH_STATUS_DMA_ENGINE_IDLE                 0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_DMA_ENGINE_BUSY                 0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_DMA_NOTIFY                           20:20 /* R-IVF */
#define NV_PGRAPH_STATUS_DMA_NOTIFY_IDLE                 0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_DMA_NOTIFY_BUSY                 0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_DMA_BUFFER_NOTIFY                    21:21 /* R-IVF */
#define NV_PGRAPH_STATUS_DMA_BUFFER_NOTIFY_IDLE          0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_DMA_BUFFER_NOTIFY_BUSY          0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_D3D                                  24:24 /* R-IVF */
#define NV_PGRAPH_STATUS_D3D_IDLE                        0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_D3D_BUSY                        0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_CACHE                                25:25 /* R-IVF */
#define NV_PGRAPH_STATUS_CACHE_IDLE                      0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_CACHE_BUSY                      0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_LIGHTING                             26:26 /* R-IVF */
#define NV_PGRAPH_STATUS_LIGHTING_IDLE                   0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_LIGHTING_BUSY                   0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_PREROP                               27:27 /* R-IVF */
#define NV_PGRAPH_STATUS_PREROP_IDLE                     0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_PREROP_BUSY                     0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_ROP                                  28:28 /* R-IVF */
#define NV_PGRAPH_STATUS_ROP_IDLE                        0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_ROP_BUSY                        0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_PORT_USER                            29:29 /* R-IVF */
#define NV_PGRAPH_STATUS_PORT_USER_IDLE                  0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_PORT_USER_BUSY                  0x00000001 /* R---V */
#define NV_PGRAPH_TRAPPED_ADDR                           0x00400704 /* R--4R */
#define NV_PGRAPH_TRAPPED_ADDR_MTHD                            12:2 /* R-XUF */
#define NV_PGRAPH_TRAPPED_ADDR_SUBCH                          15:13 /* R-XUF */
#define NV_PGRAPH_TRAPPED_ADDR_CHID                           27:24 /* R-XUF */
#define NV_PGRAPH_TRAPPED_DATA                           0x00400708 /* R--4R */
#define NV_PGRAPH_TRAPPED_DATA_VALUE                           31:0 /* R-XVF */
#define NV_PGRAPH_SURFACE                                0x0040070C /* RW-4R */
#define NV_PGRAPH_SURFACE_TYPE                                  1:0 /* RWIVF */
#define NV_PGRAPH_SURFACE_TYPE_INVALID                   0x00000000 /* RWI-V */
#define NV_PGRAPH_SURFACE_TYPE_NON_SWIZZLE               0x00000001 /* RW--V */
#define NV_PGRAPH_SURFACE_TYPE_SWIZZLE                   0x00000002 /* RW--V */
#define NV_PGRAPH_NOTIFY                                 0x00400714 /* RW-4R */
#define NV_PGRAPH_NOTIFY_BUFFER_REQ                             0:0 /* RWIVF */
#define NV_PGRAPH_NOTIFY_BUFFER_REQ_NOT_PENDING          0x00000000 /* RWI-V */
#define NV_PGRAPH_NOTIFY_BUFFER_REQ_PENDING              0x00000001 /* RW--V */
#define NV_PGRAPH_NOTIFY_BUFFER_STYLE                           8:8 /* RWIVF */
#define NV_PGRAPH_NOTIFY_BUFFER_STYLE_WRITE_ONLY         0x00000000 /* RWI-V */
#define NV_PGRAPH_NOTIFY_BUFFER_STYLE_WRITE_THEN_AWAKEN  0x00000001 /* RW--V */
#define NV_PGRAPH_NOTIFY_REQ                                  16:16 /* RWIVF */
#define NV_PGRAPH_NOTIFY_REQ_NOT_PENDING                 0x00000000 /* RWI-V */
#define NV_PGRAPH_NOTIFY_REQ_PENDING                     0x00000001 /* RW--V */
#define NV_PGRAPH_NOTIFY_STYLE                                20:20 /* RWIVF */
#define NV_PGRAPH_NOTIFY_STYLE_WRITE_ONLY                0x00000000 /* RWI-V */
#define NV_PGRAPH_NOTIFY_STYLE_WRITE_THEN_AWAKEN         0x00000001 /* RW--V */
#define NV_PGRAPH_BOFFSET(i)                     (0x00400640+(i)*4) /* RW-4A */
#define NV_PGRAPH_BOFFSET__SIZE_1                                 6 /*       */
#define NV_PGRAPH_BOFFSET_LINADRS                              23:0 /* RWIUF */
#define NV_PGRAPH_BOFFSET_LINADRS_0                      0x00000000 /* RWI-V */
#define NV_PGRAPH_BOFFSET0                               0x00400640 /* RW-4R */
#define NV_PGRAPH_BOFFSET0__ALIAS_1            NV_PGRAPH_BOFFSET(0) /*       */
#define NV_PGRAPH_BOFFSET0_LINADRS                             23:0 /* RWIUF */
#define NV_PGRAPH_BOFFSET0_LINADRS_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_BOFFSET1                               0x00400644 /* RW-4R */
#define NV_PGRAPH_BOFFSET1__ALIAS_1            NV_PGRAPH_BOFFSET(1) /*       */
#define NV_PGRAPH_BOFFSET1_LINADRS                             23:0 /* RWIUF */
#define NV_PGRAPH_BOFFSET1_LINADRS_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_BOFFSET2                               0x00400648 /* RW-4R */
#define NV_PGRAPH_BOFFSET2__ALIAS_1            NV_PGRAPH_BOFFSET(2) /*       */
#define NV_PGRAPH_BOFFSET2_LINADRS                             23:0 /* RWIUF */
#define NV_PGRAPH_BOFFSET2_LINADRS_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_BOFFSET3                               0x0040064C /* RW-4R */
#define NV_PGRAPH_BOFFSET3__ALIAS_1            NV_PGRAPH_BOFFSET(3) /*       */
#define NV_PGRAPH_BOFFSET3_LINADRS                             23:0 /* RWIUF */
#define NV_PGRAPH_BOFFSET3_LINADRS_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_BOFFSET4                               0x00400650 /* RW-4R */
#define NV_PGRAPH_BOFFSET4__ALIAS_1            NV_PGRAPH_BOFFSET(4) /*       */
#define NV_PGRAPH_BOFFSET4_LINADRS                             23:0 /* RWIUF */
#define NV_PGRAPH_BOFFSET4_LINADRS_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_BOFFSET5                               0x00400654 /* RW-4R */
#define NV_PGRAPH_BOFFSET5__ALIAS_1            NV_PGRAPH_BOFFSET(5) /*       */
#define NV_PGRAPH_BOFFSET5_LINADRS                             23:0 /* RWIUF */
#define NV_PGRAPH_BOFFSET5_LINADRS_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_BBASE(i)                       (0x00400658+(i)*4) /* RW-4A */
#define NV_PGRAPH_BBASE__SIZE_1                                   6 /*       */
#define NV_PGRAPH_BBASE_LINADRS                                23:0 /* RWIUF */
#define NV_PGRAPH_BBASE_LINADRS_0                        0x00000000 /* RWI-V */
#define NV_PGRAPH_BBASE0                                 0x00400658 /* RW-4R */
#define NV_PGRAPH_BBASE0__ALIAS_1                NV_PGRAPH_BBASE(0) /*       */
#define NV_PGRAPH_BBASE0_LINADRS                               23:0 /* RWIUF */
#define NV_PGRAPH_BBASE0_LINADRS_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_BBASE1                                 0x0040065c /* RW-4R */
#define NV_PGRAPH_BBASE1__ALIAS_1                NV_PGRAPH_BBASE(1) /*       */
#define NV_PGRAPH_BBASE1_LINADRS                               23:0 /* RWIUF */
#define NV_PGRAPH_BBASE1_LINADRS_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_BBASE2                                 0x00400660 /* RW-4R */
#define NV_PGRAPH_BBASE2__ALIAS_1                NV_PGRAPH_BBASE(2) /*       */
#define NV_PGRAPH_BBASE2_LINADRS                               23:0 /* RWIUF */
#define NV_PGRAPH_BBASE2_LINADRS_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_BBASE3                                 0x00400664 /* RW-4R */
#define NV_PGRAPH_BBASE3__ALIAS_1                NV_PGRAPH_BBASE(3) /*       */
#define NV_PGRAPH_BBASE3_LINADRS                               23:0 /* RWIUF */
#define NV_PGRAPH_BBASE3_LINADRS_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_BBASE4                                 0x00400668 /* RW-4R */
#define NV_PGRAPH_BBASE4__ALIAS_1                NV_PGRAPH_BBASE(4) /*       */
#define NV_PGRAPH_BBASE4_LINADRS                               23:0 /* RWIUF */
#define NV_PGRAPH_BBASE4_LINADRS_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_BBASE5                                 0x0040066C /* RW-4R */
#define NV_PGRAPH_BBASE5__ALIAS_1                NV_PGRAPH_BBASE(5) /*       */
#define NV_PGRAPH_BBASE5_LINADRS                               23:0 /* RWIUF */
#define NV_PGRAPH_BBASE5_LINADRS_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_BPITCH(i)                      (0x00400670+(i)*4) /* RW-4A */
#define NV_PGRAPH_BPITCH__SIZE_1                                  5 /*       */
#define NV_PGRAPH_BPITCH_VALUE                                 12:0 /* RWIUF */
#define NV_PGRAPH_BPITCH_VALUE_0                         0x00000000 /* RWI-V */
#define NV_PGRAPH_BPITCH0                                0x00400670 /* RW-4R */
#define NV_PGRAPH_BPITCH0__ALIAS_1              NV_PGRAPH_BPITCH(0) /*       */
#define NV_PGRAPH_BPITCH0_VALUE                                12:0 /* RWIUF */
#define NV_PGRAPH_BPITCH0_VALUE_0                        0x00000000 /* RWI-V */
#define NV_PGRAPH_BPITCH1                                0x00400674 /* RW-4R */
#define NV_PGRAPH_BPITCH1__ALIAS_1              NV_PGRAPH_BPITCH(1) /*       */
#define NV_PGRAPH_BPITCH1_VALUE                                12:0 /* RWIUF */
#define NV_PGRAPH_BPITCH1_VALUE_0                        0x00000000 /* RWI-V */
#define NV_PGRAPH_BPITCH2                                0x00400678 /* RW-4R */
#define NV_PGRAPH_BPITCH2__ALIAS_1              NV_PGRAPH_BPITCH(2) /*       */
#define NV_PGRAPH_BPITCH2_VALUE                                12:0 /* RWIUF */
#define NV_PGRAPH_BPITCH2_VALUE_0                        0x00000000 /* RWI-V */
#define NV_PGRAPH_BPITCH3                                0x0040067C /* RW-4R */
#define NV_PGRAPH_BPITCH3__ALIAS_1              NV_PGRAPH_BPITCH(3) /*       */
#define NV_PGRAPH_BPITCH3_VALUE                                12:0 /* RWIUF */
#define NV_PGRAPH_BPITCH3_VALUE_0                        0x00000000 /* RWI-V */
#define NV_PGRAPH_BPITCH4                                0x00400680 /* RW-4R */
#define NV_PGRAPH_BPITCH4__ALIAS_1              NV_PGRAPH_BPITCH(4) /*       */
#define NV_PGRAPH_BPITCH4_VALUE                                12:0 /* RWIUF */
#define NV_PGRAPH_BPITCH4_VALUE_0                        0x00000000 /* RWI-V */
#define NV_PGRAPH_BLIMIT(i)                      (0x00400684+(i)*4) /* RW-4A */
#define NV_PGRAPH_BLIMIT__SIZE_1                                  6 /*       */
#define NV_PGRAPH_BLIMIT_VALUE                                 23:0 /* RWXUF */
#define NV_PGRAPH_BLIMIT_TYPE                                 31:31 /* RWIVF */
#define NV_PGRAPH_BLIMIT_TYPE_IN_MEMORY                  0x00000000 /* RW--V */
#define NV_PGRAPH_BLIMIT_TYPE_NULL                       0x00000001 /* RWI-V */
#define NV_PGRAPH_BLIMIT0                                0x00400684 /* RW-4R */
#define NV_PGRAPH_BLIMIT0__ALIAS_1              NV_PGRAPH_BLIMIT(0) /*       */
#define NV_PGRAPH_BLIMIT0_VALUE                                23:0 /* RWXUF */
#define NV_PGRAPH_BLIMIT0_TYPE                                31:31 /* RWIVF */
#define NV_PGRAPH_BLIMIT0_TYPE_IN_MEMORY                 0x00000000 /* RW--V */
#define NV_PGRAPH_BLIMIT0_TYPE_NULL                      0x00000001 /* RWI-V */
#define NV_PGRAPH_BLIMIT1                                0x00400688 /* RW-4R */
#define NV_PGRAPH_BLIMIT1__ALIAS_1              NV_PGRAPH_BLIMIT(1) /*       */
#define NV_PGRAPH_BLIMIT1_VALUE                                23:0 /* RWXUF */
#define NV_PGRAPH_BLIMIT1_TYPE                                31:31 /* RWIVF */
#define NV_PGRAPH_BLIMIT1_TYPE_IN_MEMORY                 0x00000000 /* RW--V */
#define NV_PGRAPH_BLIMIT1_TYPE_NULL                      0x00000001 /* RWI-V */
#define NV_PGRAPH_BLIMIT2                                0x0040068c /* RW-4R */
#define NV_PGRAPH_BLIMIT2__ALIAS_1              NV_PGRAPH_BLIMIT(2) /*       */
#define NV_PGRAPH_BLIMIT2_VALUE                                23:0 /* RWXUF */
#define NV_PGRAPH_BLIMIT2_TYPE                                31:31 /* RWIVF */
#define NV_PGRAPH_BLIMIT2_TYPE_IN_MEMORY                 0x00000000 /* RW--V */
#define NV_PGRAPH_BLIMIT2_TYPE_NULL                      0x00000001 /* RWI-V */
#define NV_PGRAPH_BLIMIT3                                0x00400690 /* RW-4R */
#define NV_PGRAPH_BLIMIT3__ALIAS_1              NV_PGRAPH_BLIMIT(3) /*       */
#define NV_PGRAPH_BLIMIT3_VALUE                                23:0 /* RWXUF */
#define NV_PGRAPH_BLIMIT3_TYPE                                31:31 /* RWIVF */
#define NV_PGRAPH_BLIMIT3_TYPE_IN_MEMORY                 0x00000000 /* RW--V */
#define NV_PGRAPH_BLIMIT3_TYPE_NULL                      0x00000001 /* RWI-V */
#define NV_PGRAPH_BLIMIT4                                0x00400694 /* RW-4R */
#define NV_PGRAPH_BLIMIT4__ALIAS_1              NV_PGRAPH_BLIMIT(4) /*       */
#define NV_PGRAPH_BLIMIT4_VALUE                                23:0 /* RWXUF */
#define NV_PGRAPH_BLIMIT4_TYPE                                31:31 /* RWIVF */
#define NV_PGRAPH_BLIMIT4_TYPE_IN_MEMORY                 0x00000000 /* RW--V */
#define NV_PGRAPH_BLIMIT4_TYPE_NULL                      0x00000001 /* RWI-V */
#define NV_PGRAPH_BLIMIT5                                0x00400698 /* RW-4R */
#define NV_PGRAPH_BLIMIT5__ALIAS_1              NV_PGRAPH_BLIMIT(5) /*       */
#define NV_PGRAPH_BLIMIT5_VALUE                                23:0 /* RWXUF */
#define NV_PGRAPH_BLIMIT5_TYPE                                31:31 /* RWIVF */
#define NV_PGRAPH_BLIMIT5_TYPE_IN_MEMORY                 0x00000000 /* RW--V */
#define NV_PGRAPH_BLIMIT5_TYPE_NULL                      0x00000001 /* RWI-V */
#define NV_PGRAPH_BSWIZZLE2                              0x0040069c /* RW-4R */
#define NV_PGRAPH_BSWIZZLE2_WIDTH                             19:16 /* RWIUF */
#define NV_PGRAPH_BSWIZZLE2_WIDTH_0                      0x00000000 /* RWI-V */
#define NV_PGRAPH_BSWIZZLE2_HEIGHT                            27:24 /* RWIUF */
#define NV_PGRAPH_BSWIZZLE2_HEIGHT_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_BSWIZZLE5                              0x004006a0 /* RW-4R */
#define NV_PGRAPH_BSWIZZLE5_WIDTH                             19:16 /* RWIUF */
#define NV_PGRAPH_BSWIZZLE5_WIDTH_0                      0x00000000 /* RWI-V */
#define NV_PGRAPH_BSWIZZLE5_HEIGHT                            27:24 /* RWIUF */
#define NV_PGRAPH_BSWIZZLE5_HEIGHT_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_BPIXEL                                 0x00400724 /* RW-4R */
#define NV_PGRAPH_BPIXEL_DEPTH0                                 3:0 /* RWIVF */
#define NV_PGRAPH_BPIXEL_DEPTH0_INVALID                  0x00000000 /* RWI-V */
#define NV_PGRAPH_BPIXEL_DEPTH0_Y8                       0x00000001 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_X1R5G5B5_Z1R5G5B5        0x00000002 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_X1R5G5B5_O1R5G5B5        0x00000003 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_A1R5G5B5                 0x00000004 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_R5G6B5                   0x00000005 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_Y16                      0x00000006 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_X8R8G8B8_Z8R8G8B8        0x00000007 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_X8R8G8B8_O1Z7R8G8B8      0x00000008 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_X1A7R8G8B8_Z1A7R8G8B8    0x00000009 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_X1A7R8G8B8_O1A7R8G8B8    0x0000000a /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_X8R8G8B8_O8R8G8B8        0x0000000b /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_A8R8G8B8                 0x0000000c /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_Y32                      0x0000000d /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_V8YB8U8YA8               0x0000000e /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_YB8V8YA8U8               0x0000000f /* RW--V */ 
#define NV_PGRAPH_BPIXEL_DEPTH1                                 7:4 /* RWIVF */
#define NV_PGRAPH_BPIXEL_DEPTH1_INVALID                  0x00000000 /* RWI-V */
#define NV_PGRAPH_BPIXEL_DEPTH1_Y8                       0x00000001 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_X1R5G5B5_Z1R5G5B5        0x00000002 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_X1R5G5B5_O1R5G5B5        0x00000003 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_A1R5G5B5                 0x00000004 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_R5G6B5                   0x00000005 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_Y16                      0x00000006 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_X8R8G8B8_Z8R8G8B8        0x00000007 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_X8R8G8B8_O1Z7R8G8B8      0x00000008 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_X1A7R8G8B8_Z1A7R8G8B8    0x00000009 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_X1A7R8G8B8_O1A7R8G8B8    0x0000000a /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_X8R8G8B8_O8R8G8B8        0x0000000b /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_A8R8G8B8                 0x0000000c /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_Y32                      0x0000000d /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_V8YB8U8YA8               0x0000000e /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_YB8V8YA8U8               0x0000000f /* RW--V */ 
#define NV_PGRAPH_BPIXEL_DEPTH2                                11:8 /* RWIVF */
#define NV_PGRAPH_BPIXEL_DEPTH2_INVALID                  0x00000000 /* RWI-V */
#define NV_PGRAPH_BPIXEL_DEPTH2_Y8                       0x00000001 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_X1R5G5B5_Z1R5G5B5        0x00000002 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_X1R5G5B5_O1R5G5B5        0x00000003 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_A1R5G5B5                 0x00000004 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_R5G6B5                   0x00000005 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_Y16                      0x00000006 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_X8R8G8B8_Z8R8G8B8        0x00000007 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_X8R8G8B8_O1Z7R8G8B8      0x00000008 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_X1A7R8G8B8_Z1A7R8G8B8    0x00000009 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_X1A7R8G8B8_O1A7R8G8B8    0x0000000a /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_X8R8G8B8_O8R8G8B8        0x0000000b /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_A8R8G8B8                 0x0000000c /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_Y32                      0x0000000d /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_V8YB8U8YA8               0x0000000e /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_YB8V8YA8U8               0x0000000f /* RW--V */ 
#define NV_PGRAPH_BPIXEL_DEPTH3                               15:12 /* RWIVF */
#define NV_PGRAPH_BPIXEL_DEPTH3_INVALID                  0x00000000 /* RWI-V */
#define NV_PGRAPH_BPIXEL_DEPTH3_Y8                       0x00000001 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_X1R5G5B5_Z1R5G5B5        0x00000002 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_X1R5G5B5_O1R5G5B5        0x00000003 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_A1R5G5B5                 0x00000004 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_R5G6B5                   0x00000005 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_Y16                      0x00000006 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_X8R8G8B8_Z8R8G8B8        0x00000007 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_X8R8G8B8_O1Z7R8G8B8      0x00000008 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_X1A7R8G8B8_Z1A7R8G8B8    0x00000009 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_X1A7R8G8B8_O1A7R8G8B8    0x0000000a /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_X8R8G8B8_O8R8G8B8        0x0000000b /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_A8R8G8B8                 0x0000000c /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_Y32                      0x0000000d /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_V8YB8U8YA8               0x0000000e /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_YB8V8YA8U8               0x0000000f /* RW--V */ 
#define NV_PGRAPH_BPIXEL_DEPTH4                               19:16 /* RWIVF */
#define NV_PGRAPH_BPIXEL_DEPTH4_INVALID                  0x00000000 /* RWI-V */
#define NV_PGRAPH_BPIXEL_DEPTH4_Y8                       0x00000001 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH4_X1R5G5B5_Z1R5G5B5        0x00000002 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH4_X1R5G5B5_O1R5G5B5        0x00000003 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH4_A1R5G5B5                 0x00000004 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH4_R5G6B5                   0x00000005 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH4_Y16                      0x00000006 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH4_X8R8G8B8_Z8R8G8B8        0x00000007 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH4_X8R8G8B8_O1Z7R8G8B8      0x00000008 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH4_X1A7R8G8B8_Z1A7R8G8B8    0x00000009 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH4_X1A7R8G8B8_O1A7R8G8B8    0x0000000a /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH4_X8R8G8B8_O8R8G8B8        0x0000000b /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH4_A8R8G8B8                 0x0000000c /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH4_Y32                      0x0000000d /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH4_V8YB8U8YA8               0x0000000e /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH4_YB8V8YA8U8               0x0000000f /* RW--V */ 
#define NV_PGRAPH_BPIXEL_DEPTH5                               23:20 /* RWIVF */
#define NV_PGRAPH_BPIXEL_DEPTH5_INVALID                  0x00000000 /* RWI-V */
#define NV_PGRAPH_BPIXEL_DEPTH5_Y8                       0x00000001 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH5_X1R5G5B5_Z1R5G5B5        0x00000002 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH5_X1R5G5B5_O1R5G5B5        0x00000003 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH5_A1R5G5B5                 0x00000004 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH5_R5G6B5                   0x00000005 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH5_Y16                      0x00000006 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH5_X8R8G8B8_Z8R8G8B8        0x00000007 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH5_X8R8G8B8_O1Z7R8G8B8      0x00000008 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH5_X1A7R8G8B8_Z1A7R8G8B8    0x00000009 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH5_X1A7R8G8B8_O1A7R8G8B8    0x0000000a /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH5_X8R8G8B8_O8R8G8B8        0x0000000b /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH5_A8R8G8B8                 0x0000000c /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH5_Y32                      0x0000000d /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH5_V8YB8U8YA8               0x0000000e /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH5_YB8V8YA8U8               0x0000000f /* RW--V */ 
#define NV_PGRAPH_LIMIT_VIOL_PIX                         0x00400610 /* RW-4R */
#define NV_PGRAPH_LIMIT_VIOL_PIX_ADRS                          23:0 /* RWIVF */
#define NV_PGRAPH_LIMIT_VIOL_PIX_ADRS_0                  0x00000000 /* RWI-V */
#define NV_PGRAPH_LIMIT_VIOL_PIX_BLIT                         29:29 /* RWIVF */
#define NV_PGRAPH_LIMIT_VIOL_PIX_BLIT_NO_VIOL            0x00000000 /* RWI-V */
#define NV_PGRAPH_LIMIT_VIOL_PIX_BLIT_VIOL               0x00000001 /* RW--V */
#define NV_PGRAPH_LIMIT_VIOL_PIX_LIMIT                        30:30 /* RWIVF */
#define NV_PGRAPH_LIMIT_VIOL_PIX_LIMIT_NO_VIOL           0x00000000 /* RWI-V */
#define NV_PGRAPH_LIMIT_VIOL_PIX_LIMIT_VIOL              0x00000001 /* RW--V */
#define NV_PGRAPH_LIMIT_VIOL_PIX_OVRFLW                       31:31 /* RWIVF */
#define NV_PGRAPH_LIMIT_VIOL_PIX_OVRFLW_NO_VIOL          0x00000000 /* RWI-V */
#define NV_PGRAPH_LIMIT_VIOL_PIX_OVRFLW_VIOL             0x00000001 /* RW--V */
#define NV_PGRAPH_LIMIT_VIOL_Z                           0x00400614 /* RW-4R */
#define NV_PGRAPH_LIMIT_VIOL_Z_ADRS                            23:0 /* RWIVF */
#define NV_PGRAPH_LIMIT_VIOL_Z_ADRS_0                    0x00000000 /* RWI-V */
#define NV_PGRAPH_LIMIT_VIOL_Z_LIMIT                          30:30 /* RWIVF */
#define NV_PGRAPH_LIMIT_VIOL_Z_LIMIT_NO_VIOL             0x00000000 /* RWI-V */
#define NV_PGRAPH_LIMIT_VIOL_Z_LIMIT_VIOL                0x00000001 /* RW--V */
#define NV_PGRAPH_LIMIT_VIOL_Z_OVRFLW                         31:31 /* RWIVF */
#define NV_PGRAPH_LIMIT_VIOL_Z_OVRFLW_NO_VIOL            0x00000000 /* RWI-V */
#define NV_PGRAPH_LIMIT_VIOL_Z_OVRFLW_VIOL               0x00000001 /* RW--V */
#define NV_PGRAPH_STATE                                  0x00400710 /* RW-4R */
#define NV_PGRAPH_STATE_BUFFER_0                                0:0 /* RWIVF */
#define NV_PGRAPH_STATE_BUFFER_0_INVALID                 0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_BUFFER_0_VALID                   0x00000001 /* RW--V */
#define NV_PGRAPH_STATE_BUFFER_1                                1:1 /* RWIVF */
#define NV_PGRAPH_STATE_BUFFER_1_INVALID                 0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_BUFFER_1_VALID                   0x00000001 /* RW--V */
#define NV_PGRAPH_STATE_BUFFER_2                                2:2 /* RWIVF */
#define NV_PGRAPH_STATE_BUFFER_2_INVALID                 0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_BUFFER_2_VALID                   0x00000001 /* RW--V */
#define NV_PGRAPH_STATE_BUFFER_3                                3:3 /* RWIVF */
#define NV_PGRAPH_STATE_BUFFER_3_INVALID                 0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_BUFFER_3_VALID                   0x00000001 /* RW--V */
#define NV_PGRAPH_STATE_BUFFER_4                                4:4 /* RWIVF */
#define NV_PGRAPH_STATE_BUFFER_4_INVALID                 0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_BUFFER_4_VALID                   0x00000001 /* RW--V */
#define NV_PGRAPH_STATE_BUFFER_5                                5:5 /* RWIVF */
#define NV_PGRAPH_STATE_BUFFER_5_INVALID                 0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_BUFFER_5_VALID                   0x00000001 /* RW--V */
#define NV_PGRAPH_STATE_PITCH_0                                 8:8 /* RWIVF */
#define NV_PGRAPH_STATE_PITCH_0_INVALID                  0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_PITCH_0_VALID                    0x00000001 /* RW--V */
#define NV_PGRAPH_STATE_PITCH_1                                 9:9 /* RWIVF */
#define NV_PGRAPH_STATE_PITCH_1_INVALID                  0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_PITCH_1_VALID                    0x00000001 /* RW--V */
#define NV_PGRAPH_STATE_PITCH_2                               10:10 /* RWIVF */
#define NV_PGRAPH_STATE_PITCH_2_INVALID                  0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_PITCH_2_VALID                    0x00000001 /* RW--V */
#define NV_PGRAPH_STATE_PITCH_3                               11:11 /* RWIVF */
#define NV_PGRAPH_STATE_PITCH_3_INVALID                  0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_PITCH_3_VALID                    0x00000001 /* RW--V */
#define NV_PGRAPH_STATE_PITCH_4                               12:12 /* RWIVF */
#define NV_PGRAPH_STATE_PITCH_4_INVALID                  0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_PITCH_4_VALID                    0x00000001 /* RW--V */
#define NV_PGRAPH_STATE_CHROMA_COLOR                          16:16 /* RWIVF */
#define NV_PGRAPH_STATE_CHROMA_COLOR_INVALID             0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_CHROMA_COLOR_VALID               0x00000001 /* RW--V */
#define NV_PGRAPH_STATE_CHROMA_COLORFMT                       17:17 /* RWIVF */
#define NV_PGRAPH_STATE_CHROMA_COLORFMT_INVALID          0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_CHROMA_COLORFMT_VALID            0x00000001 /* RW--V */
#define NV_PGRAPH_STATE_CPATTERN_COLORFMT                     20:20 /* RWIVF */
#define NV_PGRAPH_STATE_CPATTERN_COLORFMT_INVALID        0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_CPATTERN_COLORFMT_VALID          0x00000001 /* RW--V */
#define NV_PGRAPH_STATE_CPATTERN_MONOFMT                      21:21 /* RWIVF */
#define NV_PGRAPH_STATE_CPATTERN_MONOFMT_INVALID         0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_CPATTERN_MONOFMT_VALID           0x00000001 /* RW--V */
#define NV_PGRAPH_STATE_CPATTERN_SELECT                       22:22 /* RWIVF */
#define NV_PGRAPH_STATE_CPATTERN_SELECT_INVALID          0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_CPATTERN_SELECT_VALID            0x00000001 /* RW--V */
#define NV_PGRAPH_STATE_PATTERN_COLOR0                        24:24 /* RWIVF */
#define NV_PGRAPH_STATE_PATTERN_COLOR0_INVALID           0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_PATTERN_COLOR0_VALID             0x00000001 /* RW--V */
#define NV_PGRAPH_STATE_PATTERN_COLOR1                        25:25 /* RWIVF */
#define NV_PGRAPH_STATE_PATTERN_COLOR1_INVALID           0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_PATTERN_COLOR1_VALID             0x00000001 /* RW--V */
#define NV_PGRAPH_STATE_PATTERN_PATT0                         26:26 /* RWIVF */
#define NV_PGRAPH_STATE_PATTERN_PATT0_INVALID            0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_PATTERN_PATT0_VALID              0x00000001 /* RW--V */
#define NV_PGRAPH_STATE_PATTERN_PATT1                         27:27 /* RWIVF */
#define NV_PGRAPH_STATE_PATTERN_PATT1_INVALID            0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_PATTERN_PATT1_VALID              0x00000001 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX                            0x00400728 /* RW-4R */
#define NV_PGRAPH_CACHE_INDEX_BANK                              2:2 /* RWXVF */
#define NV_PGRAPH_CACHE_INDEX_BANK_10                    0x00000000 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_BANK_32                    0x00000001 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_ADRS                             12:3 /* RWXVF */
#define NV_PGRAPH_CACHE_INDEX_ADRS_0                     0x00000000 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_ADRS_1024                  0x00000400 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_OP                              14:13 /* RWXVF */
#define NV_PGRAPH_CACHE_INDEX_OP_WR_CACHE                0x00000000 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_OP_RD_CACHE                0x00000001 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_OP_RD_INDEX                0x00000002 /* RW--V */
#define NV_PGRAPH_CACHE_RAM                              0x0040072c /* RW-4R */
#define NV_PGRAPH_CACHE_RAM_VALUE                              31:0 /* RWXVF */
#define NV_PGRAPH_DMA_PITCH                              0x00400760 /* RW-4R */
#define NV_PGRAPH_DMA_PITCH_S0                                 15:0 /* RWXSF */
#define NV_PGRAPH_DMA_PITCH_S1                                31:16 /* RWXSF */
#define NV_PGRAPH_DVD_COLORFMT                           0x00400764 /* RW-4R */
#define NV_PGRAPH_DVD_COLORFMT_IMAGE                            5:0 /* RWNVF */
#define NV_PGRAPH_DVD_COLORFMT_IMAGE_FORMAT_INVALID            0x00 /* RWN-V */
#define NV_PGRAPH_DVD_COLORFMT_IMAGE_FORMAT_LE_V8YB8U8YA8      0x12 /* RW--V */
#define NV_PGRAPH_DVD_COLORFMT_IMAGE_FORMAT_LE_YB8V8YA8U8      0x13 /* RW--V */
#define NV_PGRAPH_DVD_COLORFMT_OVLY                             9:8 /* RWNVF */
#define NV_PGRAPH_DVD_COLORFMT_OVLY_FORMAT_INVALID             0x00 /* RWN-V */
#define NV_PGRAPH_DVD_COLORFMT_OVLY_FORMAT_LE_A8Y8U8V8         0x01 /* RW--V */
#define NV_PGRAPH_DVD_COLORFMT_OVLY_FORMAT_LE_A4V6YB6A4U6YA6   0x02 /* RW--V */
#define NV_PGRAPH_DVD_COLORFMT_OVLY_FORMAT_TRANSPARENT         0x03 /* RW--V */
#define NV_PGRAPH_SCALED_FORMAT                          0x00400768 /* RW-4R */
#define NV_PGRAPH_SCALED_FORMAT_ORIGIN                        17:16 /* RWIVF */
#define NV_PGRAPH_SCALED_FORMAT_ORIGIN_INVALID           0x00000000 /* RWI-V */
#define NV_PGRAPH_SCALED_FORMAT_ORIGIN_CENTER            0x00000001 /* RW--V */
#define NV_PGRAPH_SCALED_FORMAT_ORIGIN_CORNER            0x00000002 /* RW--V */
#define NV_PGRAPH_SCALED_FORMAT_INTERPOLATOR                  24:24 /* RWIVF */
#define NV_PGRAPH_SCALED_FORMAT_INTERPOLATOR_ZOH         0x00000000 /* RWI-V */
#define NV_PGRAPH_SCALED_FORMAT_INTERPOLATOR_FOH         0x00000001 /* RW--V */
#define NV_PGRAPH_PATT_COLOR0                            0x00400800 /* RW-4R */
#define NV_PGRAPH_PATT_COLOR0_VALUE                            31:0 /* RWXUF */
#define NV_PGRAPH_PATT_COLOR1                            0x00400804 /* RW-4R */
#define NV_PGRAPH_PATT_COLOR1_VALUE                            31:0 /* RWXUF */
#define NV_PGRAPH_PATT_COLORRAM(i)               (0x00400900+(i)*4) /* R--4A */
#define NV_PGRAPH_PATT_COLORRAM__SIZE_1                          64 /*       */
#define NV_PGRAPH_PATT_COLORRAM_VALUE                          23:0 /* R--UF */
#define NV_PGRAPH_PATTERN(i)                     (0x00400808+(i)*4) /* RW-4A */
#define NV_PGRAPH_PATTERN__SIZE_1                                 2 /*       */
#define NV_PGRAPH_PATTERN_BITMAP                               31:0 /* RWXVF */
#define NV_PGRAPH_PATTERN_SHAPE                          0x00400810 /* RW-4R */
#define NV_PGRAPH_PATTERN_SHAPE_VALUE                           1:0 /* RWXVF */
#define NV_PGRAPH_PATTERN_SHAPE_VALUE_8X_8Y              0x00000000 /* RW--V */
#define NV_PGRAPH_PATTERN_SHAPE_VALUE_64X_1Y             0x00000001 /* RW--V */
#define NV_PGRAPH_PATTERN_SHAPE_VALUE_1X_64Y             0x00000002 /* RW--V */
#define NV_PGRAPH_PATTERN_SHAPE_SELECT                          4:4 /* RWXVF */
#define NV_PGRAPH_PATTERN_SHAPE_SELECT_2COLOR            0x00000000 /* RW--V */
#define NV_PGRAPH_PATTERN_SHAPE_SELECT_FULLCOLOR         0x00000001 /* RW--V */
#define NV_PGRAPH_MONO_COLOR0                            0x00400600 /* RW-4R */
#define NV_PGRAPH_MONO_COLOR0_VALUE                            31:0 /* RWXUF */
#define NV_PGRAPH_ROP3                                   0x00400604 /* RW-4R */
#define NV_PGRAPH_ROP3_VALUE                                    7:0 /* RWXVF */
#define NV_PGRAPH_CHROMA                                 0x00400814 /* RW-4R */
#define NV_PGRAPH_CHROMA_VALUE                                 31:0 /* RWXUF */
#define NV_PGRAPH_BETA_AND                               0x00400608 /* RW-4R */
#define NV_PGRAPH_BETA_AND_VALUE_FRACTION                     30:23 /* RWXUF */
#define NV_PGRAPH_BETA_PREMULT                           0x0040060c /* RW-4R */
#define NV_PGRAPH_BETA_PREMULT_VALUE                           31:0 /* RWXUF */
#define NV_PGRAPH_CONTROL0                               0x00400818 /* RW-4R */
#define NV_PGRAPH_CONTROL0_ALPHAREF                             7:0 /* RWXUF */
#define NV_PGRAPH_CONTROL0_ALPHAFUNC                           11:8 /* RWXVF */
#define NV_PGRAPH_CONTROL0_ALPHAFUNC_NEVER               0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL0_ALPHAFUNC_LESS                0x00000002 /* RW--V */
#define NV_PGRAPH_CONTROL0_ALPHAFUNC_EQUAL               0x00000003 /* RW--V */
#define NV_PGRAPH_CONTROL0_ALPHAFUNC_LESSEQUAL           0x00000004 /* RW--V */
#define NV_PGRAPH_CONTROL0_ALPHAFUNC_GREATER             0x00000005 /* RW--V */
#define NV_PGRAPH_CONTROL0_ALPHAFUNC_NOTEQUAL            0x00000006 /* RW--V */
#define NV_PGRAPH_CONTROL0_ALPHAFUNC_GREATEREQUAL        0x00000007 /* RW--V */
#define NV_PGRAPH_CONTROL0_ALPHAFUNC_ALWAYS              0x00000008 /* RW--V */
#define NV_PGRAPH_CONTROL0_ALPHATESTENABLE                    12:12 /* RWXVF */
#define NV_PGRAPH_CONTROL0_ALPHATESTENABLE_FALSE         0x00000000 /* RW--V */
#define NV_PGRAPH_CONTROL0_ALPHATESTENABLE_TRUE          0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL0_ZENABLE                            14:14 /* RWXVF */
#define NV_PGRAPH_CONTROL0_ZENABLE_FALSE                 0x00000000 /* RW--V */
#define NV_PGRAPH_CONTROL0_ZENABLE_TRUE                  0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL0_ZFUNC                              19:16 /* RWXVF */
#define NV_PGRAPH_CONTROL0_ZFUNC_NEVER                   0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL0_ZFUNC_LESS                    0x00000002 /* RW--V */
#define NV_PGRAPH_CONTROL0_ZFUNC_EQUAL                   0x00000003 /* RW--V */
#define NV_PGRAPH_CONTROL0_ZFUNC_LESSEQUAL               0x00000004 /* RW--V */
#define NV_PGRAPH_CONTROL0_ZFUNC_GREATER                 0x00000005 /* RW--V */
#define NV_PGRAPH_CONTROL0_ZFUNC_NOTEQUAL                0x00000006 /* RW--V */
#define NV_PGRAPH_CONTROL0_ZFUNC_GREATEREQUAL            0x00000007 /* RW--V */
#define NV_PGRAPH_CONTROL0_ZFUNC_ALWAYS                  0x00000008 /* RW--V */
#define NV_PGRAPH_CONTROL0_CULLMODE                           21:20 /* RWXVF */
#define NV_PGRAPH_CONTROL0_CULLMODE_NONE                 0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL0_CULLMODE_CW                   0x00000002 /* RW--V */
#define NV_PGRAPH_CONTROL0_CULLMODE_CCW                  0x00000003 /* RW--V */
#define NV_PGRAPH_CONTROL0_DITHERENABLE                       22:22 /* RWXVF */
#define NV_PGRAPH_CONTROL0_DITHERENABLE_FALSE            0x00000000 /* RW--V */
#define NV_PGRAPH_CONTROL0_DITHERENABLE_TRUE             0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL0_Z_PERSPECTIVE_ENABLE               23:23 /* RWXVF */
#define NV_PGRAPH_CONTROL0_Z_PERSPECTIVE_ENABLE_FALSE    0x00000000 /* RW--V */
#define NV_PGRAPH_CONTROL0_Z_PERSPECTIVE_ENABLE_TRUE     0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL0_ZWRITEENABLE                       24:24 /* RWXVF */
#define NV_PGRAPH_CONTROL0_ZWRITEENABLE_FALSE            0x00000000 /* RW--V */
#define NV_PGRAPH_CONTROL0_ZWRITEENABLE_TRUE             0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL0_STENCIL_WRITE_ENABLE               25:25 /* RWXVF */
#define NV_PGRAPH_CONTROL0_STENCIL_WRITE_ENABLE_FALSE    0x00000000 /* RW--V */
#define NV_PGRAPH_CONTROL0_STENCIL_WRITE_ENABLE_TRUE     0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL0_ALPHA_WRITE_ENABLE                 26:26 /* RWXVF */
#define NV_PGRAPH_CONTROL0_ALPHA_WRITE_ENABLE_FALSE      0x00000000 /* RW--V */
#define NV_PGRAPH_CONTROL0_ALPHA_WRITE_ENABLE_TRUE       0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL0_RED_WRITE_ENABLE                   27:27 /* RWXVF */
#define NV_PGRAPH_CONTROL0_RED_WRITE_ENABLE_FALSE        0x00000000 /* RW--V */
#define NV_PGRAPH_CONTROL0_RED_WRITE_ENABLE_TRUE         0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL0_GREEN_WRITE_ENABLE                 28:28 /* RWXVF */
#define NV_PGRAPH_CONTROL0_GREEN_WRITE_ENABLE_FALSE      0x00000000 /* RW--V */
#define NV_PGRAPH_CONTROL0_GREEN_WRITE_ENABLE_TRUE       0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL0_BLUE_WRITE_ENABLE                  29:29 /* RWXVF */
#define NV_PGRAPH_CONTROL0_BLUE_WRITE_ENABLE_FALSE       0x00000000 /* RW--V */
#define NV_PGRAPH_CONTROL0_BLUE_WRITE_ENABLE_TRUE        0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL0_Z_FORMAT                           31:30 /* RWXVF */
#define NV_PGRAPH_CONTROL0_Z_FORMAT_FIXED                0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL0_Z_FORMAT_FLOAT                0x00000002 /* RW--V */
#define NV_PGRAPH_CONTROL1                               0x0040081c /* RW-4R */
#define NV_PGRAPH_CONTROL1_STENCIL_TEST_ENABLE                  0:0 /* RWXVF */
#define NV_PGRAPH_CONTROL1_STENCIL_TEST_ENABLE_FALSE     0x00000000 /* RW--V */
#define NV_PGRAPH_CONTROL1_STENCIL_TEST_ENABLE_TRUE      0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL1_STENCIL_FUNC                         7:4 /* RWXVF */
#define NV_PGRAPH_CONTROL1_STENCIL_FUNC_NEVER            0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL1_STENCIL_FUNC_LESS             0x00000002 /* RW--V */
#define NV_PGRAPH_CONTROL1_STENCIL_FUNC_EQUAL            0x00000003 /* RW--V */
#define NV_PGRAPH_CONTROL1_STENCIL_FUNC_LESSEQUAL        0x00000004 /* RW--V */
#define NV_PGRAPH_CONTROL1_STENCIL_FUNC_GREATER          0x00000005 /* RW--V */
#define NV_PGRAPH_CONTROL1_STENCIL_FUNC_NOTEQUAL         0x00000006 /* RW--V */
#define NV_PGRAPH_CONTROL1_STENCIL_FUNC_GREATEREQUAL     0x00000007 /* RW--V */
#define NV_PGRAPH_CONTROL1_STENCIL_FUNC_ALWAYS           0x00000008 /* RW--V */
#define NV_PGRAPH_CONTROL1_STENCIL_REF                         15:8 /* RWXUF */
#define NV_PGRAPH_CONTROL1_STENCIL_MASK_READ                  23:16 /* RWXUF */
#define NV_PGRAPH_CONTROL1_STENCIL_MASK_WRITE                 31:24 /* RWXUF */
#define NV_PGRAPH_CONTROL2                               0x00400820 /* RW-4R */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_FAIL                      3:0 /* RWXVF */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_FAIL_KEEP          0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_FAIL_ZERO          0x00000002 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_FAIL_REPLACE       0x00000003 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_FAIL_INCRSAT       0x00000004 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_FAIL_DECRSAT       0x00000005 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_FAIL_INVERT        0x00000006 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_FAIL_INCR          0x00000007 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_FAIL_DECR          0x00000008 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_ZFAIL                     7:4 /* RWXVF */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_ZFAIL_KEEP         0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_ZFAIL_ZERO         0x00000002 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_ZFAIL_REPLACE      0x00000003 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_ZFAIL_INCRSAT      0x00000004 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_ZFAIL_DECRSAT      0x00000005 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_ZFAIL_INVERT       0x00000006 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_ZFAIL_INCR         0x00000007 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_ZFAIL_DECR         0x00000008 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_ZPASS                    11:8 /* RWXVF */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_ZPASS_KEEP         0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_ZPASS_ZERO         0x00000002 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_ZPASS_REPLACE      0x00000003 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_ZPASS_INCRSAT      0x00000004 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_ZPASS_DECRSAT      0x00000005 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_ZPASS_INVERT       0x00000006 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_ZPASS_INCR         0x00000007 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_ZPASS_DECR         0x00000008 /* RW--V */
#define NV_PGRAPH_BLEND                                  0x00400824 /* RW-4R */
#define NV_PGRAPH_BLEND_TEXTUREMAPBLEND                         3:0 /* -WXVF */
#define NV_PGRAPH_BLEND_TEXTUREMAPBLEND_DECAL            0x00000001 /* -W--V */
#define NV_PGRAPH_BLEND_TEXTUREMAPBLEND_MODULATE         0x00000002 /* -W--V */
#define NV_PGRAPH_BLEND_TEXTUREMAPBLEND_DECALALPHA       0x00000003 /* -W--V */
#define NV_PGRAPH_BLEND_TEXTUREMAPBLEND_MODULATEALPHA    0x00000004 /* -W--V */
#define NV_PGRAPH_BLEND_TEXTUREMAPBLEND_DECALMASK        0x00000005 /* -W--V */
#define NV_PGRAPH_BLEND_TEXTUREMAPBLEND_MODULATEMASK     0x00000006 /* -W--V */
#define NV_PGRAPH_BLEND_TEXTUREMAPBLEND_COPY             0x00000007 /* -W--V */
#define NV_PGRAPH_BLEND_TEXTUREMAPBLEND_ADD              0x00000008 /* -W--V */
#define NV_PGRAPH_BLEND_MASK_BIT                                5:4 /* -WXVF */
#define NV_PGRAPH_BLEND_MASK_BIT_LSB                     0x00000001 /* -W--V */
#define NV_PGRAPH_BLEND_MASK_BIT_MSB                     0x00000002 /* -W--V */
#define NV_PGRAPH_BLEND_SHADEMODE                               7:6 /* -WXVF */
#define NV_PGRAPH_BLEND_SHADEMODE_FLAT                   0x00000001 /* -W--V */
#define NV_PGRAPH_BLEND_SHADEMODE_GOURAUD                0x00000002 /* -W--V */
#define NV_PGRAPH_BLEND_SHADEMODE_PHONG                  0x00000003 /* -W--V */
#define NV_PGRAPH_BLEND_TEXTUREPERSPECTIVE                      8:8 /* -WXVF */
#define NV_PGRAPH_BLEND_TEXTUREPERSPECTIVE_FALSE         0x00000000 /* -W--V */
#define NV_PGRAPH_BLEND_TEXTUREPERSPECTIVE_TRUE          0x00000001 /* -W--V */
#define NV_PGRAPH_BLEND_SPECULARENABLE                        12:12 /* -WXVF */
#define NV_PGRAPH_BLEND_SPECULARENABLE_FALSE             0x00000000 /* -W--V */
#define NV_PGRAPH_BLEND_SPECULARENABLE_TRUE              0x00000001 /* -W--V */
#define NV_PGRAPH_BLEND_FOGENABLE                             16:16 /* -WXVF */
#define NV_PGRAPH_BLEND_FOGENABLE_FALSE                  0x00000000 /* -W--V */
#define NV_PGRAPH_BLEND_FOGENABLE_TRUE                   0x00000001 /* -W--V */
#define NV_PGRAPH_BLEND_ALPHABLENDENABLE                      20:20 /* -WXVF */
#define NV_PGRAPH_BLEND_ALPHABLENDENABLE_FALSE           0x00000000 /* -W--V */
#define NV_PGRAPH_BLEND_ALPHABLENDENABLE_TRUE            0x00000001 /* -W--V */
#define NV_PGRAPH_BLEND_SRCBLEND                              27:24 /* -WXVF */
#define NV_PGRAPH_BLEND_SRCBLEND_ZERO                    0x00000001 /* -W--V */
#define NV_PGRAPH_BLEND_SRCBLEND_ONE                     0x00000002 /* -W--V */
#define NV_PGRAPH_BLEND_SRCBLEND_SRCCOLOR                0x00000003 /* -W--V */
#define NV_PGRAPH_BLEND_SRCBLEND_INVSRCCOLOR             0x00000004 /* -W--V */
#define NV_PGRAPH_BLEND_SRCBLEND_SRCALPHA                0x00000005 /* -W--V */
#define NV_PGRAPH_BLEND_SRCBLEND_INVSRCALPHA             0x00000006 /* -W--V */
#define NV_PGRAPH_BLEND_SRCBLEND_DESTALPHA               0x00000007 /* -W--V */
#define NV_PGRAPH_BLEND_SRCBLEND_INVDESTALPHA            0x00000008 /* -W--V */
#define NV_PGRAPH_BLEND_SRCBLEND_DESTCOLOR               0x00000009 /* -W--V */
#define NV_PGRAPH_BLEND_SRCBLEND_INVDESTCOLOR            0x0000000A /* -W--V */
#define NV_PGRAPH_BLEND_SRCBLEND_SRCALPHASAT             0x0000000B /* -W--V */
#define NV_PGRAPH_BLEND_SRCBLEND_INVSRCALPHASAT          0x0000000C /* ----V */
#define NV_PGRAPH_BLEND_SRCBLEND_BETA                    0x0000000D /* ----V */
#define NV_PGRAPH_BLEND_DESTBLEND                             31:28 /* -WXVF */
#define NV_PGRAPH_BLEND_DESTBLEND_ZERO                   0x00000001 /* -W--V */
#define NV_PGRAPH_BLEND_DESTBLEND_ONE                    0x00000002 /* -W--V */
#define NV_PGRAPH_BLEND_DESTBLEND_SRCCOLOR               0x00000003 /* -W--V */
#define NV_PGRAPH_BLEND_DESTBLEND_INVSRCCOLOR            0x00000004 /* -W--V */
#define NV_PGRAPH_BLEND_DESTBLEND_SRCALPHA               0x00000005 /* -W--V */
#define NV_PGRAPH_BLEND_DESTBLEND_INVSRCALPHA            0x00000006 /* -W--V */
#define NV_PGRAPH_BLEND_DESTBLEND_DESTALPHA              0x00000007 /* -W--V */
#define NV_PGRAPH_BLEND_DESTBLEND_INVDESTALPHA           0x00000008 /* -W--V */
#define NV_PGRAPH_BLEND_DESTBLEND_DESTCOLOR              0x00000009 /* -W--V */
#define NV_PGRAPH_BLEND_DESTBLEND_INVDESTCOLOR           0x0000000A /* -W--V */
#define NV_PGRAPH_BLEND_DESTBLEND_SRCALPHASAT            0x0000000B /* -W--V */
#define NV_PGRAPH_DPRAM_INDEX                            0x00400828 /* RW-4R */
#define NV_PGRAPH_DPRAM_INDEX_ADRS                              6:0 /* RWIVF */
#define NV_PGRAPH_DPRAM_INDEX_ADRS_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT                           10:8 /* RWIVF */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_ADRS_0              0x00000000 /* RWI-V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_ADRS_1              0x00000001 /* RW--V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_DATA_0              0x00000002 /* RW--V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_DATA_1              0x00000003 /* RW--V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_WE_0                0x00000004 /* RW--V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_WE_1                0x00000005 /* RW--V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_ALPHA_0             0x00000006 /* RW--V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_ALPHA_1             0x00000007 /* RW--V */
#define NV_PGRAPH_DPRAM_DATA                             0x0040082c /* RW-4R */
#define NV_PGRAPH_DPRAM_DATA_VALUE                             31:0 /* RWXVF */
#define NV_PGRAPH_DPRAM_ADRS_0                           0x0040082c /* RW-4R */
#define NV_PGRAPH_DPRAM_ADRS_0__ALIAS_1        NV_PGRAPH_DPRAM_DATA /*       */
#define NV_PGRAPH_DPRAM_ADRS_0_VALUE                           19:0 /* RWXVF */
#define NV_PGRAPH_DPRAM_ADRS_1                           0x0040082c /* RW-4R */
#define NV_PGRAPH_DPRAM_ADRS_1__ALIAS_1        NV_PGRAPH_DPRAM_DATA /*       */
#define NV_PGRAPH_DPRAM_ADRS_1_VALUE                           19:0 /* RWXVF */
#define NV_PGRAPH_DPRAM_DATA_0                           0x0040082c /* RW-4R */
#define NV_PGRAPH_DPRAM_DATA_0__ALIAS_1        NV_PGRAPH_DPRAM_DATA /*       */
#define NV_PGRAPH_DPRAM_DATA_0_VALUE                           31:0 /* RWXVF */
#define NV_PGRAPH_DPRAM_DATA_1                           0x0040082c /* RW-4R */
#define NV_PGRAPH_DPRAM_DATA_1__ALIAS_1        NV_PGRAPH_DPRAM_DATA /*       */
#define NV_PGRAPH_DPRAM_DATA_1_VALUE                           31:0 /* RWXVF */
#define NV_PGRAPH_DPRAM_WE_0                             0x0040082c /* RW-4R */
#define NV_PGRAPH_DPRAM_WE_0__ALIAS_1          NV_PGRAPH_DPRAM_DATA /*       */
#define NV_PGRAPH_DPRAM_WE_0_VALUE                             23:0 /* RWXVF */
#define NV_PGRAPH_DPRAM_WE_1                             0x0040082c /* RW-4R */
#define NV_PGRAPH_DPRAM_WE_1__ALIAS_1          NV_PGRAPH_DPRAM_DATA /*       */
#define NV_PGRAPH_DPRAM_WE_1_VALUE                             23:0 /* RWXVF */
#define NV_PGRAPH_DPRAM_ALPHA_0                          0x0040082c /* RW-4R */
#define NV_PGRAPH_DPRAM_ALPHA_0__ALIAS_1       NV_PGRAPH_DPRAM_DATA /*       */
#define NV_PGRAPH_DPRAM_ALPHA_0_VALUE                          31:0 /* RWXVF */
#define NV_PGRAPH_DPRAM_ALPHA_1                          0x0040082c /* RW-4R */
#define NV_PGRAPH_DPRAM_ALPHA_1__ALIAS_1       NV_PGRAPH_DPRAM_DATA /*       */
#define NV_PGRAPH_DPRAM_ALPHA_1_VALUE                          31:0 /* RWXVF */
#define NV_PGRAPH_STORED_FMT                             0x00400830 /* RW-4R */
#define NV_PGRAPH_STORED_FMT_MONO0                              5:0 /* RWXVF */
#define NV_PGRAPH_STORED_FMT_PATT0                             13:8 /* RWXVF */
#define NV_PGRAPH_STORED_FMT_PATT1                            21:16 /* RWXVF */
#define NV_PGRAPH_STORED_FMT_CHROMA                           29:24 /* RWXVF */
#define NV_PGRAPH_FORMATS                                0x00400618 /* RW-4R */
#define NV_PGRAPH_FORMATS_ROP                                   2:0 /* R-XVF */
#define NV_PGRAPH_FORMATS_ROP_Y8                         0x00000000 /* -W--V */
#define NV_PGRAPH_FORMATS_ROP_RGB15                      0x00000001 /* -W--V */
#define NV_PGRAPH_FORMATS_ROP_RGB16                      0x00000002 /* -W--V */
#define NV_PGRAPH_FORMATS_ROP_Y16                        0x00000003 /* -W--V */
#define NV_PGRAPH_FORMATS_ROP_INVALID                    0x00000004 /* -W--V */
#define NV_PGRAPH_FORMATS_ROP_RGB24                      0x00000005 /* -W--V */
#define NV_PGRAPH_FORMATS_ROP_RGB30                      0x00000006 /* -W--V */
#define NV_PGRAPH_FORMATS_ROP_Y32                        0x00000007 /* -W--V */
#define NV_PGRAPH_FORMATS_SRC                                   9:4 /* R-XVF */
#define NV_PGRAPH_FORMATS_SRC_INVALID                    0x00000000 /* RW--V */
#define NV_PGRAPH_FORMATS_SRC_LE_Y8                      0x00000001 /* RW--V */
#define NV_PGRAPH_FORMATS_SRC_LE_X16A8Y8                 0x00000002 /* RW--V */
#define NV_PGRAPH_FORMATS_SRC_LE_X24Y8                   0x00000003 /* RW--V */
#define NV_PGRAPH_FORMATS_SRC_LE_A1R5G5B5                0x00000006 /* RW--V */
#define NV_PGRAPH_FORMATS_SRC_LE_X1R5G5B5                0x00000007 /* RW--V */
#define NV_PGRAPH_FORMATS_SRC_LE_X16A1R5G5B5             0x00000008 /* RW--V */
#define NV_PGRAPH_FORMATS_SRC_LE_X17R5G5B5               0x00000009 /* RW--V */
#define NV_PGRAPH_FORMATS_SRC_LE_R5G6B5                  0x0000000A /* RW--V */
#define NV_PGRAPH_FORMATS_SRC_LE_A16R5G6B5               0x0000000B /* RW--V */
#define NV_PGRAPH_FORMATS_SRC_LE_X16R5G6B5               0x0000000C /* RW--V */
#define NV_PGRAPH_FORMATS_SRC_LE_A8R8G8B8                0x0000000D /* RW--V */
#define NV_PGRAPH_FORMATS_SRC_LE_X8R8G8B8                0x0000000E /* RW--V */
#define NV_PGRAPH_FORMATS_SRC_LE_Y16                     0x0000000F /* RW--V */
#define NV_PGRAPH_FORMATS_SRC_LE_A16Y16                  0x00000010 /* RW--V */
#define NV_PGRAPH_FORMATS_SRC_LE_X16Y16                  0x00000011 /* RW--V */
#define NV_PGRAPH_FORMATS_SRC_LE_V8YB8U8YA8              0x00000012 /* RW--V */
#define NV_PGRAPH_FORMATS_SRC_LE_YB8V8YA8U8              0x00000013 /* RW--V */
#define NV_PGRAPH_FORMATS_SRC_LE_Y32                     0x00000014 /* RW--V */
#define NV_PGRAPH_FORMATS_FB                                  15:12 /* R-XVF */
#define NV_PGRAPH_FORMATS_FB_INVALID                     0x00000000 /* RWI-V */
#define NV_PGRAPH_FORMATS_FB_Y8                          0x00000001 /* RW--V */
#define NV_PGRAPH_FORMATS_FB_X1R5G5B5_Z1R5G5B5           0x00000002 /* RW--V */
#define NV_PGRAPH_FORMATS_FB_X1R5G5B5_O1R5G5B5           0x00000003 /* RW--V */
#define NV_PGRAPH_FORMATS_FB_A1R5G5B5                    0x00000004 /* RW--V */
#define NV_PGRAPH_FORMATS_FB_R5G6B5                      0x00000005 /* RW--V */
#define NV_PGRAPH_FORMATS_FB_Y16                         0x00000006 /* RW--V */
#define NV_PGRAPH_FORMATS_FB_X8R8G8B8_Z8R8G8B8           0x00000007 /* RW--V */
#define NV_PGRAPH_FORMATS_FB_X8R8G8B8_O1Z7R8G8B8         0x00000008 /* RW--V */
#define NV_PGRAPH_FORMATS_FB_X1A7R8G8B8_Z1A7R8G8B8       0x00000009 /* RW--V */
#define NV_PGRAPH_FORMATS_FB_X1A7R8G8B8_O1A7R8G8B8       0x0000000a /* RW--V */
#define NV_PGRAPH_FORMATS_FB_X8R8G8B8_O8R8G8B8           0x0000000b /* RW--V */
#define NV_PGRAPH_FORMATS_FB_A8R8G8B8                    0x0000000c /* RW--V */
#define NV_PGRAPH_FORMATS_FB_Y32                         0x0000000d /* RW--V */
#define NV_PGRAPH_FORMATS_FB_V8YB8U8YA8                  0x0000000e /* RW--V */
#define NV_PGRAPH_FORMATS_FB_YB8V8YA8U8                  0x0000000f /* RW--V */ 
#define NV_PGRAPH_ABS_X_RAM(i)                   (0x00400400+(i)*4) /* RW-4A */
#define NV_PGRAPH_ABS_X_RAM__SIZE_1                              32 /*       */
#define NV_PGRAPH_ABS_X_RAM_VALUE                              31:0 /* RWXUF */
#define NV_PGRAPH_X_RAM_BPORT(i)                 (0x00400c00+(i)*4) /* R--4A */
#define NV_PGRAPH_X_RAM_BPORT__SIZE_1                            32 /*       */
#define NV_PGRAPH_X_RAM_BPORT_VALUE                            31:0 /* R--UF */
#define NV_PGRAPH_ABS_Y_RAM(i)                   (0x00400480+(i)*4) /* RW-4A */
#define NV_PGRAPH_ABS_Y_RAM__SIZE_1                              32 /*       */
#define NV_PGRAPH_ABS_Y_RAM_VALUE                              31:0 /* RWXUF */
#define NV_PGRAPH_Y_RAM_BPORT(i)                 (0x00400c80+(i)*4) /* R--4A */
#define NV_PGRAPH_Y_RAM_BPORT__SIZE_1                            32 /*       */
#define NV_PGRAPH_Y_RAM_BPORT_VALUE                            31:0 /* R--UF */
#define NV_PGRAPH_XY_LOGIC_MISC0                         0x00400514 /* RW-4R */
#define NV_PGRAPH_XY_LOGIC_MISC0_COUNTER                       17:0 /* RWBUF */
#define NV_PGRAPH_XY_LOGIC_MISC0_COUNTER_0               0x00000000 /* RWB-V */
#define NV_PGRAPH_XY_LOGIC_MISC0_DIMENSION                    20:20 /* RWVVF */
#define NV_PGRAPH_XY_LOGIC_MISC0_DIMENSION_NONZERO       0x00000000 /* RWV-V */
#define NV_PGRAPH_XY_LOGIC_MISC0_DIMENSION_ZERO          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC0_INDEX                        31:28 /* RWBUF */
#define NV_PGRAPH_XY_LOGIC_MISC0_INDEX_0                 0x00000000 /* RWB-V */
#define NV_PGRAPH_XY_LOGIC_MISC1                         0x00400518 /* RW-4R */
#define NV_PGRAPH_XY_LOGIC_MISC1_INITIAL                        0:0 /* RWNVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_INITIAL_NEEDED          0x00000000 /* RWN-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_INITIAL_DONE            0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPX                      4:4 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPX_NOTNULL       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPX_NULL          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPY                      5:5 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPY_NOTNULL       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPY_NULL          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XIMAX                    12:12 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XIMAX_UUMAX         0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XIMAX_IMAGEMAX      0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YIMAX                    16:16 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YIMAX_UUMAX         0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YIMAX_IMAGEMAX      0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XXTRA                    20:20 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XXTRA_CLIPMAX       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XXTRA_IMAGEMAX      0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2                         0x0040051C /* RW-4R */
#define NV_PGRAPH_XY_LOGIC_MISC2_HANDOFF                        0:0 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_HANDOFF_DISABLE         0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_HANDOFF_ENABLE          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPX                      4:4 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPX_NOTNULL       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPX_NULL          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPY                      5:5 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPY_NOTNULL       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPY_NULL          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XIMAX                    12:12 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XIMAX_UCMAX         0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XIMAX_IMAGEMAX      0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YIMAX                    16:16 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YIMAX_UCMAX         0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YIMAX_IMAGEMAX      0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XXTRA                    20:20 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XXTRA_CLIPMAX       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XXTRA_IMAGEMAX      0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC3                         0x00400520 /* RW-4R */
#define NV_PGRAPH_XY_LOGIC_MISC3_WDIMY_EQ_0                     0:0 /* RWXVF */
#define NV_PGRAPH_XY_LOGIC_MISC3_WDIMY_EQ_0_NULL         0x00000000 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC3_WDIMY_EQ_0_TRUE         0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WDIMY                   4:4 /* RWXVF */
#define NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WDIMY_NULL       0x00000000 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WDIMY_TRUE       0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WX                      8:8 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WX_NULL          0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WX_TRUE          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_ALG                     12:12 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_ALG_NULL           0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_ALG_TRUE           0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_DIMX                    22:16 /* RWXUF */
#define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_DIMX_0             0x00000000 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_WDIMX                   30:24 /* RWXUF */
#define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_WDIMX_0            0x00000000 /* RW--V */
#define NV_PGRAPH_X_MISC                                 0x00400500 /* RW-4R */
#define NV_PGRAPH_X_MISC_BIT33_0                                0:0 /* RWNVF */
#define NV_PGRAPH_X_MISC_BIT33_0_0                       0x00000000 /* RWN-V */
#define NV_PGRAPH_X_MISC_BIT33_1                                1:1 /* RWNVF */
#define NV_PGRAPH_X_MISC_BIT33_1_0                       0x00000000 /* RWN-V */
#define NV_PGRAPH_X_MISC_BIT33_2                                2:2 /* RWNVF */
#define NV_PGRAPH_X_MISC_BIT33_2_0                       0x00000000 /* RWN-V */
#define NV_PGRAPH_X_MISC_BIT33_3                                3:3 /* RWNVF */
#define NV_PGRAPH_X_MISC_BIT33_3_0                       0x00000000 /* RWN-V */
#define NV_PGRAPH_X_MISC_RANGE_0                                4:4 /* RWNVF */
#define NV_PGRAPH_X_MISC_RANGE_0_0                       0x00000000 /* RWN-V */
#define NV_PGRAPH_X_MISC_RANGE_1                                5:5 /* RWNVF */
#define NV_PGRAPH_X_MISC_RANGE_1_0                       0x00000000 /* RWN-V */
#define NV_PGRAPH_X_MISC_RANGE_2                                6:6 /* RWNVF */
#define NV_PGRAPH_X_MISC_RANGE_2_0                       0x00000000 /* RWN-V */
#define NV_PGRAPH_X_MISC_RANGE_3                                7:7 /* RWNVF */
#define NV_PGRAPH_X_MISC_RANGE_3_0                       0x00000000 /* RWN-V */
#define NV_PGRAPH_X_MISC_ADDER_OUTPUT                         29:28 /* RWXVF */
#define NV_PGRAPH_X_MISC_ADDER_OUTPUT_EQ_0               0x00000000 /* RW--V */
#define NV_PGRAPH_X_MISC_ADDER_OUTPUT_LT_0               0x00000001 /* RW--V */
#define NV_PGRAPH_X_MISC_ADDER_OUTPUT_GT_0               0x00000002 /* RW--V */
#define NV_PGRAPH_Y_MISC                                 0x00400504 /* RW-4R */
#define NV_PGRAPH_Y_MISC_BIT33_0                                0:0 /* RWNVF */
#define NV_PGRAPH_Y_MISC_BIT33_0_0                       0x00000000 /* RWN-V */
#define NV_PGRAPH_Y_MISC_BIT33_1                                1:1 /* RWNVF */
#define NV_PGRAPH_Y_MISC_BIT33_1_0                       0x00000000 /* RWN-V */
#define NV_PGRAPH_Y_MISC_BIT33_2                                2:2 /* RWNVF */
#define NV_PGRAPH_Y_MISC_BIT33_2_0                       0x00000000 /* RWN-V */
#define NV_PGRAPH_Y_MISC_BIT33_3                                3:3 /* RWNVF */
#define NV_PGRAPH_Y_MISC_BIT33_3_0                       0x00000000 /* RWN-V */
#define NV_PGRAPH_Y_MISC_RANGE_0                                4:4 /* RWNVF */
#define NV_PGRAPH_Y_MISC_RANGE_0_0                       0x00000000 /* RWN-V */
#define NV_PGRAPH_Y_MISC_RANGE_1                                5:5 /* RWNVF */
#define NV_PGRAPH_Y_MISC_RANGE_1_0                       0x00000000 /* RWN-V */
#define NV_PGRAPH_Y_MISC_RANGE_2                                6:6 /* RWNVF */
#define NV_PGRAPH_Y_MISC_RANGE_2_0                       0x00000000 /* RWN-V */
#define NV_PGRAPH_Y_MISC_RANGE_3                                7:7 /* RWNVF */
#define NV_PGRAPH_Y_MISC_RANGE_3_0                       0x00000000 /* RWN-V */
#define NV_PGRAPH_Y_MISC_ADDER_OUTPUT                         29:28 /* RWXVF */
#define NV_PGRAPH_Y_MISC_ADDER_OUTPUT_EQ_0               0x00000000 /* RW--V */
#define NV_PGRAPH_Y_MISC_ADDER_OUTPUT_LT_0               0x00000001 /* RW--V */
#define NV_PGRAPH_Y_MISC_ADDER_OUTPUT_GT_0               0x00000002 /* RW--V */
#define NV_PGRAPH_ABS_UCLIP_XMIN                         0x0040053C /* RW-4R */
#define NV_PGRAPH_ABS_UCLIP_XMIN_VALUE                         15:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIP_XMAX                         0x00400544 /* RW-4R */
#define NV_PGRAPH_ABS_UCLIP_XMAX_VALUE                         17:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIP_YMIN                         0x00400540 /* RW-4R */
#define NV_PGRAPH_ABS_UCLIP_YMIN_VALUE                         15:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIP_YMAX                         0x00400548 /* RW-4R */
#define NV_PGRAPH_ABS_UCLIP_YMAX_VALUE                         17:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIPA_XMIN                        0x00400560 /* RW-4R */
#define NV_PGRAPH_ABS_UCLIPA_XMIN_VALUE                        15:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIPA_XMAX                        0x00400568 /* RW-4R */
#define NV_PGRAPH_ABS_UCLIPA_XMAX_VALUE                        17:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIPA_YMIN                        0x00400564 /* RW-4R */
#define NV_PGRAPH_ABS_UCLIPA_YMIN_VALUE                        15:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIPA_YMAX                        0x0040056C /* RW-4R */
#define NV_PGRAPH_ABS_UCLIPA_YMAX_VALUE                        17:0 /* RWXSF */
#define NV_PGRAPH_SOURCE_COLOR                           0x0040050C /* RW-4R */
#define NV_PGRAPH_SOURCE_COLOR_VALUE                           31:0 /* RWNVF */
#define NV_PGRAPH_SOURCE_COLOR_VALUE_0                   0x00000000 /* RWN-V */
#define NV_PGRAPH_VALID1                                 0x00400508 /* RW-4R */
#define NV_PGRAPH_VALID1_VLD                                   22:0 /* RWNVF */
#define NV_PGRAPH_VALID1_VLD_0                           0x00000000 /* RWN-V */
#define NV_PGRAPH_VALID1_VLD_NOCLIP                       (0x1<<19) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_SRCCOLOR                     (0x1<<16) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTMOVE                      (0x1<<21) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTX01                        (0x3<<0) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTX02                        (0x7<<0) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTX03                        (0xf<<0) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTXCHAIN01                   (0x3<<4) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTXCHAIN02                   (0x7<<4) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTXCHAIN03                   (0xf<<4) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTY01                        (0x3<<8) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTY02                        (0x7<<8) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTY03                        (0xf<<8) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTYCHAIN01                  (0x3<<12) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTYCHAIN02                  (0x7<<12) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTYCHAIN03                  (0xf<<12) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_X_OFFSET                      (0x1<<0) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_XCHAIN_OFFSET                 (0x1<<4) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_Y_OFFSET                      (0x1<<8) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_YCHAIN_OFFSET                (0x1<<12) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTCOLOR0                    (0x1<<17) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTCOLOR1                    (0x1<<18) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTCLIP                      (0x1<<20) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTFONT                      (0x1<<22) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTOFFSET                    (0x1<<22) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTBPITCH                     (0x1<<2) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTBOFFSET                    (0x1<<3) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTDUDX                       (0x1<<4) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTDVDY                       (0x1<<5) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTPOINT                      (0x1<<8) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTSIZE                       (0x1<<9) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTPITCH                     (0x1<<10) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTSTART                     (0x1<<11) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTDUDX2                     (0x1<<12) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTDVDY2                     (0x1<<13) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTPOINT2                    (0x1<<14) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTSIZE2                     (0x1<<15) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTPITCH2                    (0x1<<16) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTSTART2                    (0x1<<17) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTOFFSIN                     (0x1<<0) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTOFFSOUT                    (0x1<<1) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTPITCHIN                    (0x1<<2) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTPITCHOUT                   (0x1<<3) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTLENGTH                     (0x1<<4) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTCOUNT                      (0x1<<5) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTFORMAT                     (0x1<<6) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTNOTIFY                     (0x1<<7) /* RW--V */
#define NV_PGRAPH_VALID1_CLIP_MIN                             28:28 /* RWIVF */
#define NV_PGRAPH_VALID1_CLIP_MIN_NO_ERROR               0x00000000 /* RWI-V */
#define NV_PGRAPH_VALID1_CLIP_MIN_ONLY                   0x00000001 /* RW--V */
#define NV_PGRAPH_VALID1_CLIPA_MIN                            29:29 /* RWIVF */
#define NV_PGRAPH_VALID1_CLIPA_MIN_NO_ERROR              0x00000000 /* RWI-V */
#define NV_PGRAPH_VALID1_CLIPA_MIN_ONLY                  0x00000001 /* RW--V */
#define NV_PGRAPH_VALID1_CLIP_MAX                             30:30 /* RWIVF */
#define NV_PGRAPH_VALID1_CLIP_MAX_NO_ERROR               0x00000000 /* RWI-V */
#define NV_PGRAPH_VALID1_CLIP_MAX_ONLY                   0x00000001 /* RW--V */
#define NV_PGRAPH_VALID1_CLIPA_MAX                            31:31 /* RWIVF */
#define NV_PGRAPH_VALID1_CLIPA_MAX_NO_ERROR              0x00000000 /* RWI-V */
#define NV_PGRAPH_VALID1_CLIPA_MAX_ONLY                  0x00000001 /* RW--V */
#define NV_PGRAPH_VALID2                                 0x00400578 /* RW-4R */
#define NV_PGRAPH_VALID2_VLD2                                  28:0 /* RWNVF */
#define NV_PGRAPH_VALID2_VLD2_0                          0x00000000 /* RWN-V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_COMBINE0A               (1<<28) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_COMBINE0C               (1<<27) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_COMBINE1A               (1<<26) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_COMBINE1C               (1<<25) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_COMBFACTOR              (1<<24) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_FILTER1                 (1<<23) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_OFFSET1                 (1<<22) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_FORMAT1                 (1<<21) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_BLEND                   (1<<20) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_CONTROL2                (1<<19) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_CONTROL1                (1<<18) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_CONTROL0                (1<<17) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_FILTER0                 (1<<16) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_FORMAT0                 (1<<15) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_OFFSET0                 (1<<14) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_FOGCOLOR                (1<<13) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_COLORKEY                (1<<12) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_V1                       (1<<9) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_U1                       (1<<8) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_V0                       (1<<7) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_U0                       (1<<6) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_X                        (1<<5) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_Y                        (1<<4) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_ZETA                     (1<<3) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_M                        (1<<2) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_COLOR                    (1<<1) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_SPECULAR                 (1<<0) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_DX3FULLVERTEX               (0x7f<<0) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_DX5FULLVERTEX               (0x7f<<0) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_DX6FULLVERTEX              (0x1ff<<0) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_DX3FULLSTATE               (0x3f<<13) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_DX5FULLSTATE              (0x1ff<<12) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_DX6FULLSTATE             (0xffff<<13) /* RW--V */
#define NV_PGRAPH_ABS_ICLIP_XMAX                         0x00400534 /* RW-4R */
#define NV_PGRAPH_ABS_ICLIP_XMAX_VALUE                         17:0 /* RWXSF */
#define NV_PGRAPH_ABS_ICLIP_YMAX                         0x00400538 /* RW-4R */
#define NV_PGRAPH_ABS_ICLIP_YMAX_VALUE                         17:0 /* RWXSF */
#define NV_PGRAPH_CLIPX_0                                0x00400524 /* RW-4R */
#define NV_PGRAPH_CLIPX_0_CLIP0_MIN                             1:0 /* RWNVF */
#define NV_PGRAPH_CLIPX_0_CLIP0_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP0_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_0_CLIP0_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP0_MAX                             3:2 /* RWNVF */
#define NV_PGRAPH_CLIPX_0_CLIP0_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP0_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_0_CLIP0_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP1_MIN                             5:4 /* RWNVF */
#define NV_PGRAPH_CLIPX_0_CLIP1_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP1_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_0_CLIP1_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP1_MAX                             7:6 /* RWNVF */
#define NV_PGRAPH_CLIPX_0_CLIP1_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP1_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_0_CLIP1_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP2_MIN                             9:8 /* RWNVF */
#define NV_PGRAPH_CLIPX_0_CLIP2_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP2_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_0_CLIP2_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP2_MAX                           11:10 /* RWNVF */
#define NV_PGRAPH_CLIPX_0_CLIP2_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP2_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_0_CLIP2_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP3_MIN                           13:12 /* RWNVF */
#define NV_PGRAPH_CLIPX_0_CLIP3_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP3_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_0_CLIP3_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP3_MAX                           15:14 /* RWNVF */
#define NV_PGRAPH_CLIPX_0_CLIP3_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP3_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_0_CLIP3_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP4_MIN                           17:16 /* RWNVF */
#define NV_PGRAPH_CLIPX_0_CLIP4_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP4_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_0_CLIP4_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP4_MAX                           19:18 /* RWNVF */
#define NV_PGRAPH_CLIPX_0_CLIP4_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP4_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_0_CLIP4_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP5_MIN                           21:20 /* RWNVF */
#define NV_PGRAPH_CLIPX_0_CLIP5_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP5_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_0_CLIP5_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP5_MAX                           23:22 /* RWNVF */
#define NV_PGRAPH_CLIPX_0_CLIP5_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP5_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_0_CLIP5_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP6_MIN                           25:24 /* RWNVF */
#define NV_PGRAPH_CLIPX_0_CLIP6_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP6_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_0_CLIP6_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP6_MAX                           27:26 /* RWNVF */
#define NV_PGRAPH_CLIPX_0_CLIP6_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP6_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_0_CLIP6_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP7_MIN                           29:28 /* RWNVF */
#define NV_PGRAPH_CLIPX_0_CLIP7_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP7_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_0_CLIP7_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP7_MAX                           31:30 /* RWNVF */
#define NV_PGRAPH_CLIPX_0_CLIP7_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP7_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_0_CLIP7_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1                                0x00400528 /* RW-4R */
#define NV_PGRAPH_CLIPX_1_CLIP8_MIN                             1:0 /* RWNVF */
#define NV_PGRAPH_CLIPX_1_CLIP8_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP8_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_1_CLIP8_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP8_MAX                             3:2 /* RWNVF */
#define NV_PGRAPH_CLIPX_1_CLIP8_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP8_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_1_CLIP8_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP9_MIN                             5:4 /* RWNVF */
#define NV_PGRAPH_CLIPX_1_CLIP9_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP9_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_1_CLIP9_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP9_MAX                             7:6 /* RWNVF */
#define NV_PGRAPH_CLIPX_1_CLIP9_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP9_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_1_CLIP9_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP10_MIN                            9:8 /* RWNVF */
#define NV_PGRAPH_CLIPX_1_CLIP10_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP10_MIN_LT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_1_CLIP10_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP10_MAX                          11:10 /* RWNVF */
#define NV_PGRAPH_CLIPX_1_CLIP10_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP10_MAX_GT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_1_CLIP10_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP11_MIN                          13:12 /* RWNVF */
#define NV_PGRAPH_CLIPX_1_CLIP11_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP11_MIN_LT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_1_CLIP11MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP11_MAX                          15:14 /* RWNVF */
#define NV_PGRAPH_CLIPX_1_CLIP11_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP11_MAX_GT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_1_CLIP11_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP12_MIN                          17:16 /* RWNVF */
#define NV_PGRAPH_CLIPX_1_CLIP12_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP12_MIN_LT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_1_CLIP12_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP12_MAX                          19:18 /* RWNVF */
#define NV_PGRAPH_CLIPX_1_CLIP12_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP12_MAX_GT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_1_CLIP12_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP13_MIN                          21:20 /* RWNVF */
#define NV_PGRAPH_CLIPX_1_CLIP13_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP13_MIN_LT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_1_CLIP13_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP13_MAX                          23:22 /* RWNVF */
#define NV_PGRAPH_CLIPX_1_CLIP13_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP13_MAX_GT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_1_CLIP13_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP14_MIN                          25:24 /* RWNVF */
#define NV_PGRAPH_CLIPX_1_CLIP14_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP14_MIN_LT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_1_CLIP14_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP14_MAX                          27:26 /* RWNVF */
#define NV_PGRAPH_CLIPX_1_CLIP14_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP14_MAX_GT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_1_CLIP14_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP15_MIN                          29:28 /* RWNVF */
#define NV_PGRAPH_CLIPX_1_CLIP15_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP15_MIN_LT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_1_CLIP15_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP15_MAX                          31:30 /* RWNVF */
#define NV_PGRAPH_CLIPX_1_CLIP15_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP15_MAX_GT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_1_CLIP15_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0                                0x0040052c /* RW-4R */
#define NV_PGRAPH_CLIPY_0_CLIP0_MIN                             1:0 /* RWNVF */
#define NV_PGRAPH_CLIPY_0_CLIP0_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP0_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_0_CLIP0_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP0_MAX                             3:2 /* RWNVF */
#define NV_PGRAPH_CLIPY_0_CLIP0_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP0_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_0_CLIP0_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP1_MIN                             5:4 /* RWNVF */
#define NV_PGRAPH_CLIPY_0_CLIP1_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP1_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_0_CLIP1_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP1_MAX                             7:6 /* RWNVF */
#define NV_PGRAPH_CLIPY_0_CLIP1_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP1_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_0_CLIP1_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP2_MIN                             9:8 /* RWNVF */
#define NV_PGRAPH_CLIPY_0_CLIP2_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP2_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_0_CLIP2_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP2_MAX                           11:10 /* RWNVF */
#define NV_PGRAPH_CLIPY_0_CLIP2_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP2_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_0_CLIP2_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP3_MIN                           13:12 /* RWNVF */
#define NV_PGRAPH_CLIPY_0_CLIP3_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP3_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_0_CLIP3_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP3_MAX                           15:14 /* RWNVF */
#define NV_PGRAPH_CLIPY_0_CLIP3_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP3_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_0_CLIP3_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP4_MIN                           17:16 /* RWNVF */
#define NV_PGRAPH_CLIPY_0_CLIP4_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP4_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_0_CLIP4_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP4_MAX                           19:18 /* RWNVF */
#define NV_PGRAPH_CLIPY_0_CLIP4_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP4_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_0_CLIP4_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP5_MIN                           21:20 /* RWNVF */
#define NV_PGRAPH_CLIPY_0_CLIP5_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP5_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_0_CLIP5_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP5_MAX                           23:22 /* RWNVF */
#define NV_PGRAPH_CLIPY_0_CLIP5_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP5_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_0_CLIP5_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP6_MIN                           25:24 /* RWNVF */
#define NV_PGRAPH_CLIPY_0_CLIP6_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP6_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_0_CLIP6_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP6_MAX                           27:26 /* RWNVF */
#define NV_PGRAPH_CLIPY_0_CLIP6_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP6_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_0_CLIP6_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP7_MIN                           29:28 /* RWNVF */
#define NV_PGRAPH_CLIPY_0_CLIP7_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP7_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_0_CLIP7_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP7_MAX                           31:30 /* RWNVF */
#define NV_PGRAPH_CLIPY_0_CLIP7_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP7_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_0_CLIP7_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1                                0x00400530 /* RW-4R */
#define NV_PGRAPH_CLIPY_1_CLIP8_MIN                             1:0 /* RWNVF */
#define NV_PGRAPH_CLIPY_1_CLIP8_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP8_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_1_CLIP8_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP8_MAX                             3:2 /* RWNVF */
#define NV_PGRAPH_CLIPY_1_CLIP8_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP8_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_1_CLIP8_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP9_MIN                             5:4 /* RWNVF */
#define NV_PGRAPH_CLIPY_1_CLIP9_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP9_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_1_CLIP9_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP9_MAX                             7:6 /* RWNVF */
#define NV_PGRAPH_CLIPY_1_CLIP9_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP9_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_1_CLIP9_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP10_MIN                            9:8 /* RWNVF */
#define NV_PGRAPH_CLIPY_1_CLIP10_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP10_MIN_LT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_1_CLIP10_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP10_MAX                          11:10 /* RWNVF */
#define NV_PGRAPH_CLIPY_1_CLIP10_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP10_MAX_GT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_1_CLIP10_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP11_MIN                          13:12 /* RWNVF */
#define NV_PGRAPH_CLIPY_1_CLIP11_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP11_MIN_LT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_1_CLIP11MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP11_MAX                          15:14 /* RWNVF */
#define NV_PGRAPH_CLIPY_1_CLIP11_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP11_MAX_GT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_1_CLIP11_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP12_MIN                          17:16 /* RWNVF */
#define NV_PGRAPH_CLIPY_1_CLIP12_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP12_MIN_LT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_1_CLIP12_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP12_MAX                          19:18 /* RWNVF */
#define NV_PGRAPH_CLIPY_1_CLIP12_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP12_MAX_GT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_1_CLIP12_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP13_MIN                          21:20 /* RWNVF */
#define NV_PGRAPH_CLIPY_1_CLIP13_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP13_MIN_LT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_1_CLIP13_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP13_MAX                          23:22 /* RWNVF */
#define NV_PGRAPH_CLIPY_1_CLIP13_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP13_MAX_GT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_1_CLIP13_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP14_MIN                          25:24 /* RWNVF */
#define NV_PGRAPH_CLIPY_1_CLIP14_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP14_MIN_LT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_1_CLIP14_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP14_MAX                          27:26 /* RWNVF */
#define NV_PGRAPH_CLIPY_1_CLIP14_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP14_MAX_GT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_1_CLIP14_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP15_MIN                          29:28 /* RWNVF */
#define NV_PGRAPH_CLIPY_1_CLIP15_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP15_MIN_LT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_1_CLIP15_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP15_MAX                          31:30 /* RWNVF */
#define NV_PGRAPH_CLIPY_1_CLIP15_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP15_MAX_GT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_1_CLIP15_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_MISC24_0                               0x00400510 /* RW-4R */
#define NV_PGRAPH_MISC24_0_VALUE                               23:0 /* RWXUF */
#define NV_PGRAPH_MISC24_1                               0x00400570 /* RW-4R */
#define NV_PGRAPH_MISC24_1_VALUE                               23:0 /* RWXUF */
#define NV_PGRAPH_MISC24_2                               0x00400574 /* RW-4R */
#define NV_PGRAPH_MISC24_2_VALUE                               23:0 /* RWXUF */
#define NV_PGRAPH_PASSTHRU_0                             0x0040057C /* RW-4R */
#define NV_PGRAPH_PASSTHRU_0_VALUE                             31:0 /* RWXUF */
#define NV_PGRAPH_PASSTHRU_1                             0x00400580 /* RW-4R */
#define NV_PGRAPH_PASSTHRU_1_VALUE                             31:0 /* RWXUF */
#define NV_PGRAPH_PASSTHRU_2                             0x00400584 /* RW-4R */
#define NV_PGRAPH_PASSTHRU_2_VALUE                             31:0 /* RWXUF */
#define NV_PGRAPH_U_RAM(i)                       (0x00400d00+(i)*4) /* RW-4A */
#define NV_PGRAPH_U_RAM__SIZE_1                                  16 /*       */
#define NV_PGRAPH_U_RAM_VALUE                                  31:6 /* RWXFF */
#define NV_PGRAPH_V_RAM(i)                       (0x00400d40+(i)*4) /* RW-4A */
#define NV_PGRAPH_V_RAM__SIZE_1                                  16 /*       */
#define NV_PGRAPH_V_RAM_VALUE                                  31:6 /* RWXFF */
#define NV_PGRAPH_M_RAM(i)                       (0x00400d80+(i)*4) /* RW-4A */
#define NV_PGRAPH_M_RAM__SIZE_1                                  16 /*       */
#define NV_PGRAPH_M_RAM_VALUE                                  31:6 /* RWXFF */
#define NV_PGRAPH_D3D_XY                                 0x004005c0 /* RW-4R */
#define NV_PGRAPH_D3D_XY_X_VALUE                               15:0 /* RWXSF */
#define NV_PGRAPH_D3D_XY_Y_VALUE                              31:16 /* RWXSF */
#define NV_PGRAPH_D3D_U0                                 0x004005c4 /* RW-4R */
#define NV_PGRAPH_D3D_U0_VALUE                                 31:6 /* RWXFF */
#define NV_PGRAPH_D3D_V0                                 0x004005c8 /* RW-4R */
#define NV_PGRAPH_D3D_V0_VALUE                                 31:6 /* RWXFF */
#define NV_PGRAPH_D3D_U1                                 0x004005cc /* RW-4R */
#define NV_PGRAPH_D3D_U1_VALUE                                 31:6 /* RWXFF */
#define NV_PGRAPH_D3D_V1                                 0x004005d0 /* RW-4R */
#define NV_PGRAPH_D3D_V1_VALUE                                 31:6 /* RWXFF */
#define NV_PGRAPH_D3D_ZETA                               0x004005d4 /* RW-4R */
#define NV_PGRAPH_D3D_ZETA_VALUE                               31:0 /* RWXFF */
#define NV_PGRAPH_D3D_RGB                                0x004005d8 /* RW-4R */
#define NV_PGRAPH_D3D_RGB_VALUE                                31:0 /* RWXUF */
#define NV_PGRAPH_D3D_S                                  0x004005dc /* RW-4R */
#define NV_PGRAPH_D3D_S_VALUE                                  31:0 /* RWXUF */
#define NV_PGRAPH_D3D_M                                  0x004005e0 /* RW-4R */
#define NV_PGRAPH_D3D_M_VALUE                                  31:6 /* RWXFF */
#define NV_PGRAPH_FORMAT0                                0x004005A8 /* RW-4R */
#define NV_PGRAPH_FORMAT0_CONTEXT_DMA                           1:1 /* RWXVF */
#define NV_PGRAPH_FORMAT0_CONTEXT_DMA_A                  0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT0_CONTEXT_DMA_B                  0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT0_COLORKEYENABLE                        2:2 /* RWXVF */
#define NV_PGRAPH_FORMAT0_COLORKEYENABLE_FALSE           0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT0_COLORKEYENABLE_TRUE            0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT0_ORIGIN_ZOH                            5:5 /* RWXVF */
#define NV_PGRAPH_FORMAT0_ORIGIN_ZOH_CENTER              0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT0_ORIGIN_ZOH_CORNER              0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT0_ORIGIN_FOH                            7:7 /* RWXVF */
#define NV_PGRAPH_FORMAT0_ORIGIN_FOH_CENTER              0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT0_ORIGIN_FOH_CORNER              0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT0_COLOR                                10:8 /* RWXVF */
#define NV_PGRAPH_FORMAT0_COLOR_LE_Y8                    0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT0_COLOR_LE_AY8                   0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT0_COLOR_LE_A1R5G5B5              0x00000002 /* RW--V */
#define NV_PGRAPH_FORMAT0_COLOR_LE_X1R5G5B5              0x00000003 /* RW--V */
#define NV_PGRAPH_FORMAT0_COLOR_LE_A4R4G4B4              0x00000004 /* RW--V */
#define NV_PGRAPH_FORMAT0_COLOR_LE_R5G6B5                0x00000005 /* RW--V */
#define NV_PGRAPH_FORMAT0_COLOR_LE_A8R8G8B8              0x00000006 /* RW--V */
#define NV_PGRAPH_FORMAT0_COLOR_LE_X8R8G8B8              0x00000007 /* RW--V */
#define NV_PGRAPH_FORMAT0_MIPMAP_LEVELS                       15:12 /* RWXVF */
#define NV_PGRAPH_FORMAT0_MIPMAP_LEVELS_INVALID          0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT0_MIPMAP_LEVELS_1                0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT0_MIPMAP_LEVELS_2                0x00000002 /* RW--V */
#define NV_PGRAPH_FORMAT0_MIPMAP_LEVELS_3                0x00000003 /* RW--V */
#define NV_PGRAPH_FORMAT0_MIPMAP_LEVELS_4                0x00000004 /* RW--V */
#define NV_PGRAPH_FORMAT0_MIPMAP_LEVELS_5                0x00000005 /* RW--V */
#define NV_PGRAPH_FORMAT0_MIPMAP_LEVELS_6                0x00000006 /* RW--V */
#define NV_PGRAPH_FORMAT0_MIPMAP_LEVELS_7                0x00000007 /* RW--V */
#define NV_PGRAPH_FORMAT0_MIPMAP_LEVELS_8                0x00000008 /* RW--V */
#define NV_PGRAPH_FORMAT0_MIPMAP_LEVELS_9                0x00000009 /* RW--V */
#define NV_PGRAPH_FORMAT0_MIPMAP_LEVELS_10               0x0000000A /* RW--V */
#define NV_PGRAPH_FORMAT0_MIPMAP_LEVELS_11               0x0000000B /* RW--V */
#define NV_PGRAPH_FORMAT0_MIPMAP_LEVELS_12               0x0000000C /* RW--V */
#define NV_PGRAPH_FORMAT0_MIPMAP_LEVELS_13               0x0000000D /* RW--V */
#define NV_PGRAPH_FORMAT0_MIPMAP_LEVELS_14               0x0000000E /* RW--V */
#define NV_PGRAPH_FORMAT0_MIPMAP_LEVELS_15               0x0000000F /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_U                         19:16 /* RWXVF */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_U_1                  0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_U_2                  0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_U_4                  0x00000002 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_U_8                  0x00000003 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_U_16                 0x00000004 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_U_32                 0x00000005 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_U_64                 0x00000006 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_U_128                0x00000007 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_U_256                0x00000008 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_U_512                0x00000009 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_U_1024               0x0000000A /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_U_2048               0x0000000B /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_V                         23:20 /* RWXVF */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_V_1                  0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_V_2                  0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_V_4                  0x00000002 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_V_8                  0x00000003 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_V_16                 0x00000004 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_V_32                 0x00000005 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_V_64                 0x00000006 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_V_128                0x00000007 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_V_256                0x00000008 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_V_512                0x00000009 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_V_1024               0x0000000A /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_V_2048               0x0000000B /* RW--V */
#define NV_PGRAPH_FORMAT0_TEXTUREADDRESSU                     26:24 /* RWXVF */
#define NV_PGRAPH_FORMAT0_TEXTUREADDRESSU_WRAP           0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT0_TEXTUREADDRESSU_MIRROR         0x00000002 /* RW--V */
#define NV_PGRAPH_FORMAT0_TEXTUREADDRESSU_CLAMP          0x00000003 /* RW--V */
#define NV_PGRAPH_FORMAT0_TEXTUREADDRESSU_BORDER         0x00000004 /* RW--V */
#define NV_PGRAPH_FORMAT0_WRAPU                               27:27 /* RWXVF */
#define NV_PGRAPH_FORMAT0_WRAPU_FALSE                    0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT0_WRAPU_TRUE                     0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT0_TEXTUREADDRESSV                     30:28 /* RWXVF */
#define NV_PGRAPH_FORMAT0_TEXTUREADDRESSV_WRAP           0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT0_TEXTUREADDRESSV_MIRROR         0x00000002 /* RW--V */
#define NV_PGRAPH_FORMAT0_TEXTUREADDRESSV_CLAMP          0x00000003 /* RW--V */
#define NV_PGRAPH_FORMAT0_TEXTUREADDRESSV_BORDER         0x00000004 /* RW--V */
#define NV_PGRAPH_FORMAT0_WRAPV                               31:31 /* RWXVF */
#define NV_PGRAPH_FORMAT0_WRAPV_FALSE                    0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT0_WRAPV_TRUE                     0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT1                                0x004005AC /* RW-4R */
#define NV_PGRAPH_FORMAT1_CONTEXT_DMA                           1:1 /* RWXVF */
#define NV_PGRAPH_FORMAT1_CONTEXT_DMA_A                  0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT1_CONTEXT_DMA_B                  0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT1_COLORKEYENABLE                        2:2 /* RWXVF */
#define NV_PGRAPH_FORMAT1_COLORKEYENABLE_FALSE           0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT1_COLORKEYENABLE_TRUE            0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT1_ORIGIN_ZOH                            5:5 /* RWXVF */
#define NV_PGRAPH_FORMAT1_ORIGIN_ZOH_CENTER              0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT1_ORIGIN_ZOH_CORNER              0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT1_ORIGIN_FOH                            7:7 /* RWXVF */
#define NV_PGRAPH_FORMAT1_ORIGIN_FOH_CENTER              0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT1_ORIGIN_FOH_CORNER              0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT1_COLOR                                10:8 /* RWXVF */
#define NV_PGRAPH_FORMAT1_COLOR_LE_Y8                    0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT1_COLOR_LE_AY8                   0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT1_COLOR_LE_A1R5G5B5              0x00000002 /* RW--V */
#define NV_PGRAPH_FORMAT1_COLOR_LE_X1R5G5B5              0x00000003 /* RW--V */
#define NV_PGRAPH_FORMAT1_COLOR_LE_A4R4G4B4              0x00000004 /* RW--V */
#define NV_PGRAPH_FORMAT1_COLOR_LE_R5G6B5                0x00000005 /* RW--V */
#define NV_PGRAPH_FORMAT1_COLOR_LE_A8R8G8B8              0x00000006 /* RW--V */
#define NV_PGRAPH_FORMAT1_COLOR_LE_X8R8G8B8              0x00000007 /* RW--V */
#define NV_PGRAPH_FORMAT1_MIPMAP_LEVELS                       15:12 /* RWXVF */
#define NV_PGRAPH_FORMAT1_MIPMAP_LEVELS_INVALID          0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT1_MIPMAP_LEVELS_1                0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT1_MIPMAP_LEVELS_2                0x00000002 /* RW--V */
#define NV_PGRAPH_FORMAT1_MIPMAP_LEVELS_3                0x00000003 /* RW--V */
#define NV_PGRAPH_FORMAT1_MIPMAP_LEVELS_4                0x00000004 /* RW--V */
#define NV_PGRAPH_FORMAT1_MIPMAP_LEVELS_5                0x00000005 /* RW--V */
#define NV_PGRAPH_FORMAT1_MIPMAP_LEVELS_6                0x00000006 /* RW--V */
#define NV_PGRAPH_FORMAT1_MIPMAP_LEVELS_7                0x00000007 /* RW--V */
#define NV_PGRAPH_FORMAT1_MIPMAP_LEVELS_8                0x00000008 /* RW--V */
#define NV_PGRAPH_FORMAT1_MIPMAP_LEVELS_9                0x00000009 /* RW--V */
#define NV_PGRAPH_FORMAT1_MIPMAP_LEVELS_10               0x0000000A /* RW--V */
#define NV_PGRAPH_FORMAT1_MIPMAP_LEVELS_11               0x0000000B /* RW--V */
#define NV_PGRAPH_FORMAT1_MIPMAP_LEVELS_12               0x0000000C /* RW--V */
#define NV_PGRAPH_FORMAT1_MIPMAP_LEVELS_13               0x0000000D /* RW--V */
#define NV_PGRAPH_FORMAT1_MIPMAP_LEVELS_14               0x0000000E /* RW--V */
#define NV_PGRAPH_FORMAT1_MIPMAP_LEVELS_15               0x0000000F /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_U                         19:16 /* RWXVF */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_U_1                  0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_U_2                  0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_U_4                  0x00000002 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_U_8                  0x00000003 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_U_16                 0x00000004 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_U_32                 0x00000005 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_U_64                 0x00000006 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_U_128                0x00000007 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_U_256                0x00000008 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_U_512                0x00000009 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_U_1024               0x0000000A /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_U_2048               0x0000000B /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_V                         23:20 /* RWXVF */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_V_1                  0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_V_2                  0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_V_4                  0x00000002 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_V_8                  0x00000003 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_V_16                 0x00000004 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_V_32                 0x00000005 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_V_64                 0x00000006 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_V_128                0x00000007 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_V_256                0x00000008 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_V_512                0x00000009 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_V_1024               0x0000000A /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_V_2048               0x0000000B /* RW--V */
#define NV_PGRAPH_FORMAT1_TEXTUREADDRESSU                     26:24 /* RWXVF */
#define NV_PGRAPH_FORMAT1_TEXTUREADDRESSU_WRAP           0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT1_TEXTUREADDRESSU_MIRROR         0x00000002 /* RW--V */
#define NV_PGRAPH_FORMAT1_TEXTUREADDRESSU_CLAMP          0x00000003 /* RW--V */
#define NV_PGRAPH_FORMAT1_TEXTUREADDRESSU_BORDER         0x00000004 /* RW--V */
#define NV_PGRAPH_FORMAT1_WRAPU                               27:27 /* RWXVF */
#define NV_PGRAPH_FORMAT1_WRAPU_FALSE                    0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT1_WRAPU_TRUE                     0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT1_TEXTUREADDRESSV                     30:28 /* RWXVF */
#define NV_PGRAPH_FORMAT1_TEXTUREADDRESSV_WRAP           0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT1_TEXTUREADDRESSV_MIRROR         0x00000002 /* RW--V */
#define NV_PGRAPH_FORMAT1_TEXTUREADDRESSV_CLAMP          0x00000003 /* RW--V */
#define NV_PGRAPH_FORMAT1_TEXTUREADDRESSV_BORDER         0x00000004 /* RW--V */
#define NV_PGRAPH_FORMAT1_WRAPV                               31:31 /* RWXVF */
#define NV_PGRAPH_FORMAT1_WRAPV_FALSE                    0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT1_WRAPV_TRUE                     0x00000001 /* RW--V */
#define NV_PGRAPH_FILTER0                                0x004005B0 /* RW-4R */
#define NV_PGRAPH_FILTER0_KERNEL_SIZE_X                         4:1 /* RWXUF */
#define NV_PGRAPH_FILTER0_KERNEL_SIZE_Y                        12:9 /* RWXUF */
#define NV_PGRAPH_FILTER0_MIPMAP_DITHER_ENABLE                15:15 /* RWXVF */
#define NV_PGRAPH_FILTER0_MIPMAP_DITHER_ENABLE_FALSE     0x00000000 /* RW--V */
#define NV_PGRAPH_FILTER0_MIPMAP_DITHER_ENABLE_TRUE      0x00000001 /* RW--V */
#define NV_PGRAPH_FILTER0_MIPMAPLODBIAS                       23:16 /* RWXSF */
#define NV_PGRAPH_FILTER0_TEXTUREMIN                          26:24 /* RWXVF */
#define NV_PGRAPH_FILTER0_TEXTUREMIN_NEAREST             0x00000001 /* RW--V */
#define NV_PGRAPH_FILTER0_TEXTUREMIN_LINEAR              0x00000002 /* RW--V */
#define NV_PGRAPH_FILTER0_TEXTUREMIN_MIPNEAREST          0x00000003 /* RW--V */
#define NV_PGRAPH_FILTER0_TEXTUREMIN_MIPLINEAR           0x00000004 /* RW--V */
#define NV_PGRAPH_FILTER0_TEXTUREMIN_LINEARMIPNEAREST    0x00000005 /* RW--V */
#define NV_PGRAPH_FILTER0_TEXTUREMIN_LINEARMIPLINEAR     0x00000006 /* RW--V */
#define NV_PGRAPH_FILTER0_ANISOTROPIC_MIN_ENABLE              27:27 /* RWXVF */
#define NV_PGRAPH_FILTER0_ANISOTROPIC_MIN_ENABLE_FALSE   0x00000000 /* RW--V */
#define NV_PGRAPH_FILTER0_ANISOTROPIC_MIN_ENABLE_TRUE    0x00000001 /* RW--V */
#define NV_PGRAPH_FILTER0_TEXTUREMAG                          30:28 /* RWXVF */
#define NV_PGRAPH_FILTER0_TEXTUREMAG_NEAREST             0x00000001 /* RW--V */
#define NV_PGRAPH_FILTER0_TEXTUREMAG_LINEAR              0x00000002 /* RW--V */
#define NV_PGRAPH_FILTER0_TEXTUREMAG_MIPNEAREST          0x00000003 /* RW--V */
#define NV_PGRAPH_FILTER0_TEXTUREMAG_MIPLINEAR           0x00000004 /* RW--V */
#define NV_PGRAPH_FILTER0_TEXTUREMAG_LINEARMIPNEAREST    0x00000005 /* RW--V */
#define NV_PGRAPH_FILTER0_TEXTUREMAG_LINEARMIPLINEAR     0x00000006 /* RW--V */
#define NV_PGRAPH_FILTER0_ANISOTROPIC_MAG_ENABLE              31:31 /* RWXVF */
#define NV_PGRAPH_FILTER0_ANISOTROPIC_MAG_ENABLE_FALSE   0x00000000 /* RW--V */
#define NV_PGRAPH_FILTER0_ANISOTROPIC_MAG_ENABLE_TRUE    0x00000001 /* RW--V */
#define NV_PGRAPH_FILTER1                                0x004005B4 /* RW-4R */
#define NV_PGRAPH_FILTER1_KERNEL_SIZE_X                         4:1 /* RWXUF */
#define NV_PGRAPH_FILTER1_KERNEL_SIZE_Y                        12:9 /* RWXUF */
#define NV_PGRAPH_FILTER1_MIPMAP_DITHER_ENABLE                15:15 /* RWXVF */
#define NV_PGRAPH_FILTER1_MIPMAP_DITHER_ENABLE_FALSE     0x00000000 /* RW--V */
#define NV_PGRAPH_FILTER1_MIPMAP_DITHER_ENABLE_TRUE      0x00000001 /* RW--V */
#define NV_PGRAPH_FILTER1_MIPMAPLODBIAS                       23:16 /* RWXSF */
#define NV_PGRAPH_FILTER1_TEXTUREMIN                          26:24 /* RWXVF */
#define NV_PGRAPH_FILTER1_TEXTUREMIN_NEAREST             0x00000001 /* RW--V */
#define NV_PGRAPH_FILTER1_TEXTUREMIN_LINEAR              0x00000002 /* RW--V */
#define NV_PGRAPH_FILTER1_TEXTUREMIN_MIPNEAREST          0x00000003 /* RW--V */
#define NV_PGRAPH_FILTER1_TEXTUREMIN_MIPLINEAR           0x00000004 /* RW--V */
#define NV_PGRAPH_FILTER1_TEXTUREMIN_LINEARMIPNEAREST    0x00000005 /* RW--V */
#define NV_PGRAPH_FILTER1_TEXTUREMIN_LINEARMIPLINEAR     0x00000006 /* RW--V */
#define NV_PGRAPH_FILTER1_ANISOTROPIC_MIN_ENABLE              27:27 /* RWXVF */
#define NV_PGRAPH_FILTER1_ANISOTROPIC_MIN_ENABLE_FALSE   0x00000000 /* RW--V */
#define NV_PGRAPH_FILTER1_ANISOTROPIC_MIN_ENABLE_TRUE    0x00000001 /* RW--V */
#define NV_PGRAPH_FILTER1_TEXTUREMAG                          30:28 /* RWXVF */
#define NV_PGRAPH_FILTER1_TEXTUREMAG_NEAREST             0x00000001 /* RW--V */
#define NV_PGRAPH_FILTER1_TEXTUREMAG_LINEAR              0x00000002 /* RW--V */
#define NV_PGRAPH_FILTER1_TEXTUREMAG_MIPNEAREST          0x00000003 /* RW--V */
#define NV_PGRAPH_FILTER1_TEXTUREMAG_MIPLINEAR           0x00000004 /* RW--V */
#define NV_PGRAPH_FILTER1_TEXTUREMAG_LINEARMIPNEAREST    0x00000005 /* RW--V */
#define NV_PGRAPH_FILTER1_TEXTUREMAG_LINEARMIPLINEAR     0x00000006 /* RW--V */
#define NV_PGRAPH_FILTER1_ANISOTROPIC_MAG_ENABLE              31:31 /* RWXVF */
#define NV_PGRAPH_FILTER1_ANISOTROPIC_MAG_ENABLE_FALSE   0x00000000 /* RW--V */
#define NV_PGRAPH_FILTER1_ANISOTROPIC_MAG_ENABLE_TRUE    0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA                          0x00400590 /* RW-4R */
#define NV_PGRAPH_COMBINE0ALPHA_INVERSE_0                       0:0 /* RWXVF */
#define NV_PGRAPH_COMBINE0ALPHA_INVERSE_0_NORMAL         0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_INVERSE_0_INVERSE        0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_0                      4:2 /* RWXVF */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_0_ZERO          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_0_FACTOR        0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_0_DIFFUSE       0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_0_INPUT         0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_0_TEXTURE0      0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_0_TEXTURE1      0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_0_TEXTURELOD    0x00000007 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_INVERSE_1                       8:8 /* RWXVF */
#define NV_PGRAPH_COMBINE0ALPHA_INVERSE_1_NORMAL         0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_INVERSE_1_INVERSE        0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_1                    12:10 /* RWXVF */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_1_ZERO          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_1_FACTOR        0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_1_DIFFUSE       0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_1_INPUT         0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_1_TEXTURE0      0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_1_TEXTURE1      0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_1_TEXTURELOD    0x00000007 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_INVERSE_2                     16:16 /* RWXVF */
#define NV_PGRAPH_COMBINE0ALPHA_INVERSE_2_NORMAL         0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_INVERSE_2_INVERSE        0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_2                    20:18 /* RWXVF */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_2_ZERO          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_2_FACTOR        0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_2_DIFFUSE       0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_2_INPUT         0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_2_TEXTURE0      0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_2_TEXTURE1      0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_2_TEXTURELOD    0x00000007 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_INVERSE_3                     24:24 /* RWXVF */
#define NV_PGRAPH_COMBINE0ALPHA_INVERSE_3_NORMAL         0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_INVERSE_3_INVERSE        0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_3                    28:26 /* RWXVF */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_3_ZERO          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_3_FACTOR        0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_3_DIFFUSE       0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_3_INPUT         0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_3_TEXTURE0      0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_3_TEXTURE1      0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_3_TEXTURELOD    0x00000007 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_OPERATION                     31:29 /* RWXVF */
#define NV_PGRAPH_COMBINE0ALPHA_OPERATION_ADD            0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_OPERATION_ADD2           0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_OPERATION_ADD4           0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_OPERATION_ADDSIGNED      0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_OPERATION_MUX            0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_OPERATION_ADDCOMPLEMENT  0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_OPERATION_ADDSIGNED2     0x00000007 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR                          0x00400594 /* RW-4R */
#define NV_PGRAPH_COMBINE0COLOR_INVERSE_0                       0:0 /* RWXVF */
#define NV_PGRAPH_COMBINE0COLOR_INVERSE_0_NORMAL         0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_INVERSE_0_INVERSE        0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ALPHA_0                         1:1 /* RWXVF */
#define NV_PGRAPH_COMBINE0COLOR_ALPHA_0_COLOR            0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ALPHA_0_ALPHA            0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_0                      4:2 /* RWXVF */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_0_ZERO          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_0_FACTOR        0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_0_DIFFUSE       0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_0_INPUT         0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_0_TEXTURE0      0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_0_TEXTURE1      0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_0_TEXTURELOD    0x00000007 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_INVERSE_1                       8:8 /* RWXVF */
#define NV_PGRAPH_COMBINE0COLOR_INVERSE_1_NORMAL         0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_INVERSE_1_INVERSE        0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ALPHA_1                         9:9 /* RWXVF */
#define NV_PGRAPH_COMBINE0COLOR_ALPHA_1_COLOR            0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ALPHA_1_ALPHA            0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_1                    12:10 /* RWXVF */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_1_ZERO          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_1_FACTOR        0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_1_DIFFUSE       0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_1_INPUT         0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_1_TEXTURE0      0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_1_TEXTURE1      0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_1_TEXTURELOD    0x00000007 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_INVERSE_2                     16:16 /* RWXVF */
#define NV_PGRAPH_COMBINE0COLOR_INVERSE_2_NORMAL         0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_INVERSE_2_INVERSE        0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ALPHA_2                       17:17 /* RWXVF */
#define NV_PGRAPH_COMBINE0COLOR_ALPHA_2_COLOR            0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ALPHA_2_ALPHA            0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_2                    20:18 /* RWXVF */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_2_ZERO          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_2_FACTOR        0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_2_DIFFUSE       0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_2_INPUT         0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_2_TEXTURE0      0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_2_TEXTURE1      0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_2_TEXTURELOD    0x00000007 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_INVERSE_3                     24:24 /* RWXVF */
#define NV_PGRAPH_COMBINE0COLOR_INVERSE_3_NORMAL         0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_INVERSE_3_INVERSE        0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ALPHA_3                       25:25 /* RWXVF */
#define NV_PGRAPH_COMBINE0COLOR_ALPHA_3_COLOR            0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ALPHA_3_ALPHA            0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_3                    28:26 /* RWXVF */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_3_ZERO          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_3_FACTOR        0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_3_DIFFUSE       0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_3_INPUT         0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_3_TEXTURE0      0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_3_TEXTURE1      0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_3_TEXTURELOD    0x00000007 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_OPERATION                     31:29 /* RWXVF */
#define NV_PGRAPH_COMBINE0COLOR_OPERATION_ADD            0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_OPERATION_ADD2           0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_OPERATION_ADD4           0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_OPERATION_ADDSIGNED      0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_OPERATION_MUX            0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_OPERATION_ADDCOMPLEMENT  0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_OPERATION_ADDSIGNED2     0x00000007 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA                          0x00400598 /* RW-4R */
#define NV_PGRAPH_COMBINE1ALPHA_INVERSE_0                       0:0 /* RWXVF */
#define NV_PGRAPH_COMBINE1ALPHA_INVERSE_0_NORMAL         0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_INVERSE_0_INVERSE        0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_0                      4:2 /* RWXVF */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_0_ZERO          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_0_FACTOR        0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_0_DIFFUSE       0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_0_INPUT         0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_0_TEXTURE0      0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_0_TEXTURE1      0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_INVERSE_1                       8:8 /* RWXVF */
#define NV_PGRAPH_COMBINE1ALPHA_INVERSE_1_NORMAL         0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_INVERSE_1_INVERSE        0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_1                    12:10 /* RWXVF */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_1_ZERO          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_1_FACTOR        0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_1_DIFFUSE       0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_1_INPUT         0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_1_TEXTURE0      0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_1_TEXTURE1      0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_INVERSE_2                     16:16 /* RWXVF */
#define NV_PGRAPH_COMBINE1ALPHA_INVERSE_2_NORMAL         0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_INVERSE_2_INVERSE        0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_2                    20:18 /* RWXVF */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_2_ZERO          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_2_FACTOR        0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_2_DIFFUSE       0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_2_INPUT         0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_2_TEXTURE0      0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_2_TEXTURE1      0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_INVERSE_3                     24:24 /* RWXVF */
#define NV_PGRAPH_COMBINE1ALPHA_INVERSE_3_NORMAL         0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_INVERSE_3_INVERSE        0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_3                    28:26 /* RWXVF */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_3_ZERO          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_3_FACTOR        0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_3_DIFFUSE       0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_3_INPUT         0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_3_TEXTURE0      0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_3_TEXTURE1      0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_OPERATION                     31:29 /* RWXVF */
#define NV_PGRAPH_COMBINE1ALPHA_OPERATION_ADD            0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_OPERATION_ADD2           0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_OPERATION_ADD4           0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_OPERATION_ADDSIGNED      0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_OPERATION_MUX            0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_OPERATION_ADDCOMPLEMENT  0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_OPERATION_ADDSIGNED2     0x00000007 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR                          0x0040059C /* RW-4R */
#define NV_PGRAPH_COMBINE1COLOR_INVERSE_0                       0:0 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLOR_INVERSE_0_NORMAL         0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_INVERSE_0_INVERSE        0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ALPHA_0                         1:1 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLOR_ALPHA_0_COLOR            0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ALPHA_0_ALPHA            0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_0                      4:2 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_0_ZERO          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_0_FACTOR        0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_0_DIFFUSE       0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_0_INPUT         0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_0_TEXTURE0      0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_0_TEXTURE1      0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_INVERSE_1                       8:8 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLOR_INVERSE_1_NORMAL         0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_INVERSE_1_INVERSE        0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ALPHA_1                         9:9 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLOR_ALPHA_1_COLOR            0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ALPHA_1_ALPHA            0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_1                    12:10 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_1_ZERO          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_1_FACTOR        0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_1_DIFFUSE       0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_1_INPUT         0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_1_TEXTURE0      0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_1_TEXTURE1      0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_INVERSE_2                     16:16 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLOR_INVERSE_2_NORMAL         0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_INVERSE_2_INVERSE        0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ALPHA_2                       17:17 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLOR_ALPHA_2_COLOR            0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ALPHA_2_ALPHA            0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_2                    20:18 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_2_ZERO          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_2_FACTOR        0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_2_DIFFUSE       0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_2_INPUT         0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_2_TEXTURE0      0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_2_TEXTURE1      0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_INVERSE_3                     24:24 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLOR_INVERSE_3_NORMAL         0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_INVERSE_3_INVERSE        0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ALPHA_3                       25:25 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLOR_ALPHA_3_COLOR            0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ALPHA_3_ALPHA            0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_3                    28:26 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_3_ZERO          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_3_FACTOR        0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_3_DIFFUSE       0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_3_INPUT         0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_3_TEXTURE0      0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_3_TEXTURE1      0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_OPERATION                     31:29 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLOR_OPERATION_ADD            0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_OPERATION_ADD2           0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_OPERATION_ADD4           0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_OPERATION_ADDSIGNED      0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_OPERATION_MUX            0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_OPERATION_ADDCOMPLEMENT  0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_OPERATION_ADDSIGNED2     0x00000007 /* RW--V */
#define NV_PGRAPH_DMA_START_0                            0x00401000 /* RW-4R */
#define NV_PGRAPH_DMA_START_0_VALUE                            31:0 /* RWXUF */
#define NV_PGRAPH_DMA_START_1                            0x00401004 /* RW-4R */
#define NV_PGRAPH_DMA_START_1_VALUE                            31:0 /* RWXUF */
#define NV_PGRAPH_DMA_LENGTH                             0x00401008 /* RW-4R */
#define NV_PGRAPH_DMA_LENGTH_VALUE                             21:0 /* RWXUF */
#define NV_PGRAPH_DMA_MISC                               0x0040100C /* RW-4R */
#define NV_PGRAPH_DMA_MISC_COUNT                               15:0 /* RWXUF */
#define NV_PGRAPH_DMA_MISC_FMT_SRC                            18:16 /* RWXVF */
#define NV_PGRAPH_DMA_MISC_FMT_DST                            22:20 /* RWXVF */
#define NV_PGRAPH_DMA_DATA_0                             0x00401020 /* RW-4R */
#define NV_PGRAPH_DMA_DATA_0_VALUE                             31:0 /* RWXUF */
#define NV_PGRAPH_DMA_DATA_1                             0x00401024 /* RW-4R */
#define NV_PGRAPH_DMA_DATA_1_VALUE                             31:0 /* RWXUF */
#define NV_PGRAPH_DMA_RM                                 0x00401030 /* RW-4R */
#define NV_PGRAPH_DMA_RM_ASSIST_A                               0:0 /* RWIVF */
#define NV_PGRAPH_DMA_RM_ASSIST_A_NOT_PENDING            0x00000000 /* R-I-V */
#define NV_PGRAPH_DMA_RM_ASSIST_A_PENDING                0x00000001 /* R---V */
#define NV_PGRAPH_DMA_RM_ASSIST_A_RESET                  0x00000001 /* -W--C */
#define NV_PGRAPH_DMA_RM_ASSIST_B                               1:1 /* RWIVF */
#define NV_PGRAPH_DMA_RM_ASSIST_B_NOT_PENDING            0x00000000 /* R-I-V */
#define NV_PGRAPH_DMA_RM_ASSIST_B_PENDING                0x00000001 /* R---V */
#define NV_PGRAPH_DMA_RM_ASSIST_B_RESET                  0x00000001 /* -W--C */
#define NV_PGRAPH_DMA_RM_WRITE_REQ                              4:4 /* CWIVF */
#define NV_PGRAPH_DMA_RM_WRITE_REQ_NOT_PENDING           0x00000000 /* CWI-V */
#define NV_PGRAPH_DMA_RM_WRITE_REQ_PENDING               0x00000001 /* -W--T */
#define NV_PGRAPH_DMA_A_XLATE_INST                       0x00401040 /* RW-4R */
#define NV_PGRAPH_DMA_A_XLATE_INST_VALUE                       15:0 /* RWXUF */
#define NV_PGRAPH_DMA_A_CONTROL                          0x00401044 /* RW-4R */
#define NV_PGRAPH_DMA_A_CONTROL_PAGE_TABLE                    12:12 /* RWIVF */
#define NV_PGRAPH_DMA_A_CONTROL_PAGE_TABLE_NOT_PRESENT   0x00000000 /* RWI-V */
#define NV_PGRAPH_DMA_A_CONTROL_PAGE_TABLE_PRESENT       0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_A_CONTROL_PAGE_ENTRY                    13:13 /* RWXVF */
#define NV_PGRAPH_DMA_A_CONTROL_PAGE_ENTRY_NOT_LINEAR    0x00000000 /* RW--V */
#define NV_PGRAPH_DMA_A_CONTROL_PAGE_ENTRY_LINEAR        0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_A_CONTROL_TARGET_NODE                   17:16 /* RWXUF */
#define NV_PGRAPH_DMA_A_CONTROL_TARGET_NODE_NVM          0x00000000 /* RW--V */
#define NV_PGRAPH_DMA_A_CONTROL_TARGET_NODE_PCI          0x00000002 /* RW--V */
#define NV_PGRAPH_DMA_A_CONTROL_TARGET_NODE_AGP          0x00000003 /* RW--V */
#define NV_PGRAPH_DMA_A_CONTROL_ADJUST                        31:20 /* RWXUF */
#define NV_PGRAPH_DMA_A_LIMIT                            0x00401048 /* RW-4R */
#define NV_PGRAPH_DMA_A_LIMIT_OFFSET                           31:0 /* RWXUF */
#define NV_PGRAPH_DMA_A_TLB_PTE                          0x0040104C /* RW-4R */
#define NV_PGRAPH_DMA_A_TLB_PTE_ACCESS                          1:1 /* RWXVF */
#define NV_PGRAPH_DMA_A_TLB_PTE_ACCESS_READ_ONLY         0x00000000 /* RW--V */
#define NV_PGRAPH_DMA_A_TLB_PTE_ACCESS_READ_WRITE        0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_A_TLB_PTE_FRAME_ADDRESS                 31:12 /* RWXUF */
#define NV_PGRAPH_DMA_A_TLB_TAG                          0x00401050 /* RW-4R */
#define NV_PGRAPH_DMA_A_TLB_TAG_ADDRESS                       31:12 /* RWXUF */
#define NV_PGRAPH_DMA_A_ADJ_OFFSET                       0x00401054 /* RW-4R */
#define NV_PGRAPH_DMA_A_ADJ_OFFSET_VALUE                       31:0 /* RWXUF */
#define NV_PGRAPH_DMA_A_OFFSET                           0x00401058 /* RW-4R */
#define NV_PGRAPH_DMA_A_OFFSET_VALUE                           31:0 /* RWXUF */
#define NV_PGRAPH_DMA_A_SIZE                             0x0040105C /* RW-4R */
#define NV_PGRAPH_DMA_A_SIZE_VALUE                             24:0 /* RWXUF */
#define NV_PGRAPH_DMA_A_Y_SIZE                           0x00401060 /* RW-4R */
#define NV_PGRAPH_DMA_A_Y_SIZE_VALUE                           10:0 /* RWXUF */
#define NV_PGRAPH_DMA_B_XLATE_INST                       0x00401080 /* RW-4R */
#define NV_PGRAPH_DMA_B_XLATE_INST_VALUE                       15:0 /* RWXUF */
#define NV_PGRAPH_DMA_B_CONTROL                          0x00401084 /* RW-4R */
#define NV_PGRAPH_DMA_B_CONTROL_PAGE_TABLE                    12:12 /* RWIVF */
#define NV_PGRAPH_DMA_B_CONTROL_PAGE_TABLE_NOT_PRESENT   0x00000000 /* RWI-V */
#define NV_PGRAPH_DMA_B_CONTROL_PAGE_TABLE_PRESENT       0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_B_CONTROL_PAGE_ENTRY                    13:13 /* RWXVF */
#define NV_PGRAPH_DMA_B_CONTROL_PAGE_ENTRY_NOT_LINEAR    0x00000000 /* RW--V */
#define NV_PGRAPH_DMA_B_CONTROL_PAGE_ENTRY_LINEAR        0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_B_CONTROL_TARGET_NODE                   17:16 /* RWXUF */
#define NV_PGRAPH_DMA_B_CONTROL_TARGET_NODE_NVM          0x00000000 /* RW--V */
#define NV_PGRAPH_DMA_B_CONTROL_TARGET_NODE_PCI          0x00000002 /* RW--V */
#define NV_PGRAPH_DMA_B_CONTROL_TARGET_NODE_AGP          0x00000003 /* RW--V */
#define NV_PGRAPH_DMA_B_CONTROL_ADJUST                        31:20 /* RWXUF */
#define NV_PGRAPH_DMA_B_LIMIT                            0x00401088 /* RW-4R */
#define NV_PGRAPH_DMA_B_LIMIT_OFFSET                           31:0 /* RWXUF */
#define NV_PGRAPH_DMA_B_TLB_PTE                          0x0040108C /* RW-4R */
#define NV_PGRAPH_DMA_B_TLB_PTE_ACCESS                          1:1 /* RWXVF */
#define NV_PGRAPH_DMA_B_TLB_PTE_ACCESS_READ_ONLY         0x00000000 /* RW--V */
#define NV_PGRAPH_DMA_B_TLB_PTE_ACCESS_READ_WRITE        0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_B_TLB_PTE_FRAME_ADDRESS                 31:12 /* RWXUF */
#define NV_PGRAPH_DMA_B_TLB_TAG                          0x00401090 /* RW-4R */
#define NV_PGRAPH_DMA_B_TLB_TAG_ADDRESS                       31:12 /* RWXUF */
#define NV_PGRAPH_DMA_B_ADJ_OFFSET                       0x00401094 /* RW-4R */
#define NV_PGRAPH_DMA_B_ADJ_OFFSET_VALUE                       31:0 /* RWXUF */
#define NV_PGRAPH_DMA_B_OFFSET                           0x00401098 /* RW-4R */
#define NV_PGRAPH_DMA_B_OFFSET_VALUE                           31:0 /* RWXUF */
#define NV_PGRAPH_DMA_B_SIZE                             0x0040109C /* RW-4R */
#define NV_PGRAPH_DMA_B_SIZE_VALUE                             24:0 /* RWXUF */
#define NV_PGRAPH_DMA_B_Y_SIZE                           0x004010A0 /* RW-4R */
#define NV_PGRAPH_DMA_B_Y_SIZE_VALUE                           10:0 /* RWXUF */
#define NV_PGRAPH_CONTROL_OUT_INTERPOLATOR                      1:0 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_INTERPOLATOR_ZOH_MS        0x00000000 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_INTERPOLATOR_ZOH           0x00000001 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_INTERPOLATOR_FOH           0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_U                            5:4 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_WRAP_U_CYLINDRICAL         0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_U_WRAP                0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_U_MIRROR              0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_U_CLAMP               0x00000003 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_V                            7:6 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_WRAP_V_CYLINDRICAL         0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_V_WRAP                0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_V_MIRROR              0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_V_CLAMP               0x00000003 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_COLOR_FORMAT                      8:8 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_COLOR_FORMAT_LE_X8R8G8B8   0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_COLOR_FORMAT_LE_A8R8G8B8   0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_SRCCOLOR                        11:10 /* -W-UF */
#define NV_PGRAPH_CONTROL_OUT_SRCCOLOR_NORMAL            0x00000000 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_SRCCOLOR_COLOR_INVERSE     0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_SRCCOLOR_ALPHA_INVERSE     0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_SRCCOLOR_ALPHA_ONE         0x00000003 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_CULLING                         13:12 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_CULLING_ILLEGAL            0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_CULLING_NONE               0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_CULLING_COUNTERCLOCKWISE   0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_CULLING_CLOCKWISE          0x00000003 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZBUFFER                         15:15 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_ZBUFFER_SCREEN             0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_ZBUFFER_LINEAR             0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE                    19:16 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_ILLEGAL       0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_FALSE         0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_LT            0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_EQ            0x00000003 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_LE            0x00000004 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_GT            0x00000005 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_NE            0x00000006 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_GE            0x00000007 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_TRUE          0x00000008 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_WRITE                      22:20 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_ZETA_WRITE_NEVER           0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_WRITE_ALPHA           0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_WRITE_ALPHA_ZETA      0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_WRITE_ZETA            0x00000003 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_WRITE_ALWAYS          0x00000004 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_COLOR_WRITE                     26:24 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_COLOR_WRITE_NEVER          0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_COLOR_WRITE_ALPHA          0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_COLOR_WRITE_ALPHA_ZETA     0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_COLOR_WRITE_ZETA           0x00000003 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ROP                             28:28 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_ROP_BLEND_AND              0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_ROP_ADD_WITH_SATURATION    0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_BLEND_BETA                      29:29 /* -W-UF */
#define NV_PGRAPH_CONTROL_OUT_BLEND_BETA_SRCALPHA        0x00000000 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_BLEND_BETA_DESTCOLOR       0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_BLEND_INPUT0                    30:30 /* -W-UF */
#define NV_PGRAPH_CONTROL_OUT_BLEND_INPUT0_DESTCOLOR     0x00000000 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_BLEND_INPUT0_ZERO          0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_BLEND_INPUT1                    31:31 /* -W-UF */
#define NV_PGRAPH_CONTROL_OUT_BLEND_INPUT1_SRCCOLOR      0x00000000 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_BLEND_INPUT1_ZERO          0x00000001 /* -W-UV */
#define NV_PGRAPH_ALPHACNTRL_ALPHA_KEY                          7:0 /* RWXUF */
#define NV_PGRAPH_ALPHACNTRL_ALPHA_COMPARE                     11:8 /* RWXVF */
#define NV_PGRAPH_ALPHACNTRL_ALPHA_COMPARE_ILLEGAL       0x00000000 /* RW--V */
#define NV_PGRAPH_ALPHACNTRL_ALPHA_COMPARE_FALSE         0x00000001 /* RW--V */
#define NV_PGRAPH_ALPHACNTRL_ALPHA_COMPARE_LT            0x00000002 /* RW--V */
#define NV_PGRAPH_ALPHACNTRL_ALPHA_COMPARE_EQ            0x00000003 /* RW--V */
#define NV_PGRAPH_ALPHACNTRL_ALPHA_COMPARE_LE            0x00000004 /* RW--V */
#define NV_PGRAPH_ALPHACNTRL_ALPHA_COMPARE_GT            0x00000005 /* RW--V */
#define NV_PGRAPH_ALPHACNTRL_ALPHA_COMPARE_NE            0x00000006 /* RW--V */
#define NV_PGRAPH_ALPHACNTRL_ALPHA_COMPARE_GE            0x00000007 /* RW--V */
#define NV_PGRAPH_ALPHACNTRL_ALPHA_COMPARE_TRUE          0x00000008 /* RW--V */
/* dev_video.ref */
#define NV_PVIDEO                             0x006802FF:0x00680000 /* RW--D */
#define NV_PVIDEO_INTR_0                                 0x00680100 /* RWI4R */
#define NV_PVIDEO_INTR_0_NOTIFY                                 0:0 /* RWIVF */
#define NV_PVIDEO_INTR_0_NOTIFY_NOT_PENDING              0x00000000 /* R-I-V */
#define NV_PVIDEO_INTR_0_NOTIFY_PENDING                  0x00000001 /* R---V */
#define NV_PVIDEO_INTR_0_NOTIFY_RESET                    0x00000001 /* -W--V */
#define NV_PVIDEO_INTR_EN_0                              0x00680140 /* RWI4R */
#define NV_PVIDEO_INTR_EN_0_NOTIFY                              0:0 /* RWIVF */
#define NV_PVIDEO_INTR_EN_0_NOTIFY_DISABLED              0x00000000 /* RWI-V */
#define NV_PVIDEO_INTR_EN_0_NOTIFY_ENABLED               0x00000001 /* RW--V */
#define NV_PVIDEO_STEP_SIZE                              0x00680200 /* RW-4R */
#define NV_PVIDEO_STEP_SIZE_X                                  11:0 /* RWXVF */
#define NV_PVIDEO_STEP_SIZE_Y                                 27:16 /* RWXVF */
#define NV_PVIDEO_CONTROL_Y                              0x00680204 /* RW-4R */
#define NV_PVIDEO_CONTROL_Y_BLUR                                0:0 /* RW--F */
#define NV_PVIDEO_CONTROL_Y_BLUR_OFF                     0x00000000 /* RW--V */
#define NV_PVIDEO_CONTROL_Y_BLUR_ON                      0x00000001 /* RW--V */
#define NV_PVIDEO_CONTROL_Y_LINE                                4:4 /* RW--F */
#define NV_PVIDEO_CONTROL_Y_LINE_HALF                    0x00000000 /* RW--V */
#define NV_PVIDEO_CONTROL_Y_LINE_FULL                    0x00000001 /* RW--V */
#define NV_PVIDEO_CONTROL_X                              0x00680208 /* RW-4R */
#define NV_PVIDEO_CONTROL_X_WEIGHT                              0:0 /* RW--F */
#define NV_PVIDEO_CONTROL_X_WEIGHT_LIGHT                 0x00000000 /* RW--V */
#define NV_PVIDEO_CONTROL_X_WEIGHT_HEAVY                 0x00000001 /* RW--V */
#define NV_PVIDEO_CONTROL_X_SHARPENING                          4:4 /* RW--F */
#define NV_PVIDEO_CONTROL_X_SHARPENING_OFF               0x00000000 /* RW--V */
#define NV_PVIDEO_CONTROL_X_SHARPENING_ON                0x00000001 /* RW--V */
#define NV_PVIDEO_CONTROL_X_SMOOTHING                           8:8 /* RW--F */
#define NV_PVIDEO_CONTROL_X_SMOOTHING_OFF                0x00000000 /* RW--V */
#define NV_PVIDEO_CONTROL_X_SMOOTHING_ON                 0x00000001 /* RW--V */
#define NV_PVIDEO_BUFF0_START                            0x0068020c /* RW-4R */
#define NV_PVIDEO_BUFF0_START_ADDRESS                          23:2 /* RW-UF */
#define NV_PVIDEO_BUFF1_START                            0x00680210 /* RW-4R */
#define NV_PVIDEO_BUFF1_START_ADDRESS                          23:2 /* RW-UF */
#define NV_PVIDEO_BUFF0_PITCH                            0x00680214 /* RW-4R */
#define NV_PVIDEO_BUFF0_PITCH_LENGTH                           13:4 /* RW-UF */
#define NV_PVIDEO_BUFF1_PITCH                            0x00680218 /* RW-4R */
#define NV_PVIDEO_BUFF1_PITCH_LENGTH                           13:4 /* RW-UF */
#define NV_PVIDEO_BUFF0_OFFSET                           0x0068021c /* RW-4R */
#define NV_PVIDEO_BUFF0_OFFSET_X                                0:0 /* RW--F */
#define NV_PVIDEO_BUFF0_OFFSET_Y                                5:4 /* RW--F */
#define NV_PVIDEO_BUFF0_OFFSET_Y_OFF                     0x00000000 /* RW--V */
#define NV_PVIDEO_BUFF0_OFFSET_Y_QUARTER                 0x00000001 /* RW--V */
#define NV_PVIDEO_BUFF0_OFFSET_Y_HALF                    0x00000002 /* RW--V */
#define NV_PVIDEO_BUFF1_OFFSET                           0x00680220 /* RW-4R */
#define NV_PVIDEO_BUFF1_OFFSET_X                                0:0 /* RW--F */
#define NV_PVIDEO_BUFF1_OFFSET_Y                                5:4 /* RW--F */
#define NV_PVIDEO_BUFF1_OFFSET_Y_OFF                     0x00000000 /* RW--V */
#define NV_PVIDEO_BUFF1_OFFSET_Y_QUARTER                 0x00000001 /* RW--V */
#define NV_PVIDEO_BUFF1_OFFSET_Y_HALF                    0x00000002 /* RW--V */
#define NV_PVIDEO_OE_STATE                               0x00680224 /* RW-4R */
#define NV_PVIDEO_OE_STATE_BUFF0_INTR_NOTIFY                    0:0 /* RWXVF */
#define NV_PVIDEO_OE_STATE_BUFF1_INTR_NOTIFY                    4:4 /* RWXVF */
#define NV_PVIDEO_OE_STATE_BUFF0_ERROR                          8:8 /* RWXVF */
#define NV_PVIDEO_OE_STATE_BUFF1_ERROR                        12:12 /* RWXVF */
#define NV_PVIDEO_OE_STATE_BUFF0_IN_USE                       16:16 /* RWXVF */
#define NV_PVIDEO_OE_STATE_BUFF1_IN_USE                       20:20 /* RWXVF */
#define NV_PVIDEO_OE_STATE_CURRENT_BUFFER                     24:24 /* RWXVF */
#define NV_PVIDEO_OE_STATE_CURRENT_BUFFER_0              0x00000000 /* RW--V */
#define NV_PVIDEO_OE_STATE_CURRENT_BUFFER_1              0x00000001 /* RW--V */
#define NV_PVIDEO_SU_STATE                               0x00680228 /* RW-4R */
#define NV_PVIDEO_SU_STATE_BUFF0_IN_USE                       16:16 /* RWXVF */
#define NV_PVIDEO_SU_STATE_BUFF1_IN_USE                       20:20 /* RWXVF */
#define NV_PVIDEO_RM_STATE                               0x0068022c /* RW-4R */
#define NV_PVIDEO_RM_STATE_BUFF0_INTR_NOTIFY                    0:0 /* RWXVF */
#define NV_PVIDEO_RM_STATE_BUFF1_INTR_NOTIFY                    4:4 /* RWXVF */
#define NV_PVIDEO_WINDOW_START                           0x00680230 /* RW-4R */
#define NV_PVIDEO_WINDOW_START_X                               10:0 /* RWXUF */
#define NV_PVIDEO_WINDOW_START_Y                              26:16 /* RWXUF */
#define NV_PVIDEO_WINDOW_SIZE                            0x00680234 /* RW-4R */
#define NV_PVIDEO_WINDOW_SIZE_X                                10:0 /* RWXUF */
#define NV_PVIDEO_WINDOW_SIZE_Y                               26:16 /* RWXUF */
#define NV_PVIDEO_FIFO_THRES                             0x00680238 /* RW-4R */
#define NV_PVIDEO_FIFO_THRES_SIZE                               7:3 /* RW--F */
#define NV_PVIDEO_FIFO_BURST                             0x0068023c /* RW-4R */
#define NV_PVIDEO_FIFO_BURST_LENGTH                             1:0 /* RW--F */
#define NV_PVIDEO_FIFO_BURST_LENGTH_32                   0x00000001 /* RW--V */
#define NV_PVIDEO_FIFO_BURST_LENGTH_64                   0x00000002 /* RW--V */
#define NV_PVIDEO_FIFO_BURST_LENGTH_128                  0x00000003 /* RW--V */
#define NV_PVIDEO_KEY                                    0x00680240 /* RW-4R */
#define NV_PVIDEO_KEY_INDEX                                     7:0 /* RW-VF */
#define NV_PVIDEO_KEY_565                                      15:0 /* RW-VF */
#define NV_PVIDEO_KEY_555                                      14:0 /* RW-VF */
#define NV_PVIDEO_KEY_888                                      23:0 /* RW-VF */
#define NV_PVIDEO_KEY_PACK                                    31:24 /* RW-VF */
#define NV_PVIDEO_OVERLAY                                0x00680244 /* RWI4R */
#define NV_PVIDEO_OVERLAY_VIDEO                                 0:0 /* RWI-F */
#define NV_PVIDEO_OVERLAY_VIDEO_OFF                      0x00000000 /* RWI-V */
#define NV_PVIDEO_OVERLAY_VIDEO_ON                       0x00000001 /* RW--V */
#define NV_PVIDEO_OVERLAY_KEY                                   4:4 /* RW--F */
#define NV_PVIDEO_OVERLAY_KEY_OFF                        0x00000000 /* RW--V */
#define NV_PVIDEO_OVERLAY_KEY_ON                         0x00000001 /* RW--V */
#define NV_PVIDEO_OVERLAY_FORMAT                                8:8 /* RW--F */
#define NV_PVIDEO_OVERLAY_FORMAT_CCIR                    0x00000000 /* RW--V */
#define NV_PVIDEO_OVERLAY_FORMAT_YUY2                    0x00000001 /* RW--V */
#define NV_PVIDEO_RED_CSC                                0x00680280 /* RW-4R */
#define NV_PVIDEO_RED_CSC_OFFSET                                7:0 /* RWX-F */
#define NV_PVIDEO_GREEN_CSC                              0x00680284 /* RW-4R */
#define NV_PVIDEO_GREEN_CSC_OFFSET                              7:0 /* RWX-F */
#define NV_PVIDEO_BLUE_CSC                               0x00680288 /* RW-4R */
#define NV_PVIDEO_BLUE_CSC_OFFSET                               7:0 /* RWX-F */
#define NV_PVIDEO_CSC_ADJUST                             0x0068028c /* RW-4R */
#define NV_PVIDEO_CSC_ADJUST_B_FLAG                             0:0 /* RW--F */
#define NV_PVIDEO_CSC_ADJUST_B_FLAG_OFF                  0x00000000 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_B_FLAG_ON                   0x00000001 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_G_FLAG                             4:4 /* RW--F */
#define NV_PVIDEO_CSC_ADJUST_G_FLAG_OFF                  0x00000000 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_G_FLAG_ON                   0x00000001 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_R_FLAG                             8:8 /* RW--F */
#define NV_PVIDEO_CSC_ADJUST_R_FLAG_OFF                  0x00000000 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_R_FLAG_ON                   0x00000001 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_L_FLAG                           12:12 /* RW--F */
#define NV_PVIDEO_CSC_ADJUST_L_FLAG_OFF                  0x00000000 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_L_FLAG_ON                   0x00000001 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_CHROMA                           16:16 /* RW--F */
#define NV_PVIDEO_CSC_ADJUST_CHROMA_OFF                  0x00000000 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_CHROMA_ON                   0x00000001 /* RW--V */
/* dev_vga.ref */
#define NV_PRMCIO                             0x00601FFF:0x00601000 /* RW--D */
#define NV_PRMCIO_INP0                                   0x006013c2 /* R--1R */
#define NV_PRMCIO_INP0__MONO                             0x006013ba /* R--1R */
#define NV_PRMCIO_INP0__COLOR                            0x006013da /* R--1R */
#define NV_PRMCIO_INP0__READ_MONO                        0x006013ca /* R--1R */
#define NV_PRMCIO_INP0__WRITE_MONO                       0x006013ba /* -W-1R */
#define NV_PRMCIO_INP0__WRITE_COLOR                      0x006013da /* -W-1R */
#define NV_PRMCIO_ARX                                    0x006013c0 /* RW-1R */
#define NV_PRMCIO_AR_PALETTE__WRITE                      0x006013c0 /* -W-1R */
#define NV_PRMCIO_AR_PALETTE__READ                       0x006013c1 /* R--1R */
#define NV_PRMCIO_AR_MODE__WRITE                         0x006013c0 /* -W-1R */
#define NV_PRMCIO_AR_MODE__READ                          0x006013c1 /* R--1R */
#define NV_PRMCIO_AR_MODE_INDEX                          0x00000010 /*       */
#define NV_PRMCIO_AR_OSCAN__WRITE                        0x006013c0 /* -W-1R */
#define NV_PRMCIO_AR_OSCAN__READ                         0x006013c1 /* R--1R */
#define NV_PRMCIO_AR_OSCAN_INDEX                         0x00000011 /*       */
#define NV_PRMCIO_AR_PLANE__WRITE                        0x006013c0 /* -W-1R */
#define NV_PRMCIO_AR_PLANE__READ                         0x006013c1 /* R--1R */
#define NV_PRMCIO_AR_PLANE_INDEX                         0x00000012 /*       */
#define NV_PRMCIO_AR_HPP__WRITE                          0x006013c0 /* -W-1R */
#define NV_PRMCIO_AR_HPP__READ                           0x006013c1 /* R--1R */
#define NV_PRMCIO_AR_HPP_INDEX                           0x00000013 /*       */
#define NV_PRMCIO_AR_CSEL__WRITE                         0x006013c0 /* -W-1R */
#define NV_PRMCIO_AR_CSEL__READ                          0x006013c1 /* R--1R */
#define NV_PRMCIO_AR_CSEL_INDEX                          0x00000014 /*       */
#define NV_PRMCIO_CRX__MONO                              0x006013b4 /* RW-1R */
#define NV_PRMCIO_CRX__COLOR                             0x006013d4 /* RW-1R */
#define NV_PRMCIO_CR__MONO                               0x006013b5 /* RW-1R */
#define NV_PRMCIO_CR__COLOR                              0x006013d5 /* RW-1R */
#define NV_PRMCIO_CRE__MONO                              0x006013b5 /* RW-1R */
#define NV_PRMCIO_CRE__COLOR                             0x006013d5 /* RW-1R */
/* dev_vga.ref */
#define NV_PCRTC_INTR_0                                  0x00600100 /* RWI4R */
#define NV_PCRTC_INTR_0_VBLANK                                  0:0 /* RWI-F */
#define NV_PCRTC_INTR_0_VBLANK_NOT_PENDING               0x00000000 /* R-I-V */
#define NV_PCRTC_INTR_0_VBLANK_PENDING                   0x00000001 /* R---V */
#define NV_PCRTC_INTR_0_VBLANK_RESET                     0x00000001 /* -W--V */
#define NV_PCRTC_INTR_EN_0                               0x00600140 /* RWI4R */
#define NV_PCRTC_INTR_EN_0_VBLANK                               0:0 /* RWIVF */
#define NV_PCRTC_INTR_EN_0_VBLANK_DISABLED               0x00000000 /* RWI-V */
#define NV_PCRTC_INTR_EN_0_VBLANK_ENABLED                0x00000001 /* RW--V */
#define NV_PCRTC_START                                   0x00600800 /* RWI4R */
#define NV_PCRTC_START_ADDRESS                                 24:2 /* RWI-F */
#define NV_PCRTC_CONFIG                                  0x00600804 /* RWI4R */
#define NV_PCRTC_CONFIG_START_ADDRESS                           0:0 /* RWI-F */
#define NV_PCRTC_CONFIG_START_ADDRESS_VGA                0x00000000 /* RWI-V */
#define NV_PCRTC_CONFIG_START_ADDRESS_NON_VGA            0x00000001 /* RW--V */
#define NV_PCRTC_RASTER                                  0x00600808 /* R-I4R */
#define NV_PCRTC_RASTER_POSITION                               10:0 /* R---F */
#define NV_PCRTC_RASTER_SA_LOAD                               13:12 /* R---F */
#define NV_PCRTC_RASTER_SA_LOAD_DISPLAY                  0x00000000 /* R---V */
#define NV_PCRTC_RASTER_SA_LOAD_BEFORE                   0x00000001 /* R---V */
#define NV_PCRTC_RASTER_SA_LOAD_AFTER                    0x00000002 /* R---V */
#define NV_PCRTC_RASTER_VERT_BLANK                            16:16 /* R---F */
#define NV_PCRTC_RASTER_VERT_BLANK_ACTIVE                0x00000001 /* R---V */
#define NV_PCRTC_RASTER_VERT_BLANK_INACTIVE              0x00000000 /* R---V */
/* dev_vga.ref */
#define NV_CIO                                          0x3DF:0x3B0 /* ----D */
#define NV_CIO_INP0                                      0x000003c2 /* R--1R */
#define NV_CIO_INP0__MONO                                0x000003ba /* R--1R */
#define NV_CIO_INP0__COLOR                               0x000003da /* R--1R */
#define NV_CIO_INP0__READ_MONO                           0x000003ca /* R--1R */
#define NV_CIO_INP0__WRITE_MONO                          0x000003ba /* -W-1R */
#define NV_CIO_INP0__WRITE_COLOR                         0x000003da /* -W-1R */
#define NV_CIO_ARX                                       0x000003c0 /* RW-1R */
#define NV_CIO_AR_PALETTE__WRITE                         0x000003c0 /* -W-1R */
#define NV_CIO_AR_PALETTE__READ                          0x000003c1 /* R--1R */
#define NV_CIO_AR_MODE__WRITE                            0x000003c0 /* -W-1R */
#define NV_CIO_AR_MODE__READ                             0x000003c1 /* R--1R */
#define NV_CIO_AR_MODE_INDEX                             0x00000010 /*       */
#define NV_CIO_AR_OSCAN__WRITE                           0x000003c0 /* -W-1R */
#define NV_CIO_AR_OSCAN__READ                            0x000003c1 /* R--1R */
#define NV_CIO_AR_OSCAN_INDEX                            0x00000011 /*       */
#define NV_CIO_AR_PLANE__WRITE                           0x000003c0 /* -W-1R */
#define NV_CIO_AR_PLANE__READ                            0x000003c1 /* R--1R */
#define NV_CIO_AR_PLANE_INDEX                            0x00000012 /*       */
#define NV_CIO_AR_HPP__WRITE                             0x000003c0 /* -W-1R */
#define NV_CIO_AR_HPP__READ                              0x000003c1 /* R--1R */
#define NV_CIO_AR_HPP_INDEX                              0x00000013 /*       */
#define NV_CIO_AR_CSEL__WRITE                            0x000003c0 /* -W-1R */
#define NV_CIO_AR_CSEL__READ                             0x000003c1 /* R--1R */
#define NV_CIO_AR_CSEL_INDEX                             0x00000014 /*       */
#define NV_CIO_CRX__MONO                                 0x000003b4 /* RW-1R */
#define NV_CIO_CRX__COLOR                                0x000003d4 /* RW-1R */
#define NV_CIO_CR__MONO                                  0x000003b5 /* RW-1R */
#define NV_CIO_CR__COLOR                                 0x000003d5 /* RW-1R */
#define NV_CIO_CR_HDT_INDEX                              0x00000000 /*       */
#define NV_CIO_CR_HDE_INDEX                              0x00000001 /*       */
#define NV_CIO_CR_HBS_INDEX                              0x00000002 /*       */
#define NV_CIO_CR_HBE_INDEX                              0x00000003 /*       */
#define NV_CIO_CR_HBE_4_0                                       4:0 /* RW--F */
#define NV_CIO_CR_HRS_INDEX                              0x00000004 /*       */
#define NV_CIO_CR_HRE_INDEX                              0x00000005 /*       */
#define NV_CIO_CR_HRE_HBE_5                                     7:7 /* RW--F */
#define NV_CIO_CR_HRE_4_0                                       4:0 /* RW--F */
#define NV_CIO_CR_VDT_INDEX                              0x00000006 /*       */
#define NV_CIO_CR_OVL_INDEX                              0x00000007 /*       */
#define NV_CIO_CR_OVL_VDE_8                                     1:1 /* RW--F */
#define NV_CIO_CR_OVL_VDE_9                                     6:6 /* RW--F */
#define NV_CIO_CR_OVL_VDT_8                                     0:0 /* RW--F */
#define NV_CIO_CR_OVL_VDT_9                                     5:5 /* RW--F */
#define NV_CIO_CR_OVL_VBS_8                                     3:3 /* RW--F */
#define NV_CIO_CR_OVL_VRS_8                                     2:2 /* RW--F */
#define NV_CIO_CR_OVL_VRS_9                                     7:7 /* RW--F */
#define NV_CIO_CR_RSAL_INDEX                             0x00000008 /*       */
#define NV_CIO_CR_RSAL_PANNING                                  6:5 /* RW--F */
#define NV_CIO_CR_CELL_HT_INDEX                          0x00000009 /*       */
#define NV_CIO_CR_CELL_HT_SCANDBL                               7:7 /* RW--F */
#define NV_CIO_CR_CELL_HT_VBS_9                                 5:5 /* RW--F */
#define NV_CIO_CR_CURS_ST_INDEX                          0x0000000A /*       */
#define NV_CIO_CR_CURS_END_INDEX                         0x0000000B /*       */
#define NV_CIO_CR_SA_HI_INDEX                            0x0000000C /*       */
#define NV_CIO_CR_SA_LO_INDEX                            0x0000000D /*       */
#define NV_CIO_CR_TCOFF_HI_INDEX                         0x0000000E /*       */
#define NV_CIO_CR_TCOFF_LO_INDEX                         0x0000000F /*       */
#define NV_CIO_CR_VRS_INDEX                              0x00000010 /*       */
#define NV_CIO_CR_VRE_INDEX                              0x00000011 /*       */
#define NV_CIO_CR_VRE_3_0                                       3:0 /* RW--F */
#define NV_CIO_CR_VDE_INDEX                              0x00000012 /*       */
#define NV_CIO_CR_OFFSET_INDEX                           0x00000013 /*       */
#define NV_CIO_CR_ULINE_INDEX                            0x00000014 /*       */
#define NV_CIO_CR_VBS_INDEX                              0x00000015 /*       */
#define NV_CIO_CR_VBE_INDEX                              0x00000016 /*       */
#define NV_CIO_CR_MODE_INDEX                             0x00000017 /*       */
#define NV_CIO_CR_LCOMP_INDEX                            0x00000018 /*       */
#define NV_CIO_CR_GDATA_INDEX                            0x00000022 /*       */
#define NV_CIO_CR_ARFF_INDEX                             0x00000024 /*       */
#define NV_CIO_CR_ARX_INDEX                              0x00000026 /*       */
#define NV_CIO_CRE__MONO                                 0x000003b5 /* RW-1R */
#define NV_CIO_CRE__COLOR                                0x000003d5 /* RW-1R */
#define NV_CIO_CRE_RPC0_INDEX                            0x00000019 /*       */
#define NV_CIO_CRE_RPC0_START                                   4:0 /* RW--F */
#define NV_CIO_CRE_RPC0_OFFSET_10_8                             7:5 /* RW--F */
#define NV_CIO_CRE_RPC1_INDEX                            0x0000001A /*       */
#define NV_CIO_CRE_RPC1_LARGE                                  2:2 /* RW--F */
#define NV_CIO_CRE_FF_INDEX                              0x0000001B /*       */
#define NV_CIO_CRE_FF_BURST                                     2:0 /* RW--F */
#define NV_CIO_CRE_FF_BURST_8                            0x00000000 /* RW--V */
#define NV_CIO_CRE_FF_BURST_32                           0x00000001 /* RW--V */
#define NV_CIO_CRE_FF_BURST_64                           0x00000002 /* RW--V */
#define NV_CIO_CRE_FF_BURST_128                          0x00000003 /* RW--V */
#define NV_CIO_CRE_FF_BURST_256                          0x00000004 /* RW--V */
#define NV_CIO_CRE_ENH_INDEX                             0x0000001C /*       */
#define NV_CIO_CRE_PAGE0_INDEX                           0x0000001D /*       */
#define NV_CIO_CRE_PAGE1_INDEX                           0x0000001E /*       */
#define NV_CIO_SR_LOCK_INDEX                             0x0000001F /*       */
#define NV_CIO_SR_UNLOCK_RW_VALUE                            0x00000057 /*       */
#define NV_CIO_SR_UNLOCK_RO_VALUE                            0x00000075 /*       */
#define NV_CIO_SR_LOCK_VALUE                                 0x00000099 /*       */
#define NV_CIO_CRE_FFLWM__INDEX                          0x00000020 /*       */
#define NV_CIO_CRE_FFLWM_LWM                                    5:0 /* RW--F */
#define NV_CIO_CRE_FABID_INDEX                             0x00000025 /*       */
#define NV_CIO_CRE_LSR_INDEX                             0x00000025 /*       */
#define NV_CIO_CRE_LSR_VDE_10                                   1:1 /* RW--F */
#define NV_CIO_CRE_LSR_VDT_10                                   0:0 /* RW--F */
#define NV_CIO_CRE_LSR_HBE_6                                    4:4 /* RW--F */
#define NV_CIO_CRE_LSR_VBS_10                                   3:3 /* RW--F */
#define NV_CIO_CRE_LSR_VRS_10                                   2:2 /* RW--F */
#define NV_CIO_CRE_CHIP_ID_INDEX                        0x00000027 /*       */
#define NV_CIO_CRE_PIXEL_INDEX                           0x00000028 /*       */
#define NV_CIO_CRE_PIXEL_TV_ADJ                                 5:3 /* RW--F */
#define NV_CIO_CRE_PIXEL_FORMAT                                 1:0 /* RW--F */
#define NV_CIO_CRE_PIXEL_FORMAT_VGA                      0x00000000 /* RW--V */
#define NV_CIO_CRE_PIXEL_FORMAT_8BPP                     0x00000001 /* RW--V */
#define NV_CIO_CRE_PIXEL_FORMAT_16BPP                    0x00000002 /* RW--V */
#define NV_CIO_CRE_PIXEL_FORMAT_32BPP                    0x00000003 /* RW--V */
#define NV_CIO_CRE_PAGE_OVFL__INDEX                     0x00000029 /*       */
#define NV_CIO_CRE_OSCOL__INDEX                          0x0000002A /*       */
#define NV_CIO_CRE_SCRATCH0__INDEX                       0x0000002B /*       */
#define NV_CIO_CRE_SCRATCH1__INDEX                       0x0000002C /*       */
#define NV_CIO_CRE_HEB__INDEX                            0x0000002D /*       */
#define NV_CIO_CRE_HEB_SA_23                                    5:5 /* RW--F */
#define NV_CIO_CRE_HEB_ILC_8                                    4:4 /* RW--F */
#define NV_CIO_CRE_HEB_HRS_8                                    3:3 /* RW--F */
#define NV_CIO_CRE_HEB_HBS_8                                    2:2 /* RW--F */
#define NV_CIO_CRE_HEB_HDE_8                                    1:1 /* RW--F */
#define NV_CIO_CRE_HEB_HDT_8                                    0:0 /* RW--F */
#define NV_CIO_CRE_HCUR_ADDR2_INDEX                      0x0000002f /*       */
#define NV_CIO_CRE_HCUR_ADDR0_INDEX                      0x00000030 /*       */
#define NV_CIO_CRE_HCUR_ASI                                     7:7 /* RW--F */
#define NV_CIO_CRE_HCUR_ADDR0_ADR                               6:0 /* RW--F */
#define NV_CIO_CRE_HCUR_ADDR1_INDEX                      0x00000031 /*       */
#define NV_CIO_CRE_HCUR_ADDR1_ADR                               7:2 /* RW--F */
#define NV_CIO_CRE_HCUR_ADDR1_CUR_DBL                           1:1 /* RW--F */
#define NV_CIO_CRE_HCUR_ADDR1_ENABLE                            0:0 /* RW--F */
#define NV_CIO_CRE_VID_END0__INDEX                       0x00000032 /*       */
#define NV_CIO_CRE_VID_END_7_0                                  7:0 /* RW--F */
#define NV_CIO_CRE_VID_END1__INDEX                       0x00000033 /*       */
// NV5 specific
#define NV_CIO_CRE_LCD__INDEX                            0x00000033 /*       */
#define NV_CIO_CRE_VID_END_ENABLE                               4:4 /* RW--F */
#define NV_CIO_CRE_VID_END_10_8                                 2:0 /* RW--F */
#define NV_CIO_CRE_RL0__INDEX                            0x00000034 /*       */
#define NV_CIO_CRE_RL1__INDEX                            0x00000035 /*       */
#define NV_CIO_CRE_RMA__INDEX                            0x00000038 /*       */
#define NV_CIO_CRE_ILACE__INDEX                          0x00000039 /*       */
#define NV_CIO_CRE_SCRATCH2__INDEX                       0x0000003A /*       */
#define NV_CIO_CRE_SCRATCH3__INDEX                       0x0000003B /*       */
#define NV_CIO_CRE_SCRATCH4__INDEX                       0x0000003C /*       */
#define NV_CIO_CRE_TREG__INDEX                           0x0000003D /*       */
#define NV_CIO_CRE_TREG_HCNT                                    6:6 /* RW--F */
#define NV_CIO_CRE_TREG_VCNT                                    4:4 /* RW--F */
#define NV_CIO_CRE_TREG_SHADOW                                  0:0 /* RW--F */
#define NV_CIO_CRE_TREG_HCNT_INDEX                       0x00000000 /*       */
#define NV_CIO_CRE_TREG_VCNTA_INDEX                      0x00000006 /*       */
#define NV_CIO_CRE_TREG_VCNTB_INDEX                      0x00000007 /*       */
#define NV_CIO_CRE_DDC_STATUS__INDEX                     0x0000003E /*       */
#define NV_CIO_CRE_DDC_WR__INDEX                         0x0000003F /*       */
#define NV_CIO_CRE_PCI_TO__INDEX                          0x00000040 /*       */
#define NV_CIO_CRE_PCI_TO_DELAY                                  7:0 /* -W--F */

#define NV_CIO_CRE_H2OWNS                                0x00000044 /*       */
#define NV_CIO_CRE_H2OWNS_VGA                                   0:0 /* RW--F */
#define NV_CIO_CRE_H2OWNS_VGA_DEFAULT                    0x00000000 /* RWI-V */
#define NV_CIO_CRE_H2OWNS_VGA_DISABLE                    0x00000000 /* RW--V */
#define NV_CIO_CRE_H2OWNS_VGA_ENABLE                     0x00000001 /* RW--V */
#define NV_CIO_CRE_H2OWNS_DAC                                   1:1 /* RW--F */
#define NV_CIO_CRE_H2OWNS_DAC_DEFAULT                    0x00000000 /* RWI-V */
#define NV_CIO_CRE_H2OWNS_DAC_DISABLE                    0x00000000 /* RW--V */
#define NV_CIO_CRE_H2OWNS_DAC_ENABLE                     0x00000001 /* RW--V */
#define NV_CIO_CRE_H2OWNS_MIRROR                                2:2 /* RW--F */
#define NV_CIO_CRE_H2OWNS_MIRROR_DEFAULT                 0x00000000 /* RWI-V */
#define NV_CIO_CRE_H2OWNS_MIRROR_DISABLE                 0x00000000 /* RW--V */
#define NV_CIO_CRE_H2OWNS_MIRROR_ENABLE                  0x00000001 /* RW--V */

/* dev_vga.ref */
#define NV_VIO_MBEN                                      0x00000094 /* RW-1R */
#define NV_VIO_ADDEN                                     0x000046e8 /* RW-1R */
#define NV_VIO_VSE1                                      0x00000102 /* RW-1R */
#define NV_VIO_VSE2                                      0x000003c3 /* RW-1R */
#define NV_VIO_MISC__READ                                0x000003cc /* R--1R */
#define NV_VIO_MISC__WRITE                               0x000003c2 /* -W-1R */
#define NV_VIO_SRX                                       0x000003c4 /* RW-1R */
#define NV_VIO_SR_RESET                                  0x000003c5 /* RW-1R */
#define NV_VIO_SR_RESET_INDEX                            0x00000000 /*     V */
#define NV_VIO_SR_CLOCK                                  0x000003c5 /* RW-1R */
#define NV_VIO_SR_CLOCK_INDEX                            0x00000001 /*     V */
#define NV_VIO_SR_PLANE_MASK                             0x000003c5 /* RW-1R */
#define NV_VIO_SR_PLANE_MASK_INDEX                       0x00000002 /*     V */
#define NV_VIO_SR_CHAR_MAP                               0x000003c5 /* RW-1R */
#define NV_VIO_SR_CHAR_MAP_INDEX                         0x00000003 /*       */
#define NV_VIO_SR_MEM_MODE                               0x000003c5 /* RW-1R */
#define NV_VIO_SR_MEM_MODE_INDEX                         0x00000004 /*       */
#define NV_VIO_GRX                                       0x000003ce /* RW-1R */
#define NV_VIO_GX_SR                                     0x000003cf /* RW-1R */
#define NV_VIO_GX_SR_INDEX                               0x00000000 /*       */
#define NV_VIO_GX_SREN                                   0x000003cf /* RW-1R */
#define NV_VIO_GX_SREN_INDEX                             0x00000001 /*       */
#define NV_VIO_GX_CCOMP                                  0x000003cf /* RW-1R */
#define NV_VIO_GX_CCOMP_INDEX                            0x00000002 /*       */
#define NV_VIO_GX_ROP                                    0x000003cf /* RW-1R */
#define NV_VIO_GX_ROP_INDEX                              0x00000003 /*       */
#define NV_VIO_GX_READ_MAP                               0x000003cf /* RW-1R */
#define NV_VIO_GX_READ_MAP_INDEX                         0x00000004 /*       */
#define NV_VIO_GX_MODE                                   0x000003cf /* RW-1R */
#define NV_VIO_GX_MODE_INDEX                             0x00000005 /*       */
#define NV_VIO_GX_MISC                                   0x000003cf /* RW-1R */
#define NV_VIO_GX_MISC_INDEX                             0x00000006 /*       */
#define NV_VIO_GX_DONT_CARE                              0x000003cf /* RW-1R */
#define NV_VIO_GX_DONT_CARE_INDEX                        0x00000007 /*       */
#define NV_VIO_GX_BIT_MASK                               0x000003cf /* RW-1R */
#define NV_VIO_GX_BIT_MASK_INDEX                         0x00000008 /*       */
/* dev_vga.ref */
#define NV_PRMVIO                             0x000C7FFF:0x000C0000 /* RW--D */
#define NV_PRMVIO_MBEN                                   0x000C0094 /* RW-1R */
#define NV_PRMVIO_ADDEN                                  0x000C46e8 /* RW-1R */
#define NV_PRMVIO_VSE1                                   0x000C0102 /* RW-1R */
#define NV_PRMVIO_VSE2                                   0x000C03c3 /* RW-1R */
#define NV_PRMVIO_MISC__READ                             0x000C03cc /* R--1R */
#define NV_PRMVIO_MISC__WRITE                            0x000C03c2 /* -W-1R */
#define NV_PRMVIO_SRX                                    0x000C03c4 /* RW-1R */
#define NV_PRMVIO_SR_RESET                               0x000C03c5 /* RW-1R */
#define NV_PRMVIO_SR_RESET_INDEX                         0x00000000 /*     V */
#define NV_PRMVIO_SR_CLOCK                               0x000C03c5 /* RW-1R */
#define NV_PRMVIO_SR_CLOCK_INDEX                         0x00000001 /*     V */
#define NV_PRMVIO_SR_PLANE_MASK                          0x000C03c5 /* RW-1R */
#define NV_PRMVIO_SR_PLANE_MASK_INDEX                    0x00000002 /*     V */
#define NV_PRMVIO_SR_CHAR_MAP                            0x000C03c5 /* RW-1R */
#define NV_PRMVIO_SR_CHAR_MAP_INDEX                      0x00000003 /*       */
#define NV_PRMVIO_SR_MEM_MODE                            0x000C03c5 /* RW-1R */
#define NV_PRMVIO_SR_MEM_MODE_INDEX                      0x00000004 /*       */
#define NV_PRMVIO_GRX                                    0x000C03ce /* RW-1R */
#define NV_PRMVIO_GX_SR                                  0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_SR_INDEX                            0x00000000 /*       */
#define NV_PRMVIO_GX_SREN                                0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_SREN_INDEX                          0x00000001 /*       */
#define NV_PRMVIO_GX_CCOMP                               0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_CCOMP_INDEX                         0x00000002 /*       */
#define NV_PRMVIO_GX_ROP                                 0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_ROP_INDEX                           0x00000003 /*       */
#define NV_PRMVIO_GX_READ_MAP                            0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_READ_MAP_INDEX                      0x00000004 /*       */
#define NV_PRMVIO_GX_MODE                                0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_MODE_INDEX                          0x00000005 /*       */
#define NV_PRMVIO_GX_MISC                                0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_MISC_INDEX                          0x00000006 /*       */
#define NV_PRMVIO_GX_DONT_CARE                           0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_DONT_CARE_INDEX                     0x00000007 /*       */
#define NV_PRMVIO_GX_BIT_MASK                            0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_BIT_MASK_INDEX                      0x00000008 /*       */
/* dev_vga.ref */
#define NV_PRMVGA                             0x000BFFFF:0x000A0000 /* RW--D */
/* dev_media.ref */
#define NV_PME                                0x00200FFF:0x00200000 /* RW--D */
#define NV_PME_DEBUG_0                                   0x00200080 /* RWI4R */
#define NV_PME_DEBUG_0_DET_FIELD_SWITCH                         0:0 /* RWI-F */
#define NV_PME_DEBUG_0_DET_FIELD_SWITCH_DISABLED         0x00000000 /* RWI-V */
#define NV_PME_DEBUG_0_DET_FIELD_SWITCH_ENABLED          0x00000001 /* RW--V */
#define NV_PME_DEBUG_0_CAPTURE_00_FF                            4:4 /* RWI-F */
#define NV_PME_DEBUG_0_CAPTURE_00_FF_DISABLED            0x00000000 /* RWI-V */
#define NV_PME_DEBUG_0_CAPTURE_00_FF_ENABLED             0x00000001 /* RW--V */
#define NV_PME_DEBUG_1                                   0x00200084 /* RWI4R */
#define NV_PME_DEBUG_1_SEL                                      1:0 /* RWI-F */
#define NV_PME_DEBUG_1_SEL_VIPCLK                        0x00000000 /* RWI-V */
#define NV_PME_DEBUG_1_SEL_MCLK                          0x00000001 /* RW--V */
#define NV_PME_DEBUG_1_SEL_GLOB                          0x00000002 /* RW--V */
#define NV_PME_DEBUG_1_VIPCLK_SEL                               6:4 /* RWI-F */
#define NV_PME_DEBUG_1_VIPCLK_SEL_DEFAULT                0x00000000 /* RWI-V */
#define NV_PME_DEBUG_1_MCLK_SEL                                 9:8 /* RWI-F */
#define NV_PME_DEBUG_1_MCLK_SEL_DEFAULT                  0x00000000 /* RWI-V */
#define NV_PME_INTR_0                                    0x00200100 /* RWI4R */
#define NV_PME_INTR_0_IMAGE_NOTIFY                              0:0 /* RWIVF */
#define NV_PME_INTR_0_IMAGE_NOTIFY_NOT_PENDING           0x00000000 /* R-I-V */
#define NV_PME_INTR_0_IMAGE_NOTIFY_PENDING               0x00000001 /* R---V */
#define NV_PME_INTR_0_IMAGE_NOTIFY_RESET                 0x00000001 /* -W--V */
#define NV_PME_INTR_0_VBI_NOTIFY                                4:4 /* RWIVF */
#define NV_PME_INTR_0_VBI_NOTIFY_NOT_PENDING             0x00000000 /* R-I-V */
#define NV_PME_INTR_0_VBI_NOTIFY_PENDING                 0x00000001 /* R---V */
#define NV_PME_INTR_0_VBI_NOTIFY_RESET                   0x00000001 /* -W--V */
#define NV_PME_INTR_0_VID_NOTIFY                                8:8 /* RWIVF */
#define NV_PME_INTR_0_VID_NOTIFY_NOT_PENDING             0x00000000 /* R-I-V */
#define NV_PME_INTR_0_VID_NOTIFY_PENDING                 0x00000001 /* R---V */
#define NV_PME_INTR_0_VID_NOTIFY_RESET                   0x00000001 /* -W--V */
#define NV_PME_INTR_0_AUD_NOTIFY                              12:12 /* RWIVF */
#define NV_PME_INTR_0_AUD_NOTIFY_NOT_PENDING             0x00000000 /* R-I-V */
#define NV_PME_INTR_0_AUD_NOTIFY_PENDING                 0x00000001 /* R---V */
#define NV_PME_INTR_0_AUD_NOTIFY_RESET                   0x00000001 /* -W--V */
#define NV_PME_INTR_0_VMI                                     16:16 /* RWIVF */
#define NV_PME_INTR_0_VMI_NOT_PENDING                    0x00000000 /* R-I-V */
#define NV_PME_INTR_0_VMI_PENDING                        0x00000001 /* R---V */
#define NV_PME_INTR_0_VMI_RESET                          0x00000001 /* -W--V */
#define NV_PME_INTR_EN_0                                 0x00200140 /* RWI4R */
#define NV_PME_INTR_EN_0_IMAGE_NOTIFY                           0:0 /* RWIVF */
#define NV_PME_INTR_EN_0_IMAGE_NOTIFY_DISABLED           0x00000000 /* RWI-V */
#define NV_PME_INTR_EN_0_IMAGE_NOTIFY_ENABLED            0x00000001 /* RW--V */
#define NV_PME_INTR_EN_0_VBI_NOTIFY                             4:4 /* RWIVF */
#define NV_PME_INTR_EN_0_VBI_NOTIFY_DISABLED             0x00000000 /* RWI-V */
#define NV_PME_INTR_EN_0_VBI_NOTIFY_ENABLED              0x00000001 /* RW--V */
#define NV_PME_INTR_EN_0_VID_NOTIFY                             8:8 /* RWIVF */
#define NV_PME_INTR_EN_0_VID_NOTIFY_DISABLED             0x00000000 /* RWI-V */
#define NV_PME_INTR_EN_0_VID_NOTIFY_ENABLED              0x00000001 /* RW--V */
#define NV_PME_INTR_EN_0_AUD_NOTIFY                           12:12 /* RWIVF */
#define NV_PME_INTR_EN_0_AUD_NOTIFY_DISABLED             0x00000000 /* RWI-V */
#define NV_PME_INTR_EN_0_AUD_NOTIFY_ENABLED              0x00000001 /* RW--V */
#define NV_PME_INTR_EN_0_VMI                                  16:16 /* RWIVF */
#define NV_PME_INTR_EN_0_VMI_DISABLED                    0x00000000 /* RWI-V */
#define NV_PME_INTR_EN_0_VMI_ENABLED                     0x00000001 /* RW--V */
#define NV_PME_CONFIG_0                                  0x00200200 /* RWI4R */
#define NV_PME_CONFIG_0_BUS_MODE                                1:0 /* RWIVF */
#define NV_PME_CONFIG_0_BUS_MODE_DISABLED                0x00000000 /* RWI-V */
#define NV_PME_CONFIG_0_BUS_MODE_VMI                     0x00000001 /* RW--V */
#define NV_PME_CONFIG_0_BUS_MODE_CCIR656                 0x00000002 /* RW--V */
#define NV_PME_CONFIG_0_IMAGE                                   4:4 /* RWIVF */
#define NV_PME_CONFIG_0_IMAGE_DISABLED                   0x00000000 /* RWI-V */
#define NV_PME_CONFIG_0_IMAGE_ENABLED                    0x00000001 /* RW--V */
#define NV_PME_CONFIG_0_VBI_MODE                                9:8 /* RWIVF */
#define NV_PME_CONFIG_0_VBI_MODE_DISABLED                0x00000000 /* RWI-V */
#define NV_PME_CONFIG_0_VBI_MODE_1                       0x00000001 /* RW--V */
#define NV_PME_CONFIG_0_VBI_MODE_2                       0x00000002 /* RW--V */
#define NV_PME_CONFIG_0_VID_CD                                12:12 /* RWIVF */
#define NV_PME_CONFIG_0_VID_CD_DISABLED                  0x00000000 /* RWI-V */
#define NV_PME_CONFIG_0_VID_CD_ENABLED                   0x00000001 /* RW--V */
#define NV_PME_CONFIG_0_AUD_CD                                16:16 /* RWIVF */
#define NV_PME_CONFIG_0_AUD_CD_DISABLED                  0x00000000 /* RWI-V */
#define NV_PME_CONFIG_0_AUD_CD_ENABLED                   0x00000001 /* RW--V */
#define NV_PME_CONFIG_1                                  0x00200204 /* RWI4R */
#define NV_PME_CONFIG_1_BUFFS                                   0:0 /* RWIVF */
#define NV_PME_CONFIG_1_BUFFS_PNVM                       0x00000000 /* RWI-V */
#define NV_PME_CONFIG_1_BUFFS_SYS                        0x00000001 /* RW--V */
#define NV_PME_CONFIG_1_HOST                                    4:4 /* RWIVF */
#define NV_PME_CONFIG_1_HOST_PCI                         0x00000000 /* RWI-V */
#define NV_PME_CONFIG_1_HOST_AGP                         0x00000001 /* RW--V */
#define NV_PME_NULL_DATA                                 0x00200208 /* RWI4R */
#define NV_PME_NULL_DATA_COMPARE                                0:0 /* RWIVF */
#define NV_PME_NULL_DATA_COMPARE_DISABLED                0x00000000 /* RWI-V */
#define NV_PME_NULL_DATA_COMPARE_ENABLED                 0x00000001 /* RW--V */
#define NV_PME_NULL_DATA_LINE_DETECT                            4:4 /* RWIVF */
#define NV_PME_NULL_DATA_LINE_DETECT_DISABLED            0x00000000 /* RWI-V */
#define NV_PME_NULL_DATA_LINE_DETECT_ENABLED             0x00000001 /* RW--V */
#define NV_PME_NULL_DATA_BYTE                                 31:24 /* RWXVF */
#define NV_PME_VID_BUFF0_START_SYS                       0x00200300 /* RWI4R */ 
#define NV_PME_VID_BUFF0_START_SYS_ADDRESS                     31:4 /* RWXUF */
#define NV_PME_VID_BUFF1_START_SYS                       0x00200304 /* RWI4R */ 
#define NV_PME_VID_BUFF1_START_SYS_ADDRESS                     31:4 /* RWXUF */
#define NV_PME_VID_BUFF0_START_PNVM                      0x00200308 /* RWI4R */ 
#define NV_PME_VID_BUFF0_START_PNVM_ADDRESS                    23:4 /* RWXUF */
#define NV_PME_VID_BUFF1_START_PNVM                      0x0020030c /* RWI4R */ 
#define NV_PME_VID_BUFF1_START_PNVM_ADDRESS                    23:4 /* RWXUF */
#define NV_PME_VID_BUFF0_LENGTH                          0x00200310 /* RWI4R */ 
#define NV_PME_VID_BUFF0_LENGTH_BITS                          15:12 /* RWXUF */
#define NV_PME_VID_BUFF1_LENGTH                          0x00200314 /* RWI4R */ 
#define NV_PME_VID_BUFF1_LENGTH_BITS                          15:12 /* RWXUF */
#define NV_PME_VID_ME_STATE                              0x00200318 /* RW-4R */
#define NV_PME_VID_ME_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWIVF */
#define NV_PME_VID_ME_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
#define NV_PME_VID_ME_STATE_BUFF0_INTR_CHAINGAP                 8:8 /* RWXVF */
#define NV_PME_VID_ME_STATE_BUFF1_INTR_CHAINGAP               12:12 /* RWXVF */
#define NV_PME_VID_ME_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
#define NV_PME_VID_ME_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
#define NV_PME_VID_ME_STATE_CURRENT_BUFFER                    24:24 /* RWXVF */
#define NV_PME_VID_ME_STATE_CURRENT_BUFFER_0             0x00000000 /* RW--V */
#define NV_PME_VID_ME_STATE_CURRENT_BUFFER_1             0x00000001 /* RW--V */
#define NV_PME_VID_SU_STATE                              0x0020031c /* RW-4R */
#define NV_PME_VID_SU_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
#define NV_PME_VID_SU_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
#define NV_PME_VID_RM_STATE                              0x00200320 /* RW-4R */
#define NV_PME_VID_RM_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWXVF */
#define NV_PME_VID_RM_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
#define NV_PME_VID_RM_STATE_BUFF0_INTR_CHAINGAP                 8:8 /* RWXVF */
#define NV_PME_VID_RM_STATE_BUFF1_INTR_CHAINGAP               12:12 /* RWXVF */
#define NV_PME_VID_CURRENT                               0x00200324 /* RWI4R */ 
#define NV_PME_VID_CURRENT_POS                                 15:2 /* RWXUF */
#define NV_PME_AUD_BUFF0_START_SYS                       0x00200340 /* RWI4R */ 
#define NV_PME_AUD_BUFF0_START_SYS_ADDRESS                     31:4 /* RWXUF */
#define NV_PME_AUD_BUFF1_START_SYS                       0x00200344 /* RWI4R */ 
#define NV_PME_AUD_BUFF1_START_SYS_ADDRESS                     31:4 /* RWXUF */
#define NV_PME_AUD_BUFF0_START_PNVM                      0x00200348 /* RWI4R */ 
#define NV_PME_AUD_BUFF0_START_PNVM_ADDRESS                    23:4 /* RWXUF */
#define NV_PME_AUD_BUFF1_START_PNVM                      0x0020034c /* RWI4R */ 
#define NV_PME_AUD_BUFF1_START_PNVM_ADDRESS                    23:4 /* RWXUF */
#define NV_PME_AUD_BUFF0_LENGTH                          0x00200350 /* RWI4R */ 
#define NV_PME_AUD_BUFF0_LENGTH_BITS                          12:10 /* RWXUF */
#define NV_PME_AUD_BUFF1_LENGTH                          0x00200354 /* RWI4R */ 
#define NV_PME_AUD_BUFF1_LENGTH_BITS                          12:10 /* RWXUF */
#define NV_PME_AUD_ME_STATE                              0x00200358 /* RW-4R */
#define NV_PME_AUD_ME_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWIVF */
#define NV_PME_AUD_ME_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
#define NV_PME_AUD_ME_STATE_BUFF0_INTR_CHAINGAP                 8:8 /* RWXVF */
#define NV_PME_AUD_ME_STATE_BUFF1_INTR_CHAINGAP               12:12 /* RWXVF */
#define NV_PME_AUD_ME_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
#define NV_PME_AUD_ME_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
#define NV_PME_AUD_ME_STATE_CURRENT_BUFFER                    24:24 /* RWXVF */
#define NV_PME_AUD_ME_STATE_CURRENT_BUFFER_0             0x00000000 /* RW--V */
#define NV_PME_AUD_ME_STATE_CURRENT_BUFFER_1             0x00000001 /* RW--V */
#define NV_PME_AUD_SU_STATE                              0x0020035c /* RW-4R */
#define NV_PME_AUD_SU_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
#define NV_PME_AUD_SU_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
#define NV_PME_AUD_RM_STATE                              0x00200360 /* RW-4R */
#define NV_PME_AUD_RM_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWXVF */
#define NV_PME_AUD_RM_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
#define NV_PME_AUD_RM_STATE_BUFF0_INTR_CHAINGAP                 8:8 /* RWXVF */
#define NV_PME_AUD_RM_STATE_BUFF1_INTR_CHAINGAP               12:12 /* RWXVF */
#define NV_PME_AUD_CURRENT                               0x00200364 /* RWI4R */ 
#define NV_PME_AUD_CURRENT_POS                                 12:2 /* RWXUF */
#define NV_PME_VBI_BUFF0_START                           0x00200380 /* RWI4R */ 
#define NV_PME_VBI_BUFF0_START_ADDRESS                         23:4 /* RWXUF */
#define NV_PME_VBI_BUFF1_START                           0x00200384 /* RWI4R */ 
#define NV_PME_VBI_BUFF1_START_ADDRESS                         23:4 /* RWXUF */
#define NV_PME_VBI_BUFF0_PITCH                           0x00200388 /* RWI4R */ 
#define NV_PME_VBI_BUFF0_PITCH_VALUE                           13:4 /* RWXUF */
#define NV_PME_VBI_BUFF1_PITCH                           0x0020038c /* RWI4R */ 
#define NV_PME_VBI_BUFF1_PITCH_VALUE                           13:4 /* RWXUF */
#define NV_PME_VBI_BUFF0_LENGTH                          0x00200390 /* RWI4R */ 
#define NV_PME_VBI_BUFF0_LENGTH_BITS                           19:4 /* RWXUF */
#define NV_PME_VBI_BUFF1_LENGTH                          0x00200394 /* RWI4R */ 
#define NV_PME_VBI_BUFF1_LENGTH_BITS                           19:4 /* RWXUF */
#define NV_PME_VBI_ME_STATE                              0x00200398 /* RW-4R */
#define NV_PME_VBI_ME_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWXVF */
#define NV_PME_VBI_ME_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
#define NV_PME_VBI_ME_STATE_BUFF0_ERROR_CODE                   10:8 /* RWXVF */
#define NV_PME_VBI_ME_STATE_BUFF1_ERROR_CODE                  14:12 /* RWXVF */
#define NV_PME_VBI_ME_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
#define NV_PME_VBI_ME_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
#define NV_PME_VBI_ME_STATE_CURRENT_BUFFER                    24:24 /* RWXVF */
#define NV_PME_VBI_ME_STATE_CURRENT_BUFFER_0             0x00000000 /* RW--V */
#define NV_PME_VBI_ME_STATE_CURRENT_BUFFER_1             0x00000001 /* RW--V */
#define NV_PME_VBI_SU_STATE                              0x0020039c /* RW-4R */
#define NV_PME_VBI_SU_STATE_BUFF0_FIELD                         8:8 /* RWXVF */
#define NV_PME_VBI_SU_STATE_BUFF1_FIELD                       12:12 /* RWXVF */
#define NV_PME_VBI_SU_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
#define NV_PME_VBI_SU_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
#define NV_PME_VBI_RM_STATE                              0x002003a0 /* RW-4R */
#define NV_PME_VBI_RM_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWXVF */
#define NV_PME_VBI_RM_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
#define NV_PME_VBI                                       0x002003a4 /* RWI4R */
#define NV_PME_VBI_START_LINE                                   4:0 /* RWX-F */
#define NV_PME_VBI_NUM_LINES                                  20:16 /* RWX-F */
#define NV_PME_IMAGE_BUFF0_START                         0x00200400 /* RWI4R */ 
#define NV_PME_IMAGE_BUFF0_START_ADDRESS                       23:4 /* RWXUF */
#define NV_PME_IMAGE_BUFF1_START                         0x00200404 /* RWI4R */ 
#define NV_PME_IMAGE_BUFF1_START_ADDRESS                       23:4 /* RWXUF */
#define NV_PME_IMAGE_BUFF0_PITCH                         0x00200408 /* RWI4R */ 
#define NV_PME_IMAGE_BUFF0_PITCH_VALUE                         13:4 /* RWXUF */
#define NV_PME_IMAGE_BUFF1_PITCH                         0x0020040c /* RWI4R */ 
#define NV_PME_IMAGE_BUFF1_PITCH_VALUE                         13:4 /* RWXUF */
#define NV_PME_IMAGE_BUFF0_LENGTH                        0x00200410 /* RWI4R */ 
#define NV_PME_IMAGE_BUFF0_LENGTH_BITS                         19:4 /* RWXUF */
#define NV_PME_IMAGE_BUFF1_LENGTH                        0x00200414 /* RWI4R */ 
#define NV_PME_IMAGE_BUFF1_LENGTH_BITS                         19:4 /* RWXUF */
#define NV_PME_IMAGE_ME_STATE                            0x00200418 /* RW-4R */
#define NV_PME_IMAGE_ME_STATE_BUFF0_INTR_NOTIFY                 0:0 /* RWXVF */
#define NV_PME_IMAGE_ME_STATE_BUFF1_INTR_NOTIFY                 4:4 /* RWXVF */
#define NV_PME_IMAGE_ME_STATE_BUFF0_ERROR_CODE                 10:8 /* RWXVF */
#define NV_PME_IMAGE_ME_STATE_BUFF1_ERROR_CODE                14:12 /* RWXVF */
#define NV_PME_IMAGE_ME_STATE_BUFF0_IN_USE                    16:16 /* RWXVF */
#define NV_PME_IMAGE_ME_STATE_BUFF1_IN_USE                    20:20 /* RWXVF */
#define NV_PME_IMAGE_ME_STATE_CURRENT_BUFFER                  24:24 /* RWXVF */
#define NV_PME_IMAGE_ME_STATE_CURRENT_BUFFER_0           0x00000000 /* RW--V */
#define NV_PME_IMAGE_ME_STATE_CURRENT_BUFFER_1           0x00000001 /* RW--V */
#define NV_PME_IMAGE_SU_STATE                            0x0020041c /* RW-4R */
#define NV_PME_IMAGE_SU_STATE_BUFF0_FIELD                       8:8 /* RWXVF */
#define NV_PME_IMAGE_SU_STATE_BUFF1_FIELD                     12:12 /* RWXVF */
#define NV_PME_IMAGE_SU_STATE_BUFF0_IN_USE                    16:16 /* RWXVF */
#define NV_PME_IMAGE_SU_STATE_BUFF1_IN_USE                    20:20 /* RWXVF */
#define NV_PME_IMAGE_RM_STATE                            0x00200420 /* RW-4R */
#define NV_PME_IMAGE_RM_STATE_BUFF0_INTR_NOTIFY                 0:0 /* RWXVF */
#define NV_PME_IMAGE_RM_STATE_BUFF1_INTR_NOTIFY                 4:4 /* RWXVF */
#define NV_PME_IMAGE_BUFF0_SCALE_INCR                    0x00200424 /* RW-4R */
#define NV_PME_IMAGE_BUFF0_SCALE_INCR_Y                       26:16 /* RWXVF */
#define NV_PME_IMAGE_BUFF0_SCALE_INCR_X                        10:0 /* RWXVF */
#define NV_PME_IMAGE_BUFF1_SCALE_INCR                    0x00200428 /* RW-4R */
#define NV_PME_IMAGE_BUFF1_SCALE_INCR_Y                       26:16 /* RWXVF */
#define NV_PME_IMAGE_BUFF1_SCALE_INCR_X                        10:0 /* RWXVF */
#define NV_PME_IMAGE_Y_CROP                              0x0020042c /* RW-4R */
#define NV_PME_IMAGE_Y_CROP_STARTLINE                           8:0 /* RWXVF */
#define NV_PME_FIFO_LINE_START                           0x00200480 /* RW-4R */
#define NV_PME_FIFO_LINE_START_ADDRESS                         20:4 /* RWXVF */
#define NV_PME_FIFO_CURRENT                              0x00200484 /* RW-4R */
#define NV_PME_FIFO_CURRENT_ADDRESS                            20:2 /* RWXVF */
#define NV_PME_VMI_POLL                                  0x00200488 /* R--4R */
#define NV_PME_VMI_POLL_UNCD                                    0:0 /* R-IVF */
#define NV_PME_VMI_POLL_UNCD_NOT_PENDING                 0x00000000 /* R-I-V */
#define NV_PME_VMI_POLL_UNCD_PENDING                     0x00000001 /* R---V */
#define NV_PME_VMI_POLL_VIDCD                                   1:1 /* R-IVF */
#define NV_PME_VMI_POLL_VIDCD_NOT_PENDING                0x00000000 /* R-I-V */
#define NV_PME_VMI_POLL_VIDCD_PENDING                    0x00000001 /* R---V */
#define NV_PME_VMI_POLL_AUDCD                                   2:2 /* R-IVF */
#define NV_PME_VMI_POLL_AUDCD_NOT_PENDING                0x00000000 /* R-I-V */
#define NV_PME_VMI_POLL_AUDCD_PENDING                    0x00000001 /* R---V */
#define NV_PME_VMI_POLL_INT                                     3:3 /* R-IVF */
#define NV_PME_VMI_POLL_INT_NOT_PENDING                  0x00000000 /* R-I-V */
#define NV_PME_VMI_POLL_INT_PENDING                      0x00000001 /* R---V */
#define NV_PME_VMI_POLL_CPURDREC                                4:4 /* R-IVF */
#define NV_PME_VMI_POLL_CPURDREC_NOT_PENDING             0x00000000 /* R-I-V */
#define NV_PME_VMI_POLL_CPURDREC_PENDING                 0x00000001 /* R---V */
#define NV_PME_EXTERNAL(i)                       (0x00200600+(i)*4) /* RW-4A */
#define NV_PME_EXTERNAL_SIZE_1                                  256 /*       */  
#define NV_PME_EXTERNAL_DATA                                    7:0 /* RWXVF */
/* dev_framebuffer.ref */
#define NV_PFB                                0x00100FFF:0x00100000 /* RW--D */
#define NV_PFB_BOOT_0                                    0x00100000 /* RW-4R */
#define NV_PFB_BOOT_0_RAM_AMOUNT                                1:0 /* RW-VF */
#define NV_PFB_BOOT_0_RAM_AMOUNT_32MB                    0x00000000 /* RW--V */
#define NV_PFB_BOOT_0_RAM_AMOUNT_4MB                     0x00000001 /* RW--V */
#define NV_PFB_BOOT_0_RAM_AMOUNT_8MB                     0x00000002 /* RW--V */
#define NV_PFB_BOOT_0_RAM_AMOUNT_16MB                    0x00000003 /* RW--V */
#define NV_PFB_BOOT_0_RAM_WIDTH_128                             2:2 /* RW-VF */
#define NV_PFB_BOOT_0_RAM_WIDTH_128_OFF                  0x00000000 /* RW--V */
#define NV_PFB_BOOT_0_RAM_WIDTH_128_ON                   0x00000001 /* RW--V */
#define NV_PFB_BOOT_0_RAM_TYPE                                  4:3 /* RW-VF */
#define NV_PFB_BOOT_0_RAM_TYPE_256K                      0x00000000 /* RW--V */
#define NV_PFB_BOOT_0_RAM_TYPE_512K_2BANK                0x00000001 /* RW--V */
#define NV_PFB_BOOT_0_RAM_TYPE_512K_4BANK                0x00000002 /* RW--V */

// Added UMA support
#define NV_PFB_BOOT_0_UMA                                       8:8 /* RW-VF */
#define NV_PFB_BOOT_0_UMA_DISABLE                        0x00000000 /* RWI-V */
#define NV_PFB_BOOT_0_UMA_ENABLE                         0x00000001 /* RW--V */
#define NV_PFB_BOOT_0_UMA_SIZE                                15:12 /* RW-VF */
#define NV_PFB_BOOT_0_UMA_SIZE_DEFAULT                   0x00000007 /* RWI-V */
#define NV_PFB_BOOT_0_UMA_SIZE_2M                        0x00000000 /* RW--V */
#define NV_PFB_BOOT_0_UMA_SIZE_4M                        0x00000001 /* RW--V */
#define NV_PFB_BOOT_0_UMA_SIZE_6M                        0x00000002 /* RW--V */
#define NV_PFB_BOOT_0_UMA_SIZE_8M                        0x00000003 /* RW--V */
#define NV_PFB_BOOT_0_UMA_SIZE_10M                       0x00000004 /* RW--V */
#define NV_PFB_BOOT_0_UMA_SIZE_12M                       0x00000005 /* RW--V */
#define NV_PFB_BOOT_0_UMA_SIZE_14M                       0x00000006 /* RW--V */
#define NV_PFB_BOOT_0_UMA_SIZE_16M                       0x00000007 /* RW--V */
#define NV_PFB_BOOT_0_UMA_SIZE_18M                       0x00000008 /* RW--V */
#define NV_PFB_BOOT_0_UMA_SIZE_20M                       0x00000009 /* RW--V */
#define NV_PFB_BOOT_0_UMA_SIZE_22M                       0x0000000a /* RW--V */
#define NV_PFB_BOOT_0_UMA_SIZE_24M                       0x0000000b /* RW--V */
#define NV_PFB_BOOT_0_UMA_SIZE_26M                       0x0000000c /* RW--V */
#define NV_PFB_BOOT_0_UMA_SIZE_28M                       0x0000000d /* RW--V */
#define NV_PFB_BOOT_0_UMA_SIZE_30M                       0x0000000e /* RW--V */
#define NV_PFB_BOOT_0_UMA_SIZE_32M                       0x0000000f /* RW--V */

// Added NV10/NV11/NV15 support
#define NV_PFB_CSTATUS                                   0x0010020C /* R--4R */
#define NV_PFB_CSTATUS_RAMAMOUNT                              27:20 /* R--VF */
#define NV_PFB_CFG                                       0x00100200 /* RW-4R */
#define NV_PFB_CFG_BUS                                          5:4 /* RWIVF */
#define NV_PFB_CFG_BUS_64                                0x00000000 /* RWI-V */
#define NV_PFB_CFG_BUS_128                               0x00000001 /* RW--V */
#define NV_PFB_CFG_BUS_32                                0x00000002 /* RW--V */

#define NV_PFB_DEBUG_0                                   0x00100080 /* RW-4R */
#define NV_PFB_DEBUG_0_PAGE_MODE                                0:0 /* RWIVF */
#define NV_PFB_DEBUG_0_PAGE_MODE_ENABLED                 0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0_PAGE_MODE_DISABLED                0x00000001 /* RW--V */
#define NV_PFB_DEBUG_0_REFRESH                                  4:4 /* RWIVF */
#define NV_PFB_DEBUG_0_REFRESH_ENABLED                   0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0_REFRESH_DISABLED                  0x00000001 /* RW--V */
#define NV_PFB_DEBUG_0_REFRESH_COUNTX64                        13:8 /* RWIVF */
#define NV_PFB_DEBUG_0_REFRESH_COUNTX64_DEFAULT          0x00000010 /* RWI-V */
#define NV_PFB_DEBUG_0_REFRESH_SLOW_CLK                       14:14 /* RWIVF */
#define NV_PFB_DEBUG_0_REFRESH_SLOW_CLK_DISABLED         0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0_REFRESH_SLOW_CLK_ENABLED          0x00000001 /* RW--V */
#define NV_PFB_DEBUG_0_CASOE                                  20:20 /* RWIVF */
#define NV_PFB_DEBUG_0_CASOE_ENABLED                     0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0_CASOE_DISABLED                    0x00000001 /* RW--V */
#define NV_PFB_DEBUG_0_CKE_INVERT                             28:28 /* RWIVF */
#define NV_PFB_DEBUG_0_CKE_INVERT_OFF                    0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0_CKE_INVERT_ON                     0x00000001 /* RW--V */
#define NV_PFB_DEBUG_0_REFINC                                 29:29 /* RWIVF */
#define NV_PFB_DEBUG_0_REFINC_DISABLED                   0x00000000 /* RW--V */
#define NV_PFB_DEBUG_0_REFINC_ENABLED                    0x00000001 /* RWI-V */
#define NV_PFB_DEBUG_0_SAVE_POWER                             30:30 /* RWIVF */
#define NV_PFB_DEBUG_0_SAVE_POWER_ON                     0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0_SAVE_POWER_OFF                    0x00000001 /* RW--V */
#define NV_PFB_GREEN_0                                   0x001000C0 /* RW-4R */
#define NV_PFB_GREEN_0_LEVEL                                    1:0 /* RWIVF */
#define NV_PFB_GREEN_0_LEVEL_VIDEO_ENABLED               0x00000000 /* RW--V */
#define NV_PFB_GREEN_0_LEVEL_VIDEO_DISABLED              0x00000001 /* RW--V */
#define NV_PFB_GREEN_0_LEVEL_TIMING_DISABLED             0x00000002 /* RW--V */
#define NV_PFB_GREEN_0_LEVEL_MEMORY_DISABLED             0x00000003 /* RWI-V */
#define NV_PFB_CONFIG_0                                  0x00100200 /* RW-4R */
#define NV_PFB_CONFIG_0_TYPE                                   14:0 /* RWIVF */
#define NV_PFB_CONFIG_0_TYPE_OLD1024_FIXED_8BPP          0x00000120 /* RW--V */
#define NV_PFB_CONFIG_0_TYPE_OLD1024_FIXED_16BPP         0x00000220 /* RW--V */
#define NV_PFB_CONFIG_0_TYPE_OLD1024_FIXED_32BPP         0x00000320 /* RW--V */
#define NV_PFB_CONFIG_0_TYPE_OLD1024_VAR_8BPP            0x00004120 /* RW--V */
#define NV_PFB_CONFIG_0_TYPE_OLD1024_VAR_16BPP           0x00004220 /* RW--V */
#define NV_PFB_CONFIG_0_TYPE_OLD1024_VAR_32BPP           0x00004320 /* RW--V */
#define NV_PFB_CONFIG_0_TYPE_TETRIS                      0x00002000 /* RW--V */
#define NV_PFB_CONFIG_0_TYPE_NOTILING                    0x00001114 /* RWI-V */
#define NV_PFB_CONFIG_0_TETRIS_MODE                           17:15 /* RWI-F */
#define NV_PFB_CONFIG_0_TETRIS_MODE_PASS                 0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_TETRIS_MODE_1                    0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_TETRIS_MODE_2                    0x00000002 /* RW--V */
#define NV_PFB_CONFIG_0_TETRIS_MODE_3                    0x00000003 /* RW--V */
#define NV_PFB_CONFIG_0_TETRIS_MODE_4                    0x00000004 /* RW--V */
#define NV_PFB_CONFIG_0_TETRIS_MODE_5                    0x00000005 /* RW--V */
#define NV_PFB_CONFIG_0_TETRIS_MODE_6                    0x00000006 /* RW--V */
#define NV_PFB_CONFIG_0_TETRIS_MODE_7                    0x00000007 /* RW--V */
#define NV_PFB_CONFIG_0_TETRIS_SHIFT                          19:18 /* RWI-F */
#define NV_PFB_CONFIG_0_TETRIS_SHIFT_0                   0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_TETRIS_SHIFT_1                   0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_TETRIS_SHIFT_2                   0x00000002 /* RW--V */
#define NV_PFB_CONFIG_0_BANK_SWAP                             22:20 /* RWI-F */
#define NV_PFB_CONFIG_0_BANK_SWAP_OFF                    0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_BANK_SWAP_1M                     0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_BANK_SWAP_2M                     0x00000005 /* RW--V */
#define NV_PFB_CONFIG_0_BANK_SWAP_4M                     0x00000007 /* RW--V */
#define NV_PFB_CONFIG_0_UNUSED                                23:23 /* RW-VF */
#define NV_PFB_CONFIG_0_SCRAMBLE_EN                           29:29 /* RWIVF */
#define NV_PFB_CONFIG_0_SCRAMBLE_EN_INIT                 0x00000000 /* RW--V */
#define NV_PFB_CONFIG_0_SCRAMBLE_ACTIVE                  0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_PRAMIN_WR                             28:28 /* RWIVF */
#define NV_PFB_CONFIG_0_PRAMIN_WR_INIT                   0x00000000 /* RW--V */
#define NV_PFB_CONFIG_0_PRAMIN_WR_DISABLED               0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_PRAMIN_WR_MASK                        27:24 /* RWIVF */
#define NV_PFB_CONFIG_0_PRAMIN_WR_MASK_INIT              0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_PRAMIN_WR_MASK_CLEAR             0x0000000f /* RWI-V */
#define NV_PFB_CONFIG_1                                  0x00100204 /* RW-4R */
#define NV_PFB_CONFIG_1_CAS_LATENCY                             2:0 /* RWIVF */
#define NV_PFB_CONFIG_1_CAS_LATENCY_3                    0x00000003 /* RWI-V */
#define NV_PFB_CONFIG_1_CAS_LATENCY_2                    0x00000002 /* RW--V */
#define NV_PFB_CONFIG_1_CAS_LATENCY_4                    0x00000004 /* RW--V */
#define NV_PFB_CONFIG_1_RAS_RAS                                 7:4 /* RWIUF */
#define NV_PFB_CONFIG_1_RAS_RAS_DEFAULT                  0x00000009 /* RWI-V */
#define NV_PFB_CONFIG_1_RAS_RAS_9CYCLES                  0x00000008 /* RW--V */
#define NV_PFB_CONFIG_1_RAS_RAS_8CYCLES                  0x00000007 /* RW--V */
#define NV_PFB_CONFIG_1_RAS_RAS_7CYCLES                  0x00000006 /* RW--V */
#define NV_PFB_CONFIG_1_RAS_PCHG                               10:8 /* RWIUF */
#define NV_PFB_CONFIG_1_RAS_PCHG_DEFAULT                 0x00000002 /* RWI-V */
#define NV_PFB_CONFIG_1_RAS_PCHG_2CYCLES                 0x00000001 /* RW--V */
#define NV_PFB_CONFIG_1_RAS_LOW                               14:12 /* RWIUF */
#define NV_PFB_CONFIG_1_RAS_LOW_DEFAULT                  0x00000006 /* RWI-V */
#define NV_PFB_CONFIG_1_RAS_LOW_7CYCLES                  0x00000007 /* RW--V */
#define NV_PFB_CONFIG_1_RAS_LOW_5CYCLES                  0x00000005 /* RW--V */
#define NV_PFB_CONFIG_1_RAS_LOW_4CYCLES                  0x00000004 /* RW--V */
#define NV_PFB_CONFIG_1_MRS_TO_RAS                            18:16 /* RWIUF */
#define NV_PFB_CONFIG_1_MRS_TO_RAS_DEFAULT               0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_1_MRS_TO_RAS_2CYCLES               0x00000002 /* RW--V */
#define NV_PFB_CONFIG_1_MRS_TO_RAS_0CYCLES               0x00000000 /* RW--V */
#define NV_PFB_CONFIG_1_WRITE_TO_READ                         22:20 /* RWIUF */
#define NV_PFB_CONFIG_1_WRITE_TO_READ_DEFAULT            0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_1_RAS_TO_CAS_M1                         26:24 /* RWIUF */
#define NV_PFB_CONFIG_1_RAS_TO_CAS_M1_DEFAULT            0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_1_RAS_TO_CAS_M1_2CYCLES            0x00000002 /* RW--V */
#define NV_PFB_CONFIG_1_RAS_TO_CAS_M1_0CYCLES            0x00000000 /* RW--V */
#define NV_PFB_CONFIG_1_READ_TO_WRITE                         30:28 /* RWIUF */
#define NV_PFB_CONFIG_1_READ_TO_WRITE_DEFAULT            0x00000004 /* RWI-V */
#define NV_PFB_CONFIG_1_READ_TO_WRITE_5CYCLES            0x00000005 /* RW--V */
#define NV_PFB_CONFIG_1_READ_TO_WRITE_3CYCLES            0x00000003 /* RW--V */
#define NV_PFB_CONFIG_1_READ_TO_WRITE_2CYCLES            0x00000002 /* RW--V */
#define NV_PFB_CONFIG_1_READ_TO_PCHG                          31:31 /* RWIUF */
#define NV_PFB_CONFIG_1_READ_TO_PCHG_ON                  0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_1_READ_TO_PCHG_OFF                 0x00000000 /* RW--V */
#define NV_PFB_RTL                                       0x00100300 /* RW-4R */
#define NV_PFB_RTL_H                                            0:0 /* RWIUF */
#define NV_PFB_RTL_H_DEFAULT                             0x00000000 /* RWI-V */
#define NV_PFB_RTL_MC                                           1:1 /* RWIUF */
#define NV_PFB_RTL_MC_DEFAULT                            0x00000000 /* RWI-V */
#define NV_PFB_RTL_V                                            2:2 /* RWIUF */
#define NV_PFB_RTL_V_DEFAULT                             0x00000000 /* RWI-V */
#define NV_PFB_RTL_G                                            3:3 /* RWIUF */
#define NV_PFB_RTL_G_DEFAULT                             0x00000000 /* RWI-V */
#define NV_PFB_RTL_GB                                           4:4 /* RWIUF */
#define NV_PFB_RTL_GB_DEFAULT                            0x00000000 /* RWI-V */
#define NV_PFB_SCRAMBLE(i)                     (0x00100400+((i)*4)) /* RW-4A */
#define NV_PFB_SCRAMBLE_SIZE_1                                    8 /*       */
#define NV_PFB_SCRAMBLE_w0                                      4:0 /* RWXUF */
#define NV_PFB_SCRAMBLE_w1                                     12:8 /* RWXUF */
#define NV_PFB_SCRAMBLE_w2                                    20:16 /* RWXUF */
#define NV_PFB_SCRAMBLE_w3                                    28:24 /* RWXUF */
#define NV_PFB_SCRAMBLE_EN                               0x00100420 /* RW-4R */
#define NV_PFB_SCRAMBLE_VALUE_0                          0x03020100 /* RW--V */
#define NV_PFB_SCRAMBLE_VALUE_1                          0x07060504 /* RW--V */
#define NV_PFB_SCRAMBLE_VALUE_2                          0x0b0a0908 /* RW--V */
#define NV_PFB_SCRAMBLE_VALUE_3                          0x0f0e0d0c /* RW--V */
#define NV_PFB_SCRAMBLE_VALUE_4                          0x13121110 /* RW--V */
#define NV_PFB_SCRAMBLE_VALUE_5                          0x17161514 /* RW--V */
#define NV_PFB_SCRAMBLE_VALUE_6                          0x1b1a1918 /* RW--V */
#define NV_PFB_SCRAMBLE_VALUE_7                          0x1f1e1d1c /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION                              5:0 /* RWIVF */
#define NV_PFB_CONFIG_0_RESOLUTION_320_PIXELS            0x0000000a /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_400_PIXELS            0x0000000d /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_480_PIXELS            0x0000000f /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_512_PIXELS            0x00000010 /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_640_PIXELS            0x00000014 /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_800_PIXELS            0x00000019 /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_960_PIXELS            0x0000001e /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_1024_PIXELS           0x00000020 /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_1152_PIXELS           0x00000024 /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_1280_PIXELS           0x00000028 /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_1600_PIXELS           0x00000032 /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_DEFAULT               0x00000014 /* RWI-V */
#define NV_PFB_CONFIG_0_PIXEL_DEPTH                             9:8 /* RWIVF */
#define NV_PFB_CONFIG_0_PIXEL_DEPTH_8_BITS               0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_PIXEL_DEPTH_16_BITS              0x00000002 /* RW--V */
#define NV_PFB_CONFIG_0_PIXEL_DEPTH_32_BITS              0x00000003 /* RW--V */
#define NV_PFB_CONFIG_0_PIXEL_DEPTH_DEFAULT              0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING                                12:12 /* RWIVF */
#define NV_PFB_CONFIG_0_TILING_ENABLED                   0x00000000 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DISABLED                  0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG                          23:13 /* RWIVF */
#define NV_PFB_CONFIG_0_TILING_DEBUG_DISABLED            0x00000000 /* RW--V */
#define NV_PFB_CONFIG_0_TILE                                  14:12 /* RWIVF */
#define NV_PFB_CONFIG_0_TILE_OLD1024_FIXED               0x00000000 /* RW--V */
#define NV_PFB_CONFIG_0_TILE_OLD1024_VARIABLE            0x00000004 /* RW--V */
#define NV_PFB_CONFIG_0_TILE_TETRIS_ALLOW                0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_TILE_TETRIS_REDUNDANT            0x00000002 /* RW--V */
#define NV_PFB_CONFIG_0_TILE_TETRIS_REDUNDANT2           0x00000003 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_ON                       13:13 /* RWI-F */
#define NV_PFB_CONFIG_0_TILING_DEBUG_ON_ENABLED          0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_ON_DISABLED         0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TILESIZE                 14:14 /* RWI-F */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TILESIZE_FIXED      0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TILESIZE_VARIABLE   0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE              17:15 /* RWI-F */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE_PASS    0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE_1       0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE_2       0x00000002 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE_3       0x00000003 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE_4       0x00000004 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE_5       0x00000005 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE_6       0x00000006 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE_7       0x00000007 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_SHIFT             19:18 /* RWI-F */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_SHIFT_0      0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_SHIFT_1      0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_SHIFT_2      0x00000002 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_BANK_SWAP                20:20 /* RWI-F */
#define NV_PFB_CONFIG_0_TILING_DEBUG_BANK_SWAP_OFF       0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_BANK_SWAP_ON        0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_BANK_SWAP_MSB            22:21 /* RWI-F */
#define NV_PFB_CONFIG_0_TILING_DEBUG_BANK_SWAP_MSB_1M    0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_BANK_SWAP_MSB_2M    0x00000002 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_BANK_SWAP_MSB_4M    0x00000003 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_UNUSED                   23:23 /* RW--F */
#define NV_PFB_CONFIG_1_SGRAM100                                3:3 /* RWIVF */
#define NV_PFB_CONFIG_1_SGRAM100_ENABLED                 0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_1_SGRAM100_DISABLED                0x00000001 /* RW--V */
#define NV_PFB_DEBUG_0_CKE_ALWAYSON                           29:29 /* RWIVF */
#define NV_PFB_DEBUG_0_CKE_ALWAYSON_OFF                  0x00000000 /* RW--V */
#define NV_PFB_DEBUG_0_CKE_ALWAYSON_ON                   0x00000001 /* RWI-V */
/* dev_framebuffer.ref */
#define NV_PNVM                               0x01FFFFFF:0x01000000 /* RW--M */
#define NV_PNVM_DATA032(i)                       (0x01000000+(i)*4) /* RW-4A */
#define NV_PNVM_DATA032__SIZE_1                              524288 /*       */
#define NV_PNVM_DATA032_VALUE                                  31:0 /* RWXVF */
#define NV_PNVM_DATA024(i)           (0x01000000+((i)/2)*4+((i)%2)) /* RW-3A */
#define NV_PNVM_DATA024__SIZE_1                             1048576 /*       */
#define NV_PNVM_DATA024_VALUE                                  23:0 /* RWXVF */
#define NV_PNVM_DATA016(i)           (0x01000000+((i)/3)*4+((i)%3)) /* RW-2A */
#define NV_PNVM_DATA016__SIZE_1                             1572864 /*       */
#define NV_PNVM_DATA016_VALUE                                  15:0 /* RWXVF */
#define NV_PNVM_DATA008(i)                         (0x01000000+(i)) /* RW-1A */
#define NV_PNVM_DATA008__SIZE_1                             2097152 /*       */
#define NV_PNVM_DATA008_VALUE                                   7:0 /* RWXVF */
/* dev_framebuffer.ref */
#define NV_PRAMIN                             0x007FFFFF:0x00700000 /* RW--M */
#define NV_PRAMIN_DATA032(i)                     (0x00700000+(i)*4) /* RW-4A */
#define NV_PRAMIN_DATA032__SIZE_1                            524288 /*       */
#define NV_PRAMIN_DATA032_VALUE                                31:0 /* RWXVF */
#define NV_PRAMIN_DATA024(i)         (0x00700000+((i)/2)*4+((i)%2)) /* RW-3A */
#define NV_PRAMIN_DATA024__SIZE_1                           1048576 /*       */
#define NV_PRAMIN_DATA024_VALUE                                23:0 /* RWXVF */
#define NV_PRAMIN_DATA016(i)         (0x00700000+((i)/3)*4+((i)%3)) /* RW-2A */
#define NV_PRAMIN_DATA016__SIZE_1                           1572864 /*       */
#define NV_PRAMIN_DATA016_VALUE                                15:0 /* RWXVF */
#define NV_PRAMIN_DATA008(i)                       (0x00700000+(i)) /* RW-1A */
#define NV_PRAMIN_DATA008__SIZE_1                           2097152 /*       */
#define NV_PRAMIN_DATA008_VALUE                                 7:0 /* RWXVF */
/* dev_ram.ref */
#define NV_PRAMIN_CONTEXT_0                   ( 0*32+31):( 0*32+ 0) /*       */
#define NV_PRAMIN_CONTEXT_1                   ( 1*32+31):( 1*32+ 0) /*       */
#define NV_PRAMIN_CONTEXT_2                   ( 2*32+31):( 2*32+ 0) /*       */
#define NV_PRAMIN_CONTEXT_3                   ( 3*32+31):( 3*32+ 0) /*       */
#define NV_PRAMIN_RAMHT_0                     0x00710FFF:0x00710000 /* RW--M */
#define NV_PRAMIN_RAMFC_0                     0x007111FF:0x00711000 /* RW--M */
#define NV_PRAMIN_RAMRO_0                     0x007113FF:0x00711200 /* RW--M */
#define NV_PRAMIN_CTX_0(i)                    (0x00700000 + (i)*16) /* RW--M */
#define NV_PRAMIN_CTX_0__SIZE_1                             0x10000 /*       */
#define NV_PRAMIN_CTX_0_NVCLASS                                11:0 /* RWXUF */
#define NV_PRAMIN_CTX_0_CHROMA_KEY                            12:12 /* RWXUF */
#define NV_PRAMIN_CTX_0_CHROMA_KEY_DISABLE               0x00000000 /* RW--V */
#define NV_PRAMIN_CTX_0_CHROMA_KEY_ENABLE                0x00000001 /* RW--V */
#define NV_PRAMIN_CTX_0_USER_CLIP                             13:13 /* RWXUF */
#define NV_PRAMIN_CTX_0_USER_CLIP_DISABLE                0x00000000 /* RW--V */
#define NV_PRAMIN_CTX_0_USER_CLIP_ENABLE                 0x00000001 /* RW--V */
#define NV_PRAMIN_CTX_0_SWIZZLE                               14:14 /* RWXUF */
#define NV_PRAMIN_CTX_0_SWIZZLE_DISABLE                  0x00000000 /* RW--V */
#define NV_PRAMIN_CTX_0_SWIZZLE_ENABLE                   0x00000001 /* RW--V */
#define NV_PRAMIN_CTX_0_PATCH_CONFIG                          17:15 /* RWXUF */
#define NV_PRAMIN_CTX_0_PATCH_CONFIG_SRCCOPY_AND         0x00000000 /* RW--V */
#define NV_PRAMIN_CTX_0_PATCH_CONFIG_ROP_AND             0x00000001 /* RW--V */
#define NV_PRAMIN_CTX_0_PATCH_CONFIG_BLEND_AND           0x00000002 /* RW--V */
#define NV_PRAMIN_CTX_0_PATCH_CONFIG_SRCCOPY             0x00000003 /* RW--V */
#define NV_PRAMIN_CTX_0_PATCH_CONFIG_SRCCOPY_PRE         0x00000004 /* RW--V */
#define NV_PRAMIN_CTX_0_PATCH_CONFIG_BLEND_PRE           0x00000005 /* RW--V */
#define NV_PRAMIN_CTX_0_PATCH_STATUS                          24:24 /* RWXUF */
#define NV_PRAMIN_CTX_0_PATCH_STATUS_INVALID             0x00000000 /* RW--V */
#define NV_PRAMIN_CTX_0_PATCH_STATUS_VALID               0x00000001 /* RW--V */
#define NV_PRAMIN_CTX_0_CONTEXT_SURFACE                       25:25 /* RWXUF */
#define NV_PRAMIN_CTX_0_CONTEXT_SURFACE_INVALID          0x00000000 /* RW--V */
#define NV_PRAMIN_CTX_0_CONTEXT_SURFACE_VALID            0x00000001 /* RW--V */
#define NV_PRAMIN_CTX_1(i)                    (0x00700004 + (i)*16) /* RW--M */
#define NV_PRAMIN_CTX_1__SIZE_1                             0x10000 /*       */
#define NV_PRAMIN_CTX_1_MONO_FORMAT                             7:0 /* RWXUF */
#define NV_PRAMIN_CTX_1_MONO_FORMAT_INVALID                    0x00 /* RWI-V */
#define NV_PRAMIN_CTX_1_MONO_FORMAT_CGA6_M1                    0x01 /* RW--V */
#define NV_PRAMIN_CTX_1_MONO_FORMAT_LE_M1                      0x02 /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT                           15:8 /* RWXUF */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_INVALID                   0x00 /* RWI-V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_Y8                     0x01 /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_X16A8Y8                0x02 /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_X24Y8                  0x03 /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_A1R5G5B5               0x06 /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_X1R5G5B5               0x07 /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_X16A1R5G5B5            0x08 /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_X17R5G5B5              0x09 /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_R5G6B5                 0x0A /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_A16R5G6B5              0x0B /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_X16R5G6B5              0x0C /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_A8R8G8B8               0x0D /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_X8R8G8B8               0x0E /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_Y16                    0x0F /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_A16Y16                 0x10 /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_X16Y16                 0x11 /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_V8YB8U8YA8             0x12 /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_YB8V8YA8U8             0x13 /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_Y32                    0x14 /* RW--V */
#define NV_PRAMIN_CTX_1_NOTIFY_INSTANCE                       31:16 /* RWXUF */
#define NV_PRAMIN_CTX_1_NOTIFY_INSTANCE_INVALID              0x0000 /* RWI-V */
#define NV_PRAMIN_CTX_2(i)                    (0x00700008 + (i)*16) /* RW--M */
#define NV_PRAMIN_CTX_2__SIZE_1                             0x10000 /*       */
#define NV_PRAMIN_CTX_2_DMA_0_INSTANCE                         15:0 /* RWXUF */
#define NV_PRAMIN_CTX_2_DMA_0_INSTANCE_INVALID               0x0000 /* RWI-V */
#define NV_PRAMIN_CTX_2_DMA_1_INSTANCE                        31:16 /* RWXUF */
#define NV_PRAMIN_CTX_2_DMA_1_INSTANCE_INVALID               0x0000 /* RWI-V */
/* dev_ram.ref */
#define NV_FIFO_DMA_OPCODE                    ( 0*32+31):( 0*32+29) /* RWXUF */
#define NV_FIFO_DMA_OPCODE_METHOD                        0x00000000 /* ----- */
#define NV_FIFO_DMA_OPCODE_JUMP                          0x00000001 /* ----- */
#define NV_FIFO_DMA_METHOD_COUNT              ( 0*32+28):( 0*32+18) /* RWXUF */
#define NV_FIFO_DMA_METHOD_SUBCHANNEL         ( 0*32+15):( 0*32+13) /* RWXUF */
#define NV_FIFO_DMA_METHOD_ADDRESS            ( 0*32+12):( 0*32+ 2) /* RWXUF */
#define NV_FIFO_DMA_DATA                      ( 1*32+31):( 1*32+ 0) /* RWXUF */
#define NV_FIFO_DMA_JUMP_OFFSET                                28:2 /* RWXUF */
/* dev_framebuffer.ref */
#define NV_PDFB                               0x01FFFFFF:0x01000000 /* RW--D */
#define NV_PDFB_DATA032(i)                       (0x01000000+(i)*4) /* RW-4A */
#define NV_PDFB_DATA032__SIZE_1                              524288 /*       */
#define NV_PDFB_DATA032_VALUE                                  31:0 /* RWXVF */
#define NV_PDFB_DATA024(i)           (0x01000000+((i)/2)*4+((i)%2)) /* RW-3A */
#define NV_PDFB_DATA024__SIZE_1                             1048576 /*       */
#define NV_PDFB_DATA024_VALUE                                  23:0 /* RWXVF */
#define NV_PDFB_DATA016(i)           (0x01000000+((i)/3)*4+((i)%3)) /* RW-2A */
#define NV_PDFB_DATA016__SIZE_1                             1572864 /*       */
#define NV_PDFB_DATA016_VALUE                                  15:0 /* RWXVF */
#define NV_PDFB_DATA008(i)                         (0x01000000+(i)) /* RW-1A */
#define NV_PDFB_DATA008__SIZE_1                             2097152 /*       */
#define NV_PDFB_DATA008_VALUE                                   7:0 /* RWXVF */
/* dev_ram.ref */
#define NV_PRAM                               0x00006FFF:0x00006000 /* RW--D */
/* dev_ext_devices.ref */
#define NV_PEXTDEV                            0x00101FFF:0x00101000 /* RW--D */
#define NV_PEXTDEV_BOOT_0                                0x00101000 /* R--4R */
#define NV_PEXTDEV_BOOT_0_STRAP_BUS_SPEED                       0:0 /* R-XVF */
#define NV_PEXTDEV_BOOT_0_STRAP_BUS_SPEED_33MHZ          0x00000000 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_BUS_SPEED_66MHZ          0x00000001 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_SUB_VENDOR                      1:1 /* R-XVF */
#define NV_PEXTDEV_BOOT_0_STRAP_SUB_VENDOR_NO_BIOS       0x00000000 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_SUB_VENDOR_BIOS          0x00000001 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE                        3:2 /* R-XVF */
#define NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE_SGRAM_256K      0x00000000 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE_SGRAM_512K_2BANK 0x00000001 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE_SGRAM_512K_4BANK 0x00000002 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE_1024K_2BANK     0x00000003 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_RAM_WIDTH                       4:4 /* R-XVF */
#define NV_PEXTDEV_BOOT_0_STRAP_RAM_WIDTH_64             0x00000000 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_RAM_WIDTH_128            0x00000001 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_BUS_TYPE                        5:5 /* R-XVF */
#define NV_PEXTDEV_BOOT_0_STRAP_BUS_TYPE_PCI             0x00000000 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_BUS_TYPE_AGP             0x00000001 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL                         6:6 /* R-XVF */
#define NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL_13500K           0x00000000 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL_14318180         0x00000001 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_TVMODE                          8:7 /* R-XVF */
#define NV_PEXTDEV_BOOT_0_STRAP_TVMODE_SECAM             0x00000000 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_TVMODE_NTSC              0x00000001 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_TVMODE_PAL               0x00000002 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_TVMODE_DISABLED          0x00000003 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_OVERWRITE                     11:11 /* RWIVF */
#define NV_PEXTDEV_BOOT_0_STRAP_OVERWRITE_DISABLED       0x00000000 /* RWI-V */
#define NV_PEXTDEV_BOOT_0_STRAP_OVERWRITE_ENABLED        0x00000001 /* RW--V */
#define NV_PEXTDEV_NEW_BOOT_0                            0x00101000 /* RW-4R */
#define NV_PEXTDEV_NEW_BOOT_0_STRAP_VALUE                       8:0 /* RWIVF */
#define NV_PEXTDEV_NEW_BOOT_0_STRAP_OVERWRITE                 11:11 /* RWIVF */
#define NV_PEXTDEV_NEW_BOOT_0_STRAP_OVERWRITE_DISABLED   0x00000000 /* RWI-V */
#define NV_PEXTDEV_NEW_BOOT_0_STRAP_OVERWRITE_ENABLED    0x00000001 /* RW--V */
/* dev_ext_devices.ref */
#define NV_PDAC                               0x00680FFF:0x00680000 /* RW--D */
#define NV_PDAC_DATA(i)                          (0x00680000+(i)*4) /* RW-4A */
#define NV_PDAC_DATA__SIZE_1                                     16 /*       */
#define NV_PDAC_DATA_VALUE                                      7:0 /* RW-VF */
/* dev_ext_devices.ref */
/* dev_ext_devices.ref */
#define NV_PROM                               0x0030FFFF:0x00300000 /* RW--D */
#define NV_PROM_DATA(i)                            (0x00300000+(i)) /* RW-1A */
#define NV_PROM_DATA__SIZE_1                                  65536 /*       */
#define NV_PROM_DATA_VALUE                                      7:0 /* RW-VF */
/* dev_realmode.ref */
#define NV_PRM                                0x00005FFF:0x00004000 /* RW--D */
#define NV_PRM_INTR_0                                    0x00004100 /* RW-4R */
#define NV_PRM_INTR_0_TRACE_MPU401                              0:0 /* RWXVF */
#define NV_PRM_INTR_0_TRACE_MPU401_NOT_PENDING           0x00000000 /* R---V */
#define NV_PRM_INTR_0_TRACE_MPU401_PENDING               0x00000001 /* R---V */
#define NV_PRM_INTR_0_TRACE_MPU401_RESET                 0x00000001 /* -W--V */
#define NV_PRM_INTR_0_TRACE_FM                                  4:4 /* RWXVF */
#define NV_PRM_INTR_0_TRACE_FM_NOT_PENDING               0x00000000 /* R---V */
#define NV_PRM_INTR_0_TRACE_FM_PENDING                   0x00000001 /* R---V */
#define NV_PRM_INTR_0_TRACE_FM_RESET                     0x00000001 /* -W--V */
#define NV_PRM_INTR_0_TRACE_SB_DIGITAL                          8:8 /* RWXVF */
#define NV_PRM_INTR_0_TRACE_SB_DIGITAL_NOT_PENDING       0x00000000 /* R---V */
#define NV_PRM_INTR_0_TRACE_SB_DIGITAL_PENDING           0x00000001 /* R---V */
#define NV_PRM_INTR_0_TRACE_SB_DIGITAL_RESET             0x00000001 /* -W--V */
#define NV_PRM_INTR_0_TRACE_SB_MIXER                          12:12 /* RWXVF */
#define NV_PRM_INTR_0_TRACE_SB_MIXER_NOT_PENDING         0x00000000 /* R---V */
#define NV_PRM_INTR_0_TRACE_SB_MIXER_PENDING             0x00000001 /* R---V */
#define NV_PRM_INTR_0_TRACE_SB_MIXER_RESET               0x00000001 /* -W--V */
#define NV_PRM_INTR_0_TRACE_OVERFLOW                          16:16 /* RWXVF */
#define NV_PRM_INTR_0_TRACE_OVERFLOW_NOT_PENDING         0x00000000 /* R---V */
#define NV_PRM_INTR_0_TRACE_OVERFLOW_PENDING             0x00000001 /* R---V */
#define NV_PRM_INTR_0_TRACE_OVERFLOW_RESET               0x00000001 /* -W--V */
#define NV_PRM_INTR_EN_0                                 0x00004140 /* RW-4R */
#define NV_PRM_INTR_EN_0_TRACE_MPU401                           0:0 /* RWIVF */
#define NV_PRM_INTR_EN_0_TRACE_MPU401_DISABLED           0x00000000 /* RWI-V */
#define NV_PRM_INTR_EN_0_TRACE_MPU401_ENABLED            0x00000001 /* RW--V */
#define NV_PRM_INTR_EN_0_TRACE_FM                               4:4 /* RWIVF */
#define NV_PRM_INTR_EN_0_TRACE_FM_DISABLED               0x00000000 /* RWI-V */
#define NV_PRM_INTR_EN_0_TRACE_FM_ENABLED                0x00000001 /* RW--V */
#define NV_PRM_INTR_EN_0_TRACE_SB_DIGITAL                       8:8 /* RWIVF */
#define NV_PRM_INTR_EN_0_TRACE_SB_DIGITAL_DISABLED       0x00000000 /* RWI-V */
#define NV_PRM_INTR_EN_0_TRACE_SB_DIGITAL_ENABLED        0x00000001 /* RW--V */
#define NV_PRM_INTR_EN_0_TRACE_SB_MIXER                       12:12 /* RWIVF */
#define NV_PRM_INTR_EN_0_TRACE_SB_MIXER_DISABLED         0x00000000 /* RWI-V */
#define NV_PRM_INTR_EN_0_TRACE_SB_MIXER_ENABLED          0x00000001 /* RW--V */
#define NV_PRM_INTR_EN_0_TRACE_OVERFLOW                       16:16 /* RWIVF */
#define NV_PRM_INTR_EN_0_TRACE_OVERFLOW_DISABLED         0x00000000 /* RWI-V */
#define NV_PRM_INTR_EN_0_TRACE_OVERFLOW_ENABLED          0x00000001 /* RW--V */
#define NV_PRM_RAMRM                                     0x00004200 /* RW-4R */
#define NV_PRM_RAMRM_BASE_ADDRESS                             15:12 /* RWXVF */
#define NV_PRM_RAMRM_BASE_ADDRESS_2000                   0x00002000 /* RWI-V */
#define NV_PRM_TRACE                                     0x00004300 /* RW-4R */
#define NV_PRM_TRACE_IO_CAPTURE                                 1:0 /* RWIVF */
#define NV_PRM_TRACE_IO_CAPTURE_DISABLED                 0x00000000 /* RWI-V */
#define NV_PRM_TRACE_IO_CAPTURE_WRITES                   0x00000001 /* RW--V */
#define NV_PRM_TRACE_IO_CAPTURE_READS                    0x00000002 /* RW--V */
#define NV_PRM_TRACE_IO_CAPTURE_READS_WRITES             0x00000003 /* RW--V */
#define NV_PRM_TRACE_IO_WRITE                                   4:4 /* RWXVF */
#define NV_PRM_TRACE_IO_WRITE_NONE                       0x00000000 /* R---V */
#define NV_PRM_TRACE_IO_WRITE_OCCURED                    0x00000001 /* R---V */
#define NV_PRM_TRACE_IO_WRITE_RESET                      0x00000001 /* -W--V */
#define NV_PRM_TRACE_IO_READ                                    5:5 /* RWXVF */
#define NV_PRM_TRACE_IO_READ_NONE                        0x00000000 /* R---V */
#define NV_PRM_TRACE_IO_READ_OCCURED                     0x00000001 /* R---V */
#define NV_PRM_TRACE_IO_READ_RESET                       0x00000001 /* -W--V */
#define NV_PRM_TRACE_INDEX                               0x00004310 /* RW-4R */
#define NV_PRM_TRACE_INDEX_ADDRESS                              9:0 /* RWXUF */
#define NV_PRM_TRACE_INDEX_ADDRESS_0                     0x00000000 /* RW--V */
#define NV_PRM_IGNORE_0                                  0x00004320 /* RW-4R */
#define NV_PRM_IGNORE_0_MPU401                                  1:0 /* RWXVF */
#define NV_PRM_IGNORE_0_MPU401_DISABLED                  0x00000000 /* RW--V */
#define NV_PRM_IGNORE_0_MPU401_WRITES                    0x00000001 /* RW--V */
#define NV_PRM_IGNORE_0_MPU401_READS                     0x00000002 /* RW--V */
#define NV_PRM_IGNORE_0_MPU401_READS_WRITES              0x00000003 /* RW--V */
#define NV_PRM_IGNORE_0_FM                                      5:4 /* RWXVF */
#define NV_PRM_IGNORE_0_FM_DISABLED                      0x00000000 /* RW--V */
#define NV_PRM_IGNORE_0_FM_WRITES                        0x00000001 /* RW--V */
#define NV_PRM_IGNORE_0_FM_READS                         0x00000002 /* RW--V */
#define NV_PRM_IGNORE_0_FM_READS_WRITES                  0x00000003 /* RW--V */
#define NV_PRM_IGNORE_0_SB_DIGITAL                              9:8 /* RWXVF */
#define NV_PRM_IGNORE_0_SB_DIGITAL_DISABLED              0x00000000 /* RW--V */
#define NV_PRM_IGNORE_0_SB_DIGITAL_WRITES                0x00000001 /* RW--V */
#define NV_PRM_IGNORE_0_SB_DIGITAL_READS                 0x00000002 /* RW--V */
#define NV_PRM_IGNORE_0_SB_DIGITAL_READS_WRITES          0x00000003 /* RW--V */
#define NV_PRM_IGNORE_0_SB_MIXER                              13:12 /* RWXVF */
#define NV_PRM_IGNORE_0_SB_MIXER_DISABLED                0x00000000 /* RW--V */
#define NV_PRM_IGNORE_0_SB_MIXER_WRITES                  0x00000001 /* RW--V */
#define NV_PRM_IGNORE_0_SB_MIXER_READS                   0x00000002 /* RW--V */
#define NV_PRM_IGNORE_0_SB_MIXER_READS_WRITES            0x00000003 /* RW--V */
/* dev_realmode.ref */
#define NV_PRMIO                              0x00007FFF:0x00007000 /* RW--D */
/* dev_realmode.ref */
/* dev_fifo.ref */
#define NV_USER                               0x00FFFFFF:0x00800000 /* RW--D */
#define NV_USER_OBJECT(i,j)     (0x00800000+(i)*0x10000+(j)*0x2000) /* -W-4A */
#define NV_USER_OBJECT__SIZE_1                                   16 /*       */
#define NV_USER_OBJECT__SIZE_2                                    8 /*       */
#define NV_USER_OBJECT_HANDLE                                  31:0 /* -W-VF */
#define NV_USER_FREE016(i,j)        (0x00800010+(i)*65536+(j)*8192) /* R--2A */
#define NV_USER_FREE016__SIZE_1                                  16 /*       */
#define NV_USER_FREE016__SIZE_2                                   8 /*       */
#define NV_USER_FREE016_COUNT_LO                                1:0 /* C--UF */
#define NV_USER_FREE016_COUNT_LO_0                       0x00000000 /* C---V */
#define NV_USER_FREE016_COUNT                                   9:2 /* R--UF */
#define NV_USER_FREE016_COUNT_HI                              15:10 /* C--UF */
#define NV_USER_FREE016_COUNT_HI_0                       0x00000000 /* C---V */
#define NV_USER_FREE032(i,j)        (0x00800010+(i)*65536+(j)*8192) /* R--4A */
#define NV_USER_FREE032__SIZE_1                                  16 /*       */
#define NV_USER_FREE032__SIZE_2                                   8 /*       */
#define NV_USER_FREE032_COUNT_LO                                1:0 /* C--UF */
#define NV_USER_FREE032_COUNT_LO_0                       0x00000000 /* C---V */
#define NV_USER_FREE032_COUNT                                   9:2 /* R--UF */
#define NV_USER_FREE032_COUNT_HI                              31:10 /* C--UF */
#define NV_USER_FREE032_COUNT_HI_0                       0x00000000 /* C---V */
#define NV_USER_ZERO016(i,j,k) (0x0800012+(i)*65536+(j)*8192+(k)*2) /* R--2A */
#define NV_USER_ZERO016__SIZE_1                                  16 /*       */
#define NV_USER_ZERO016__SIZE_2                                   8 /*       */
#define NV_USER_ZERO016__SIZE_3                                   7 /*       */
#define NV_USER_ZERO016_COUNT                                  15:0 /* C--UF */
#define NV_USER_ZERO016_COUNT_0                          0x00000000 /* C---V */
#define NV_USER_ZERO032(i,j,k) (0x0800014+(i)*65536+(j)*8192+(k)*4) /* R--4A */
#define NV_USER_ZERO032__SIZE_1                                  16 /*       */
#define NV_USER_ZERO032__SIZE_2                                   8 /*       */
#define NV_USER_ZERO032__SIZE_3                                   3 /*       */
#define NV_USER_ZERO032_COUNT                                  31:0 /* C--UF */
#define NV_USER_ZERO032_COUNT_0                          0x00000000 /* C---V */
#define NV_USER_DMA_PUT(i,j)    (0x00800040+(i)*0x10000+(j)*0x2000) /* -W-4A */
#define NV_USER_DMA_PUT_OFFSET                                 28:2 /* -WXUF */
#define NV_USER_DMA_GET(i,j)    (0x00800044+(i)*0x10000+(j)*0x2000) /* R--4A */
#define NV_USER_DMA_GET_OFFSET                                 28:2 /* R-XUF */
/* dev_misc.ref */
#define NV_USER_ADR_CHID                                      22:16 /*       */
#define NV_USER_ADR_SUBCHID                                   15:13 /*       */
#define NV_USER_ADR_METHOD                                     12:0 /*       */
#define NV_USER_DEVICE                                        22:16 /*       */
/* dev_timer.ref */
#define NV_PTIMER                             0x00009FFF:0x00009000 /* RW--D */
#define NV_PTIMER_INTR_0                                 0x00009100 /* RW-4R */
#define NV_PTIMER_INTR_0_ALARM                                  0:0 /* RWXVF */
#define NV_PTIMER_INTR_0_ALARM_NOT_PENDING               0x00000000 /* R---V */
#define NV_PTIMER_INTR_0_ALARM_PENDING                   0x00000001 /* R---V */
#define NV_PTIMER_INTR_0_ALARM_RESET                     0x00000001 /* -W--V */
#define NV_PTIMER_INTR_EN_0                              0x00009140 /* RW-4R */
#define NV_PTIMER_INTR_EN_0_ALARM                               0:0 /* RWIVF */
#define NV_PTIMER_INTR_EN_0_ALARM_DISABLED               0x00000000 /* RWI-V */
#define NV_PTIMER_INTR_EN_0_ALARM_ENABLED                0x00000001 /* RW--V */
#define NV_PTIMER_NUMERATOR                              0x00009200 /* RW-4R */
#define NV_PTIMER_NUMERATOR_VALUE                              15:0 /* RWIUF */
#define NV_PTIMER_NUMERATOR_VALUE_0                      0x00000000 /* RWI-V */
#define NV_PTIMER_DENOMINATOR                            0x00009210 /* RW-4R */
#define NV_PTIMER_DENOMINATOR_VALUE                            15:0 /* RWIUF */
#define NV_PTIMER_DENOMINATOR_VALUE_0                    0x00000000 /* RWI-V */
#define NV_PTIMER_TIME_0                                 0x00009400 /* RW-4R */
#define NV_PTIMER_TIME_0_NSEC                                  31:5 /* RWXUF */
#define NV_PTIMER_TIME_1                                 0x00009410 /* RW-4R */
#define NV_PTIMER_TIME_1_NSEC                                  28:0 /* RWXUF */
#define NV_PTIMER_ALARM_0                                0x00009420 /* RW-4R */
#define NV_PTIMER_ALARM_0_NSEC                                 31:5 /* RWXUF */
/* dev_realmode.ref */
#define NV_TRACE                              0x0000FFFF:0x00000000 /* RW--M */
#define NV_TRACE_DATA                         ( 0*32+ 7):( 0*32+ 0) /* RWXVF */
#define NV_TRACE_ACCESS                       ( 0*32+14):( 0*32+14) /* RWXVF */
#define NV_TRACE_ACCESS_WRITE                            0x00000000 /* RW--V */
#define NV_TRACE_ACCESS_READ                             0x00000001 /* RW--V */
#define NV_TRACE_TYPE                         ( 0*32+15):( 0*32+15) /* RWXVF */
#define NV_TRACE_TYPE_IO                                 0x00000000 /* RW--V */
#define NV_TRACE_TYPE_MEMORY                             0x00000001 /* RW--V */
#define NV_TRACE_ADDRESS                      ( 0*32+31):( 0*32+16) /* RWXUF */
/* dev_ram.ref */
#define NV_RAMHT__SIZE_0                      0x00000FFF:0x00000000 /* RW--M */
#define NV_RAMHT__SIZE_1                      0x00001FFF:0x00000000 /* RW--M */
#define NV_RAMHT__SIZE_2                      0x00003FFF:0x00000000 /* RW--M */
#define NV_RAMHT__SIZE_3                      0x00007FFF:0x00000000 /* RW--M */
#define NV_RAMHT_HANDLE                       ( 0*32+31):( 0*32+ 0) /* RWXVF */
#define NV_RAMHT_INSTANCE                     ( 1*32+15):( 1*32+ 0) /* RWXUF */
#define NV_RAMHT_ENGINE                       ( 1*32+17):( 1*32+16) /* RWXVF */
#define NV_RAMHT_ENGINE_SW                               0x00000000 /* RW--V */
#define NV_RAMHT_ENGINE_GRAPHICS                         0x00000001 /* RW--V */
#define NV_RAMHT_ENGINE_DVD                              0x00000002 /* RW--V */
#define NV_RAMHT_CHID                         ( 1*32+27):( 1*32+24) /* RWXUF */
#define NV_RAMHT_STATUS                       ( 1*32+31):( 1*32+31) /* RWXUF */
#define NV_RAMHT_STATUS_INVALID                          0x00000000 /* RW--V */
#define NV_RAMHT_STATUS_VALID                            0x00000001 /* RW--V */
/* dev_ram.ref */
#define NV_RAMRO__SIZE_0                      0x000001FF:0x00000000 /* RW--M */
#define NV_RAMRO__SIZE_1                      0x00001FFF:0x00000000 /* RW--M */
#define NV_RAMRO_METHOD                       ( 0*32+12):( 0*32+ 0) /* RWXUF */
#define NV_RAMRO_SUBCHANNEL                   ( 0*32+15):( 0*32+13) /* RWXUF */
#define NV_RAMRO_CHID                         ( 0*32+22):( 0*32+16) /* RWXUF */
#define NV_RAMRO_TYPE                         ( 0*32+23):( 0*32+23) /* RWXVF */
#define NV_RAMRO_TYPE_WRITE                              0x00000000 /* RW--V */
#define NV_RAMRO_TYPE_READ                               0x00000001 /* RW--V */
#define NV_RAMRO_BYTE_ENABLES                 ( 0*32+27):( 0*32+24) /* RWXVF */
#define NV_RAMRO_REASON                       ( 0*32+31):( 0*32+28) /* RWXVF */
#define NV_RAMRO_REASON_ILLEGAL_ACCESS                   0x00000000 /* RW--V */
#define NV_RAMRO_REASON_NO_CACHE_AVAILABLE               0x00000001 /* RW--V */
#define NV_RAMRO_REASON_CACHE_RAN_OUT                    0x00000002 /* RW--V */
#define NV_RAMRO_REASON_FREE_COUNT_OVERRUN               0x00000003 /* RW--V */
#define NV_RAMRO_REASON_CAUGHT_LYING                     0x00000004 /* RW--V */
#define NV_RAMRO_REASON_RESERVED_ACCESS                  0x00000005 /* RW--V */
#define NV_RAMRO_DATA                         ( 1*32+31):( 1*32+ 0) /* RWXVF */
/* dev_ram.ref */
#define NV_RAMFC__SIZE_0                      0x000001FF:0x00000000 /* RW--M */
#define NV_RAMFC_DMA_PUT                      ( 0*32+28):( 0*32+ 2) /* RWXUF */
#define NV_RAMFC_DMA_GET                      ( 1*32+28):( 1*32+ 2) /* RWXUF */
#define NV_RAMFC_DMA_INST                     ( 2*32+15):( 2*32+ 0) /* RWXUF */
#define NV_RAMFC_DMA_METHOD                   ( 3*32+12):( 3*32+ 2) /* RWXUF */
#define NV_RAMFC_DMA_SUBCHANNEL               ( 3*32+15):( 3*32+13) /* RWXUF */
#define NV_RAMFC_DMA_METHOD_COUNT             ( 3*32+28):( 3*32+18) /* RWXUF */
#define NV_RAMFC_DMA_FETCH_TRIG               ( 4*32+ 7):( 4*32+ 3) /* RWXUF */
#define NV_RAMFC_DMA_FETCH_SIZE               ( 4*32+15):( 4*32+13) /* RWXUF */
#define NV_RAMFC_DMA_FETCH_MAX_REQS           ( 4*32+19):( 4*32+16) /* RWXUF */
#define NV_RAMFC_ENGINE_SUB_0                 ( 5*32+ 1):( 5*32+ 0) /* RWXUF */
#define NV_RAMFC_ENGINE_SUB_1                 ( 5*32+ 5):( 5*32+ 4) /* RWXUF */
#define NV_RAMFC_ENGINE_SUB_2                 ( 5*32+ 9):( 5*32+ 8) /* RWXUF */
#define NV_RAMFC_ENGINE_SUB_3                 ( 5*32+13):( 5*32+12) /* RWXUF */
#define NV_RAMFC_ENGINE_SUB_4                 ( 5*32+17):( 5*32+16) /* RWXUF */
#define NV_RAMFC_ENGINE_SUB_5                 ( 5*32+21):( 5*32+20) /* RWXUF */
#define NV_RAMFC_ENGINE_SUB_6                 ( 5*32+25):( 5*32+24) /* RWXUF */
#define NV_RAMFC_ENGINE_SUB_7                 ( 5*32+29):( 5*32+28) /* RWXUF */
#define NV_RAMFC_ENGINE_SW                               0x00000000 /* RW--V */
#define NV_RAMFC_ENGINE_GRAPHICS                         0x00000001 /* RW--V */
#define NV_RAMFC_ENGINE_DVD                              0x00000002 /* RW--V */
#define NV_RAMFC_PULL1_ENGINE                 ( 6*32+ 1):( 6*32+ 0) /* RWXUF */
#define NV_RAMFC_PULL1_ENGINE_SW                         0x00000000 /* RW--V */
#define NV_RAMFC_PULL1_ENGINE_GRAPHICS                   0x00000001 /* RW--V */
#define NV_RAMFC_PULL1_ENGINE_DVD                        0x00000002 /* RW--V */
/* dev_ram.ref */
/* dev_ram.ref */
/* dev_ram.ref */
#define NV_RAMDVD_CTX_TABLE                   (63*32+31):( 0*32+ 0) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT(c,s) (((c)*4+((s)/2))*32+((s)%2)*16+15):(((c)*4+((s)/2))*32+((s)%2)*16) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_0        ( 0*32+15):( 0*32+ 0) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_1        ( 0*32+31):( 0*32+16) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_2        ( 1*32+15):( 1*32+ 0) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_3        ( 1*32+31):( 1*32+16) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_4        ( 2*32+15):( 2*32+ 0) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_5        ( 2*32+31):( 2*32+16) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_6        ( 3*32+15):( 3*32+ 0) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_7        ( 3*32+31):( 3*32+16) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_0       (60*32+15):(60*32+ 0) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_1       (60*32+31):(60*32+16) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_2       (61*32+15):(61*32+ 0) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_3       (61*32+31):(61*32+16) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_4       (62*32+15):(62*32+ 0) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_5       (62*32+31):(62*32+16) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_6       (63*32+15):(63*32+ 0) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_7       (63*32+31):(63*32+16) /* RWXUF */
/* dev_ram.ref */
/* dev_ram.ref */
#define NV_DMA_CLASS                          ( 0*32+11):( 0*32+ 0) /* RWXUF */
#define NV_DMA_PAGE_TABLE                     ( 0*32+12):( 0*32+12) /* RWXVF */
#define NV_DMA_PAGE_TABLE_NOT_PRESENT                    0x00000000 /* RW--V */
#define NV_DMA_PAGE_TABLE_PRESENT                        0x00000001 /* RW--V */
#define NV_DMA_PAGE_ENTRY                     ( 0*32+13):( 0*32+13) /* RWXVF */
#define NV_DMA_PAGE_ENTRY_NOT_LINEAR                     0x00000000 /* RW--V */
#define NV_DMA_PAGE_ENTRY_LINEAR                         0x00000001 /* RW--V */
#define NV_DMA_TARGET_NODE                    ( 0*32+17):( 0*32+16) /* RWXVF */
#define NV_DMA_TARGET_NODE_NVM                           0x00000000 /* RW--V */
#define NV_DMA_TARGET_NODE_PCI                           0x00000002 /* RW--V */
#define NV_DMA_TARGET_NODE_AGP                           0x00000003 /* RW--V */
#define NV_DMA_ADJUST                         ( 0*32+31):( 0*32+20) /* RWXUF */
#define NV_DMA_LIMIT                          ( 1*32+31):( 1*32+ 0) /* RWXUF */
#define NV_DMA_ACCESS                         ( 2*32+ 1):( 2*32+ 1) /* RWXVF */
#define NV_DMA_ACCESS_READ_ONLY                          0x00000000 /* RW--V */
#define NV_DMA_ACCESS_READ_AND_WRITE                     0x00000001 /* RW--V */
#define NV_DMA_FRAME_ADDRESS                  ( 2*32+31):( 2*32+12) /* RWXUF */
/* dev_ram.ref */
#define NV_SUBCHAN_CTX_SWITCH                 ( 0*32+31):( 0*32+ 0) /* RWXUF */
#define NV_SUBCHAN_DMA_INSTANCE               ( 1*32+15):( 1*32+ 0) /* RWXUF */
#define NV_SUBCHAN_NOTIFY_INSTANCE            ( 1*32+31):( 1*32+16) /* RWXUF */
#define NV_SUBCHAN_MEMFMT_INSTANCE            ( 2*32+15):( 2*32+ 0) /* RWXUF */
#define NV_SUBCHAN_MEMFMT_LINEAR              ( 2*32+16):( 2*32+16) /* RWXUF */
#define NV_SUBCHAN_MEMFMT_LINEAR_OUT                     0x00000000 /* RW--V */
#define NV_SUBCHAN_MEMFMT_LINEAR_IN                      0x00000001 /* RW--V */

#endif /* _NV_REG_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\nv3_ref.h ===
/* @(#) $Header: /resman.040/inc/nv3_ref.h 16    10/28/97 1:07p Kevink $
 NVidia Corporation */
/* basis: nv1 manuals 10.1
 95/06/27 NVidia Corporation */

#ifndef _NV_REF_H_
#define _NV_REF_H_

/* dev_bus.ref */
#define NV_SPACE                              0x01FFFFFF:0x00000000 /* RW--D */
/* dev_bus.ref */
#define NV_MSPACE                             0x00FFFFFF:0x00000000 /* RW--D */
/* dev_bus.ref */
#define NV_RSPACE                             0x00FFFFFF:0x00000000 /* RW--D */
/* dev_bus.ref */
#define NV_CONFIG                             0x000000FF:0x00000000 /* RW--D */
#define NV_CONFIG_PCI_NV_0                               0x00000000 /* R--4R */
#define NV_CONFIG_PCI_NV_0__ALIAS_1                NV_PBUS_PCI_NV_0 /*       */
#define NV_CONFIG_PCI_NV_0_VENDOR_ID                           15:0 /* C--UF */
#define NV_CONFIG_PCI_NV_0_VENDOR_ID_NVIDIA_SGS          0x000012D2 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_FUNC                     18:16 /* C--UF */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_FUNC_VGA            0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_CHIP                     31:19 /* C--UF */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_CHIP_NV0            0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_CHIP_NV1            0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_CHIP_NV2            0x00000002 /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_CHIP_NV3            0x00000003 /* C---V */
#define NV_CONFIG_PCI_NV_1                               0x00000004 /* RW-4R */
#define NV_CONFIG_PCI_NV_1__ALIAS_1                NV_PBUS_PCI_NV_1 /*       */
#define NV_CONFIG_PCI_NV_1_IO_SPACE                             0:0 /* RWIVF */
#define NV_CONFIG_PCI_NV_1_IO_SPACE_DISABLED             0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_1_IO_SPACE_ENABLED              0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_1_MEMORY_SPACE                         1:1 /* RWIVF */
#define NV_CONFIG_PCI_NV_1_MEMORY_SPACE_DISABLED         0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_1_MEMORY_SPACE_ENABLED          0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_1_BUS_MASTER                           2:2 /* RWIVF */
#define NV_CONFIG_PCI_NV_1_BUS_MASTER_DISABLED           0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_1_BUS_MASTER_ENABLED            0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_1_WRITE_AND_INVAL                      4:4 /* C--VF */
#define NV_CONFIG_PCI_NV_1_WRITE_AND_INVAL_DISABLED      0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_1_WRITE_AND_INVAL_ENABLED       0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_1_PALETTE_SNOOP                        5:5 /* RWIVF */
#define NV_CONFIG_PCI_NV_1_PALETTE_SNOOP_DISABLED        0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_1_PALETTE_SNOOP_ENABLED         0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_1_CAPLIST                            20:20 /* R--VF */
#define NV_CONFIG_PCI_NV_1_CAPLIST_NOT_PRESENT           0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_1_CAPLIST_PRESENT               0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_1_66MHZ                              21:21 /* C--VF */
#define NV_CONFIG_PCI_NV_1_66MHZ_INCAPABLE               0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_1_66MHZ_CAPABLE                 0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_1_FAST_BACK2BACK                     23:23 /* C--VF */
#define NV_CONFIG_PCI_NV_1_FAST_BACK2BACK_INCAPABLE      0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_1_FAST_BACK2BACK_CAPABLE        0x00000001 /* C---V */
#define NV_CONFIG_PCI_NV_1_DEVSEL_TIMING                      26:25 /* C--VF */
#define NV_CONFIG_PCI_NV_1_DEVSEL_TIMING_FAST            0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_1_DEVSEL_TIMING_MEDIUM          0x00000001 /* C---V */
#define NV_CONFIG_PCI_NV_1_DEVSEL_TIMING_SLOW            0x00000002 /* ----V */
#define NV_CONFIG_PCI_NV_1_SIGNALED_TARGET                    27:27 /* RWIVF */
#define NV_CONFIG_PCI_NV_1_SIGNALED_TARGET_NO_ABORT      0x00000000 /* R-I-V */
#define NV_CONFIG_PCI_NV_1_SIGNALED_TARGET_ABORT         0x00000001 /* R---V */
#define NV_CONFIG_PCI_NV_1_SIGNALED_TARGET_CLEAR         0x00000001 /* -W--V */
#define NV_CONFIG_PCI_NV_1_RECEIVED_TARGET                    28:28 /* RWIVF */
#define NV_CONFIG_PCI_NV_1_RECEIVED_TARGET_NO_ABORT      0x00000000 /* R-I-V */
#define NV_CONFIG_PCI_NV_1_RECEIVED_TARGET_ABORT         0x00000001 /* R---V */
#define NV_CONFIG_PCI_NV_1_RECEIVED_TARGET_CLEAR         0x00000001 /* -W--V */
#define NV_CONFIG_PCI_NV_1_RECEIVED_MASTER                    29:29 /* RWIVF */
#define NV_CONFIG_PCI_NV_1_RECEIVED_MASTER_NO_ABORT      0x00000000 /* R-I-V */
#define NV_CONFIG_PCI_NV_1_RECEIVED_MASTER_ABORT         0x00000001 /* R---V */
#define NV_CONFIG_PCI_NV_1_RECEIVED_MASTER_CLEAR         0x00000001 /* -W--V */
#define NV_CONFIG_PCI_NV_2                               0x00000008 /* R--4R */
#define NV_CONFIG_PCI_NV_2__ALIAS_1                NV_PBUS_PCI_NV_2 /*       */
#define NV_CONFIG_PCI_NV_2_REVISION_ID                          7:0 /* C--UF */
#define NV_CONFIG_PCI_NV_2_REVISION_ID_A01               0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_2_REVISION_ID_B01               0x00000010 /* C---V */
#define NV_CONFIG_PCI_NV_2_CLASS_CODE                          31:8 /* C--VF */
#define NV_CONFIG_PCI_NV_2_CLASS_CODE_VGA                0x00030000 /* C---V */
#define NV_CONFIG_PCI_NV_2_CLASS_CODE_MULTIMEDIA         0x00048000 /* ----V */
#define NV_CONFIG_PCI_NV_3                               0x0000000C /* RW-4R */
#define NV_CONFIG_PCI_NV_3__ALIAS_1                NV_PBUS_PCI_NV_3 /*       */
#define NV_CONFIG_PCI_NV_3_LATENCY_TIMER                      15:11 /* RWIUF */
#define NV_CONFIG_PCI_NV_3_LATENCY_TIMER_0_CLOCKS        0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_3_LATENCY_TIMER_8_CLOCKS        0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_3_LATENCY_TIMER_240_CLOCKS      0x0000001E /* RW--V */
#define NV_CONFIG_PCI_NV_3_LATENCY_TIMER_248_CLOCKS      0x0000001F /* RW--V */
#define NV_CONFIG_PCI_NV_3_HEADER_TYPE                        23:16 /* C--VF */
#define NV_CONFIG_PCI_NV_3_HEADER_TYPE_SINGLEFUNC        0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_3_HEADER_TYPE_MULTIFUNC         0x00000080 /* ----V */
#define NV_CONFIG_PCI_NV_4                               0x00000010 /* RW-4R */
#define NV_CONFIG_PCI_NV_4__ALIAS_1                NV_PBUS_PCI_NV_4 /*       */
#define NV_CONFIG_PCI_NV_4_SPACE_TYPE                           0:0 /* C--VF */
#define NV_CONFIG_PCI_NV_4_SPACE_TYPE_MEMORY             0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_4_SPACE_TYPE_IO                 0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_4_ADDRESS_TYPE                         2:1 /* C--VF */
#define NV_CONFIG_PCI_NV_4_ADDRESS_TYPE_32_BIT           0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_4_ADDRESS_TYPE_20_BIT           0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_4_ADDRESS_TYPE_64_BIT           0x00000002 /* ----V */
#define NV_CONFIG_PCI_NV_4_PREFETCHABLE                         3:3 /* C--VF */
#define NV_CONFIG_PCI_NV_4_PREFETCHABLE_NOT              0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_4_PREFETCHABLE_MERGABLE         0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_4_BASE_ADDRESS                       31:24 /* RWXUF */
#define NV_CONFIG_PCI_NV_5                               0x00000014 /* RW-4R */
#define NV_CONFIG_PCI_NV_5__ALIAS_1                NV_PBUS_PCI_NV_5 /*       */
#define NV_CONFIG_PCI_NV_5_SPACE_TYPE                           0:0 /* C--VF */
#define NV_CONFIG_PCI_NV_5_SPACE_TYPE_MEMORY             0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_5_SPACE_TYPE_IO                 0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_5_ADDRESS_TYPE                         2:1 /* C--VF */
#define NV_CONFIG_PCI_NV_5_ADDRESS_TYPE_32_BIT           0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_5_ADDRESS_TYPE_20_BIT           0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_5_ADDRESS_TYPE_64_BIT           0x00000002 /* ----V */
#define NV_CONFIG_PCI_NV_5_PREFETCHABLE                         3:3 /* C--VF */
#define NV_CONFIG_PCI_NV_5_PREFETCHABLE_NOT              0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_5_PREFETCHABLE_MERGABLE         0x00000001 /* C---V */
#define NV_CONFIG_PCI_NV_5_BASE_ADDRESS                       31:24 /* RWXUF */
#define NV_CONFIG_PCI_NV_6                               0x00000018 /* RW-4R */
#define NV_CONFIG_PCI_NV_6__ALIAS_1                NV_PBUS_PCI_NV_6 /*       */
#define NV_CONFIG_PCI_NV_6_SPACE_TYPE                           0:0 /* C--VF */
#define NV_CONFIG_PCI_NV_6_SPACE_TYPE_MEMORY             0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_6_SPACE_TYPE_IO                 0x00000001 /* C---V */
#define NV_CONFIG_PCI_NV_6_BASE_ADDRESS                        31:8 /* RWXUF */
#define NV_CONFIG_PCI_NV_7(i)                    (0x0000001C+(i)*4) /* R--4A */
#define NV_CONFIG_PCI_NV_7__SIZE_1                                4 /*       */
#define NV_CONFIG_PCI_NV_7__ALIAS_1                NV_PBUS_PCI_NV_7 /*       */
#define NV_CONFIG_PCI_NV_7_RESERVED                            31:0 /* C--VF */
#define NV_CONFIG_PCI_NV_7_RESERVED_0                    0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_11                              0x0000002C /* R--4R */
#define NV_CONFIG_PCI_NV_11__ALIAS_1              NV_PBUS_PCI_NV_11 /*       */
#define NV_CONFIG_PCI_NV_11_SUBSYSTEM_VENDOR_ID                15:0 /* R--UF */
#define NV_CONFIG_PCI_NV_11_SUBSYSTEM_VENDOR_ID_NONE     0x00000000 /* R---V */
#define NV_CONFIG_PCI_NV_11_SUBSYSTEM_ID                      31:16 /* R--UF */
#define NV_CONFIG_PCI_NV_11_SUBSYSTEM_ID_NONE            0x00000000 /* R---V */
#define NV_CONFIG_PCI_NV_12                              0x00000030 /* RW-4R */
#define NV_CONFIG_PCI_NV_12__ALIAS_1              NV_PBUS_PCI_NV_12 /*       */
#define NV_CONFIG_PCI_NV_12_ROM_DECODE                          0:0 /* RWIVF */
#define NV_CONFIG_PCI_NV_12_ROM_DECODE_DISABLED          0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_12_ROM_DECODE_ENABLED           0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_12_ROM_BASE                          31:22 /* RWXUF */
#define NV_CONFIG_PCI_NV_13                              0x00000034 /* RW-4R */
#define NV_CONFIG_PCI_NV_13__ALIAS_1              NV_PBUS_PCI_NV_13 /*       */
#define NV_CONFIG_PCI_NV_13_CAP_PTR                             7:0 /* C--VF */
#define NV_CONFIG_PCI_NV_13_CAP_PTR_AGP                  0x00000044 /* C---V */
#define NV_CONFIG_PCI_NV_14                              0x00000038 /* R--4A */
#define NV_CONFIG_PCI_NV_14__ALIAS_1              NV_PBUS_PCI_NV_14 /*       */
#define NV_CONFIG_PCI_NV_14_RESERVED                           31:0 /* C--VF */
#define NV_CONFIG_PCI_NV_14_RESERVED_0                   0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_15                              0x0000003C /* RW-4R */
#define NV_CONFIG_PCI_NV_15__ALIAS_1              NV_PBUS_PCI_NV_15 /*       */
#define NV_CONFIG_PCI_NV_15_INTR_LINE                           7:0 /* RWIVF */
#define NV_CONFIG_PCI_NV_15_INTR_LINE_IRQ0               0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_15_INTR_LINE_IRQ1               0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_15_INTR_LINE_IRQ15              0x0000000F /* RW--V */
#define NV_CONFIG_PCI_NV_15_INTR_LINE_UNKNOWN            0x000000FF /* RW--V */
#define NV_CONFIG_PCI_NV_15_INTR_PIN                           15:8 /* C--VF */
#define NV_CONFIG_PCI_NV_15_INTR_PIN_INTA                0x00000001 /* C---V */
#define NV_CONFIG_PCI_NV_15_MIN_GNT                           23:16 /* C--VF */
#define NV_CONFIG_PCI_NV_15_MIN_GNT_NO_REQUIREMENTS      0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_15_MIN_GNT_750NS                0x00000003 /* C---V */
#define NV_CONFIG_PCI_NV_15_MAX_LAT                           31:24 /* C--VF */
#define NV_CONFIG_PCI_NV_15_MAX_LAT_NO_REQUIREMENTS      0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_15_MAX_LAT_250NS                0x00000001 /* C---V */
#define NV_CONFIG_PCI_NV_16                              0x00000040 /* RW-4R */
#define NV_CONFIG_PCI_NV_16__ALIAS_1              NV_PBUS_PCI_NV_16 /*       */
#define NV_CONFIG_PCI_NV_16_SUBSYSTEM_VENDOR_ID                15:0 /* RW-VF */
#define NV_CONFIG_PCI_NV_16_SUBSYSTEM_VENDOR_ID_NONE     0x00000000 /* R---V */
#define NV_CONFIG_PCI_NV_16_SUBSYSTEM_ID                      31:16 /* RW-VF */
#define NV_CONFIG_PCI_NV_16_SUBSYSTEM_ID_NONE            0x00000000 /* R---V */
#define NV_CONFIG_PCI_NV_17                              0x00000044 /* RW-4R */
#define NV_CONFIG_PCI_NV_17__ALIAS_1              NV_PBUS_PCI_NV_17 /*       */
#define NV_CONFIG_PCI_NV_17_AGP_REV_MAJOR                     23:20 /* C--VF */
#define NV_CONFIG_PCI_NV_17_AGP_REV_MAJOR_1              0x00000001 /* C---V */
#define NV_CONFIG_PCI_NV_17_AGP_REV_MINOR                     19:16 /* C--VF */
#define NV_CONFIG_PCI_NV_17_AGP_REV_MINOR_0              0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_17_NEXT_PTR                           15:8 /* C--VF */
#define NV_CONFIG_PCI_NV_17_NEXT_PTR_NULL                0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_17_CAP_ID                              7:0 /* C--VF */
#define NV_CONFIG_PCI_NV_17_CAP_ID_AGP                   0x00000002 /* C---V */
#define NV_CONFIG_PCI_NV_18                              0x00000048 /* RW-4R */
#define NV_CONFIG_PCI_NV_18__ALIAS_1              NV_PBUS_PCI_NV_18 /*       */
#define NV_CONFIG_PCI_NV_18_AGP_STATUS_RQ                     31:24 /* C--VF */
#define NV_CONFIG_PCI_NV_18_AGP_STATUS_RQ_4              0x00000004 /* C---V */
#define NV_CONFIG_PCI_NV_18_AGP_STATUS_SBA                      9:9 /* C--VF */
#define NV_CONFIG_PCI_NV_18_AGP_STATUS_SBA_NONE          0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_18_AGP_STATUS_RATE                     1:0 /* C--VF */
#define NV_CONFIG_PCI_NV_18_AGP_STATUS_RATE_1X           0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_18_AGP_STATUS_RATE_2X           0x00000002 /* ----V */
#define NV_CONFIG_PCI_NV_18_AGP_STATUS_RATE_1X_AND_2X    0x00000003 /* C---V */
#define NV_CONFIG_PCI_NV_19                              0x0000004C /* RW-4R */
#define NV_CONFIG_PCI_NV_19__ALIAS_1              NV_PBUS_PCI_NV_19 /*       */
#define NV_CONFIG_PCI_NV_19_AGP_COMMAND_RQ_DEPTH              31:24 /* RWIVF */
#define NV_CONFIG_PCI_NV_19_AGP_COMMAND_RQ_DEPTH_0       0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_19_AGP_COMMAND_AGP_ENABLE              8:8 /* RWIVF */
#define NV_CONFIG_PCI_NV_19_AGP_COMMAND_AGP_ENABLE_OFF   0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_19_AGP_COMMAND_DATA_RATE               1:0 /* RWIVF */
#define NV_CONFIG_PCI_NV_19_AGP_COMMAND_DATA_RATE_OFF    0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_19_AGP_COMMAND_DATA_RATE_1X     0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_19_AGP_COMMAND_DATA_RATE_2X     0x00000002 /* RW--V */
#define NV_CONFIG_PCI_NV_20                              0x00000050 /* RW-4R */
#define NV_CONFIG_PCI_NV_20__ALIAS_1              NV_PBUS_PCI_NV_20 /*       */
#define NV_CONFIG_PCI_NV_20_SOUND_BLASTER                       0:0 /* RWIVF */
#define NV_CONFIG_PCI_NV_20_SOUND_BLASTER_DISABLED       0x00000000 /* RW--V */
#define NV_CONFIG_PCI_NV_20_SOUND_BLASTER_ENABLED        0x00000001 /* RWI-V */
#define NV_CONFIG_PCI_NV_20_FM_SYNTHESIS                        1:1 /* RWIVF */
#define NV_CONFIG_PCI_NV_20_FM_SYNTHESIS_DISABLED        0x00000000 /* RW--V */
#define NV_CONFIG_PCI_NV_20_FM_SYNTHESIS_ENABLED         0x00000001 /* RWI-V */
#define NV_CONFIG_PCI_NV_20_GAME_PORT                           2:2 /* RWIVF */
#define NV_CONFIG_PCI_NV_20_GAME_PORT_DISABLED           0x00000000 /* RW--V */
#define NV_CONFIG_PCI_NV_20_GAME_PORT_ENABLED            0x00000001 /* RWI-V */
#define NV_CONFIG_PCI_NV_20_MPU401_IO                           3:3 /* RWIVF */
#define NV_CONFIG_PCI_NV_20_MPU401_IO_DISABLED           0x00000000 /* RW--V */
#define NV_CONFIG_PCI_NV_20_MPU401_IO_ENABLED            0x00000001 /* RWI-V */
#define NV_CONFIG_PCI_NV_20_MPU401_IRQ                          4:4 /* RWIVF */
#define NV_CONFIG_PCI_NV_20_MPU401_IRQ_DISABLED          0x00000000 /* RW--V */
#define NV_CONFIG_PCI_NV_20_MPU401_IRQ_ENABLED           0x00000001 /* RWI-V */
#define NV_CONFIG_PCI_NV_20_IO_ALIASING                         5:5 /* RWIVF */
#define NV_CONFIG_PCI_NV_20_IO_ALIASING_DISABLED         0x00000000 /* RW--V */
#define NV_CONFIG_PCI_NV_20_IO_ALIASING_ENABLED          0x00000001 /* RWI-V */
#define NV_CONFIG_PCI_NV_20_LEGACY_AUDIO                        7:7 /* RWIVF */
#define NV_CONFIG_PCI_NV_20_LEGACY_AUDIO_ENABLED         0x00000000 /* RW--V */
#define NV_CONFIG_PCI_NV_20_LEGACY_AUDIO_DISABLED        0x00000001 /* RWI-V */
#define NV_CONFIG_PCI_NV_20_SB_BASE                             9:8 /* RWIVF */
#define NV_CONFIG_PCI_NV_20_SB_BASE_220H                 0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_20_SB_BASE_240H                 0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_20_SB_BASE_260H                 0x00000002 /* RW--V */
#define NV_CONFIG_PCI_NV_20_MPU_BASE                          13:12 /* RWIVF */
#define NV_CONFIG_PCI_NV_20_MPU_BASE_330H                0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_20_MPU_BASE_230H                0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_20_MPU_BASE_300H                0x00000002 /* RW--V */
#define NV_CONFIG_PCI_NV_20_DMA_SNOOP                         16:16 /* RWIVF */
#define NV_CONFIG_PCI_NV_20_DMA_SNOOP_DISABLED           0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_20_DMA_SNOOP_ENABLED            0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_21                              0x00000054 /* RW-4R */
#define NV_CONFIG_PCI_NV_21__ALIAS_1              NV_PBUS_PCI_NV_21 /*       */
#define NV_CONFIG_PCI_NV_21_VGA                                 0:0 /* RWIVF */
#define NV_CONFIG_PCI_NV_21_VGA_DISABLED                 0x00000000 /* RW--V */
#define NV_CONFIG_PCI_NV_21_VGA_ENABLED                  0x00000001 /* RWI-V */
#define NV_CONFIG_PCI_NV_22                              0x00000058 /* RW-4R */
#define NV_CONFIG_PCI_NV_22__ALIAS_1              NV_PBUS_PCI_NV_22 /*       */
#define NV_CONFIG_PCI_NV_22_SCRATCH                            23:0 /* RWIVF */
#define NV_CONFIG_PCI_NV_22_SCRATCH_DEFAULT              0x0023D6CE /* RWI-V */
#define NV_CONFIG_PCI_NV_23                              0x0000005C /* RW-4R */
#define NV_CONFIG_PCI_NV_23__ALIAS_1              NV_PBUS_PCI_NV_23 /*       */
#define NV_CONFIG_PCI_NV_23_AGP2X_HIGHMARK                      4:0 /* RWIVF */
#define NV_CONFIG_PCI_NV_23_AGP2X_HIGHMARK_8             0x00000008 /* RWI-V */
#define NV_CONFIG_PCI_NV_24(i)                   (0x00000060+(i)*4) /* R--4A */
#define NV_CONFIG_PCI_NV_24__SIZE_1                              40 /*       */
#define NV_CONFIG_PCI_NV_24__ALIAS_1              NV_PBUS_PCI_NV_24 /*       */
#define NV_CONFIG_PCI_NV_24_RESERVED                           31:0 /* C--VF */
#define NV_CONFIG_PCI_NV_24_RESERVED_0                   0x00000000 /* C---V */
/* dev_bus.ref */
#define NV_RMA_ID                                        0x00000000 /* R--4R */
#define NV_RMA_ID__ALIAS_1                          NV_PRMIO_RMA_ID /*       */
#define NV_RMA_ID_CODE                                         31:0 /* C--UF */
#define NV_RMA_ID_CODE_VALID                             0x2B16D065 /* C---V */
#define NV_RMA_PTR                                       0x00000004 /* RW-4R */
#define NV_RMA_PTR__ALIAS_1                        NV_PRMIO_RMA_PTR /*       */
#define NV_RMA_PTR_ADDRESS                                     24:2 /* RWXUF */
#define NV_RMA_DATA                                      0x00000008 /* RW-4R */
#define NV_RMA_DATA__ALIAS_1                      NV_PRMIO_RMA_DATA /*       */
#define NV_RMA_DATA_PORT                                       31:0 /* RWXUF */
#define NV_RMA_DATA32                                    0x0000000C /* RW-2R */
#define NV_RMA_DATA32__ALIAS_1                  NV_PRMIO_RMA_DATA32 /*       */
#define NV_RMA_DATA32_MSW                                     31:16 /* -WXUF */
#define NV_RMA_DATA32_LSW                                      15:0 /* RWXUF */
#define NV_RMA_INCDATA                                   0x00000010 /* RW-4R */
#define NV_RMA_INCDATA__ALIAS_1                NV_PRMIO_RMA_INCDATA /*       */
#define NV_RMA_INCDATA_PORT                                    31:0 /* RWXUF */
#define NV_RMA_INCDATA32                                 0x00000014 /* RW-4R */
#define NV_RMA_INCDATA32__ALIAS_1            NV_PRMIO_RMA_INCDATA32 /*       */
#define NV_RMA_INCDATA32_PORT                                  31:0 /* RWXUF */
/* dev_bus.ref */
#define NV_RMAIO                              0x000000FF:0x00000000 /* RW--D */
/* dev_bus.ref */
#define NV_PRMIO_RMA_ID                                  0x00007100 /* R--4R */
#define NV_PRMIO_RMA_ID__ALIAS_1                          NV_RMA_ID /*       */
#define NV_PRMIO_RMA_PTR                                 0x00007104 /* RW-4R */
#define NV_PRMIO_RMA_PTR__ALIAS_1                        NV_RMA_PTR /*       */
#define NV_PRMIO_RMA_DATA                                0x00007108 /* RW-4R */
#define NV_PRMIO_RMA_DATA__ALIAS_1                      NV_RMA_DATA /*       */
#define NV_PRMIO_RMA_DATA32                              0x0000710C /* RW-2R */
#define NV_PRMIO_RMA_DATA32__ALIAS_1                  NV_RMA_DATA32 /*       */
#define NV_PRMIO_RMA_INCDATA                             0x00007110 /* RW-4R */
#define NV_PRMIO_RMA_INCDATA__ALIAS_1                NV_RMA_INCDATA /*       */
#define NV_PRMIO_RMA_INCDATA32                           0x00007114 /* RW-4R */
#define NV_PRMIO_RMA_INCDATA32__ALIAS_1            NV_RMA_INCDATA32 /*       */
/* dev_bus.ref */
#define NV_MEMORY                             0xFFFFFFFF:0x00000000 /* RW--D */
/* dev_realmode.ref */
/* dev_bus.ref */
#define NV_IO                                 0xFFFFFFFF:0x00000000 /* RW--D */
#define NV_IO_DMA_0000                                   0x00000000 /* -W-1R */
#define NV_IO_DMA_0000_ADDRESS                                  7:0 /* -W-UF */
#define NV_IO_DMA_0001                                   0x00000001 /* -W-1R */
#define NV_IO_DMA_0001_COUNT                                    7:0 /* -W-UF */
#define NV_IO_DMA_0002                                   0x00000002 /* -W-1R */
#define NV_IO_DMA_0002_ADDRESS                                  7:0 /* -W-UF */
#define NV_IO_DMA_0003                                   0x00000003 /* -W-1R */
#define NV_IO_DMA_0003_COUNT                                    7:0 /* -W-UF */
#define NV_IO_DMA_0004                                   0x00000004 /* -W-1R */
#define NV_IO_DMA_0004_ADDRESS                                  7:0 /* -W-UF */
#define NV_IO_DMA_0005                                   0x00000005 /* -W-1R */
#define NV_IO_DMA_0005_COUNT                                    7:0 /* -W-UF */
#define NV_IO_DMA_0006                                   0x00000006 /* -W-1R */
#define NV_IO_DMA_0006_ADDRESS                                  7:0 /* -W-UF */
#define NV_IO_DMA_0007                                   0x00000007 /* -W-1R */
#define NV_IO_DMA_0007_COUNT                                    7:0 /* -W-UF */
#define NV_IO_DMA_0008                                   0x00000008 /* -W-1R */
#define NV_IO_DMA_0008_CONTROLLER                               2:2 /* -W-VF */
#define NV_IO_DMA_0008_CONTROLLER_DISABLED               0x00000000 /* -W--V */
#define NV_IO_DMA_0008_CONTROLLER_ENABLED                0x00000001 /* -W--V */
#define NV_IO_DMA_000A                                   0x0000000A /* -W-1R */
#define NV_IO_DMA_000A_CHANNEL                                  1:0 /* -W-UF */
#define NV_IO_DMA_000A_MASK_BIT                                 2:2 /* -W-VF */
#define NV_IO_DMA_000A_MASK_BIT_CLEAR                    0x00000000 /* -W--V */
#define NV_IO_DMA_000A_MASK_BIT_SET                      0x00000001 /* -W--V */
#define NV_IO_DMA_000B                                   0x0000000B /* -W-1R */
#define NV_IO_DMA_000B_CHANNEL                                  1:0 /* -W-UF */
#define NV_IO_DMA_000B_AUTOINITIALIZE                           4:4 /* -W-VF */
#define NV_IO_DMA_000B_AUTOINITIALIZE_DISABLED           0x00000000 /* -W--V */
#define NV_IO_DMA_000B_AUTOINITIALIZE_ENABLED            0x00000001 /* -W--V */
#define NV_IO_DMA_000B_DIRECTION                                5:5 /* -W-VF */
#define NV_IO_DMA_000B_DIRECTION_INCREMENT               0x00000000 /* -W--V */
#define NV_IO_DMA_000B_DIRECTION_DECREMENT               0x00000001 /* -W--V */
#define NV_IO_DMA_000C                                   0x0000000C /* -W-1R */
#define NV_IO_DMA_000C_CLEAR_FLIPFLOP                           7:0 /* -W-VF */
#define NV_IO_DMA_0081                                   0x00000081 /* -W-1R */
#define NV_IO_DMA_0081_ADDRESS                                  3:0 /* -W-UF */
#define NV_IO_DMA_0082                                   0x00000082 /* -W-1R */
#define NV_IO_DMA_0082_ADDRESS                                  3:0 /* -W-UF */
#define NV_IO_DMA_0083                                   0x00000083 /* -W-1R */
#define NV_IO_DMA_0083_ADDRESS                                  3:0 /* -W-UF */
#define NV_IO_DMA_0087                                   0x00000087 /* -W-1R */
#define NV_IO_DMA_0087_ADDRESS                                  3:0 /* -W-UF */
/* dev_dac.ref */
#define NV_PRAMDAC                            0x00680FFF:0x00680300 /* RW--D */
#define NV_PRAMDAC_CU_START_POS                          0x00680300 /* RW-4R */
#define NV_PRAMDAC_CU_START_POS_X                              11:0 /* RWXSF */
#define NV_PRAMDAC_CU_START_POS_Y                             27:16 /* RWXSF */
#define NV_PRAMDAC_APLL_COEFF                            0x00680500 /* RW-4R */
#define NV_PRAMDAC_APLL_COEFF_MDIV                              7:0 /* RWIUF */
#define NV_PRAMDAC_APLL_COEFF_NDIV                             15:8 /* RWIUF */
#define NV_PRAMDAC_APLL_COEFF_PDIV                            18:16 /* RWIVF */
#define NV_PRAMDAC_MPLL_COEFF                            0x00680504 /* RW-4R */
#define NV_PRAMDAC_MPLL_COEFF_MDIV                              7:0 /* RWIUF */
#define NV_PRAMDAC_MPLL_COEFF_NDIV                             15:8 /* RWIUF */
#define NV_PRAMDAC_MPLL_COEFF_PDIV                            18:16 /* RWIVF */
#define NV_PRAMDAC_VPLL_COEFF                            0x00680508 /* RW-4R */
#define NV_PRAMDAC_VPLL_COEFF_MDIV                              7:0 /* RWIUF */
#define NV_PRAMDAC_VPLL_COEFF_NDIV                             15:8 /* RWIUF */
#define NV_PRAMDAC_VPLL_COEFF_PDIV                            18:16 /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT                      0x0068050C /* RW-4R */
#define NV_PRAMDAC_PLL_COEFF_SELECT_DLL_BYPASS                  4:4 /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT_DLL_BYPASS_FALSE     0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_DLL_BYPASS_TRUE      0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_MPLL_SOURCE                 8:8 /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT_MPLL_SOURCE_DEFAULT  0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_MPLL_SOURCE_PROG     0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_MPLL_BYPASS               12:12 /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT_MPLL_BYPASS_FALSE    0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_MPLL_BYPASS_TRUE     0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VPLL_SOURCE               16:16 /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VPLL_SOURCE_DEFAULT  0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VPLL_SOURCE_PROG     0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VPLL_BYPASS               20:20 /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VPLL_BYPASS_FALSE    0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VPLL_BYPASS_TRUE     0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_PCLK_SOURCE               25:24 /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT_PCLK_SOURCE_VPLL     0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_PCLK_SOURCE_VIP      0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_PCLK_SOURCE_XTALOSC  0x00000002 /* RW--V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VCLK_RATIO                28:28 /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VCLK_RATIO_DB1       0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VCLK_RATIO_DB2       0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_SETUP_CONTROL                     0x00680510 /* RW-4R */
#define NV_PRAMDAC_PLL_SETUP_CONTROL_VALUE                     10:0 /* RWIVF */
#define NV_PRAMDAC_PLL_SETUP_CONTROL_VAL                 0x0000044E /* RWI-V */
#define NV_PRAMDAC_PLL_SETUP_CONTROL_PWRDWN                   12:12 /* RWIVF */
#define NV_PRAMDAC_PLL_SETUP_CONTROL_PWRDWN_ON           0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_SETUP_CONTROL_PWRDWN_OFF          0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_TEST_COUNTER                      0x00680514 /* RW-4R */
#define NV_PRAMDAC_PLL_TEST_COUNTER_NOOFIPCLKS                  9:0 /* -WIVF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_VALUE                      15:0 /* R--VF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_ENABLE                    16:16 /* RWIVF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_ENABLE_DEASSERTED    0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_ENABLE_ASSERTED      0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_RESET                     20:20 /* RWIVF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_RESET_DEASSERTED     0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_RESET_ASSERTED       0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_SOURCE                    25:24 /* RWIVF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_SOURCE_MCLK          0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_SOURCE_VCLK          0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_SOURCE_ACLK          0x00000002 /* RW--V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_PDIV_RST                  28:28 /* RWIVF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_PDIVRST_DEASSERTED   0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_PDIVRST_ASSERTED     0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_DLL_LOCK                  29:29 /* R--VF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_DLL_NOTLOCKED        0x00000000 /* R---V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_DLL_LOCKED           0x00000001 /* R---V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_MPLL_LOCK                 30:30 /* R--VF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_MPLL_NOTLOCKED       0x00000000 /* R---V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_MPLL_LOCKED          0x00000001 /* R---V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_VPLL_LOCK                 31:31 /* R--VF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_VPLL_NOTLOCKED       0x00000000 /* R---V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_VPLL_LOCKED          0x00000001 /* R---V */
#define NV_PRAMDAC_PALETTE_TEST                          0x00680518 /* RW-4R */
#define NV_PRAMDAC_PALETTE_TEST_BLUE_DATA                       7:0 /* R--VF */
#define NV_PRAMDAC_PALETTE_TEST_GREEN_DATA                     15:8 /* R--VF */
#define NV_PRAMDAC_PALETTE_TEST_RED_DATA                      23:16 /* R--VF */
#define NV_PRAMDAC_PALETTE_TEST_MODE                          24:24 /* RWIVF */
#define NV_PRAMDAC_PALETTE_TEST_MODE_8BIT                0x00000000 /* RWI-V */
#define NV_PRAMDAC_PALETTE_TEST_MODE_24BIT               0x00000001 /* RW--V */
#define NV_PRAMDAC_PALETTE_TEST_ADDRINC                       28:28 /* RWIVF */
#define NV_PRAMDAC_PALETTE_TEST_ADDRINC_READWRITE        0x00000000 /* RWI-V */
#define NV_PRAMDAC_PALETTE_TEST_ADDRINC_WRITEONLY        0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL                       0x00680600 /* RW-4R */
#define NV_PRAMDAC_GENERAL_CONTROL_FF_COEFF                     1:0 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_FF_COEFF_DEF          0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_IDC_MODE                     4:4 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_IDC_MODE_GAMMA        0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_IDC_MODE_INDEX        0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL_VGA_STATE                    8:8 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_VGA_STATE_NOTSE       0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_VGA_STATE_SEL         0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL_565_MODE                   12:12 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_565_MODE_NOTSEL       0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_565_MODE_SEL          0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL_BLK_PEDSTL                 16:16 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_BLK_PEDSTL_OFF        0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_BLK_PEDSTL_ON         0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL_TERMINATION                17:17 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_TERMINATION_37OHM     0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_TERMINATION_75OHM     0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL_BPC                        20:20 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_BPC_6BITS             0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_BPC_8BITS             0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL_DAC_SLEEP                  24:24 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_DAC_SLEEP_DIS         0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_DAC_SLEEP_EN          0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL_PALETTE_CLK                28:28 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_PALETTE_CLK_EN        0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_PALETTE_CLK_DIS       0x00000001 /* RW--V */
#define NV_PRAMDAC_PALETTE_RECOVERY                      0x00680604 /* R--4R */
#define NV_PRAMDAC_PALETTE_RECOVERY_ACTIVE_ADDRESS              7:0 /* R--UF */
#define NV_PRAMDAC_PALETTE_RECOVERY_RGB_POINTER                10:8 /* R--VF */
#define NV_PRAMDAC_PALETTE_RECOVERY_RGB_POINTER_RED      0x00000001 /* R---V */
#define NV_PRAMDAC_PALETTE_RECOVERY_RGB_POINTER_GREEN    0x00000002 /* R---V */
#define NV_PRAMDAC_PALETTE_RECOVERY_RGB_POINTER_BLUE     0x00000004 /* R---V */
#define NV_PRAMDAC_PALETTE_RECOVERY_DAC_STATE                 13:12 /* R--VF */
#define NV_PRAMDAC_PALETTE_RECOVERY_DAC_STATE_WRITE      0x00000000 /* R---V */
#define NV_PRAMDAC_PALETTE_RECOVERY_DAC_STATE_READ       0x00000003 /* R---V */
#define NV_PRAMDAC_PALETTE_RECOVERY_RED_DATA                  23:16 /* R--VF */
#define NV_PRAMDAC_PALETTE_RECOVERY_GREEN_DATA                31:24 /* R--VF */
#define NV_PRAMDAC_TEST_CONTROL                          0x00680608 /* RW-4R */
#define NV_PRAMDAC_TEST_CONTROL_CRC_RESET                       0:0 /* RWIVF */
#define NV_PRAMDAC_TEST_CONTROL_CRC_RESET_DEASSERTED     0x00000000 /* RWI-V */
#define NV_PRAMDAC_TEST_CONTROL_CRC_RESET_ASSERTED       0x00000001 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_CRC_ENABLE                      4:4 /* RWIVF */
#define NV_PRAMDAC_TEST_CONTROL_CRC_ENABLE_DEASSERTED    0x00000000 /* RWI-V */
#define NV_PRAMDAC_TEST_CONTROL_CRC_ENABLE_ASSERTED      0x00000001 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_CRC_CHANNEL                     9:8 /* RWIVF */
#define NV_PRAMDAC_TEST_CONTROL_CRC_CHANNEL_BLUE         0x00000000 /* RWI-V */
#define NV_PRAMDAC_TEST_CONTROL_CRC_CHANNEL_GREEN        0x00000001 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_CRC_CHANNEL_RED          0x00000002 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_TP_INS_EN                     12:12 /* RWIVF */
#define NV_PRAMDAC_TEST_CONTROL_TP_INS_EN_DEASSERTED     0x00000000 /* RWI-V */
#define NV_PRAMDAC_TEST_CONTROL_TP_INS_EN_ASSERTED       0x00000001 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_PWRDWN_DAC                    16:16 /* RWIVF */
#define NV_PRAMDAC_TEST_CONTROL_PWRDWN_DAC_ON            0x00000000 /* RWI-V */
#define NV_PRAMDAC_TEST_CONTROL_PWRDWN_DAC_OFF           0x00000001 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_DACTM                         20:20 /* RWIVF */
#define NV_PRAMDAC_TEST_CONTROL_DACTM_NORMAL             0x00000000 /* RWI-V */
#define NV_PRAMDAC_TEST_CONTROL_DACTM_TEST               0x00000001 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_TPATH1                        24:24 /* RWIVF */
#define NV_PRAMDAC_TEST_CONTROL_TPATH1_CLEAR             0x00000000 /* RWI-V */
#define NV_PRAMDAC_TEST_CONTROL_TPATH1_SET               0x00000001 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_TPATH31                       25:25 /* RWIVF */
#define NV_PRAMDAC_TEST_CONTROL_TPATH31_CLEAR            0x00000000 /* RWI-V */
#define NV_PRAMDAC_TEST_CONTROL_TPATH31_SET              0x00000001 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_SENSEB                        28:28 /* R--VF */
#define NV_PRAMDAC_TEST_CONTROL_SENSEB_SOMELO            0x00000000 /* R---V */
#define NV_PRAMDAC_TEST_CONTROL_SENSEB_ALLHI             0x00000001 /* R---V */
#define NV_PRAMDAC_CHECKSUM                              0x0068060C /* R--4R */
#define NV_PRAMDAC_CHECKSUM_VALUE                              23:0 /* R--VF */
#define NV_PRAMDAC_TESTPOINT_DATA                        0x00680610 /* -W-4R */
#define NV_PRAMDAC_TESTPOINT_DATA_RED                           9:0 /* -W-VF */
#define NV_PRAMDAC_TESTPOINT_DATA_GREEN                       19:10 /* -W-VF */
#define NV_PRAMDAC_TESTPOINT_DATA_BLUE                        29:20 /* -W-VF */
#define NV_PRAMDAC_TESTPOINT_DATA_BLACK                       30:30 /* -W-VF */
#define NV_PRAMDAC_TESTPOINT_DATA_NOTBLANK                    31:31 /* -W-VF */
#define NV_PRAMDAC_VSERR_WIDTH                           0x00680700 /* RW-4R */
#define NV_PRAMDAC_VSERR_WIDTH_VAL                             10:0 /* RWIVF */
#define NV_PRAMDAC_VEQU_END                              0x00680704 /* RW-4R */
#define NV_PRAMDAC_VEQU_END_VAL                                10:0 /* RWIVF */
#define NV_PRAMDAC_VBBLANK_END                           0x00680708 /* RW-4R */
#define NV_PRAMDAC_VBBLANK_END_VAL                             10:0 /* RWIVF */
#define NV_PRAMDAC_VBLANK_END                            0x0068070C /* RW-4R */
#define NV_PRAMDAC_VBLANK_END_VAL                              10:0 /* RWIVF */
#define NV_PRAMDAC_VBLANK_START                          0x00680710 /* RW-4R */
#define NV_PRAMDAC_VBLANK_START_VAL                            10:0 /* RWIVF */
#define NV_PRAMDAC_VBBLANK_START                         0x00680714 /* RW-4R */
#define NV_PRAMDAC_VBBLANK_START_VAL                           10:0 /* RWIVF */
#define NV_PRAMDAC_VEQU_START                            0x00680718 /* RW-4R */
#define NV_PRAMDAC_VEQU_START_VAL                              10:0 /* RWIVF */
#define NV_PRAMDAC_VTOTAL                                0x0068071C /* RW-4R */
#define NV_PRAMDAC_VTOTAL_VAL                                  10:0 /* RWIVF */
#define NV_PRAMDAC_HSYNC_WIDTH                           0x00680720 /* RW-4R */
#define NV_PRAMDAC_HSYNC_WIDTH_VAL                             10:0 /* RWIVF */
#define NV_PRAMDAC_HBURST_START                          0x00680724 /* RW-4R */
#define NV_PRAMDAC_HBURST_START_VAL                            10:0 /* RWIVF */
#define NV_PRAMDAC_HBURST_END                            0x00680728 /* RW-4R */
#define NV_PRAMDAC_HBURST_END_VAL                              10:0 /* RWIVF */
#define NV_PRAMDAC_HBLANK_START                          0x0068072C /* RW-4R */
#define NV_PRAMDAC_HBLANK_START_VAL                            10:0 /* RWIVF */
#define NV_PRAMDAC_HBLANK_END                            0x00680730 /* RW-4R */
#define NV_PRAMDAC_HBLANK_END_VAL                              10:0 /* RWIVF */
#define NV_PRAMDAC_HTOTAL                                0x00680734 /* RW-4R */
#define NV_PRAMDAC_HTOTAL_VAL                                  10:0 /* RWIVF */
#define NV_PRAMDAC_HEQU_WIDTH                            0x00680738 /* RW-4R */
#define NV_PRAMDAC_HEQU_WIDTH_VAL                              10:0 /* RWIVF */
#define NV_PRAMDAC_HSERR_WIDTH                           0x0068073C /* RW-4R */
#define NV_PRAMDAC_HSERR_WIDTH_VAL                             10:0 /* RWIVF */
/* dev_dac.ref */
#define NV_USER_DAC                           0x00681FFF:0x00681200 /* RW--D */
#define NV_USER_DAC_PIXEL_MASK                           0x006813C6 /* RWI1R */
#define NV_USER_DAC_PIXEL_MASK_VALUE                            7:0 /* RWIVF */
#define NV_USER_DAC_PIXEL_MASK_MASK                      0x000000FF /* RWI-V */
#define NV_USER_DAC_READ_MODE_ADDRESS                    0x006813C7 /* RW-1R */
#define NV_USER_DAC_READ_MODE_ADDRESS_VALUE                     7:0 /* RW-VF */
#define NV_USER_DAC_READ_MODE_ADDRESS_WO_VALUE                  7:0 /* -W-VF */
#define NV_USER_DAC_READ_MODE_ADDRESS_RW_STATE                  1:0 /* R--VF */
#define NV_USER_DAC_READ_MODE_ADDRESS_RW_STATE_WRITE     0x00000000 /* R---V */
#define NV_USER_DAC_READ_MODE_ADDRESS_RW_STATE_READ      0x00000003 /* R---V */
#define NV_USER_DAC_WRITE_MODE_ADDRESS                   0x006813C8 /* RW-1R */
#define NV_USER_DAC_WRITE_MODE_ADDRESS_VALUE                    7:0 /* RW-VF */
#define NV_USER_DAC_PALETTE_DATA                         0x006813C9 /* RW-1R */
#define NV_USER_DAC_PALETTE_DATA_VALUE                          7:0 /* RW-VF */
/* dev_realmode.ref */
#define NV_IO_MPU_401_DATA                               0x00000330 /* R--1R */
#define NV_IO_MPU_401_DATA__ALIAS_1                      0x00000300 /* R--1R */
#define NV_IO_MPU_401_DATA__ALIAS_2                      0x00000230 /* R--1R */
#define NV_IO_MPU_401_DATA_VALUE                                7:0 /* R--VF */
#define NV_IO_MPU_401_DATA_ACK                           0x000000FE /* R---V */
#define NV_IO_MPU_401_STATUS                             0x00000331 /* R--1R */
#define NV_IO_MPU_401_STATUS__ALIAS_1                    0x00000301 /* R--1R */
#define NV_IO_MPU_401_STATUS__ALIAS_2                    0x00000231 /* R--1R */
#define NV_IO_MPU_401_STATUS_DATA                               5:0 /* R--VF */
#define NV_IO_MPU_401_STATUS_WRITE                              6:6 /* R--VF */
#define NV_IO_MPU_401_STATUS_WRITE_EMPTY                 0x00000000 /* R---V */
#define NV_IO_MPU_401_STATUS_WRITE_FULL                  0x00000001 /* R---V */
#define NV_IO_MPU_401_STATUS_READ                               7:7 /* R--VF */
#define NV_IO_MPU_401_STATUS_READ_FULL                   0x00000000 /* R---V */
#define NV_IO_MPU_401_STATUS_READ_EMPTY                  0x00000001 /* R---V */
#define NV_IO_MPU_401_COM                                0x00000331 /* -W-1R */
#define NV_IO_MPU_401_COM__ALIAS_1                       0x00000301 /* -W-1R */
#define NV_IO_MPU_401_COM__ALIAS_2                       0x00000231 /* -W-1R */
#define NV_IO_MPU_401_COM_UART_MODE                             7:0 /* -WIVF */
#define NV_IO_MPU_401_COM_UART_MODE_COMPLEX              0x000000ff /* -WI-V */
#define NV_IO_MPU_401_COM_UART_MODE_SIMPLE               0x0000003f /* -W--V */
/* dev_master.ref */
#define NV_PMC                                0x00000FFF:0x00000000 /* RW--D */
#define NV_PMC_BOOT_0                                    0x00000000 /* R--4R */
#define NV_PMC_BOOT_0_FIB_REVISION                              3:0 /* C--VF */
#define NV_PMC_BOOT_0_FIB_REVISION_0                     0x00000000 /* C---V */
#define NV_PMC_BOOT_0_FIB_REVISION_1                     0x00000001 /* ----V */
#define NV_PMC_BOOT_0_MASK_REVISION                             7:4 /* C--VF */
#define NV_PMC_BOOT_0_MASK_REVISION_A                    0x00000000 /* ----V */
#define NV_PMC_BOOT_0_MASK_REVISION_B                    0x00000001 /* C---V */
#define NV_PMC_BOOT_0_IMPLEMENTATION                           15:8 /* C--VF */
#define NV_PMC_BOOT_0_IMPLEMENTATION_NV3                 0x00000001 /* C---V */
#define NV_PMC_BOOT_0_ARCHITECTURE                            23:16 /* C--VF */
#define NV_PMC_BOOT_0_ARCHITECTURE_NV0                   0x00000000 /* ----V */
#define NV_PMC_BOOT_0_ARCHITECTURE_NV1                   0x00000001 /* ----V */
#define NV_PMC_BOOT_0_ARCHITECTURE_NV2                   0x00000002 /* ----V */
#define NV_PMC_BOOT_0_ARCHITECTURE_NV3                   0x00000003 /* C---V */
#define NV_PMC_BOOT_0_MANUFACTURER                            27:24 /* C--UF */
#define NV_PMC_BOOT_0_MANUFACTURER_NVIDIA                0x00000000 /* C---V */
#define NV_PMC_BOOT_0_FOUNDRY                                 31:28 /* C--VF */
#define NV_PMC_BOOT_0_FOUNDRY_SGS                        0x00000000 /* ----V */
#define NV_PMC_BOOT_0_FOUNDRY_HELIOS                     0x00000001 /* ----V */
#define NV_PMC_BOOT_0_FOUNDRY_TSMC                       0x00000002 /* C---V */
#define NV_PMC_INTR_0                                    0x00000100 /* RW-4R */
#define NV_PMC_INTR_0_PAUDIO                                    0:0 /* R--VF */
#define NV_PMC_INTR_0_PAUDIO_NOT_PENDING                 0x00000000 /* R---V */
#define NV_PMC_INTR_0_PAUDIO_PENDING                     0x00000001 /* R---V */
#define NV_PMC_INTR_0_PMEDIA                                    4:4 /* R--VF */
#define NV_PMC_INTR_0_PMEDIA_NOT_PENDING                 0x00000000 /* R---V */
#define NV_PMC_INTR_0_PMEDIA_PENDING                     0x00000001 /* R---V */
#define NV_PMC_INTR_0_PFIFO                                     8:8 /* R--VF */
#define NV_PMC_INTR_0_PFIFO_NOT_PENDING                  0x00000000 /* R---V */
#define NV_PMC_INTR_0_PFIFO_PENDING                      0x00000001 /* R---V */
#define NV_PMC_INTR_0_PGRAPH0                                 12:12 /* R--VF */
#define NV_PMC_INTR_0_PGRAPH0_NOT_PENDING                0x00000000 /* R---V */
#define NV_PMC_INTR_0_PGRAPH0_PENDING                    0x00000001 /* R---V */
#define NV_PMC_INTR_0_PGRAPH1                                 13:13 /* R--VF */
#define NV_PMC_INTR_0_PGRAPH1_NOT_PENDING                0x00000000 /* R---V */
#define NV_PMC_INTR_0_PGRAPH1_PENDING                    0x00000001 /* R---V */
#define NV_PMC_INTR_0_PVIDEO                                  16:16 /* R--VF */
#define NV_PMC_INTR_0_PVIDEO_NOT_PENDING                 0x00000000 /* R---V */
#define NV_PMC_INTR_0_PVIDEO_PENDING                     0x00000001 /* R---V */
#define NV_PMC_INTR_0_PTIMER                                  20:20 /* R--VF */
#define NV_PMC_INTR_0_PTIMER_NOT_PENDING                 0x00000000 /* R---V */
#define NV_PMC_INTR_0_PTIMER_PENDING                     0x00000001 /* R---V */
#define NV_PMC_INTR_0_PFB                                     24:24 /* R--VF */
#define NV_PMC_INTR_0_PFB_NOT_PENDING                    0x00000000 /* R---V */
#define NV_PMC_INTR_0_PFB_PENDING                        0x00000001 /* R---V */
#define NV_PMC_INTR_0_PBUS                                    28:28 /* R--VF */
#define NV_PMC_INTR_0_PBUS_NOT_PENDING                   0x00000000 /* R---V */
#define NV_PMC_INTR_0_PBUS_PENDING                       0x00000001 /* R---V */
#define NV_PMC_INTR_0_SOFTWARE                                31:31 /* RWIVF */
#define NV_PMC_INTR_0_SOFTWARE_NOT_PENDING               0x00000000 /* RWI-V */
#define NV_PMC_INTR_0_SOFTWARE_PENDING                   0x00000001 /* RW--V */
#define NV_PMC_INTR_EN_0                                 0x00000140 /* RW-4R */
#define NV_PMC_INTR_EN_0_INTA                                   1:0 /* RWIVF */
#define NV_PMC_INTR_EN_0_INTA_DISABLED                   0x00000000 /* RWI-V */
#define NV_PMC_INTR_EN_0_INTA_HARDWARE                   0x00000001 /* RW--V */
#define NV_PMC_INTR_EN_0_INTA_SOFTWARE                   0x00000002 /* RW--V */
#define NV_PMC_INTR_READ_0                               0x00000160 /* R--4R */
#define NV_PMC_INTR_READ_0_INTA                                 0:0 /* R--VF */
#define NV_PMC_INTR_READ_0_INTA_LOW                      0x00000000 /* R---V */
#define NV_PMC_INTR_READ_0_INTA_HIGH                     0x00000001 /* R---V */
#define NV_PMC_ENABLE                                    0x00000200 /* RW-4R */
#define NV_PMC_ENABLE_PAUDIO                                    0:0 /* RWIVF */
#define NV_PMC_ENABLE_PAUDIO_DISABLED                    0x00000000 /* RWI-V */
#define NV_PMC_ENABLE_PAUDIO_ENABLED                     0x00000001 /* RW--V */
#define NV_PMC_ENABLE_PMEDIA                                    4:4 /* RWIVF */
#define NV_PMC_ENABLE_PMEDIA_DISABLED                    0x00000000 /* RWI-V */
#define NV_PMC_ENABLE_PMEDIA_ENABLED                     0x00000001 /* RW--V */
#define NV_PMC_ENABLE_PFIFO                                     8:8 /* RWIVF */
#define NV_PMC_ENABLE_PFIFO_DISABLED                     0x00000000 /* RWI-V */
#define NV_PMC_ENABLE_PFIFO_ENABLED                      0x00000001 /* RW--V */
#define NV_PMC_ENABLE_PGRAPH                                  12:12 /* RWIVF */
#define NV_PMC_ENABLE_PGRAPH_DISABLED                    0x00000000 /* RWI-V */
#define NV_PMC_ENABLE_PGRAPH_ENABLED                     0x00000001 /* RW--V */
#define NV_PMC_ENABLE_PPMI                                    16:16 /* RWIVF */
#define NV_PMC_ENABLE_PPMI_DISABLED                      0x00000000 /* RWI-V */
#define NV_PMC_ENABLE_PPMI_ENABLED                       0x00000001 /* RW--V */
#define NV_PMC_ENABLE_PFB                                     20:20 /* RWIVF */
#define NV_PMC_ENABLE_PFB_DISABLED                       0x00000000 /* RW--V */
#define NV_PMC_ENABLE_PFB_ENABLED                        0x00000001 /* RWI-V */
#define NV_PMC_ENABLE_PCRTC                                   24:24 /* RWIVF */
#define NV_PMC_ENABLE_PCRTC_DISABLED                     0x00000000 /* RW--V */
#define NV_PMC_ENABLE_PCRTC_ENABLED                      0x00000001 /* RWI-V */
#define NV_PMC_ENABLE_PVIDEO                                  28:28 /* RWIVF */
#define NV_PMC_ENABLE_PVIDEO_DISABLED                    0x00000000 /* RWI-V */
#define NV_PMC_ENABLE_PVIDEO_ENABLED                     0x00000001 /* RW--V */
/* dev_bus.ref */
#define NV_PBUS                               0x00001FFF:0x00001000 /* RW--D */
#define NV_PBUS_DEBUG_0                                  0x00001080 /* RW-4R */
#define NV_PBUS_DEBUG_0_MODE                                    0:0 /* RWIVF */
#define NV_PBUS_DEBUG_0_MODE_DISABLED                    0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_0_MODE_ENABLED                     0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_0_DESKEWER                                4:4 /* RWIVF */
#define NV_PBUS_DEBUG_0_DESKEWER_ENABLED                 0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_0_DESKEWER_BYPASS                  0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_0_FBIO_SCLK_DELAY                        11:8 /* RWIVF */
#define NV_PBUS_DEBUG_0_FBIO_SCLK_DELAY_8                0x00000008 /* RWI-V */
#define NV_PBUS_DEBUG_SEL_0                              0x00001090 /* RW-4R */
#define NV_PBUS_DEBUG_SEL_0_X                                   2:0 /* RWXUF */
#define NV_PBUS_DEBUG_SEL_1                              0x00001094 /* RW-4R */
#define NV_PBUS_DEBUG_SEL_1_X                                   2:0 /* RWXUF */
#define NV_PBUS_DEBUG_SEL_2                              0x00001098 /* RW-4R */
#define NV_PBUS_DEBUG_SEL_2_X                                   2:0 /* RWXUF */
#define NV_PBUS_DEBUG_SEL_3                              0x0000109C /* RW-4R */
#define NV_PBUS_DEBUG_SEL_3_X                                   2:0 /* RWXUF */
#define NV_PBUS_DEBUG_HOST                               0x000010A0 /* RW-4R */
#define NV_PBUS_DEBUG_HOST_SEL                                  2:0 /* RWXUF */
#define NV_PBUS_DEBUG_1                                  0x00001084 /* RW-4R */
#define NV_PBUS_DEBUG_1_PCIM_THROTTLE                           0:0 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIM_THROTTLE_DISABLED           0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIM_THROTTLE_ENABLED            0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIM_CMD                                1:1 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIM_CMD_SIZE_BASED              0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIM_CMD_MRL_ONLY                0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIM_AGP                                2:2 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIM_AGP_IS_AGP                  0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIM_AGP_IS_PCI                  0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_AGPM_CMD                                4:3 /* RWIVF */
#define NV_PBUS_DEBUG_1_AGPM_CMD_HP_ON_1ST               0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_AGPM_CMD_LP_ONLY                 0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_AGPM_CMD_HP_ONLY                 0x00000002 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_WRITE                              5:5 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_WRITE_0_CYCLE               0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_WRITE_1_CYCLE               0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIS_2_1                                6:6 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_2_1_DISABLED                0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_2_1_ENABLED                 0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIS_RETRY                              7:7 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_RETRY_DISABLED              0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_RETRY_ENABLED               0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIS_RD_BURST                           8:8 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_RD_BURST_DISABLED           0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIS_RD_BURST_ENABLED            0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_WR_BURST                           9:9 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_WR_BURST_DISABLED           0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIS_WR_BURST_ENABLED            0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_EARLY_RTY                        10:10 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_EARLY_RTY_DISABLED          0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_EARLY_RTY_ENABLED           0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIS_RMAIO                            11:11 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_RMAIO_DISABLED              0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_RMAIO_ENABLED               0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIS_CPUQ                             12:12 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_CPUQ_DISABLED               0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_CPUQ_ENABLED                0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_SPARE1                                13:13 /* RWIVF */
#define NV_PBUS_DEBUG_1_SPARE1_ZERO                      0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_SPARE1_ONE                       0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_SPARE2                                14:14 /* RWIVF */
#define NV_PBUS_DEBUG_1_SPARE2_ZERO                      0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_SPARE2_ONE                       0x00000001 /* RW--V */
#define NV_PBUS_INTR_0                                   0x00001100 /* RW-4R */
#define NV_PBUS_INTR_0_PCI_BUS_ERROR                            0:0 /* RWXVF */
#define NV_PBUS_INTR_0_PCI_BUS_ERROR_NOT_PENDING         0x00000000 /* R---V */
#define NV_PBUS_INTR_0_PCI_BUS_ERROR_PENDING             0x00000001 /* R---V */
#define NV_PBUS_INTR_0_PCI_BUS_ERROR_RESET               0x00000001 /* -W--V */
#define NV_PBUS_INTR_EN_0                                0x00001140 /* RWI4R */
#define NV_PBUS_INTR_EN_0_PCI_BUS_ERROR                         0:0 /* RWIVF */
#define NV_PBUS_INTR_EN_0_PCI_BUS_ERROR_DISABLED         0x00000000 /* RWI-V */
#define NV_PBUS_INTR_EN_0_PCI_BUS_ERROR_ENABLED          0x00000001 /* RW--V */
#define NV_PBUS_RMC_DMA_0                                0x00001E80 /* RW-4R */
#define NV_PBUS_RMC_DMA_0_ADDRESS_BYTE_0                        7:0 /* RWXUF */
#define NV_PBUS_RMC_DMA_0_ADDRESS_BYTE_1                       15:8 /* RWXUF */
#define NV_PBUS_RMC_DMA_0_ADDRESS_BYTE_2                      23:16 /* RWXUF */
#define NV_PBUS_RMC_DMA_0_MASK_BIT                            24:24 /* RWXVF */
#define NV_PBUS_RMC_DMA_0_MASK_BIT_CLEAR                 0x00000000 /* RW--V */
#define NV_PBUS_RMC_DMA_0_MASK_BIT_SET                   0x00000001 /* RW--V */
#define NV_PBUS_RMC_DMA_0_AUTOINITIALIZE                      25:25 /* RWXVF */
#define NV_PBUS_RMC_DMA_0_AUTOINITIALIZE_DISABLED        0x00000000 /* RW--V */
#define NV_PBUS_RMC_DMA_0_AUTOINITIALIZE_ENABLED         0x00000001 /* RW--V */
#define NV_PBUS_RMC_DMA_0_DIRECTION                           26:26 /* RWXVF */
#define NV_PBUS_RMC_DMA_0_DIRECTION_INCREMENT            0x00000000 /* RW--V */
#define NV_PBUS_RMC_DMA_0_DIRECTION_DECREMENT            0x00000001 /* RW--V */
#define NV_PBUS_RMC_DMA_0_CHANNEL                             29:28 /* RWXUF */
#define NV_PBUS_RMC_DMA_0_CONTROLLER                          30:30 /* RWXVF */
#define NV_PBUS_RMC_DMA_0_CONTROLLER_DISABLED            0x00000000 /* RW--V */
#define NV_PBUS_RMC_DMA_0_CONTROLLER_ENABLED             0x00000001 /* RW--V */
#define NV_PBUS_RMC_DMA_0_FLIPFLOP                            31:31 /* RWIVF */
#define NV_PBUS_RMC_DMA_0_FLIPFLOP_BYTE_0                0x00000000 /* RWI-V */
#define NV_PBUS_RMC_DMA_0_FLIPFLOP_BYTE_1                0x00000001 /* RW--V */
#define NV_PBUS_RMC_DMA_1                                0x00001E84 /* RW-4R */
#define NV_PBUS_RMC_DMA_1_COUNT_BYTE_0                          7:0 /* RWXUF */
#define NV_PBUS_RMC_DMA_1_COUNT_BYTE_1                         15:8 /* RWXUF */
#define NV_PBUS_RMC_DMA_1_STATE                               28:28 /* RWXVF */
#define NV_PBUS_RMC_DMA_1_STATE_CLEAN                    0x00000000 /* RW--V */
#define NV_PBUS_RMC_DMA_1_STATE_DIRTY                    0x00000001 /* RW--V */
#define NV_PBUS_PCI_NV_0                                 0x00001800 /* R--4R */
#define NV_PBUS_PCI_NV_0__ALIAS_1                NV_CONFIG_PCI_NV_0 /*       */
#define NV_PBUS_PCI_NV_1                                 0x00001804 /* RW-4R */
#define NV_PBUS_PCI_NV_1__ALIAS_1                NV_CONFIG_PCI_NV_1 /*       */
#define NV_PBUS_PCI_NV_2                                 0x00001808 /* R--4R */
#define NV_PBUS_PCI_NV_2__ALIAS_1                NV_CONFIG_PCI_NV_2 /*       */
#define NV_PBUS_PCI_NV_3                                 0x0000180C /* RW-4R */
#define NV_PBUS_PCI_NV_3__ALIAS_1                NV_CONFIG_PCI_NV_3 /*       */
#define NV_PBUS_PCI_NV_4                                 0x00001810 /* RW-4R */
#define NV_PBUS_PCI_NV_4__ALIAS_1                NV_CONFIG_PCI_NV_4 /*       */
#define NV_PBUS_PCI_NV_5                                 0x00001814 /* RW-4R */
#define NV_PBUS_PCI_NV_5__ALIAS_1                NV_CONFIG_PCI_NV_5 /*       */
#define NV_PBUS_PCI_NV_6                                 0x00001818 /* RW-4R */
#define NV_PBUS_PCI_NV_6__ALIAS_1                NV_CONFIG_PCI_NV_6 /*       */
#define NV_PBUS_PCI_NV_7(i)                      (0x0000181C+(i)*4) /* R--4A */
#define NV_PBUS_PCI_NV_7__SIZE_1                                  4 /*       */
#define NV_PBUS_PCI_NV_7__ALIAS_1                NV_CONFIG_PCI_NV_7 /*       */
#define NV_PBUS_PCI_NV_11                                0x0000182C /* R--4R */
#define NV_PBUS_PCI_NV_11__ALIAS_1              NV_CONFIG_PCI_NV_11 /*       */
#define NV_PBUS_PCI_NV_12                                0x00001830 /* RW-4R */
#define NV_PBUS_PCI_NV_12__ALIAS_1              NV_CONFIG_PCI_NV_12 /*       */
#define NV_PBUS_PCI_NV_13                                0x00001834 /* RW-4R */
#define NV_PBUS_PCI_NV_13__ALIAS_1              NV_CONFIG_PCI_NV_13 /*       */
#define NV_PBUS_PCI_NV_14                                0x00001838 /* R--4A */
#define NV_PBUS_PCI_NV_14__ALIAS_1              NV_CONFIG_PCI_NV_14 /*       */
#define NV_PBUS_PCI_NV_15                                0x0000183C /* RW-4R */
#define NV_PBUS_PCI_NV_15__ALIAS_1              NV_CONFIG_PCI_NV_15 /*       */
#define NV_PBUS_PCI_NV_16                                0x00001840 /* RW-4R */
#define NV_PBUS_PCI_NV_16__ALIAS_1              NV_CONFIG_PCI_NV_16 /*       */
#define NV_PBUS_PCI_NV_17                                0x00001844 /* RW-4R */
#define NV_PBUS_PCI_NV_17__ALIAS_1              NV_CONFIG_PCI_NV_17 /*       */
#define NV_PBUS_PCI_NV_18                                0x00001848 /* RW-4R */
#define NV_PBUS_PCI_NV_18__ALIAS_1              NV_CONFIG_PCI_NV_18 /*       */
#define NV_PBUS_PCI_NV_19                                0x0000184C /* RW-4R */
#define NV_PBUS_PCI_NV_19__ALIAS_1              NV_CONFIG_PCI_NV_19 /*       */
#define NV_PBUS_PCI_NV_20                                0x00001850 /* RW-4R */
#define NV_PBUS_PCI_NV_20__ALIAS_1              NV_CONFIG_PCI_NV_20 /*       */
#define NV_PBUS_PCI_NV_21                                0x00001854 /* RW-4R */
#define NV_PBUS_PCI_NV_21__ALIAS_1              NV_CONFIG_PCI_NV_21 /*       */
#define NV_PBUS_PCI_NV_22                                0x00001858 /* RW-4R */
#define NV_PBUS_PCI_NV_22__ALIAS_1              NV_CONFIG_PCI_NV_22 /*       */
#define NV_PBUS_PCI_NV_23                                0x0000185C /* RW-4R */
#define NV_PBUS_PCI_NV_23__ALIAS_1              NV_CONFIG_PCI_NV_23 /*       */
#define NV_PBUS_PCI_NV_24(i)                     (0x00001860+(i)*4) /* R--4A */
#define NV_PBUS_PCI_NV_24__SIZE_1                                40 /*       */
#define NV_PBUS_PCI_NV_24__ALIAS_1              NV_CONFIG_PCI_NV_24 /*       */
/* dev_fifo.ref */
#define NV_PFIFO                              0x00003FFF:0x00002000 /* RW--D */
#define NV_PFIFO_DELAY_0                                 0x00002040 /* RW-4R */
#define NV_PFIFO_DELAY_0_WAIT_RETRY                             7:0 /* RWIUF */
#define NV_PFIFO_DELAY_0_WAIT_RETRY_0                    0x00000000 /* RWI-V */
#define NV_PFIFO_DEBUG_0                                 0x00002080 /* R--4R */
#define NV_PFIFO_DEBUG_0_CACHE_ERROR0                           0:0 /* R-XVF */
#define NV_PFIFO_DEBUG_0_CACHE_ERROR0_NOT_PENDING        0x00000000 /* R---V */
#define NV_PFIFO_DEBUG_0_CACHE_ERROR0_PENDING            0x00000001 /* R---V */
#define NV_PFIFO_DEBUG_0_CACHE_ERROR1                           4:4 /* R-XVF */
#define NV_PFIFO_DEBUG_0_CACHE_ERROR1_NOT_PENDING        0x00000000 /* R---V */
#define NV_PFIFO_DEBUG_0_CACHE_ERROR1_PENDING            0x00000001 /* R---V */
#define NV_PFIFO_INTR_0                                  0x00002100 /* RW-4R */
#define NV_PFIFO_INTR_0_CACHE_ERROR                             0:0 /* RWXVF */
#define NV_PFIFO_INTR_0_CACHE_ERROR_NOT_PENDING          0x00000000 /* R---V */
#define NV_PFIFO_INTR_0_CACHE_ERROR_PENDING              0x00000001 /* R---V */
#define NV_PFIFO_INTR_0_CACHE_ERROR_RESET                0x00000001 /* -W--V */
#define NV_PFIFO_INTR_0_RUNOUT                                  4:4 /* RWXVF */
#define NV_PFIFO_INTR_0_RUNOUT_NOT_PENDING               0x00000000 /* R---V */
#define NV_PFIFO_INTR_0_RUNOUT_PENDING                   0x00000001 /* R---V */
#define NV_PFIFO_INTR_0_RUNOUT_RESET                     0x00000001 /* -W--V */
#define NV_PFIFO_INTR_0_RUNOUT_OVERFLOW                         8:8 /* RWXVF */
#define NV_PFIFO_INTR_0_RUNOUT_OVERFLOW_NOT_PENDING      0x00000000 /* R---V */
#define NV_PFIFO_INTR_0_RUNOUT_OVERFLOW_PENDING          0x00000001 /* R---V */
#define NV_PFIFO_INTR_0_RUNOUT_OVERFLOW_RESET            0x00000001 /* -W--V */
#define NV_PFIFO_INTR_0_DMA_PUSHER                            12:12 /* RWXVF */
#define NV_PFIFO_INTR_0_DMA_PUSHER_NOT_PENDING           0x00000000 /* R---V */
#define NV_PFIFO_INTR_0_DMA_PUSHER_PENDING               0x00000001 /* R---V */
#define NV_PFIFO_INTR_0_DMA_PUSHER_RESET                 0x00000001 /* -W--V */
#define NV_PFIFO_INTR_0_DMA_PTE                               16:16 /* RWXVF */
#define NV_PFIFO_INTR_0_DMA_PTE_NOT_PENDING              0x00000000 /* R---V */
#define NV_PFIFO_INTR_0_DMA_PTE_PENDING                  0x00000001 /* R---V */
#define NV_PFIFO_INTR_0_DMA_PTE_RESET                    0x00000001 /* -W--V */
#define NV_PFIFO_INTR_EN_0                               0x00002140 /* RW-4R */
#define NV_PFIFO_INTR_EN_0_CACHE_ERROR                          0:0 /* RWIVF */
#define NV_PFIFO_INTR_EN_0_CACHE_ERROR_DISABLED          0x00000000 /* RWI-V */
#define NV_PFIFO_INTR_EN_0_CACHE_ERROR_ENABLED           0x00000001 /* RW--V */
#define NV_PFIFO_INTR_EN_0_RUNOUT                               4:4 /* RWIVF */
#define NV_PFIFO_INTR_EN_0_RUNOUT_DISABLED               0x00000000 /* RWI-V */
#define NV_PFIFO_INTR_EN_0_RUNOUT_ENABLED                0x00000001 /* RW--V */
#define NV_PFIFO_INTR_EN_0_RUNOUT_OVERFLOW                      8:8 /* RWIVF */
#define NV_PFIFO_INTR_EN_0_RUNOUT_OVERFLOW_DISABLED      0x00000000 /* RWI-V */
#define NV_PFIFO_INTR_EN_0_RUNOUT_OVERFLOW_ENABLED       0x00000001 /* RW--V */
#define NV_PFIFO_INTR_EN_0_DMA_PUSHER                         12:12 /* RWIVF */
#define NV_PFIFO_INTR_EN_0_DMA_PUSHER_DISABLED           0x00000000 /* RWI-V */
#define NV_PFIFO_INTR_EN_0_DMA_PUSHER_ENABLED            0x00000001 /* RW--V */
#define NV_PFIFO_INTR_EN_0_DMA_PTE                            16:16 /* RWIVF */
#define NV_PFIFO_INTR_EN_0_DMA_PTE_DISABLED              0x00000000 /* RWI-V */
#define NV_PFIFO_INTR_EN_0_DMA_PTE_ENABLED               0x00000001 /* RW--V */
#define NV_PFIFO_CONFIG_0                                0x00002200 /* RW-4R */
#define NV_PFIFO_CONFIG_0_DMA_FETCH                            10:8 /* RWXVF */
#define NV_PFIFO_CONFIG_0_DMA_FETCH_32_BYTES             0x00000000 /* RW--V */
#define NV_PFIFO_CONFIG_0_DMA_FETCH_64_BYTES             0x00000001 /* RW--V */
#define NV_PFIFO_CONFIG_0_DMA_FETCH_96_BYTES             0x00000002 /* RW--V */
#define NV_PFIFO_CONFIG_0_DMA_FETCH_128_BYTES            0x00000003 /* RW--V */
#define NV_PFIFO_CONFIG_0_DMA_FETCH_160_BYTES            0x00000004 /* RW--V */
#define NV_PFIFO_CONFIG_0_DMA_FETCH_192_BYTES            0x00000005 /* RW--V */
#define NV_PFIFO_CONFIG_0_DMA_FETCH_224_BYTES            0x00000006 /* RW--V */
#define NV_PFIFO_CONFIG_0_DMA_FETCH_256_BYTES            0x00000007 /* RW--V */
#define NV_PFIFO_CONFIG_0_DMA_WATERMARK                       22:18 /* RWXVF */
#define NV_PFIFO_RAMHT                                   0x00002210 /* RW-4R */
#define NV_PFIFO_RAMHT_BASE_ADDRESS                           15:12 /* RWXVF */
#define NV_PFIFO_RAMHT_BASE_ADDRESS_0                    0x00000000 /* RWI-V */
#define NV_PFIFO_RAMHT_SIZE                                   17:16 /* RWXVF */
#define NV_PFIFO_RAMHT_SIZE_4K                           0x00000000 /* RWI-V */
#define NV_PFIFO_RAMHT_SIZE_8K                           0x00000001 /* RW--V */
#define NV_PFIFO_RAMHT_SIZE_16K                          0x00000002 /* RW--V */
#define NV_PFIFO_RAMHT_SIZE_32K                          0x00000003 /* RW--V */
#define NV_PFIFO_RAMFC                                   0x00002214 /* RW-4R */
#define NV_PFIFO_RAMFC_BASE_ADDRESS                            15:9 /* RWXVF */
#define NV_PFIFO_RAMFC_BASE_ADDRESS_1C00                 0x00001C00 /* RWI-V */
#define NV_PFIFO_RAMRO                                   0x00002218 /* RW-4R */
#define NV_PFIFO_RAMRO_BASE_ADDRESS                            15:9 /* RWXVF */
#define NV_PFIFO_RAMRO_BASE_ADDRESS_1E00                 0x00001E00 /* RWI-V */
#define NV_PFIFO_RAMRO_SIZE                                   16:16 /* RWXVF */
#define NV_PFIFO_RAMRO_SIZE_512                          0x00000000 /* RWI-V */
#define NV_PFIFO_RAMRO_SIZE_8K                           0x00000001 /* RW--V */
#define NV_PFIFO_CACHES                                  0x00002500 /* RW-4R */
#define NV_PFIFO_CACHES_REASSIGN                                0:0 /* RWIVF */
#define NV_PFIFO_CACHES_REASSIGN_DISABLED                0x00000000 /* RWI-V */
#define NV_PFIFO_CACHES_REASSIGN_ENABLED                 0x00000001 /* RW--V */
#define NV_PFIFO_CACHE0_PUSH0                            0x00003000 /* RW-4R */
#define NV_PFIFO_CACHE0_PUSH0_ACCESS                            0:0 /* RWIVF */
#define NV_PFIFO_CACHE0_PUSH0_ACCESS_DISABLED            0x00000000 /* RWI-V */
#define NV_PFIFO_CACHE0_PUSH0_ACCESS_ENABLED             0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_PUSH0                            0x00003200 /* RW-4R */
#define NV_PFIFO_CACHE1_PUSH0_ACCESS                            0:0 /* RWIVF */
#define NV_PFIFO_CACHE1_PUSH0_ACCESS_DISABLED            0x00000000 /* RWI-V */
#define NV_PFIFO_CACHE1_PUSH0_ACCESS_ENABLED             0x00000001 /* RW--V */
#define NV_PFIFO_CACHE0_PUSH1                            0x00003004 /* RW-4R */
#define NV_PFIFO_CACHE0_PUSH1_CHID                              6:0 /* RWXUF */
#define NV_PFIFO_CACHE1_PUSH1                            0x00003204 /* RW-4R */
#define NV_PFIFO_CACHE1_PUSH1_CHID                              6:0 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA0                             0x00003220 /* RW-4R */
#define NV_PFIFO_CACHE1_DMA0_ACCESS                             0:0 /* RWIVF */
#define NV_PFIFO_CACHE1_DMA0_ACCESS_DISABLED             0x00000000 /* RWI-V */
#define NV_PFIFO_CACHE1_DMA0_ACCESS_ENABLED              0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_DMA0_STATE                              4:4 /* R-IVF */
#define NV_PFIFO_CACHE1_DMA0_STATE_IDLE                  0x00000000 /* R-I-V */
#define NV_PFIFO_CACHE1_DMA0_STATE_BUSY                  0x00000001 /* R---V */
#define NV_PFIFO_CACHE1_DMA1                             0x00003224 /* RW-4R */
#define NV_PFIFO_CACHE1_DMA1_LENGTH                            23:2 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA2                             0x00003228 /* RW-4R */
#define NV_PFIFO_CACHE1_DMA2_ADDRESS                           23:2 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA3                             0x0000322C /* RW-4R */
#define NV_PFIFO_CACHE1_DMA3_TARGET_NODE                        1:0 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA3_TARGET_NODE_PCI             0x00000002 /* RW--V */
#define NV_PFIFO_CACHE1_DMA3_TARGET_NODE_AGP             0x00000003 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_STATUS                       0x00003218 /* RW-4R */
#define NV_PFIFO_CACHE1_DMA_STATUS_METHOD                      12:2 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_STATUS_SUBCHANNEL                 15:13 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_STATUS_METHOD_COUNT               28:18 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_STATUS_REASON                     30:30 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_STATUS_REASON_DONE           0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_STATUS_REASON_NON_CACHE      0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_TLB_TAG                      0x00003230 /* RW-4R */
#define NV_PFIFO_CACHE1_DMA_TLB_TAG_ADDRESS                   23:12 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_TLB_PTE                      0x00003234 /* RW-4R */
#define NV_PFIFO_CACHE1_DMA_TLB_PTE_PAGE                        0:0 /* RWXVF */
#define NV_PFIFO_CACHE1_DMA_TLB_PTE_PAGE_NOT_PRESENT     0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_TLB_PTE_PAGE_PRESENT         0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_TLB_PTE_FRAME_ADDRESS             31:12 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_TLB_PT_BASE                  0x00003238 /* RW-4R */
#define NV_PFIFO_CACHE1_DMA_TLB_PT_BASE_ADDRESS                19:2 /* RWXUF */
#define NV_PFIFO_CACHE0_PULL0                            0x00003040 /* RW-4R */
#define NV_PFIFO_CACHE0_PULL0_ACCESS                            0:0 /* RWIVF */
#define NV_PFIFO_CACHE0_PULL0_ACCESS_DISABLED            0x00000000 /* RWI-V */
#define NV_PFIFO_CACHE0_PULL0_ACCESS_ENABLED             0x00000001 /* RW--V */
#define NV_PFIFO_CACHE0_PULL0_HASH                              4:4 /* R-XVF */
#define NV_PFIFO_CACHE0_PULL0_HASH_SUCCEEDED             0x00000000 /* R---V */
#define NV_PFIFO_CACHE0_PULL0_HASH_FAILED                0x00000001 /* R---V */
#define NV_PFIFO_CACHE0_PULL0_DEVICE                            8:8 /* R-XVF */
#define NV_PFIFO_CACHE0_PULL0_DEVICE_HARDWARE            0x00000000 /* R---V */
#define NV_PFIFO_CACHE0_PULL0_DEVICE_SOFTWARE            0x00000001 /* R---V */
#define NV_PFIFO_CACHE1_PULL0                            0x00003240 /* RW-4R */
#define NV_PFIFO_CACHE1_PULL0_ACCESS                            0:0 /* RWIVF */
#define NV_PFIFO_CACHE1_PULL0_ACCESS_DISABLED            0x00000000 /* RWI-V */
#define NV_PFIFO_CACHE1_PULL0_ACCESS_ENABLED             0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_PULL0_HASH                              4:4 /* R-XVF */
#define NV_PFIFO_CACHE1_PULL0_HASH_SUCCEEDED             0x00000000 /* R---V */
#define NV_PFIFO_CACHE1_PULL0_HASH_FAILED                0x00000001 /* R---V */
#define NV_PFIFO_CACHE1_PULL0_DEVICE                            8:8 /* R-XVF */
#define NV_PFIFO_CACHE1_PULL0_DEVICE_HARDWARE            0x00000000 /* R---V */
#define NV_PFIFO_CACHE1_PULL0_DEVICE_SOFTWARE            0x00000001 /* R---V */
#define NV_PFIFO_CACHE1_PULL1                            0x00003250 /* RW-4R */
#define NV_PFIFO_CACHE1_PULL1_CTX                               4:4 /* RWXVF */
#define NV_PFIFO_CACHE1_PULL1_CTX_CLEAN                  0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_PULL1_CTX_DIRTY                  0x00000001 /* RW--V */
#define NV_PFIFO_CACHE0_STATUS                           0x00003014 /* R--4R */
#define NV_PFIFO_CACHE0_STATUS_LOW_MARK                         4:4 /* R--VF */
#define NV_PFIFO_CACHE0_STATUS_LOW_MARK_NOT_EMPTY        0x00000000 /* R---V */
#define NV_PFIFO_CACHE0_STATUS_LOW_MARK_EMPTY            0x00000001 /* R---V */
#define NV_PFIFO_CACHE0_STATUS_HIGH_MARK                        8:8 /* R--VF */
#define NV_PFIFO_CACHE0_STATUS_HIGH_MARK_NOT_FULL        0x00000000 /* R---V */
#define NV_PFIFO_CACHE0_STATUS_HIGH_MARK_FULL            0x00000001 /* R---V */
#define NV_PFIFO_CACHE1_STATUS                           0x00003214 /* R--4R */
#define NV_PFIFO_CACHE1_STATUS_RANOUT                           0:0 /* R-XVF */
#define NV_PFIFO_CACHE1_STATUS_RANOUT_FALSE              0x00000000 /* R---V */
#define NV_PFIFO_CACHE1_STATUS_RANOUT_TRUE               0x00000001 /* R---V */
#define NV_PFIFO_CACHE1_STATUS_LOW_MARK                         4:4 /* R--VF */
#define NV_PFIFO_CACHE1_STATUS_LOW_MARK_NOT_EMPTY        0x00000000 /* R---V */
#define NV_PFIFO_CACHE1_STATUS_LOW_MARK_EMPTY            0x00000001 /* R---V */
#define NV_PFIFO_CACHE1_STATUS_HIGH_MARK                        8:8 /* R--VF */
#define NV_PFIFO_CACHE1_STATUS_HIGH_MARK_NOT_FULL        0x00000000 /* R---V */
#define NV_PFIFO_CACHE1_STATUS_HIGH_MARK_FULL            0x00000001 /* R---V */
#define NV_PFIFO_CACHE0_PUT                              0x00003010 /* RW-4R */
#define NV_PFIFO_CACHE0_PUT_ADDRESS                             2:2 /* RWXUF */
#define NV_PFIFO_CACHE1_PUT                              0x00003210 /* RW-4R */
#define NV_PFIFO_CACHE1_PUT_ADDRESS                             6:2 /* RWXUF */
#define NV_PFIFO_CACHE0_GET                              0x00003070 /* RW-4R */
#define NV_PFIFO_CACHE0_GET_ADDRESS                             2:2 /* RWXUF */
#define NV_PFIFO_CACHE1_GET                              0x00003270 /* RW-4R */
#define NV_PFIFO_CACHE1_GET_ADDRESS                             6:2 /* RWXUF */
#define NV_PFIFO_CACHE0_CTX(i)                  (0x00003080+(i)*16) /* RW-4A */
#define NV_PFIFO_CACHE0_CTX__SIZE_1                               1 /*       */
#define NV_PFIFO_CACHE0_CTX_INSTANCE                           15:0 /* RWXUF */
#define NV_PFIFO_CACHE0_CTX_DEVICE                            22:16 /* RWXUF */
#define NV_PFIFO_CACHE0_CTX_ENGINE                            23:23 /* RWXVF */
#define NV_PFIFO_CACHE0_CTX_ENGINE_SW                    0x00000000 /* RW--V */
#define NV_PFIFO_CACHE0_CTX_ENGINE_GRAPHICS              0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_CTX(i)                  (0x00003280+(i)*16) /* RW-4A */
#define NV_PFIFO_CACHE1_CTX__SIZE_1                               8 /*       */
#define NV_PFIFO_CACHE1_CTX_INSTANCE                           15:0 /* RWXUF */
#define NV_PFIFO_CACHE1_CTX_DEVICE                            22:16 /* RWXUF */
#define NV_PFIFO_CACHE1_CTX_ENGINE                            23:23 /* RWXVF */
#define NV_PFIFO_CACHE1_CTX_ENGINE_SW                    0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_CTX_ENGINE_GRAPHICS              0x00000001 /* RW--V */
#define NV_PFIFO_CACHE0_METHOD(i)                (0x00003100+(i)*8) /* RW-4A */
#define NV_PFIFO_CACHE0_METHOD__SIZE_1                            1 /*       */
#define NV_PFIFO_CACHE0_METHOD_ADDRESS                         12:2 /* RWXUF */
#define NV_PFIFO_CACHE0_METHOD_SUBCHANNEL                     15:13 /* RWXUF */
#define NV_PFIFO_CACHE1_METHOD(i)                (0x00003300+(i)*8) /* RW-4A */
#define NV_PFIFO_CACHE1_METHOD__SIZE_1                           32 /*       */
#define NV_PFIFO_CACHE1_METHOD_ADDRESS                         12:2 /* RWXUF */
#define NV_PFIFO_CACHE1_METHOD_SUBCHANNEL                     15:13 /* RWXUF */
#define NV_PFIFO_CACHE0_DATA(i)                  (0x00003104+(i)*8) /* RW-4A */
#define NV_PFIFO_CACHE0_DATA__SIZE_1                              1 /*       */
#define NV_PFIFO_CACHE0_DATA_VALUE                             31:0 /* RWXVF */
#define NV_PFIFO_CACHE1_DATA(i)                  (0x00003304+(i)*8) /* RW-4A */
#define NV_PFIFO_CACHE1_DATA__SIZE_1                             32 /*       */
#define NV_PFIFO_CACHE1_DATA_VALUE                             31:0 /* RWXVF */
#define NV_PFIFO_DEVICE(i)                       (0x00002800+(i)*4) /* R--4A */
#define NV_PFIFO_DEVICE__SIZE_1                                 128 /*       */
#define NV_PFIFO_DEVICE_CHID                                    6:0 /* R--UF */
#define NV_PFIFO_DEVICE_SWITCH                                24:24 /* R--VF */
#define NV_PFIFO_DEVICE_SWITCH_UNAVAILABLE               0x00000000 /* R---V */
#define NV_PFIFO_DEVICE_SWITCH_AVAILABLE                 0x00000001 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS                           0x00002400 /* R--4R */
#define NV_PFIFO_RUNOUT_STATUS_RANOUT                           0:0 /* R--VF */
#define NV_PFIFO_RUNOUT_STATUS_RANOUT_FALSE              0x00000000 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS_RANOUT_TRUE               0x00000001 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS_LOW_MARK                         4:4 /* R--VF */
#define NV_PFIFO_RUNOUT_STATUS_LOW_MARK_NOT_EMPTY        0x00000000 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS_LOW_MARK_EMPTY            0x00000001 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS_HIGH_MARK                        8:8 /* R--VF */
#define NV_PFIFO_RUNOUT_STATUS_HIGH_MARK_NOT_FULL        0x00000000 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS_HIGH_MARK_FULL            0x00000001 /* R---V */
#define NV_PFIFO_RUNOUT_PUT                              0x00002410 /* RW-4R */
#define NV_PFIFO_RUNOUT_PUT_ADDRESS                            12:3 /* RWXUF */
#define NV_PFIFO_RUNOUT_PUT_ADDRESS__SIZE_0                     8:3 /*       */
#define NV_PFIFO_RUNOUT_PUT_ADDRESS__SIZE_1                    12:3 /*       */
#define NV_PFIFO_RUNOUT_GET                              0x00002420 /* RW-4R */
#define NV_PFIFO_RUNOUT_GET_ADDRESS                            13:3 /* RWXUF */
/* dev_graphics.ref */
#define NV_PGRAPH                             0x00401FFF:0x00400000 /* RW--D */
#define NV_PGRAPH_DEBUG_0                                0x00400080 /* RW-4R */
#define NV_PGRAPH_DEBUG_0_STATE                                 0:0 /* CW-VF */
#define NV_PGRAPH_DEBUG_0_STATE_NORMAL                   0x00000000 /* CW--V */
#define NV_PGRAPH_DEBUG_0_STATE_RESET                    0x00000001 /* -W--V */
#define NV_PGRAPH_DEBUG_0_AP_PIPE_STATE                         1:1 /* CW-VF */
#define NV_PGRAPH_DEBUG_0_AP_PIPE_STATE_NORMAL           0x00000000 /* CW--V */
#define NV_PGRAPH_DEBUG_0_AP_PIPE_STATE_RESET            0x00000001 /* -W--V */
#define NV_PGRAPH_DEBUG_0_CACHE_STATE                           2:2 /* CW-VF */
#define NV_PGRAPH_DEBUG_0_CACHE_STATE_NORMAL             0x00000000 /* CW--V */
#define NV_PGRAPH_DEBUG_0_CACHE_STATE_RESET              0x00000001 /* -W--V */
#define NV_PGRAPH_DEBUG_0_3D_PIPE_STATE                         3:3 /* CW-VF */
#define NV_PGRAPH_DEBUG_0_3D_PIPE_STATE_NORMAL           0x00000000 /* CW--V */
#define NV_PGRAPH_DEBUG_0_3D_PIPE_STATE_RESET            0x00000001 /* -W--V */
#define NV_PGRAPH_DEBUG_0_BULK_READS                            4:4 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_BULK_READS_DISABLED            0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_BULK_READS_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_SPARE1                                8:8 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_SPARE1_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_SPARE1_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_SPARE2                              12:12 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_SPARE2_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_SPARE2_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_TILING                              16:16 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_TILING_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_TILING_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS_2D                  20:20 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS_2D_DISABLED    0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS_2D_ENABLED     0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS_3D                  21:21 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS_3D_DISABLED    0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS_3D_ENABLED     0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_DRAWDIR_AUTO                        24:24 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_DRAWDIR_AUTO_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_DRAWDIR_AUTO_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_DRAWDIR_Y                           25:25 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_DRAWDIR_Y_DECR                 0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_DRAWDIR_Y_INCR                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_ALPHA_ABORT                         28:28 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_ALPHA_ABORT_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_ALPHA_ABORT_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1                                0x00400084 /* RW-4R */
#define NV_PGRAPH_DEBUG_1_VOLATILE_RESET                        0:0 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_VOLATILE_RESET_NOT_LAST        0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_VOLATILE_RESET_LAST            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_DMA_ACTIVITY                          4:4 /* CW-VF */
#define NV_PGRAPH_DEBUG_1_DMA_ACTIVITY_IGNORE            0x00000000 /* CW--V */
#define NV_PGRAPH_DEBUG_1_DMA_ACTIVITY_CANCEL            0x00000001 /* -W--V */
#define NV_PGRAPH_DEBUG_1_TURBO3D_2X                            8:8 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_TURBO3D_2X__DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_TURBO3D_2X_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_TURBO3D_4X                            9:9 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_TURBO3D_4X__DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_TURBO3D_4X_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_TRI_OPTS                            12:12 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_TRI_OPTS_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_TRI_OPTS_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_TRICLIP_OPTS                        13:13 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_TRICLIP_OPTS_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_TRICLIP_OPTS_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_INSTANCE                            16:16 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_INSTANCE_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_INSTANCE_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_CTX                                 20:20 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_CTX_DISABLED                   0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_CTX_ENABLED                    0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_CACHE                               24:24 /* CW-VF */
#define NV_PGRAPH_DEBUG_1_CACHE_IGNORE                   0x00000000 /* CW--V */
#define NV_PGRAPH_DEBUG_1_CACHE_FLUSH                    0x00000001 /* -W--V */
#define NV_PGRAPH_DEBUG_1_ZCLAMP                              28:28 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_ZCLAMP_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_ZCLAMP_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2                                0x00400088 /* RW-4R */
#define NV_PGRAPH_DEBUG_2_AVOID_RMW_BLEND                       0:0 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_AVOID_RMW_BLEND_DISABLED       0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_AVOID_RMW_BLEND_ENABLED        0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_SPARE1                                4:4 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_SPARE1_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_SPARE1_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_DPWR_FIFO                             8:8 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_DPWR_FIFO_DISABLED             0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_DPWR_FIFO_ENABLED              0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_BILINEAR_3D                         12:12 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_BILINEAR_3D_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_BILINEAR_3D_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_ANISOTROPIC_3D                      13:13 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_ANISOTROPIC_3D_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_ANISOTROPIC_3D_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_FOG_3D                              14:14 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_FOG_3D_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_FOG_3D_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_LIGHTING_3D                         15:15 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_LIGHTING_3D_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_LIGHTING_3D_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_BILINEAR_2D                         16:16 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_BILINEAR_2D_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_BILINEAR_2D_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_ANISOTROPIC_2D                      17:17 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_ANISOTROPIC_2D_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_ANISOTROPIC_2D_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_COELESCE_D3D                        20:20 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_COELESCE_D3D_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_COELESCE_D3D_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_COELESCE_PTZ                        21:21 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_COELESCE_PTZ_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_COELESCE_PTZ_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_PREFETCH                            24:24 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_PREFETCH_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_PREFETCH_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_VOLATILE_RESET                      28:28 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_VOLATILE_RESET_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_VOLATILE_RESET_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3                                0x0040008C /* RW-4R */
#define NV_PGRAPH_DEBUG_3_CULLING                               0:0 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_CULLING_DISABLED               0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_CULLING_ENABLED                0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_FAST_DATA_STRTCH                      4:4 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_FAST_DATA_STRTCH_DISABLED      0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_FAST_DATA_STRTCH_ENABLED       0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_FAST_DATA_D3D                         5:5 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_FAST_DATA_D3D_DISABLED         0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_FAST_DATA_D3D_ENABLED          0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_ZFLUSH                                7:7 /* CW-VF */
#define NV_PGRAPH_DEBUG_3_ZFLUSH_IGNORE                  0x00000000 /* CW--V */
#define NV_PGRAPH_DEBUG_3_ZFLUSH_ACTIVATE                0x00000001 /* -W--V */
#define NV_PGRAPH_DEBUG_3_AUTOZFLUSH_PTZ                        8:8 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_AUTOZFLUSH_PTZ_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_AUTOZFLUSH_PTZ_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_AUTOZFLUSH_D3D                        9:9 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_AUTOZFLUSH_D3D_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_AUTOZFLUSH_D3D_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_SLOT_CONFLICT_PTZ                   10:10 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_SLOT_CONFLICT_PTZ_DISABLED     0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_SLOT_CONFLICT_PTZ_ENABLED      0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_SLOT_CONFLICT_D3D                   11:11 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_SLOT_CONFLICT_D3D_DISABLED     0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_SLOT_CONFLICT_D3D_ENABLED      0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_EARLYZ_ABORT                        12:12 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_EARLYZ_ABORT_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_EARLYZ_ABORT_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_TRIEND_FLUSH                        13:13 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_TRIEND_FLUSH_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_TRIEND_FLUSH_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_ZFIFO_NOP_OPT                       14:14 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_ZFIFO_NOP_OPT_DISABLED         0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_ZFIFO_NOP_OPT_ENABLED          0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_DITHER_3D                           15:15 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_DITHER_3D_DISABLED             0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_DITHER_3D_ENABLED              0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_FORCE_CREAD                         16:16 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_FORCE_CREAD_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_FORCE_CREAD_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_FORCE_ZREAD                         17:17 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_FORCE_ZREAD_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_FORCE_ZREAD_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_DATA_CHECK                          20:20 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_DATA_CHECK_DISABLED            0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_DATA_CHECK_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_DATA_CHECK_FAIL                     21:21 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_DATA_CHECK_FAIL_DISABLED       0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_DATA_CHECK_FAIL_ENABLED        0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_FORMAT_CHECK                        22:22 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_FORMAT_CHECK_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_FORMAT_CHECK_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_ALPHA_CHECK                         24:24 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_ALPHA_CHECK_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_ALPHA_CHECK_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_SPARE1                              28:28 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_SPARE1_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_SPARE1_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_0                                 0x00400100 /* RW-4R */
#define NV_PGRAPH_INTR_0_RESERVED                               0:0 /* RW-VF */
#define NV_PGRAPH_INTR_0_RESERVED_NOT_PENDING            0x00000000 /* R---V */
#define NV_PGRAPH_INTR_0_RESERVED_PENDING                0x00000001 /* R---V */
#define NV_PGRAPH_INTR_0_RESERVED_RESET                  0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_0_CONTEXT_SWITCH                         4:4 /* RWIVF */
#define NV_PGRAPH_INTR_0_CONTEXT_SWITCH_NOT_PENDING      0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_0_CONTEXT_SWITCH_PENDING          0x00000001 /* R---V */
#define NV_PGRAPH_INTR_0_CONTEXT_SWITCH_RESET            0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_0_VBLANK                                 8:8 /* RWIVF */
#define NV_PGRAPH_INTR_0_VBLANK_NOT_PENDING              0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_0_VBLANK_PENDING                  0x00000001 /* R---V */
#define NV_PGRAPH_INTR_0_VBLANK_RESET                    0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_0_RANGE                                12:12 /* RWIVF */
#define NV_PGRAPH_INTR_0_RANGE_NOT_PENDING               0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_0_RANGE_PENDING                   0x00000001 /* R---V */
#define NV_PGRAPH_INTR_0_RANGE_RESET                     0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_0_METHOD_COUNT                         16:16 /* RWIVF */
#define NV_PGRAPH_INTR_0_METHOD_COUNT_NOT_PENDING        0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_0_METHOD_COUNT_PENDING            0x00000001 /* R---V */
#define NV_PGRAPH_INTR_0_METHOD_COUNT_RESET              0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_0_FORMAT                               20:20 /* RWIVF */
#define NV_PGRAPH_INTR_0_FORMAT_NOT_PENDING              0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_0_FORMAT_PENDING                  0x00000001 /* R---V */
#define NV_PGRAPH_INTR_0_FORMAT_RESET                    0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_0_COMPLEX_CLIP                         24:24 /* RWIVF */
#define NV_PGRAPH_INTR_0_COMPLEX_CLIP_NOT_PENDING        0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_0_COMPLEX_CLIP_PENDING            0x00000001 /* R---V */
#define NV_PGRAPH_INTR_0_COMPLEX_CLIP_RESET              0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_0_NOTIFY                               28:28 /* RWIVF */
#define NV_PGRAPH_INTR_0_NOTIFY_NOT_PENDING              0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_0_NOTIFY_PENDING                  0x00000001 /* R---V */
#define NV_PGRAPH_INTR_0_NOTIFY_RESET                    0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_1                                 0x00400104 /* RW-4R */
#define NV_PGRAPH_INTR_1_METHOD                                 0:0 /* RWIVF */
#define NV_PGRAPH_INTR_1_METHOD_NOT_PENDING              0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_1_METHOD_PENDING                  0x00000001 /* R---V */
#define NV_PGRAPH_INTR_1_METHOD_RESET                    0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_1_DATA                                   4:4 /* RWIVF */
#define NV_PGRAPH_INTR_1_DATA_NOT_PENDING                0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_1_DATA_PENDING                    0x00000001 /* R---V */
#define NV_PGRAPH_INTR_1_DATA_RESET                      0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_1_DOUBLE_NOTIFY                        12:12 /* RWIVF */
#define NV_PGRAPH_INTR_1_DOUBLE_NOTIFY_NOT_PENDING       0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_1_DOUBLE_NOTIFY_PENDING           0x00000001 /* R---V */
#define NV_PGRAPH_INTR_1_DOUBLE_NOTIFY_RESET             0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_1_CTXSW_NOTIFY                         16:16 /* RWIVF */
#define NV_PGRAPH_INTR_1_CTXSW_NOTIFY_NOT_PENDING        0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_1_CTXSW_NOTIFY_PENDING            0x00000001 /* R---V */
#define NV_PGRAPH_INTR_1_CTXSW_NOTIFY_RESET              0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_EN_0                              0x00400140 /* RW-4R */
#define NV_PGRAPH_INTR_EN_0_RESERVED                            0:0 /* RWIVF */
#define NV_PGRAPH_INTR_EN_0_RESERVED_DISABLED            0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_0_RESERVED_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_0_CONTEXT_SWITCH                      4:4 /* RWIVF */
#define NV_PGRAPH_INTR_EN_0_CONTEXT_SWITCH_DISABLED      0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_0_CONTEXT_SWITCH_ENABLED       0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_0_VBLANK                              8:8 /* RWIVF */
#define NV_PGRAPH_INTR_EN_0_VBLANK_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_0_VBLANK_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_0_RANGE                             12:12 /* RWIVF */
#define NV_PGRAPH_INTR_EN_0_RANGE_DISABLED               0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_0_RANGE_ENABLED                0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_0_METHOD_COUNT                      16:16 /* RWIVF */
#define NV_PGRAPH_INTR_EN_0_METHOD_COUNT_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_0_METHOD_COUNT_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_0_FORMAT                            20:20 /* RWIVF */
#define NV_PGRAPH_INTR_EN_0_FORMAT_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_0_FORMAT_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_0_COMPLEX_CLIP                      24:24 /* RWIVF */
#define NV_PGRAPH_INTR_EN_0_COMPLEX_CLIP_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_0_COMPLEX_CLIP_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_0_NOTIFY                            28:28 /* RWIVF */
#define NV_PGRAPH_INTR_EN_0_NOTIFY_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_0_NOTIFY_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_1                              0x00400144 /* RW-4R */
#define NV_PGRAPH_INTR_EN_1_METHOD                              0:0 /* RWIVF */
#define NV_PGRAPH_INTR_EN_1_METHOD_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_1_METHOD_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_1_DATA                                4:4 /* RWIVF */
#define NV_PGRAPH_INTR_EN_1_DATA_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_1_DATA_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_1_DOUBLE_NOTIFY                     12:12 /* RWIVF */
#define NV_PGRAPH_INTR_EN_1_DOUBLE_NOTIFY_DISABLED       0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_1_DOUBLE_NOTIFY_ENABLED        0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_1_CTXSW_NOTIFY                      16:16 /* RWIVF */
#define NV_PGRAPH_INTR_EN_1_CTXSW_NOTIFY_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_1_CTXSW_NOTIFY_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH                             0x00400180 /* RW-4R */
#define NV_PGRAPH_CTX_SWITCH_COLOR                              2:0 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_COLOR_R5G5B5                0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_COLOR_R8G8B8                0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_COLOR_R10G10B10             0x00000002 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_COLOR_Y8                    0x00000003 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_COLOR_Y16                   0x00000004 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_COLOR_V8Y18U8Y08            0x00000005 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_COLOR_Y18V8Y08U8            0x00000006 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_COLOR_Y420                  0x00000007 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_ALPHA                              3:3 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_ALPHA_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_ALPHA_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_SPARE1                             4:4 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_SPARE1_DISABLED             0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_SPARE1_ENABLED              0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_MONO_FORMAT                        8:8 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_MONO_FORMAT_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_MONO_FORMAT_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_DAC_BYPASS                         9:9 /* RWXVF */
#define NV_PGRAPH_CTX_SWITCH_DAC_BYPASS_DISABLED         0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_DAC_BYPASS_ENABLED          0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_SPARE2                           10:10 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_SPARE2_DISABLED             0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_SPARE2_ENABLED              0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_ZWRITE                           12:12 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_ZWRITE_DISABLED             0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_ZWRITE_ENABLED              0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_CHROMA_KEY                       13:13 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_CHROMA_KEY_DISABLED         0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_CHROMA_KEY_ENABLED          0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PLANE_MASK                       14:14 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_PLANE_MASK_DISABLED         0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_PLANE_MASK_ENABLED          0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_USER_CLIP                        15:15 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_USER_CLIP_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_USER_CLIP_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_SRC_BUFFER                       17:16 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_SRC_BUFFER_0                0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_SRC_BUFFER_1                0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_SRC_BUFFER_2                0x00000002 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_SRC_BUFFER_3                0x00000003 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER0                      20:20 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER0_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER0_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER1                      21:21 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER1_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER1_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER2                      22:22 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER2_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER2_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER3                      23:23 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER3_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER3_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG                     28:24 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_RSVD0          0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_DST_DST_SRC    0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_DST_SRC_DST    0x00000002 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_DST_SRC_SRC    0x00000003 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_DST_DST    0x00000004 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_DST_SRC    0x00000005 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_SRC_DST    0x00000006 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_SRC_SRC0   0x00000007 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_SRC_SRC1   0x00000008 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_SRC_PAT    0x00000009 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_PAT_SRC    0x0000000a /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_PAT_PAT    0x0000000b /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_PAT_SRC_SRC    0x0000000c /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_PAT_SRC_PAT    0x0000000d /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_PAT_PAT_SRC    0x0000000e /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_RSVD1          0x0000000f /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_PAT_SRC_DST    0x00000010 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_PAT_DST_SRC    0x00000011 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_PAT_DST    0x00000012 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_DST_PAT    0x00000013 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_DST_PAT_SRC    0x00000014 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_DST_SRC_PAT    0x00000015 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_RSVD2          0x00000016 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_BYPASS     0x00000017 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_BLEND_RSVD0    0x00000018 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_BLEND_SRC_DST  0x00000019 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_BLEND_DST_SRC  0x0000001a /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_BLEND_RSVD1    0x0000001b /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_BLEND_RSVD2    0x0000001c /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_BLEND_SRC      0x0000001d /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_BLEND_RSVD3    0x0000001e /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_BLEND_RSVD4    0x0000001f /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_SPARE3                           29:29 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_SPARE3_DISABLED             0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_SPARE3_ENABLED              0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_VOLATILE                         31:31 /* CWIVF */
#define NV_PGRAPH_CTX_SWITCH_VOLATILE_IGNORE             0x00000000 /* CWI-V */
#define NV_PGRAPH_CTX_SWITCH_VOLATILE_RESET              0x00000001 /* -W--V */
#define NV_PGRAPH_CTX_CACHE(i)                   (0x004001a0+(i)*4) /* RW-4A */
#define NV_PGRAPH_CTX_CACHE__SIZE_1                               8 /*       */
#define NV_PGRAPH_CTX_CACHE_COLOR                              2:0  /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_ALPHA                              3:3  /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_SPARE1                             4:4  /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_MONO_FORMAT                        8:8  /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_DAC_BYPASS                         9:9  /* RWXVF */
#define NV_PGRAPH_CTX_CACHE_SPARE2                            10:10 /* RWXVF */
#define NV_PGRAPH_CTX_CACHE_ZWRITE                            12:12 /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_CHROMA_KEY                        13:13 /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_PLANE_MASK                        14:14 /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_USER_CLIP                         15:15 /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_SRC_BUFFER                        17:16 /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_DST_BUFFER0                       20:20 /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_DST_BUFFER1                       21:21 /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_DST_BUFFER2                       22:22 /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_DST_BUFFER3                       23:23 /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_PATCH_CONFIG                      28:24 /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_SPARE3                            29:29 /* RWXVF */
#define NV_PGRAPH_CTX_CONTROL                            0x00400190 /* RW-4R */
#define NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME                      1:0 /* RWIVF */
#define NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME_33US          0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME_262US         0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME_2MS           0x00000002 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME_17MS          0x00000003 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_TIME                              8:8 /* RWIVF */
#define NV_PGRAPH_CTX_CONTROL_TIME_EXPIRED               0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_CONTROL_TIME_NOT_EXPIRED           0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_CHID                            16:16 /* RWIVF */
#define NV_PGRAPH_CTX_CONTROL_CHID_INVALID               0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_CONTROL_CHID_VALID                 0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_SWITCH                          20:20 /* R--VF */
#define NV_PGRAPH_CTX_CONTROL_SWITCH_UNAVAILABLE         0x00000000 /* R---V */
#define NV_PGRAPH_CTX_CONTROL_SWITCH_AVAILABLE           0x00000001 /* R---V */
#define NV_PGRAPH_CTX_CONTROL_SWITCHING                       24:24 /* RWIVF */
#define NV_PGRAPH_CTX_CONTROL_SWITCHING_IDLE             0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_CONTROL_SWITCHING_BUSY             0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_DEVICE                          28:28 /* RWIVF */
#define NV_PGRAPH_CTX_CONTROL_DEVICE_DISABLED            0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_CONTROL_DEVICE_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_USER                               0x00400194 /* RW-4R */
#define NV_PGRAPH_CTX_USER_SUBCH                              15:13 /* RWXVF */
#define NV_PGRAPH_CTX_USER_CLASS                              20:16 /* RWXVF */
#define NV_PGRAPH_CTX_USER_CHID                               30:24 /* RWXVF */
#define NV_PGRAPH_FIFO                                   0x004006A4 /* RW-4R */
#define NV_PGRAPH_FIFO_ACCESS                                   0:0 /* RWIVF */
#define NV_PGRAPH_FIFO_ACCESS_DISABLED                   0x00000000 /* RW--V */
#define NV_PGRAPH_FIFO_ACCESS_ENABLED                    0x00000001 /* RWI-V */
#define NV_PGRAPH_STATUS                                 0x004006B0 /* R--4R */
#define NV_PGRAPH_STATUS_STATE                                  0:0 /* R-IVF */
#define NV_PGRAPH_STATUS_STATE_IDLE                      0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_STATE_BUSY                      0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_XY_LOGIC                               4:4 /* R-IVF */
#define NV_PGRAPH_STATUS_XY_LOGIC_IDLE                   0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_XY_LOGIC_BUSY                   0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_PORT_NOTIFY                            8:8 /* R-IVF */
#define NV_PGRAPH_STATUS_PORT_NOTIFY_IDLE                0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_PORT_NOTIFY_BUSY                0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_PORT_REGISTER                        12:12 /* R-IVF */
#define NV_PGRAPH_STATUS_PORT_REGISTER_IDLE              0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_PORT_REGISTER_BUSY              0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_PORT_DMA                             16:16 /* R-IVF */
#define NV_PGRAPH_STATUS_PORT_DMA_IDLE                   0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_PORT_DMA_BUSY                   0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_DMA_ENGINE                           17:17 /* R-IVF */
#define NV_PGRAPH_STATUS_DMA_ENGINE_IDLE                 0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_DMA_ENGINE_BUSY                 0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_DMA_NOTIFY                           20:20 /* R-IVF */
#define NV_PGRAPH_STATUS_DMA_NOTIFY_IDLE                 0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_DMA_NOTIFY_BUSY                 0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_3D                                   24:24 /* R-IVF */
#define NV_PGRAPH_STATUS_3D_IDLE                         0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_3D_BUSY                         0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_CACHE                                25:25 /* R-IVF */
#define NV_PGRAPH_STATUS_CACHE_IDLE                      0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_CACHE_BUSY                      0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_LIGHTING                             26:26 /* R-IVF */
#define NV_PGRAPH_STATUS_LIGHTING_IDLE                   0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_LIGHTING_BUSY                   0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_ZFIFO                                27:27 /* R-IVF */
#define NV_PGRAPH_STATUS_ZFIFO_IDLE                      0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_ZFIFO_BUSY                      0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_PORT_USER                            28:28 /* R-IVF */
#define NV_PGRAPH_STATUS_PORT_USER_IDLE                  0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_PORT_USER_BUSY                  0x00000001 /* R---V */
#define NV_PGRAPH_TRAPPED_ADDR                           0x004006B4 /* R--4R */
#define NV_PGRAPH_TRAPPED_ADDR_MTHD                            12:2 /* R-XUF */
#define NV_PGRAPH_TRAPPED_ADDR_SUBCH                          15:13 /* R-XUF */
#define NV_PGRAPH_TRAPPED_ADDR_CLASS                          20:16 /* R-XUF */
#define NV_PGRAPH_TRAPPED_ADDR_CHID                           30:24 /* R-XUF */
#define NV_PGRAPH_TRAPPED_DATA                           0x004006B8 /* R--4R */
#define NV_PGRAPH_TRAPPED_DATA_VALUE                           31:0 /* R-XVF */
#define NV_PGRAPH_TRAPPED_INST                           0x004006BC /* R--4R */
#define NV_PGRAPH_TRAPPED_INST_VALUE                           15:0 /* R-XVF */
#define NV_PGRAPH_CLIP_MISC                              0x004006A0 /* RW-4R */
#define NV_PGRAPH_CLIP_MISC_REGIONS                             1:0 /* RWIUF */
#define NV_PGRAPH_CLIP_MISC_REGIONS_DISABLED             0x00000000 /* RWI-V */
#define NV_PGRAPH_CLIP_MISC_REGIONS_1                    0x00000001 /* RW--V */
#define NV_PGRAPH_CLIP_MISC_REGIONS_2                    0x00000002 /* RW--V */
#define NV_PGRAPH_CLIP_MISC_RENDER                              4:4 /* RWIVF */
#define NV_PGRAPH_CLIP_MISC_RENDER_INCLUDED              0x00000000 /* RWI-V */
#define NV_PGRAPH_CLIP_MISC_RENDER_OCCLUDED              0x00000001 /* RW--V */
#define NV_PGRAPH_CLIP_MISC_COMPLEX                             8:8 /* RWIVF */
#define NV_PGRAPH_CLIP_MISC_COMPLEX_DISABLED             0x00000000 /* RWI-V */
#define NV_PGRAPH_CLIP_MISC_COMPLEX_ENABLED              0x00000001 /* RW--V */
#define NV_PGRAPH_SRC_CANVAS_MIN                         0x00400550 /* RW-4R */
#define NV_PGRAPH_SRC_CANVAS_MIN_X                             10:0 /* RWXUF */
#define NV_PGRAPH_SRC_CANVAS_MIN_Y                            30:16 /* RWXUF */
#define NV_PGRAPH_DST_CANVAS_MIN                         0x00400558 /* RW-4R */
#define NV_PGRAPH_DST_CANVAS_MIN_X                             10:0 /* RWXUF */
#define NV_PGRAPH_DST_CANVAS_MIN_Y                            30:16 /* RWXUF */
#define NV_PGRAPH_SRC_CANVAS_MAX                         0x00400554 /* RW-4R */
#define NV_PGRAPH_SRC_CANVAS_MAX_X                             10:0 /* RWXUF */
#define NV_PGRAPH_SRC_CANVAS_MAX_Y                            30:16 /* RWXUF */
#define NV_PGRAPH_DST_CANVAS_MAX                         0x0040055C /* RW-4R */
#define NV_PGRAPH_DST_CANVAS_MAX_X                             10:0 /* RWXUF */
#define NV_PGRAPH_DST_CANVAS_MAX_Y                            30:16 /* RWXUF */
#define NV_PGRAPH_CLIP0_MIN                              0x00400690 /* RW-4R */
#define NV_PGRAPH_CLIP0_MIN_X                                  10:0 /* RWXSF */
#define NV_PGRAPH_CLIP0_MIN_Y                                 30:16 /* RWXSF */
#define NV_PGRAPH_CLIP1_MIN                              0x00400698 /* RW-4R */
#define NV_PGRAPH_CLIP1_MIN_X                                  10:0 /* RWXSF */
#define NV_PGRAPH_CLIP1_MIN_Y                                 30:16 /* RWXSF */
#define NV_PGRAPH_CLIP0_MAX                              0x00400694 /* RW-4R */
#define NV_PGRAPH_CLIP0_MAX_X                                  10:0 /* RWXSF */
#define NV_PGRAPH_CLIP0_MAX_Y                                 30:16 /* RWXSF */
#define NV_PGRAPH_CLIP1_MAX                              0x0040069C /* RW-4R */
#define NV_PGRAPH_CLIP1_MAX_X                                  10:0 /* RWXSF */
#define NV_PGRAPH_CLIP1_MAX_Y                                 30:16 /* RWXSF */
#define NV_PGRAPH_DMA                                    0x00400680 /* RW-4R */
#define NV_PGRAPH_DMA_INSTANCE                                 15:0 /* RWXUF */
#define NV_PGRAPH_NOTIFY                                 0x00400684 /* RW-4R */
#define NV_PGRAPH_NOTIFY_INSTANCE                              15:0 /* RWXUF */
#define NV_PGRAPH_NOTIFY_REQ                                  16:16 /* RWIVF */
#define NV_PGRAPH_NOTIFY_REQ_NOT_PENDING                 0x00000000 /* RWI-V */
#define NV_PGRAPH_NOTIFY_REQ_PENDING                     0x00000001 /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE                                 23:20 /* RWIVF */
#define NV_PGRAPH_NOTIFY_TYPE_HW                         0x00000000 /* RWI-V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_1                       0x00000001 /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_2                       0x00000002 /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_3                       0x00000003 /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_4                       0x00000004 /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_5                       0x00000005 /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_6                       0x00000006 /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_7                       0x00000007 /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_8                       0x00000008 /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_9                       0x00000009 /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_10                      0x0000000A /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_11                      0x0000000B /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_12                      0x0000000C /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_13                      0x0000000D /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_14                      0x0000000E /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_15                      0x0000000F /* RW--V */
#define NV_PGRAPH_INSTANCE                               0x00400688 /* RW-4R */
#define NV_PGRAPH_INSTANCE_TAG                                 15:0 /* RWXUF */
#define NV_PGRAPH_INSTANCE_TAG_INVALID                   0x00000000 /* RWI-V */
#define NV_PGRAPH_MEMFMT                                 0x0040068C /* RW-4R */
#define NV_PGRAPH_MEMFMT_INSTANCE                              15:0 /* RWXUF */
#define NV_PGRAPH_MEMFMT_LINEAR                               16:16 /* RWIVF */
#define NV_PGRAPH_MEMFMT_LINEAR_OUT                      0x00000000 /* RW--V */
#define NV_PGRAPH_MEMFMT_LINEAR_IN                       0x00000001 /* RW--V */
#define NV_PGRAPH_BOFFSET0                               0x00400630 /* RW-4R */
#define NV_PGRAPH_BOFFSET0_LINADRS                             22:0 /* RWIUF */
#define NV_PGRAPH_BOFFSET0_LINADRS_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_BOFFSET1                               0x00400634 /* RW-4R */
#define NV_PGRAPH_BOFFSET1_LINADRS                             22:0 /* RWIUF */
#define NV_PGRAPH_BOFFSET1_LINADRS_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_BOFFSET2                               0x00400638 /* RW-4R */
#define NV_PGRAPH_BOFFSET2_LINADRS                             22:0 /* RWIUF */
#define NV_PGRAPH_BOFFSET2_LINADRS_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_BOFFSET3                               0x0040063C /* RW-4R */
#define NV_PGRAPH_BOFFSET3_LINADRS                             22:0 /* RWIUF */
#define NV_PGRAPH_BOFFSET3_LINADRS_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_BPITCH0                                0x00400650 /* RW-4R */
#define NV_PGRAPH_BPITCH0_VALUE                                12:0 /* RWXUF */
#define NV_PGRAPH_BPITCH1                                0x00400654 /* RW-4R */
#define NV_PGRAPH_BPITCH1_VALUE                                12:0 /* RWXUF */
#define NV_PGRAPH_BPITCH2                                0x00400658 /* RW-4R */
#define NV_PGRAPH_BPITCH2_VALUE                                12:0 /* RWXUF */
#define NV_PGRAPH_BPITCH3                                0x0040065C /* RW-4R */
#define NV_PGRAPH_BPITCH3_VALUE                                12:0 /* RWXUF */
#define NV_PGRAPH_BPIXEL                                 0x004006a8 /* RW-4R */
#define NV_PGRAPH_BPIXEL_DEPTH0_FMT                             1:0 /* RWXVF */
#define NV_PGRAPH_BPIXEL_DEPTH0_FMT_Y16_BITS             0x00000000 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_FMT_8_BITS               0x00000001 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_FMT_16_BITS              0x00000002 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_FMT_32_BITS              0x00000003 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0                                 2:2 /* RWXVF */
#define NV_PGRAPH_BPIXEL_DEPTH0_NOT_VALID                0x00000000 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_VALID                    0x00000001 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_FMT                             5:4 /* RWXVF */
#define NV_PGRAPH_BPIXEL_DEPTH1_FMT_Y16_BITS             0x00000000 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_FMT_8_BITS               0x00000001 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_FMT_16_BITS              0x00000002 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_FMT_32_BITS              0x00000003 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1                                 6:6 /* RWXVF */
#define NV_PGRAPH_BPIXEL_DEPTH1_NOT_VALID                0x00000000 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_VALID                    0x00000001 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_FMT                             9:8 /* RWXVF */
#define NV_PGRAPH_BPIXEL_DEPTH2_FMT_Y16_BITS             0x00000000 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_FMT_8_BITS               0x00000001 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_FMT_16_BITS              0x00000002 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_FMT_32_BITS              0x00000003 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2                               10:10 /* RWXVF */
#define NV_PGRAPH_BPIXEL_DEPTH2_NOT_VALID                0x00000000 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_VALID                    0x00000001 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_FMT                           13:12 /* RWXVF */
#define NV_PGRAPH_BPIXEL_DEPTH3_FMT_Y16_BITS             0x00000000 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_FMT_8_BITS               0x00000001 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_FMT_16_BITS              0x00000002 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_FMT_32_BITS              0x00000003 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3                               14:14 /* RWXVF */
#define NV_PGRAPH_BPIXEL_DEPTH3_NOT_VALID                0x00000000 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_VALID                    0x00000001 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX                            0x004006c0 /* RW-4R */
#define NV_PGRAPH_CACHE_INDEX_BANK                              2:2 /* RWXVF */
#define NV_PGRAPH_CACHE_INDEX_BANK_10                    0x00000000 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_BANK_32                    0x00000001 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_ADRS                             12:3 /* RWXVF */
#define NV_PGRAPH_CACHE_INDEX_ADRS_0                     0x00000000 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_ADRS_1024                  0x00000400 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_OP                              14:13 /* RWXVF */
#define NV_PGRAPH_CACHE_INDEX_OP_WR_CACHE                0x00000000 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_OP_RD_CACHE                0x00000001 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_OP_RD_INDEX                0x00000002 /* RW--V */
#define NV_PGRAPH_CACHE_RAM                              0x004006c4 /* RW-4R */
#define NV_PGRAPH_CACHE_RAM_VALUE                              31:0 /* RWXVF */
#define NV_PGRAPH_ALPHACNTRL                             0x004006c8 /* RW-4R */
#define NV_PGRAPH_ALPHACNTRL_ALPHA_KEY                          7:0 /* RWXUF */
#define NV_PGRAPH_ALPHACNTRL_ALPHA_COMPARE                     11:8 /* RWXVF */
#define NV_PGRAPH_ALPHACNTRL_ALPHA_COMPARE_ILLEGAL       0x00000000 /* RW--V */
#define NV_PGRAPH_ALPHACNTRL_ALPHA_COMPARE_FALSE         0x00000001 /* RW--V */
#define NV_PGRAPH_ALPHACNTRL_ALPHA_COMPARE_LT            0x00000002 /* RW--V */
#define NV_PGRAPH_ALPHACNTRL_ALPHA_COMPARE_EQ            0x00000003 /* RW--V */
#define NV_PGRAPH_ALPHACNTRL_ALPHA_COMPARE_LE            0x00000004 /* RW--V */
#define NV_PGRAPH_ALPHACNTRL_ALPHA_COMPARE_GT            0x00000005 /* RW--V */
#define NV_PGRAPH_ALPHACNTRL_ALPHA_COMPARE_NE            0x00000006 /* RW--V */
#define NV_PGRAPH_ALPHACNTRL_ALPHA_COMPARE_GE            0x00000007 /* RW--V */
#define NV_PGRAPH_ALPHACNTRL_ALPHA_COMPARE_TRUE          0x00000008 /* RW--V */
#define NV_PGRAPH_PATT_COLOR0_0                          0x00400600 /* RW-4R */
#define NV_PGRAPH_PATT_COLOR0_0_BLUE                            9:0 /* RWXUF */
#define NV_PGRAPH_PATT_COLOR0_0_GREEN                         19:10 /* RWXUF */
#define NV_PGRAPH_PATT_COLOR0_0_RED                           29:20 /* RWXUF */
#define NV_PGRAPH_PATT_COLOR0_1                          0x00400604 /* RW-4R */
#define NV_PGRAPH_PATT_COLOR0_1_ALPHA                           7:0 /* RWXUF */
#define NV_PGRAPH_PATT_COLOR1_0                          0x00400608 /* RW-4R */
#define NV_PGRAPH_PATT_COLOR1_0_BLUE                            9:0 /* RWXUF */
#define NV_PGRAPH_PATT_COLOR1_0_GREEN                         19:10 /* RWXUF */
#define NV_PGRAPH_PATT_COLOR1_0_RED                           29:20 /* RWXUF */
#define NV_PGRAPH_PATT_COLOR1_1                          0x0040060C /* RW-4R */
#define NV_PGRAPH_PATT_COLOR1_1_ALPHA                           7:0 /* RWXUF */
#define NV_PGRAPH_PATTERN(i)                     (0x00400610+(i)*4) /* RW-4A */
#define NV_PGRAPH_PATTERN__SIZE_1                                 2 /*       */
#define NV_PGRAPH_PATTERN_BITMAP                               31:0 /* RWXVF */
#define NV_PGRAPH_PATTERN_SHAPE                          0x00400618 /* RW-4R */
#define NV_PGRAPH_PATTERN_SHAPE_VALUE                           1:0 /* RWXVF */
#define NV_PGRAPH_PATTERN_SHAPE_VALUE_8X8                0x00000000 /* RW--V */
#define NV_PGRAPH_PATTERN_SHAPE_VALUE_64X1               0x00000001 /* RW--V */
#define NV_PGRAPH_PATTERN_SHAPE_VALUE_1X64               0x00000002 /* RW--V */
#define NV_PGRAPH_MONO_COLOR0                            0x0040061C /* RW-4R */
#define NV_PGRAPH_MONO_COLOR0_BLUE                              9:0 /* RWXUF */
#define NV_PGRAPH_MONO_COLOR0_GREEN                           19:10 /* RWXUF */
#define NV_PGRAPH_MONO_COLOR0_RED                             29:20 /* RWXUF */
#define NV_PGRAPH_MONO_COLOR0_ALPHA                           30:30 /* RWXUF */
#define NV_PGRAPH_ROP3                                   0x00400624 /* RW-4R */
#define NV_PGRAPH_ROP3_VALUE                                    7:0 /* RWXVF */
#define NV_PGRAPH_PLANE_MASK                             0x00400628 /* RW-4R */
#define NV_PGRAPH_PLANE_MASK_BLUE                               9:0 /* RWXUF */
#define NV_PGRAPH_PLANE_MASK_GREEN                            19:10 /* RWXUF */
#define NV_PGRAPH_PLANE_MASK_RED                              29:20 /* RWXUF */
#define NV_PGRAPH_PLANE_MASK_ALPHA                            30:30 /* RWXUF */
#define NV_PGRAPH_CHROMA                                 0x0040062C /* RW-4R */
#define NV_PGRAPH_CHROMA_BLUE                                   9:0 /* RWXUF */
#define NV_PGRAPH_CHROMA_GREEN                                19:10 /* RWXUF */
#define NV_PGRAPH_CHROMA_RED                                  29:20 /* RWXUF */
#define NV_PGRAPH_CHROMA_ALPHA                                30:30 /* RWXUF */
#define NV_PGRAPH_BETA                                   0x00400640 /* RW-4R */
#define NV_PGRAPH_BETA_VALUE_FRACTION                         30:23 /* RWXUF */
#define NV_PGRAPH_CONTROL_OUT                            0x00400644 /* RW-4R */
#define NV_PGRAPH_CONTROL_OUT_INTERPOLATOR                      1:0 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_INTERPOLATOR_ZOH           0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_INTERPOLATOR_ZOH_MS        0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_INTERPOLATOR_FOH           0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_U                            5:4 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_WRAP_U_CYLINDRICAL         0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_U_WRAP                0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_U_MIRROR              0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_U_CLAMP               0x00000003 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_V                            7:6 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_WRAP_V_CYLINDRICAL         0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_V_WRAP                0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_V_MIRROR              0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_V_CLAMP               0x00000003 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_COLOR_FORMAT                      8:8 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_COLOR_FORMAT_LE_X8R8G8B8   0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_COLOR_FORMAT_LE_A8R8G8B8   0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_SRCCOLOR                        11:10 /* -W-UF */
#define NV_PGRAPH_CONTROL_OUT_SRCCOLOR_NORMAL            0x00000000 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_SRCCOLOR_COLOR_INVERSE     0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_SRCCOLOR_ALPHA_INVERSE     0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_SRCCOLOR_ALPHA_ONE         0x00000003 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_CULLING                         13:12 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_CULLING_ILLEGAL            0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_CULLING_NONE               0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_CULLING_CLOCKWISE          0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_CULLING_COUNTERCLOCKWISE   0x00000003 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZBUFFER                         15:15 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_ZBUFFER_SCREEN             0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_ZBUFFER_LINEAR             0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE                    19:16 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_ILLEGAL       0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_FALSE         0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_LT            0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_EQ            0x00000003 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_LE            0x00000004 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_GT            0x00000005 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_NE            0x00000006 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_GE            0x00000007 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_TRUE          0x00000008 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_WRITE                      22:20 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_ZETA_WRITE_NEVER           0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_WRITE_ALPHA           0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_WRITE_ALPHA_ZETA      0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_WRITE_ZETA            0x00000003 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_WRITE_ALWAYS          0x00000004 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_COLOR_WRITE                     26:24 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_COLOR_WRITE_NEVER          0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_COLOR_WRITE_ALPHA          0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_COLOR_WRITE_ALPHA_ZETA     0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_COLOR_WRITE_ZETA           0x00000003 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_COLOR_WRITE_ALWAYS         0x00000004 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ROP                             28:28 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_ROP_BLEND_AND              0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_ROP_ADD_WITH_SATURATION    0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_BLEND_BETA                      29:29 /* -W-UF */
#define NV_PGRAPH_CONTROL_OUT_BLEND_BETA_SRCALPHA        0x00000000 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_BLEND_BETA_DESTCOLOR       0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_BLEND_INPUT0                    30:30 /* -W-UF */
#define NV_PGRAPH_CONTROL_OUT_BLEND_INPUT0_DESTCOLOR     0x00000000 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_BLEND_INPUT0_ZERO          0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_BLEND_INPUT1                    31:31 /* -W-UF */
#define NV_PGRAPH_CONTROL_OUT_BLEND_INPUT1_SRCCOLOR      0x00000000 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_BLEND_INPUT1_ZERO          0x00000001 /* -W-UV */
#define NV_PGRAPH_DPRAM_INDEX                            0x00400648 /* RW-4R */
#define NV_PGRAPH_DPRAM_INDEX_ADRS                              5:0 /* RWIVF */
#define NV_PGRAPH_DPRAM_INDEX_ADRS_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT                           10:8 /* RWIVF */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_ADRS_0              0x00000000 /* RWI-V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_ADRS_1              0x00000001 /* RW--V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_DATA_0              0x00000002 /* RW--V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_DATA_1              0x00000003 /* RW--V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_WE                  0x00000004 /* RW--V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_ALPHA               0x00000005 /* RW--V */
#define NV_PGRAPH_DPRAM_DATA                             0x0040064c /* RW-4R */
#define NV_PGRAPH_DPRAM_DATA_VALUE                             31:0 /* RWXVF */
#define NV_PGRAPH_DPRAM_ADRS_0                           0x0040064c /* RW-4R */
#define NV_PGRAPH_DPRAM_ADRS_0__ALIAS_1        NV_PGRAPH_DPRAM_DATA /*       */
#define NV_PGRAPH_DPRAM_ADRS_0_VALUE                           19:0 /* RWXVF */
#define NV_PGRAPH_DPRAM_ADRS_1                           0x0040064c /* RW-4R */
#define NV_PGRAPH_DPRAM_ADRS_1__ALIAS_1        NV_PGRAPH_DPRAM_DATA /*       */
#define NV_PGRAPH_DPRAM_ADRS_1_VALUE                           19:0 /* RWXVF */
#define NV_PGRAPH_DPRAM_DATA_0                           0x0040064c /* RW-4R */
#define NV_PGRAPH_DPRAM_DATA_0__ALIAS_1        NV_PGRAPH_DPRAM_DATA /*       */
#define NV_PGRAPH_DPRAM_DATA_0_VALUE                           31:0 /* RWXVF */
#define NV_PGRAPH_DPRAM_DATA_1                           0x0040064c /* RW-4R */
#define NV_PGRAPH_DPRAM_DATA_1__ALIAS_1        NV_PGRAPH_DPRAM_DATA /*       */
#define NV_PGRAPH_DPRAM_DATA_1_VALUE                           31:0 /* RWXVF */
#define NV_PGRAPH_DPRAM_WE                               0x0040064c /* RW-4R */
#define NV_PGRAPH_DPRAM_WE__ALIAS_1            NV_PGRAPH_DPRAM_DATA /*       */
#define NV_PGRAPH_DPRAM_WE_VALUE                               31:0 /* RWXVF */
#define NV_PGRAPH_DPRAM_ALPHA                            0x0040064c /* RW-4R */
#define NV_PGRAPH_DPRAM_ALPHA__ALIAS_1         NV_PGRAPH_DPRAM_DATA /*       */
#define NV_PGRAPH_DPRAM_ALPHA_VALUE                            31:0 /* RWXVF */
#define NV_PGRAPH_ABS_X_RAM(i)                   (0x00400400+(i)*4) /* RW-4A */
#define NV_PGRAPH_ABS_X_RAM__SIZE_1                              32 /*       */
#define NV_PGRAPH_ABS_X_RAM_VALUE                              31:0 /* RWXUF */
#define NV_PGRAPH_X_RAM_BPORT(i)                 (0x00400c00+(i)*4) /* R--4A */
#define NV_PGRAPH_X_RAM_BPORT__SIZE_1                            32 /*       */
#define NV_PGRAPH_X_RAM_BPORT_VALUE                            31:0 /* R--UF */
#define NV_PGRAPH_ABS_Y_RAM(i)                   (0x00400480+(i)*4) /* RW-4A */
#define NV_PGRAPH_ABS_Y_RAM__SIZE_1                              32 /*       */
#define NV_PGRAPH_ABS_Y_RAM_VALUE                              31:0 /* RWXUF */
#define NV_PGRAPH_Y_RAM_BPORT(i)                 (0x00400c80+(i)*4) /* R--4A */
#define NV_PGRAPH_Y_RAM_BPORT__SIZE_1                            32 /*       */
#define NV_PGRAPH_Y_RAM_BPORT_VALUE                            31:0 /* R--UF */
#define NV_PGRAPH_XY_LOGIC_MISC0                         0x00400514 /* RW-4R */
#define NV_PGRAPH_XY_LOGIC_MISC0_COUNTER                       17:0 /* RWIUF */
#define NV_PGRAPH_XY_LOGIC_MISC0_COUNTER_0               0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC0_DIMENSION                    20:20 /* RWXVF */
#define NV_PGRAPH_XY_LOGIC_MISC0_DIMENSION_NONZERO       0x00000000 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC0_DIMENSION_ZERO          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC0_INDEX                        31:28 /* RWIUF */
#define NV_PGRAPH_XY_LOGIC_MISC0_INDEX_0                 0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1                         0x00400518 /* RW-4R */
#define NV_PGRAPH_XY_LOGIC_MISC1_INITIAL                        0:0 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_INITIAL_NEEDED          0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_INITIAL_DONE            0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPX                      4:4 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPX_NOTNULL       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPX_NULL          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPY                      5:5 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPY_NOTNULL       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPY_NULL          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_USERCLIPX                      8:8 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_USERCLIPX_NOTNULL       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_USERCLIPX_NULL          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_USERCLIPY                      9:9 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_USERCLIPY_NOTNULL       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_USERCLIPY_NULL          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XCMIN                    12:12 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XCMIN_CANVASMIN     0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XCMIN_USERMIN       0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XCMAX                    13:13 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XCMAX_CANVASMAX     0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XCMAX_USERMAX       0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XIMAX                    14:14 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XIMAX_UCMAX         0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XIMAX_IMAGEMAX      0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YCMIN                    16:16 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YCMIN_CANVASMIN     0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YCMIN_USERMIN       0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YCMAX                    17:17 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YCMAX_CANVASMAX     0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YCMAX_USERMAX       0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YIMAX                    18:18 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YIMAX_UCMAX         0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YIMAX_IMAGEMAX      0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XXTRA                    20:20 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XXTRA_CLIPMAX       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XXTRA_IMAGEMAX      0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_DUDX                         27:24 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_DUDX_VALUE              0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2                         0x0040051C /* RW-4R */
#define NV_PGRAPH_XY_LOGIC_MISC2_HANDOFF                        0:0 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_HANDOFF_DISABLE         0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_HANDOFF_ENABLE          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPX                      4:4 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPX_NOTNULL       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPX_NULL          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPY                      5:5 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPY_NOTNULL       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPY_NULL          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_USERCLIPX                      8:8 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_USERCLIPX_NOTNULL       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_USERCLIPX_NULL          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_USERCLIPY                      9:9 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_USERCLIPY_NOTNULL       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_USERCLIPY_NULL          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XCMIN                    12:12 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XCMIN_CANVASMIN     0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XCMIN_USERMIN       0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XCMAX                    13:13 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XCMAX_CANVASMAX     0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XCMAX_USERMAX       0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XIMAX                    14:14 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XIMAX_UCMAX         0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XIMAX_IMAGEMAX      0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YCMIN                    16:16 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YCMIN_CANVASMIN     0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YCMIN_USERMIN       0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YCMAX                    17:17 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YCMAX_CANVASMAX     0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YCMAX_USERMAX       0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YIMAX                    18:18 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YIMAX_UCMAX         0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YIMAX_IMAGEMAX      0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XXTRA                    20:20 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XXTRA_CLIPMAX       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XXTRA_IMAGEMAX      0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_DVDY                         27:24 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_DVDY_VALUE              0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC3                         0x00400520 /* RW-4R */
#define NV_PGRAPH_XY_LOGIC_MISC3_WDIMY_EQ_0                     0:0 /* RWXVF */
#define NV_PGRAPH_XY_LOGIC_MISC3_WDIMY_EQ_0_NULL         0x00000000 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC3_WDIMY_EQ_0_TRUE         0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WDIMY                   4:4 /* RWXVF */
#define NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WDIMY_NULL       0x00000000 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WDIMY_TRUE       0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WX                      8:8 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WX_NULL          0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WX_TRUE          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_ALG                     12:12 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_ALG_NULL           0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_ALG_TRUE           0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_DIMX                    22:16 /* RWXUF */
#define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_DIMX_0             0x00000000 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_WDIMX                   30:24 /* RWXUF */
#define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_WDIMX_0            0x00000000 /* RW--V */
#define NV_PGRAPH_X_MISC                                 0x00400500 /* RW-4R */
#define NV_PGRAPH_X_MISC_BIT33_0                                0:0 /* RWIVF */
#define NV_PGRAPH_X_MISC_BIT33_0_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_X_MISC_BIT33_1                                1:1 /* RWIVF */
#define NV_PGRAPH_X_MISC_BIT33_1_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_X_MISC_BIT33_2                                2:2 /* RWIVF */
#define NV_PGRAPH_X_MISC_BIT33_2_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_X_MISC_BIT33_3                                3:3 /* RWIVF */
#define NV_PGRAPH_X_MISC_BIT33_3_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_X_MISC_RANGE_0                                4:4 /* RWIVF */
#define NV_PGRAPH_X_MISC_RANGE_0_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_X_MISC_RANGE_1                                5:5 /* RWIVF */
#define NV_PGRAPH_X_MISC_RANGE_1_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_X_MISC_RANGE_2                                6:6 /* RWIVF */
#define NV_PGRAPH_X_MISC_RANGE_2_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_X_MISC_RANGE_3                                7:7 /* RWIVF */
#define NV_PGRAPH_X_MISC_RANGE_3_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_X_MISC_ADDER_OUTPUT                         29:28 /* RWXVF */
#define NV_PGRAPH_X_MISC_ADDER_OUTPUT_EQ_0               0x00000000 /* RW--V */
#define NV_PGRAPH_X_MISC_ADDER_OUTPUT_LT_0               0x00000001 /* RW--V */
#define NV_PGRAPH_X_MISC_ADDER_OUTPUT_GT_0               0x00000002 /* RW--V */
#define NV_PGRAPH_Y_MISC                                 0x00400504 /* RW-4R */
#define NV_PGRAPH_Y_MISC_BIT33_0                                0:0 /* RWIVF */
#define NV_PGRAPH_Y_MISC_BIT33_0_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_Y_MISC_BIT33_1                                1:1 /* RWIVF */
#define NV_PGRAPH_Y_MISC_BIT33_1_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_Y_MISC_BIT33_2                                2:2 /* RWIVF */
#define NV_PGRAPH_Y_MISC_BIT33_2_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_Y_MISC_BIT33_3                                3:3 /* RWIVF */
#define NV_PGRAPH_Y_MISC_BIT33_3_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_Y_MISC_RANGE_0                                4:4 /* RWIVF */
#define NV_PGRAPH_Y_MISC_RANGE_0_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_Y_MISC_RANGE_1                                5:5 /* RWIVF */
#define NV_PGRAPH_Y_MISC_RANGE_1_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_Y_MISC_RANGE_2                                6:6 /* RWIVF */
#define NV_PGRAPH_Y_MISC_RANGE_2_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_Y_MISC_RANGE_3                                7:7 /* RWIVF */
#define NV_PGRAPH_Y_MISC_RANGE_3_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_Y_MISC_ADDER_OUTPUT                         29:28 /* RWXVF */
#define NV_PGRAPH_Y_MISC_ADDER_OUTPUT_EQ_0               0x00000000 /* RW--V */
#define NV_PGRAPH_Y_MISC_ADDER_OUTPUT_LT_0               0x00000001 /* RW--V */
#define NV_PGRAPH_Y_MISC_ADDER_OUTPUT_GT_0               0x00000002 /* RW--V */
#define NV_PGRAPH_ABS_UCLIP_XMIN                         0x0040053C /* RW-4R */
#define NV_PGRAPH_ABS_UCLIP_XMIN_VALUE                         17:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIP_XMAX                         0x00400544 /* RW-4R */
#define NV_PGRAPH_ABS_UCLIP_XMAX_VALUE                         17:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIP_YMIN                         0x00400540 /* RW-4R */
#define NV_PGRAPH_ABS_UCLIP_YMIN_VALUE                         17:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIP_YMAX                         0x00400548 /* RW-4R */
#define NV_PGRAPH_ABS_UCLIP_YMAX_VALUE                         17:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIPA_XMIN                        0x00400560 /* RW-4R */
#define NV_PGRAPH_ABS_UCLIPA_XMIN_VALUE                        17:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIPA_XMAX                        0x00400568 /* RW-4R */
#define NV_PGRAPH_ABS_UCLIPA_XMAX_VALUE                        17:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIPA_YMIN                        0x00400564 /* RW-4R */
#define NV_PGRAPH_ABS_UCLIPA_YMIN_VALUE                        17:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIPA_YMAX                        0x0040056C /* RW-4R */
#define NV_PGRAPH_ABS_UCLIPA_YMAX_VALUE                        17:0 /* RWXSF */
#define NV_PGRAPH_SOURCE_COLOR                           0x0040050C /* RW-4R */
#define NV_PGRAPH_SOURCE_COLOR_VALUE                           31:0 /* RWXVF */
#define NV_PGRAPH_EXCEPTIONS                             0x00400508 /* RW-4R */
#define NV_PGRAPH_EXCEPTIONS_VALID                             27:0 /* RWIVF */
#define NV_PGRAPH_EXCEPTIONS_VALID_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_EXCEPTIONS_CLIP_MIN                         28:28 /* RWIVF */
#define NV_PGRAPH_EXCEPTIONS_CLIP_MIN_NO_ERROR           0x00000000 /* RWI-V */
#define NV_PGRAPH_EXCEPTIONS_CLIP_MIN_ONLY               0x00000001 /* RW--V */
#define NV_PGRAPH_EXCEPTIONS_CLIPA_MIN                        29:29 /* RWIVF */
#define NV_PGRAPH_EXCEPTIONS_CLIPA_MIN_NO_ERROR          0x00000000 /* RWI-V */
#define NV_PGRAPH_EXCEPTIONS_CLIPA_MIN_ONLY              0x00000001 /* RW--V */
#define NV_PGRAPH_EXCEPTIONS_CLIP_MAX                         30:30 /* RWIVF */
#define NV_PGRAPH_EXCEPTIONS_CLIP_MAX_NO_ERROR           0x00000000 /* RWI-V */
#define NV_PGRAPH_EXCEPTIONS_CLIP_MAX_ONLY               0x00000001 /* RW--V */
#define NV_PGRAPH_EXCEPTIONS_CLIPA_MAX                        31:31 /* RWIVF */
#define NV_PGRAPH_EXCEPTIONS_CLIPA_MAX_NO_ERROR          0x00000000 /* RWI-V */
#define NV_PGRAPH_EXCEPTIONS_CLIPA_MAX_ONLY              0x00000001 /* RW--V */
#define NV_PGRAPH_ABS_ICLIP_XMAX                         0x00400534 /* RW-4R */
#define NV_PGRAPH_ABS_ICLIP_XMAX_VALUE                         17:0 /* RWXSF */
#define NV_PGRAPH_ABS_ICLIP_YMAX                         0x00400538 /* RW-4R */
#define NV_PGRAPH_ABS_ICLIP_YMAX_VALUE                         17:0 /* RWXSF */
#define NV_PGRAPH_CLIPX_0                                0x00400524 /* RW-4R */
#define NV_PGRAPH_CLIPX_0_CLIP0_MIN                             1:0 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP0_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP0_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP0_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP0_MAX                             3:2 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP0_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP0_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP0_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP1_MIN                             5:4 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP1_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP1_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP1_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP1_MAX                             7:6 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP1_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP1_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP1_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP2_MIN                             9:8 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP2_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP2_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP2_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP2_MAX                           11:10 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP2_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP2_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP2_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP3_MIN                           13:12 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP3_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP3_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP3_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP3_MAX                           15:14 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP3_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP3_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP3_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP4_MIN                           17:16 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP4_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP4_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP4_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP4_MAX                           19:18 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP4_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP4_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP4_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP5_MIN                           21:20 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP5_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP5_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP5_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP5_MAX                           23:22 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP5_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP5_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP5_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP6_MIN                           25:24 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP6_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP6_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP6_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP6_MAX                           27:26 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP6_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP6_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP6_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP7_MIN                           29:28 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP7_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP7_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP7_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP7_MAX                           31:30 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP7_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP7_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP7_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1                                0x00400528 /* RW-4R */
#define NV_PGRAPH_CLIPX_1_CLIP8_MIN                             1:0 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP8_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP8_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP8_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP8_MAX                             3:2 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP8_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP8_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP8_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP9_MIN                             5:4 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP9_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP9_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP9_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP9_MAX                             7:6 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP9_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP9_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP9_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP10_MIN                            9:8 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP10_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP10_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP10_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP10_MAX                          11:10 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP10_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP10_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP10_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP11_MIN                          13:12 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP11_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP11_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP11MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP11_MAX                          15:14 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP11_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP11_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP11_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP12_MIN                          17:16 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP12_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP12_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP12_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP12_MAX                          19:18 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP12_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP12_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP12_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP13_MIN                          21:20 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP13_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP13_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP13_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP13_MAX                          23:22 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP13_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP13_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP13_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP14_MIN                          25:24 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP14_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP14_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP14_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP14_MAX                          27:26 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP14_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP14_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP14_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP15_MIN                          29:28 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP15_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP15_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP15_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP15_MAX                          31:30 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP15_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP15_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP15_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0                                0x0040052c /* RW-4R */
#define NV_PGRAPH_CLIPY_0_CLIP0_MIN                             1:0 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP0_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP0_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP0_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP0_MAX                             3:2 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP0_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP0_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP0_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP1_MIN                             5:4 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP1_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP1_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP1_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP1_MAX                             7:6 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP1_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP1_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP1_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP2_MIN                             9:8 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP2_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP2_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP2_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP2_MAX                           11:10 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP2_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP2_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP2_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP3_MIN                           13:12 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP3_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP3_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP3_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP3_MAX                           15:14 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP3_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP3_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP3_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP4_MIN                           17:16 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP4_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP4_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP4_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP4_MAX                           19:18 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP4_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP4_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP4_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP5_MIN                           21:20 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP5_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP5_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP5_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP5_MAX                           23:22 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP5_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP5_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP5_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP6_MIN                           25:24 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP6_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP6_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP6_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP6_MAX                           27:26 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP6_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP6_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP6_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP7_MIN                           29:28 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP7_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP7_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP7_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP7_MAX                           31:30 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP7_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP7_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP7_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1                                0x00400530 /* RW-4R */
#define NV_PGRAPH_CLIPY_1_CLIP8_MIN                             1:0 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP8_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP8_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP8_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP8_MAX                             3:2 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP8_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP8_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP8_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP9_MIN                             5:4 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP9_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP9_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP9_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP9_MAX                             7:6 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP9_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP9_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP9_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP10_MIN                            9:8 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP10_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP10_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP10_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP10_MAX                          11:10 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP10_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP10_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP10_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP11_MIN                          13:12 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP11_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP11_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP11MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP11_MAX                          15:14 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP11_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP11_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP11_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP12_MIN                          17:16 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP12_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP12_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP12_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP12_MAX                          19:18 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP12_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP12_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP12_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP13_MIN                          21:20 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP13_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP13_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP13_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP13_MAX                          23:22 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP13_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP13_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP13_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP14_MIN                          25:24 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP14_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP14_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP14_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP14_MAX                          27:26 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP14_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP14_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP14_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP15_MIN                          29:28 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP15_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP15_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP15_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP15_MAX                          31:30 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP15_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP15_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP15_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_MISC24_0                               0x00400510 /* RW-4R */
#define NV_PGRAPH_MISC24_0_VALUE                               23:0 /* RWXSF */
#define NV_PGRAPH_MISC24_1                               0x00400570 /* RW-4R */
#define NV_PGRAPH_MISC24_1_VALUE                               23:0 /* RWXSF */
#define NV_PGRAPH_PASSTHRU                               0x0040054c /* RW-4R */
#define NV_PGRAPH_PASSTHRU_VALUE                               23:0 /* RWXSF */
#define NV_PGRAPH_ZFOG_RAM(i)                    (0x00400580+(i)*4) /* RW-4A */
#define NV_PGRAPH_ZFOG_RAM__SIZE_1                               16 /*       */
#define NV_PGRAPH_ZFOG_RAM_ZETA                                15:0 /* RWXUF */
#define NV_PGRAPH_ZFOG_RAM_FOG                                23:16 /* RWXUF */
#define NV_PGRAPH_D3D_XY                                 0x004005c0 /* RW-4R */
#define NV_PGRAPH_D3D_XY_X_VALUE                               15:0 /* RWXSF */
#define NV_PGRAPH_D3D_XY_Y_VALUE                              31:16 /* RWXSF */
#define NV_PGRAPH_D3D_UV                                 0x004005c4 /* RW-4R */
#define NV_PGRAPH_D3D_UV_U_VALUE                               15:0 /* RWXSF */
#define NV_PGRAPH_D3D_UV_V_VALUE                              31:16 /* RWXSF */
#define NV_PGRAPH_D3D_ZETA                               0x004005c8 /* RW-4R */
#define NV_PGRAPH_D3D_ZETA_VALUE                               15:0 /* RWXSF */
#define NV_PGRAPH_D3D_RGB                                0x004005cc /* RW-4R */
#define NV_PGRAPH_D3D_RGB_VALUE                                15:0 /* RWXSF */
#define NV_PGRAPH_D3D_FOG                                0x004005d0 /* RW-4R */
#define NV_PGRAPH_D3D_FOG_I0                                    3:0 /* RWXSF */
#define NV_PGRAPH_D3D_FOG_I1                                    7:4 /* RWXSF */
#define NV_PGRAPH_D3D_FOG_I2                                   11:8 /* RWXSF */
#define NV_PGRAPH_D3D_FOG_I3                                  15:12 /* RWXSF */
#define NV_PGRAPH_D3D_FOG_I4                                  19:16 /* RWXSF */
#define NV_PGRAPH_D3D_FOG_I5                                  23:20 /* RWXSF */
#define NV_PGRAPH_D3D_FOG_FOG_VALUE                           31:24 /* RWXSF */
#define NV_PGRAPH_D3D_M                                  0x004005d4 /* RW-4R */
#define NV_PGRAPH_D3D_M_VALUE                                  31:0 /* RWXSF */
#define NV_PGRAPH_DMA_INTR_0                             0x00401100 /* RW-4R */
#define NV_PGRAPH_DMA_INTR_0_INSTANCE                           0:0 /* RWXVF */
#define NV_PGRAPH_DMA_INTR_0_INSTANCE_NOT_PENDING        0x00000000 /* R---V */
#define NV_PGRAPH_DMA_INTR_0_INSTANCE_PENDING            0x00000001 /* R---V */
#define NV_PGRAPH_DMA_INTR_0_INSTANCE_RESET              0x00000001 /* -W--V */
#define NV_PGRAPH_DMA_INTR_0_PRESENT                            4:4 /* RWXVF */
#define NV_PGRAPH_DMA_INTR_0_PRESENT_NOT_PENDING         0x00000000 /* R---V */
#define NV_PGRAPH_DMA_INTR_0_PRESENT_PENDING             0x00000001 /* R---V */
#define NV_PGRAPH_DMA_INTR_0_PRESENT_RESET               0x00000001 /* -W--V */
#define NV_PGRAPH_DMA_INTR_0_PROTECTION                         8:8 /* RWXVF */
#define NV_PGRAPH_DMA_INTR_0_PROTECTION_NOT_PENDING      0x00000000 /* R---V */
#define NV_PGRAPH_DMA_INTR_0_PROTECTION_PENDING          0x00000001 /* R---V */
#define NV_PGRAPH_DMA_INTR_0_PROTECTION_RESET            0x00000001 /* -W--V */
#define NV_PGRAPH_DMA_INTR_0_LINEAR                           12:12 /* RWXVF */
#define NV_PGRAPH_DMA_INTR_0_LINEAR_NOT_PENDING          0x00000000 /* R---V */
#define NV_PGRAPH_DMA_INTR_0_LINEAR_PENDING              0x00000001 /* R---V */
#define NV_PGRAPH_DMA_INTR_0_LINEAR_RESET                0x00000001 /* -W--V */
#define NV_PGRAPH_DMA_INTR_0_NOTIFY                           16:16 /* RWXVF */
#define NV_PGRAPH_DMA_INTR_0_NOTIFY_NOT_PENDING          0x00000000 /* R---V */
#define NV_PGRAPH_DMA_INTR_0_NOTIFY_PENDING              0x00000001 /* R---V */
#define NV_PGRAPH_DMA_INTR_0_NOTIFY_RESET                0x00000001 /* -W--V */
#define NV_PGRAPH_DMA_INTR_EN_0                          0x00401140 /* RW-4R */
#define NV_PGRAPH_DMA_INTR_EN_0_INSTANCE                        0:0 /* RWIVF */
#define NV_PGRAPH_DMA_INTR_EN_0_INSTANCE_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_DMA_INTR_EN_0_INSTANCE_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_INTR_EN_0_PRESENT                         4:4 /* RWIVF */
#define NV_PGRAPH_DMA_INTR_EN_0_PRESENT_DISABLED         0x00000000 /* RWI-V */
#define NV_PGRAPH_DMA_INTR_EN_0_PRESENT_ENABLED          0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_INTR_EN_0_PROTECTION                      8:8 /* RWIVF */
#define NV_PGRAPH_DMA_INTR_EN_0_PROTECTION_DISABLED      0x00000000 /* RWI-V */
#define NV_PGRAPH_DMA_INTR_EN_0_PROTECTION_ENABLED       0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_INTR_EN_0_LINEAR                        12:12 /* RWIVF */
#define NV_PGRAPH_DMA_INTR_EN_0_LINEAR_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DMA_INTR_EN_0_LINEAR_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_INTR_EN_0_NOTIFY                        16:16 /* RWIVF */
#define NV_PGRAPH_DMA_INTR_EN_0_NOTIFY_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DMA_INTR_EN_0_NOTIFY_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_ACCESS                             0x00401200 /* -W-4R */
#define NV_PGRAPH_DMA_PTE_ACCESS_PTE                            0:0 /* -W-VF */
#define NV_PGRAPH_DMA_PTE_ACCESS_PTE_ENABLE              0x00000001 /* -W--V */
#define NV_PGRAPH_DMA_CONTROL                            0x00401210 /* RW-4R */
#define NV_PGRAPH_DMA_CONTROL_ADJUST                           11:0 /* RWXUF */
#define NV_PGRAPH_DMA_CONTROL_PAGE_TABLE                      16:16 /* RWXVF */
#define NV_PGRAPH_DMA_CONTROL_PAGE_TABLE_NOT_PRESENT     0x00000000 /* RW--V */
#define NV_PGRAPH_DMA_CONTROL_PAGE_TABLE_PRESENT         0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_CONTROL_TARGET_NODE                     25:24 /* RWXUF */
#define NV_PGRAPH_DMA_CONTROL_TARGET_NODE_NVM            0x00000000 /* RW--V */
#define NV_PGRAPH_DMA_CONTROL_TARGET_NODE_CART           0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_CONTROL_TARGET_NODE_PCI            0x00000002 /* RW--V */
#define NV_PGRAPH_DMA_CONTROL_TARGET_NODE_AGP            0x00000003 /* RW--V */
#define NV_PGRAPH_DMA_LIMIT                              0x00401220 /* RW-4R */
#define NV_PGRAPH_DMA_LIMIT_OFFSET                             31:0 /* RWXUF */
#define NV_PGRAPH_DMA_TLB_PTE                            0x00401230 /* RW-4R */
#define NV_PGRAPH_DMA_TLB_PTE_PAGE                              0:0 /* RWXVF */
#define NV_PGRAPH_DMA_TLB_PTE_PAGE_NOT_PRESENT           0x00000000 /* RW--V */
#define NV_PGRAPH_DMA_TLB_PTE_PAGE_PRESENT               0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_TLB_PTE_ACCESS                            1:1 /* RWXVF */
#define NV_PGRAPH_DMA_TLB_PTE_ACCESS_READ_ONLY           0x00000000 /* RW--V */
#define NV_PGRAPH_DMA_TLB_PTE_ACCESS_READ_WRITE          0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_TLB_PTE_FRAME_ADDRESS                   31:12 /* RWXUF */
#define NV_PGRAPH_DMA_TLB_TAG                            0x00401240 /* RW-4R */
#define NV_PGRAPH_DMA_TLB_TAG_ADDRESS                         31:12 /* RWXUF */
#define NV_PGRAPH_DMA_ADJ_OFFSET                         0x00401250 /* RW-4R */
#define NV_PGRAPH_DMA_ADJ_OFFSET_VALUE                         31:0 /* RWXUF */
#define NV_PGRAPH_DMA_OFFSET                             0x00401260 /* RW-4R */
#define NV_PGRAPH_DMA_OFFSET_VALUE                             31:0 /* RW-UF */
#define NV_PGRAPH_DMA_SIZE                               0x00401270 /* RW-4R */
#define NV_PGRAPH_DMA_SIZE_VALUE                               21:0 /* RW-UF */
#define NV_PGRAPH_DMA_XLATE_INST                         0x00401280 /* RW-4R */
#define NV_PGRAPH_DMA_XLATE_INST_VALUE                         15:0 /* RWXUF */
#define NV_PGRAPH_DMA_Y_SIZE                             0x00401290 /* RW-4R */
#define NV_PGRAPH_DMA_Y_SIZE_VALUE                             10:0 /* RW-UF */
#define NV_PGRAPH_DMA_LINEAR_LIMIT                       0x00401400 /* RW-4R */
#define NV_PGRAPH_DMA_LINEAR_LIMIT_VALUE                       22:0 /* RWXUF */
#define NV_PGRAPH_DMA_START(i)                  (0x00401800+(i)*16) /* RW-4A */
#define NV_PGRAPH_DMA_START__SIZE_1                               3 /*       */
#define NV_PGRAPH_DMA_START_VALUE                              31:0 /* RWXUF */
#define NV_PGRAPH_DMA_PITCH                              0x00401830 /* RW-4R */
#define NV_PGRAPH_DMA_PITCH_0                                  15:0 /* RWXS4 */
#define NV_PGRAPH_DMA_PITCH_1                                 31:16 /* RWXS4 */
#define NV_PGRAPH_DMA_FORMAT                             0x00401840 /* RW-4R */
#define NV_PGRAPH_DMA_FORMAT_SRC                                2:0 /* RWXS4 */
#define NV_PGRAPH_DMA_FORMAT_SRC_INC_1                   0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_FORMAT_SRC_INC_2                   0x00000002 /* RW--V */
#define NV_PGRAPH_DMA_FORMAT_SRC_INC_4                   0x00000004 /* RW--V */
#define NV_PGRAPH_DMA_FORMAT_DST                               10:8 /* RWXS4 */
#define NV_PGRAPH_DMA_FORMAT_DST_INC_1                   0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_FORMAT_DST_INC_2                   0x00000002 /* RW--V */
#define NV_PGRAPH_DMA_FORMAT_DST_INC_4                   0x00000004 /* RW--V */
#define NV_PGRAPH_DMA_MTMF_NOTIFY                        0x00401820 /* RW-4R */
#define NV_PGRAPH_DMA_MTMF_NOTIFY_TYPE                         31:0 /* RWIVF */
#define NV_PGRAPH_DMA_MTMF_NOTIFY_TYPE_HW                0x00000000 /* RWI-V */
/* dev_video.ref */
#define NV_PVIDEO                             0x006802FF:0x00680000 /* RW--D */
#define NV_PVIDEO_INTR_0                                 0x00680100 /* RWI4R */
#define NV_PVIDEO_INTR_0_NOTIFY                                 0:0 /* RWIVF */
#define NV_PVIDEO_INTR_0_NOTIFY_NOT_PENDING              0x00000000 /* R-I-V */
#define NV_PVIDEO_INTR_0_NOTIFY_PENDING                  0x00000001 /* R---V */
#define NV_PVIDEO_INTR_0_NOTIFY_RESET                    0x00000001 /* -W--V */
#define NV_PVIDEO_INTR_EN_0                              0x00680140 /* RWI4R */
#define NV_PVIDEO_INTR_EN_0_NOTIFY                              0:0 /* RWIVF */
#define NV_PVIDEO_INTR_EN_0_NOTIFY_DISABLED              0x00000000 /* RWI-V */
#define NV_PVIDEO_INTR_EN_0_NOTIFY_ENABLED               0x00000001 /* RW--V */
#define NV_PVIDEO_STEP_SIZE                              0x00680200 /* RW-4R */
#define NV_PVIDEO_STEP_SIZE_X                                  11:0 /* RWXVF */
#define NV_PVIDEO_STEP_SIZE_Y                                 27:16 /* RWXVF */
#define NV_PVIDEO_CONTROL_Y                              0x00680204 /* RW-4R */
#define NV_PVIDEO_CONTROL_Y_BLUR                                0:0 /* RW--F */
#define NV_PVIDEO_CONTROL_Y_BLUR_OFF                     0x00000000 /* RW--V */
#define NV_PVIDEO_CONTROL_Y_BLUR_ON                      0x00000001 /* RW--V */
#define NV_PVIDEO_CONTROL_Y_LINE                                4:4 /* RW--F */
#define NV_PVIDEO_CONTROL_Y_LINE_HALF                    0x00000000 /* RW--V */
#define NV_PVIDEO_CONTROL_Y_LINE_FULL                    0x00000001 /* RW--V */
#define NV_PVIDEO_CONTROL_X                              0x00680208 /* RW-4R */
#define NV_PVIDEO_CONTROL_X_WEIGHT                              0:0 /* RW--F */
#define NV_PVIDEO_CONTROL_X_WEIGHT_LIGHT                 0x00000000 /* RW--V */
#define NV_PVIDEO_CONTROL_X_WEIGHT_HEAVY                 0x00000001 /* RW--V */
#define NV_PVIDEO_CONTROL_X_SHARPENING                          4:4 /* RW--F */
#define NV_PVIDEO_CONTROL_X_SHARPENING_OFF               0x00000000 /* RW--V */
#define NV_PVIDEO_CONTROL_X_SHARPENING_ON                0x00000001 /* RW--V */
#define NV_PVIDEO_CONTROL_X_SMOOTHING                           8:8 /* RW--F */
#define NV_PVIDEO_CONTROL_X_SMOOTHING_OFF                0x00000000 /* RW--V */
#define NV_PVIDEO_CONTROL_X_SMOOTHING_ON                 0x00000001 /* RW--V */
#define NV_PVIDEO_BUFF0_START                            0x0068020c /* RW-4R */
#define NV_PVIDEO_BUFF0_START_ADDRESS                          22:2 /* RW-UF */
#define NV_PVIDEO_BUFF1_START                            0x00680210 /* RW-4R */
#define NV_PVIDEO_BUFF1_START_ADDRESS                          22:2 /* RW-UF */
#define NV_PVIDEO_BUFF0_PITCH                            0x00680214 /* RW-4R */
#define NV_PVIDEO_BUFF0_PITCH_LENGTH                           13:4 /* RW-UF */
#define NV_PVIDEO_BUFF1_PITCH                            0x00680218 /* RW-4R */
#define NV_PVIDEO_BUFF1_PITCH_LENGTH                           13:4 /* RW-UF */
#define NV_PVIDEO_BUFF0_OFFSET                           0x0068021c /* RW-4R */
#define NV_PVIDEO_BUFF0_OFFSET_Y                                5:4 /* RW--F */
#define NV_PVIDEO_BUFF0_OFFSET_Y_OFF                     0x00000000 /* RW--V */
#define NV_PVIDEO_BUFF0_OFFSET_Y_QUARTER                 0x00000001 /* RW--V */
#define NV_PVIDEO_BUFF0_OFFSET_Y_HALF                    0x00000002 /* RW--V */
#define NV_PVIDEO_BUFF1_OFFSET                           0x00680220 /* RW-4R */
#define NV_PVIDEO_BUFF1_OFFSET_Y                                5:4 /* RW--F */
#define NV_PVIDEO_BUFF1_OFFSET_Y_OFF                     0x00000000 /* RW--V */
#define NV_PVIDEO_BUFF1_OFFSET_Y_QUARTER                 0x00000001 /* RW--V */
#define NV_PVIDEO_BUFF1_OFFSET_Y_HALF                    0x00000002 /* RW--V */
#define NV_PVIDEO_OE_STATE                               0x00680224 /* RW-4R */
#define NV_PVIDEO_OE_STATE_BUFF0_INTR_NOTIFY                    0:0 /* RWXVF */
#define NV_PVIDEO_OE_STATE_BUFF1_INTR_NOTIFY                    4:4 /* RWXVF */
#define NV_PVIDEO_OE_STATE_BUFF0_ERROR                          8:8 /* RWXVF */
#define NV_PVIDEO_OE_STATE_BUFF1_ERROR                        12:12 /* RWXVF */
#define NV_PVIDEO_OE_STATE_BUFF0_IN_USE                       16:16 /* RWXVF */
#define NV_PVIDEO_OE_STATE_BUFF1_IN_USE                       20:20 /* RWXVF */
#define NV_PVIDEO_OE_STATE_CURRENT_BUFFER                     24:24 /* RWXVF */
#define NV_PVIDEO_OE_STATE_CURRENT_BUFFER_0              0x00000000 /* RW--V */
#define NV_PVIDEO_OE_STATE_CURRENT_BUFFER_1              0x00000001 /* RW--V */
#define NV_PVIDEO_SU_STATE                               0x00680228 /* RW-4R */
#define NV_PVIDEO_SU_STATE_BUFF0_IN_USE                       16:16 /* RWXVF */
#define NV_PVIDEO_SU_STATE_BUFF1_IN_USE                       20:20 /* RWXVF */
#define NV_PVIDEO_RM_STATE                               0x0068022c /* RW-4R */
#define NV_PVIDEO_RM_STATE_BUFF0_INTR_NOTIFY                    0:0 /* RWXVF */
#define NV_PVIDEO_RM_STATE_BUFF1_INTR_NOTIFY                    4:4 /* RWXVF */
#define NV_PVIDEO_WINDOW_START                           0x00680230 /* RW-4R */
#define NV_PVIDEO_WINDOW_START_X                               10:0 /* RWXUF */
#define NV_PVIDEO_WINDOW_START_Y                              26:16 /* RWXUF */
#define NV_PVIDEO_WINDOW_SIZE                            0x00680234 /* RW-4R */
#define NV_PVIDEO_WINDOW_SIZE_X                                10:0 /* RWXUF */
#define NV_PVIDEO_WINDOW_SIZE_Y                               26:16 /* RWXUF */
#define NV_PVIDEO_FIFO_THRES                             0x00680238 /* RW-4R */
#define NV_PVIDEO_FIFO_THRES_SIZE                               6:3 /* RW--F */
#define NV_PVIDEO_FIFO_BURST                             0x0068023c /* RW-4R */
#define NV_PVIDEO_FIFO_BURST_LENGTH                             1:0 /* RW--F */
#define NV_PVIDEO_FIFO_BURST_LENGTH_32                   0x00000001 /* RW--V */
#define NV_PVIDEO_FIFO_BURST_LENGTH_64                   0x00000002 /* RW--V */
#define NV_PVIDEO_FIFO_BURST_LENGTH_128                  0x00000003 /* RW--V */
#define NV_PVIDEO_KEY                                    0x00680240 /* RW-4R */
#define NV_PVIDEO_KEY_INDEX                                     7:0 /* RW-VF */
#define NV_PVIDEO_KEY_565                                      15:0 /* RW-VF */
#define NV_PVIDEO_KEY_555                                      14:0 /* RW-VF */
#define NV_PVIDEO_KEY_888                                      23:0 /* RW-VF */
#define NV_PVIDEO_KEY_PACK                                    31:24 /* RW-VF */
#define NV_PVIDEO_OVERLAY                                0x00680244 /* RWI4R */
#define NV_PVIDEO_OVERLAY_VIDEO                                 0:0 /* RWI-F */
#define NV_PVIDEO_OVERLAY_VIDEO_OFF                      0x00000000 /* RWI-V */
#define NV_PVIDEO_OVERLAY_VIDEO_ON                       0x00000001 /* RW--V */
#define NV_PVIDEO_OVERLAY_KEY                                   4:4 /* RW--F */
#define NV_PVIDEO_OVERLAY_KEY_OFF                        0x00000000 /* RW--V */
#define NV_PVIDEO_OVERLAY_KEY_ON                         0x00000001 /* RW--V */
#define NV_PVIDEO_OVERLAY_FORMAT                                8:8 /* RW--F */
#define NV_PVIDEO_OVERLAY_FORMAT_CCIR                    0x00000000 /* RW--V */
#define NV_PVIDEO_OVERLAY_FORMAT_YUY2                    0x00000001 /* RW--V */
#define NV_PVIDEO_RED_CSC                                0x00680280 /* RW-4R */
#define NV_PVIDEO_RED_CSC_OFFSET                                7:0 /* RWX-F */
#define NV_PVIDEO_GREEN_CSC                              0x00680284 /* RW-4R */
#define NV_PVIDEO_GREEN_CSC_OFFSET                              7:0 /* RWX-F */
#define NV_PVIDEO_BLUE_CSC                               0x00680288 /* RW-4R */
#define NV_PVIDEO_BLUE_CSC_OFFSET                               7:0 /* RWX-F */
#define NV_PVIDEO_CSC_ADJUST                             0x0068028c /* RW-4R */
#define NV_PVIDEO_CSC_ADJUST_B_FLAG                             0:0 /* RW--F */
#define NV_PVIDEO_CSC_ADJUST_B_FLAG_OFF                  0x00000000 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_B_FLAG_ON                   0x00000001 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_G_FLAG                             4:4 /* RW--F */
#define NV_PVIDEO_CSC_ADJUST_G_FLAG_OFF                  0x00000000 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_G_FLAG_ON                   0x00000001 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_R_FLAG                             8:8 /* RW--F */
#define NV_PVIDEO_CSC_ADJUST_R_FLAG_OFF                  0x00000000 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_R_FLAG_ON                   0x00000001 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_L_FLAG                           12:12 /* RW--F */
#define NV_PVIDEO_CSC_ADJUST_L_FLAG_OFF                  0x00000000 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_L_FLAG_ON                   0x00000001 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_CHROMA                           16:16 /* RW--F */
#define NV_PVIDEO_CSC_ADJUST_CHROMA_OFF                  0x00000000 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_CHROMA_ON                   0x00000001 /* RW--V */
/* vga.ref */
#define NV_PRMCIO                             0x00601FFF:0x00601000 /* RW--D */
#define NV_PRMCIO_INP0                                   0x006013c2 /* R--1R */
#define NV_PRMCIO_INP0__MONO                             0x006013ba /* R--1R */
#define NV_PRMCIO_INP0__COLOR                            0x006013da /* R--1R */
#define NV_PRMCIO_INP0__READ_MONO                        0x006013ca /* R--1R */
#define NV_PRMCIO_INP0__WRITE_MONO                       0x006013ba /* -W-1R */
#define NV_PRMCIO_INP0__WRITE_COLOR                      0x006013da /* -W-1R */
#define NV_PRMCIO_ARX                                    0x006013c0 /* RW-1R */
#define NV_PRMCIO_AR_PALETTE__WRITE                      0x006013c0 /* -W-1R */
#define NV_PRMCIO_AR_PALETTE__READ                       0x006013c1 /* R--1R */
#define NV_PRMCIO_AR_MODE__WRITE                         0x006013c0 /* -W-1R */
#define NV_PRMCIO_AR_MODE__READ                          0x006013c1 /* R--1R */
#define NV_PRMCIO_AR_MODE_INDEX                          0x00000010 /*       */
#define NV_PRMCIO_AR_OSCAN__WRITE                        0x006013c0 /* -W-1R */
#define NV_PRMCIO_AR_OSCAN__READ                         0x006013c1 /* R--1R */
#define NV_PRMCIO_AR_OSCAN_INDEX                         0x00000011 /*       */
#define NV_PRMCIO_AR_PLANE__WRITE                        0x006013c0 /* -W-1R */
#define NV_PRMCIO_AR_PLANE__READ                         0x006013c1 /* R--1R */
#define NV_PRMCIO_AR_PLANE_INDEX                         0x00000012 /*       */
#define NV_PRMCIO_AR_HPP__WRITE                          0x006013c0 /* -W-1R */
#define NV_PRMCIO_AR_HPP__READ                           0x006013c1 /* R--1R */
#define NV_PRMCIO_AR_HPP_INDEX                           0x00000013 /*       */
#define NV_PRMCIO_AR_CSEL__WRITE                         0x006013c0 /* -W-1R */
#define NV_PRMCIO_AR_CSEL__READ                          0x006013c1 /* R--1R */
#define NV_PRMCIO_AR_CSEL_INDEX                          0x00000014 /*       */
#define NV_PRMCIO_CRX__MONO                              0x006013b4 /* RW-1R */
#define NV_PRMCIO_CRX__COLOR                             0x006013d4 /* RW-1R */
#define NV_PRMCIO_CR__MONO                               0x006013b5 /* RW-1R */
#define NV_PRMCIO_CR__COLOR                              0x006013d5 /* RW-1R */
#define NV_PRMCIO_CRE__MONO                              0x006013b5 /* RW-1R */
#define NV_PRMCIO_CRE__COLOR                             0x006013d5 /* RW-1R */
/* vga.ref */
#define NV_CIO                                          0x3DF:0x3B0 /* ----- */
#define NV_CIO_INP0                                      0x000003c2 /* R--1R */
#define NV_CIO_INP0__MONO                                0x000003ba /* R--1R */
#define NV_CIO_INP0__COLOR                               0x000003da /* R--1R */
#define NV_CIO_INP0__READ_MONO                           0x000003ca /* R--1R */
#define NV_CIO_INP0__WRITE_MONO                          0x000003ba /* -W-1R */
#define NV_CIO_INP0__WRITE_COLOR                         0x000003da /* -W-1R */
#define NV_CIO_ARX                                       0x000003c0 /* RW-1R */
#define NV_CIO_AR_PALETTE__WRITE                         0x000003c0 /* -W-1R */
#define NV_CIO_AR_PALETTE__READ                          0x000003c1 /* R--1R */
#define NV_CIO_AR_MODE__WRITE                            0x000003c0 /* -W-1R */
#define NV_CIO_AR_MODE__READ                             0x000003c1 /* R--1R */
#define NV_CIO_AR_MODE_INDEX                             0x00000010 /*       */
#define NV_CIO_AR_OSCAN__WRITE                           0x000003c0 /* -W-1R */
#define NV_CIO_AR_OSCAN__READ                            0x000003c1 /* R--1R */
#define NV_CIO_AR_OSCAN_INDEX                            0x00000011 /*       */
#define NV_CIO_AR_PLANE__WRITE                           0x000003c0 /* -W-1R */
#define NV_CIO_AR_PLANE__READ                            0x000003c1 /* R--1R */
#define NV_CIO_AR_PLANE_INDEX                            0x00000012 /*       */
#define NV_CIO_AR_HPP__WRITE                             0x000003c0 /* -W-1R */
#define NV_CIO_AR_HPP__READ                              0x000003c1 /* R--1R */
#define NV_CIO_AR_HPP_INDEX                              0x00000013 /*       */
#define NV_CIO_AR_CSEL__WRITE                            0x000003c0 /* -W-1R */
#define NV_CIO_AR_CSEL__READ                             0x000003c1 /* R--1R */
#define NV_CIO_AR_CSEL_INDEX                             0x00000014 /*       */
#define NV_CIO_CRX__MONO                                 0x000003b4 /* RW-1R */
#define NV_CIO_CRX__COLOR                                0x000003d4 /* RW-1R */
#define NV_CIO_CR__MONO                                  0x000003b5 /* RW-1R */
#define NV_CIO_CR__COLOR                                 0x000003d5 /* RW-1R */
#define NV_CIO_CR_HDT_INDEX                              0x00000000 /*       */
#define NV_CIO_CR_HDE_INDEX                              0x00000001 /*       */
#define NV_CIO_CR_HBS_INDEX                              0x00000002 /*       */
#define NV_CIO_CR_HBE_INDEX                              0x00000003 /*       */
#define NV_CIO_CR_HBE_4_0                                       4:0 /* RW--F */
#define NV_CIO_CR_HRS_INDEX                              0x00000004 /*       */
#define NV_CIO_CR_HRE_INDEX                              0x00000005 /*       */
#define NV_CIO_CR_HRE_HBE_5                                     7:7 /* RW--F */
#define NV_CIO_CR_HRE_4_0                                       4:0 /* RW--F */
#define NV_CIO_CR_VDT_INDEX                              0x00000006 /*       */
#define NV_CIO_CR_OVL_INDEX                              0x00000007 /*       */
#define NV_CIO_CR_OVL_VDE_8                                     1:1 /* RW--F */
#define NV_CIO_CR_OVL_VDE_9                                     6:6 /* RW--F */
#define NV_CIO_CR_OVL_VDT_8                                     0:0 /* RW--F */
#define NV_CIO_CR_OVL_VDT_9                                     5:5 /* RW--F */
#define NV_CIO_CR_OVL_VBS_8                                     3:3 /* RW--F */
#define NV_CIO_CR_OVL_VRS_8                                     2:2 /* RW--F */
#define NV_CIO_CR_OVL_VRS_9                                     7:7 /* RW--F */
#define NV_CIO_CR_RSAL_INDEX                             0x00000008 /*       */
#define NV_CIO_CR_RSAL_PANNING                                  6:5 /* RW--F */
#define NV_CIO_CR_CELL_HT_INDEX                          0x00000009 /*       */
#define NV_CIO_CR_CELL_HT_SCANDBL                               7:7 /* RW--F */
#define NV_CIO_CR_CELL_HT_VBS_9                                 5:5 /* RW--F */
#define NV_CIO_CR_CURS_ST_INDEX                          0x0000000A /*       */
#define NV_CIO_CR_CURS_END_INDEX                         0x0000000B /*       */
#define NV_CIO_CR_SA_HI_INDEX                            0x0000000C /*       */
#define NV_CIO_CR_SA_LO_INDEX                            0x0000000D /*       */
#define NV_CIO_CR_TCOFF_HI_INDEX                         0x0000000E /*       */
#define NV_CIO_CR_TCOFF_LO_INDEX                         0x0000000F /*       */
#define NV_CIO_CR_VRS_INDEX                              0x00000010 /*       */
#define NV_CIO_CR_VRE_INDEX                              0x00000011 /*       */
#define NV_CIO_CR_VRE_3_0                                       3:0 /* RW--F */
#define NV_CIO_CR_VDE_INDEX                              0x00000012 /*       */
#define NV_CIO_CR_OFFSET_INDEX                           0x00000013 /*       */
#define NV_CIO_CR_ULINE_INDEX                            0x00000014 /*       */
#define NV_CIO_CR_VBS_INDEX                              0x00000015 /*       */
#define NV_CIO_CR_VBE_INDEX                              0x00000016 /*       */
#define NV_CIO_CR_MODE_INDEX                             0x00000017 /*       */
#define NV_CIO_CR_LCOMP_INDEX                            0x00000018 /*       */
#define NV_CIO_CR_GDATA_INDEX                            0x00000022 /*       */
#define NV_CIO_CR_ARFF_INDEX                             0x00000024 /*       */
#define NV_CIO_CR_ARX_INDEX                              0x00000026 /*       */
#define NV_CIO_CRE__MONO                                 0x000003b5 /* RW-1R */
#define NV_CIO_CRE__COLOR                                0x000003d5 /* RW-1R */
#define NV_CIO_CRE_RPC0_INDEX                           0x00000019 /*       */
#define NV_CIO_CRE_RPC0_START                                   4:0 /* RW--F */
#define NV_CIO_CRE_RPC0_OFFSET_10_8                             7:5 /* RW--F */
#define NV_CIO_CRE_RPC1_INDEX                            0x0000001A /*       */
#define NV_CIO_CRE_RPC1_LARGE                                  2:2 /* RW--F */
#define NV_CIO_CRE_FF_INDEX                              0x0000001B /*       */
#define NV_CIO_CRE_FF_BURST                                     2:0 /* RW--F */
#define NV_CIO_CRE_FF_BURST_8                            0x00000000 /* RW--V */
#define NV_CIO_CRE_FF_BURST_32                           0x00000001 /* RW--V */
#define NV_CIO_CRE_FF_BURST_64                           0x00000002 /* RW--V */
#define NV_CIO_CRE_FF_BURST_128                          0x00000003 /* RW--V */
#define NV_CIO_CRE_FF_BURST_256                          0x00000004 /* RW--V */
#define NV_CIO_CRE_ENH_INDEX                             0x0000001C /*       */
#define NV_CIO_CRE_PAGE0_INDEX                           0x0000001D /*       */
#define NV_CIO_CRE_PAGE1_INDEX                           0x0000001E /*       */
#define NV_CIO_CRE_FFLWM__INDEX                          0x00000020 /*       */
#define NV_CIO_CRE_FFLWM_LWM                                    5:0 /* RW--F */
#define NV_CIO_CRE_LSR_INDEX                             0x00000025 /*       */
#define NV_CIO_CRE_LSR_FORMAT                                   7:6 /* RW--F */
#define NV_CIO_CRE_LSR_FORMAT_8BIT                       0x00000001 /* RW--V */
#define NV_CIO_CRE_LSR_FORMAT_555                        0x00000002 /* RW--V */
#define NV_CIO_CRE_LSR_FORMAT_565                        0x00000003 /* RW--V */
#define NV_CIO_CRE_LSR_VDE_10                                   1:1 /* RW--F */
#define NV_CIO_CRE_LSR_VDT_10                                   0:0 /* RW--F */
#define NV_CIO_CRE_LSR_HBE_6                                    4:4 /* RW--F */
#define NV_CIO_CRE_LSR_VBS_10                                   3:3 /* RW--F */
#define NV_CIO_CRE_LSR_VRS_10                                   2:2 /* RW--F */
#define NV_CIO_CRE_PIXEL_INDEX                           0x00000028 /*       */
#define NV_CIO_CRE_PIXEL_FORMAT                                 1:0 /* RW--F */
#define NV_CIO_CRE_PIXEL_FORMAT_VGA                      0x00000000 /* RW--V */
#define NV_CIO_CRE_PIXEL_FORMAT_8BPP                     0x00000001 /* RW--V */
#define NV_CIO_CRE_PIXEL_FORMAT_16BPP                    0x00000002 /* RW--V */
#define NV_CIO_CRE_PIXEL_FORMAT_32BPP                    0x00000003 /* RW--V */
#define NV_CIO_CRE_PIXEL_TILING                                 2:2 /* RW--F */
#define NV_CIO_CRE_DEC__INDEX                            0x00000029 /*       */
#define NV_CIO_CRE_OSCOL__INDEX                          0x0000002A /*       */
#define NV_CIO_CRE_SCRATCH0__INDEX                       0x0000002B /*       */
#define NV_CIO_CRE_SCRATCH1__INDEX                       0x0000002C /*       */
#define NV_CIO_CRE_HEB__INDEX                            0x0000002D /*       */
#define NV_CIO_CRE_HEB_ILC_8                                    4:4 /* RW--F */
#define NV_CIO_CRE_HEB_HRS_8                                    3:3 /* RW--F */
#define NV_CIO_CRE_HEB_HBS_8                                    2:2 /* RW--F */
#define NV_CIO_CRE_HEB_HDE_8                                    1:1 /* RW--F */
#define NV_CIO_CRE_HEB_HDT_8                                    0:0 /* RW--F */
#define NV_CIO_CRE_HCUR_ADDR0_INDEX                      0x00000030 /*       */
#define NV_CIO_CRE_HCUR_ADDR0_ADR                               6:0 /* RW--F */
#define NV_CIO_CRE_HCUR_ADDR1_INDEX                      0x00000031 /*       */
#define NV_CIO_CRE_HCUR_ADDR1_ADR                               7:3 /* RW--F */
#define NV_CIO_CRE_HCUR_ADDR1_CUR_DBL                           1:1 /* RW--F */
#define NV_CIO_CRE_HCUR_ADDR1_ENABLE                            0:0 /* RW--F */
#define NV_CIO_CRE_VID_END0__INDEX                       0x00000032 /*       */
#define NV_CIO_CRE_VID_END_7_0                                  7:0 /* RW--F */
#define NV_CIO_CRE_VID_END1__INDEX                       0x00000033 /*       */
#define NV_CIO_CRE_VID_END_ENABLE                               4:4 /* RW--F */
#define NV_CIO_CRE_VID_END_10_8                                 2:0 /* RW--F */
#define NV_CIO_CRE_RL0__INDEX                            0x00000034 /*       */
#define NV_CIO_CRE_RL1__INDEX                            0x00000035 /*       */
#define NV_CIO_CRE_RMA__INDEX                            0x00000038 /*       */
#define NV_CIO_CRE_ILACE__INDEX                          0x00000039 /*       */
#define NV_CIO_CRE_TREG__INDEX                           0x0000003D /*       */
#define NV_CIO_CRE_TREG_HCNT                                    6:6 /* RW--F */
#define NV_CIO_CRE_TREG_VCNT                                    4:4 /* RW--F */
#define NV_CIO_CRE_TREG_HCNT_INDEX                       0x00000000 /*       */
#define NV_CIO_CRE_TREG_VCNTA_INDEX                      0x00000006 /*       */
#define NV_CIO_CRE_TREG_VCNTB_INDEX                      0x00000007 /*       */
#define NV_CIO_CRE_DDC_STATUS__INDEX                     0x0000003E /*       */
#define NV_CIO_CRE_DDC_WR__INDEX                         0x0000003F /*       */
/* vga.ref */
#define NV_PRMVIO                             0x000C7FFF:0x000C0000 /* RW--D */
#define NV_PRMVIO_MBEN                                   0x000C0094 /* RW-1R */
#define NV_PRMVIO_ADDEN                                  0x000C46e8 /* RW-1R */
#define NV_PRMVIO_VSE1                                   0x000C0102 /* RW-1R */
#define NV_PRMVIO_VSE2                                   0x000C03c3 /* RW-1R */
#define NV_PRMVIO_MISC__READ                             0x000C03cc /* R--1R */
#define NV_PRMVIO_MISC__WRITE                            0x000C03c2 /* -W-1R */
#define NV_PRMVIO_SRX                                    0x000C03c4 /* RW-1R */
#define NV_PRMVIO_SR_RESET                               0x000C03c5 /* RW-1R */
#define NV_PRMVIO_SR_RESET_INDEX                         0x00000000 /*       */
#define NV_PRMVIO_SR_CLOCK                               0x000C03c5 /* RW-1R */
#define NV_PRMVIO_SR_CLOCK_INDEX                         0x00000001 /*       */
#define NV_PRMVIO_SR_PLANE_MASK                          0x000C03c5 /* RW-1R */
#define NV_PRMVIO_SR_PLANE_MASK_INDEX                    0x00000002 /*       */
#define NV_PRMVIO_SR_CHAR_MAP                            0x000C03c5 /* RW-1R */
#define NV_PRMVIO_SR_CHAR_MAP_INDEX                      0x00000003 /*       */
#define NV_PRMVIO_SR_MEM_MODE                            0x000C03c5 /* RW-1R */
#define NV_PRMVIO_SR_MEM_MODE_INDEX                      0x00000004 /*       */
#define NV_PRMVIO_SR_LOCK                                0x000C03c5 /* RW-1R */
#define NV_PRMVIO_SR_LOCK_INDEX                          0x00000006 /*       */
#define NV_PRMVIO_GRX                                    0x000C03ce /* RW-1R */
#define NV_PRMVIO_GX_SR                                  0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_SR_INDEX                            0x00000000 /*       */
#define NV_PRMVIO_GX_SREN                                0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_SREN_INDEX                          0x00000001 /*       */
#define NV_PRMVIO_GX_CCOMP                               0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_CCOMP_INDEX                         0x00000002 /*       */
#define NV_PRMVIO_GX_ROP                                 0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_ROP_INDEX                           0x00000003 /*       */
#define NV_PRMVIO_GX_READ_MAP                            0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_READ_MAP_INDEX                      0x00000004 /*       */
#define NV_PRMVIO_GX_MODE                                0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_MODE_INDEX                          0x00000005 /*       */
#define NV_PRMVIO_GX_MISC                                0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_MISC_INDEX                          0x00000006 /*       */
#define NV_PRMVIO_GX_DONT_CARE                           0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_DONT_CARE_INDEX                     0x00000007 /*       */
#define NV_PRMVIO_GX_BIT_MASK                            0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_BIT_MASK_INDEX                      0x00000008 /*       */
/* vga.ref */
#define NV_PRMVGA                             0x000BFFFF:0x000A0000 /* RW--D */
/* dev_media.ref */
#define NV_PME                                0x00200FFF:0x00200000 /* RW--D */
#define NV_PME_DEBUG_0                                   0x00200080 /* RWI4R */
#define NV_PME_DEBUG_0_DET_FIELD_SWITCH                         0:0 /* RWI-F */
#define NV_PME_DEBUG_0_DET_FIELD_SWITCH_DISABLED         0x00000000 /* RWI-V */
#define NV_PME_DEBUG_0_DET_FIELD_SWITCH_ENABLED          0x00000001 /* RW--V */
#define NV_PME_DEBUG_1                                   0x00200084 /* RWI4R */
#define NV_PME_DEBUG_1_SEL                                      1:0 /* RWI-F */
#define NV_PME_DEBUG_1_SEL_VIPCLK                        0x00000000 /* RWI-V */
#define NV_PME_DEBUG_1_SEL_MCLK                          0x00000001 /* RW--V */
#define NV_PME_DEBUG_1_SEL_GLOB                          0x00000002 /* RW--V */
#define NV_PME_DEBUG_1_VIPCLK_SEL                               6:4 /* RWI-F */
#define NV_PME_DEBUG_1_VIPCLK_SEL_DEFAULT                0x00000000 /* RWI-V */
#define NV_PME_DEBUG_1_MCLK_SEL                                 9:8 /* RWI-F */
#define NV_PME_DEBUG_1_MCLK_SEL_DEFAULT                  0x00000000 /* RWI-V */
#define NV_PME_INTR_0                                    0x00200100 /* RWI4R */
#define NV_PME_INTR_0_IMAGE_NOTIFY                              0:0 /* RWIVF */
#define NV_PME_INTR_0_IMAGE_NOTIFY_NOT_PENDING           0x00000000 /* R-I-V */
#define NV_PME_INTR_0_IMAGE_NOTIFY_PENDING               0x00000001 /* R---V */
#define NV_PME_INTR_0_IMAGE_NOTIFY_RESET                 0x00000001 /* -W--V */
#define NV_PME_INTR_0_VBI_NOTIFY                                4:4 /* RWIVF */
#define NV_PME_INTR_0_VBI_NOTIFY_NOT_PENDING             0x00000000 /* R-I-V */
#define NV_PME_INTR_0_VBI_NOTIFY_PENDING                 0x00000001 /* R---V */
#define NV_PME_INTR_0_VBI_NOTIFY_RESET                   0x00000001 /* -W--V */
#define NV_PME_INTR_0_VID_NOTIFY                                8:8 /* RWIVF */
#define NV_PME_INTR_0_VID_NOTIFY_NOT_PENDING             0x00000000 /* R-I-V */
#define NV_PME_INTR_0_VID_NOTIFY_PENDING                 0x00000001 /* R---V */
#define NV_PME_INTR_0_VID_NOTIFY_RESET                   0x00000001 /* -W--V */
#define NV_PME_INTR_0_AUD_NOTIFY                              12:12 /* RWIVF */
#define NV_PME_INTR_0_AUD_NOTIFY_NOT_PENDING             0x00000000 /* R-I-V */
#define NV_PME_INTR_0_AUD_NOTIFY_PENDING                 0x00000001 /* R---V */
#define NV_PME_INTR_0_AUD_NOTIFY_RESET                   0x00000001 /* -W--V */
#define NV_PME_INTR_0_VMI                                     16:16 /* RWIVF */
#define NV_PME_INTR_0_VMI_NOT_PENDING                    0x00000000 /* R-I-V */
#define NV_PME_INTR_0_VMI_PENDING                        0x00000001 /* R---V */
#define NV_PME_INTR_0_VMI_RESET                          0x00000001 /* -W--V */
#define NV_PME_INTR_EN_0                                 0x00200140 /* RWI4R */
#define NV_PME_INTR_EN_0_IMAGE_NOTIFY                           0:0 /* RWIVF */
#define NV_PME_INTR_EN_0_IMAGE_NOTIFY_DISABLED           0x00000000 /* RWI-V */
#define NV_PME_INTR_EN_0_IMAGE_NOTIFY_ENABLED            0x00000001 /* RW--V */
#define NV_PME_INTR_EN_0_VBI_NOTIFY                             4:4 /* RWIVF */
#define NV_PME_INTR_EN_0_VBI_NOTIFY_DISABLED             0x00000000 /* RWI-V */
#define NV_PME_INTR_EN_0_VBI_NOTIFY_ENABLED              0x00000001 /* RW--V */
#define NV_PME_INTR_EN_0_VID_NOTIFY                             8:8 /* RWIVF */
#define NV_PME_INTR_EN_0_VID_NOTIFY_DISABLED             0x00000000 /* RWI-V */
#define NV_PME_INTR_EN_0_VID_NOTIFY_ENABLED              0x00000001 /* RW--V */
#define NV_PME_INTR_EN_0_AUD_NOTIFY                           12:12 /* RWIVF */
#define NV_PME_INTR_EN_0_AUD_NOTIFY_DISABLED             0x00000000 /* RWI-V */
#define NV_PME_INTR_EN_0_AUD_NOTIFY_ENABLED              0x00000001 /* RW--V */
#define NV_PME_INTR_EN_0_VMI                                  16:16 /* RWIVF */
#define NV_PME_INTR_EN_0_VMI_DISABLED                    0x00000000 /* RWI-V */
#define NV_PME_INTR_EN_0_VMI_ENABLED                     0x00000001 /* RW--V */
#define NV_PME_CONFIG_0                                  0x00200200 /* RWI4R */
#define NV_PME_CONFIG_0_BUS_MODE                                1:0 /* RWIVF */
#define NV_PME_CONFIG_0_BUS_MODE_DISABLED                0x00000000 /* RWI-V */
#define NV_PME_CONFIG_0_BUS_MODE_VMI                     0x00000001 /* RW--V */
#define NV_PME_CONFIG_0_BUS_MODE_CCIR656                 0x00000002 /* RW--V */
#define NV_PME_CONFIG_0_IMAGE                                   4:4 /* RWIVF */
#define NV_PME_CONFIG_0_IMAGE_DISABLED                   0x00000000 /* RWI-V */
#define NV_PME_CONFIG_0_IMAGE_ENABLED                    0x00000001 /* RW--V */
#define NV_PME_CONFIG_0_VBI_MODE                                9:8 /* RWIVF */
#define NV_PME_CONFIG_0_VBI_MODE_DISABLED                0x00000000 /* RWI-V */
#define NV_PME_CONFIG_0_VBI_MODE_1                       0x00000001 /* RW--V */
#define NV_PME_CONFIG_0_VBI_MODE_2                       0x00000002 /* RW--V */
#define NV_PME_CONFIG_0_VID_CD                                12:12 /* RWIVF */
#define NV_PME_CONFIG_0_VID_CD_DISABLED                  0x00000000 /* RWI-V */
#define NV_PME_CONFIG_0_VID_CD_ENABLED                   0x00000001 /* RW--V */
#define NV_PME_CONFIG_0_AUD_CD                                16:16 /* RWIVF */
#define NV_PME_CONFIG_0_AUD_CD_DISABLED                  0x00000000 /* RWI-V */
#define NV_PME_CONFIG_0_AUD_CD_ENABLED                   0x00000001 /* RW--V */
#define NV_PME_CONFIG_1                                  0x00200204 /* RWI4R */
#define NV_PME_CONFIG_1_BUFFS                                   0:0 /* RWIVF */
#define NV_PME_CONFIG_1_BUFFS_PNVM                       0x00000000 /* RWI-V */
#define NV_PME_CONFIG_1_BUFFS_SYS                        0x00000001 /* RW--V */
#define NV_PME_CONFIG_1_HOST                                    4:4 /* RWIVF */
#define NV_PME_CONFIG_1_HOST_PCI                         0x00000000 /* RWI-V */
#define NV_PME_CONFIG_1_HOST_AGP                         0x00000001 /* RW--V */
#define NV_PME_VID_BUFF0_START_SYS                       0x00200300 /* RWI4R */ 
#define NV_PME_VID_BUFF0_START_SYS_ADDRESS                     31:4 /* RWXUF */
#define NV_PME_VID_BUFF1_START_SYS                       0x00200304 /* RWI4R */ 
#define NV_PME_VID_BUFF1_START_SYS_ADDRESS                     31:4 /* RWXUF */
#define NV_PME_VID_BUFF0_START_PNVM                      0x00200308 /* RWI4R */ 
#define NV_PME_VID_BUFF0_START_PNVM_ADDRESS                    22:4 /* RWXUF */
#define NV_PME_VID_BUFF1_START_PNVM                      0x0020030c /* RWI4R */ 
#define NV_PME_VID_BUFF1_START_PNVM_ADDRESS                    22:4 /* RWXUF */
#define NV_PME_VID_BUFF0_LENGTH                          0x00200310 /* RWI4R */ 
#define NV_PME_VID_BUFF0_LENGTH_BITS                          15:12 /* RWXUF */
#define NV_PME_VID_BUFF1_LENGTH                          0x00200314 /* RWI4R */ 
#define NV_PME_VID_BUFF1_LENGTH_BITS                          15:12 /* RWXUF */
#define NV_PME_VID_ME_STATE                              0x00200318 /* RW-4R */
#define NV_PME_VID_ME_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWIVF */
#define NV_PME_VID_ME_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
#define NV_PME_VID_ME_STATE_BUFF0_INTR_CHAINGAP                 8:8 /* RWXVF */
#define NV_PME_VID_ME_STATE_BUFF1_INTR_CHAINGAP               12:12 /* RWXVF */
#define NV_PME_VID_ME_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
#define NV_PME_VID_ME_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
#define NV_PME_VID_ME_STATE_CURRENT_BUFFER                    24:24 /* RWXVF */
#define NV_PME_VID_ME_STATE_CURRENT_BUFFER_0             0x00000000 /* RW--V */
#define NV_PME_VID_ME_STATE_CURRENT_BUFFER_1             0x00000001 /* RW--V */
#define NV_PME_VID_SU_STATE                              0x0020031c /* RW-4R */
#define NV_PME_VID_SU_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
#define NV_PME_VID_SU_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
#define NV_PME_VID_RM_STATE                              0x00200320 /* RW-4R */
#define NV_PME_VID_RM_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWXVF */
#define NV_PME_VID_RM_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
#define NV_PME_VID_RM_STATE_BUFF0_INTR_CHAINGAP                 8:8 /* RWXVF */
#define NV_PME_VID_RM_STATE_BUFF1_INTR_CHAINGAP               12:12 /* RWXVF */
#define NV_PME_VID_CURRENT                               0x00200324 /* RWI4R */ 
#define NV_PME_VID_CURRENT_POS                                 15:2 /* RWXUF */
#define NV_PME_AUD_BUFF0_START_SYS                       0x00200340 /* RWI4R */ 
#define NV_PME_AUD_BUFF0_START_SYS_ADDRESS                     31:4 /* RWXUF */
#define NV_PME_AUD_BUFF1_START_SYS                       0x00200344 /* RWI4R */ 
#define NV_PME_AUD_BUFF1_START_SYS_ADDRESS                     31:4 /* RWXUF */
#define NV_PME_AUD_BUFF0_START_PNVM                      0x00200348 /* RWI4R */ 
#define NV_PME_AUD_BUFF0_START_PNVM_ADDRESS                    22:4 /* RWXUF */
#define NV_PME_AUD_BUFF1_START_PNVM                      0x0020034c /* RWI4R */ 
#define NV_PME_AUD_BUFF1_START_PNVM_ADDRESS                    22:4 /* RWXUF */
#define NV_PME_AUD_BUFF0_LENGTH                          0x00200350 /* RWI4R */ 
#define NV_PME_AUD_BUFF0_LENGTH_BITS                          12:10 /* RWXUF */
#define NV_PME_AUD_BUFF1_LENGTH                          0x00200354 /* RWI4R */ 
#define NV_PME_AUD_BUFF1_LENGTH_BITS                          12:10 /* RWXUF */
#define NV_PME_AUD_ME_STATE                              0x00200358 /* RW-4R */
#define NV_PME_AUD_ME_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWIVF */
#define NV_PME_AUD_ME_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
#define NV_PME_AUD_ME_STATE_BUFF0_INTR_CHAINGAP                 8:8 /* RWXVF */
#define NV_PME_AUD_ME_STATE_BUFF1_INTR_CHAINGAP               12:12 /* RWXVF */
#define NV_PME_AUD_ME_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
#define NV_PME_AUD_ME_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
#define NV_PME_AUD_ME_STATE_CURRENT_BUFFER                    24:24 /* RWXVF */
#define NV_PME_AUD_ME_STATE_CURRENT_BUFFER_0             0x00000000 /* RW--V */
#define NV_PME_AUD_ME_STATE_CURRENT_BUFFER_1             0x00000001 /* RW--V */
#define NV_PME_AUD_SU_STATE                              0x0020035c /* RW-4R */
#define NV_PME_AUD_SU_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
#define NV_PME_AUD_SU_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
#define NV_PME_AUD_RM_STATE                              0x00200360 /* RW-4R */
#define NV_PME_AUD_RM_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWXVF */
#define NV_PME_AUD_RM_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
#define NV_PME_AUD_RM_STATE_BUFF0_INTR_CHAINGAP                 8:8 /* RWXVF */
#define NV_PME_AUD_RM_STATE_BUFF1_INTR_CHAINGAP               12:12 /* RWXVF */
#define NV_PME_AUD_CURRENT                               0x00200364 /* RWI4R */ 
#define NV_PME_AUD_CURRENT_POS                                 12:2 /* RWXUF */
#define NV_PME_VBI_BUFF0_START                           0x00200380 /* RWI4R */ 
#define NV_PME_VBI_BUFF0_START_ADDRESS                         22:4 /* RWXUF */
#define NV_PME_VBI_BUFF1_START                           0x00200384 /* RWI4R */ 
#define NV_PME_VBI_BUFF1_START_ADDRESS                         22:4 /* RWXUF */
#define NV_PME_VBI_BUFF0_PITCH                           0x00200388 /* RWI4R */ 
#define NV_PME_VBI_BUFF0_PITCH_VALUE                           13:4 /* RWXUF */
#define NV_PME_VBI_BUFF1_PITCH                           0x0020038c /* RWI4R */ 
#define NV_PME_VBI_BUFF1_PITCH_VALUE                           13:4 /* RWXUF */
#define NV_PME_VBI_BUFF0_LENGTH                          0x00200390 /* RWI4R */ 
#define NV_PME_VBI_BUFF0_LENGTH_BITS                           19:4 /* RWXUF */
#define NV_PME_VBI_BUFF1_LENGTH                          0x00200394 /* RWI4R */ 
#define NV_PME_VBI_BUFF1_LENGTH_BITS                           19:4 /* RWXUF */
#define NV_PME_VBI_ME_STATE                              0x00200398 /* RW-4R */
#define NV_PME_VBI_ME_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWXVF */
#define NV_PME_VBI_ME_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
#define NV_PME_VBI_ME_STATE_BUFF0_ERROR_CODE                   10:8 /* RWXVF */
#define NV_PME_VBI_ME_STATE_BUFF1_ERROR_CODE                  14:12 /* RWXVF */
#define NV_PME_VBI_ME_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
#define NV_PME_VBI_ME_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
#define NV_PME_VBI_ME_STATE_CURRENT_BUFFER                    24:24 /* RWXVF */
#define NV_PME_VBI_ME_STATE_CURRENT_BUFFER_0             0x00000000 /* RW--V */
#define NV_PME_VBI_ME_STATE_CURRENT_BUFFER_1             0x00000001 /* RW--V */
#define NV_PME_VBI_SU_STATE                              0x0020039c /* RW-4R */
#define NV_PME_VBI_SU_STATE_BUFF0_FIELD                         8:8 /* RWXVF */
#define NV_PME_VBI_SU_STATE_BUFF1_FIELD                       12:12 /* RWXVF */
#define NV_PME_VBI_SU_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
#define NV_PME_VBI_SU_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
#define NV_PME_VBI_RM_STATE                              0x002003a0 /* RW-4R */
#define NV_PME_VBI_RM_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWXVF */
#define NV_PME_VBI_RM_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
#define NV_PME_VBI                                       0x002003a4 /* RWI4R */
#define NV_PME_VBI_START_LINE                                   4:0 /* RWX-F */
#define NV_PME_VBI_NUM_LINES                                  20:16 /* RWX-F */
#define NV_PME_IMAGE_BUFF0_START                         0x00200400 /* RWI4R */ 
#define NV_PME_IMAGE_BUFF0_START_ADDRESS                       22:4 /* RWXUF */
#define NV_PME_IMAGE_BUFF1_START                         0x00200404 /* RWI4R */ 
#define NV_PME_IMAGE_BUFF1_START_ADDRESS                       22:4 /* RWXUF */
#define NV_PME_IMAGE_BUFF0_PITCH                         0x00200408 /* RWI4R */ 
#define NV_PME_IMAGE_BUFF0_PITCH_VALUE                         13:4 /* RWXUF */
#define NV_PME_IMAGE_BUFF1_PITCH                         0x0020040c /* RWI4R */ 
#define NV_PME_IMAGE_BUFF1_PITCH_VALUE                         13:4 /* RWXUF */
#define NV_PME_IMAGE_BUFF0_LENGTH                        0x00200410 /* RWI4R */ 
#define NV_PME_IMAGE_BUFF0_LENGTH_BITS                         19:4 /* RWXUF */
#define NV_PME_IMAGE_BUFF1_LENGTH                        0x00200414 /* RWI4R */ 
#define NV_PME_IMAGE_BUFF1_LENGTH_BITS                         19:4 /* RWXUF */
#define NV_PME_IMAGE_ME_STATE                            0x00200418 /* RW-4R */
#define NV_PME_IMAGE_ME_STATE_BUFF0_INTR_NOTIFY                 0:0 /* RWXVF */
#define NV_PME_IMAGE_ME_STATE_BUFF1_INTR_NOTIFY                 4:4 /* RWXVF */
#define NV_PME_IMAGE_ME_STATE_BUFF0_ERROR_CODE                 10:8 /* RWXVF */
#define NV_PME_IMAGE_ME_STATE_BUFF1_ERROR_CODE                14:12 /* RWXVF */
#define NV_PME_IMAGE_ME_STATE_BUFF0_IN_USE                    16:16 /* RWXVF */
#define NV_PME_IMAGE_ME_STATE_BUFF1_IN_USE                    20:20 /* RWXVF */
#define NV_PME_IMAGE_ME_STATE_CURRENT_BUFFER                  24:24 /* RWXVF */
#define NV_PME_IMAGE_ME_STATE_CURRENT_BUFFER_0           0x00000000 /* RW--V */
#define NV_PME_IMAGE_ME_STATE_CURRENT_BUFFER_1           0x00000001 /* RW--V */
#define NV_PME_IMAGE_SU_STATE                            0x0020041c /* RW-4R */
#define NV_PME_IMAGE_SU_STATE_BUFF0_FIELD                       8:8 /* RWXVF */
#define NV_PME_IMAGE_SU_STATE_BUFF1_FIELD                     12:12 /* RWXVF */
#define NV_PME_IMAGE_SU_STATE_BUFF0_IN_USE                    16:16 /* RWXVF */
#define NV_PME_IMAGE_SU_STATE_BUFF1_IN_USE                    20:20 /* RWXVF */
#define NV_PME_IMAGE_RM_STATE                            0x00200420 /* RW-4R */
#define NV_PME_IMAGE_RM_STATE_BUFF0_INTR_NOTIFY                 0:0 /* RWXVF */
#define NV_PME_IMAGE_RM_STATE_BUFF1_INTR_NOTIFY                 4:4 /* RWXVF */
#define NV_PME_IMAGE_BUFF0_SCALE_INCR                    0x00200424 /* RW-4R */
#define NV_PME_IMAGE_BUFF0_SCALE_INCR_Y                       26:16 /* RWXVF */
#define NV_PME_IMAGE_BUFF0_SCALE_INCR_X                        10:0 /* RWXVF */
#define NV_PME_IMAGE_BUFF1_SCALE_INCR                    0x00200428 /* RW-4R */
#define NV_PME_IMAGE_BUFF1_SCALE_INCR_Y                       26:16 /* RWXVF */
#define NV_PME_IMAGE_BUFF1_SCALE_INCR_X                        10:0 /* RWXVF */
#define NV_PME_IMAGE_Y_CROP                              0x0020042c /* RW-4R */
#define NV_PME_IMAGE_Y_CROP_STARTLINE                           8:0 /* RWXVF */
#define NV_PME_FIFO_LINE_START                           0x00200480 /* R--4R */
#define NV_PME_FIFO_LINE_START_ADDRESS                         20:4 /* R-XVF */
#define NV_PME_FIFO_CURRENT                              0x00200484 /* RWI4R */
#define NV_PME_FIFO_CURRENT_ADDRESS                            20:2 /* RWXVF */
#define NV_PME_VMI_POLL                                  0x00200488 /* R--4R */
#define NV_PME_VMI_POLL_UNCD                                    0:0 /* R-IVF */
#define NV_PME_VMI_POLL_UNCD_NOT_PENDING                 0x00000000 /* R-IVF */
#define NV_PME_VMI_POLL_UNCD_PENDING                     0x00000001 /* R--VF */
#define NV_PME_VMI_POLL_VIDCD                                   1:1 /* R-IVF */
#define NV_PME_VMI_POLL_VIDCD_NOT_PENDING                0x00000000 /* R-IVF */
#define NV_PME_VMI_POLL_VIDCD_PENDING                    0x00000001 /* R--VF */
#define NV_PME_VMI_POLL_AUDCD                                   2:2 /* R-IVF */
#define NV_PME_VMI_POLL_AUDCD_NOT_PENDING                0x00000000 /* R-IVF */
#define NV_PME_VMI_POLL_AUDCD_PENDING                    0x00000001 /* R--VF */
#define NV_PME_VMI_POLL_INT                                     3:3 /* R-IVF */
#define NV_PME_VMI_POLL_INT_NOT_PENDING                  0x00000000 /* R-IVF */
#define NV_PME_VMI_POLL_INT_PENDING                      0x00000001 /* R--VF */
#define NV_PME_VMI_POLL_CPURDREC                                4:4 /* R-IVF */
#define NV_PME_VMI_POLL_CPURDREC_NOT_PENDING             0x00000000 /* R-IVF */
#define NV_PME_VMI_POLL_CPURDREC_PENDING                 0x00000001 /* R--VF */
#define NV_PME_EXTERNAL(i)                       (0x00200600+(i)*4) /* RW-4A */
#define NV_PME_EXTERNAL_SIZE_1                                  256 /*       */  
#define NV_PME_EXTERNAL_DATA                                    7:0 /* RWXVF */
/* usr_beta_solid.ref */
#define NV_UBETA                              0x00411FFF:0x00410000 /* -W--D */
#define NV_UBETA_CTX_SWITCH                              0x00410000 /* -W-4R */
#define NV_UBETA_CTX_SWITCH_INSTANCE                           15:0 /* -W-UF */
#define NV_UBETA_CTX_SWITCH_CHID                              22:16 /* -W-UF */
#define NV_UBETA_CTX_SWITCH_VOLATILE                          31:31 /* -W-VF */
#define NV_UBETA_CTX_SWITCH_VOLATILE_IGNORE              0x00000000 /* -W--V */
#define NV_UBETA_CTX_SWITCH_VOLATILE_RESET               0x00000001 /* -W--V */
#define NV_UBETA_SET_NOTIFY                              0x00410104 /* -W-4R */
#define NV_UBETA_SET_NOTIFY_PARAMETER                          31:0 /* -W-VF */
#define NV_UBETA_SET_NOTIFY_PARAMETER_WRITE              0x00000000 /* -W--V */
#define NV_UBETA_SET_BETA1D31                            0x00410300 /* -W-4R */
#define NV_UBETA_SET_BETA1D31_VALUE_FRACTION                  30:21 /* -W-UF */
#define NV_UBETA_SET_BETA1D31_VALUE                           31:31 /* -W-SF */
/* usr_rop_solid.ref */
#define NV_UROP                               0x00421FFF:0x00420000 /* -W--D */
#define NV_UROP_CTX_SWITCH                               0x00420000 /* -W-4R */
#define NV_UROP_CTX_SWITCH_INSTANCE                            15:0 /* -W-UF */
#define NV_UROP_CTX_SWITCH_CHID                               22:16 /* -W-UF */
#define NV_UROP_CTX_SWITCH_VOLATILE                           31:31 /* -W-VF */
#define NV_UROP_CTX_SWITCH_VOLATILE_IGNORE               0x00000000 /* -W--V */
#define NV_UROP_CTX_SWITCH_VOLATILE_RESET                0x00000001 /* -W--V */
#define NV_UROP_SET_NOTIFY                               0x00420104 /* -W-4R */
#define NV_UROP_SET_NOTIFY_PARAMETER                           31:0 /* -W-VF */
#define NV_UROP_SET_NOTIFY_PARAMETER_WRITE               0x00000000 /* -W--V */
#define NV_UROP_SET_ROP                                  0x00420300 /* -W-4R */
#define NV_UROP_SET_ROP_VALUE                                   7:0 /* -W-VF */
/* usr_color_key.ref */
#define NV_UCHROMA                            0x00431FFF:0x00430000 /* -W--D */
#define NV_UCHROMA_CTX_SWITCH                            0x00430000 /* -W-4R */
#define NV_UCHROMA_CTX_SWITCH_INSTANCE                         15:0 /* -W-UF */
#define NV_UCHROMA_CTX_SWITCH_CHID                            22:16 /* -W-UF */
#define NV_UCHROMA_CTX_SWITCH_VOLATILE                        31:31 /* -W-VF */
#define NV_UCHROMA_CTX_SWITCH_VOLATILE_IGNORE            0x00000000 /* -W--V */
#define NV_UCHROMA_CTX_SWITCH_VOLATILE_RESET             0x00000001 /* -W--V */
#define NV_UCHROMA_SET_NOTIFY                            0x00430104 /* -W-4R */
#define NV_UCHROMA_SET_NOTIFY_PARAMETER                        31:0 /* -W-VF */
#define NV_UCHROMA_SET_NOTIFY_PARAMETER_WRITE            0x00000000 /* -W--V */
#define NV_UCHROMA_SET_COLOR                             0x00430304 /* -W-4R */
#define NV_UCHROMA_SET_COLOR_VALUE                             31:0 /* -W-VF */
/* usr_plane_switch.ref */
#define NV_UPLANE                             0x00441FFF:0x00440000 /* -W--D */
#define NV_UPLANE_CTX_SWITCH                             0x00440000 /* -W-4R */
#define NV_UPLANE_CTX_SWITCH_INSTANCE                          15:0 /* -W-UF */
#define NV_UPLANE_CTX_SWITCH_CHID                             22:16 /* -W-UF */
#define NV_UPLANE_CTX_SWITCH_VOLATILE                         31:31 /* -W-VF */
#define NV_UPLANE_CTX_SWITCH_VOLATILE_IGNORE             0x00000000 /* -W--V */
#define NV_UPLANE_CTX_SWITCH_VOLATILE_RESET              0x00000001 /* -W--V */
#define NV_UPLANE_SET_NOTIFY                             0x00440104 /* -W-4R */
#define NV_UPLANE_SET_NOTIFY_PARAMETER                         31:0 /* -W-VF */
#define NV_UPLANE_SET_NOTIFY_PARAMETER_WRITE             0x00000000 /* -W--V */
#define NV_UPLANE_SET_COLOR                              0x00440304 /* -W-4R */
#define NV_UPLANE_SET_COLOR_VALUE                              31:0 /* -W-VF */
/* usr_clipping.ref */
#define NV_UCLIP                              0x00451FFF:0x00450000 /* -W--D */
#define NV_UCLIP_CTX_SWITCH                              0x00450000 /* -W-4R */
#define NV_UCLIP_CTX_SWITCH_INSTANCE                           15:0 /* -W-UF */
#define NV_UCLIP_CTX_SWITCH_CHID                              22:16 /* -W-UF */
#define NV_UCLIP_CTX_SWITCH_VOLATILE                          31:31 /* -W-VF */
#define NV_UCLIP_CTX_SWITCH_VOLATILE_IGNORE              0x00000000 /* -W--V */
#define NV_UCLIP_CTX_SWITCH_VOLATILE_RESET               0x00000001 /* -W--V */
#define NV_UCLIP_SET_NOTIFY                              0x00450104 /* -W-4R */
#define NV_UCLIP_SET_NOTIFY_PARAMETER                          31:0 /* -W-VF */
#define NV_UCLIP_SET_NOTIFY_PARAMETER_WRITE              0x00000000 /* -W--V */
#define NV_UCLIP_SET_RECT_0                              0x00450300 /* -W-4R */
#define NV_UCLIP_SET_RECT_0_X                                  15:0 /* -W-SF */
#define NV_UCLIP_SET_RECT_0_Y                                 31:16 /* -W-SF */
#define NV_UCLIP_SET_RECT_1                              0x00450304 /* -W-4R */
#define NV_UCLIP_SET_RECT_1_WIDTH                              15:0 /* -W-UF */
#define NV_UCLIP_SET_RECT_1_HEIGHT                            31:16 /* -W-UF */
/* usr_d3d0_triangle_zeta.ref */
#define NV_UD3D0Z                             0x00571FFF:0x00570000 /* -W--D */
#define NV_UD3D0Z_CTX_SWITCH                             0x00570000 /* -W-4R */
#define NV_UD3D0Z_CTX_SWITCH_INSTANCE                          15:0 /* -W-UF */
#define NV_UD3D0Z_CTX_SWITCH_CHID                             22:16 /* -W-UF */
#define NV_UD3D0Z_CTX_SWITCH_VOLATILE                         31:31 /* -W-VF */
#define NV_UD3D0Z_CTX_SWITCH_VOLATILE_IGNORE             0x00000000 /* -W--V */
#define NV_UD3D0Z_CTX_SWITCH_VOLATILE_RESET              0x00000001 /* -W--V */
#define NV_UD3D0Z_SET_NOTIFY                             0x00570104 /* -W-4R */
#define NV_UD3D0Z_SET_NOTIFY_PARAMETER                         31:0 /* -W-VF */
#define NV_UD3D0Z_SET_NOTIFY_PARAMETER_WRITE             0x00000000 /* -W--V */
#define NV_UD3D0Z_TEXTURE_OFFSET                         0x00570304 /* -W-4R */
#define NV_UD3D0Z_TEXTURE_OFFSET_VALUE                         31:0 /* -W-UF */
#define NV_UD3D0Z_TEXTURE_FORMAT                         0x00570308 /* -W-4R */
#define NV_UD3D0Z_TEXTURE_FORMAT_COLOR_KEY_COLOR_MASK          15:0 /* -W-UF */
#define NV_UD3D0Z_TEXTURE_FORMAT_COLOR_KEY                    16:16 /* -W-UF */
#define NV_UD3D0Z_TEXTURE_FORMAT_COLOR_KEY_DISABLED      0x00000000 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_COLOR_KEY_ENABLED       0x00000001 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_COLOR_FORMAT                 21:20 /* -W-UF */
#define NV_UD3D0Z_TEXTURE_FORMAT_COLOR_FORMAT_A1R5G5B5   0x00000000 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_COLOR_FORMAT_X1R5G5B5   0x00000001 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_COLOR_FORMAT_A4R4G4B4   0x00000002 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_COLOR_FORMAT_R5G6B5     0x00000003 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN                     27:24 /* -W-UF */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_1X1            0x00000000 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_2X2            0x00000001 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_4X4            0x00000002 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_8X8            0x00000003 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_16X16          0x00000004 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_32X32          0x00000005 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_64X64          0x00000006 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_128X128        0x00000007 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_256X256        0x00000008 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_512X512        0x00000009 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_1024X1024      0x0000000a /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_2048X2048      0x0000000b /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX                     31:28 /* -W-UF */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_1X1            0x00000000 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_2X2            0x00000001 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_4X4            0x00000002 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_8X8            0x00000003 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_16X16          0x00000004 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_32X32          0x00000005 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_64X64          0x00000006 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_128X128        0x00000007 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_256X256        0x00000008 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_512X512        0x00000009 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_1024X1024      0x0000000a /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_2048X2048      0x0000000b /* -W-UV */
#define NV_UD3D0Z_FILTER                                 0x0057030C /* -W-4R */
#define NV_UD3D0Z_FILTER_SPREADX                                7:0 /* -W-UF */
#define NV_UD3D0Z_FILTER_SPREADY                               15:8 /* -W-UF */
#define NV_UD3D0Z_FILTER_MIPMAP                               23:16 /* -W-SF */
#define NV_UD3D0Z_FILTER_TURBO                                31:24 /* -W-SF */
#define NV_UD3D0Z_FOG_COLOR                              0x00570310 /* -W-4R */
#define NV_UD3D0Z_FOG_COLOR_BLU                                 7:0 /* -W-UF */
#define NV_UD3D0Z_FOG_COLOR_GRN                                15:8 /* -W-UF */
#define NV_UD3D0Z_FOG_COLOR_RED                               23:16 /* -W-UF */
#define NV_UD3D0Z_FOG_COLOR_VALUE                              31:0 /* -W-UF */
#define NV_UD3D0Z_CONTROL_OUT                            0x00570314 /* -W-4R */
#define NV_UD3D0Z_CONTROL_OUT_INTERPOLATOR                      1:0 /* -W-UF */
#define NV_UD3D0Z_CONTROL_OUT_INTERPOLATOR_ZOH           0x00000000 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_INTERPOLATOR_ZOH_MS        0x00000001 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_INTERPOLATOR_FOH           0x00000002 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_WRAP_U                            5:4 /* -W-UF */
#define NV_UD3D0Z_CONTROL_OUT_WRAP_U_CYLINDRICAL         0x00000000 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_WRAP_U_WRAP                0x00000001 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_WRAP_U_MIRROR              0x00000002 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_WRAP_U_CLAMP               0x00000003 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_WRAP_V                            7:6 /* -W-UF */
#define NV_UD3D0Z_CONTROL_OUT_WRAP_V_CYLINDRICAL         0x00000000 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_WRAP_V_WRAP                0x00000001 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_WRAP_V_MIRROR              0x00000002 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_WRAP_V_CLAMP               0x00000003 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_COLOR_FORMAT                      8:8 /* -W-UF */
#define NV_UD3D0Z_CONTROL_OUT_COLOR_FORMAT_LE_X8R8G8B8   0x00000000 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_COLOR_FORMAT_LE_A8R8G8B8   0x00000001 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_SRCCOLOR                        11:10 /* -W-UF */
#define NV_UD3D0Z_CONTROL_OUT_SRCCOLOR_NORMAL            0x00000000 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_SRCCOLOR_COLOR_INVERSE     0x00000001 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_SRCCOLOR_ALPHA_INVERSE     0x00000002 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_SRCCOLOR_ALPHA_ONE         0x00000003 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_CULLING                         13:12 /* -W-UF */
#define NV_UD3D0Z_CONTROL_OUT_CULLING_NONE               0x00000001 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_CULLING_CLOCKWISE          0x00000002 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_CULLING_COUNTERCLOCKWISE   0x00000003 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZBUFFER                         15:15 /* -W-UF */
#define NV_UD3D0Z_CONTROL_OUT_ZBUFFER_SCREEN             0x00000000 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZBUFFER_LINEAR             0x00000001 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE                    19:16 /* -W-UF */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_FALSE         0x00000001 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_LT            0x00000002 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_EQ            0x00000003 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_LE            0x00000004 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_GT            0x00000005 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_NE            0x00000006 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_GE            0x00000007 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_TRUE          0x00000008 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_WRITE                      22:20 /* -W-UF */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_WRITE_NEVER           0x00000000 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_WRITE_ALPHA           0x00000001 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_WRITE_ALPHA_ZETA      0x00000002 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_WRITE_ZETA            0x00000003 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_WRITE_ALWAYS          0x00000004 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_COLOR_WRITE                     26:24 /* -W-UF */
#define NV_UD3D0Z_CONTROL_OUT_COLOR_WRITE_NEVER          0x00000000 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_COLOR_WRITE_ALPHA          0x00000001 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_COLOR_WRITE_ALPHA_ZETA     0x00000002 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_COLOR_WRITE_ZETA           0x00000003 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_COLOR_WRITE_ALWAYS         0x00000004 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ROP                             28:28 /* -W-UF */
#define NV_UD3D0Z_CONTROL_OUT_ROP_BLEND_AND              0x00000000 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ROP_ADD_WITH_SATURATION    0x00000001 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_BLEND_BETA                      29:29 /* -W-UF */
#define NV_UD3D0Z_CONTROL_OUT_BLEND_BETA_SRCALPHA        0x00000000 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_BLEND_BETA_DESTCOLOR       0x00000001 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_BLEND_INPUT0                    30:30 /* -W-UF */
#define NV_UD3D0Z_CONTROL_OUT_BLEND_INPUT0_DESTCOLOR     0x00000000 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_BLEND_INPUT0_ZERO          0x00000001 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_BLEND_INPUT1                    31:31 /* -W-UF */
#define NV_UD3D0Z_CONTROL_OUT_BLEND_INPUT1_SRCCOLOR      0x00000000 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_BLEND_INPUT1_ZERO          0x00000001 /* -W-UV */
#define NV_UD3D0Z_ALPHA_CONTROL                          0x00570318 /* -W-4R */
#define NV_UD3D0Z_ALPHA_CONTROL_ALPHA_KEY                       7:0 /* -WXUF */
#define NV_UD3D0Z_ALPHA_CONTROL_ALPHA_COMPARE                  11:8 /* -WIUF */
#define NV_UD3D0Z_ALPHA_CONTROL_ALPHA_COMPARE_ILLEGAL    0x00000000 /* -W-UV */
#define NV_UD3D0Z_ALPHA_CONTROL_ALPHA_COMPARE_FALSE      0x00000001 /* -W-UV */
#define NV_UD3D0Z_ALPHA_CONTROL_ALPHA_COMPARE_LT         0x00000002 /* -W-UV */
#define NV_UD3D0Z_ALPHA_CONTROL_ALPHA_COMPARE_EQ         0x00000003 /* -W-UV */
#define NV_UD3D0Z_ALPHA_CONTROL_ALPHA_COMPARE_LE         0x00000004 /* -W-UV */
#define NV_UD3D0Z_ALPHA_CONTROL_ALPHA_COMPARE_GT         0x00000005 /* -W-UV */
#define NV_UD3D0Z_ALPHA_CONTROL_ALPHA_COMPARE_NE         0x00000006 /* -W-UV */
#define NV_UD3D0Z_ALPHA_CONTROL_ALPHA_COMPARE_GE         0x00000007 /* -W-UV */
#define NV_UD3D0Z_ALPHA_CONTROL_ALPHA_COMPARE_TRUE       0x00000008 /* -WIUV */
#define NV_UD3D0Z_SPECULAR(i)                   (0x00571000+(i)*32) /* -W-4A */
#define NV_UD3D0Z_SPECULAR__SIZE_1                              128 /*       */
#define NV_UD3D0Z_SPECULAR_I0                                   3:0 /* -W-UF */
#define NV_UD3D0Z_SPECULAR_I1                                   7:4 /* -W-UF */
#define NV_UD3D0Z_SPECULAR_I2                                  11:8 /* -W-UF */
#define NV_UD3D0Z_SPECULAR_I3                                 15:12 /* -W-UF */
#define NV_UD3D0Z_SPECULAR_I4                                 19:16 /* -W-UF */
#define NV_UD3D0Z_SPECULAR_I5                                 23:20 /* -W-UF */
#define NV_UD3D0Z_SPECULAR_FOG                                31:24 /* -W-UF */
#define NV_UD3D0Z_COLOR(i)                      (0x00571004+(i)*32) /* -W-4A */
#define NV_UD3D0Z_COLOR__SIZE_1                                 128 /*       */
#define NV_UD3D0Z_COLOR_B8                                      7:0 /* -W-UF */
#define NV_UD3D0Z_COLOR_G8                                     16:8 /* -W-UF */
#define NV_UD3D0Z_COLOR_R8                                    23:16 /* -W-UF */
#define NV_UD3D0Z_COLOR_A8                                    32:24 /* -W-UF */
#define NV_UD3D0Z_X(i)                          (0x00571008+(i)*32) /* -W-4A */
#define NV_UD3D0Z_X__SIZE_1                                     128 /*       */
#define NV_UD3D0Z_X_VALUE                                      31:0 /* -W-FF */
#define NV_UD3D0Z_Y(i)                          (0x0057100C+(i)*32) /* -W-4A */
#define NV_UD3D0Z_Y__SIZE_1                                     128 /*       */
#define NV_UD3D0Z_Y_VALUE                                      31:0 /* -W-FF */
#define NV_UD3D0Z_Z(i)                          (0x00571010+(i)*32) /* -W-4A */
#define NV_UD3D0Z_Z__SIZE_1                                     128 /*       */
#define NV_UD3D0Z_Z_VALUE                                      31:0 /* -W-FF */
#define NV_UD3D0Z_M(i)                          (0x00571014+(i)*32) /* -W-4A */
#define NV_UD3D0Z_M__SIZE_1                                     128 /*       */
#define NV_UD3D0Z_M_VALUE                                      31:0 /* -W-FF */
#define NV_UD3D0Z_U(i)                          (0x00571018+(i)*32) /* -W-4A */
#define NV_UD3D0Z_U__SIZE_1                                     128 /*       */
#define NV_UD3D0Z_U_VALUE                                      31:0 /* -W-FF */
#define NV_UD3D0Z_V(i)                          (0x0057101c+(i)*32) /* -W-4A */
#define NV_UD3D0Z_V__SIZE_1                                     128 /*       */
#define NV_UD3D0Z_V_VALUE                                      31:0 /* -W-FF */
/* usr_pattern.ref */
#define NV_UPATT                              0x00461FFF:0x00460000 /* -W--D */
#define NV_UPATT_CTX_SWITCH                              0x00460000 /* -W-4R */
#define NV_UPATT_CTX_SWITCH_INSTANCE                           15:0 /* -W-UF */
#define NV_UPATT_CTX_SWITCH_CHID                              22:16 /* -W-UF */
#define NV_UPATT_CTX_SWITCH_VOLATILE                          31:31 /* -W-VF */
#define NV_UPATT_CTX_SWITCH_VOLATILE_IGNORE              0x00000000 /* -W--V */
#define NV_UPATT_CTX_SWITCH_VOLATILE_RESET               0x00000001 /* -W--V */
#define NV_UPATT_SET_NOTIFY                              0x00460104 /* -W-4R */
#define NV_UPATT_SET_NOTIFY_PARAMETER                          31:0 /* -W-VF */
#define NV_UPATT_SET_NOTIFY_PARAMETER_WRITE              0x00000000 /* -W--V */
#define NV_UPATT_SET_SHAPE                               0x00460308 /* -W-4R */
#define NV_UPATT_SET_SHAPE_VALUE                                1:0 /* -W-VF */
#define NV_UPATT_SET_SHAPE_VALUE_8X8                     0x00000000 /* -W--V */
#define NV_UPATT_SET_SHAPE_VALUE_64X1                    0x00000001 /* -W--V */
#define NV_UPATT_SET_SHAPE_VALUE_1X64                    0x00000002 /* -W--V */
#define NV_UPATT_SET_COLOR0                              0x00460310 /* -W-4R */
#define NV_UPATT_SET_COLOR0_VALUE                              31:0 /* -W-VF */
#define NV_UPATT_SET_COLOR1                              0x00460314 /* -W-4R */
#define NV_UPATT_SET_COLOR1_VALUE                              31:0 /* -W-VF */
#define NV_UPATT_SET_PATTERN(i)                  (0x00460318+(i)*4) /* -W-4A */
#define NV_UPATT_SET_PATTERN__SIZE_1                              2 /*       */
#define NV_UPATT_SET_PATTERN_BITMAP                            31:0 /* -W-VF */
/* usr_point.ref */
#define NV_UPOINT                             0x00481FFF:0x00480000 /* -W--D */
#define NV_UPOINT_CTX_SWITCH                             0x00480000 /* -W-4R */
#define NV_UPOINT_CTX_SWITCH_INSTANCE                          15:0 /* -W-UF */
#define NV_UPOINT_CTX_SWITCH_CHID                             22:16 /* -W-UF */
#define NV_UPOINT_CTX_SWITCH_VOLATILE                         31:31 /* -W-VF */
#define NV_UPOINT_CTX_SWITCH_VOLATILE_IGNORE             0x00000000 /* -W--V */
#define NV_UPOINT_CTX_SWITCH_VOLATILE_RESET              0x00000001 /* -W--V */
#define NV_UPOINT_SET_NOTIFY                             0x00480104 /* -W-4R */
#define NV_UPOINT_SET_NOTIFY_PARAMETER                         31:0 /* -W-VF */
#define NV_UPOINT_SET_NOTIFY_PARAMETER_WRITE             0x00000000 /* -W--V */
#define NV_UPOINT_COLOR                                  0x00480304 /* -W-4R */
#define NV_UPOINT_COLOR_VALUE                                  31:0 /* -W-VF */
#define NV_UPOINT_POINT(i)                       (0x00480400+(i)*4) /* -W-4A */
#define NV_UPOINT_POINT__SIZE_1                                  32 /*       */
#define NV_UPOINT_POINT_X                                      15:0 /* -W-SF */
#define NV_UPOINT_POINT_Y                                     31:16 /* -W-SF */
#define NV_UPOINT_POINT32_0(i)                   (0x00480480+(i)*8) /* -W-4A */
#define NV_UPOINT_POINT32_0__SIZE_1                              16 /*       */
#define NV_UPOINT_POINT32_0_X                                  31:0 /* -W-SF */
#define NV_UPOINT_POINT32_1(i)                   (0x00480484+(i)*8) /* -W-4A */
#define NV_UPOINT_POINT32_1__SIZE_1                              16 /*       */
#define NV_UPOINT_POINT32_1_Y                                  31:0 /* -W-SF */
#define NV_UPOINT_CPOINT_0(i)                    (0x00480500+(i)*8) /* -W-4A */
#define NV_UPOINT_CPOINT_0__SIZE_1                               16 /*       */
#define NV_UPOINT_CPOINT_0_COLOR                               31:0 /* -W-VF */
#define NV_UPOINT_CPOINT_1(i)                    (0x00480504+(i)*8) /* -W-4A */
#define NV_UPOINT_CPOINT_1__SIZE_1                               16 /*       */
#define NV_UPOINT_CPOINT_1_X                                   15:0 /* -W-SF */
#define NV_UPOINT_CPOINT_1_Y                                  31:16 /* -W-SF */
/* usr_pointz.ref */
#define NV_UPOINTZ                            0x00581FFF:0x00580000 /* -W--D */
#define NV_UPOINTZ_CTX_SWITCH                            0x00580000 /* -W-4R */
#define NV_UPOINTZ_CTX_SWITCH_INSTANCE                         15:0 /* -W-UF */
#define NV_UPOINTZ_CTX_SWITCH_CHID                            22:16 /* -W-UF */
#define NV_UPOINTZ_CTX_SWITCH_VOLATILE                        31:31 /* -W-VF */
#define NV_UPOINTZ_CTX_SWITCH_VOLATILE_IGNORE            0x00000000 /* -W--V */
#define NV_UPOINTZ_CTX_SWITCH_VOLATILE_RESET             0x00000001 /* -W--V */
#define NV_UPOINTZ_SET_NOTIFY                            0x00580104 /* -W-4R */
#define NV_UPOINTZ_SET_NOTIFY_PARAMETER                        31:0 /* -W-VF */
#define NV_UPOINTZ_SET_NOTIFY_PARAMETER_WRITE            0x00000000 /* -W--V */
#define NV_UPOINTZ_CONTROL_OUT                           0x00580304 /* -W-4R */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE                   19:16 /* -W-UF */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_FALSE        0x00000001 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_LT           0x00000002 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_EQ           0x00000003 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_LE           0x00000004 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_GT           0x00000005 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_NE           0x00000006 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_GE           0x00000007 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_TRUE         0x00000008 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_WRITE                     22:20 /* -W-UF */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_WRITE_NEVER          0x00000000 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_WRITE_ALPHA          0x00000001 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_WRITE_ALPHA_ZETA     0x00000002 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_WRITE_ZETA           0x00000003 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_WRITE_ALWAYS         0x00000004 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_COLOR_WRITE                    26:24 /* -W-UF */
#define NV_UPOINTZ_CONTROL_OUT_COLOR_WRITE_NEVER         0x00000000 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_COLOR_WRITE_ALPHA         0x00000001 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_COLOR_WRITE_ALPHA_ZETA    0x00000002 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_COLOR_WRITE_ZETA          0x00000003 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_COLOR_WRITE_ALWAYS        0x00000004 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_ROP                            28:28 /* -W-UF */
#define NV_UPOINTZ_CONTROL_OUT_ROP_BLEND_AND             0x00000000 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_ROP_ADD_WITH_SATURATION   0x00000001 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_BLEND_BETA                     29:29 /* -W-UF */
#define NV_UPOINTZ_CONTROL_OUT_BLEND_BETA_SRCALPHA       0x00000000 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_BLEND_BETA_DESTCOLOR      0x00000001 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_BLEND_INPUT0                   30:30 /* -W-UF */
#define NV_UPOINTZ_CONTROL_OUT_BLEND_INPUT0_DESTCOLOR    0x00000000 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_BLEND_INPUT0_ZERO         0x00000001 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_BLEND_INPUT1                   31:31 /* -W-UF */
#define NV_UPOINTZ_CONTROL_OUT_BLEND_INPUT1_SRCCOLOR     0x00000000 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_BLEND_INPUT1_ZERO         0x00000001 /* -W-UV */
#define NV_UPOINTZ_ALPHA_CONTROL                         0x00580308 /* -W-4R */
#define NV_UPOINTZ_ALPHA_CONTROL_ALPHA_KEY                      7:0 /* -WXVF */
#define NV_UPOINTZ_ALPHA_CONTROL_ALPHA_COMPARE                 11:8 /* -WIUF */
#define NV_UPOINTZ_ALPHA_CONTROL_ALPHA_COMPARE_ILLEGAL   0x00000000 /* -W-UV */
#define NV_UPOINTZ_ALPHA_CONTROL_ALPHA_COMPARE_FALSE     0x00000001 /* -W-UV */
#define NV_UPOINTZ_ALPHA_CONTROL_ALPHA_COMPARE_LT        0x00000002 /* -W-UV */
#define NV_UPOINTZ_ALPHA_CONTROL_ALPHA_COMPARE_EQ        0x00000003 /* -W-UV */
#define NV_UPOINTZ_ALPHA_CONTROL_ALPHA_COMPARE_LE        0x00000004 /* -W-UV */
#define NV_UPOINTZ_ALPHA_CONTROL_ALPHA_COMPARE_GT        0x00000005 /* -W-UV */
#define NV_UPOINTZ_ALPHA_CONTROL_ALPHA_COMPARE_NE        0x00000006 /* -W-UV */
#define NV_UPOINTZ_ALPHA_CONTROL_ALPHA_COMPARE_GE        0x00000007 /* -W-UV */
#define NV_UPOINTZ_ALPHA_CONTROL_ALPHA_COMPARE_TRUE      0x00000008 /* -WIUV */
#define NV_UPOINTZ_POINT                                 0x005807FC /* -W-4R */
#define NV_UPOINTZ_POINT_X                                     15:0 /* -W-SF */
#define NV_UPOINTZ_POINT_Y                                    31:16 /* -W-SF */
#define NV_UPOINTZ_COLOR(i)                      (0x00580800+(i)*8) /* -W-4A */
#define NV_UPOINTZ_COLOR__SIZE_1                                256 /*       */
#define NV_UPOINTZ_COLOR_VALUE                                 31:0 /* -W-VF */
#define NV_UPOINTZ_ZETA(i)                       (0x00580804+(i)*8) /* -W-4A */
#define NV_UPOINTZ_ZETA__SIZE_1                                 256 /*       */
#define NV_UPOINTZ_ZETA_VALUE                                  31:0 /* -W-VF */
/* usr_line.ref */
#define NV_ULINE                              0x00491FFF:0x00490000 /* -W--D */
#define NV_ULINE_CTX_SWITCH                              0x00490000 /* -W-4R */
#define NV_ULINE_CTX_SWITCH_INSTANCE                           15:0 /* -W-UF */
#define NV_ULINE_CTX_SWITCH_CHID                              22:16 /* -W-UF */
#define NV_ULINE_CTX_SWITCH_VOLATILE                          31:31 /* -W-VF */
#define NV_ULINE_CTX_SWITCH_VOLATILE_IGNORE              0x00000000 /* -W--V */
#define NV_ULINE_CTX_SWITCH_VOLATILE_RESET               0x00000001 /* -W--V */
#define NV_ULINE_SET_NOTIFY                              0x00490104 /* -W-4R */
#define NV_ULINE_SET_NOTIFY_PARAMETER                          31:0 /* -W-VF */
#define NV_ULINE_SET_NOTIFY_PARAMETER_WRITE              0x00000000 /* -W--V */
#define NV_ULINE_COLOR                                   0x00490304 /* -W-4R */
#define NV_ULINE_COLOR_VALUE                                   31:0 /* -W-VF */
#define NV_ULINE_LINE_0(i)                       (0x00490400+(i)*8) /* -W-4A */
#define NV_ULINE_LINE_0__SIZE_1                                  16 /*       */
#define NV_ULINE_LINE_0_X                                      15:0 /* -W-SF */
#define NV_ULINE_LINE_0_Y                                     31:16 /* -W-SF */
#define NV_ULINE_LINE_1(i)                       (0x00490404+(i)*8) /* -W-4A */
#define NV_ULINE_LINE_1__SIZE_1                                  16 /*       */
#define NV_ULINE_LINE_1_X                                      15:0 /* -W-SF */
#define NV_ULINE_LINE_1_Y                                     31:16 /* -W-SF */
#define NV_ULINE_LINE32_0(i)                    (0x00490480+(i)*16) /* -W-4A */
#define NV_ULINE_LINE32_0__SIZE_1                                 8 /*       */
#define NV_ULINE_LINE32_0_X                                    31:0 /* -W-SF */
#define NV_ULINE_LINE32_1(i)                    (0x00490484+(i)*16) /* -W-4A */
#define NV_ULINE_LINE32_1__SIZE_1                                 8 /*       */
#define NV_ULINE_LINE32_1_Y                                    31:0 /* -W-SF */
#define NV_ULINE_LINE32_2(i)                    (0x00490488+(i)*16) /* -W-4A */
#define NV_ULINE_LINE32_2__SIZE_1                                 8 /*       */
#define NV_ULINE_LINE32_2_X                                    31:0 /* -W-SF */
#define NV_ULINE_LINE32_3(i)                    (0x0049048C+(i)*16) /* -W-4A */
#define NV_ULINE_LINE32_3__SIZE_1                                 8 /*       */
#define NV_ULINE_LINE32_3_Y                                    31:0 /* -W-SF */
#define NV_ULINE_POLYLINE(i)                     (0x00490500+(i)*4) /* -W-4A */
#define NV_ULINE_POLYLINE__SIZE_1                                32 /*       */
#define NV_ULINE_POLYLINE_X                                    15:0 /* -W-SF */
#define NV_ULINE_POLYLINE_Y                                   31:16 /* -W-SF */
#define NV_ULINE_POLYLINE32_0(i)                 (0x00490580+(i)*8) /* -W-4A */
#define NV_ULINE_POLYLINE32_0__SIZE_1                            16 /*       */
#define NV_ULINE_POLYLINE32_0_X                                31:0 /* -W-SF */
#define NV_ULINE_POLYLINE32_1(i)                 (0x00490584+(i)*8) /* -W-4A */
#define NV_ULINE_POLYLINE32_1__SIZE_1                            16 /*       */
#define NV_ULINE_POLYLINE32_1_Y                                31:0 /* -W-SF */
#define NV_ULINE_CPOLYLINE_0(i)                  (0x00490600+(i)*8) /* -W-4A */
#define NV_ULINE_CPOLYLINE_0__SIZE_1                             16 /*       */
#define NV_ULINE_CPOLYLINE_0_COLOR                             31:0 /* -W-VF */
#define NV_ULINE_CPOLYLINE_1(i)                  (0x00490604+(i)*8) /* -W-4A */
#define NV_ULINE_CPOLYLINE_1__SIZE_1                             16 /*       */
#define NV_ULINE_CPOLYLINE_1_X                                 15:0 /* -W-SF */
#define NV_ULINE_CPOLYLINE_1_Y                                31:16 /* -W-SF */
/* usr_lin.ref */
#define NV_ULIN                               0x004A1FFF:0x004A0000 /* -W--D */
#define NV_ULIN_CTX_SWITCH                               0x004A0000 /* -W-4R */
#define NV_ULIN_CTX_SWITCH_INSTANCE                            15:0 /* -W-UF */
#define NV_ULIN_CTX_SWITCH_CHID                               22:16 /* -W-UF */
#define NV_ULIN_CTX_SWITCH_VOLATILE                           31:31 /* -W-VF */
#define NV_ULIN_CTX_SWITCH_VOLATILE_IGNORE               0x00000000 /* -W--V */
#define NV_ULIN_CTX_SWITCH_VOLATILE_RESET                0x00000001 /* -W--V */
#define NV_ULIN_SET_NOTIFY                               0x004A0104 /* -W-4R */
#define NV_ULIN_SET_NOTIFY_PARAMETER                           31:0 /* -W-VF */
#define NV_ULIN_SET_NOTIFY_PARAMETER_WRITE               0x00000000 /* -W--V */
#define NV_ULIN_COLOR                                    0x004A0304 /* -W-4R */
#define NV_ULIN_COLOR_VALUE                                    31:0 /* -W-VF */
#define NV_ULIN_LIN_0(i)                         (0x004A0400+(i)*8) /* -W-4A */
#define NV_ULIN_LIN_0__SIZE_1                                    16 /*       */
#define NV_ULIN_LIN_0_X                                        15:0 /* -W-SF */
#define NV_ULIN_LIN_0_Y                                       31:16 /* -W-SF */
#define NV_ULIN_LIN_1(i)                         (0x004A0404+(i)*8) /* -W-4A */
#define NV_ULIN_LIN_1__SIZE_1                                    16 /*       */
#define NV_ULIN_LIN_1_X                                        15:0 /* -W-SF */
#define NV_ULIN_LIN_1_Y                                       31:16 /* -W-SF */
#define NV_ULIN_LIN32_0(i)                      (0x004A0480+(i)*16) /* -W-4A */
#define NV_ULIN_LIN32_0__SIZE_1                                   8 /*       */
#define NV_ULIN_LIN32_0_X                                      31:0 /* -W-SF */
#define NV_ULIN_LIN32_1(i)                      (0x004A0484+(i)*16) /* -W-4A */
#define NV_ULIN_LIN32_1__SIZE_1                                   8 /*       */
#define NV_ULIN_LIN32_1_Y                                      31:0 /* -W-SF */
#define NV_ULIN_LIN32_2(i)                      (0x004A0488+(i)*16) /* -W-4A */
#define NV_ULIN_LIN32_2__SIZE_1                                   8 /*       */
#define NV_ULIN_LIN32_2_X                                      31:0 /* -W-SF */
#define NV_ULIN_LIN32_3(i)                      (0x004A048C+(i)*16) /* -W-4A */
#define NV_ULIN_LIN32_3__SIZE_1                                   8 /*       */
#define NV_ULIN_LIN32_3_Y                                      31:0 /* -W-SF */
#define NV_ULIN_POLYLIN(i)                       (0x004A0500+(i)*4) /* -W-4A */
#define NV_ULIN_POLYLIN__SIZE_1                                  32 /*       */
#define NV_ULIN_POLYLIN_X                                      15:0 /* -W-SF */
#define NV_ULIN_POLYLIN_Y                                     31:16 /* -W-SF */
#define NV_ULIN_POLYLIN32_0(i)                   (0x004A0580+(i)*8) /* -W-4A */
#define NV_ULIN_POLYLIN32_0__SIZE_1                              16 /*       */
#define NV_ULIN_POLYLIN32_0_X                                  31:0 /* -W-SF */
#define NV_ULIN_POLYLIN32_1(i)                   (0x004A0584+(i)*8) /* -W-4A */
#define NV_ULIN_POLYLIN32_1__SIZE_1                              16 /*       */
#define NV_ULIN_POLYLIN32_1_Y                                  31:0 /* -W-SF */
#define NV_ULIN_CPOLYLIN_0(i)                    (0x004A0600+(i)*8) /* -W-4A */
#define NV_ULIN_CPOLYLIN_0__SIZE_1                               16 /*       */
#define NV_ULIN_CPOLYLIN_0_COLOR                               31:0 /* -W-VF */
#define NV_ULIN_CPOLYLIN_1(i)                    (0x004A0604+(i)*8) /* -W-4A */
#define NV_ULIN_CPOLYLIN_1__SIZE_1                               16 /*       */
#define NV_ULIN_CPOLYLIN_1_X                                   15:0 /* -W-SF */
#define NV_ULIN_CPOLYLIN_1_Y                                  31:16 /* -W-SF */
/* usr_mem_to_mem.ref */
#define NV_UMEMFMT                            0x004D1FFF:0x004D0000 /* -W--D */
#define NV_UMEMFMT_CTX_SWITCH                            0x004D0000 /* -W-4R */
#define NV_UMEMFMT_CTX_SWITCH_INSTANCE                         15:0 /* -W-UF */
#define NV_UMEMFMT_CTX_SWITCH_CHID                            22:16 /* -W-UF */
#define NV_UMEMFMT_CTX_SWITCH_VOLATILE                        31:31 /* -W-VF */
#define NV_UMEMFMT_CTX_SWITCH_VOLATILE_IGNORE            0x00000000 /* -W--V */
#define NV_UMEMFMT_CTX_SWITCH_VOLATILE_RESET             0x00000001 /* -W--V */
#define NV_UMEMFMT_SET_NOTIFY                            0x004D0104 /* -W-4R */
#define NV_UMEMFMT_SET_NOTIFY_PARAMETER                        31:0 /* -W-VF */
#define NV_UMEMFMT_SET_NOTIFY_PARAMETER_WRITE            0x00000000 /* -W--V */
#define NV_UMEMFMT_OFFSET_IN                             0x004D030C /* -W-4R */
#define NV_UMEMFMT_OFFSET_IN_VALUE                             31:0 /* -W-UF */
#define NV_UMEMFMT_OFFSET_OUT                            0x004D0310 /* -W-4R */
#define NV_UMEMFMT_OFFSET_OUT_VALUE                            31:0 /* -W-UF */
#define NV_UMEMFMT_PITCH_IN                              0x004D0314 /* -W-4R */
#define NV_UMEMFMT_PITCH_IN_VALUE                              31:0 /* -W-SF */
#define NV_UMEMFMT_PITCH_OUT                             0x004D0318 /* -W-4R */
#define NV_UMEMFMT_PITCH_OUT_VALUE                             31:0 /* -W-SF */
#define NV_UMEMFMT_LINE_LENGTH_IN                        0x004D031C /* -W-4R */
#define NV_UMEMFMT_LINE_LENGTH_IN_VALUE                        31:0 /* -W-UF */
#define NV_UMEMFMT_LINE_COUNT                            0x004D0320 /* -W-4R */
#define NV_UMEMFMT_LINE_COUNT_VALUE                            31:0 /* -W-UF */
#define NV_UMEMFMT_FORMAT                                0x004D0324 /* -W-4R */
#define NV_UMEMFMT_FORMAT_INPUT_INC                             2:0 /* -W-UF */
#define NV_UMEMFMT_FORMAT_INPUT_INC_1                    0x00000001 /* -WIUV */
#define NV_UMEMFMT_FORMAT_INPUT_INC_2                    0x00000002 /* -W-UV */
#define NV_UMEMFMT_FORMAT_INPUT_INC_4                    0x00000004 /* -W-UV */
#define NV_UMEMFMT_FORMAT_OUTPUT_INC                           10:8 /* -W-UF */
#define NV_UMEMFMT_FORMAT_OUTPUT_INC_1                   0x00000001 /* -WIUV */
#define NV_UMEMFMT_FORMAT_OUTPUT_INC_2                   0x00000002 /* -W-UV */
#define NV_UMEMFMT_FORMAT_OUTPUT_INC_4                   0x00000004 /* -W-UV */
#define NV_UMEMFMT_BUF_NOTIFY                            0x004D0328 /* -W-4R */
#define NV_UMEMFMT_BUF_NOTIFY_VALUE                            31:0 /* -W-UF */
/* usr_triangle.ref */
#define NV_UTRI                               0x004B1FFF:0x004B0000 /* -W--D */
#define NV_UTRI_CTX_SWITCH                               0x004B0000 /* -W-4R */
#define NV_UTRI_CTX_SWITCH_INSTANCE                            15:0 /* -W-UF */
#define NV_UTRI_CTX_SWITCH_CHID                               22:16 /* -W-UF */
#define NV_UTRI_CTX_SWITCH_VOLATILE                           31:31 /* -W-VF */
#define NV_UTRI_CTX_SWITCH_VOLATILE_IGNORE               0x00000000 /* -W--V */
#define NV_UTRI_CTX_SWITCH_VOLATILE_RESET                0x00000001 /* -W--V */
#define NV_UTRI_SET_NOTIFY                               0x004B0104 /* -W-4R */
#define NV_UTRI_SET_NOTIFY_PARAMETER                           31:0 /* -W-VF */
#define NV_UTRI_SET_NOTIFY_PARAMETER_WRITE               0x00000000 /* -W--V */
#define NV_UTRI_COLOR                                    0x004B0304 /* -W-4R */
#define NV_UTRI_COLOR_VALUE                                    31:0 /* -W-VF */
#define NV_UTRI_TRIANGLE_0                               0x004B0310 /* -W-4R */
#define NV_UTRI_TRIANGLE_0_X                                   15:0 /* -W-SF */
#define NV_UTRI_TRIANGLE_0_Y                                  31:16 /* -W-SF */
#define NV_UTRI_TRIANGLE_1                               0x004B0314 /* -W-4R */
#define NV_UTRI_TRIANGLE_1_X                                   15:0 /* -W-SF */
#define NV_UTRI_TRIANGLE_1_Y                                  31:16 /* -W-SF */
#define NV_UTRI_TRIANGLE_2                               0x004B0318 /* -W-4R */
#define NV_UTRI_TRIANGLE_2_X                                   15:0 /* -W-SF */
#define NV_UTRI_TRIANGLE_2_Y                                  31:16 /* -W-SF */
#define NV_UTRI_TRIANGLE32_0                             0x004B0320 /* -W-4R */
#define NV_UTRI_TRIANGLE32_0_X                                 31:0 /* -W-SF */
#define NV_UTRI_TRIANGLE32_1                             0x004B0324 /* -W-4R */
#define NV_UTRI_TRIANGLE32_1_Y                                 31:0 /* -W-SF */
#define NV_UTRI_TRIANGLE32_2                             0x004B0328 /* -W-4R */
#define NV_UTRI_TRIANGLE32_2_X                                 31:0 /* -W-SF */
#define NV_UTRI_TRIANGLE32_3                             0x004B032C /* -W-4R */
#define NV_UTRI_TRIANGLE32_3_Y                                 31:0 /* -W-SF */
#define NV_UTRI_TRIANGLE32_4                             0x004B0330 /* -W-4R */
#define NV_UTRI_TRIANGLE32_4_X                                 31:0 /* -W-SF */
#define NV_UTRI_TRIANGLE32_5                             0x004B0334 /* -W-4R */
#define NV_UTRI_TRIANGLE32_5_Y                                 31:0 /* -W-SF */
#define NV_UTRI_TRIMESH(i)                       (0x004B0400+(i)*4) /* -W-4A */
#define NV_UTRI_TRIMESH__SIZE_1                                  32 /*       */
#define NV_UTRI_TRIMESH_X                                      15:0 /* -W-SF */
#define NV_UTRI_TRIMESH_Y                                     31:16 /* -W-SF */
#define NV_UTRI_TRIMESH32_0(i)                   (0x004B0480+(i)*8) /* -W-4A */
#define NV_UTRI_TRIMESH32_0__SIZE_1                              16 /*       */
#define NV_UTRI_TRIMESH32_0_X                                  31:0 /* -W-SF */
#define NV_UTRI_TRIMESH32_1(i)                   (0x004B0484+(i)*8) /* -W-4A */
#define NV_UTRI_TRIMESH32_1__SIZE_1                              16 /*       */
#define NV_UTRI_TRIMESH32_1_Y                                  31:0 /* -W-SF */
#define NV_UTRI_CTRIANGLE_0(i)                  (0x004B0500+(i)*16) /* -W-4A */
#define NV_UTRI_CTRIANGLE_0__SIZE_1                               8 /*       */
#define NV_UTRI_CTRIANGLE_0_COLOR                              31:0 /* -W-VF */
#define NV_UTRI_CTRIANGLE_1(i)                  (0x004B0504+(i)*16) /* -W-4A */
#define NV_UTRI_CTRIANGLE_1__SIZE_1                               8 /*       */
#define NV_UTRI_CTRIANGLE_1_X                                  15:0 /* -W-SF */
#define NV_UTRI_CTRIANGLE_1_Y                                 31:16 /* -W-SF */
#define NV_UTRI_CTRIANGLE_2(i)                  (0x004B0508+(i)*16) /* -W-4A */
#define NV_UTRI_CTRIANGLE_2__SIZE_1                               8 /*       */
#define NV_UTRI_CTRIANGLE_2_X                                  15:0 /* -W-SF */
#define NV_UTRI_CTRIANGLE_2_Y                                 31:16 /* -W-SF */
#define NV_UTRI_CTRIANGLE_3(i)                  (0x004B050C+(i)*16) /* -W-4A */
#define NV_UTRI_CTRIANGLE_3__SIZE_1                               8 /*       */
#define NV_UTRI_CTRIANGLE_3_X                                  15:0 /* -W-SF */
#define NV_UTRI_CTRIANGLE_3_Y                                 31:16 /* -W-SF */
#define NV_UTRI_CTRIMESH_0(i)                    (0x004B0580+(i)*8) /* -W-4A */
#define NV_UTRI_CTRIMESH_0__SIZE_1                               16 /*       */
#define NV_UTRI_CTRIMESH_0_COLOR                               31:0 /* -W-VF */
#define NV_UTRI_CTRIMESH_1(i)                    (0x004B0584+(i)*8) /* -W-4A */
#define NV_UTRI_CTRIMESH_1__SIZE_1                               16 /*       */
#define NV_UTRI_CTRIMESH_1_X                                   15:0 /* -W-SF */
#define NV_UTRI_CTRIMESH_1_Y                                  31:16 /* -W-SF */
/* usr_rectangle.ref */
#define NV_URECT                              0x00471FFF:0x00470000 /* -W--D */
#define NV_URECT_CTX_SWITCH                              0x00470000 /* -W-4R */
#define NV_URECT_CTX_SWITCH_INSTANCE                           15:0 /* -W-UF */
#define NV_URECT_CTX_SWITCH_CHID                              22:16 /* -W-UF */
#define NV_URECT_CTX_SWITCH_VOLATILE                          31:31 /* -W-VF */
#define NV_URECT_CTX_SWITCH_VOLATILE_IGNORE              0x00000000 /* -W--V */
#define NV_URECT_CTX_SWITCH_VOLATILE_RESET               0x00000001 /* -W--V */
#define NV_URECT_SET_NOTIFY                              0x00470104 /* -W-4R */
#define NV_URECT_SET_NOTIFY_PARAMETER                          31:0 /* -W-VF */
#define NV_URECT_SET_NOTIFY_PARAMETER_WRITE              0x00000000 /* -W--V */
#define NV_URECT_COLOR                                   0x00470304 /* -W-4R */
#define NV_URECT_COLOR_VALUE                                   31:0 /* -W-VF */
#define NV_URECT_RECTANGLE_0(i)                  (0x00470400+(i)*8) /* -W-4A */
#define NV_URECT_RECTANGLE_0__SIZE_1                             16 /*       */
#define NV_URECT_RECTANGLE_0_X                                 15:0 /* -W-SF */
#define NV_URECT_RECTANGLE_0_Y                                31:16 /* -W-SF */
#define NV_URECT_RECTANGLE_1(i)                  (0x00470404+(i)*8) /* -W-4A */
#define NV_URECT_RECTANGLE_1__SIZE_1                             16 /*       */
#define NV_URECT_RECTANGLE_1_WIDTH                             15:0 /* -W-UF */
#define NV_URECT_RECTANGLE_1_HEIGHT                           31:16 /* -W-UF */
/* usr_image_blit.ref */
#define NV_UBLIT                              0x00501FFF:0x00500000 /* -W--D */
#define NV_UBLIT_CTX_SWITCH                              0x00500000 /* -W-4R */
#define NV_UBLIT_CTX_SWITCH_INSTANCE                           15:0 /* -W-UF */
#define NV_UBLIT_CTX_SWITCH_CHID                              22:16 /* -W-UF */
#define NV_UBLIT_CTX_SWITCH_VOLATILE                          31:31 /* -W-VF */
#define NV_UBLIT_CTX_SWITCH_VOLATILE_IGNORE              0x00000000 /* -W--V */
#define NV_UBLIT_CTX_SWITCH_VOLATILE_RESET               0x00000001 /* -W--V */
#define NV_UBLIT_SET_NOTIFY                              0x00500104 /* -W-4R */
#define NV_UBLIT_SET_NOTIFY_PARAMETER                          31:0 /* -W-VF */
#define NV_UBLIT_SET_NOTIFY_PARAMETER_WRITE              0x00000000 /* -W--V */
#define NV_UBLIT_POINT_IN                                0x00500300 /* -W-4R */
#define NV_UBLIT_POINT_IN_X                                    15:0 /* -W-SF */
#define NV_UBLIT_POINT_IN_Y                                   31:16 /* -W-SF */
#define NV_UBLIT_POINT_OUT                               0x00500304 /* -W-4R */
#define NV_UBLIT_POINT_OUT_X                                   15:0 /* -W-SF */
#define NV_UBLIT_POINT_OUT_Y                                  31:16 /* -W-SF */
#define NV_UBLIT_SIZE                                    0x00500308 /* -W-4R */
#define NV_UBLIT_SIZE_WIDTH                                    15:0 /* -W-UF */
#define NV_UBLIT_SIZE_HEIGHT                                  31:16 /* -W-UF */
/* usr_image_from_cpu.ref */
#define NV_UIMAGE                             0x00511FFF:0x00510000 /* -W--D */
#define NV_UIMAGE_CTX_SWITCH                             0x00510000 /* -W-4R */
#define NV_UIMAGE_CTX_SWITCH_INSTANCE                          15:0 /* -W-UF */
#define NV_UIMAGE_CTX_SWITCH_CHID                             22:16 /* -W-UF */
#define NV_UIMAGE_CTX_SWITCH_VOLATILE                         31:31 /* -W-VF */
#define NV_UIMAGE_CTX_SWITCH_VOLATILE_IGNORE             0x00000000 /* -W--V */
#define NV_UIMAGE_CTX_SWITCH_VOLATILE_RESET              0x00000001 /* -W--V */
#define NV_UIMAGE_SET_NOTIFY                             0x00510104 /* -W-4R */
#define NV_UIMAGE_SET_NOTIFY_PARAMETER                         31:0 /* -W-VF */
#define NV_UIMAGE_SET_NOTIFY_PARAMETER_WRITE             0x00000000 /* -W--V */
#define NV_UIMAGE_POINT                                  0x00510304 /* -W-4R */
#define NV_UIMAGE_POINT_X                                      15:0 /* -W-SF */
#define NV_UIMAGE_POINT_Y                                     31:16 /* -W-SF */
#define NV_UIMAGE_SIZE                                   0x00510308 /* -W-4R */
#define NV_UIMAGE_SIZE_WIDTH                                   15:0 /* -W-UF */
#define NV_UIMAGE_SIZE_HEIGHT                                 31:16 /* -W-UF */
#define NV_UIMAGE_SIZE_IN                                0x0051030C /* -W-4R */
#define NV_UIMAGE_SIZE_IN_WIDTH                                15:0 /* -W-UF */
#define NV_UIMAGE_SIZE_IN_HEIGHT                              31:16 /* -W-UF */
#define NV_UIMAGE_COLOR(i)                       (0x00510400+(i)*4) /* -W-4A */
#define NV_UIMAGE_COLOR__SIZE_1                                  32 /*       */
#define NV_UIMAGE_COLOR_VALUE                                  31:0 /* -W-VF */
/* usr_bitmap_from_cpu.ref */
#define NV_UBITMAP                            0x00521FFF:0x00520000 /* -W--D */
#define NV_UBITMAP_CTX_SWITCH                            0x00520000 /* -W-4R */
#define NV_UBITMAP_CTX_SWITCH_INSTANCE                         15:0 /* -W-UF */
#define NV_UBITMAP_CTX_SWITCH_CHID                            22:16 /* -W-UF */
#define NV_UBITMAP_CTX_SWITCH_VOLATILE                        31:31 /* -W-VF */
#define NV_UBITMAP_CTX_SWITCH_VOLATILE_IGNORE            0x00000000 /* -W--V */
#define NV_UBITMAP_CTX_SWITCH_VOLATILE_RESET             0x00000001 /* -W--V */
#define NV_UBITMAP_SET_NOTIFY                            0x00520104 /* -W-4R */
#define NV_UBITMAP_SET_NOTIFY_PARAMETER                        31:0 /* -W-VF */
#define NV_UBITMAP_SET_NOTIFY_PARAMETER_WRITE            0x00000000 /* -W--V */
#define NV_UBITMAP_COLOR0                                0x00520308 /* -W-4R */
#define NV_UBITMAP_COLOR0_VALUE                                31:0 /* -W-VF */
#define NV_UBITMAP_COLOR1                                0x0052030C /* -W-4R */
#define NV_UBITMAP_COLOR1_VALUE                                31:0 /* -W-VF */
#define NV_UBITMAP_POINT                                 0x00520310 /* -W-4R */
#define NV_UBITMAP_POINT_X                                     15:0 /* -W-SF */
#define NV_UBITMAP_POINT_Y                                    31:16 /* -W-SF */
#define NV_UBITMAP_SIZE                                  0x00520314 /* -W-4R */
#define NV_UBITMAP_SIZE_WIDTH                                  15:0 /* -W-UF */
#define NV_UBITMAP_SIZE_HEIGHT                                31:16 /* -W-UF */
#define NV_UBITMAP_SIZE_IN                               0x00520318 /* -W-4R */
#define NV_UBITMAP_SIZE_IN_WIDTH                               15:0 /* -W-UF */
#define NV_UBITMAP_SIZE_IN_HEIGHT                             31:16 /* -W-UF */
#define NV_UBITMAP_MONOCHROME(i)                 (0x00520400+(i)*4) /* -W-4A */
#define NV_UBITMAP_MONOCHROME__SIZE_1                            32 /*       */
#define NV_UBITMAP_MONOCHROME_BITMAP                           31:0 /* -W-VF */
/* usr_image_to_mem.ref */
#define NV_UTOMEM                             0x00541FFF:0x00540000 /* -W--D */
#define NV_UTOMEM_CTX_SWITCH                             0x00540000 /* -W-4R */
#define NV_UTOMEM_CTX_SWITCH_INSTANCE                          15:0 /* -W-UF */
#define NV_UTOMEM_CTX_SWITCH_CHID                             22:16 /* -W-UF */
#define NV_UTOMEM_CTX_SWITCH_VOLATILE                         31:31 /* -W-VF */
#define NV_UTOMEM_CTX_SWITCH_VOLATILE_IGNORE             0x00000000 /* -W--V */
#define NV_UTOMEM_CTX_SWITCH_VOLATILE_RESET              0x00000001 /* -W--V */
#define NV_UTOMEM_SET_NOTIFY                             0x00540104 /* -W-4R */
#define NV_UTOMEM_SET_NOTIFY_PARAMETER                         31:0 /* -W-VF */
#define NV_UTOMEM_SET_NOTIFY_PARAMETER_WRITE             0x00000000 /* -W--V */
#define NV_UTOMEM_POINT                                  0x00540308 /* -W-4R */
#define NV_UTOMEM_POINT_X                                      15:0 /* -W-SF */
#define NV_UTOMEM_POINT_Y                                     31:16 /* -W-SF */
#define NV_UTOMEM_SIZE                                   0x0054030C /* -W-4R */
#define NV_UTOMEM_SIZE_WIDTH                                   15:0 /* -W-UF */
#define NV_UTOMEM_SIZE_HEIGHT                                 31:16 /* -W-UF */
#define NV_UTOMEM_IMAGE_PITCH                            0x00540310 /* -W-4R */
#define NV_UTOMEM_IMAGE_PITCH_VALUE                            31:0 /* -W-SF */
#define NV_UTOMEM_IMAGE_START                            0x00540314 /* -W-4R */
#define NV_UTOMEM_IMAGE_START_OFFSET                           31:0 /* -W-UF */
/* usr_scaled_image_from_mem.ref */
#define NV_USCALED                            0x004E1FFF:0x004E0000 /* -W--D */
#define NV_USCALED_CTX_SWITCH                            0x004E0000 /* -W-4R */
#define NV_USCALED_CTX_SWITCH_INSTANCE                         15:0 /* -W-UF */
#define NV_USCALED_CTX_SWITCH_CHID                            22:16 /* -W-UF */
#define NV_USCALED_CTX_SWITCH_VOLATILE                        31:31 /* -W-VF */
#define NV_USCALED_CTX_SWITCH_VOLATILE_IGNORE            0x00000000 /* -W--V */
#define NV_USCALED_CTX_SWITCH_VOLATILE_RESET             0x00000001 /* -W--V */
#define NV_USCALED_SET_NOTIFY                            0x004E0104 /* -W-4R */
#define NV_USCALED_SET_NOTIFY_PARAMETER                        31:0 /* -W-VF */
#define NV_USCALED_SET_NOTIFY_PARAMETER_WRITE            0x00000000 /* -W--V */
#define NV_USCALED_CLIP_0                                0x004E0308 /* -W-4R */
#define NV_USCALED_CLIP_0_X                                    15:0 /* -W-SF */
#define NV_USCALED_CLIP_0_Y                                   31:16 /* -W-SF */
#define NV_USCALED_CLIP_1                                0x004E030C /* -W-4R */
#define NV_USCALED_CLIP_1_WIDTH                                15:0 /* -W-UF */
#define NV_USCALED_CLIP_1_HEIGHT                              31:16 /* -W-UF */
#define NV_USCALED_RECTANGLE_OUT_0                       0x004E0310 /* -W-4R */
#define NV_USCALED_RECTANGLE_OUT_0_X                           15:0 /* -W-SF */
#define NV_USCALED_RECTANGLE_OUT_0_Y                          31:16 /* -W-SF */
#define NV_USCALED_RECTANGLE_OUT_1                       0x004E0314 /* -W-4R */
#define NV_USCALED_RECTANGLE_OUT_1_WIDTH                       15:0 /* -W-UF */
#define NV_USCALED_RECTANGLE_OUT_1_HEIGHT                     31:16 /* -W-UF */
#define NV_USCALED_DELTA_DU_DX                           0x004E0318 /* -W-4R */
#define NV_USCALED_DELTA_DU_DX_R_FRACTION                      19:0 /* -W-SF */
#define NV_USCALED_DELTA_DU_DX_R_INT                          31:20 /* -W-UF */
#define NV_USCALED_DELTA_DU_DX_R                               31:0 /* -W-UF */
#define NV_USCALED_DELTA_DV_DY                           0x004E031C /* -W-4R */
#define NV_USCALED_DELTA_DV_DY_R_FRACTION                      19:0 /* -W-SF */
#define NV_USCALED_DELTA_DV_DY_R_INT                          31:20 /* -W-UF */
#define NV_USCALED_DELTA_DV_DY_R                               31:0 /* -W-UF */
#define NV_USCALED_SIZE                                  0x004E0400 /* -W-4R */
#define NV_USCALED_SIZE_WIDTH                                  15:0 /* -W-UF */
#define NV_USCALED_SIZE_HEIGHT                                31:16 /* -W-UF */
#define NV_USCALED_PITCH                                 0x004E0404 /* -W-4R */
#define NV_USCALED_PITCH_VALUE                                 31:0 /* -W-SF */
#define NV_USCALED_OFFSET                                0x004E0408 /* -W-4R */
#define NV_USCALED_OFFSET_VALUE                               31:0  /* -W-UF */
#define NV_USCALED_POINT                                 0x004E040C /* -W-4R */
#define NV_USCALED_POINT_V_FRACTION                            11:0 /* -W-UF */
#define NV_USCALED_POINT_V_INT                                15:12 /* -W-UF */
#define NV_USCALED_POINT_V_VALUE                               15:0 /* -W-UF */
#define NV_USCALED_POINT_U_FRACTION                           19:16 /* -W-UF */
#define NV_USCALED_POINT_U_INT                                31:20 /* -W-UF */
#define NV_USCALED_POINT_U_VALUE                               31:0 /* -W-UF */
#define NV_USCALED_SIZE_Y                                0x004E0400 /* -W-4R */
#define NV_USCALED_SIZE_Y_WIDTH                                15:0 /* -W-UF */
#define NV_USCALED_SIZE_Y_HEIGHT                              31:16 /* -W-UF */
#define NV_USCALED_PITCH_420                             0x004E0404 /* -W-4R */
#define NV_USCALED_PITCH_420_Y                                 15:0 /* -W-UF */
#define NV_USCALED_PITCH_420_UV                               31:16 /* -W-UF */
#define NV_USCALED_OFFSET_Y                              0x004E0408 /* -W-4R */
#define NV_USCALED_OFFSET_Y_VALUE                             31:0  /* -W-UF */
#define NV_USCALED_OFFSET_U                              0x004E040C /* -W-4R */
#define NV_USCALED_OFFSET_U_VALUE                             31:0  /* -W-UF */
#define NV_USCALED_OFFSET_V                              0x004E0410 /* -W-4R */
#define NV_USCALED_OFFSET_V_VALUE                             31:0  /* -W-UF */
#define NV_USCALED_POINT_Y                               0x004E0414 /* -W-4R */
#define NV_USCALED_POINT_Y_V_FRACTION                          11:0 /* -W-UF */
#define NV_USCALED_POINT_Y_V_INT                              15:12 /* -W-UF */
#define NV_USCALED_POINT_Y_V_VALUE                             15:0 /* -W-UF */
#define NV_USCALED_POINT_Y_U_FRACTION                         19:16 /* -W-UF */
#define NV_USCALED_POINT_Y_U_INT                              31:20 /* -W-UF */
#define NV_USCALED_POINT_Y_U_VALUE                            31:16 /* -W-UF */
/* usr_stretch_from_cpu.ref */
#define NV_USTRTCH                            0x00551FFF:0x00550000 /* -W--D */
#define NV_USTRTCH_CTX_SWITCH                            0x00550000 /* -W-4R */
#define NV_USTRTCH_CTX_SWITCH_INSTANCE                         15:0 /* -W-UF */
#define NV_USTRTCH_CTX_SWITCH_CHID                            22:16 /* -W-UF */
#define NV_USTRTCH_CTX_SWITCH_VOLATILE                        31:31 /* -W-VF */
#define NV_USTRTCH_CTX_SWITCH_VOLATILE_IGNORE            0x00000000 /* -W--V */
#define NV_USTRTCH_CTX_SWITCH_VOLATILE_RESET             0x00000001 /* -W--V */
#define NV_USTRTCH_SET_NOTIFY                            0x00550104 /* -W-4R */
#define NV_USTRTCH_SET_NOTIFY_PARAMETER                        31:0 /* -W-VF */
#define NV_USTRTCH_SET_NOTIFY_PARAMETER_WRITE            0x00000000 /* -W--V */
#define NV_USTRTCH_SIZE_IN                               0x00550304 /* -W-4R */
#define NV_USTRTCH_SIZE_IN_WIDTH                               15:0 /* -W-UF */
#define NV_USTRTCH_SIZE_IN_HEIGHT                             31:16 /* -W-UF */
#define NV_USTRTCH_DELTA_DX_DU                           0x00550308 /* -W-4R */
#define NV_USTRTCH_DELTA_DX_DU_R_FRACTION                      19:0 /* -W-UF */
#define NV_USTRTCH_DELTA_DX_DU_R_INT                          31:20 /* -W-UF */
#define NV_USTRTCH_DELTA_DX_DU_R                               31:0 /* -W-UF */
#define NV_USTRTCH_DELTA_DY_DV                           0x0055030C /* -W-4R */
#define NV_USTRTCH_DELTA_DY_DV_R_FRACTION                      19:0 /* -W-UF */
#define NV_USTRTCH_DELTA_DY_DV_R_INT                          31:20 /* -W-UF */
#define NV_USTRTCH_DELTA_DY_DV_R                               31:0 /* -W-UF */
#define NV_USTRTCH_CLIP_0                                0x00550310 /* -W-4R */
#define NV_USTRTCH_CLIP_0_X                                    15:0 /* -W-SF */
#define NV_USTRTCH_CLIP_0_Y                                   31:16 /* -W-SF */
#define NV_USTRTCH_CLIP_1                                0x00550314 /* -W-4R */
#define NV_USTRTCH_CLIP_1_WIDTH                                15:0 /* -W-UF */
#define NV_USTRTCH_CLIP_1_HEIGHT                              31:16 /* -W-UF */
#define NV_USTRTCH_POINT12D4                             0x00550318 /* -W-4R */
#define NV_USTRTCH_POINT12D4_X_FRACTION                         3:0 /* -W-SF */
#define NV_USTRTCH_POINT12D4_X_INT                             15:4 /* -W-SF */
#define NV_USTRTCH_POINT12D4_X                                 15:0 /* -W-SF */
#define NV_USTRTCH_POINT12D4_Y_FRACTION                       19:16 /* -W-SF */
#define NV_USTRTCH_POINT12D4_Y_INT                            31:20 /* -W-SF */
#define NV_USTRTCH_POINT12D4_Y                                31:16 /* -W-SF */
#define NV_USTRTCH_COLOR(i)                      (0x00550400+(i)*4) /* -W-4A */
#define NV_USTRTCH_COLOR__SIZE_1                               1792 /*       */
#define NV_USTRTCH_COLOR_VALUE                                 31:0 /* -W-VF */
/* usr_win95_text.ref */
#define NV_UW95TXT                            0x004C1FFF:0x004C0000 /* -W--D */
#define NV_UW95TXT_CTX_SWITCH                            0x004C0000 /* -W-4R */
#define NV_UW95TXT_CTX_SWITCH_INSTANCE                         15:0 /* -W-UF */
#define NV_UW95TXT_CTX_SWITCH_CHID                            22:16 /* -W-UF */
#define NV_UW95TXT_CTX_SWITCH_VOLATILE                        31:31 /* -W-VF */
#define NV_UW95TXT_CTX_SWITCH_VOLATILE_IGNORE            0x00000000 /* -W--V */
#define NV_UW95TXT_CTX_SWITCH_VOLATILE_RESET             0x00000001 /* -W--V */
#define NV_UW95TXT_SET_NOTIFY                            0x004C0104 /* -W-4R */
#define NV_UW95TXT_SET_NOTIFY_PARAMETER                        31:0 /* -W-VF */
#define NV_UW95TXT_SET_NOTIFY_PARAMETER_WRITE            0x00000000 /* -W--V */
#define NV_UW95TXT_COLOR_A                               0x004C03FC /* -W-4R */
#define NV_UW95TXT_COLOR_A_VALUE                               31:0 /* -W-VF */
#define NV_UW95TXT_RECT_NCLIP_0(i)               (0x004C0400+(i)*8) /* -W-4A */
#define NV_UW95TXT_RECT_NCLIP_0__SIZE_1                          64 /*       */
#define NV_UW95TXT_RECT_NCLIP_0_Y                              15:0 /* -W-SF */
#define NV_UW95TXT_RECT_NCLIP_0_X                             31:16 /* -W-SF */
#define NV_UW95TXT_RECT_NCLIP_1(i)               (0x004C0404+(i)*8) /* -W-4A */
#define NV_UW95TXT_RECT_NCLIP_1__SIZE_1                          64 /*       */
#define NV_UW95TXT_RECT_NCLIP_1_HEIGHT                         15:0 /* -W-UF */
#define NV_UW95TXT_RECT_NCLIP_1_WIDTH                         31:16 /* -W-UF */
#define NV_UW95TXT_CLIP_B_0                              0x004C07F4 /* -W-4R */
#define NV_UW95TXT_CLIP_B_0_LEFT                               15:0 /* -W-SF */
#define NV_UW95TXT_CLIP_B_0_TOP                               31:16 /* -W-SF */
#define NV_UW95TXT_CLIP_B_1                              0x004C07F8 /* -W-4R */
#define NV_UW95TXT_CLIP_B_1_RIGHT                              15:0 /* -W-SF */
#define NV_UW95TXT_CLIP_B_1_BOTTOM                            31:16 /* -W-SF */
#define NV_UW95TXT_COLOR_B                               0x004C07FC /* -W-4R */
#define NV_UW95TXT_COLOR_B_VALUE                               31:0 /* -W-VF */
#define NV_UW95TXT_RECT_CLIP_0(i)                (0x004C0800+(i)*8) /* -W-4A */
#define NV_UW95TXT_RECT_CLIP_0__SIZE_1                           64 /*       */
#define NV_UW95TXT_RECT_CLIP_0_LEFT                            15:0 /* -W-SF */
#define NV_UW95TXT_RECT_CLIP_0_TOP                            31:16 /* -W-SF */
#define NV_UW95TXT_RECT_CLIP_1(i)                (0x004C0804+(i)*8) /* -W-4A */
#define NV_UW95TXT_RECT_CLIP_1__SIZE_1                           64 /*       */
#define NV_UW95TXT_RECT_CLIP_1_RIGHT                           15:0 /* -W-SF */
#define NV_UW95TXT_RECT_CLIP_1_BOTTOM                         31:16 /* -W-SF */
#define NV_UW95TXT_CLIP_C_0                              0x004C0BEC /* -W-4R */
#define NV_UW95TXT_CLIP_C_0_LEFT                               15:0 /* -W-SF */
#define NV_UW95TXT_CLIP_C_0_TOP                               31:16 /* -W-SF */
#define NV_UW95TXT_CLIP_C_1                              0x004C0BF0 /* -W-4R */
#define NV_UW95TXT_CLIP_C_1_RIGHT                              15:0 /* -W-SF */
#define NV_UW95TXT_CLIP_C_1_BOTTOM                            31:16 /* -W-SF */
#define NV_UW95TXT_COLOR1_C                              0x004C0BF4 /* -W-4R */
#define NV_UW95TXT_COLOR1_C_VALUE                              31:0 /* -W-VF */
#define NV_UW95TXT_SIZE_C                                0x004C0BF8 /* -W-4R */
#define NV_UW95TXT_SIZE_C_WIDTH                                15:0 /* -W-UF */
#define NV_UW95TXT_SIZE_C_HEIGHT                              31:16 /* -W-UF */
#define NV_UW95TXT_POINT_C                               0x004C0BFC /* -W-4R */
#define NV_UW95TXT_POINT_C_X                                   15:0 /* -W-SF */
#define NV_UW95TXT_POINT_C_Y                                  31:16 /* -W-SF */
#define NV_UW95TXT_MONO_COLOR1_C(i)              (0x004C0C00+(i)*4) /* -W-4A */
#define NV_UW95TXT_MONO_COLOR1_C__SIZE_1                        128 /*       */
#define NV_UW95TXT_MONO_COLOR1_C_BITMAP                        31:0 /* -W-VF */
#define NV_UW95TXT_CLIP_D_0                              0x004C0FE8 /* -W-4R */
#define NV_UW95TXT_CLIP_D_0_LEFT                               15:0 /* -W-SF */
#define NV_UW95TXT_CLIP_D_0_TOP                               31:16 /* -W-SF */
#define NV_UW95TXT_CLIP_D_1                              0x004C0FEC /* -W-4R */
#define NV_UW95TXT_CLIP_D_1_RIGHT                              15:0 /* -W-SF */
#define NV_UW95TXT_CLIP_D_1_BOTTOM                            31:16 /* -W-SF */
#define NV_UW95TXT_COLOR1_D                              0x004C0FF0 /* -W-4R */
#define NV_UW95TXT_COLOR1_D_VALUE                              31:0 /* -W-VF */
#define NV_UW95TXT_SIZE_IN_D                             0x004C0FF4 /* -W-4R */
#define NV_UW95TXT_SIZE_IN_D_WIDTH                             15:0 /* -W-UF */
#define NV_UW95TXT_SIZE_IN_D_HEIGHT                           31:16 /* -W-UF */
#define NV_UW95TXT_SIZE_OUT_D                            0x004C0FF8 /* -W-4R */
#define NV_UW95TXT_SIZE_OUT_D_WIDTH                            15:0 /* -W-UF */
#define NV_UW95TXT_SIZE_OUT_D_HEIGHT                          31:16 /* -W-UF */
#define NV_UW95TXT_POINT_D                               0x004C0FFC /* -W-4R */
#define NV_UW95TXT_POINT_D_X                                   15:0 /* -W-SF */
#define NV_UW95TXT_POINT_D_Y                                  31:16 /* -W-SF */
#define NV_UW95TXT_MONO_COLOR1_D(i)              (0x004C1000+(i)*4) /* -W-4A */
#define NV_UW95TXT_MONO_COLOR1_D__SIZE_1                        128 /*       */
#define NV_UW95TXT_MONO_COLOR1_D_BITMAP                        31:0 /* -W-VF */
#define NV_UW95TXT_CLIP_E_0                              0x004C13E4 /* -W-4R */
#define NV_UW95TXT_CLIP_E_0_LEFT                               15:0 /* -W-SF */
#define NV_UW95TXT_CLIP_E_0_TOP                               31:16 /* -W-SF */
#define NV_UW95TXT_CLIP_E_1                              0x004C13E8 /* -W-4R */
#define NV_UW95TXT_CLIP_E_1_RIGHT                              15:0 /* -W-SF */
#define NV_UW95TXT_CLIP_E_1_BOTTOM                            31:16 /* -W-SF */
#define NV_UW95TXT_COLOR0_E                              0x004C13EC /* -W-4R */
#define NV_UW95TXT_COLOR0_E_VALUE                              31:0 /* -W-VF */
#define NV_UW95TXT_COLOR1_E                              0x004C13F0 /* -W-4R */
#define NV_UW95TXT_COLOR1_E_VALUE                              31:0 /* -W-VF */
#define NV_UW95TXT_SIZE_IN_E                             0x004C13F4 /* -W-4R */
#define NV_UW95TXT_SIZE_IN_E_WIDTH                             15:0 /* -W-UF */
#define NV_UW95TXT_SIZE_IN_E_HEIGHT                           31:16 /* -W-UF */
#define NV_UW95TXT_SIZE_OUT_E                            0x004C13F8 /* -W-4R */
#define NV_UW95TXT_SIZE_OUT_E_WIDTH                            15:0 /* -W-UF */
#define NV_UW95TXT_SIZE_OUT_E_HEIGHT                          31:16 /* -W-UF */
#define NV_UW95TXT_POINT_E                               0x004C13FC /* -W-4R */
#define NV_UW95TXT_POINT_E_X                                   15:0 /* -W-SF */
#define NV_UW95TXT_POINT_E_Y                                  31:16 /* -W-SF */
#define NV_UW95TXT_MONO_COLOR01_E(i)             (0x004C1400+(i)*4) /* -W-4A */
#define NV_UW95TXT_MONO_COLOR01_E__SIZE_1                       128 /*       */
#define NV_UW95TXT_MONO_COLOR01_E_BITMAP                       31:0 /* -W-VF */
/* usr_image_in_mem.ref */
#define NV_UINMEM                             0x005C1FFF:0x005C0000 /* -W--D */
#define NV_UINMEM_CTX_SWITCH                             0x005C0000 /* -W-4R */
#define NV_UINMEM_CTX_SWITCH_INSTANCE                          15:0 /* -W-UF */
#define NV_UINMEM_CTX_SWITCH_CHID                             22:16 /* -W-UF */
#define NV_UINMEM_CTX_SWITCH_VOLATILE                         31:31 /* -W-VF */
#define NV_UINMEM_CTX_SWITCH_VOLATILE_IGNORE             0x00000000 /* -W--V */
#define NV_UINMEM_CTX_SWITCH_VOLATILE_RESET              0x00000001 /* -W--V */
#define NV_UINMEM_SET_NOTIFY                             0x005C0104 /* -W-4R */
#define NV_UINMEM_SET_NOTIFY_PARAMETER                         31:0 /* -W-VF */
#define NV_UINMEM_SET_NOTIFY_PARAMETER_WRITE             0x00000000 /* -W--V */
#define NV_UINMEM_PITCH                                  0x005C0308 /* -W-4R */
#define NV_UINMEM_PITCH_VALUE                                  15:0 /* -WXUF */
#define NV_UINMEM_OFFSET                                 0x005C030C /* -W-4R */
#define NV_UINMEM_OFFSET_LINADRS                               22:0 /* -WIUF */
#define NV_UINMEM_OFFSET_LINADRS_0                       0x00000000 /* -WI-V */
#define NV_UINMEM_FORMAT                                 0x005C0300 /* -W-4R */
#define NV_UINMEM_FORMAT_VALUE                                 31:0 /* -WXUF */
#define NV_UINMEM_FORMAT_VALUE_LE_Y8_P4                  0x01010000 /* -W--V */
#define NV_UINMEM_FORMAT_VALUE_LE_Y16_P2                 0x01010001 /* -W--V */
#define NV_UINMEM_FORMAT_VALUE_LE_X1R5G5B5_P2            0x01000000 /* -W--V */
#define NV_UINMEM_FORMAT_VALUE_LE_X8R8G8B8               0x00000001 /* -W--V */
/* dev_framebuffer.ref */
#define NV_PFB                                0x00100FFF:0x00100000 /* RW--D */
#define NV_PFB_BOOT_0                                    0x00100000 /* RW-4R */
#define NV_PFB_BOOT_0_RAM_AMOUNT                                1:0 /* RWIVF */
#define NV_PFB_BOOT_0_RAM_AMOUNT_8MB                     0x00000000 /* RW--V */
#define NV_PFB_BOOT_0_RAM_AMOUNT_2MB                     0x00000001 /* RW--V */
#define NV_PFB_BOOT_0_RAM_AMOUNT_4MB                     0x00000002 /* RW--V */
#define NV_PFB_BOOT_0_RAM_AMOUNT_UNDEFINED               0x00000003 /* RW--V */
#define NV_PFB_BOOT_0_RAM_AMOUNT_DEFAULT                 0x00000002 /* RWI-V */
#define NV_PFB_BOOT_0_RAM_WIDTH_128                             2:2 /* RW-VF */
#define NV_PFB_BOOT_0_RAM_WIDTH_128_OFF                  0x00000000 /* RW--V */
#define NV_PFB_BOOT_0_RAM_WIDTH_128_ON                   0x00000001 /* RW--V */
#define NV_PFB_BOOT_0_RAM_BANKS                                 3:3 /* RWIVF */
#define NV_PFB_BOOT_0_RAM_BANKS_2BANK                    0x00000000 /* RWI-V */
#define NV_PFB_BOOT_0_RAM_BANKS_4BANK                    0x00000001 /* RW--V */
#define NV_PFB_BOOT_0_RAMDATA_TWIDDLE                           4:4 /* RWIVF */
#define NV_PFB_BOOT_0_RAMDATA_TWIDDLE_OFF                0x00000000 /* RWI-V */
#define NV_PFB_BOOT_0_RAMDATA_TWIDDLE_ON                 0x00000001 /* RW--V */
#define NV_PFB_BOOT_0_RAM_AMOUNT_EXTENSION                      5:5 /* RWIVF */
#define NV_PFB_BOOT_0_RAM_AMOUNT_EXTENSION_OFF           0x00000000 /* RWI-V */
#define NV_PFB_BOOT_0_RAM_AMOUNT_EXTENSION_8MB           0x00000001 /* RW--V */
#define NV_PFB_DELAY_1                                   0x00100044 /* RW-4R */
#define NV_PFB_DELAY_1_WRITE_ENABLE_RISE                        1:0 /* RWIUF */
#define NV_PFB_DELAY_1_WRITE_ENABLE_RISE_0               0x00000000 /* RWI-V */
#define NV_PFB_DELAY_1_WRITE_ENABLE_FALL                        5:4 /* RWIUF */
#define NV_PFB_DELAY_1_WRITE_ENABLE_FALL_0               0x00000000 /* RWI-V */
#define NV_PFB_DELAY_1_CAS_ENABLE_RISE                          9:8 /* RWIUF */
#define NV_PFB_DELAY_1_CAS_ENABLE_RISE_0                 0x00000000 /* RWI-V */
#define NV_PFB_DELAY_1_CAS_ENABLE_FALL                        13:12 /* RWIUF */
#define NV_PFB_DELAY_1_CAS_ENABLE_FALL_0                 0x00000000 /* RWI-V */
#define NV_PFB_DELAY_1_OUTPUT_DATA                            17:16 /* RWIUF */
#define NV_PFB_DELAY_1_OUTPUT_DATA_0                     0x00000000 /* RWI-V */
#define NV_PFB_DELAY_1_RAS_ENABLE                             21:20 /* RWIUF */
#define NV_PFB_DELAY_1_RAS_ENABLE_0                      0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0                                   0x00100080 /* RW-4R */
#define NV_PFB_DEBUG_0_PAGE_MODE                                0:0 /* RWIVF */
#define NV_PFB_DEBUG_0_PAGE_MODE_ENABLED                 0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0_PAGE_MODE_DISABLED                0x00000001 /* RW--V */
#define NV_PFB_DEBUG_0_REFRESH                                  4:4 /* RWIVF */
#define NV_PFB_DEBUG_0_REFRESH_ENABLED                   0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0_REFRESH_DISABLED                  0x00000001 /* RW--V */
#define NV_PFB_DEBUG_0_REFRESH_COUNTX64                        12:8 /* RWIVF */
#define NV_PFB_DEBUG_0_REFRESH_COUNTX64_DEFAULT          0x00000010 /* RWI-V */
#define NV_PFB_DEBUG_0_CASOE                                  20:20 /* RWIVF */
#define NV_PFB_DEBUG_0_CASOE_ENABLED                     0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0_CASOE_DISABLED                    0x00000001 /* RW--V */
#define NV_PFB_DEBUG_0_CKE_INVERT                             28:28 /* RWIVF */
#define NV_PFB_DEBUG_0_CKE_INVERT_OFF                    0x00000000 /* RWIVF */
#define NV_PFB_DEBUG_0_CKE_INVERT_ON                     0x00000001 /* RW-VF */
#define NV_PFB_DEBUG_0_REFINC                                 29:29 /* RWIVF */
#define NV_PFB_DEBUG_0_REFINC_DISABLED                   0x00000000 /* RW-VF */
#define NV_PFB_DEBUG_0_REFINC_ENABLED                    0x00000001 /* RWIVF */
#define NV_PFB_DEBUG_0_SAVE_POWER                             30:30 /* RWIVF */
#define NV_PFB_DEBUG_0_SAVE_POWER_ON                     0x00000000 /* RWIVF */
#define NV_PFB_DEBUG_0_SAVE_POWER_OFF                    0x00000001 /* RW-VF */
#define NV_PFB_GREEN_0                                   0x001000C0 /* RW-4R */
#define NV_PFB_GREEN_0_LEVEL                                    1:0 /* RWIVF */
#define NV_PFB_GREEN_0_LEVEL_VIDEO_ENABLED               0x00000000 /* RW--V */
#define NV_PFB_GREEN_0_LEVEL_VIDEO_DISABLED              0x00000001 /* RW--V */
#define NV_PFB_GREEN_0_LEVEL_TIMING_DISABLED             0x00000002 /* RW--V */
#define NV_PFB_GREEN_0_LEVEL_MEMORY_DISABLED             0x00000003 /* RWI-V */
#define NV_PFB_CONFIG_0                                  0x00100200 /* RW-4R */
#define NV_PFB_CONFIG_0_TYPE                                   14:0 /* RWIVF */
#define NV_PFB_CONFIG_0_TYPE_OLD1024_FIXED_8BPP          0x00000120 /* RW-VF */
#define NV_PFB_CONFIG_0_TYPE_OLD1024_FIXED_16BPP         0x00000220 /* RW-VF */
#define NV_PFB_CONFIG_0_TYPE_OLD1024_FIXED_32BPP         0x00000320 /* RW-VF */
#define NV_PFB_CONFIG_0_TYPE_OLD1024_VAR_8BPP            0x00004120 /* RW-VF */
#define NV_PFB_CONFIG_0_TYPE_OLD1024_VAR_16BPP           0x00004220 /* RW-VF */
#define NV_PFB_CONFIG_0_TYPE_OLD1024_VAR_32BPP           0x00004320 /* RW-VF */
#define NV_PFB_CONFIG_0_TYPE_TETRIS                      0x00002000 /* RW-VF */
#define NV_PFB_CONFIG_0_TYPE_NOTILING                    0x00001114 /* RWIVF */
#define NV_PFB_CONFIG_0_TETRIS_MODE                           17:15 /* RWI-V */
#define NV_PFB_CONFIG_0_TETRIS_MODE_PASS                 0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_TETRIS_MODE_1                    0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_TETRIS_MODE_2                    0x00000002 /* RW--V */
#define NV_PFB_CONFIG_0_TETRIS_MODE_3                    0x00000003 /* RW--V */
#define NV_PFB_CONFIG_0_TETRIS_MODE_4                    0x00000004 /* RW--V */
#define NV_PFB_CONFIG_0_TETRIS_MODE_5                    0x00000005 /* RW--V */
#define NV_PFB_CONFIG_0_TETRIS_MODE_6                    0x00000006 /* RW--V */
#define NV_PFB_CONFIG_0_TETRIS_MODE_7                    0x00000007 /* RW--V */
#define NV_PFB_CONFIG_0_TETRIS_SHIFT                          19:18 /* RWI-V */
#define NV_PFB_CONFIG_0_TETRIS_SHIFT_0                   0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_TETRIS_SHIFT_1                   0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_TETRIS_SHIFT_2                   0x00000002 /* RW--V */
#define NV_PFB_CONFIG_0_BANK_SWAP                             22:20 /* RWI-V */
#define NV_PFB_CONFIG_0_BANK_SWAP_OFF                    0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_BANK_SWAP_1M                     0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_BANK_SWAP_2M                     0x00000005 /* RW--V */
#define NV_PFB_CONFIG_0_BANK_SWAP_4M                     0x00000007 /* RW--V */
#define NV_PFB_CONFIG_0_UNUSED                                23:23 /* RW--V */
#define NV_PFB_CONFIG_1                                  0x00100204 /* RW-4R */
#define NV_PFB_CONFIG_1_CAS_LATENCY                             2:0 /* RWIVF */
#define NV_PFB_CONFIG_1_CAS_LATENCY_3                    0x00000003 /* RWI-V */
#define NV_PFB_CONFIG_1_NEC_MODE                                3:3 /* RW-VF */
#define NV_PFB_CONFIG_1_NEC_MODE_DISABLED                0x00000000 /* RW--V */
#define NV_PFB_CONFIG_1_NEC_MODE_ENABLED                 0x00000001 /* RW--V */
#define NV_PFB_CONFIG_1_RAS_RAS                                 7:4 /* RWIUF */
#define NV_PFB_CONFIG_1_RAS_RAS_DEFAULT                  0x00000009 /* RWI-V */
#define NV_PFB_CONFIG_1_RAS_RAS_9CYCLES                  0x00000008 /* RW--V */
#define NV_PFB_CONFIG_1_RAS_PCHG                               10:8 /* RWIUF */
#define NV_PFB_CONFIG_1_RAS_PCHG_DEFAULT                 0x00000002 /* RWI-V */
#define NV_PFB_CONFIG_1_RAS_LOW                               14:12 /* RWIUF */
#define NV_PFB_CONFIG_1_RAS_LOW_DEFAULT                  0x00000006 /* RWI-V */
#define NV_PFB_CONFIG_1_MRS_TO_RAS                            18:16 /* RWIUF */
#define NV_PFB_CONFIG_1_MRS_TO_RAS_DEFAULT               0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_1_WRITE_TO_READ                         22:20 /* RWIUF */
#define NV_PFB_CONFIG_1_WRITE_TO_READ_DEFAULT            0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_1_RAS_TO_CAS_M1                         26:24 /* RWIUF */
#define NV_PFB_CONFIG_1_RAS_TO_CAS_M1_DEFAULT            0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_1_READ_TO_WRITE                         30:28 /* RWIUF */
#define NV_PFB_CONFIG_1_READ_TO_WRITE_DEFAULT            0x00000004 /* RWI-V */
#define NV_PFB_CONFIG_1_READ_TO_PCHG                          31:31 /* RWIUF */
#define NV_PFB_CONFIG_1_READ_TO_PCHG_ON                  0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_1_READ_TO_PCHG_OFF                 0x00000000 /* RW--V */
#define NV_PFB_CONFIG_1_ED_RAC1                                 0:0 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_RAC1_DEFAULT                  0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_1_ED_RWT1                                 1:1 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_RWT1_DEFAULT                  0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_1_ED_RPC1                                 2:2 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_RPC1_DEFAULT                  0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_1_ED_PMAW                                 4:4 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_PMAW_DEFAULT                  0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_1_ED_PAGE                                 5:5 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_PAGE_DEFAULT                  0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_1_ED_RAC0_0                               8:8 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_RAC0_0_DEFAULT                0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_1_ED_RAC0_1                               9:9 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_RAC0_1_DEFAULT                0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_1_ED_RAC1_0                             10:10 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_RAC1_0_DEFAULT                0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_1_ED_RAC1_1                             12:12 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_RAC1_1_DEFAULT                0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_1_ED_RAD0_0                             13:13 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_RAD0_0_DEFAULT                0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_1_ED_RAD0_1                             14:14 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_RAD0_1_DEFAULT                0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_1_ED_RPC0_0                             16:16 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_RPC0_0_DEFAULT                0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_1_ED_RPC0_1                             17:17 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_RPC0_1_DEFAULT                0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_1_ED_RPC1_0                             18:18 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_RPC1_0_DEFAULT                0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_1_ED_RPC1_1                             20:20 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_RPC1_1_DEFAULT                0x00000001 /* RWI-V */
#define NV_PFB_RTL                                       0x00100300 /* RW-4R */
#define NV_PFB_RTL_S                                            1:0 /* RWIUF */
#define NV_PFB_RTL_S_DEFAULT                             0x00000002 /* RWI-V */
#define NV_PFB_RTL_V                                            5:4 /* RWIUF */
#define NV_PFB_RTL_V_DEFAULT                             0x00000002 /* RWI-V */
#define NV_PFB_RTL_M                                            9:8 /* RWIUF */
#define NV_PFB_RTL_M_DEFAULT                             0x00000002 /* RWI-V */
#define NV_PFB_RTL_H                                          13:12 /* RWIUF */
#define NV_PFB_RTL_H_DEFAULT                             0x00000001 /* RWI-V */
#define NV_PFB_RTL_A                                          17:16 /* RWIUF */
#define NV_PFB_RTL_A_DEFAULT                             0x00000001 /* RWI-V */
#define NV_PFB_RTL_G                                          21:20 /* RWIUF */
#define NV_PFB_RTL_G_DEFAULT                             0x00000001 /* RWI-V */
#define NV_PFB_RTL_ARB_GR_HI_PRIOR                            24:24 /* RWIUF */
#define NV_PFB_RTL_ARB_GR_HI_PRIOR_DEFAULT               0x00000000 /* RWI-V */
#define NV_PFB_RTL_ARB_MEDIA_HI_PRIOR                         28:28 /* RWIUF */
#define NV_PFB_RTL_ARB_MEDIA_HI_PRIOR_DEFAULT            0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_RESOLUTION                              5:0 /* RWIVF */
#define NV_PFB_CONFIG_0_RESOLUTION_320_PIXELS            0x0000000a /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_400_PIXELS            0x0000000d /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_480_PIXELS            0x0000000f /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_512_PIXELS            0x00000010 /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_640_PIXELS            0x00000014 /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_800_PIXELS            0x00000019 /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_960_PIXELS            0x0000001e /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_1024_PIXELS           0x00000020 /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_1152_PIXELS           0x00000024 /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_1280_PIXELS           0x00000028 /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_1600_PIXELS           0x00000032 /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_DEFAULT               0x00000014 /* RWI-V */
#define NV_PFB_CONFIG_0_PIXEL_DEPTH                             9:8 /* RWIVF */
#define NV_PFB_CONFIG_0_PIXEL_DEPTH_8_BITS               0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_PIXEL_DEPTH_16_BITS              0x00000002 /* RW--V */
#define NV_PFB_CONFIG_0_PIXEL_DEPTH_32_BITS              0x00000003 /* RW--V */
#define NV_PFB_CONFIG_0_PIXEL_DEPTH_DEFAULT              0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING                                12:12 /* RWIVF */
#define NV_PFB_CONFIG_0_TILING_ENABLED                   0x00000000 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DISABLED                  0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG                          23:13 /* RWIVF */
#define NV_PFB_CONFIG_0_TILING_DEBUG_DISABLED            0x00000000 /* RW--V */
#define NV_PFB_CONFIG_0_TILE                                  14:12 /* RWIVF */
#define NV_PFB_CONFIG_0_TILE_OLD1024_FIXED               0x00000000 /* RW-VF */
#define NV_PFB_CONFIG_0_TILE_OLD1024_VARIABLE            0x00000004 /* RW-VF */
#define NV_PFB_CONFIG_0_TILE_TETRIS_ALLOW                0x00000001 /* RW-VF */
#define NV_PFB_CONFIG_0_TILE_TETRIS_REDUNDANT            0x00000002 /* RW-VF */
#define NV_PFB_CONFIG_0_TILE_TETRIS_REDUNDANT2           0x00000003 /* RW-VF */
#define NV_PFB_CONFIG_0_TILING_DEBUG_ON                       13:13 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_ON_ENABLED          0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_ON_DISABLED         0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TILESIZE                 14:14 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TILESIZE_FIXED      0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TILESIZE_VARIABLE   0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE              17:15 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE_PASS    0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE_1       0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE_2       0x00000002 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE_3       0x00000003 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE_4       0x00000004 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE_5       0x00000005 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE_6       0x00000006 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE_7       0x00000007 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_SHIFT             19:18 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_SHIFT_0      0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_SHIFT_1      0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_SHIFT_2      0x00000002 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_BANK_SWAP                20:20 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_BANK_SWAP_OFF       0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_BANK_SWAP_ON        0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_BANK_SWAP_MSB            22:21 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_BANK_SWAP_MSB_1M    0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_BANK_SWAP_MSB_2M    0x00000002 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_BANK_SWAP_MSB_4M    0x00000003 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_UNUSED                   23:23 /* RW--V */
#define NV_PFB_CONFIG_1_SGRAM100                                3:3 /* RWIVF */
#define NV_PFB_CONFIG_1_SGRAM100_ENABLED                 0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_1_SGRAM100_DISABLED                0x00000001 /* RW--V */
#define NV_PFB_DEBUG_0_CKE_ALWAYSON                           29:29 /* RWIVF */
#define NV_PFB_DEBUG_0_CKE_ALWAYSON_OFF                  0x00000000 /* RW-VF */
#define NV_PFB_DEBUG_0_CKE_ALWAYSON_ON                   0x00000001 /* RWIVF */
/* dev_framebuffer.ref */
#define NV_PNVM                               0x017FFFFF:0x01000000 /* RW--M */
#define NV_PNVM_DATA032(i)                       (0x01000000+(i)*4) /* RW-4A */
#define NV_PNVM_DATA032__SIZE_1                              524288 /*       */
#define NV_PNVM_DATA032_VALUE                                  31:0 /* RWXVF */
#define NV_PNVM_DATA024(i)           (0x01000000+((i)/2)*4+((i)%2)) /* RW-3A */
#define NV_PNVM_DATA024__SIZE_1                             1048576 /*       */
#define NV_PNVM_DATA024_VALUE                                  23:0 /* RWXVF */
#define NV_PNVM_DATA016(i)           (0x01000000+((i)/3)*4+((i)%3)) /* RW-2A */
#define NV_PNVM_DATA016__SIZE_1                             1572864 /*       */
#define NV_PNVM_DATA016_VALUE                                  15:0 /* RWXVF */
#define NV_PNVM_DATA008(i)                         (0x01000000+(i)) /* RW-1A */
#define NV_PNVM_DATA008__SIZE_1                             2097152 /*       */
#define NV_PNVM_DATA008_VALUE                                   7:0 /* RWXVF */
/* dev_framebuffer.ref */
#define NV_PRAMIN                             0x01FFFFFF:0x01C00000 /* RW--M */
#define NV_PRAMIN_DATA032(i)                       (0x01C00000+(i)*4) /* RW-4A */
#define NV_PRAMIN_DATA032__SIZE_1                              524288 /*       */
#define NV_PRAMIN_DATA032_VALUE                                  31:0 /* RWXVF */
#define NV_PRAMIN_DATA024(i)           (0x01C00000+((i)/2)*4+((i)%2)) /* RW-3A */
#define NV_PRAMIN_DATA024__SIZE_1                             1048576 /*       */
#define NV_PRAMIN_DATA024_VALUE                                  23:0 /* RWXVF */
#define NV_PRAMIN_DATA016(i)           (0x01C00000+((i)/3)*4+((i)%3)) /* RW-2A */
#define NV_PRAMIN_DATA016__SIZE_1                             1572864 /*       */
#define NV_PRAMIN_DATA016_VALUE                                  15:0 /* RWXVF */
#define NV_PRAMIN_DATA008(i)                         (0x01C00000+(i)) /* RW-1A */
#define NV_PRAMIN_DATA008__SIZE_1                             2097152 /*       */
#define NV_PRAMIN_DATA008_VALUE                                   7:0 /* RWXVF */
/* dev_ram.ref */
#define NV_PRAMIN                             0x01FFFFFF:0x01C00000 /* RW--M */
#define NV_PRAMIN_CONTEXT_0                   ( 0*32+31):( 0*32+ 0) /*       */
#define NV_PRAMIN_CONTEXT_1                   ( 1*32+31):( 1*32+ 0) /*       */
#define NV_PRAMIN_CONTEXT_2                   ( 2*32+31):( 2*32+ 0) /*       */
#define NV_PRAMIN_CONTEXT_3                   ( 3*32+31):( 3*32+ 0) /*       */
#define NV_PRAMIN_RAMHT_0                     0x01C00FFF:0x01C00000 /* RW--M */
#define NV_PRAMIN_RAMAU_0                     0x01C01BFF:0x01C01000 /* RW--M */
#define NV_PRAMIN_RAMFC_0                     0x01C01DFF:0x01C01C00 /* RW--M */
#define NV_PRAMIN_RAMRO_0                     0x01C01FFF:0x01C01E00 /* RW--M */
#define NV_PRAMIN_RAMRM_0                     0x01C02FFF:0x01C02000 /* RW--M */
/* dev_ram.ref */
#define NV_FIFO_DMA_METHOD_ADDRESS            ( 0*32+12):( 0*32+ 2) /* RWXUF */
#define NV_FIFO_DMA_METHOD_SUBCHANNEL         ( 0*32+15):( 0*32+13) /* RWXUF */
#define NV_FIFO_DMA_METHOD_COUNT              ( 0*32+28):( 0*32+18) /* RWXUF */
#define NV_FIFO_DMA_DATA                      ( 1*32+31):( 1*32+ 0) /* RWXUF */
/* dev_framebuffer.ref */
#define NV_PDFB                               0x017FFFFF:0x01000000 /* RW--D */
#define NV_PDFB_DATA032(i)                       (0x01000000+(i)*4) /* RW-4A */
#define NV_PDFB_DATA032__SIZE_1                              524288 /*       */
#define NV_PDFB_DATA032_VALUE                                  31:0 /* RWXVF */
#define NV_PDFB_DATA024(i)           (0x01000000+((i)/2)*4+((i)%2)) /* RW-3A */
#define NV_PDFB_DATA024__SIZE_1                             1048576 /*       */
#define NV_PDFB_DATA024_VALUE                                  23:0 /* RWXVF */
#define NV_PDFB_DATA016(i)           (0x01000000+((i)/3)*4+((i)%3)) /* RW-2A */
#define NV_PDFB_DATA016__SIZE_1                             1572864 /*       */
#define NV_PDFB_DATA016_VALUE                                  15:0 /* RWXVF */
#define NV_PDFB_DATA008(i)                         (0x01000000+(i)) /* RW-1A */
#define NV_PDFB_DATA008__SIZE_1                             2097152 /*       */
#define NV_PDFB_DATA008_VALUE                                   7:0 /* RWXVF */
/* dev_ram.ref */
#define NV_PRAM                               0x00006FFF:0x00006000 /* RW--D */
/* dev_ext_devices.ref */
#define NV_PEXTDEV                            0x00101FFF:0x00101000 /* RW--D */
#define NV_PEXTDEV_BOOT_0                                0x00101000 /* RW-4R */
#define NV_PEXTDEV_BOOT_0_STRAP_BUS_SPEED                       0:0 /* RWXVF */
#define NV_PEXTDEV_BOOT_0_STRAP_BUS_SPEED_33MHZ          0x00000000 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_BUS_SPEED_66MHZ          0x00000001 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_SUB_VENDOR                      1:1 /* RWXVF */
#define NV_PEXTDEV_BOOT_0_STRAP_SUB_VENDOR_NO_BIOS       0x00000000 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_SUB_VENDOR_BIOS          0x00000001 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE                        2:2 /* RWXVF */
#define NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE_SGRAM_16MBIT    0x00000000 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE_SGRAM_8MBIT     0x00000001 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_NEC_MODE                        3:3 /* RWXVF */
#define NV_PEXTDEV_BOOT_0_STRAP_NEC_MODE_OFF             0x00000000 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_NEC_MODE_ON              0x00000001 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_RAM_WIDTH                       4:4 /* RWXVF */
#define NV_PEXTDEV_BOOT_0_STRAP_RAM_WIDTH_64             0x00000000 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_RAM_WIDTH_128            0x00000001 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_BUS_TYPE                        5:5 /* RWXVF */
#define NV_PEXTDEV_BOOT_0_STRAP_BUS_TYPE_PCI             0x00000000 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_BUS_TYPE_AGP             0x00000001 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL                         6:6 /* RWXVF */
#define NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL_13500K           0x00000000 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL_14318180         0x00000001 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_TVMODE                          8:7 /* RWXVF */
#define NV_PEXTDEV_BOOT_0_STRAP_TVMODE_SECAM             0x00000000 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_TVMODE_NTSC              0x00000001 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_TVMODE_PAL               0x00000002 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_TVMODE_DISABLED          0x00000003 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_AGP_2X                          9:9 /* RWXVF */
#define NV_PEXTDEV_BOOT_0_STRAP_AGP_2X_ENABLED           0x00000000 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_AGP_2X_DISABLED          0x00000001 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_UNUSED                        10:10 /* RWXVF */
#define NV_PEXTDEV_BOOT_0_STRAP_OVERWRITE                     11:11 /* RWIVF */
#define NV_PEXTDEV_BOOT_0_STRAP_OVERWRITE_DISABLED       0x00000000 /* RWI-V */
#define NV_PEXTDEV_BOOT_0_STRAP_OVERWRITE_ENABLED        0x00000001 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE_EDO             0x00000000 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE_SGRAM_256K      0x00000001 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE_NEC_EDO         0x00000002 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE_NEC_SGRAM       0x00000003 /* R---V */
/* dev_ext_devices.ref */
#define NV_PDAC                               0x00680FFF:0x00680000 /* RW--D */
#define NV_PDAC_DATA(i)                          (0x00500000+(i)*4) /* RW-4A */
#define NV_PDAC_DATA__SIZE_1                                     16 /*       */
#define NV_PDAC_DATA_VALUE                                      7:0 /* RW-VF */
/* dev_ext_devices.ref */
/* dev_ext_devices.ref */
#define NV_PROM                               0x0011FFFF:0x00110000 /* RW--D */
#define NV_PROM_DATA(i)                            (0x00110000+(i)) /* RW-1A */
#define NV_PROM_DATA__SIZE_1                                  65536 /*       */
#define NV_PROM_DATA_VALUE                                      7:0 /* RW-VF */
/* dev_ext_devices.ref */
#define NV_PALT                               0x0012FFFF:0x00120000 /* RW--D */
#define NV_PALT_DATA(i)                            (0x00120000+(i)) /* RW-1A */
#define NV_PALT_DATA__SIZE_1                                  65536 /*       */
#define NV_PALT_DATA_VALUE                                      7:0 /* RW-VF */
/* dev_realmode.ref */
#define NV_PRM                                0x00005FFF:0x00004000 /* RW--D */
#define NV_PRM_INTR_0                                    0x00004100 /* RW-4R */
#define NV_PRM_INTR_0_TRACE_MPU401                              0:0 /* RWXVF */
#define NV_PRM_INTR_0_TRACE_MPU401_NOT_PENDING           0x00000000 /* R---V */
#define NV_PRM_INTR_0_TRACE_MPU401_PENDING               0x00000001 /* R---V */
#define NV_PRM_INTR_0_TRACE_MPU401_RESET                 0x00000001 /* -W--V */
#define NV_PRM_INTR_0_TRACE_FM                                  4:4 /* RWXVF */
#define NV_PRM_INTR_0_TRACE_FM_NOT_PENDING               0x00000000 /* R---V */
#define NV_PRM_INTR_0_TRACE_FM_PENDING                   0x00000001 /* R---V */
#define NV_PRM_INTR_0_TRACE_FM_RESET                     0x00000001 /* -W--V */
#define NV_PRM_INTR_0_TRACE_SB_DIGITAL                          8:8 /* RWXVF */
#define NV_PRM_INTR_0_TRACE_SB_DIGITAL_NOT_PENDING       0x00000000 /* R---V */
#define NV_PRM_INTR_0_TRACE_SB_DIGITAL_PENDING           0x00000001 /* R---V */
#define NV_PRM_INTR_0_TRACE_SB_DIGITAL_RESET             0x00000001 /* -W--V */
#define NV_PRM_INTR_0_TRACE_SB_MIXER                          12:12 /* RWXVF */
#define NV_PRM_INTR_0_TRACE_SB_MIXER_NOT_PENDING         0x00000000 /* R---V */
#define NV_PRM_INTR_0_TRACE_SB_MIXER_PENDING             0x00000001 /* R---V */
#define NV_PRM_INTR_0_TRACE_SB_MIXER_RESET               0x00000001 /* -W--V */
#define NV_PRM_INTR_0_TRACE_OVERFLOW                          16:16 /* RWXVF */
#define NV_PRM_INTR_0_TRACE_OVERFLOW_NOT_PENDING         0x00000000 /* R---V */
#define NV_PRM_INTR_0_TRACE_OVERFLOW_PENDING             0x00000001 /* R---V */
#define NV_PRM_INTR_0_TRACE_OVERFLOW_RESET               0x00000001 /* -W--V */
#define NV_PRM_INTR_EN_0                                 0x00004140 /* RW-4R */
#define NV_PRM_INTR_EN_0_TRACE_MPU401                           0:0 /* RWIVF */
#define NV_PRM_INTR_EN_0_TRACE_MPU401_DISABLED           0x00000000 /* RWI-V */
#define NV_PRM_INTR_EN_0_TRACE_MPU401_ENABLED            0x00000001 /* RW--V */
#define NV_PRM_INTR_EN_0_TRACE_FM                               4:4 /* RWIVF */
#define NV_PRM_INTR_EN_0_TRACE_FM_DISABLED               0x00000000 /* RWI-V */
#define NV_PRM_INTR_EN_0_TRACE_FM_ENABLED                0x00000001 /* RW--V */
#define NV_PRM_INTR_EN_0_TRACE_SB_DIGITAL                       8:8 /* RWIVF */
#define NV_PRM_INTR_EN_0_TRACE_SB_DIGITAL_DISABLED       0x00000000 /* RWI-V */
#define NV_PRM_INTR_EN_0_TRACE_SB_DIGITAL_ENABLED        0x00000001 /* RW--V */
#define NV_PRM_INTR_EN_0_TRACE_SB_MIXER                       12:12 /* RWIVF */
#define NV_PRM_INTR_EN_0_TRACE_SB_MIXER_DISABLED         0x00000000 /* RWI-V */
#define NV_PRM_INTR_EN_0_TRACE_SB_MIXER_ENABLED          0x00000001 /* RW--V */
#define NV_PRM_INTR_EN_0_TRACE_OVERFLOW                       16:16 /* RWIVF */
#define NV_PRM_INTR_EN_0_TRACE_OVERFLOW_DISABLED         0x00000000 /* RWI-V */
#define NV_PRM_INTR_EN_0_TRACE_OVERFLOW_ENABLED          0x00000001 /* RW--V */
#define NV_PRM_RAMRM                                     0x00004200 /* RW-4R */
#define NV_PRM_RAMRM_BASE_ADDRESS                             15:12 /* RWXVF */
#define NV_PRM_RAMRM_BASE_ADDRESS_2000                   0x00002000 /* RWI-V */
#define NV_PRM_TRACE                                     0x00004300 /* RW-4R */
#define NV_PRM_TRACE_IO_CAPTURE                                 1:0 /* RWIVF */
#define NV_PRM_TRACE_IO_CAPTURE_DISABLED                 0x00000000 /* RWI-V */
#define NV_PRM_TRACE_IO_CAPTURE_WRITES                   0x00000001 /* RW--V */
#define NV_PRM_TRACE_IO_CAPTURE_READS                    0x00000002 /* RW--V */
#define NV_PRM_TRACE_IO_CAPTURE_READS_WRITES             0x00000003 /* RW--V */
#define NV_PRM_TRACE_IO_WRITE                                   4:4 /* RWXVF */
#define NV_PRM_TRACE_IO_WRITE_NONE                       0x00000000 /* R---V */
#define NV_PRM_TRACE_IO_WRITE_OCCURED                    0x00000001 /* R---V */
#define NV_PRM_TRACE_IO_WRITE_RESET                      0x00000001 /* -W--V */
#define NV_PRM_TRACE_IO_READ                                    5:5 /* RWXVF */
#define NV_PRM_TRACE_IO_READ_NONE                        0x00000000 /* R---V */
#define NV_PRM_TRACE_IO_READ_OCCURED                     0x00000001 /* R---V */
#define NV_PRM_TRACE_IO_READ_RESET                       0x00000001 /* -W--V */
#define NV_PRM_TRACE_INDEX                               0x00004310 /* RW-4R */
#define NV_PRM_TRACE_INDEX_ADDRESS                              9:0 /* RWXUF */
#define NV_PRM_TRACE_INDEX_ADDRESS_0                     0x00000000 /* RW--V */
#define NV_PRM_IGNORE_0                                  0x00004320 /* RW-4R */
#define NV_PRM_IGNORE_0_MPU401                                  1:0 /* RWXVF */
#define NV_PRM_IGNORE_0_MPU401_DISABLED                  0x00000000 /* RW--V */
#define NV_PRM_IGNORE_0_MPU401_WRITES                    0x00000001 /* RW--V */
#define NV_PRM_IGNORE_0_MPU401_READS                     0x00000002 /* RW--V */
#define NV_PRM_IGNORE_0_MPU401_READS_WRITES              0x00000003 /* RW--V */
#define NV_PRM_IGNORE_0_FM                                      5:4 /* RWXVF */
#define NV_PRM_IGNORE_0_FM_DISABLED                      0x00000000 /* RW--V */
#define NV_PRM_IGNORE_0_FM_WRITES                        0x00000001 /* RW--V */
#define NV_PRM_IGNORE_0_FM_READS                         0x00000002 /* RW--V */
#define NV_PRM_IGNORE_0_FM_READS_WRITES                  0x00000003 /* RW--V */
#define NV_PRM_IGNORE_0_SB_DIGITAL                              9:8 /* RWXVF */
#define NV_PRM_IGNORE_0_SB_DIGITAL_DISABLED              0x00000000 /* RW--V */
#define NV_PRM_IGNORE_0_SB_DIGITAL_WRITES                0x00000001 /* RW--V */
#define NV_PRM_IGNORE_0_SB_DIGITAL_READS                 0x00000002 /* RW--V */
#define NV_PRM_IGNORE_0_SB_DIGITAL_READS_WRITES          0x00000003 /* RW--V */
#define NV_PRM_IGNORE_0_SB_MIXER                              13:12 /* RWXVF */
#define NV_PRM_IGNORE_0_SB_MIXER_DISABLED                0x00000000 /* RW--V */
#define NV_PRM_IGNORE_0_SB_MIXER_WRITES                  0x00000001 /* RW--V */
#define NV_PRM_IGNORE_0_SB_MIXER_READS                   0x00000002 /* RW--V */
#define NV_PRM_IGNORE_0_SB_MIXER_READS_WRITES            0x00000003 /* RW--V */
/* dev_realmode.ref */
#define NV_PRMIO                              0x00007FFF:0x00007000 /* RW--D */
/* dev_realmode.ref */
/* dev_fifo.ref */
#define NV_USER                               0x00FFFFFF:0x00800000 /* RW--D */
#define NV_USER_OBJECT(i,j)     (0x00800000+(i)*0x10000+(j)*0x2000) /* -W-4A */
#define NV_USER_OBJECT__SIZE_1                                  128 /*       */
#define NV_USER_OBJECT__SIZE_2                                    8 /*       */
#define NV_USER_OBJECT_HANDLE                                  31:0 /* -W-VF */
#define NV_USER_FREE016(i,j)        (0x00800010+(i)*65536+(j)*8192) /* R--2A */
#define NV_USER_FREE016__SIZE_1                                 128 /*       */
#define NV_USER_FREE016__SIZE_2                                   8 /*       */
#define NV_USER_FREE016_COUNT_LO                                1:0 /* C--UF */
#define NV_USER_FREE016_COUNT_LO_0                       0x00000000 /* C---V */
#define NV_USER_FREE016_COUNT                                   9:2 /* R--UF */
#define NV_USER_FREE016_COUNT_HI                              15:10 /* C--UF */
#define NV_USER_FREE016_COUNT_HI_0                       0x00000000 /* C---V */
#define NV_USER_FREE032(i,j)        (0x00800010+(i)*65536+(j)*8192) /* R--4A */
#define NV_USER_FREE032__SIZE_1                                 128 /*       */
#define NV_USER_FREE032__SIZE_2                                   8 /*       */
#define NV_USER_FREE032_COUNT_LO                                1:0 /* C--UF */
#define NV_USER_FREE032_COUNT_LO_0                       0x00000000 /* C---V */
#define NV_USER_FREE032_COUNT                                   9:2 /* R--UF */
#define NV_USER_FREE032_COUNT_HI                              31:10 /* C--UF */
#define NV_USER_FREE032_COUNT_HI_0                       0x00000000 /* C---V */
#define NV_USER_ZERO016(i,j,k) (0x0800012+(i)*65536+(j)*8192+(k)*2) /* R--2A */
#define NV_USER_ZERO016__SIZE_1                                 128 /*       */
#define NV_USER_ZERO016__SIZE_2                                   8 /*       */
#define NV_USER_ZERO016__SIZE_3                                   7 /*       */
#define NV_USER_ZERO016_COUNT                                  15:0 /* C--UF */
#define NV_USER_ZERO016_COUNT_0                          0x00000000 /* C---V */
#define NV_USER_ZERO032(i,j,k) (0x0800014+(i)*65536+(j)*8192+(k)*4) /* R--4A */
#define NV_USER_ZERO032__SIZE_1                                 128 /*       */
#define NV_USER_ZERO032__SIZE_2                                   8 /*       */
#define NV_USER_ZERO032__SIZE_3                                   3 /*       */
#define NV_USER_ZERO032_COUNT                                  31:0 /* C--UF */
#define NV_USER_ZERO032_COUNT_0                          0x00000000 /* C---V */
/* dev_misc.ref */
#define NV_USER_ADR_CHID                                      22:16 /*       */
#define NV_USER_ADR_SUBCHID                                   15:13 /*       */
#define NV_USER_ADR_METHOD                                     12:0 /*       */
#define NV_USER_DEVICE                                        22:16 /*       */
/* dev_timer.ref */
#define NV_PTIMER                             0x00009FFF:0x00009000 /* RW--D */
#define NV_PTIMER_INTR_0                                 0x00009100 /* RW-4R */
#define NV_PTIMER_INTR_0_ALARM                                  0:0 /* RWXVF */
#define NV_PTIMER_INTR_0_ALARM_NOT_PENDING               0x00000000 /* R---V */
#define NV_PTIMER_INTR_0_ALARM_PENDING                   0x00000001 /* R---V */
#define NV_PTIMER_INTR_0_ALARM_RESET                     0x00000001 /* -W--V */
#define NV_PTIMER_INTR_EN_0                              0x00009140 /* RW-4R */
#define NV_PTIMER_INTR_EN_0_ALARM                               0:0 /* RWIVF */
#define NV_PTIMER_INTR_EN_0_ALARM_DISABLED               0x00000000 /* RWI-V */
#define NV_PTIMER_INTR_EN_0_ALARM_ENABLED                0x00000001 /* RW--V */
#define NV_PTIMER_NUMERATOR                              0x00009200 /* RW-4R */
#define NV_PTIMER_NUMERATOR_VALUE                              15:0 /* RWIUF */
#define NV_PTIMER_NUMERATOR_VALUE_0                      0x00000000 /* RWI-V */
#define NV_PTIMER_DENOMINATOR                            0x00009210 /* RW-4R */
#define NV_PTIMER_DENOMINATOR_VALUE                            15:0 /* RWIUF */
#define NV_PTIMER_DENOMINATOR_VALUE_0                    0x00000000 /* RWI-V */
#define NV_PTIMER_TIME_0                                 0x00009400 /* RW-4R */
#define NV_PTIMER_TIME_0_NSEC                                  31:5 /* RWXUF */
#define NV_PTIMER_TIME_1                                 0x00009410 /* RW-4R */
#define NV_PTIMER_TIME_1_NSEC                                  28:0 /* RWXUF */
#define NV_PTIMER_ALARM_0                                0x00009420 /* RW-4R */
#define NV_PTIMER_ALARM_0_NSEC                                 31:5 /* RWXUF */
/* dev_realmode.ref */
#define NV_TRACE                              0x0000FFFF:0x00000000 /* RW--M */
#define NV_TRACE_DATA                         ( 0*32+ 7):( 0*32+ 0) /* RWXVF */
#define NV_TRACE_ACCESS                       ( 0*32+14):( 0*32+14) /* RWXVF */
#define NV_TRACE_ACCESS_WRITE                            0x00000000 /* RW--V */
#define NV_TRACE_ACCESS_READ                             0x00000001 /* RW--V */
#define NV_TRACE_TYPE                         ( 0*32+15):( 0*32+15) /* RWXVF */
#define NV_TRACE_TYPE_IO                                 0x00000000 /* RW--V */
#define NV_TRACE_TYPE_MEMORY                             0x00000001 /* RW--V */
#define NV_TRACE_ADDRESS                      ( 0*32+31):( 0*32+16) /* RWXUF */
/* dev_ram.ref */
#define NV_RAMHT__SIZE_0                      0x00000FFF:0x00000000 /* RW--M */
#define NV_RAMHT__SIZE_1                      0x00001FFF:0x00000000 /* RW--M */
#define NV_RAMHT__SIZE_2                      0x00003FFF:0x00000000 /* RW--M */
#define NV_RAMHT__SIZE_3                      0x00007FFF:0x00000000 /* RW--M */
#define NV_RAMHT_HANDLE                       ( 0*32+31):( 0*32+ 0) /* RWXVF */
#define NV_RAMHT_INSTANCE                     ( 1*32+15):( 1*32+ 0) /* RWXUF */
#define NV_RAMHT_DEVICE                       ( 1*32+22):( 1*32+16) /* RWXUF */
#define NV_RAMHT_ENGINE                       ( 1*32+23):( 1*32+23) /* RWXVF */
#define NV_RAMHT_ENGINE_SW                               0x00000000 /* RW--V */
#define NV_RAMHT_ENGINE_GRAPHICS                         0x00000001 /* RW--V */
#define NV_RAMHT_CHID                         ( 1*32+30):( 1*32+24) /* RWXUF */
/* dev_ram.ref */
#define NV_RAMRO__SIZE_0                      0x000001FF:0x00000000 /* RW--M */
#define NV_RAMRO__SIZE_1                      0x00001FFF:0x00000000 /* RW--M */
#define NV_RAMRO_METHOD                       ( 0*32+15):( 0*32+ 0) /* RWXUF */
#define NV_RAMRO_CHID                         ( 0*32+22):( 0*32+16) /* RWXUF */
#define NV_RAMRO_TYPE                         ( 0*32+23):( 0*32+23) /* RWXVF */
#define NV_RAMRO_TYPE_WRITE                              0x00000000 /* RW--V */
#define NV_RAMRO_TYPE_READ                               0x00000001 /* RW--V */
#define NV_RAMRO_BYTE_ENABLES                 ( 0*32+27):( 0*32+24) /* RWXVF */
#define NV_RAMRO_REASON                       ( 0*32+31):( 0*32+28) /* RWXVF */
#define NV_RAMRO_REASON_ILLEGAL_ACCESS                   0x00000000 /* RW--V */
#define NV_RAMRO_REASON_NO_CACHE_AVAILABLE               0x00000001 /* RW--V */
#define NV_RAMRO_REASON_CACHE_RAN_OUT                    0x00000002 /* RW--V */
#define NV_RAMRO_REASON_FREE_COUNT_OVERRUN               0x00000003 /* RW--V */
#define NV_RAMRO_REASON_CAUGHT_LYING                     0x00000004 /* RW--V */
#define NV_RAMRO_REASON_RESERVED_ACCESS                  0x00000005 /* RW--V */
#define NV_RAMRO_DATA                         ( 1*32+31):( 1*32+ 0) /* RWXVF */
/* dev_ram.ref */
/* dev_ram.ref */
#define NV_RAMFC__SIZE_0                      0x000001FF:0x00000000 /* RW--M */
#define NV_RAMFC__SIZE_1                      0x00000FFF:0x00000000 /* RW--M */
#define NV_RAMFC_INSTANCE_0                   ( 0*32+15):( 0*32+ 0) /* RWXUF */
#define NV_RAMFC_DEVICE_0                     ( 0*32+22):( 0*32+16) /* RWXUF */
#define NV_RAMFC_DEVICE_0_NOT_FOUND                      0x00000000 /* RW--V */
#define NV_RAMFC_ENGINE_0                     ( 0*32+23):( 0*32+23) /* RWXVF */
#define NV_RAMFC_ENGINE_0_SW                             0x00000000 /* RW--V */
#define NV_RAMFC_ENGINE_0_GRAPHICS                       0x00000001 /* RW--V */
#define NV_RAMFC_INSTANCE_1                   ( 1*32+15):( 1*32+ 0) /* RWXUF */
#define NV_RAMFC_DEVICE_1                     ( 1*32+22):( 1*32+16) /* RWXUF */
#define NV_RAMFC_DEVICE_1_NOT_FOUND                      0x00000000 /* RW--V */
#define NV_RAMFC_ENGINE_1                     ( 1*32+23):( 1*32+23) /* RWXVF */
#define NV_RAMFC_ENGINE_1_SW                             0x00000000 /* RW--V */
#define NV_RAMFC_ENGINE_1_GRAPHICS                       0x00000001 /* RW--V */
#define NV_RAMFC_INSTANCE_7                   ( 7*32+15):( 7*32+ 0) /* RWXUF */
#define NV_RAMFC_DEVICE_7                     ( 7*32+22):( 7*32+16) /* RWXUF */
#define NV_RAMFC_DEVICE_7_NOT_FOUND                      0x00000000 /* RW--V */
#define NV_RAMFC_ENGINE_7                     ( 7*32+23):( 7*32+23) /* RWXVF */
#define NV_RAMFC_ENGINE_7_SW                             0x00000000 /* RW--V */
#define NV_RAMFC_ENGINE_7_GRAPHICS                       0x00000001 /* RW--V */
/* dev_ram.ref */
/* dev_ram.ref */
/* dev_ram.ref */
#define NV_DMA_ADJUST                         ( 0*32+11):( 0*32+ 0) /* RWXUF */
#define NV_DMA_PAGE_TABLE                     ( 0*32+16):( 0*32+16) /* RWXVF */
#define NV_DMA_PAGE_TABLE_NOT_PRESENT                    0x00000000 /* RW--V */
#define NV_DMA_PAGE_TABLE_PRESENT                        0x00000001 /* RW--V */
#define NV_DMA_TARGET_NODE                    ( 0*32+25):( 0*32+24) /* RWXVF */
#define NV_DMA_TARGET_NODE_NVM                           0x00000000 /* RW--V */
#define NV_DMA_TARGET_NODE_PCI                           0x00000002 /* RW--V */
#define NV_DMA_TARGET_NODE_AGP                           0x00000003 /* RW--V */
#define NV_DMA_LIMIT                          ( 1*32+31):( 1*32+ 0) /* RWXUF */
#define NV_DMA_PAGE                           ( 2*32+ 0):( 2*32+ 0) /* RWXVF */
#define NV_DMA_PAGE_NOT_PRESENT                          0x00000000 /* RW--V */
#define NV_DMA_PAGE_PRESENT                              0x00000001 /* RW--V */
#define NV_DMA_ACCESS                         ( 2*32+ 1):( 2*32+ 1) /* RWXVF */
#define NV_DMA_ACCESS_READ_ONLY                          0x00000000 /* RW--V */
#define NV_DMA_ACCESS_READ_AND_WRITE                     0x00000001 /* RW--V */
#define NV_DMA_FRAME_ADDRESS                  ( 2*32+31):( 2*32+12) /* RWXUF */
/* dev_ram.ref */
#define NV_SUBCHAN_CTX_SWITCH                 ( 0*32+31):( 0*32+ 0) /* RWXUF */
#define NV_SUBCHAN_DMA_INSTANCE               ( 1*32+15):( 1*32+ 0) /* RWXUF */
#define NV_SUBCHAN_NOTIFY_INSTANCE            ( 1*32+31):( 1*32+16) /* RWXUF */
#define NV_SUBCHAN_MEMFMT_INSTANCE            ( 2*32+15):( 2*32+ 0) /* RWXUF */
#define NV_SUBCHAN_MEMFMT_LINEAR              ( 2*32+16):( 2*32+16) /* RWXUF */
#define NV_SUBCHAN_MEMFMT_LINEAR_OUT                     0x00000000 /* RW--V */
#define NV_SUBCHAN_MEMFMT_LINEAR_IN                      0x00000001 /* RW--V */
/* dev_ram.ref */
/* dev_ram.ref */
/* dev_ram.ref */
#endif /* _NV_REF_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\nvapi.h ===
// NV API definitions
#ifdef __cplusplus
extern "C" {
#endif // __cplusplus
typedef HANDLE NVDESCRIPTOR;
#define NV_DEVICE_NAME_LENGTH_MAX 127
#define NVARCH_INVALID_NVDESCRIPTOR 0
#define NVARCH_INVALID_CLIENT_HANDLE 0

// the following is used to open the RM -- this will go away when RM is in MP
#define NVAPI_IOCTL_OPEN    NV_IOCTL_CODE(0x0100)
#define NVAPI_IOCTL_CLOSE   NV_IOCTL_CODE(0x0101)
HANDLE  __cdecl NvOpen          (HANDLE);
VOID    __cdecl NvClose         (HANDLE);

// control codes
ULONG __cdecl NvAllocRoot       (HANDLE, ULONG, ULONG*);
ULONG __cdecl NvAllocDevice     (HANDLE, ULONG, ULONG, ULONG, PUCHAR);
ULONG __cdecl NvAllocContextDma (HANDLE, ULONG, ULONG, ULONG, ULONG, PVOID, ULONG);
ULONG __cdecl NvAllocChannelPio (HANDLE, ULONG, ULONG, ULONG, ULONG, ULONG, PVOID*, ULONG);
ULONG __cdecl NvAllocChannelDma (HANDLE, ULONG, ULONG, ULONG, ULONG, ULONG, ULONG, ULONG, PVOID*);
ULONG __cdecl NvAllocEvent      (HANDLE, ULONG, ULONG, ULONG, ULONG, ULONG, 
#ifdef _WIN64
                                 PVOID);
#else
                                 ULONG);
#endif
ULONG __cdecl NvAllocMemory     (HANDLE, ULONG, ULONG, ULONG, ULONG, ULONG, PVOID*, ULONG*);
ULONG __cdecl NvAllocObject     (HANDLE, ULONG, ULONG, ULONG, ULONG);
ULONG __cdecl NvAlloc           (HANDLE, ULONG, ULONG, ULONG, ULONG, PVOID);
ULONG __cdecl NvFree            (HANDLE, ULONG, ULONG, ULONG);
ULONG __cdecl NvDmaFlowControl  (HANDLE, ULONG, ULONG, ULONG, ULONG);
//ULONG     NvDmaPushMutexState (HANDLE, DWORD);
ULONG __cdecl NvArchHeap        (HANDLE, PVOID);
ULONG __cdecl NvConfigVersion   (HANDLE, ULONG, ULONG, ULONG*);
ULONG __cdecl NvConfigGet       (HANDLE, ULONG, ULONG, ULONG, ULONG*);
ULONG __cdecl NvConfigSet       (HANDLE, ULONG, ULONG, ULONG, ULONG, ULONG*);
ULONG __cdecl NvConfigGetEx     (HANDLE, ULONG, ULONG, ULONG, PVOID, ULONG);
ULONG __cdecl NvConfigSetEx     (HANDLE, ULONG, ULONG, ULONG, PVOID, ULONG);
ULONG __cdecl NvConfigUpdate    (HANDLE, ULONG, ULONG, ULONG);
ULONG __cdecl NvGetDmaPushInfo  (HANDLE, ULONG, ULONG, ULONG, ULONG,ULONG);
ULONG         NvRmDebugControl  (HANDLE, ULONG, ULONG, PVOID);
ULONG __cdecl NvDirectMethodCall(HANDLE, ULONG, ULONG, ULONG, ULONG, ULONG);

#ifdef __cplusplus
}
#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\nvalpha.h ===
//******************************************************************************
// 
// Copyright (c) 1992  Microsoft Corporation
// 
// Module Name:
// 
//     nvsubch.h
// 
// Abstract:
// 
//     This module contains the object subchannel definitions 
// 
// Environment:
// 
//     Kernel mode
// 
// Revision History:
// 
// 
//******************************************************************************

//******************************************************************************
// 
// Copyright (c) 1996,1997  NVidia Corporation. All Rights Reserved
// 
//******************************************************************************

//******************************************************************************
// Values used to ENABLE and DISABLE color keying
//******************************************************************************

#define NV_ALPHA_1_32         0xff000000
#define NV_ALPHA_1_16         0x00008000
#define NV_ALPHA_1_08         0x0000ff00

#define NV_ALPHA_1_565        0xffff0000
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\nvntddctl.h ===
// display driver - to - miniport IOCTL's

// device type and base control code
#define FILE_DEVICE_NVRM 	0x00008000
#define NVRM_IOCTL_INDEX 	0x00000800
#define NV_IOCTL_CODE(f)		  	\
	CTL_CODE(                   	\
		FILE_DEVICE_NVRM+(f),   	\
		NVRM_IOCTL_INDEX,     		\
		METHOD_BUFFERED,        	\
		FILE_ANY_ACCESS         	\
	)

//
#define NVDD_IOCTL_CLOSE_RESOURCE_MANAGER	NV_IOCTL_CODE(0x0FFC)
#define NVDD_IOCTL_OPEN_RESOURCE_MANAGER	NV_IOCTL_CODE(0x0FFD)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\nvdat.c ===
//******************************************************************************
//
// Copyright (c) 1992  Microsoft Corporation
//
// Module Name:
//
//     NVDAT.C
//
// Abstract:
//
//     This module contains all the global data used by the NV driver.
//
// Environment:
//
//     Kernel mode
//
// Revision History:
//
//
//******************************************************************************

//******************************************************************************
//
// Copyright (c) 1996,1997  NVidia Corporation. All Rights Reserved
//
//******************************************************************************


#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"

#include "nv.h"

#include "cmdcnst.h"

#if defined(ALLOC_PRAGMA)
#pragma data_seg("PAGE")
#endif

//
// This structure describes to which ports access is required.
//

VIDEO_ACCESS_RANGE VgaAccessRange[] = {
{
    VGA_BASE_IO_PORT, 0x00000000,                // 64-bit linear base address
                                                 // of range
    VGA_MAX_IO_PORT - VGA_BASE_IO_PORT + 1, // # of ports
    1,                                           // range is in I/O space
    1,                                           // range should be visible
    0                                            // range should be shareable
},
{
    VGA_END_BREAK_PORT, 0x00000000,
    VGA_MAX_IO_PORT - VGA_END_BREAK_PORT + 1,
    1,
    1,
    0
},
{
    0x000A0000, 0x00000000,
    0x00020000,
    0,
    1,
    0
},

//
// Linear frame buffer access range (uninitialized)
//

{
    0x00000000, 0x00000000,
    0x00000000,
    0,
    1,
    0
}
};




//******************************************************************************
//
// VGA Palette Access Range
//
//******************************************************************************

VIDEO_ACCESS_RANGE VgaPaletteAccessRange   =
    {
    0x3c8, 0x00000000,                           // 64-bit linear base address
                                                 // of range
    2,                                           // # of ports
    1,                                           // range is in I/O space
    1,                                           // range should be visible
    1                                            // range should be shareable
    };




//
// PUBLIC ACCESS RANGE OFFSETS
//
// This table contains the offsets from the start of the base physical address
//

RANGE_OFFSETS RangeOffsets[NV_NUM_RANGES];





//
// Validator Port list.
// This structure describes all the ports that must be hooked out of the V86
// emulator when a DOS app goes to full-screen mode.
// The structure determines to which routine the data read or written to a
// specific port should be sent.
//

//EMULATOR_ACCESS_ENTRY VgaEmulatorAccessEntries[] = {
//
//    //
//    // Traps for byte OUTs.
//    //
//
//    {
//        0x000003b0,                   // range start I/O address
//        0xC,                         // range length
//        Uchar,                        // access size to trap
//        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS, // types of access to trap
//        FALSE,                        // does not support string accesses
//        (PVOID)VgaValidatorUcharEntry // routine to which to trap
//    },
//
//    {
//        0x000003c0,                   // range start I/O address
//        0x20,                         // range length
//        Uchar,                        // access size to trap
//        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS, // types of access to trap
//        FALSE,                        // does not support string accesses
//        (PVOID)VgaValidatorUcharEntry // routine to which to trap
//    },
//
//    //
//    // Traps for word OUTs.
//    //
//
//    {
//        0x000003b0,
//        0x06,
//        Ushort,
//        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS,
//        FALSE,
//        (PVOID)VgaValidatorUshortEntry
//    },
//
//    {
//        0x000003c0,
//        0x10,
//        Ushort,
//        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS,
//        FALSE,
//        (PVOID)VgaValidatorUshortEntry
//    },
//
//    //
//    // Traps for dword OUTs.
//    //
//
//    {
//        0x000003b0,
//        0x03,
//        Ulong,
//        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS,
//        FALSE,
//        (PVOID)VgaValidatorUlongEntry
//    },
//
//    {
//        0x000003c0,
//        0x08,
//        Ulong,
//        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS,
//        FALSE,
//        (PVOID)VgaValidatorUlongEntry
//    }
//
//};


//
// Used to trap only the sequncer and the misc output registers
//

VIDEO_ACCESS_RANGE MinimalVgaValidatorAccessRange[] = {
{
    VGA_BASE_IO_PORT, 0x00000000,
    VGA_START_BREAK_PORT - VGA_BASE_IO_PORT + 1,
    1,
    1,        // <- enable range IOPM so that it is not trapped.
    0
},
{
    VGA_END_BREAK_PORT, 0x00000000,
    VGA_MAX_IO_PORT - VGA_END_BREAK_PORT + 1,
    1,
    1,
    0
},
{
    VGA_BASE_IO_PORT + MISC_OUTPUT_REG_WRITE_PORT, 0x00000000,
    0x00000001,
    1,
    0,
    0
},
{
    VGA_BASE_IO_PORT + SEQ_ADDRESS_PORT, 0x00000000,
    0x00000002,
    1,
    0,
    0
}
};

//
// Used to trap all registers
//

VIDEO_ACCESS_RANGE FullVgaValidatorAccessRange[] = {
{
    VGA_BASE_IO_PORT, 0x00000000,
    VGA_START_BREAK_PORT - VGA_BASE_IO_PORT + 1,
    1,
    0,        // <- disable range in the IOPM so that it is trapped.
    0
},
{
    VGA_END_BREAK_PORT, 0x00000000,
    VGA_MAX_IO_PORT - VGA_END_BREAK_PORT + 1,
    1,
    0,
    0
}
};

USHORT ET4K_1K_WIDE[] = {
    OW,                             // stretch scans to 1k
    CRTC_ADDRESS_PORT_COLOR,
    0x8013,

    EOD
};

// This is the only value that avoids broken rasters (at least they're not
// broken within the visible portion of the bitmap)
USHORT ET4K_1928_WIDE[] = {
    OW,                             // stretch scans to 1928
    CRTC_ADDRESS_PORT_COLOR,
    0xF113,

    EOD
};

//
// Memory map table -
//
// These memory maps are used to save and restore the physical video buffer.
//

MEMORYMAPS MemoryMaps[] = {

//               length      start
//               ------      -----
    {           0x08000,    0xB0000},   // all mono text modes (7)
    {           0x08000,    0xB8000},   // all color text modes (0, 1, 2, 3,
    {           0x10000,    0xA0000},   // all VGA graphics modes
};

//
// Video mode table - contains information and commands for initializing each
// mode. These entries must correspond with those in VIDEO_MODE_VGA. The first
// entry is commented; the rest follow the same format, but are not so
// heavily commented.
//

VIDEOMODE ModesVGA[] = {

//
// Standard VGA modes.
//

//
// Mode index 0
// Color text mode 3, 720x400, 9x16 char cell (VGA).
//

{
  VIDEO_MODE_COLOR,  // flags that this mode is a color mode, but not graphics
  4,                 // four planes
  1,                 // one bit of colour per plane
  80, 25,            // 80x25 text resolution
  720, 400,          // 720x400 pixels on screen
  160, 0x10000,      // 160 bytes per scan line, 64K of CPU-addressable bitmap
  0, 0,              // only support one frequency, non-interlaced
  NoBanking,         // no banking supported or needed in this mode
  MemMap_CGA,        // the memory mapping is the standard CGA memory mapping
                     //  of 32K at B8000
  FALSE,             // Mode is not available by default
  0x3,               // int 10 modesset value
  NULL,              // scan line stretching option
},

//
// Color text mode 3, 640x350, 8x14 char cell (EGA).
//

{ VIDEO_MODE_COLOR, 4, 1, 80, 25,
  640, 350, 160, 0x10000, 0, 0, NoBanking, MemMap_CGA,
  FALSE,
  0x3,
  NULL,
},

//
// Standard VGA Color graphics mode 0x12, 640x480 16 colors.
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 80, 30,
  640, 480, 80, 0x10000, 60, 0, NoBanking, MemMap_VGA,
  FALSE,
  0x12,
  NULL,
},

//
// Standard VGA Color graphics mode 0x12, 640x480 16 colors. 72Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 80, 30,
  640, 480, 80, 0x10000, 72, 0, NoBanking, MemMap_VGA,
  FALSE,
  0x12,
  NULL,
},

//
// Beginning of SVGA modes
//

//
// 800x600 16 colors.
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 100, 37,
  800, 600, 100, 0x10000, 60, 0, NoBanking, MemMap_VGA,
  FALSE,
  0x29,
  NULL,
},

//
// 800x600 16 colors. 72 hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 100, 37,
  800, 600, 100, 0x10000, 72, 0, NoBanking, MemMap_VGA,
  FALSE,
  0x29,
  NULL,
},

//
// 800x600 16 colors. 56 hz for 8514/a monitors... (fixed freq)
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 100, 37,
  800, 600, 100, 0x10000, 56, 0, NoBanking, MemMap_VGA,
  FALSE,
  0x29,
  NULL,
},

//
// 1024x768 non-interlaced 16 colors.
// Assumes 512K.
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 128, 48,
  1024, 768, 128, 0x20000, 60, 0, NormalBanking, MemMap_VGA,
  FALSE,
  0x37,
  NULL,
},

//
// 1024x768 non-interlaced 16 colors. 70hz
// Assumes 512K.
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 128, 48,
  1024, 768, 128, 0x20000, 70, 0, NormalBanking, MemMap_VGA,
  FALSE,
  0x37,
  NULL
},

//
// 1024x768 non-interlaced 16 colors. Interlaced (45 hz)
// Assumes 512K.
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 128, 48,
  1024, 768, 128, 0x20000, 45, 1, NormalBanking, MemMap_VGA,
  FALSE,
  0x37,
  NULL
},

//////////////////////////////////////////////////////////////////
// Non Planar Modes
//

//
// 640x480x256
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  640, 480, 1024, 0x80000, 60, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x2E,
  ET4K_1K_WIDE
},

//
// 640x480x256 72 Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  640, 480, 1024, 0x80000, 72, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x2E,
  ET4K_1K_WIDE
},

//
// 640x480x256 75 Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  640, 480, 1024, 0x80000, 75, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x2E,
  ET4K_1K_WIDE
},

//
// 640x480x256 85 Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  640, 480, 1024, 0x80000, 85, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x2E,
  ET4K_1K_WIDE
},

//
// 640x480x256 90 Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  640, 480, 1024, 0x80000, 90, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x2E,
  ET4K_1K_WIDE
},

// NOTE: 800x600 modes need 1Meg until we support broken rasters

//
// 800x600x256  56Hz
//
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  800, 600, 1024, 0x100000, 56, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x30,
  ET4K_1K_WIDE
},

//
// 800x600x256 60Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  800, 600, 1024, 0x100000, 60, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x30,
  ET4K_1K_WIDE
},

//
// 800x600x256 72Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  800, 600, 1024, 0x100000, 72, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x30,
  ET4K_1K_WIDE
},

//
// 800x600x256  75Hz
//
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  800, 600, 1024, 0x100000, 75, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x30,
  ET4K_1K_WIDE
},

//
// 800x600x256  85Hz
//
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  800, 600, 1024, 0x100000, 85, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x30,
  ET4K_1K_WIDE
},

//
// 800x600x256  90Hz
//
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  800, 600, 1024, 0x100000, 90, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x30,
  ET4K_1K_WIDE
},

//
// 1024x768x256 45Hz (Interlaced)
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  1024, 768, 1024, 0x100000, 45, 1, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x38,
  NULL
},

//
// 1024x768x256 60Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  1024, 768, 1024, 0x100000, 60, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x38,
  NULL
},

//
// 1024x768x256 70Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  1024, 768, 1024, 0x100000, 70, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x38,
  NULL
},

//
// 1024x768x256 72Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  1024, 768, 1024, 0x100000, 72, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x38,
  NULL
},

//
// 1024x768x256 75Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  1024, 768, 1024, 0x100000, 75, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x38,
  NULL
},

//
// 640x480x64K
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  640, 480, 1928, 0x100000, 60, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x2E,
  ET4K_1928_WIDE
},

//
// 640x480x64K 72Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  640, 480, 1928, 0x100000, 72, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x2E,
  ET4K_1928_WIDE
},

//
// 640x480x64K 75Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  640, 480, 1928, 0x80000, 75, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x2E,
  ET4K_1928_WIDE
},

//
// 640x480x64K 90Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  640, 480, 1928, 0x80000, 90, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x2E,
  ET4K_1928_WIDE
},

//
// 800x600x64K
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  800, 600, 800*2, 0x100000, 60, 0, NormalBanking, MemMap_VGA,
  FALSE,
  0x30,
  NULL
},

//
// 800x600x64K 72Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  800, 600, 800*2, 0x100000, 72, 0, NormalBanking, MemMap_VGA,
  FALSE,
  0x30,
  NULL
},

//
// 800x600x64K 75Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  800, 600, 800*2, 0x100000, 75, 0, NormalBanking, MemMap_VGA,
  FALSE,
  0x30,
  NULL
},

//
// 800x600x64K 90Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  800, 600, 800*2, 0x100000, 90, 0, NormalBanking, MemMap_VGA,
  FALSE,
  0x30,
  NULL
},

//
// 1024x768x64K
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  1024, 768, 1024*2, 0x200000, 60, 0, NormalBanking, MemMap_VGA,
  FALSE,
  0x38,
  NULL
},

//
// 1024x768x64K 70Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  1024, 768, 1024*2, 0x200000, 70, 0, NormalBanking, MemMap_VGA,
  FALSE,
  0x38,
  NULL
},

//
// 1024x768x64K 75Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  1024, 768, 1024*2, 0x200000, 75, 0, NormalBanking, MemMap_VGA,
  FALSE,
  0x38,
  NULL
},

//
// 1280x1024x256 45Hz (interlaced)
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  1280, 1024, 1280, 0x200000, 45, 1, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x3F,
  NULL
},

//
// 1280x1024 8bpp 60Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  1280, 1024, 1280, 0x200000, 60, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x3F,
  NULL
},

//
// 1280x1024 8bpp 70Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  1280, 1024, 1280, 0x200000, 70, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x3F,
  NULL
},

//
// 1280x1024 8bpp 75Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  1280, 1024, 1280, 0x200000, 75, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x3F,
  NULL
},

//
// 640x480 24bpp 60Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 80, 30,
  640, 480, 640*3, 640*480*3, 60, 0, MemMgrBanking, MemMap_VGA,
  FALSE,
  0x2E,
  NULL
},

//
// 640x480 24bpp 75Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 80, 30,
  640, 480, 640*3, 640*480*3, 75, 0, MemMgrBanking, MemMap_VGA,
  FALSE,
  0x2E,
  NULL
},

//
// 640x480 24bpp 90Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 80, 30,
  640, 480, 640*3, 640*480*3, 90, 0, MemMgrBanking, MemMap_VGA,
  FALSE,
  0x2E,
  NULL
},

//
// 800x600 24bpp 60Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 80, 30,
  800, 600, 800*3, 800*600*3, 60, 0, MemMgrBanking, MemMap_VGA,
  FALSE,
  0x30,
  NULL
},

//
// 800x600 24bpp 75Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 80, 30,
  800, 600, 800*3, 800*600*3, 75, 0, MemMgrBanking, MemMap_VGA,
  FALSE,
  0x30,
  NULL
},

//
// 800x600 24bpp 90Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 80, 30,
  800, 600, 800*3, 800*600*3, 90, 0, MemMgrBanking, MemMap_VGA,
  FALSE,
  0x30,
  NULL
},

#if 0
//
// 1024x768 24bpp 60Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 80, 30,
  1024, 768, 1024*3, 1024*768*3, 60, 0, MemMgrBanking, MemMap_VGA,
  FALSE,
  0x30,
  NULL
},

//
// 1024x768 24bpp 75Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 80, 30,
  1024, 768, 1024*3, 1024*768*3, 75, 0, MemMgrBanking, MemMap_VGA,
  FALSE,
  0x30,
  NULL
},
#endif

//////////////////////////////////////////////////////////////////////
// DirectDraw modes
//

//
// 320x200 8bpp 60Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  320, 200, 320, 320*200, 60, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x13,
  NULL
},

//
// 320x200 16bpp 60Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  320, 200, 320*2, 320*200*2, 60, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x13,
  NULL
},

//
// 320x200 24bpp 60Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 80, 30,
  320, 200, 320*3, 320*200*3, 60, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x13,
  NULL
},

//
// 320x240 8bpp 60Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  320, 240, 320, 320*240, 60, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x1e,
  NULL
},

//
// 320x240 16bpp 60Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  320, 240, 320*2, 320*240*2, 60, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x1e,
  NULL
},

//
// 320x240 24bpp 60Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 80, 30,
  320, 240, 320*3, 320*240*3, 60, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x1e,
  NULL
},

//
// 512x384 8bpp 60Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  512, 384, 512, 512*384, 60, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x1f,
  NULL
},

//
// 512x384 16bpp 60Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  512, 384, 512*2, 512*384*2, 60, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x1f,
  NULL
},

//
// 512x384 24bpp 60Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 80, 30,
  512, 384, 512*3, 512*384*3, 60, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x1f,
  NULL
},

//
// 640x400 8bpp 60Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  640, 400, 640, 640*400, 60, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x2f,
  NULL
},

//
// 640x400 16bpp 60Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  640, 400, 640*2, 640*400*2, 60, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x2f,
  NULL
},

//
// 640x400 24bpp 60Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 80, 30,
  640, 400, 640*3, 640*400*3, 60, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x2f,
  NULL
},

};

// TESTING VL  For now, just bring up 640x480 16bpp resolution
//
// ULONG NumVideoModes = sizeof(ModesVGA) / sizeof(VIDEOMODE);
//ULONG NumVideoModes = 1;

ULONG NumVideoModes = NUM_RESOLUTIONS * NUM_REFRESHES * NUM_DEPTHS;




//
//
// Data used to set the Graphics and Sequence Controllers to put the
// VGA into a planar state at A0000 for 64K, with plane 2 enabled for
// reads and writes, so that a font can be loaded, and to disable that mode.
//

// Settings to enable planar mode with plane 2 enabled.
//

USHORT EnableA000Data[] = {
    OWM,
    SEQ_ADDRESS_PORT,
    1,
    0x0100,

    OWM,
    GRAPH_ADDRESS_PORT,
    3,
    0x0204,     // Read Map = plane 2
    0x0005, // Graphics Mode = read mode 0, write mode 0
    0x0406, // Graphics Miscellaneous register = A0000 for 64K, not odd/even,
            //  graphics mode
    OWM,
    SEQ_ADDRESS_PORT,
    3,
    0x0402, // Map Mask = write to plane 2 only
    0x0404, // Memory Mode = not odd/even, not full memory, graphics mode
    0x0300,  // end sync reset
    EOD
};

//
// Settings to disable the font-loading planar mode.
//

USHORT DisableA000Color[] = {
    OWM,
    SEQ_ADDRESS_PORT,
    1,
    0x0100,

    OWM,
    GRAPH_ADDRESS_PORT,
    3,
    0x0004, 0x1005, 0x0E06,

    OWM,
    SEQ_ADDRESS_PORT,
    3,
    0x0302, 0x0204, 0x0300,  // end sync reset
    EOD

};

#if defined(ALLOC_PRAGMA)
#pragma data_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\nvmode.c ===
//******************************************************************************
//
// Copyright (c) 1992  Microsoft Corporation
//
// Module Name:
//
//     NVMODE.C
//
// Abstract:
//
//     This is the modeset code for the NV miniport driver.
//
// Environment:
//
//     kernel mode only
//
// Notes:
//
// Revision History:
//
//******************************************************************************

//******************************************************************************
//
// Copyright (c) 1996,1997  NVidia Corporation. All Rights Reserved
//
//******************************************************************************


#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"

#include "nv.h"

// Bring this in to get the flat panel structs
#include "nvcm.h"
#include "cmdcnst.h"
#include "monitor.h"
#include "vesadata.h"
#include "nvMultiMon.h"

// modeset DLL definitions                    
#include "modeext.h"
void InitializeCommonModesetCode(PHW_DEVICE_EXTENSION HwDeviceExtension);
ULONG GetTimingDacCommonModesetCode(PHW_DEVICE_EXTENSION HwDeviceExtension, HEAD_RESOLUTION_INFO *pResolution, DAC_TIMING_VALUES * pTimingInfo);
extern int FindModeEntry (LPDISPDATA lpDispData,
    LPCHAR      lpEdidBuffer,
    ULONG       dwEdidSize,
    LPMODEINFO  lpModeDesc,
    LPMODEOUT   lpModeOut,
    LPMODEINFO  lpModeNew);

extern ULONG ConvertDeviceMaskToIndex(
    ULONG ulDeviceMask);
extern ULONG MaskToDeviceType( ULONG ulDeviceMask);
extern ULONG MaskToFindModeEntryDeviceType( ULONG ulDeviceMask);
extern ULONG MaskToTVFormat( ULONG ulDeviceMask);

extern VOID InitializeFPCode(VOID **ppSave, VOID **pMutex);
extern VOID EnterFPCode(VOID *pSave, VOID *pMutex);
extern VOID ExitFPCode(VOID *pSave, VOID *pMutex);



#define NV3_BYTE_ALIGNMENT_PAD   15L
#define NV4_BYTE_ALIGNMENT_PAD   31L
#define NV10_BYTE_ALIGNMENT_PAD  63L

#define IMAGE_PITCH_LIMIT       16320


//******************************************************************************
//
// Function Declarations
//
//******************************************************************************

VP_STATUS
NVQueryAvailableModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE_INFORMATION ModeInformation,
    ULONG ModeInformationSize,
    ULONG_PTR* OutputSize
    );

VP_STATUS
NVQueryNumberOfAvailableModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_NUM_MODES NumModes,
    ULONG NumModesSize,
    ULONG_PTR* OutputSize
    );

VP_STATUS
NVQueryCurrentMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE_INFORMATION ModeInformation,
    ULONG ModeInformationSize,
    ULONG_PTR* OutputSize
    );

VOID
NVValidateModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

BOOL NVValidateDeviceMode(PHW_DEVICE_EXTENSION HwDeviceExtension, VALMODEXTR *vmx);

//******************************************************************************
//
// External Function Declarations
//
//******************************************************************************

extern BOOL RmConfigGetExKernel
(
    U032 deviceReference,
    U032 index,
    VOID* pParms,
    U032 parmSize
);

extern BOOL RmConfigGetKernel (U032, U032, U032*);

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,NVQueryAvailableModes)
#pragma alloc_text(PAGE,NVQueryNumberOfAvailableModes)
#pragma alloc_text(PAGE,NVQueryCurrentMode)
#pragma alloc_text(PAGE,NVValidateModes)
#endif

MODE_ENTRY FakeModes[] =  { {1,640,480,8 ,60},
                            {1,640,480,16,60},
                            {1,640,480,32,60},
                            {1,640,480,8 ,70},
                            {1,640,480,16,70},
                            {1,640,480,32,70},
                            {1,640,480,8 ,75},
                            {1,640,480,16,75},
                            {1,640,480,32,75},

                            {1,800,600,8 ,60},
                            {1,800,600,16,60},
                            {1,800,600,32,60},
                            {1,800,600,8 ,70},
                            {1,800,600,16,70},
                            {1,800,600,32,70},
                            {1,800,600,8 ,75},
                            {1,800,600,16,75},
                            {1,800,600,32,75},

                            {1,1024,768,8 ,60},
                            {1,1024,768,16,60},
                            {1,1024,768,32,60},
                            {1,1024,768,8 ,70},
                            {1,1024,768,16,70},
                            {1,1024,768,32,70},
                            {1,1024,768,8 ,75},
                            {1,1024,768,16,75},
                            {1,1024,768,32,75} };


//******************************************************************************
//
//  Function:  NVQueryAvailableModes()
//
//  Routine Description:
//
//      This routine returns the list of all available available modes on the
//      card.
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//      ModeInformation - Pointer to the output buffer supplied by the user.
//          This is where the list of all valid modes is stored.
//
//      ModeInformationSize - Length of the output buffer supplied by the user.
//
//      OutputSize - Pointer to a buffer in which to return the actual size of
//          the data in the buffer. If the buffer was not large enough, this
//          contains the minimum required buffer size.
//
//  Return Value:
//
//      ERROR_INSUFFICIENT_BUFFER if the output buffer was not large enough
//          for the data being returned.
//
//      NO_ERROR if the operation completed successfully.
//
//******************************************************************************


VP_STATUS
NVQueryAvailableModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE_INFORMATION ModeInformation,
    ULONG ModeInformationSize,
    ULONG_PTR* OutputSize
    )

{
    PVIDEO_MODE_INFORMATION videoModes = ModeInformation;
    ULONG i;
    PMODE_ENTRY ModeEntry;
    ULONG BytesPerPel;
    ULONG NumberOfModesBeforeMemRestrictions;
    
    
    //**************************************************************************
    // Find out the size of the data to be put in the buffer and return
    // that in the status information (whether or not the information is
    // there). If the buffer passed in is not large enough return an
    // appropriate error code.
    //**************************************************************************

    if (ModeInformationSize < (*OutputSize =
            HwDeviceExtension->NumAvailableModes *
            sizeof(VIDEO_MODE_INFORMATION)) ) {

        VideoDebugPrint((0,"NVQueryAvailableModes: ERROR_INSUFFICIENT_BUFFER\n"));
        return ERROR_INSUFFICIENT_BUFFER;

    }


    //**************************************************************************
    // During unattended install with an Intel 810 present,
    // we're going to return a 'fake' set of available modes.
    // We'll specify just enough modes to 'fake out' unattended install
    // to let it succeed.  We do this because we completely skipped
    // the ValidateModes() function.  We'll specify 9 modes, 3 refreshes each.
    // (640x480, 800x600, 1024x768 at 60hz,70hz,75hz)
    //**************************************************************************

    if (HwDeviceExtension->DeviceMappingFailed==TRUE)
        {

        if (ModeInformationSize < (*OutputSize = 9 * 3 * sizeof(VIDEO_MODE_INFORMATION)) ) 
            {
            VideoDebugPrint((0,"NVQueryAvailableModes: ERROR_INSUFFICIENT_BUFFER\n"));
            return ERROR_INSUFFICIENT_BUFFER;
            }


        //**************************************************************************
        // Point to fake mode table
        //**************************************************************************

        ModeEntry = (PMODE_ENTRY)&(FakeModes[0]);

        //**************************************************************************
        // Parse the fake mode table (27 modes), and return it to Win2k
        //**************************************************************************

        for (i = 0; i < 27 ; i++)

            {
            if ((ModeEntry[i].Depth == 15) || (ModeEntry[i].Depth == 16))
                BytesPerPel = 16/8;
            else
                BytesPerPel = (ModeEntry[i].Depth/8);

            videoModes->Length              = sizeof(VIDEO_MODE_INFORMATION);
            videoModes->ModeIndex           = i;
            videoModes->VisScreenWidth      = ModeEntry[i].Width;
            videoModes->ScreenStride        = ModeEntry[i].Width * BytesPerPel;
            videoModes->VisScreenHeight     = ModeEntry[i].Height;
            videoModes->NumberOfPlanes      = 1;

            if (ModeEntry[i].Depth == 15)
                videoModes->BitsPerPlane = 16;
            else
                videoModes->BitsPerPlane = ModeEntry[i].Depth;

            videoModes->Frequency           = ModeEntry[i].RefreshRate;
            videoModes->XMillimeter         = 320;  // temporary hardcoded constant
            videoModes->YMillimeter         = 240;  // temporary hardcoded constant
            videoModes->NumberRedBits       = 8;    // Do we have an 8 or 6 bit DAC?
            videoModes->NumberGreenBits     = 8;    // Do we have an 8 or 6 bit DAC?
            videoModes->NumberBlueBits      = 8;    // Do we have an 8 or 6 bit DAC?
            videoModes->AttributeFlags      = VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS;
            videoModes->AttributeFlags      |=  0;  // No interlacing today.

            videoModes->VideoMemoryBitmapWidth = ModeEntry[i].Width;
            videoModes->VideoMemoryBitmapHeight =
                   HwDeviceExtension->AdapterMemorySize / videoModes->ScreenStride;

            if (ModeEntry[i].Depth == 15)
                {
                videoModes->RedMask = 0x7c00;           // 5:5:5 format
                videoModes->GreenMask = 0x03e0;
                videoModes->BlueMask = 0x001f;
                }

            else if (ModeEntry[i].Depth == 16)
                {
                videoModes->RedMask = 0xf800;           // 5:6:5 format
                videoModes->GreenMask = 0x07e0;
                videoModes->BlueMask = 0x001f;
                }

            else if (ModeEntry[i].Depth == 32)

                {
                videoModes->RedMask =   0xff0000;
                videoModes->GreenMask = 0x00ff00;
                videoModes->BlueMask =  0x0000ff;
                }

            else

                {
                videoModes->RedMask = 0;
                videoModes->GreenMask = 0;
                videoModes->BlueMask = 0;
                videoModes->AttributeFlags |= VIDEO_MODE_PALETTE_DRIVEN |
                         VIDEO_MODE_MANAGED_PALETTE;
                }

            videoModes++;

            }

        return NO_ERROR;
        }


    //**************************************************************************
    // Get pointer to our mode data table
    //
    // NOTE: NV3 still uses the OLD style modeset code meaning:
    //
    //          1) The 'validated' modes are located in HwDeviceExtension->fbTimingTable
    //          2) The old modeset code (in modeset.c) is still being used.
    //             This code is no longer being maintained/updated.
    //             Available modes are 'fixed' , it's not as easy to
    //             to add/modify new modes using this old style modeset code.
    //
    //       NV4 (and better) now used the NEW style modeset code:
    //
    //          1) The 'validated' modes are located in HwDeviceExtension->ValidModeTable
    //          2) The mode gets set the the RM (via RmSetMode).  The RM also
    //             handles modeset code arbitration.  This is the same modeset
    //             code used by the Win9x driver, and is 'shared'.  It is much
    //             easier to add/modify new modes using this new style modeset code.
    //
    //**************************************************************************

    if (HwDeviceExtension->ulChipID  == NV3_DEVICE_NV3_ID)
        {        
        //**********************************************************************
        // NV3  (Old style modeset code)
        //**********************************************************************

        ModeEntry = (PMODE_ENTRY)&(HwDeviceExtension->fbTimingTable[0]);
        }
        
    else
        {
        //**********************************************************************
        // NV4 or better (New style modeset code)
        //**********************************************************************

        ModeEntry = (PMODE_ENTRY)&(HwDeviceExtension->ValidModeTable[0]);
        }
        


    if (HwDeviceExtension->ulChipID  == NV3_DEVICE_NV3_ID)

        {
        //**********************************************************************
        // NV3 still uses OLD style modeset code
        //
        // 'NumVideoModes' is a fixed value, and represents the number
        // of modes that were available before eliminating modes due
        // to the amount of memory on the card.
        //**********************************************************************

        NumberOfModesBeforeMemRestrictions = NumVideoModes;
        }
        
    else

        {
        //**********************************************************************
        // NV4 uses the NEW style modeset code.
        //
        // 'NumRegistryModes' represents the number of modes available
        // before eliminating modes due to the amount of memory on the card.
        // The DIFFERENCE is that this value depends on 
        //      1) What modes are listed in VESADATA.C (in GTFTimingTable) and
        //      2) What modes were specified in the REGISTRY
        //**********************************************************************

        NumberOfModesBeforeMemRestrictions = HwDeviceExtension->NumRegistryModes;
        }
        

    //**************************************************************************
    // For each mode supported by the card, store the mode characteristics
    // in the output buffer.
    //**************************************************************************


      for (i = 0; i < NumberOfModesBeforeMemRestrictions; i++)

        {
        //**********************************************************************
        // In ValidateModes, we check to see which ones are currently
        // available, depending on the amount of RAM currently present
        // on the adapter, etc....
        //**********************************************************************

        if (ModeEntry[i].ValidMode)
            {
            //******************************************************************
            // Handle 15bpp modes same as 16bpp modes
            //******************************************************************

            if ((ModeEntry[i].Depth == 15) || (ModeEntry[i].Depth == 16))
                BytesPerPel = 16/8;
            else
                BytesPerPel = (ModeEntry[i].Depth/8);


            videoModes->Length = sizeof(VIDEO_MODE_INFORMATION);
            videoModes->ModeIndex  = i;
            videoModes->VisScreenWidth = ModeEntry[i].Width;
            videoModes->ScreenStride = ModeEntry[i].Width * BytesPerPel;
            videoModes->VisScreenHeight = ModeEntry[i].Height;
            videoModes->NumberOfPlanes = 1;

            //******************************************************************
            // NV3: Only supports 555 format for 16bpp modes.  However, we return
            // 16bits of color even though we are really running in 15bit (555 mode)
            // (Display applet thinks we have 64k colors) Microsoft said this was ok
            // due to WHQL complications related to 15bpp modes.
            //
            // NV4:  Can support 555 and 565 modes for 16bpp
            // We'll eventually just support 565 modes (64k colors).
            //******************************************************************

            if (ModeEntry[i].Depth == 15)
                videoModes->BitsPerPlane = 16;
            else
                videoModes->BitsPerPlane = ModeEntry[i].Depth;

            videoModes->Frequency = ModeEntry[i].RefreshRate;
            videoModes->XMillimeter = 320;      // temporary hardcoded constant
            videoModes->YMillimeter = 240;      // temporary hardcoded constant
            videoModes->NumberRedBits = 8;      // Do we have an 8 or 6 bit DAC?
            videoModes->NumberGreenBits = 8;    // Do we have an 8 or 6 bit DAC?
            videoModes->NumberBlueBits = 8;     // Do we have an 8 or 6 bit DAC?
            videoModes->AttributeFlags = VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS;
            videoModes->AttributeFlags |=  0;   // No interlacing today.

            //******************************************************************
            // Calculate the VideoMemoryBitmapWidth
            // Since our hardware handles variable pitch, we don't ever
            // have offscreen memory on the 'right' side.
            // BitmapWidth will always equal the VisScreenWidth.
            //******************************************************************

            videoModes->VideoMemoryBitmapWidth = ModeEntry[i].Width;

            //******************************************************************
            // NOTE: AdapterMemorySize was adjusted in NVValidateModes
            //       to compensate for INSTANCE memory in offscreen memory.
            //       That is, Hash Table, Fifo Context, and Run Out information
            //       is stored in PRAMIN memory, which also exists in offscreen memory.
            //       We must make sure NO ONE (but the miniport) touches this offscreen memory.
            //
            //       In the display driver, ppdev->cyMemory = VideoMemoryBitmapHeight
            //       Direct Draw uses cyMemory to determine how much memory to 'Share'.
            //       Since these values are obtained from AdapterMemorySize,
            //       no additional adjustments are necessary here.
            //******************************************************************

            //******************************************************************
            // TOTAL number of vertical scanlines in video memory
            //******************************************************************

            videoModes->VideoMemoryBitmapHeight =
                   HwDeviceExtension->AdapterMemorySize / videoModes->ScreenStride;

            //******************************************************************
            // Color masks (specify 5:5:5 format for 16bpp on NV3 only)
            // NV4 supports 5:5:5 as well as 5:6:5
            //******************************************************************

            if (ModeEntry[i].Depth == 15)
                {
                videoModes->RedMask = 0x7c00;           // 5:5:5 format
                videoModes->GreenMask = 0x03e0;
                videoModes->BlueMask = 0x001f;
                }

            else if (ModeEntry[i].Depth == 16)
                {
                videoModes->RedMask = 0xf800;           // 5:6:5 format
                videoModes->GreenMask = 0x07e0;
                videoModes->BlueMask = 0x001f;
                }

            else if (ModeEntry[i].Depth == 24)

                {
                videoModes->RedMask =   0xff0000;
                videoModes->GreenMask = 0x00ff00;
                videoModes->BlueMask =  0x0000ff;
                }

            else if (ModeEntry[i].Depth == 32)

                {
                videoModes->RedMask =   0xff0000;
                videoModes->GreenMask = 0x00ff00;
                videoModes->BlueMask =  0x0000ff;
                }

            else

                {
                videoModes->RedMask = 0;
                videoModes->GreenMask = 0;
                videoModes->BlueMask = 0;
                videoModes->AttributeFlags |= VIDEO_MODE_PALETTE_DRIVEN |
                         VIDEO_MODE_MANAGED_PALETTE;
                }

            videoModes++;

            }

        }

        return NO_ERROR;

    } // end NVQueryAvailableModes()


//******************************************************************************
//
//  Function:   NVQueryNumberOfAvailableModes()
//
//  Routine Description:
//
//      This routine returns the number of available modes for this particular
//      video card.
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//      NumModes - Pointer to the output buffer supplied by the user. This is
//          where the number of modes is stored.
//
//      NumModesSize - Length of the output buffer supplied by the user.
//
//      OutputSize - Pointer to a buffer in which to return the actual size of
//          the data in the buffer.
//
//  Return Value:
//
//      ERROR_INSUFFICIENT_BUFFER if the output buffer was not large enough
//          for the data being returned.
//
//      NO_ERROR if the operation completed successfully.
//
//******************************************************************************

VP_STATUS NVQueryNumberOfAvailableModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_NUM_MODES NumModes,
    ULONG NumModesSize,
    ULONG_PTR* OutputSize
    )

    {
        
    

    //**************************************************************************
    // Find out the size of the data to be put in the the buffer and return
    // that in the status information (whether or not the information is
    // there). If the buffer passed in is not large enough return an
    // appropriate error code.
    //**************************************************************************

    if (NumModesSize < (*OutputSize = sizeof(VIDEO_NUM_MODES)) ) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //**************************************************************************
    // During unattended install with an Intel 810 present,
    // we're going to return a 'fake' set of available modes.
    // We'll specify just enough modes to 'fake out' unattended install
    // to let it succeed.  We do this because we completely skipped
    // the ValidateModes() function.  We'll specify 9 modes, 3 refreshes each.
    // (640x480, 800x600, 1024x768 at 60hz,70hz,75hz) for a total of 27 modes
    //**************************************************************************


    if (HwDeviceExtension->DeviceMappingFailed==TRUE)
        {
        NumModes->NumModes = 27;
        NumModes->ModeInformationLength = sizeof(VIDEO_MODE_INFORMATION);

        VideoDebugPrint((0,"Fake NumAvailableModes = %d\n", 27));
        return NO_ERROR;
        }


    //**************************************************************************
    // Store the number of modes into the buffer.
    // This number is determined in NVValidateModes, which gets called
    // by the function NV1IsPresent (which gets called by NVFindAdapter)
    //**************************************************************************

    NumModes->NumModes = HwDeviceExtension->NumAvailableModes;
    NumModes->ModeInformationLength = sizeof(VIDEO_MODE_INFORMATION);

    VideoDebugPrint((1,"NumAvailableModes = %d\n", HwDeviceExtension->NumAvailableModes));
    return NO_ERROR;

} // end VgaGetNumberOfAvailableModes()


//******************************************************************************
//
// Function: NVQueryCurrentMode()
//
// Routine Description:
//
//     This routine returns a description of the current video mode.
//
// Arguments:
//
//     HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//     ModeInformation - Pointer to the output buffer supplied by the user.
//         This is where the current mode information is stored.
//
//     ModeInformationSize - Length of the output buffer supplied by the user.
//
//     OutputSize - Pointer to a buffer in which to return the actual size of
//         the data in the buffer. If the buffer was not large enough, this
//         contains the minimum required buffer size.
//
// Return Value:
//
//     ERROR_INSUFFICIENT_BUFFER if the output buffer was not large enough
//         for the data being returned.
//
//     NO_ERROR if the operation completed successfully.
//
//******************************************************************************

VP_STATUS
NVQueryCurrentMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE_INFORMATION ModeInformation,
    ULONG ModeInformationSize,
    ULONG_PTR* OutputSize
    )


    {
    ULONG BytesPerPel;


    //**************************************************************************
    // Find out the size of the data to be put in the the buffer and return
    // that in the status information (whether or not the information is
    // there). If the buffer passed in is not large enough return an
    // appropriate error code.
    //**************************************************************************

    if (ModeInformationSize < (*OutputSize = sizeof(VIDEO_MODE_INFORMATION)))
        {
        return ERROR_INSUFFICIENT_BUFFER;
        }

    //**************************************************************************
    // Return which chip is present (NV1 or NV3) in the
    // DriverSpecificAttributeFlags field. ulChipID gets determined
    // during NVFindAdapter()
    //
    // For NV5,NV5ULTRA, NV5VANTA, NV0A,NV10 we'll set the NV4 bit to also signify that
    // these chips are also NV4 COMPATIBLE'
    //**************************************************************************

    if (HwDeviceExtension->ulChipID == NV1_DEVICE_NV1_ID)
        ModeInformation->DriverSpecificAttributeFlags = CAPS_NV1_IS_PRESENT;
    else if (HwDeviceExtension->ulChipID == NV3_DEVICE_NV3_ID)
        ModeInformation->DriverSpecificAttributeFlags = CAPS_NV3_IS_PRESENT;
    else if (HwDeviceExtension->ulChipID == NV4_DEVICE_NV4_ID)
        ModeInformation->DriverSpecificAttributeFlags = CAPS_NV4_IS_PRESENT;

    //**************************************************************************
    // For NV5, set the NV4 bit to signify NV4 compatibility !!
    //**************************************************************************

    else if (HwDeviceExtension->ulChipID == NV5_DEVICE_NV5_ID)
        ModeInformation->DriverSpecificAttributeFlags = ( CAPS_NV5_IS_PRESENT | CAPS_NV4_IS_PRESENT) ;

    //**************************************************************************
    // For NV5ULTRA, set the NV5ULTRA bit to signify NV4 compatibility !!
    //**************************************************************************

    else if (HwDeviceExtension->ulChipID == NV5ULTRA_DEVICE_NV5ULTRA_ID)
        ModeInformation->DriverSpecificAttributeFlags = ( CAPS_NV5ULTRA_IS_PRESENT | CAPS_NV4_IS_PRESENT) ;

    //**************************************************************************
    // For NV5VANTA, set the NV5VANTA bit to signify NV4 compatibility !!
    //**************************************************************************

    else if (HwDeviceExtension->ulChipID == NV5VANTA_DEVICE_NV5VANTA_ID)
        ModeInformation->DriverSpecificAttributeFlags = ( CAPS_NV5VANTA_IS_PRESENT | CAPS_NV4_IS_PRESENT) ;

    //**************************************************************************
    // For NV5MODEL64, set the NV5MODEL64 bit to signify NV4 compatibility !!
    //**************************************************************************

    else if (HwDeviceExtension->ulChipID == NV5MODEL64_DEVICE_NV5MODEL64_ID)
        ModeInformation->DriverSpecificAttributeFlags = ( CAPS_NV5MODEL64_IS_PRESENT | CAPS_NV4_IS_PRESENT) ;

    //**************************************************************************
    // For NV0A, set the NV4 bit to signify NV4 compatibility !!
    //**************************************************************************

    else if (HwDeviceExtension->ulChipID == NV0A_DEVICE_NV0A_ID)
        ModeInformation->DriverSpecificAttributeFlags = ( CAPS_NV0A_IS_PRESENT | CAPS_NV4_IS_PRESENT) ;

    //**************************************************************************
    // For NV10, set the NV4 bit to signify NV4 compatibility !!
    //**************************************************************************

    else if (HwDeviceExtension->ulChipID == NV10_DEVICE_NV10_ID)
        ModeInformation->DriverSpecificAttributeFlags = ( CAPS_NV10_IS_PRESENT | CAPS_NV4_IS_PRESENT) ;

    //**************************************************************************
    // For NV10DDR, set the NV4 bit to signify NV4 compatibility !!
    //**************************************************************************

    else if (HwDeviceExtension->ulChipID == NV10DDR_DEVICE_NV10DDR_ID)
        ModeInformation->DriverSpecificAttributeFlags = ( CAPS_NV10DDR_IS_PRESENT | CAPS_NV4_IS_PRESENT) ;
           
    //**************************************************************************
    // For NV10GL, set the NV4 bit to signify NV4 compatibility !!
    //**************************************************************************

    else if (HwDeviceExtension->ulChipID == NV10GL_DEVICE_NV10GL_ID)
        ModeInformation->DriverSpecificAttributeFlags = ( CAPS_NV10GL_IS_PRESENT | CAPS_NV4_IS_PRESENT) ;
           
    //**************************************************************************
    // For NV11, set the NV4 bit to signify NV4 compatibility !!
    //**************************************************************************

    else if (HwDeviceExtension->ulChipID == NV11_DEVICE_NV11_ID)
        ModeInformation->DriverSpecificAttributeFlags = ( CAPS_NV11_IS_PRESENT | CAPS_NV4_IS_PRESENT) ;

    //**************************************************************************
    // For NV11DDR, set the NV4 bit to signify NV4 compatibility !!
    //**************************************************************************

    else if (HwDeviceExtension->ulChipID == NV11DDR_DEVICE_NV11DDR_ID)
        ModeInformation->DriverSpecificAttributeFlags = ( CAPS_NV11DDR_IS_PRESENT | CAPS_NV4_IS_PRESENT) ;
           
    //**************************************************************************
    // For NV11M, set the NV4 bit to signify NV4 compatibility !!
    //**************************************************************************

    else if (HwDeviceExtension->ulChipID == NV11M_DEVICE_NV11M_ID)
        ModeInformation->DriverSpecificAttributeFlags = ( CAPS_NV11M_IS_PRESENT | CAPS_NV4_IS_PRESENT) ;
           
    //**************************************************************************
    // For NV11GL, set the NV4 bit to signify NV4 compatibility !!
    //**************************************************************************

    else if (HwDeviceExtension->ulChipID == NV11GL_DEVICE_NV11GL_ID)
        ModeInformation->DriverSpecificAttributeFlags = ( CAPS_NV11GL_IS_PRESENT | CAPS_NV4_IS_PRESENT) ;
           
    //**************************************************************************
    // For CRUSH11, set the NV4 bit to signify NV4 compatibility !!
    //**************************************************************************

    else if (HwDeviceExtension->ulChipID == NV11_DEVICE_CRUSH11_ID)
        ModeInformation->DriverSpecificAttributeFlags = ( CAPS_CRUSH11_IS_PRESENT | CAPS_NV4_IS_PRESENT) ;

    //**************************************************************************
    // For NV15, set the NV4 bit to signify NV4 compatibility !!
    //**************************************************************************

    else if (HwDeviceExtension->ulChipID == NV15_DEVICE_NV15_ID)
        ModeInformation->DriverSpecificAttributeFlags = ( CAPS_NV15_IS_PRESENT | CAPS_NV4_IS_PRESENT) ;

    //**************************************************************************
    // For NV15DDR, set the NV4 bit to signify NV4 compatibility !!
    //**************************************************************************

    else if (HwDeviceExtension->ulChipID == NV15DDR_DEVICE_NV15DDR_ID)
        ModeInformation->DriverSpecificAttributeFlags = ( CAPS_NV15DDR_IS_PRESENT | CAPS_NV4_IS_PRESENT) ;
           
    //**************************************************************************
    // For NV15BR, set the NV4 bit to signify NV4 compatibility !!
    //**************************************************************************

    else if (HwDeviceExtension->ulChipID == NV15BR_DEVICE_NV15BR_ID)
        ModeInformation->DriverSpecificAttributeFlags = ( CAPS_NV15BR_IS_PRESENT | CAPS_NV4_IS_PRESENT) ;
           
    //**************************************************************************
    // For NV15GL, set the NV4 bit to signify NV4 compatibility !!
    //**************************************************************************

    else if (HwDeviceExtension->ulChipID == NV15GL_DEVICE_NV15GL_ID)
        ModeInformation->DriverSpecificAttributeFlags = ( CAPS_NV15GL_IS_PRESENT | CAPS_NV4_IS_PRESENT) ;
           
    //**************************************************************************
    // For NV20, set the NV4 bit to signify NV4 compatibility !!
    //**************************************************************************

    else if (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_ID)
        ModeInformation->DriverSpecificAttributeFlags = ( CAPS_NV20_IS_PRESENT | CAPS_NV4_IS_PRESENT) ;

    //**************************************************************************
    // For NV20_1, set the NV4 bit to signify NV4 compatibility !!
    //**************************************************************************

    else if (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_1_ID)
        ModeInformation->DriverSpecificAttributeFlags = ( CAPS_NV20_IS_PRESENT | CAPS_NV4_IS_PRESENT) ;

    //**************************************************************************
    // For NV20_2, set the NV4 bit to signify NV4 compatibility !!
    //**************************************************************************

    else if (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_2_ID)
        ModeInformation->DriverSpecificAttributeFlags = ( CAPS_NV20_IS_PRESENT | CAPS_NV4_IS_PRESENT) ;

    //**************************************************************************
    // For NV20_3, set the NV4 bit to signify NV4 compatibility !!
    //**************************************************************************

    else if (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_3_ID)
        ModeInformation->DriverSpecificAttributeFlags = ( CAPS_NV20_IS_PRESENT | CAPS_NV4_IS_PRESENT) ;

    else
        ModeInformation->DriverSpecificAttributeFlags = 0;

    //**************************************************************************
    // Handle 15bpp modes same as 16bpp modes
    //**************************************************************************

    if (HwDeviceExtension->CurrentMode->Depth == 15)
        BytesPerPel = 16/8;
    else
        BytesPerPel = (HwDeviceExtension->CurrentMode->Depth/8);


    //**************************************************************************
    // Store the characteristics of the current mode into the buffer.
    //**************************************************************************

    ModeInformation->Length = sizeof(VIDEO_MODE_INFORMATION);

    ModeInformation->ModeIndex = HwDeviceExtension->ModeIndex;
    if(HwDeviceExtension->DeskTopInfo.ulDesktopMode & NV_ENABLE_VIRTUAL_DESKTOP)
    {
        ModeInformation->VisScreenWidth =  HwDeviceExtension->DeskTopInfo.ulDesktopWidth; 
        ModeInformation->VisScreenHeight = HwDeviceExtension->DeskTopInfo.ulDesktopHeight;
    }
    else
    {
        ModeInformation->VisScreenWidth = HwDeviceExtension->CurrentMode->Width;
        ModeInformation->VisScreenHeight = HwDeviceExtension->CurrentMode->Height;
    }

    ModeInformation->ScreenStride = ModeInformation->VisScreenWidth * BytesPerPel;

    //**************************************************************************
    // Add alignment for all chips
    //**************************************************************************
    if (ModeInformation->DriverSpecificAttributeFlags & CAPS_NV3_IS_PRESENT)
    {
        ModeInformation->ScreenStride += NV3_BYTE_ALIGNMENT_PAD;
        ModeInformation->ScreenStride &= ~NV3_BYTE_ALIGNMENT_PAD;
    }
    else if ((ModeInformation->DriverSpecificAttributeFlags & CAPS_NV10_IS_PRESENT) ||      
        (ModeInformation->DriverSpecificAttributeFlags & CAPS_NV10DDR_IS_PRESENT) || 
        (ModeInformation->DriverSpecificAttributeFlags & CAPS_NV10GL_IS_PRESENT)  ||
        (ModeInformation->DriverSpecificAttributeFlags & CAPS_NV11_IS_PRESENT)    ||   
        (ModeInformation->DriverSpecificAttributeFlags & CAPS_NV11DDR_IS_PRESENT) ||   
        (ModeInformation->DriverSpecificAttributeFlags & CAPS_NV11M_IS_PRESENT)   ||   
        (ModeInformation->DriverSpecificAttributeFlags & CAPS_NV11GL_IS_PRESENT)  ||   
        (ModeInformation->DriverSpecificAttributeFlags & CAPS_CRUSH11_IS_PRESENT) ||   
        (ModeInformation->DriverSpecificAttributeFlags & CAPS_NV15_IS_PRESENT)    ||   
        (ModeInformation->DriverSpecificAttributeFlags & CAPS_NV15DDR_IS_PRESENT) ||   
        (ModeInformation->DriverSpecificAttributeFlags & CAPS_NV15BR_IS_PRESENT)  ||   
        (ModeInformation->DriverSpecificAttributeFlags & CAPS_NV15GL_IS_PRESENT)  ||   
        (ModeInformation->DriverSpecificAttributeFlags & CAPS_NV20_IS_PRESENT) )
    {
        ModeInformation->ScreenStride += NV10_BYTE_ALIGNMENT_PAD;
        ModeInformation->ScreenStride &= ~NV10_BYTE_ALIGNMENT_PAD;
    }
    else        
    {
        ModeInformation->ScreenStride += NV4_BYTE_ALIGNMENT_PAD;
        ModeInformation->ScreenStride &= ~NV4_BYTE_ALIGNMENT_PAD;
    }

    ModeInformation->NumberOfPlanes = 1;

    //**************************************************************************
    // NV3: Only supports 555 format for 16bpp modes.  However, we return
    // 16bits of color even though we are really running in 15bit (555 mode)
    // (Display applet thinks we have 64k colors) Microsoft said this was ok
    // due to WHQL complications related to 15bpp modes.
    //
    // NV4:  Can support 555 and 565 modes for 16bpp
    // We'll eventually just support 565 modes (64k colors).
    //**************************************************************************

    if (HwDeviceExtension->CurrentMode->Depth == 15)
        ModeInformation->BitsPerPlane  = 16;
    else
        ModeInformation->BitsPerPlane = HwDeviceExtension->CurrentMode->Depth;


    ModeInformation->Frequency = HwDeviceExtension->CurrentMode->RefreshRate;

    ModeInformation->XMillimeter = 320;        // temporary hardcoded constant
    ModeInformation->YMillimeter = 240;        // temporary hardcoded constant
    ModeInformation->NumberRedBits = 8;
    ModeInformation->NumberGreenBits = 8;
    ModeInformation->NumberBlueBits = 8;
    ModeInformation->AttributeFlags = VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS;

   if (HwDeviceExtension->CurrentMode->Depth == 15)
       {
       ModeInformation->RedMask = 0x7c00;
       ModeInformation->GreenMask = 0x03e0;
       ModeInformation->BlueMask = 0x001f;
       }

   else if (HwDeviceExtension->CurrentMode->Depth == 16)
       {
       ModeInformation->RedMask = 0xf800;
       ModeInformation->GreenMask = 0x07e0;
       ModeInformation->BlueMask = 0x001f;
       }

   else if (HwDeviceExtension->CurrentMode->Depth == 24)

       {
       ModeInformation->RedMask =   0xff0000;
       ModeInformation->GreenMask = 0x00ff00;
       ModeInformation->BlueMask =  0x0000ff;
       }

   else if (HwDeviceExtension->CurrentMode->Depth == 32)

       {
       ModeInformation->RedMask =   0xff0000;
       ModeInformation->GreenMask = 0x00ff00;
       ModeInformation->BlueMask =  0x0000ff;
       }

   else        // 8bpp palette driven
       {
       ModeInformation->RedMask = 0;
       ModeInformation->GreenMask = 0;
       ModeInformation->BlueMask = 0;
       ModeInformation->AttributeFlags |= VIDEO_MODE_PALETTE_DRIVEN |
                VIDEO_MODE_MANAGED_PALETTE;
       }

   //**************************************************************************
   // Calculate the VideoMemoryBitmapWidth
   // Since our hardware handles variable pitch, we don't ever
   // have offscreen memory on the 'right' side.
   // BitmapWidth will always equal the VisScreenWidth.
   //**************************************************************************

    ModeInformation->VideoMemoryBitmapWidth = ModeInformation->VisScreenWidth;

   //**************************************************************************
   // NOTE: AdapterMemorySize was adjusted in NVValidateModes
   //       to compensate for INSTANCE memory in offscreen memory.
   //       That is, Hash Table, Fifo Context, and Run Out information
   //       is stored in PRAMIN memory, which also exists in offscreen memory.
   //       We must make sure NO ONE (but the miniport) touches this offscreen memory.
   //
   //       In the display driver (in Enable), ppdev->cyMemory = VideoMemoryBitmapHeight
   //       Direct Draw uses cyMemory to determine how much memory to 'Share'.
   //       Since these values are obtained from AdapterMemorySize,
   //       no additional adjustments are necessary here.
   //**************************************************************************

    ModeInformation->VideoMemoryBitmapHeight =
             HwDeviceExtension->AdapterMemorySize / ModeInformation->ScreenStride;

    if(HwDeviceExtension->ulForceSwCursor)
        ModeInformation->DriverSpecificAttributeFlags |= CAPS_SW_POINTER;

    return NO_ERROR;

    } // end NVQueryCurrentMode()


//******************************************************************************
//
//  Function:   NVValidateModes()
//
//  Routine Description:
//
//      Determines which modes are valid and which are not.
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NVValidateModes(PHW_DEVICE_EXTENSION HwDeviceExtension)
    {

    ULONG i, AvailableAdapterMemorySize;
    PHWINFO NVInfo;
    PMODE_ENTRY ModeEntry;
    ULONG NumAvailableModesTmp = 0;
    ULONG ulMonitorType;
    NV_CFGEX_GET_SURFACE_DIMENSIONS_PARAMS nvPitch;

    HwDeviceExtension->NumAvailableModes = HwDeviceExtension->NumRegistryModes;
    HwDeviceExtension->NumAvailableModes1 = HwDeviceExtension->NumRegistryModes;
    
    //**********************************************************************
    // Get the amount of video memory on this card
    //**********************************************************************
    NVInfo = (PHWINFO)&(HwDeviceExtension->NvInfo);
    HwDeviceExtension->AdapterMemorySize = NVInfo->Framebuffer.RamSize - HwDeviceExtension->TotalInstanceMemory;
    AvailableAdapterMemorySize = HwDeviceExtension->AdapterMemorySize;
#if (_WIN32_WINNT >= 0x0500)
    if (HwDeviceExtension->ulDualViewStatus & DUALVIEW_STATUS_ENABLE_DUALVIEW)
        AvailableAdapterMemorySize /= 2;
#endif

    ModeEntry = (PMODE_ENTRY)&(HwDeviceExtension->ValidModeTable[0]);

    for (i = 0; i < HwDeviceExtension->NumRegistryModes; i++)
    {
        nvPitch.Width = ModeEntry[i].Width;
        nvPitch.Height = ModeEntry[i].Height;
        nvPitch.Depth = ModeEntry[i].Depth;

        RmConfigGetExKernel(HwDeviceExtension->DeviceReference, NV_CFGEX_GET_SURFACE_DIMENSIONS, &nvPitch, sizeof(NV_CFGEX_GET_SURFACE_DIMENSIONS_PARAMS));

        //******************************************************************
        // Make the modes that fit in video memory valid. 
        //******************************************************************
    
        if (AvailableAdapterMemorySize >= nvPitch.Pitch * ModeEntry[i].Height)
        {
            //**************************************************************
            // Set the mode as available if it fits in memory
            //**************************************************************
                if(nvPitch.Pitch > IMAGE_PITCH_LIMIT)
                {
                    ModeEntry[i].ValidMode = FALSE;
                    VideoDebugPrint((0,"%dx%d mode[%d] disabled\n",
                        ModeEntry[i].Width,
                        ModeEntry[i].Height,
                        i));
                }
                else
                {
    
                    ModeEntry[i].ValidMode = TRUE;
                    NumAvailableModesTmp++;
    
                    VideoDebugPrint((2,"mode[%d] valid\n",i));
                    VideoDebugPrint((2,"         width(%d)\n",ModeEntry[i].Width));
                    VideoDebugPrint((2,"         height(%d)\n",ModeEntry[i].Height));
                    VideoDebugPrint((2,"         depth(%d)\n",ModeEntry[i].Depth));
                    VideoDebugPrint((2,"         refresh(%d)\n",ModeEntry[i].RefreshRate));
                    VideoDebugPrint((2,"         bytes needed(%d)\n",nvPitch.Pitch * ModeEntry[i].Height));
                    VideoDebugPrint((2,"         memory pres(%d)\n",HwDeviceExtension->AdapterMemorySize));
                }
        }
        else
            //**************************************************************
            // Mode not available on this adapter
            //**************************************************************
        {
            ModeEntry[i].ValidMode = FALSE;
        }

        switch(HwDeviceExtension->ulChipID)
        {
            case NV4_DEVICE_NV4_ID:               
            case NV5_DEVICE_NV5_ID:               
            case NV5ULTRA_DEVICE_NV5ULTRA_ID:
            case NV5VANTA_DEVICE_NV5VANTA_ID:     
            case NV5MODEL64_DEVICE_NV5MODEL64_ID: 
            case NV0A_DEVICE_NV0A_ID:             
            case NV10_DEVICE_NV10_ID:             
            case NV10DDR_DEVICE_NV10DDR_ID:       
            case NV10GL_DEVICE_NV10GL_ID:         
            case NV15_DEVICE_NV15_ID:
            case NV15DDR_DEVICE_NV15DDR_ID:
            case NV15BR_DEVICE_NV15BR_ID:
            case NV15GL_DEVICE_NV15GL_ID:
                // NV15 and older have HW look table to perform scaling for DFP
                // 1152x864 is not in the table.  Cannot support the mode
                // NV11 and later is not using table anymore and fully programmable
                RmConfigGetKernel(HwDeviceExtension->DeviceReference, NV_CFG_VIDEO_MONITOR_TYPE, &ulMonitorType);
                if (ulMonitorType == MONITOR_TYPE_FLAT_PANEL && ModeEntry[i].Width == 1152 &&  ModeEntry[i].Height == 864)
                {
                    ModeEntry[i].ValidMode = FALSE;
                }
                break;
            default:
            break;
        }

    }

    HwDeviceExtension->NumAvailableModes = NumAvailableModesTmp;

    } // nvValidateModes()


// NOTE: This function is no longer needed. It will be deleted once Sandy removes this call from ddVPP.c
// Determine if a mode is valid for a particular device
BOOL NVValidateDeviceMode(PHW_DEVICE_EXTENSION HwDeviceExtension, VALMODEXTR *vmx)
{

   PMODE_ENTRY SrcModes, DstModes;
   PMODE_ENTRY ModeEntry;
   PHWINFO     NVInfo;
   ULONG       AvailableAdapterMemorySize;
   ULONG       BytesPerPel;
   U032        memstatus;
   ULONG       i,index;
   BOOL        ModeValid;
   ULONG       refresh;
   BOOL        FoundDell1501FP = FALSE;
   ULONG       ulHead = 0;
   UCHAR       *pEDIDBuffer = HwDeviceExtension->EdidCollection->HeadMaps[ulHead]->EDIDBuffer;

   // @ Most of this code is sourced from NvValidateModes above
   // - Copy the modes in the ValidModeTable to our ValidDeviceModeTable
   DstModes = (PMODE_ENTRY)&(HwDeviceExtension->ValidDeviceModeTable[0]);
   SrcModes = (PMODE_ENTRY)&(HwDeviceExtension->ValidModeTable[0]);
   VideoPortMoveMemory(DstModes, SrcModes, sizeof(MODE_ENTRY) * HwDeviceExtension->NumRegistryModes);
   
   //**********************************************************************
   // Limit the modes according to how much video memory is available
   //**********************************************************************
   ModeEntry = DstModes;
   NVInfo = (PHWINFO)&(HwDeviceExtension->NvInfo);

   //**********************************************************************
   // Get the amount of video memory on this card
   //**********************************************************************
   AvailableAdapterMemorySize = NVInfo->Framebuffer.RamSize - HwDeviceExtension->TotalInstanceMemory;
#if (_WIN32_WINNT >= 0x0500)
   if (HwDeviceExtension->ulDualViewStatus & DUALVIEW_STATUS_ENABLE_DUALVIEW)
       AvailableAdapterMemorySize /= 2;
#endif
   
   //**********************************************************************
   // Now parse the modes to see which ones we can use ( Limit by memory first )
   //**********************************************************************
   for (i = 0; i < HwDeviceExtension->NumRegistryModes; i++)
    
      {
       //******************************************************************
       // Handle 15bpp modes same as 16bpp modes (sizewise they're the same)
       //******************************************************************
    
       if ((ModeEntry[i].Depth == 15) || (ModeEntry[i].Depth == 16))
            BytesPerPel = 16/8;
       else
            BytesPerPel = (ModeEntry[i].Depth/8);
    
       //******************************************************************
       // Make the modes that fit in video memory valid. 
       //******************************************************************
    
       if (AvailableAdapterMemorySize >= ModeEntry[i].Width * ModeEntry[i].Height * BytesPerPel )
                        
           {
           //**************************************************************
           // Set the mode as available if it fits in memory
           //**************************************************************
    
           ModeEntry[i].ValidMode = TRUE;
    
           VideoDebugPrint((2,"NVVDM: mode[%d] valid\n",i));
           VideoDebugPrint((2,"NVVDM:   width(%d)\n",ModeEntry[i].Width));
           VideoDebugPrint((2,"NVVDM:   height(%d)\n",ModeEntry[i].Height));
           VideoDebugPrint((2,"NVVDM:   depth(%d)\n",ModeEntry[i].Depth));
           VideoDebugPrint((2,"NVVDM:   refresh(%d)\n",ModeEntry[i].RefreshRate));
           VideoDebugPrint((2,"NVVDM:   bytes needed(%d)\n",ModeEntry[i].Width * ModeEntry[i].Height * BytesPerPel));
           VideoDebugPrint((2,"NVVDM:   memory pres(%d)\n",AvailableAdapterMemorySize));
           }

       else
    
           //**************************************************************
           // Mode not available on this adapter
           //**************************************************************
           {
           ModeEntry[i].ValidMode = FALSE;
           }
      }



   // @ Now that we know what is possible on the "adapter", lets find out whats possible on the requested display device

   // - Assume the requested mode is invalid on the requested device
   ModeValid = FALSE;
   
   // - Filter against requested device   
   switch( vmx->dwDeviceType ) {

      case  MONITOR_TYPE_VGA:
         // - Under NT4, we assume the monitor can do what the adapter can do for now
         //   Under W2K, we would filter again by the monitors caps here
         break;

      case  MONITOR_TYPE_FLAT_PANEL:
         {
            NV_CFGEX_GET_FLATPANEL_INFO_PARAMS fpp;
            unsigned long FPSizeX;
            unsigned long FPSizeY;
            BOOL  RmStatus;

            RmStatus = RmConfigGetExKernel(HwDeviceExtension->DeviceReference, 
                                           NV_CFGEX_GET_FLAT_PANEL_INFO, 
                                           (VOID *)&fpp,
                                           sizeof(NV_CFGEX_GET_FLATPANEL_INFO_PARAMS));

            // - Dynamically assign the width and height maximums  
            if(RmStatus) {
               // - We got something from the Rm, so use its width
               FPSizeX = fpp.FlatPanelSizeX;
               FPSizeY = fpp.FlatPanelSizeY;
            }
            else {
               // changed to match following mods by others 
               FPSizeX = HwDeviceExtension->MaxFlatPanelWidth;
               FPSizeY = HwDeviceExtension->MaxFlatPanelHeight;
            }

            // Look at EDID Detailed block 3 (starts at offset 0x36)
            // See if can find DELL 1501FP flat panel monitor
            if (VideoPortCompareMemory(&pEDIDBuffer[0x36+ (18*2) + 5], "DELL 1501FP", 11)  == 11)
            {
                FoundDell1501FP = TRUE;
            }

            for (i = 0; i < HwDeviceExtension->NumRegistryModes; i++)
    
                {
                if (ModeEntry[i].ValidMode)
    
                    {
                    //**********************************************************
                    // Remove any mode that doesn't have a refresh rate of 60hz.
                    // - EXCEPT for 320x200, and 640x400 which have refresh
                    //   rates at 70hz...these are required by whql)
                    // - EXCEPT DELL 1501FP multisync flat panel monitor
                    //   Limit DELL refresh rates to 75 hz
                    //**********************************************************

                    if (FoundDell1501FP == TRUE)

                        {
                        if ( (ModeEntry[i].Width  > FPSizeX)  ||
                             (ModeEntry[i].Height > FPSizeY)  || 
                             (ModeEntry[i].RefreshRate > 75)                               ||
                             ((ModeEntry[i].Width == 480) && ( ModeEntry[i].Height == 360))   ||
                             ((ModeEntry[i].Width == 1280) && ( ModeEntry[i].Height == 960))  ||
                             ((ModeEntry[i].Width == 960) && ( ModeEntry[i].Height == 720))   ||
                             ((ModeEntry[i].Width == 864) && ( ModeEntry[i].Height == 480))   ||
                             ((ModeEntry[i].Width == 856) && ( ModeEntry[i].Height == 480))   ||
                             ((ModeEntry[i].Width == 852) && ( ModeEntry[i].Height == 480))   ||
                             ((ModeEntry[i].Width == 848) && ( ModeEntry[i].Height == 480))   ||
                             ((ModeEntry[i].Width == 720) && ( ModeEntry[i].Height == 480))   )
    
    
                            {
                            ModeEntry[i].ValidMode = FALSE;
                            }

                        }
                        
                        
                    else
                    
                        {                        
                        if ( (ModeEntry[i].Width  > FPSizeX)  ||
                             (ModeEntry[i].Height > FPSizeY)  || 
                             ((ModeEntry[i].RefreshRate !=60) && 
                                   (!( (ModeEntry[i].RefreshRate == 70) && (ModeEntry[i].Width == 640) && (ModeEntry[i].Height == 400))) &&
                                   (!( (ModeEntry[i].RefreshRate == 70) && (ModeEntry[i].Width == 320) && (ModeEntry[i].Height == 200))))     ||
                             ((ModeEntry[i].Width == 480) && ( ModeEntry[i].Height == 360))   ||
                             ((ModeEntry[i].Width == 1280) && ( ModeEntry[i].Height == 960))  ||
                             ((ModeEntry[i].Width == 960) && ( ModeEntry[i].Height == 720))   ||
                             ((ModeEntry[i].Width == 864) && ( ModeEntry[i].Height == 480))   ||
                             ((ModeEntry[i].Width == 856) && ( ModeEntry[i].Height == 480))   ||
                             ((ModeEntry[i].Width == 852) && ( ModeEntry[i].Height == 480))   ||
                             ((ModeEntry[i].Width == 848) && ( ModeEntry[i].Height == 480))   ||
                             ((ModeEntry[i].Width == 720) && ( ModeEntry[i].Height == 480))   )
    
    
                            {
                            ModeEntry[i].ValidMode = FALSE;
                            }

                        }
    
                    }
    
                }
         }
         break;

      case  MONITOR_TYPE_NTSC:
      case  MONITOR_TYPE_PAL:
         // - For now, we use the TV modes filter from VnValidateModes above
         for(i = 0; i < HwDeviceExtension->NumRegistryModes; i++) {

             if(ModeEntry[i].ValidMode) {

                //**********************************************************
                // Remove all modes greater than width == 800, AND
                // any mode that doesn't have a refresh rate of 60hz.
                // (EXCEPT for 320x200, and 640x400 which have refresh
                // rates at 70hz...these are required by whql)
                //**********************************************************

                if ( (ModeEntry[i].Width > 800)  || 
                    ((ModeEntry[i].RefreshRate !=60) && 
                        (!( (ModeEntry[i].RefreshRate == 70) && (ModeEntry[i].Width == 640) && (ModeEntry[i].Height == 400))) &&
                        (!( (ModeEntry[i].RefreshRate == 70) && (ModeEntry[i].Width == 320) && (ModeEntry[i].Height == 200))))     ||
                    ((ModeEntry[i].Width == 480) && ( ModeEntry[i].Height == 360)) ) {

                    ModeEntry[i].ValidMode = FALSE;
                    }
    
                }
    
         }
         break;

      default:
         // - We dont know this device, so mark all modes invalid
         for(i = 0; i < HwDeviceExtension->NumRegistryModes; i++) {

           ModeEntry[i].ValidMode = FALSE;
         }
         break;

   }


   // - Adjust for the refresh type, if dwRefresh is 0, use 60Hz
   if(vmx->dwRefresh == 0) {
      refresh = 60;
   }
   else {
      refresh = vmx->dwRefresh;
   }


   // - Finally, see if requested mode is in the trimmed modes table
   for(i = 0; (ModeValid == FALSE) && (i < HwDeviceExtension->NumRegistryModes) ; i++) {

      if(ModeEntry[i].ValidMode) {

         if( ModeEntry[i].Width == vmx->dwHRes &&
             ModeEntry[i].Height == vmx->dwVRes &&
             ModeEntry[i].Depth == vmx->dwBpp &&
             ModeEntry[i].RefreshRate == refresh ) {

            // - We located the mode, so indicate valid and break out...
            ModeValid = TRUE;
            index = i;
         }
      }
   }


   if(ModeValid) {
      VideoDebugPrint((1,"NVVDM:   Requested mode is VALID...\n"));
      VideoDebugPrint((1,"NVVDM:    width(%d)\n",ModeEntry[index].Width));
      VideoDebugPrint((1,"NVVDM:    height(%d)\n",ModeEntry[index].Height));
      VideoDebugPrint((1,"NVVDM:    depth(%d)\n",ModeEntry[index].Depth));
      VideoDebugPrint((1,"NVVDM:    refresh(%d)\n",ModeEntry[index].RefreshRate));
   }
   else {
      VideoDebugPrint((1,"NVVDM:   Requested mode is INVALID...\n"));
   }


   // - Return the validity code derived above
   return(ModeValid);
}


//
// Does a one-time initialization of various fields required by the new common mode set code.
// Initilizes the pixelclockfrequency limits for 8/16/32 bpp for each head.
//
void InitializeCommonModesetCode(PHW_DEVICE_EXTENSION HwDeviceExtension)
{

    NV_CFGEX_DAC_PCLK_LIMIT_PARAMS ClkParams;
    ULONG ulHead;

    // Initilize the floating point save/restore code.
    InitializeFPCode(&HwDeviceExtension->pFPStateSave, &HwDeviceExtension->pFPMutex);

    for (ulHead = 0; ulHead < HwDeviceExtension->DeskTopInfo.ulNumberDacsOnBoard; ulHead++)
    {
        ClkParams.Head = ulHead;
        ClkParams.pclkLimit = 0;

        //
        // Check if CRT is connected for second head. Only then should we
        // use the pixel clock for the second head. Otherwise, we should use the pixel clock of
        // DAC 0 for both heads.
        //
        // if (ulHead == 1 && HwDeviceExtension->DeskTopInfo.ulDeviceType[ulHead] != MONITOR_TYPE_VGA) {
        // ClkParams.Head = 0;
        // }
            

        if (!RmConfigGetExKernel(HwDeviceExtension->DeviceReference, NV_CFGEX_DAC_PCLK_LIMIT_8BPP, (VOID *)&ClkParams, sizeof(NV_CFGEX_DAC_PCLK_LIMIT_PARAMS))) {
            VideoDebugPrint((0,"Oops!  RmConfigGetExKernel() failed NV_CFGEX_DAC_PCLK_LIMIT_8BPP for Head: 0x%x\n",ulHead));
            return;
        } else {
            HwDeviceExtension->maxPixelClockFrequency_8bpp[ulHead] = ClkParams.pclkLimit;
        }
        if (!RmConfigGetExKernel(HwDeviceExtension->DeviceReference, NV_CFGEX_DAC_PCLK_LIMIT_16BPP, (VOID *)&ClkParams, sizeof(NV_CFGEX_DAC_PCLK_LIMIT_PARAMS))) {
            VideoDebugPrint((0,"Oops!  RmConfigGetExKernel() failed NV_CFGEX_DAC_PCLK_LIMIT_16BPP for Head: 0x%x\n",ulHead));
            return;
        } else {
            HwDeviceExtension->maxPixelClockFrequency_16bpp[ulHead] = ClkParams.pclkLimit;
        }
        if (!RmConfigGetExKernel(HwDeviceExtension->DeviceReference, NV_CFGEX_DAC_PCLK_LIMIT_32BPP, (VOID *)&ClkParams, sizeof(NV_CFGEX_DAC_PCLK_LIMIT_PARAMS))) {
            VideoDebugPrint((0,"Oops!  RmConfigGetExKernel() failed NV_CFGEX_DAC_PCLK_LIMIT_32BPP for Head: 0x%x\n",ulHead));
            return;
        } else {
            HwDeviceExtension->maxPixelClockFrequency_32bpp[ulHead] = ClkParams.pclkLimit;
        }

        // sanity check
        if (HwDeviceExtension->maxPixelClockFrequency_8bpp[ulHead] == 0 || 
            HwDeviceExtension->maxPixelClockFrequency_16bpp[ulHead] == 0 || 
            HwDeviceExtension->maxPixelClockFrequency_32bpp[ulHead] == 0) {
             VideoDebugPrint((0,"oops! MaxPixelClockFreq is 0!!!. Returning\n"));
             return;
        }

        VideoDebugPrint((1,"Head: %d, Max8bppFreq (HZ): 0x%x\n",ulHead, HwDeviceExtension->maxPixelClockFrequency_8bpp[ulHead]));
        VideoDebugPrint((1,"Head: %d, Max16bppFreq (HZ): 0x%x\n",ulHead, HwDeviceExtension->maxPixelClockFrequency_16bpp[ulHead]));
        VideoDebugPrint((1,"Head: %d, Max32bppFreq (HZ): 0x%x\n",ulHead, HwDeviceExtension->maxPixelClockFrequency_32bpp[ulHead]));
    }
}

//
// uses the commond mode set code FindModeEntry() to get the monitor timings for the reqested resolution and head.
// If the ulOption flag is set to HEAD_RESOLUTION_OPTION_DONT_BACKOFF, then if the requested mode is not 
// supported in the EDID, ignores the EDID and returns the timing without backing off.
//
ULONG GetTimingDacCommonModesetCode(PHW_DEVICE_EXTENSION HwDeviceExtension, HEAD_RESOLUTION_INFO *pResolution, DAC_TIMING_VALUES * pTimingInfo)
{
    ULONG ulFrequencyHead;
    DISPDATA DispData;
    MODEINFO ModeDesc;
    MODEOUT  ModeOut;
    MODEINFO ModeNew;
    ULONG ulRet;
    ULONG ulHeadEDID;
    LPEDID_UNIT pEdidUnit;

    LPDISPDATA lpDispData;
    LPMODEINFO lpModeDesc;
    LPMODEOUT  lpModeOut;
    LPMODEINFO lpModeNew;

    lpDispData = &DispData;
    lpModeDesc = &ModeDesc;
    lpModeOut = &ModeOut;
    lpModeNew = &ModeNew;

    VideoDebugPrint((3,"Enter GetTimingDacCommonModesetCode()\n"));

    //
    // Check if CRT is connected for second head. Only then should we
    // use the pixel clock for the second head. Otherwise, we should use the pixel clock of
    // DAC 0 for both heads.
    //
    ulFrequencyHead = pResolution->ulHead;
    if (pResolution->ulHead == 1 && pResolution->ulDeviceType != MONITOR_TYPE_VGA) {
         ulFrequencyHead = 0;
    }

    
    ulHeadEDID = ConvertDeviceMaskToIndex(pResolution->ulDeviceMask);
    pEdidUnit  = HwDeviceExtension->EdidCollection->HeadMaps[ulHeadEDID];
    pResolution->ulDeviceType = MaskToDeviceType(pResolution->ulDeviceMask);
    
    lpDispData->lpBoardRegistryData = NULL;
    lpDispData->lpMonitorRegistryData = NULL;
    if (pEdidUnit->Valid)
    {
        lpDispData->dwMonitorInfType = PLUG_AND_PLAY_DEVICE;
    }
    else
    {
        lpDispData->dwMonitorInfType = UNKNOWN_DEVICE;
    }
    
    lpDispData->dwDeviceID = HwDeviceExtension->ulChipID;
    lpDispData->dwCRTCIndex = pResolution->ulHead;
    lpDispData->dwVideoMemoryInBytes = HwDeviceExtension->AdapterMemorySize;
    lpDispData->dwMaxDacSpeedInHertz8bpp= HwDeviceExtension->maxPixelClockFrequency_8bpp[ulFrequencyHead];
    lpDispData->dwMaxDacSpeedInHertz16bpp = HwDeviceExtension->maxPixelClockFrequency_16bpp[ulFrequencyHead];
    lpDispData->dwMaxDacSpeedInHertz32bpp = HwDeviceExtension->maxPixelClockFrequency_32bpp[ulFrequencyHead];
    lpDispData->dwMaxDfpScaledXResInPixels = HwDeviceExtension->MaxFlatPanelWidth;
    lpDispData->lpfnGetModeSize = 0;  // GK: WHat is this?
    lpDispData->dwContext1 = (PVOID)HwDeviceExtension;
    lpDispData->dwContext2 = (PVOID)0;
    lpDispData->dwMaxTVOutResolution = HwDeviceExtension->ulMaxTVOutResolution;

    lpModeDesc->dwXRes = pResolution->ulDisplayWidth;
    lpModeDesc->dwYRes = pResolution->ulDisplayHeight;

    if((pResolution->ulDeviceType == MONITOR_TYPE_FLAT_PANEL) && (HwDeviceExtension->ulDisableDfpModesGreaterThan))
    {
        ULONG ulWidth, ulHeight;

        // Registry key force to limit the resolution
        ulWidth = HwDeviceExtension->ulDisableDfpModesGreaterThan >> 16;
        ulHeight = HwDeviceExtension->ulDisableDfpModesGreaterThan & 0xFFFF;
        if ((pResolution->ulDisplayWidth > ulWidth) && (pResolution->ulDisplayHeight > ulHeight))
        { 
            lpModeDesc->dwXRes = ulWidth;
            lpModeDesc->dwYRes = ulHeight;
        }
    }

    lpModeDesc->dwBpp = pResolution->ulDisplayPixelDepth;
    lpModeDesc->dwRefreshRate = pResolution->ulDisplayRefresh;
    lpModeDesc->dwDevType = MaskToFindModeEntryDeviceType(pResolution->ulDeviceMask);
    lpModeDesc->dwTVFormat = pResolution->ulTVFormat;
    lpModeDesc->dwOriginalRefreshRate = pResolution->ulDisplayRefresh; 

    lpModeDesc->MIDevData.cType     = (CHAR)MaskToFindModeEntryDeviceType(pResolution->ulDeviceMask);
    lpModeDesc->MIDevData.cNumber   = (CHAR)MaskToDeviceType(pResolution->ulDeviceMask);
    lpModeDesc->MIDevData.cFormat   = (CHAR)pResolution->ulTVFormat;
    lpModeDesc->MIDevData.cReserved = 0x0;

    // Call the modeset DLL to see if this mode is valid.
    VideoDebugPrint((3,"Before: lpModeDescr: %d, %d, %d bpp, %d HZ, 0x%x devType, %d HZ ori\n",
       lpModeDesc->dwXRes, lpModeDesc->dwYRes, lpModeDesc->dwBpp, lpModeDesc->dwRefreshRate, 
       lpModeDesc->dwDevType, lpModeDesc->dwOriginalRefreshRate));

    EnterFPCode(HwDeviceExtension->pFPStateSave, HwDeviceExtension->pFPMutex);

    ulRet = FindModeEntry(lpDispData, pEdidUnit->EDIDBuffer, pEdidUnit->Size,
                          lpModeDesc, lpModeOut, lpModeNew);
    
    ExitFPCode(HwDeviceExtension->pFPStateSave, HwDeviceExtension->pFPMutex);

    VideoDebugPrint((3,"ulRet: 0x%x\n",ulRet));
    VideoDebugPrint((3,"After: lpModeDescr: %d, %d, %d bpp, %d HZ, 0x%x devType, %d HZ ori\n",
       lpModeDesc->dwXRes, lpModeDesc->dwYRes, lpModeDesc->dwBpp, lpModeDesc->dwRefreshRate, 
       lpModeDesc->dwDevType, lpModeDesc->dwOriginalRefreshRate));
    VideoDebugPrint((3,"After: lpModeNew: %d, %d, %d bpp, %d HZ, 0x%x devType, %d HZ ori\n",
       lpModeNew->dwXRes, lpModeNew->dwYRes, lpModeNew->dwBpp, lpModeNew->dwRefreshRate, 
       lpModeNew->dwDevType, lpModeNew->dwOriginalRefreshRate));
    if (ulRet != 0)
    {
        VideoDebugPrint((3, "EDID does not support this requested mode: ulRet: 0x%x\n", ulRet));
        //
        // This should not happen on laptop systems. We should never ask the timings for an unsupported
        // mode as pan-scan is handled in the display driver.
        //
        if (HwDeviceExtension->ACPISystem)
        {
            VideoDebugPrint((1,"Laptop: Something wrong. Asking for unsupported physical mode timings"));
            VideoDebugPrint((1,"lpModeDescr: %d, %d, %d bpp, %d HZ, 0x%x devType, %d HZ ori\n",
               lpModeDesc->dwXRes, lpModeDesc->dwYRes, lpModeDesc->dwBpp, lpModeDesc->dwRefreshRate, 
               lpModeDesc->dwDevType, lpModeDesc->dwOriginalRefreshRate));
            VideoDebugPrint((1,"lpModeNew: %d, %d, %d bpp, %d HZ, 0x%x devType, %d HZ ori\n",
               lpModeNew->dwXRes, lpModeNew->dwYRes, lpModeNew->dwBpp, lpModeNew->dwRefreshRate, 
               lpModeNew->dwDevType, lpModeNew->dwOriginalRefreshRate));
        }
        else
        {
            //
            // This is a desktop system. We now try without the EDID. We do this only if the
            // HEAD_RESOLUTION_OPTION_DONT_BACKOFF is set.
            //
            if (pResolution->ulOption & HEAD_RESOLUTION_OPTION_DONT_BACKOFF)
            {
                VideoDebugPrint((1,"Desktop: Getting timing without the EDID\n"));
                lpDispData->dwMonitorInfType = UNKNOWN_DEVICE;
                EnterFPCode(HwDeviceExtension->pFPStateSave, HwDeviceExtension->pFPMutex);

                ulRet = FindModeEntry(lpDispData, NULL, 0,
                          lpModeDesc, lpModeOut, lpModeNew);
    
                ExitFPCode(HwDeviceExtension->pFPStateSave, HwDeviceExtension->pFPMutex);

                VideoDebugPrint((1,"ulRet: 0x%x\n",ulRet));
                VideoDebugPrint((1,"After: lpModeDescr: %d, %d, %d bpp, %d HZ, 0x%x devType, %d HZ ori\n",
                   lpModeDesc->dwXRes, lpModeDesc->dwYRes, lpModeDesc->dwBpp, lpModeDesc->dwRefreshRate, 
                   lpModeDesc->dwDevType, lpModeDesc->dwOriginalRefreshRate));
                VideoDebugPrint((1,"After: lpModeNew: %d, %d, %d bpp, %d HZ, 0x%x devType, %d HZ ori\n",
                   lpModeNew->dwXRes, lpModeNew->dwYRes, lpModeNew->dwBpp, lpModeNew->dwRefreshRate, 
                   lpModeNew->dwDevType, lpModeNew->dwOriginalRefreshRate));
            }
        }
    }
    VideoDebugPrint((3,"lpModeOut: 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x,0x%x, 0x%x, 0x%x, 0x%x,0x%x, 0x%x, 0x%x, 0x%x\n",
          lpModeOut->wXRes,
          lpModeOut->wYRes,
          lpModeOut->wHBlankStart,
          lpModeOut->wHBlankWidth,
          lpModeOut->wHSyncStart,
          lpModeOut->wHSyncWidth,
          lpModeOut->wVBlankStart,
          lpModeOut->wVBlankWidth,
          lpModeOut->wVSyncStart,
          lpModeOut->wVSyncWidth,
          lpModeOut->wHTotal,
          lpModeOut->wVTotal,
          lpModeOut->dwPixelClock,
          lpModeOut->dwFormat,
          lpModeOut->wRefreshRate,
          lpModeOut->dwPitchInBytes));

    // Copy the timing info into DAC_TIMING_VALUES
    pTimingInfo->HorizontalVisible = lpModeOut->wXRes;
    pTimingInfo->VerticalVisible = lpModeOut->wYRes;
    pTimingInfo->Refresh = lpModeOut->wRefreshRate;
    pTimingInfo->HorizontalTotal = lpModeOut->wHTotal;
    pTimingInfo->VerticalTotal = lpModeOut->wVTotal;
    pTimingInfo->HorizontalBlankStart = lpModeOut->wHBlankStart;
    pTimingInfo->VerticalBlankStart = lpModeOut->wVBlankStart;
    pTimingInfo->HorizontalRetraceStart = lpModeOut->wHSyncStart;
    pTimingInfo->VerticalRetraceStart = lpModeOut->wVSyncStart;
    pTimingInfo->HorizontalRetraceEnd = lpModeOut->wHSyncStart + lpModeOut->wHSyncWidth;
    pTimingInfo->VerticalRetraceEnd = lpModeOut->wVSyncStart + lpModeOut->wVSyncWidth;
    pTimingInfo->HorizontalBlankEnd = lpModeOut->wHBlankStart + lpModeOut->wHBlankWidth;
    pTimingInfo->VerticalBlankEnd = lpModeOut->wVBlankStart + lpModeOut->wVBlankWidth;
    pTimingInfo->PixelClock = lpModeOut->dwPixelClock;
    pTimingInfo->HSyncpolarity = (lpModeOut->dwFormat & 0x4);
    pTimingInfo->VSyncpolarity = (lpModeOut->dwFormat & 0x8);

    VideoDebugPrint((3,"Exit GetTimingDacCommonModesetCode()\n"));
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\nvntioctl.h ===
// NT client IOCTLs

// NV graphics device driver string
#define NVRM_NAME_STRING L"\\Device\\nvgfx"
#define NVRM_LINK_STRING L"\\DosDevices\\nvgfx"

// device type and base control code
#define FILE_DEVICE_NVRM    0x00008000
#define NVRM_IOCTL_INDEX    0x00000800
#define NV_IOCTL_CODE(f)            \
    CTL_CODE(                       \
        FILE_DEVICE_NVRM+(f),       \
        NVRM_IOCTL_INDEX,           \
        METHOD_BUFFERED,            \
        FILE_ANY_ACCESS             \
    )

// control codes
#define IOCTL_NV01_ALLOC_ROOT           NV_IOCTL_CODE(NV01_ALLOC_ROOT)
#define IOCTL_NV01_ALLOC_DEVICE         NV_IOCTL_CODE(NV01_ALLOC_DEVICE)
#define IOCTL_NV01_ALLOC_CONTEXT_DMA    NV_IOCTL_CODE(NV01_ALLOC_CONTEXT_DMA)
#define IOCTL_NV01_ALLOC_CHANNEL_PIO    NV_IOCTL_CODE(NV01_ALLOC_CHANNEL_PIO)
#define IOCTL_NV03_ALLOC_CHANNEL_DMA    NV_IOCTL_CODE(NV03_ALLOC_CHANNEL_DMA)
#define IOCTL_NV01_ALLOC_MEMORY         NV_IOCTL_CODE(NV01_ALLOC_MEMORY)
#define IOCTL_NV01_ALLOC_OBJECT         NV_IOCTL_CODE(NV01_ALLOC_OBJECT)
#define IOCTL_NV01_ALLOC_EVENT          NV_IOCTL_CODE(NV01_ALLOC_EVENT)
#define IOCTL_NV04_ALLOC                NV_IOCTL_CODE(NV04_ALLOC)
#define IOCTL_NV01_FREE                 NV_IOCTL_CODE(NV01_FREE)
#define IOCTL_NV03_DMA_FLOW_CONTROL     NV_IOCTL_CODE(NV03_DMA_FLOW_CONTROL)
#define IOCTL_NV01_ARCH_HEAP            NV_IOCTL_CODE(NV01_ARCH_HEAP)
#define IOCTL_NV01_CONFIG_VERSION       NV_IOCTL_CODE(NV01_CONFIG_VERSION)
#define IOCTL_NV01_CONFIG_GET           NV_IOCTL_CODE(NV01_CONFIG_GET)
#define IOCTL_NV01_CONFIG_SET           NV_IOCTL_CODE(NV01_CONFIG_SET)
#define IOCTL_NV04_CONFIG_GET_EX        NV_IOCTL_CODE(NV04_CONFIG_GET_EX)
#define IOCTL_NV04_CONFIG_SET_EX        NV_IOCTL_CODE(NV04_CONFIG_SET_EX)
#define IOCTL_NV01_CONFIG_UPDATE        NV_IOCTL_CODE(NV01_CONFIG_UPDATE)
#define IOCTL_NV01_DEBUG_CONTROL        NV_IOCTL_CODE(NV01_DEBUG_CONTROL)
#define IOCTL_NV04_I2C_ACCESS           NV_IOCTL_CODE(NV04_I2C_ACCESS)
#define IOCTL_NV04_DIRECT_METHOD_CALL   NV_IOCTL_CODE(NV04_DIRECT_METHOD_CALL)

#define MAX_AGP_HEAP 0x02000000
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\nvntver.h ===
// nvver.h
//      Versions of NV drivers
//
// Copyright (C) NVidia Corporation 1997.
// Portions Copyright 1993,1996 NVidia Corporation. All Rights Reserved.
//

//
// This is the version number for the build. This is the only string which needs
// to be modified to bump the version number.
//
#include "nvver.h"
#define NV_VER                      NV_VERSION_STRING

//
// Common strings used in all binaries.
//
#ifdef VER_COMPANYNAME_STR
#undef VER_COMPANYNAME_STR
#endif

//
// MS build/version number for WHQL compliance - NT4
//
#ifdef VER_PRODUCTBUILD_QFE
#undef VER_PRODUCTBUILD_QFE
#endif
#define VER_PRODUCTBUILD_QFE NV_DRIVER_VERSION

//
// MS build/version number for WHQL compliance - Win2K.
//
#if (_WIN32_WINNT > 0x0400)

#ifdef VER_PRODUCTBUILD
#undef VER_PRODUCTBUILD
#endif
#define VER_PRODUCTBUILD 01

#ifdef VER_PRODUCTBUILD_QFE
#undef VER_PRODUCTBUILD_QFE
#endif
#define VER_PRODUCTBUILD_QFE NV_DRIVER_VERSION

#ifdef VER_PRODUCTVERSION_STRING
#undef VER_PRODUCTVERSION_STRING
#endif
#define VER_PRODUCTVERSION_STRING "5.13"

#ifdef VER_PRODUCTVERSION
#undef VER_PRODUCTVERSION
#endif
#define VER_PRODUCTVERSION 5,13,VER_PRODUCTBUILD,VER_PRODUCTBUILD_QFE

#ifdef VER_PRODUCTVERSION_W
#undef VER_PRODUCTVERSION_W
#endif
#define VER_PRODUCTVERSION_W (0x0513)

#ifdef VER_PRODUCTVERSION_DW
#undef VER_PRODUCTVERSION_DW
#endif
#define VER_PRODUCTVERSION_DW (0x05130000 | VER_PRODUCTBUILD)

#endif  //Win2K

#define VER_COMPANYNAME_STR         NV_COMPANY_NAME_STRING
#define VER_LEGALCOPYRIGHT_STR      "Copyright  NVIDIA Corp. 1996-2001"

//
// Strings used in the miniport driver.
//
#define NV_MINI_VER  NV_NTMINIVER
#define NV_MINI_NAME NV_NTMINIVER

//
// Strings used in the display driver.
//
#define NV_DISP_VER  NV_NTDISPVER
#define NV_DISP_NAME NV_NTDISPVER


//
// This hackery is only necessary for NT4, since the NT4 DDK version
// files expect VER_PRODUCTVERSION_STR to be the version number.
//
#if (_WIN32_WINNT < 0x0500)
#if     (VER_PRODUCTBUILD < 10)
#define VER_BPAD "000"
#elif   (VER_PRODUCTBUILD < 100)
#define VER_BPAD "00"
#elif   (VER_PRODUCTBUILD < 1000)
#define VER_BPAD "0"
#else
#define VER_BPAD
#endif

#define VER_PRODUCTVERSION_STRING "4.00"
#define VER_PRODUCTVERSION_STR2(x,y) VER_PRODUCTVERSION_STRING "." VER_BPAD #x "." #y
#define VER_PRODUCTVERSION_STR1(x,y) VER_PRODUCTVERSION_STR2(x, y)

#ifdef VER_PRODUCTVERSION_STR
#undef VER_PRODUCTVERSION_STR
#endif

#define VER_PRODUCTVERSION_STR VER_PRODUCTVERSION_STR1(VER_PRODUCTBUILD, VER_PRODUCTBUILD_QFE)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\nvfloat.c ===
//******************************************************************************
//
// Copyright (c) 1992  Microsoft Corporation
//
// Module Name:
//
//     nvFloat.C
//
// Abstract:
//
//     Contains routines for protecting the Floating Point operations for the modeset code.
//     Note: 
//     - I had to create a seperate file for these routines since I could not include
//     ntddk.h in nv.c as that would lead to redifinition compiler errors in miniport.h
//     and video.h etc..
//     - We can not include nv.h in nvFloat due to conflict with ntddk.h. 
//     Hence no reference to HwDeviceExtension structure is allowed in this file.
//
// Environment:
//
//     kernel mode only
//
//
//******************************************************************************

//******************************************************************************
//
// Copyright (c) 1996,1997  NVidia Corporation. All Rights Reserved
//
//******************************************************************************

#include "ntddk.h"
#include "nvMultiMon.h"
#include "nvsvc_public.h"

//
// These definitions are not found in ntddk.h for NT4.0, so manually define them.
//
#if _WIN32_WINNT < 0x0500
      //
      // The non-volatile 387 state
      //
        
      typedef struct _KFLOATING_SAVE {
          ULONG   DoNotUse1;
          ULONG   DoNotUse2;
          ULONG   DoNotUse3;
          ULONG   DoNotUse4;
          ULONG   DoNotUse5;
          ULONG   DoNotUse6;
          ULONG   DoNotUse7;
          ULONG   DoNotUse8;
      } KFLOATING_SAVE, *PKFLOATING_SAVE;
  

      NTKERNELAPI
      KeSaveFloatingPointState (
         OUT PKFLOATING_SAVE     FloatSave
         );
      
      NTKERNELAPI
      KeRestoreFloatingPointState (
         IN PKFLOATING_SAVE      FloatSave
         );
#endif // #if _WIN32_WINNT < 0x0500

VOID InitializeFPCode(VOID **ppSave, VOID **pMutex);
VOID EnterFPCode(VOID *pSave, VOID *pMutex);
VOID ExitFPCode(VOID *pSave, VOID *pMutex);

//VOID CheckForcedResolution(PHW_DEVICE_EXTENSION HwDeviceExtension, ULONG ulWidth, ULONG ulHeight, ULONG ulDepth, ULONG ulRefreshRate, BOOLEAN SetBestResolution );
//
// moved to nv.c because I can't include nv.h here (since ntddk.h is included)  
//
// The build dependency tree is a mess!


//
// Exported event functions
//
VOID SignalModeSwitchEvent();
VOID SignalNVCplHotKeyEvent();
VOID InitNVSVCEvents();

//
// internal helper event function.
//
VOID HandleEvent(PCSZ pEventName, ULONG ulAction);


//
// Does a one time initialization to create the mutex and the floating point save buffer
// This function does the following
// - Initilize the mutex. Supported only for Win2K and later.
// - Initialize the buffer to save the FP state. 
//
VOID InitializeFPCode(VOID **ppSave, VOID **ppMutex)
{
    *ppSave = NULL;
    *ppMutex = NULL;

    // Allocate the FP state save area.
    // 0 is for nonpaged pool.
    *ppSave = ExAllocatePool(NonPagedPool, sizeof(KFLOATING_SAVE));

#ifdef ENABLE_FP_MUTEX
#if (_WIN32_WINNT >= 0x0500)
    // Initialize the fast mutex. These are defined only in win2K.
    *ppMutex = ExAllocatePool(NonPagedPool, sizeof(FAST_MUTEX));
    if (*ppMutex == NULL)
    {
        return;
    }
    ExInitializeFastMutex((FAST_MUTEX *)*ppMutex);
#endif
#endif ENABLE_FP_MUTEX
}

//
// Call this function before doing Floatng point operations. Every call to EnterFPMutex() _should_ be matched with
// a corresponding call to ExitFPMutex().
// - Acuires the mutex inorder to disable all interrupts so that this thread does not get time sliced by the OS scheduler.
// - Saves the FP state.
//
VOID EnterFPCode(VOID *pSave, VOID *pMutex)
{
    NTSTATUS Status;
    // First Disable the interrupts
    // For NT4.0, we use the brute force way of cli/sti.
    // For Win2K, we use fast mutexes.
#ifdef ENABLE_FP_MUTEX
#if (_WIN32_WINNT >= 0x0500)
    if (pMutex != NULL)
    {
        // Acquire the mutex now.
        ExAcquireFastMutex((FAST_MUTEX *)pMutex);
    }
#else
    //
    // NT 4.0 case
    // Note: Do not do any registry reads while interrupts are disabled as that causes NT4.0
    // to BSOD.
    //
     _asm
     {
        cli
     }
#endif (_WIN32_WINNT >= 0x0500)
#endif ENABLE_FP_MUTEX

    // If the FP state save area was not created, we do nothing and exit.
    if (pSave == NULL)
    {
        return;
    }

    // Now save the FP state.
    Status = KeSaveFloatingPointState((KFLOATING_SAVE *)pSave);

}


//
// Call this function before exiting Floatng point operations. Every call to EnterFPMutex() _should_ be matched with
// a corresponding call to ExitFPMutex().
// - Releases the mutex
// - Restores the FP state.
//
VOID ExitFPCode(VOID *pSave, VOID *pMutex)
{
    NTSTATUS Status;

    // If the FP state save area was created, we restore the Floating Point state.
    if (pSave != NULL)
    {
        Status = KeRestoreFloatingPointState((KFLOATING_SAVE *)pSave);
    }

    // Now enable the interrupts.
    // For NT4.0, we use the brute force way of cli/sti.
    // For Win2K, we use fast mutexes.
#ifdef ENABLE_FP_MUTEX
#if (_WIN32_WINNT >= 0x0500)
    if (pMutex != NULL)
    {
        // Release the mutex now.
        ExReleaseFastMutex((FAST_MUTEX *)pMutex);
    }
#else
    // NT 4.0 case
    // Note: Do not do any registry reads while interrupts are disabled as that causes NT4.0
    // to BSOD.
     _asm
     {
        sti
     }
#endif (_WIN32_WINNT >= 0x0500)
#endif ENABLE_FP_MUTEX

}


//
// Signals the "NVModeSwitchEvent" object to wake up the NVSVC to induce a modeset. The actual deviceMask
// to be used by the nvPanel will be returned in an escape callNV_ESC_INDUCE_MODESET
//
VOID SignalModeSwitchEvent()
{
    HandleEvent(NVSVC_EVENT_MODESWITCH_DRIVER, EVENT_ACTION_SIGNAL);
}

//
// Signals the "NVCplHotKeyEvent" object to let the control panel thread know that a 
// hotkey device switch has taken place.
//
VOID SignalNVCplHotKeyEvent()
{
    HandleEvent(NVCPL_EVENT_HOTKEY_DRIVER, EVENT_ACTION_SIGNAL);
}

//
// Create the events that NVSVC sleeps on and set them to cleared state. We need to
// explicitly clear the created event since they would be created with signalled state.
//
VOID InitNVSVCEvents()
{
    UNICODE_STRING EventUnicodeString;
    PKEVENT EventPtr = NULL;
    HANDLE  EventHandle;

    HandleEvent(NVSVC_EVENT_ICONBEGIN_DRIVER, EVENT_ACTION_CREATE);
    HandleEvent(NVSVC_EVENT_ICONEND_DRIVER, EVENT_ACTION_CREATE);
    HandleEvent(NVSVC_EVENT_MODESWITCH_DRIVER, EVENT_ACTION_CREATE);

    //
    // This event is _not_ used by NVSVC. It is used for a special case control panel thread. If the control
    // panel is already open, and the user preses a hotkey on laptops, control panel needs to know that
    // a hotkey device switch has happened. This is because if the same desktop mode is maintained after the 
    // device switch, the OS does not send a WM_DISPLAYCHANGE message to the control panel thread.
    //
    HandleEvent(NVCPL_EVENT_HOTKEY_DRIVER, EVENT_ACTION_CREATE);
}



//
// This helper function performs the specified operation on the requested named event.
// Arguements:
// pEventName:      In parameter: An event name such as  "\\BaseNamedObjects\\SomeEventName" passed as constant string. 
//                  These names are defined uniquely in either nvsvc_public.h or nvMultiMon.h
// ulAction:        In Parameter: 
//                  EVENT_ACTION_CREATE: creates the named event and sets it to cleared state.
//                  EVENT_ACTION_SIGNAL: signals the named event.
//                  EVENT_ACTION_CLEAR:  clears the named event.                        
// Return Value:    None
//
VOID HandleEvent(PCSZ pEventName, ULONG ulAction)
{
    ANSI_STRING sAnsiString;
    ULONG NameLength;
    UNICODE_STRING sEventUniCodeString;
    PKEVENT EventPtr = NULL;
    HANDLE  EventHandle;
    WCHAR   NameBuffer[NVSVC_EVENT_NAME_MAX_LENGTH];

    //
    // Sanity checks.
    //
    if (pEventName == NULL)
    {
        return;
    }
    NameLength = strlen(pEventName);
    if (NameLength > NVSVC_EVENT_NAME_MAX_LENGTH)
    {
        return;
    }
       
    //
    // convert the requested reguar string to an ansi string.
    //
    RtlInitAnsiString(&sAnsiString, pEventName);
    //
    // Allocate the buffer for the string for the unicode
    //
    sEventUniCodeString.Length = sEventUniCodeString.MaximumLength = sizeof(NameBuffer);
    sEventUniCodeString.Buffer = (PWSTR)NameBuffer;
    //
    // Convert the ansi string to a unicode string.
    //
    RtlAnsiStringToUnicodeString(&sEventUniCodeString, &sAnsiString, FALSE);
    //
    // Finally, get the event pointer and signal the event.
    //
    EventPtr = IoCreateSynchronizationEvent(&sEventUniCodeString, &EventHandle);
    if (EventPtr)
    {
        //
        // Perform the requested operation
        //
        switch (ulAction)
        {
        case EVENT_ACTION_CREATE:
            //
            // We need to clear because a newly created event gets born in a signalled state.
            //
            KeClearEvent(EventPtr);
            break;
        case EVENT_ACTION_CLEAR:
            KeClearEvent(EventPtr);
            break;
        case EVENT_ACTION_SIGNAL:
            KeSetEvent(EventPtr, 0, FALSE);
            break;
        default:
            break;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\nvpekmvt.h ===
/*
==============================================================================

    NVIDIA Corporation, (C) Copyright 
    1996,1997,1998,1999. All rights reserved.

    nvpekmvt.h

    Local definitions used by kernel mode video transport

    Dec 17, 1999

==============================================================================
*/

#ifndef _NVPEKMVT_H
#define _NVPEKMVT_H

typedef unsigned long	DWORD;

#include "dxmini.h"


#ifndef NTSTATUS
typedef LONG NTSTATUS;
#endif
#define PDEVICE_OBJECT	PVOID
#include "i2cgpio.h"

extern ULONG NVGetI2CPort (ULONG HwID);
extern ULONG NVGetI2CHead (ULONG HwID);

extern NTSTATUS dynI2COpen (PDEVICE_OBJECT pDev, ULONG acquire, PI2CControl pI2CCtrl);
extern NTSTATUS dynI2CAccess (PDEVICE_OBJECT pDev, PI2CControl pI2CCtrl);

extern NTSTATUS priI2COpen (PDEVICE_OBJECT pDev, ULONG acquire, PI2CControl pI2CCtrl);
extern NTSTATUS priI2CAccess (PDEVICE_OBJECT pDev, PI2CControl pI2CCtrl);

extern NTSTATUS secI2COpen (PDEVICE_OBJECT pDev, ULONG acquire, PI2CControl pI2CCtrl);
extern NTSTATUS secI2CAccess (PDEVICE_OBJECT pDev, PI2CControl pI2CCtrl);

/// redefinition/re-mapping of some KMVT data structures so that we can share same code with Win9x
typedef VOID (*PNVP_DX_IRQCALLBACK)(void);

typedef DDVIDEOPORTDATA              * PNVP_DDVIDEOPORTDATA;
typedef DDSKIPNEXTFIELDINFO          * PNVP_DDSKIPNEXTFIELDINFO;
typedef DDBOBNEXTFIELDINFO           * PNVP_DDBOBNEXTFIELDINFO;
typedef DDSETSTATEININFO             * PNVP_DDSETSTATEININFO;
typedef DDSETSTATEOUTINFO            * PNVP_DDSETSTATEOUTINFO;
typedef DDLOCKININFO                 * PNVP_DDLOCKININFO;
typedef DDLOCKOUTINFO                * PNVP_DDLOCKOUTINFO;
typedef DDFLIPOVERLAYINFO            * PNVP_DDFLIPOVERLAYINFO;
typedef DDFLIPVIDEOPORTINFO          * PNVP_DDFLIPVIDEOPORTINFO;
typedef DDGETPOLARITYININFO          * PNVP_DDGETPOLARITYININFO;
typedef DDGETPOLARITYOUTINFO         * PNVP_DDGETPOLARITYOUTINFO;
typedef DDGETCURRENTAUTOFLIPININFO   * PNVP_DDGETCURRENTAUTOFLIPININFO;
typedef DDGETCURRENTAUTOFLIPOUTINFO  * PNVP_DDGETCURRENTAUTOFLIPOUTINFO;
typedef DDGETPREVIOUSAUTOFLIPININFO  * PNVP_DDGETPREVIOUSAUTOFLIPININFO;
typedef DDGETPREVIOUSAUTOFLIPOUTINFO * PNVP_DDGETPREVIOUSAUTOFLIPOUTINFO;
typedef DDTRANSFERININFO             * PNVP_DDTRANSFERININFO;
typedef DDTRANSFEROUTINFO            * PNVP_DDTRANSFEROUTINFO;
typedef DDGETTRANSFERSTATUSOUTINFO   * PNVP_DDGETTRANSFEROUTINFO;

/////////////////
// prototypes
//
DWORD GetIrqInfo(
    PVOID HwDeviceExtension,
    PVOID lpInput,
    PDDGETIRQINFO GetIrqInfo);

VP_STATUS NVQueryInterface(
    PVOID HwDeviceExtension,
    PQUERY_INTERFACE QueryInterface);

/// external, defined in nvpecore.c
DWORD FlipVideoPort(
    PVOID HwDeviceExtension,
    PNVP_DDFLIPVIDEOPORTINFO pFlipVideoPort,
    PVOID lpOutput);
DWORD FlipOverlay(
    PVOID HwDeviceExtension,
    PNVP_DDFLIPOVERLAYINFO pFlipOverlayInfo,
    PVOID lpOutput);
DWORD BobNextField(
    PVOID HwDeviceExtension,
    PNVP_DDBOBNEXTFIELDINFO pBobNextFieldInfo,
    PVOID lpOutput);
DWORD SetState(
    PVOID HwDeviceExtension,
    PNVP_DDSETSTATEININFO pSetStateInInfo,
    PNVP_DDSETSTATEOUTINFO pSetStateOutInfo);
DWORD SkipNextField(
    PVOID HwDeviceExtension,
    PNVP_DDSKIPNEXTFIELDINFO pSkipNextFieldInfo,
    PVOID lpOutput);
DWORD GetPolarity(
    PVOID HwDeviceExtension,
    PDDGETPOLARITYININFO pGetPolarityInInfo,
    PDDGETPOLARITYOUTINFO pGetPolarityOutInfo);
DWORD GetCurrentAutoflip(
    PVOID HwDeviceExtension,
    PNVP_DDGETCURRENTAUTOFLIPININFO pGetCurrentAutoflipInInfo,
    PNVP_DDGETCURRENTAUTOFLIPOUTINFO pGetAutoFlipInfoOut);
DWORD GetPreviousAutoflip(
    PVOID HwDeviceExtension,
    PNVP_DDGETPREVIOUSAUTOFLIPININFO pGetAutoflipInInfo,
    PNVP_DDGETPREVIOUSAUTOFLIPOUTINFO pGetAutoFlipInfoOut);
DWORD NVPTransfer(
	PVOID pContext, 
	PNVP_DDTRANSFERININFO pInInfo, 
	PNVP_DDTRANSFEROUTINFO pOutInfo);
DWORD NVPGetTransferStatus(
	PVOID pContext, 
	PVOID pNotUsed, 
	PNVP_DDGETTRANSFEROUTINFO pOutInfo);

DWORD LockSurface(
    PVOID HwDeviceExtension,
    PNVP_DDLOCKININFO pLockInfoIn, 
    PNVP_DDLOCKOUTINFO pLockInfoOut);

#endif // _NVPEKMVT_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\nvpekmvt.c ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

//***************************************************************************
//  Module Name:
//
//      nvpekmvt.c
//
//  Abstract:
//
//      This module contains the callback to Kernel mode video transport services
//      Win2k
//
//  Environment:
//
//      Kernel mode
//
//***************************************************************************

#ifdef NVPE

#define INITGUID     // Instantiate GUID_DxApi
#include "dderror.h"
#include "miniport.h"
#include "ntddvdeo.h"
#include "video.h"
#include "nv.h"
#include "nvpekmvt.h"


//
// Mark those routines that we can as pageable.  Remember that most
// "kernel-mode VPE" routines can be called at raised IRQL, which means
// that they must be kept non-paged.
//
// Note that these are the only two VPE miniport routines which may be
// pageable:
//

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,NVQueryInterface)
#pragma alloc_text(PAGE,GetIrqInfo)
#endif

// !!! Not hooking Lock is success, but not hooking SetPattern is failure?
// !!! Should dwFlags be ANDed or EQUALed?  (SkipNextField)
// !!! Should we mark the interrupt as unsharable?


/*++

Routine Description:

    On NT, the miniport always has to "manage the IRQ" (to borrow from the
    Win95 terminology).  Consequently, this routine simply tells DirectDraw
    what interrupts we support.

    It's actually pretty easy to enable interrupts, in part because you
    don't have to tell the system what interrupt vector you're using, as
    PNP already knows that.  However, you *do* have to check whether PNP
    successfully assigned you an interrupt vector, before you tell DirectDraw
    that you support interrupts.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    GetIrqInfo - Function parameters.

Return Value:

    DX_OK if successful.

--*/

DWORD kmvtGetIrqInfo(
    PVOID HwDeviceExtension,
    PVOID lpInput,
    PDDGETIRQINFO GetIrqInfo)
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    DWORD status = DXERR_UNSUPPORTED;

    //
    // Sometimes, the motherboard BIOS or PNP may conspire to refuse to
    // allocate an interrupt to us.  So before we tell DirectDraw that
    // we support interrupts, we must first check if we've actually been
    // assigned one!
    //

//     if ((hwDeviceExtension->BusInterruptLevel != 0) ||
//        (hwDeviceExtension->BusInterruptVector != 0)) 
	{

        GetIrqInfo->dwFlags = IRQINFO_HANDLED;

        status = DX_OK;
	}

    return status;
}

/*++

Routine Description:

    This routine is the interrupt service routine for the kernel video
    driver.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's adapter information.

Return Value:

    TRUE if the interrupt is serviced; FALSE if it wasn't ours (this is done
    to support chained interrupts).

--*/

BOOLEAN kmvtInterrupt(PVOID HwDeviceExtension)
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    // add your IRQ handling code here
	return FALSE;
}

/*++

Routine Description:

    This function notifies the miniport when it should enable or disable
    interrupts for VPE.  If an IRQ is not specified in this call, it
    should be disabled.

    On NT, since miniports always "manage the IRQ", we must call DirectDraw's
    IRQCallback routine from our HwInterrupt routine to notify DirectDraw
    whenever an interrupt occurs.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    EnableIrqInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/

DWORD kmvtEnableIrq(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PDDENABLEIRQINFO EnableIrqInfo,
    PVOID lpOutput)
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    //
    // First make sure we stash IRQCallback in our device extension before
    // enabling interrupts for the first time, otherwise we may call a NULL
    // pointer from our HwInterrupt routine!
    //
    // (Note that DirectDraw will give us a valid IRQCallback and lpIRQData
    // even when disabling interrupts, which means we won't crash if an
    // interrupt is taken between this point and the actual disabling of the
    // interrupt.)
    //

    hwDeviceExtension->IRQCallback = EnableIrqInfo->IRQCallback;
    hwDeviceExtension->pIRQData = EnableIrqInfo->lpIRQData;
	hwDeviceExtension->dwIRQSources = EnableIrqInfo->dwIRQSources;

    //
    // Clear any existing interrupts, turn off all interrupts by default,
    // and enable the new requested interrupts.
    //
    // NOTE: Be very careful if your driver uses interrupts for purposes
    //       other than VPE.  For example, if your display driver uses DMA,
    //       you probably won't want to clear the DMA interrupt flag here!
    //

    // Now enable the master interrupt switch.  Again, be careful if your
    // display driver uses interrupt for purposes other than VPE -- you
    // probably won't want to disable all video interrupts here like we
    // do!
    //
    // Note: DxEnableIrq is the only routine that may access the CRTC
    //       registers!  For more details, read the large note at the
    //       top of this file.
    //

    // If the vsync interrupt has been disabled, but a deferred overlay
    // offset is pending, flush it now.
    //

    return DX_OK;
}

/*++

Routine Description:

    This function flips the video port to the target surface.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    FlipVideoPortInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/

DWORD kmvtFlipVideoPort(
    PVOID HwDeviceExtension,
    PNVP_DDFLIPVIDEOPORTINFO pFlipVideoPort,
    PVOID lpOutput)
{
    return FlipVideoPort(HwDeviceExtension, pFlipVideoPort, lpOutput);
}

/*++

Routine Description:

    This function flips the overlay to the target surface.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    FlipOverlayInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/
DWORD kmvtFlipOverlay(
    PVOID HwDeviceExtension,
    PNVP_DDFLIPOVERLAYINFO pFlipOverlayInfo,
    PVOID lpOutput)
{
    return FlipOverlay(HwDeviceExtension, pFlipOverlayInfo, lpOutput);
}


/*++

Routine Description:

    This function is called when "bob" is used and a VPORT VSYNC occurs
    that does not cause a flip to occur (e.g., bobbing while interleaved).
    When bobbing, the overlay must adjust itself on every VSYNC, so this
    function notifies it of the VSYNCs that it doesn't already know about
    (e.g., VSYNCs that trigger a flip to occur).

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    BobNextFieldInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/

DWORD kmvtBobNextField(
    PVOID HwDeviceExtension,
    PNVP_DDBOBNEXTFIELDINFO pBobNextFieldInfo,
    PVOID lpOutput)
{
    return BobNextField(HwDeviceExtension, pBobNextFieldInfo, lpOutput);
}

/*++

Routine Description:

    This function is called when the client wants to switch from bob to
    weave.  The overlay flags indicate which state to use.  This is only
    called for interleaved surfaces.

    Note that when this is called, the specified surface may not be
    displaying the overlay (due to a flip).  Instead of failing the call,
    change the bob/weave state for the overlay that would be used if the
    overlay was flipped again to the specified surface.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    SetStateInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/
DWORD kmvtSetState(
    PVOID HwDeviceExtension,
    PNVP_DDSETSTATEININFO pSetStateInInfo,
    PNVP_DDSETSTATEOUTINFO pSetStateOutInfo)
{
    return SetState(HwDeviceExtension, pSetStateInInfo, pSetStateOutInfo);
}


/*++

Routine Description:

    This function is called when the client wants to skip the next field,
    usually to undo a 3:2 pulldown but also for decreasing the frame
    rate.  The driver should not lose the VBI lines if dwVBIHeight contains
    a valid value.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    SkipNextFieldInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/
DWORD kmvtSkipNextField(
    PVOID HwDeviceExtension,
    PNVP_DDSKIPNEXTFIELDINFO pSkipNextFieldInfo,
    PVOID lpOutput)
{
    return SkipNextField(HwDeviceExtension, pSkipNextFieldInfo, lpOutput);
}


/*++

Routine Description:

    This function returns the polarity of the current field being written
    to the specified video port.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    GetPolarityInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/

DWORD kmvtGetPolarity(
    PVOID HwDeviceExtension,
    PDDGETPOLARITYININFO pGetPolarityInInfo,
    PDDGETPOLARITYOUTINFO pGetPolarityOutInfo)
{
    return GetPolarity(HwDeviceExtension, pGetPolarityInInfo, pGetPolarityOutInfo);
}

/*++

Routine Description:

    This function returns the current surface receiving data from the
    video port while autoflipping is taking place.  Only called when
    hardware autoflipping.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    GetCurrentAutoflipInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/
DWORD kmvtGetCurrentAutoflip(
    PVOID HwDeviceExtension,
    PNVP_DDGETCURRENTAUTOFLIPININFO pGetCurrentAutoflipInInfo,
    PNVP_DDGETCURRENTAUTOFLIPOUTINFO pGetAutoFlipInfoOut)
{

    return GetCurrentAutoflip(HwDeviceExtension, pGetCurrentAutoflipInInfo, pGetAutoFlipInfoOut);
}


/*++

Routine Description:

    This function returns the current surface receiving data from the
    video port while autoflipping is taking place.  Only called when
    hardware autoflipping.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    GetPreviousAutoflipInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/
DWORD kmvtGetPreviousAutoflip(
    PVOID HwDeviceExtension,
    PNVP_DDGETPREVIOUSAUTOFLIPININFO pGetAutoflipInInfo,
    PNVP_DDGETPREVIOUSAUTOFLIPOUTINFO pGetAutoFlipInfoOut)
{
    return GetPreviousAutoflip(HwDeviceExtension, pGetAutoflipInInfo, pGetAutoFlipInfoOut);
}


DWORD kmvtTransfer(
	PVOID pContext, 
	PNVP_DDTRANSFERININFO pInInfo, 
	PNVP_DDTRANSFEROUTINFO pOutInfo)
{
	return NVPTransfer(pContext, pInInfo, pOutInfo);
}

DWORD kmvtGetTransferStatus(
	PVOID pContext, 
	PVOID pNotUsed, 
	PNVP_DDGETTRANSFEROUTINFO pOutInfo)
{
	return NVPGetTransferStatus(pContext, NULL, pOutInfo);
}

DWORD kmvtLockSurface(
    PVOID HwDeviceExtension,
    PNVP_DDLOCKININFO pLockInfoIn, 
    PNVP_DDLOCKOUTINFO pLockInfoOut)
{
    return LockSurface(HwDeviceExtension, pLockInfoIn, pLockInfoOut);
}

DWORD kmvtNVPCallbackDxApi(PVOID *pContext, DWORD dwIRQSource)
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION) pContext;
    PDX_IRQDATA pIRQData;
	
	// can we pass on the interrupt !
	if (pHwDevExt->IRQCallback)
	{
		pIRQData = (PDX_IRQDATA)(pHwDevExt->pIRQData);
		pIRQData->dwIrqFlags |= dwIRQSource;
		((PDX_IRQCALLBACK)(pHwDevExt->IRQCallback))(pIRQData);
	}

    return 0;
}

VOID
NVInterfaceReference(
    IN PVOID pContext)
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = (PHW_DEVICE_EXTENSION) pContext;

    //
    // Increment the I2C interface reference count
    //
    hwDeviceExtension->I2C_Reference_Count++;

    return;
}

VOID
NVInterfaceDereference(
    IN PVOID pContext)
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = (PHW_DEVICE_EXTENSION) pContext;

    //
    // Decrement the I2C interface reference count
    //
    hwDeviceExtension->I2C_Reference_Count--;

    return;
}

/*++

Routine Description:

    Generic method for obtaining interfaces from the miniport.

    Among other things, it's used for exporting the DXAPI "kernel-mode
    VPE" interface.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    QueryInterface - Pointer to structure that describes the requested
        interface.

Return Value:

    DX_OK if successful.

--*/
VP_STATUS NVQueryInterface(
    PVOID HwDeviceExtension,
    PQUERY_INTERFACE QueryInterface)
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    VP_STATUS status = NO_ERROR;
    ULONG HwID;

    if (IsEqualGUID(QueryInterface->InterfaceType, &GUID_DxApi)) 
    {
        PDXAPI_INTERFACE DxApiInterface;
        DxApiInterface = (PDXAPI_INTERFACE) QueryInterface->Interface;

        //
        // We are queried here for our "kernel-mode VPE" support only after
        // the display driver has already enabled VPE.  Consequently, we let
        // the display driver control what chips VPE is enabled on -- we
        // don't have to do that here.
        //

        DxApiInterface->Size    = sizeof(DXAPI_INTERFACE);
        DxApiInterface->Version = DXAPI_HALVERSION;
        DxApiInterface->Context = hwDeviceExtension;

        DxApiInterface->DxGetIrqInfo          = kmvtGetIrqInfo;
        DxApiInterface->DxEnableIrq           = kmvtEnableIrq;
        DxApiInterface->DxSkipNextField       = kmvtSkipNextField;
        DxApiInterface->DxBobNextField        = kmvtBobNextField;
        DxApiInterface->DxSetState            = kmvtSetState;
        DxApiInterface->DxFlipOverlay         = kmvtFlipOverlay;
        DxApiInterface->DxFlipVideoPort       = kmvtFlipVideoPort;
        DxApiInterface->DxGetPolarity         = kmvtGetPolarity;
        DxApiInterface->DxGetCurrentAutoflip  = kmvtGetCurrentAutoflip;
        DxApiInterface->DxGetPreviousAutoflip = kmvtGetPreviousAutoflip;
        DxApiInterface->DxTransfer            = kmvtTransfer;
        DxApiInterface->DxGetTransferStatus   = kmvtGetTransferStatus;
        DxApiInterface->DxLock                = kmvtLockSurface;
    }
    // I2c Interface
    else if (IsEqualGUID(QueryInterface->InterfaceType, &GUID_I2C_INTERFACE))
    {
        I2CINTERFACE *pI2cInterface;
        pI2cInterface = (I2CINTERFACE *) QueryInterface->Interface;

        if (QueryInterface->Size == sizeof(I2CINTERFACE))
        {    
            //
            // Check to see if we can convert PDO to hardware ID
            //
            if (hwDeviceExtension->pfnVideoPortGetAssociatedDeviceID)
            {
                //
                // Force hardware ID to use dynamic I2C port (0)
                // This allows dual heads to work properly
                //
                HwID = 0;
            }
            else    // Cannot get hardware ID value
            {
                //
                // Switch on the I2C Interface Version
                //
                switch(QueryInterface->Version)
                {
                    case 1:     /* Original I2C interface version */

                        //
                        // Force hardware ID to first external device (NVCAP_I2C_DEVICE_ID)
                        // i.e., assume I2C access is to external device (Secondary)
                        //
                        HwID = NVCAP_I2C_DEVICE_ID;
                        break;

                    case 2:     /* New I2C interface version */

                        //
                        // Check for special PDO value (0 or -1 is primary monitor)
                        //
                        if (((ULONG_PTR) QueryInterface->InterfaceSpecificData == 0) ||
                            ((ULONG_PTR) QueryInterface->InterfaceSpecificData == -1))
                        {
                            //
                            // Force hardware ID to first head DDC monitor
                            //
                            HwID = QUERY_MONITOR_ID;
                        }
                        else    // Regular PDO value
                        {
                            //
                            // Force hardware ID to first external device (NVCAP_I2C_DEVICE_ID)
                            // i.e., assume I2C access is to external device (Secondary)
                            //
                            HwID = NVCAP_I2C_DEVICE_ID;
                        }
                        break;

                    default:    /* Unknown I2C interface version */

                        VideoDebugPrint((1, "QueryInterface: I2C interface size incorrect!\n"));
                        status = ERROR_INVALID_PARAMETER;
                        break;
                }
            }
            //
            // Check for valid I2C interface
            //
            if (status == NO_ERROR)
            {
                //
                // Initialize the interface
                //
                pI2cInterface->_vddInterface.Size = sizeof(I2CINTERFACE);
                pI2cInterface->_vddInterface.Version = QueryInterface->Version;
                pI2cInterface->_vddInterface.Context = HwDeviceExtension;
                pI2cInterface->_vddInterface.InterfaceReference = NVInterfaceReference;
                pI2cInterface->_vddInterface.InterfaceDereference = NVInterfaceDereference;

                //
                // Switch on the I2C port number to use (0 = Dynamic)
                //
                switch(NVGetI2CPort(HwID))
                {
                    case I2C_ACCESS_DYNAMIC_PORT:

                        //
                        // Setup dynamic I2C port routines
                        //
                        pI2cInterface->i2cOpen = (I2COPEN) dynI2COpen;
                        pI2cInterface->i2cAccess = (I2CACCESS) dynI2CAccess;

                        break;

                    case I2C_ACCESS_PRIMARY_PORT:

                        //
                        // Setup primary I2C port routines
                        //
                        pI2cInterface->i2cOpen = (I2COPEN) priI2COpen;
                        pI2cInterface->i2cAccess = (I2CACCESS) priI2CAccess;

                        break;

                    case I2C_ACCESS_SECONDARY_PORT:

                        //
                        // Setup secondary I2C port routines
                        //
                        pI2cInterface->i2cOpen = (I2COPEN) secI2COpen;
                        pI2cInterface->i2cAccess = (I2CACCESS) secI2CAccess;

                        break;
                }
                //
                // Reference the interface before handing it out
                //
                pI2cInterface->_vddInterface.InterfaceReference(pI2cInterface->_vddInterface.Context);
            }
        }
        else    // Invalid I2C Interface Size
        {
            VideoDebugPrint((1, "QueryInterface: I2C interface size incorrect!\n"));
            status = ERROR_INVALID_PARAMETER;
        }
    }
    else
    {
        VideoDebugPrint((1, "QueryInteface: Unsupported Interface\n"));
        status = ERROR_INVALID_PARAMETER;
    }
    return status;
}

#endif // NVPE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\nvrm.h ===
#ifndef _NVRM_H_
#define _NVRM_H_
//
// (C) Copyright NVIDIA Corporation Inc., 1995,1996. All rights reserved.
//
/**************** Resource Manager Defines and Structures ******************\
*                                                                           *
* Module: NVRM.H                                                            *
*       Resource Manager defines and structures used throughout the code.   *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       David Schmenk (dschmenk)    11/22/93 - wrote it.                    *
*       David Schmenk (dschmenk)    07/06/94 - rewrote it.                  *
*                                                                           *
\***************************************************************************/

//---------------------------------------------------------------------------
//
//  Version number of files built using this header file.
//
//  The format of this is 0x00010206, where
//   - 0x0001 is the chip architecture
//   -   0x02 is the software release
//   -   0x06 is the minor revision
//
//---------------------------------------------------------------------------

#define NVRM_VERSION    0x00030200

//---------------------------------------------------------------------------
//  define some inline assembly instructions

#ifdef __WATCOMC__

void my_sti();
#pragma aux my_sti = \
    "pushf" \
    "sti";

void my_cli();
#pragma aux my_cli =  \
    "popf";

#else   // if not Watcom, its the Microsoft compiler

#define my_sti \
    _asm    pushf   \
    _asm    sti
#define my_cli \
    __asm   popf

#endif  // _WATCOMC_

//---------------------------------------------------------------------------
//
//  NVidia data types.
//
//---------------------------------------------------------------------------

#ifdef NTRM
#include <nvtypes.h>
#endif

#ifndef NVTYPES_INCLUDED
typedef unsigned char   U008;
typedef unsigned short  U016;
typedef unsigned long   U032;
typedef double          U064;

typedef unsigned char   V008;
typedef unsigned short  V016;
typedef unsigned long   V032;
typedef double          V064;

typedef signed char     S008;
typedef signed short    S016;
typedef signed long     S032;
typedef double          S064;
#endif
//
// Fixed point math types and macros.
//
typedef signed long     S016d016;
typedef unsigned long   U016d016;
typedef signed long     S008d024;
typedef unsigned long   U008d024;
typedef signed long     S012d020;
typedef unsigned long   U012d020;

#define FIX16_POINT             16
#define FIX16_SCALE             ((U032)1<<FIX16_POINT)
#define FIX16_INT_MASK          ((U032)~0<<FIX16_POINT)
#define FIX16_FRAC_MASK         (~FIX16_INT_MASK)
#define FIX16_INT(f)            ((f)>>FIX16_POINT)
#define FIX16_FRAC(f)           ((f)&FIX16_FRAC_MASK)
#define INT_FIX16(f)            ((f)<<FIX16_POINT)
#define FIX16(i)                (S016d016)((i)*FIX16_SCALE))
#define FIX16_MUL(f1,f2)        ((FIX16_INT(f1)*FIX16_INT(f2)<<FIX16_POINT)     \
                                +(FIX16_INT(f1)*FIX16_FRAC(f2))                 \
                                +(FIX16_FRAC(f1)*FIX16_INT(f2))                 \
                                +(FIX16_FRAC(f1)*FIX16_FRAC(f2)>>FIX16_POINT))
#define FIX16_DIV(f1,f2)        (((f1)<<(FIX16_POINT/2))/((f2)>>(FIX16_POINT/2)))
#define FIX16_DIVI(f1,f2)       ((f1)/((f2)>>(FIX16_POINT)))
#define FIX16_IDIV(f1,f2)       (((f1)<<(FIX16_POINT))/(f2))
#define FIX24_POINT             24
#define FIX24_SCALE             ((U032)1<<FIX24_POINT)
#define FIX24_INT_MASK          ((U032)~0<<FIX24_POINT)
#define FIX24_FRAC_MASK         (~FIX24_INT_MASK)
#define FIX24_TO_INT(f)         ((f)>>FIX24_POINT)
#define FIX24(i)                ((S008d024)((i)*FIX24_SCALE))
#define FIX24_MUL(f1,f2)        (((f1)>>(FIX24_POINT/2))*((f2)>>(FIX24_POINT/2)))
#define FIX24_DIV(f1,f2)        (((f1)<<(FIX24_POINT/2))/((f2)>>(FIX24_POINT/2)))
#define FIX24_DIVI(f1,f2)       ((f1)/((f2)>>(FIX24_POINT)))
#define FIX24_IDIV(f1,f2)       (((f1)<<(FIX24_POINT))/(f2))

//---------------------------------------------------------------------------
//
//  Common types.
//
//---------------------------------------------------------------------------

#ifndef VOID
#define VOID            void
#endif
#ifndef BOOL
#define BOOL            S032
#endif
#ifndef TRUE
#define TRUE            ~0
#endif
#ifndef FALSE
#define FALSE           0
#endif
#ifndef NULL
#define NULL            0L
#endif
    
//---------------------------------------------------------------------------
//
//  Error codes.
//
//---------------------------------------------------------------------------

//
// External codes.
//
#define NV_ERROR_1                      0x0100
#define NV_TYPE_CONFLICT                (0x01|NV_ERROR_1)
#define NV_OUT_OF_RANGE                 (0x02|NV_ERROR_1)
#define NV_NO_CONNECTION                (0x03|NV_ERROR_1)
#define NV_NO_SUCH_OBJECT               (0x04|NV_ERROR_1)
#define NV_NAME_IN_USE                  (0x05|NV_ERROR_1)
#define NV_OUT_OF_RESOURCES             (0x06|NV_ERROR_1)
#define NV_TRANSLATION_VIOLATION        (0x07|NV_ERROR_1)
#define NV_PROTECTION_VIOLATION         (0x08|NV_ERROR_1)
#define NV_BUFFER_BUSY                  (0x09|NV_ERROR_1)
#define NV_ILLEGAL_ACCESS               (0x0A|NV_ERROR_1)
#define NV_BAD_COLORMAP_FORMAT          (0x0B|NV_ERROR_1)
#define NV_BAD_COLOR_FORMAT             (0x0C|NV_ERROR_1)
#define NV_BAD_MONOCHROME_FORMAT        (0x0D|NV_ERROR_1)
#define NV_BAD_PATTERN_SHAPE            (0x0E|NV_ERROR_1)
#define NV_BAD_SUBDIVIDE                (0x0F|NV_ERROR_1)
#define NV_NO_CURRENT_POINT             (0x10|NV_ERROR_1)
#define NV_BAD_AUDIO_FORMAT             (0x11|NV_ERROR_1)
#define NV_NO_DMA_TRANSLATION           (0x12|NV_ERROR_1)
#define NV_INCOMPLETE_METHOD            (0x13|NV_ERROR_1)
#define NV_RESERVED_ADDRESS             (0x14|NV_ERROR_1)
#define NV_UNIMPLEMENTED_PATCH          (0x15|NV_ERROR_1)
#define NV_OS_NAME_ERROR                (0x16|NV_ERROR_1)
#define NV_INCOMPLETE_PATCH             (0x17|NV_ERROR_1)
#define NV_BUFFERGAP_ERROR              (0x18|NV_ERROR_1)
#define NV_FIFO_OVERFLOW                (0x19|NV_ERROR_1)
//
// Internal codes.
//
typedef U032 RM_STATUS;
#define NUM_RM_ERRORS                   22
#define RM_OK                           0x00000000
#define RM_ERROR                        0xFFFFFFFF
#define RM_WARN_NULL_OBJECT             (0x10000000|RM_OK)
#define RM_WARN_AUDIO_DISABLED          (0x20000000|RM_OK)
#define RM_WARN_GRAPHICS_DISABLED       (0x30000000|RM_OK)
#define RM_ERR_NO_FREE_MEM              (0x01000000|NV_OUT_OF_RESOURCES)
#define RM_ERR_MEM_NOT_FREED            (0x01010000|NV_OUT_OF_RESOURCES)
#define RM_ERR_PAGE_TABLE_NOT_AVAIL     (0x01020000|NV_OUT_OF_RESOURCES)
#define RM_ERR_NO_FREE_FIFOS            (0x02000000|NV_OUT_OF_RESOURCES)
#define RM_ERR_CANT_CREATE_CLASS_OBJS   (0x02010000|NV_OUT_OF_RESOURCES)
#define RM_ERR_BAD_OBJECT               (0x03000000|NV_NO_SUCH_OBJECT)
#define RM_ERR_INSERT_DUPLICATE_NAME    (0x03010000|NV_NAME_IN_USE)
#define RM_ERR_OBJECT_NOT_FOUND         (0x03020000|NV_NO_SUCH_OBJECT)
#define RM_ERR_CREATE_BAD_CLASS         (0x04000000|NV_NO_SUCH_OBJECT)
#define RM_ERR_DELETE_BAD_CLASS         (0x04010000|NV_NO_SUCH_OBJECT)
#define RM_ERR_FIFO_RUNOUT_OVERFLOW     (0x05000000|NV_FIFO_OVERFLOW)
#define RM_ERR_FIFO_BAD_ACCESS          (0x05010000|NV_RESERVED_ADDRESS)
#define RM_ERR_FIFO_OVERFLOW            (0x05020000|NV_FIFO_OVERFLOW)
#define RM_ERR_METHOD_ORDER             (0x06000000|NV_INCOMPLETE_METHOD)
#define RM_ERR_METHOD_COUNT             (0x06010000|NV_INCOMPLETE_METHOD)
#define RM_ERR_ILLEGAL_OBJECT           (0x06020000|NV_TYPE_CONFLICT)
#define RM_ERR_DMA_IN_USE               (0x07000000|NV_BUFFER_BUSY)
#define RM_ERR_BAD_DMA_SPECIFIER        (0x07010000|NV_TRANSLATION_VIOLATION)
#define RM_ERR_INVALID_XLATE            (0x07020000|NV_TRANSLATION_VIOLATION)
#define RM_ERR_INVALID_START_LENGTH     (0x07030000|NV_PROTECTION_VIOLATION)
#define RM_ERR_DMA_MEM_NOT_LOCKED       (0x07040000|NV_OUT_OF_RESOURCES)
#define RM_ERR_DMA_MEM_NOT_UNLOCKED     (0x07050000|NV_OUT_OF_RESOURCES)
#define RM_ERR_NOTIFY_IN_USE            (0x07060000|NV_BUFFER_BUSY)
#define RM_ERR_ILLEGAL_ADDRESS          (0x08000000|NV_ILLEGAL_ACCESS)
#define RM_ERR_BAD_ADDRESS              (0x08010000|NV_PROTECTION_VIOLATION)
#define RM_ERR_INVALID_COLOR_FORMAT     (0x09000000|NV_BAD_COLOR_FORMAT)
#define RM_ERR_INVALID_MONO_FORMAT      (0x09010000|NV_BAD_MONOCHROME_FORMAT)
#define RM_ERR_INVALID_AUDIO_FORMAT     (0x09020000|NV_BAD_AUDIO_FORMAT)
#define RM_ERR_INVALID_GAMEPORT_FORMAT  (0x09030000|NV_BAD_AUDIO_FORMAT)
#define RM_ERR_OBJECT_TYPE_MISMATCH     (0x0A000000|NV_TYPE_CONFLICT)
#define RM_ERR_NO_FREE_AUDIO_INSTANCES  (0x0B000000|NV_OUT_OF_RESOURCES)
#define RM_ERR_CODEC_INPUT_IN_USE       (0x0B010000|NV_OUT_OF_RESOURCES)
#define RM_ERR_AUDIO_DISABLED           (0x0B020000|NV_OUT_OF_RESOURCES)
#define RM_ERR_INCOMPLETE_PATCH         (0x0C000000|NV_INCOMPLETE_PATCH)
#define RM_ERR_INVALID_PATCH            (0x0C010000|NV_UNIMPLEMENTED_PATCH)
#define RM_ERR_PATCH_TOO_COMPLEX        (0x0C020000|NV_UNIMPLEMENTED_PATCH)
#define RM_ERR_MAX_PATCH_FANOUT         (0x0C030000|NV_UNIMPLEMENTED_PATCH)
#define RM_ERR_DEVICE_DISCONNECTED      (0x0C040000|NV_NO_CONNECTION)
#define RM_ERR_BUFFER_GAP               (0x0D000000|NV_BUFFER_GAP)
#define RM_ERR_INVALID_OS_NAME          (0x0E000000|NV_OS_NAME_ERROR)
#define RM_ERR_ILLEGAL_ACTION           (0x0E010000|NV_OS_NAME_ERROR)
// The DMA direction specified for the DMA object is not allowed in the
// specified address space.
#define RM_ERR_ILLEGAL_DIRECTION        (0x0E020000|NV_OS_NAME_ERROR)
#define RM_ERR_OUT_OF_TIMER_CALLBACKS   (0x0F000000|NV_OUT_OF_RESOURCES)
//
// NV Reference Manual register access definitions.
//
#define BIT(b)                  (1<<(b))
#define DEVICE_BASE(d)          (0?d)
#define DEVICE_EXTENT(d)        (1?d)
#define DRF_SHIFT(drf)          ((0?drf) % 32)
#define DRF_MASK(drf)           (0xFFFFFFFF>>(31-((1?drf) % 32)+((0?drf) % 32)))
#define DRF_DEF(d,r,f,c)        ((NV ## d ## r ## f ## c)<<DRF_SHIFT(NV ## d ## r ## f))
#define DRF_NUM(d,r,f,n)        (((n)&DRF_MASK(NV ## d ## r ## f))<<DRF_SHIFT(NV ## d ## r ## f))
#define DRF_VAL(d,r,f,v)        (((v)>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))
#define REG_WR_DRF_NUM(d,r,f,n) REG_WR32(NV ## d ## r, DRF_NUM(d,r,f,n))
#define REG_WR_DRF_DEF(d,r,f,c) REG_WR32(NV ## d ## r, DRF_DEF(d,r,f,c))
#define FLD_WR_DRF_NUM(d,r,f,n) REG_WR32(NV##d##r,(REG_RD32(NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define FLD_WR_DRF_DEF(d,r,f,c) REG_WR32(NV##d##r,(REG_RD32(NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define REG_RD_DRF(d,r,f)       (((REG_RD32(NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))
//
// NV Reference Manual instance memory structure access definitions.
//
#define INST_WR32(i,o,d)        MEM_WR32(DEVICE_BASE(NV_PRAMIN)+((i)<<4)+(o),(d))
#define INST_RD32(i,o)          MEM_RD32(DEVICE_BASE(NV_PRAMIN)+((i)<<4)+(o))
#define SF_OFFSET(sf)           (((0?sf)/32)<<2)
#define SF_SHIFT(sf)            ((0?sf)&31)
#undef  SF_MASK
#define SF_MASK(sf)             (0xFFFFFFFF>>(31-(1?sf)+(0?sf)))
#define SF_DEF(s,f,c)           ((NV ## s ## f ## c)<<SF_SHIFT(NV ## s ## f))
#define SF_NUM(s,f,n)           (((n)&SF_MASK(NV ## s ## f))<<SF_SHIFT(NV ## s ## f))
#define SF_VAL(s,f,v)           (((v)>>SF_SHIFT(NV ## s ## f))&SF_MASK(NV ## s ## f))
#define RAM_WR_ISF_NUM(i,s,f,n) INST_WR32(i,SF_OFFSET(NV ## s ## f),SF_NUM(s,f,n))
#define RAM_WR_ISF_DEF(i,s,f,c) INST_WR32(i,SF_OFFSET(NV ## s ## f),SF_DEF(s,f,c))
#define FLD_WR_ISF_NUM(i,s,f,n) INST_WR32(i,SF_OFFSET(NV##s##f),(INST_RD32(i,SF_OFFSET(NV##s##f))&~(SF_MASK(NV##s##f)<<SF_SHIFT(NV##s##f)))|SF_NUM(s,f,n))
#define FLD_WR_ISF_DEF(i,s,f,c) INST_WR32(i,SF_OFFSET(NV##s##f),(INST_RD32(i,SF_OFFSET(NV##s##f))&~(SF_MASK(NV##s##f)<<SF_SHIFT(NV##s##f)))|SF_DEF(s,f,c))
#define RAM_RD_ISF(i,s,f)       (((INST_RD32(i,SF_OFFSET(NV ## s ## f)))>>SF_SHIFT(NV ## s ## f))&SF_MASK(NV ## s ## f))
//
// EEPROM access macros.
//
#define EEPROM_INDEX_RD08(ii, dd)   \
    {REG_WR32(NV_PEEPROM_CONTROL,DRF_NUM(_PEEPROM,_CONTROL,_ADDRESS,(ii))|DRF_DEF(_PEEPROM,_CONTROL,_COMMAND,_READ));\
    osDelay(1);\
    (dd)=REG_RD32(NV_PEEPROM_CONTROL)&0xFF;}
//
// DevInfo update/finish flags.
//
#define UPDATE_HWINFO_AUDIO_VOLUME             BIT(0)
#define FINISH_HWINFO_AUDIO_VOLUME             BIT(0)
#define UPDATE_HWINFO_AUDIO_NEAR_MARK          BIT(1)
#define FINISH_HWINFO_AUDIO_NEAR_MARK          BIT(1)
#define UPDATE_HWINFO_AUDIO_BLOCK_LENGTH       BIT(2)
#define FINISH_HWINFO_AUDIO_BLOCK_LENGTH       BIT(2)
#define UPDATE_HWINFO_DAC_CURSOR_POS           BIT(0)
#define FINISH_HWINFO_DAC_CURSOR_POS           BIT(0)
#define UPDATE_HWINFO_DAC_CURSOR_IMAGE         BIT(1)
#define FINISH_HWINFO_DAC_CURSOR_IMAGE         BIT(1)
#define UPDATE_HWINFO_DAC_CURSOR_COLOR         BIT(2)
#define FINISH_HWINFO_DAC_CURSOR_COLOR         BIT(2)
#define UPDATE_HWINFO_DAC_COLORMAP             BIT(3)
#define FINISH_HWINFO_DAC_COLORMAP             BIT(3)
#define UPDATE_HWINFO_DAC_CURSOR_ENABLE        BIT(4)
#define FINISH_HWINFO_DAC_CURSOR_ENABLE        BIT(4)
#define UPDATE_HWINFO_DAC_CURSOR_DISABLE       BIT(5)
#define FINISH_HWINFO_DAC_CURSOR_DISABLE       BIT(5)
#define UPDATE_HWINFO_DAC_CURSOR_TYPE          BIT(6)
#define FINISH_HWINFO_DAC_CURSOR_TYPE          BIT(6)
#define UPDATE_HWINFO_DAC_CURSOR_IMAGE_DELAYED BIT(7)
#define FINISH_HWINFO_DAC_CURSOR_IMAGE_DELAYED BIT(7)
#define UPDATE_HWINFO_DAC_DPML                 BIT(8)
#define FINISH_HWINFO_DAC_DPML                 BIT(8)
#define UPDATE_HWINFO_DAC_APLL                 BIT(9)
#define FINISH_HWINFO_DAC_APLL                 BIT(9)
#define UPDATE_HWINFO_DAC_VPLL                 BIT(10)
#define FINISH_HWINFO_DAC_VPLL                 BIT(10)
#define UPDATE_HWINFO_DAC_MPLL                 BIT(11)
#define FINISH_HWINFO_DAC_MPLL                 BIT(11)
#define UPDATE_HWINFO_CODEC_FREQUENCY          BIT(0)
#define FINISH_HWINFO_CODEC_FREQUENCY          BIT(0)
#define UPDATE_HWINFO_CODEC_SOURCE             BIT(1)
#define FINISH_HWINFO_CODEC_SOURCE             BIT(1)
#define UPDATE_HWINFO_CODEC_GAIN               BIT(2)
#define FINISH_HWINFO_CODEC_GAIN               BIT(2)
#define UPDATE_HWINFO_CODEC_PIN_CONTROL        BIT(3)
#define FINISH_HWINFO_CODEC_PIN_CONTROL        BIT(3)
#define UPDATE_HWINFO_BUFFER_FLIP              BIT(0)
#define FINISH_HWINFO_BUFFER_FLIP              BIT(0)
#define UPDATE_HWINFO_BUFFER_PARAMS            BIT(8)
#define FINISH_HWINFO_BUFFER_PARAMS            BIT(8)
#define UPDATE_HWINFO_DISPLAY_PARAMS           BIT(9)
#define FINISH_HWINFO_DISPLAY_PARAMS           BIT(9)
#define UPDATE_HWINFO_REFRESH_PARAMS           BIT(10)
#define FINISH_HWINFO_REFRESH_PARAMS           BIT(10)
#define UPDATE_HWINFO_GAMEPORT                 BIT(0)
#define FINISH_HWINFO_GAMEPORT                 BIT(0)
#define UPDATE_HWINFO_GAMEPORT_START_COUNT     BIT(1)
#define FINISH_HWINFO_GAMEPORT_START_COUNT     BIT(1)
#define UPDATE_HWINFO_GAMEPORT_GET_POSITION    BIT(2)
#define FINISH_HWINFO_GAMEPORT_GET_POSITION    BIT(2)
#define UPDATE_HWINFO_FIFO_LIE                 BIT(0)
#define FINISH_HWINFO_FIFO_LIE                 BIT(0)
#define FINISH_HWINFO_VGA_FIXUP                BIT(0)
#define UPDATE_HWINFO_DGP_3D_ENABLE            BIT(0)
#define FINISH_HWINFO_DGP_3D_ENABLE            BIT(0)
#define UPDATE_HWINFO_VIDEO_ENABLE             BIT(0)
#define FINISH_HWINFO_VIDEO_ENABLE             BIT(0)
#define UPDATE_HWINFO_VIDEO_START              BIT(1)
#define FINISH_HWINFO_VIDEO_START              BIT(1)
#define UPDATE_HWINFO_VIDEO_SIZE               BIT(2)
#define FINISH_HWINFO_VIDEO_SIZE               BIT(2)
#define UPDATE_HWINFO_VIDEO_SCALE              BIT(3)
#define FINISH_HWINFO_VIDEO_SCALE              BIT(3)
#define UPDATE_HWINFO_VIDEO_COLORKEY           BIT(4)
#define FINISH_HWINFO_VIDEO_COLORKEY           BIT(4)
//
// Notification otherInfo defines.
//
#define NOTIFY_INFO16_BUFFER_CHAIN_GAP  1
#define NOTIFY_INFO16_BUFFER_YANK       2
#define NOTIFY_INFO16_BUFFER_LOOP       3

//---------------------------------------------------------------------------
//
// 32 bit debug marker values.
//
//---------------------------------------------------------------------------

// Solaris machines are byte reversed from Intel machines
#ifdef SOLARIS
#define NV_MARKER1 (U032)(('N' << 24) | ('V' << 16) | ('R' << 8) | 'M')
#define NV_MARKER2 (U032)(('M' << 24) | ('R' << 16) | ('V' << 8) | 'N')
#else
#define NV_MARKER1 (U032)(('M' << 24) | ('R' << 16) | ('V' << 8) | 'N')
#define NV_MARKER2 (U032)(('N' << 24) | ('V' << 16) | ('R' << 8) | 'M')
#endif

//---------------------------------------------------------------------------
//
// DevInfo state values.
//
//---------------------------------------------------------------------------

//
// BUS type.
//
#define BUS_PCI                         1
#define BUS_VL                          2
#define BUS_NIRV                        3
#define BUS_AGP                         4
//
// Predefined GART offset in physical memory
//
#define AGP_APERTURE_SIZE               0x2000000       // 32 MB
#define AGP_APERTURE_PHYS_BASE          0xC0000000      // 3 gig
//
// Define the various NV chip ID's
//
#define NV3_REV_A_00                    0x00
#define NV3_REV_B_00                    0x10
#define NV3_REV_C_00                    0x20
//
// SEGA Game Port "DAC Hack" Gate Array ID's.
//
#define DGP_SGP                         1
#define DGP_ASGP                        2
//
// Define CODEC BIOS ID's
//
#define CODEC_AD1848                    0x00000000
#define CODEC_AD1845                    0x00000001
#define CODEC_AD1846                    0x00000002
#define CODEC_CS4248                    0x00000003
#define CODEC_CS4231A                   0x00000004
#define CODEC_ESS1688                   0x00000005
#define CODEC_ESS1788                   0x00000006
#define CODEC_ESS1888                   0x00000007
#define CODEC_ESS1868                   0x00000008
#define CODEC_ADREDCORAL                0x00000009
#define CODEC_OPTI                      0x0000000A
#define CODEC_YAC516                    0x0000000B
#define CODEC_CHRONTEL                  0x0000000C
#define CODEC_YAC701                    0x0000000D
#define CODEC_ID_MASK                   0x00003FFF
#define CODEC_NONE                      0xFFFFFFFF
//
// Define CODEC BIOS Frequency ID's.
//
#define CODEC_FREQ_11KHz                0x00000000
#define CODEC_FREQ_22KHz                0x00004000
#define CODEC_FREQ_44KHz                0x00008000
#define CODEC_FREQ_MASK                 0x0000C000
//
// Define the ever changing CODEC Interface Protocol values.
//
#define CODEC_IP_AD                     0x30
#define CODEC_IP_YAMAHA                 0x40
#define CODEC_IP_ESS                    0xC8
//
// CODEC values.
//
#define CODEC_22KHz                     0x56220000
#define CODEC_44KHz                     0xAC440000 
#define CODEC_48KHz                     0xBB800000
#define NUM_CODEC_INPUTS                4
#define CODEC_INPUT_LINE                0  
#define CODEC_INPUT_MIC                 1  
#define CODEC_INPUT_AUX                 2
#define CODEC_INPUT_AUX1                2
#define CODEC_INPUT_MIX                 3
#define CODEC_INPUT_AUX2                3
#define CODEC_PASSTHRU                  4
#define CODEC_INPUT_GAIN_0DB            0
#define CODEC_INPUT_GAIN_20DB           20
#define CODEC_OUTPUT_ATTEN_0DB          0
#define CODEC_OUTPUT_ATTEN_20DB         20
//
// Framebuffer values.
//
#define BUFFER_DRAM                     0
#define BUFFER_SGRAM                    1
#define BUFFER_DRAM_EDO                 0
#define BUFFER_DRAM_FPM                 1
#define BUFFER_HSYNC_NEGATIVE           0
#define BUFFER_HSYNC_POSITIVE           1
#define BUFFER_VSYNC_NEGATIVE           0
#define BUFFER_VSYNC_POSITIVE           1
#define BUFFER_CSYNC_DISABLED           0
#define BUFFER_CSYNC_ENABLED            1
//
// Dedicated privileged device ram size in bytes.
//
#define NV_PRAM_DEVICE_SIZE_12_KBYTES   0x3000  // 12KB
#define NV_PRAM_DEVICE_SIZE_20_KBYTES  0x5000   // 20KB
#define NV_PRAM_DEVICE_SIZE_36_KBYTES  0x9000   // 36KB             
#define NV_PRAM_DEVICE_SIZE_68_KBYTES  0x11000  // 68KB
//
// NV3's priviliged size, minus audio
//
#define NV_PRAM_DEVICE_SIZE_5_5_KBYTES   0x1600 // 5.5KB
#define NV_PRAM_DEVICE_SIZE_9_5_KBYTES   0x2600 // 9.5KB
#define NV_PRAM_DEVICE_SIZE_17_5_KBYTES  0x4600 // 17.5KB             
#define NV_PRAM_DEVICE_SIZE_33_5_KBYTES  0x8600 // 33.5KB
//
// Offscreen Instance Memory size.
//
#define NV_PRAM_MIN_SIZE_INSTANCE_MEM  0x1000   // 4KB
//
// New states for the SaveToEEPROMEnable flag in nvinfo.framebuffer
//
#define NV_CFG_DISABLE_NON_VOLATILE_STORAGE     0
#define NV_CFG_ENABLE_NON_VOLATILE_STORAGE      0x042
//
// DAC values.
//
#define DAC_CURSOR_DISABLED             0
#define DAC_CURSOR_THREE_COLOR          1
#define DAC_CURSOR_TWO_COLOR_XOR        2
#define DAC_CURSOR_TWO_COLOR            3
#define DAC_CURSOR_FULL_COLOR_XOR       4
#define DAC_CURSOR_FULL_COLOR           5

#define DAC_CURSOR_CACHE_ENTRY          0x80000000
#define DAC_CURSOR_CACHE_DISPLAY        0x40000000

#define MAX_CACHED_CURSORS              5

// For attempting to do Frame locking...

//#define FRAME_LOCK

#ifdef FRAME_LOCK
#define MAXROCKS    (256)
#define LOCKPARAM1  (18)
#define LOCKPARAM2  (4)
#define LOCKLOCATION (50)
#endif //FRAME_LOCK


#define NV3WDMHACK


#ifdef NV3WDMHACK

#define NVWDMHACKDELAY  (45)

#endif // NV3WDMHACK

//
// Video modes.
//
// (keep these around until all rm's os sections are updated)
//
#define NUM_VIDEO_DEPTHS                3
#define VIDEO_DEPTH_8BPP                8
#define VIDEO_DEPTH_15BPP               15
#define VIDEO_DEPTH_30BPP               30
#define NUM_RESOLUTIONS                 16
#define RESOLUTION_576X432              0
#define RESOLUTION_640X400              1
#define RESOLUTION_640X480              2
#define RESOLUTION_800X600              3
#define RESOLUTION_1024X768             4
#define RESOLUTION_1152X864             5
#define RESOLUTION_1280X1024            6
#define RESOLUTION_1600X1200            7
#define RESOLUTION_320X200              8
#define RESOLUTION_320X240              9
#define RESOLUTION_512X384              10
#define RESOLUTION_640X240              11
#define RESOLUTION_400X300              12
#define RESOLUTION_480X360              13
#define RESOLUTION_960X720              14
#define RESOLUTION_320X400              15
//
// Monitor types
//
#define NV_MONITOR_VGA                  0
#define NV_MONITOR_NTSC                 2
#define NV_MONITOR_PAL                  3

// Use the following for monitor types. The ones above are obsolete names.
#define MONITOR_TYPE_VGA                0
#define MONITOR_TYPE_NTSC               2
#define MONITOR_TYPE_PAL                3
#define MONITOR_TYPE_FLAT_PANEL         4

// Use the following for display types. The ones above are obsolete names.
#define DISPLAY_TYPE_MONITOR            0
#define DISPLAY_TYPE_TV                 1
#define DISPLAY_TYPE_DUALSURFACE        2
#define DISPLAY_TYPE_FLAT_PANEL         3


//
// Gamport Info Analog Data Array values.
//
#define NV_GPORT_X_AXIS                 0
#define NV_GPORT_Y_AXIS                 1
#define NV_GPORT_Z_AXIS                 2
#define NV_GPORT_PEDALS                 3
#define NV_GPORT_PEDALS_1               3
#define NV_GPORT_PEDALS_2               4
#define NV_GPORT_THROTTLE               5
#define NV_GPORT_THROTTLE_1             5
#define NV_GPORT_THROTTLE_2             6
//
// Gamport source values.
//
#define GPORT_INPUT_NULL                0x0000
#define GPORT_INPUT_POT                 0x0100
#define GPORT_INPUT_JOYSTICK            0x0200
#define GPORT_INPUT_PEDALS              0x0300
#define GPORT_INPUT_THROTTLE            0x0400
#define GPORT_INPUT_PAD                 0x0500
#define GPORT_INPUT_YOKE                0x0600
#define GPORT_INPUT_POTA                0x0700
#define GPORT_INPUT_GUN                 0x0800
#define GPORT_INPUT_INVALID             0xFF00
#define GPORT_INPUT_SOURCE_MASK         0xFF00
//
// Gamport source port values.
//
#define GPORT_INPUT_PORT_PLAYER1        0
#define GPORT_INPUT_PORT_PLAYER2        1
#define GPORT_INPUT_PORT_PLAYER3        2
#define GPORT_INPUT_PORT_PLAYER4        3
#define GPORT_INPUT_PORT_PLAYER5        4
#define GPORT_INPUT_PORT_PLAYER6        5
#define GPORT_INPUT_PORT_PLAYER7        6
#define GPORT_INPUT_PORT_PLAYER8        7
#define GPORT_INPUT_PORT_PLAYER9        8
#define GPORT_INPUT_PORT_PLAYER10       9
#define GPORT_INPUT_PORT_PLAYER11       10
#define GPORT_INPUT_PORT_PLAYER12       11
#define GPORT_INPUT_PORT_POT            12
#define GPORT_INPUT_PORT_MAX            12
#define GPORT_INPUT_PORT_MASK           0x00FF
//
// Gameport source channel values. 
//
#define GPORT_INPUT_BUTTONS             BIT(0)
#define GPORT_INPUT_X_AXIS              BIT(1)
#define GPORT_INPUT_Y_AXIS              BIT(2)
#define GPORT_INPUT_Z_AXIS              BIT(3)
#define GPORT_INPUT_X_POS               BIT(4)
#define GPORT_INPUT_Y_POS               BIT(5)

//---------------------------------------------------------------------------
//
//  Max number of FIFO channels used.
//
//---------------------------------------------------------------------------

#ifdef RM_MUT
#define NUM_FIFOS                       4
#else
#define NUM_FIFOS                       32
#endif

//---------------------------------------------------------------------------
//
//  Data structures.
//
//---------------------------------------------------------------------------

#include "all_incs.h"

// JJV-MM This is messy ... but it beats including nvhw.h
//
// Device register access array.
//
typedef union _def_HwReg
{
    volatile V008 Reg008[1];
    volatile V016 Reg016[1];
    volatile V032 Reg032[1];
} HWREG, * PHWREG;

//
// A hardware fifo hash table entry.
//
typedef struct _def_HashTableEntry
{
    V032 ht_ObjectHandle;
    V032 ht_Context;
} HASH_TABLE_ENTRY;
         
//
// Device state and configuration information.
//
typedef struct _def_hw_info
{
    struct _def_chip_info
    {
        U032 Size;
        char ID[32];
        U032 SavePmc;
        U032 SaveIntrEn0;
        U032 IntrEn0;
        U032 Implementation;
        U032 Revision;
        U032 Architecture;
        U032 Manufacturer;
        U032 Bus;
        U032 NVAGPEnabled;
        U032 CrystalFreq;
        U032 ChipToken[2];
        U032 ServiceCount;
        U032 ServiceTimeLo;
        U032 ServiceTimeHi;
        U032 ExceptionTimeLo;
        U032 ExceptionTimeHi;
        U032 osStartInterrupt;
    } Chip;
    struct _def_mapping_info
    {
        U032 Size;
        char ID[32];
        U032 PhysAddr;
        U032 PhysFbAddr;
        U032 IntLine;
        U032 IntPin;
        U032 AGPPhysStart;
        U032 AGPLinearStart;
        U032 AGPLimit;
        U032 UpdateFlags;
        U032 FinishFlags;
        //PHWREG nvAddr;                   //***
        //PHWREG romAddr;                  //***
        //PHWREG fbAddr;                   //***
        //PHWREG agpAddr;                  //***
        U032 nvPhys;                       //***
        U032 fbPhys;                       //***
        U032 nvIRQ;                        //***
        U032 dllIpcOffset;                 //***
        U032 dllIpcSelector;               //***
        U032 dllNotifyOffset;              //***
        U032 dllNotifySelector;            //***
                                           //***
        U032 ChipID;                       //***
        //U032 *ApertureTranslationTable;  //***
        U032 hpicIRQ;                      //***
        U032 hDev;                         //***
        U032 osDeviceHandle;               // JJV - This may be the same as the one above ???
    } Mapping;
    struct _def_pram_info
    {
        U032 Size;
        char ID[32];
        U032 ConfigReg;
        U032 HashDepth;
        U032 RunOutMask;
        U032 FreeInstSize;
        U032 FreeInstBase;
        U032 FreeInstMax;
        U032 CurrentSize;
        U032 AvailableSize[4];
        U032 PrivBase;
        U032 UpdateFlags;
        U032 FinishFlags;
        U032 HashTableAddr;
        U032 FifoRunoutAddr;
        U032 FifoContextAddr;
        U032 AudioScratchAddr;
        U032 AuthScratchAddr;
        U032 VideoDmaInstance;
    } Pram;        
    struct _def_dma_info
    {
    
        //PDMAOBJECT DmaList;              //***
        U032       dmaPushPutOffset;       //***
        U032       dmaPushGetOffset;       //***
        U032       dmaPushGetOffsetRead;   //***
        U032       dmaPushJumpOffset;      //***
        U032       dmaPushJumpOffsetSet;   //***
        //PDMAOBJECT VidDmaObject;         //***
    } Dma;        
    struct _def_fifo_info
    {
        U032 Size;
        char ID[32];
        U032 ServiceCount;
        U032 AllocateCount;
        U032 CacheDepth;
        U032 LieDepth;
        U032 RetryCount;
        U032 Count;
        U032 UpdateFlags;
        U032 FinishFlags;
        U032 DmaFetchAmount;       // Burst amount the DMA pusher should use
                                   // when reading into the FIFO
        U032 DmaWaterMark;         // Fifo level which will kick of the next
                                   // DMA burst
        U032 CurrentChID;
        //PFIFO   fifoTable;               //***
        U032    fifoAllocateCount;         //***
        //POBJECT *hashTable;              //***
    } Fifo;
    struct _def_master_info
    {
        U032 Size;
        char ID[32];
        U032 UpdateFlags;
        U032 FinishFlags;
    } Master;
    struct _def_framebuffer_info
    {
        U032 Size;
        char ID[32];
        U032 ConfigReg;
        U032 ConfigPageHeight;
        U032 RamSizeMb;
        U032 RamSize;
        U032 RamType;
        U032 RamTech;
        U032 DpmLevel;
        U032 Depth;
        U032 Resolution;
        U032 RefreshRate;
        U032 HorizFrontPorch;
        U032 HorizSyncWidth;
        U032 HorizBackPorch;
        U032 HorizDisplayWidth;
        U032 VertFrontPorch;
        U032 VertSyncWidth;
        U032 VertBackPorch;
        U032 VertDisplayWidth;
        U032 HSyncPolarity;
        U032 VSyncPolarity;
        U032 CSync;
        U032 Count;
        U032 ServiceCount;
        U032 ActiveCount;
        U032 ActiveMask;
        U032 Start[4];
        U032 Limit[4];
        U032 Current;
        U032 FlipUsageCount;
        U032 FlipTo;
        U032 FlipFrom;
        U032 VBlankToggle;
        U032 UpdateFlags;
        U032 FinishFlags;
        U032 MonitorType;
        U032 FilterEnable;
        U032 SaveToEEPROMEnable;
        U032 Underscan_x;
        U032 Underscan_y;
        U032 Scale_x;               
        U032 Scale_y;
        U032 Instance;
        U032 DmaInstance;
        //U008 *fbInstBitmap;              //***
        U032 fbSave[4];                    //***
    } Framebuffer;
    struct _def_graphics_info
    {
        U032 Size;
        char ID[32];
        U032 Debug0;
        U032 Debug1;
        U032 Debug2;
        U032 Debug3;
        U032 CurrentChID;
        U032 Count;
        U032 CanvasCount;
        U032 Enabled;
        U032 ServiceCount;
        U032 ComplexClipCount;
        U032 UpdateFlags;
        U032 FinishFlags;
        //PGRAPHICSCHANNEL  grTable;         //***
        //PCANVAS           grSysCanvas;     //***
        //PNODE             grCanvasTree;    //***
        //PVBLANKNOTIFY     grVBlankList[2]; //***
        U032              grSave[36];        //***
    } Graphics;
    struct _def_video_info
    {
        U032 Size;
        char ID[32];
        U032 CurrentChID;
        U032 ColorKeyEnabled;
        U032 ScaleFactor;   // 12.20
        U032 Enabled;
        U032 VideoStart;
        U032 VideoSize;
        U032 VideoScale;
        U032 VideoColorKey;
        U032 UpdateFlags;
        U032 FinishFlags;
#ifdef FRAME_LOCK
        // the rock under which we store information to try to genlock things
        U032 dwStartIt;
        S032 dwPhaseError;
        S032 dwlocError;
        U032 dwRockIndex;
        S032 dwRockStorage[MAXROCKS];
        U032 dwRockStorage2[MAXROCKS];
        U032 dwLastIt;
        
        S032 oldRaw;
        S032 oldLow;
        S032 oldReject;
        S032 oldOutput;
#endif // FRAME_LOCK

#ifdef  NV3WDMHACK
        // there are four sets of these, two each for Image and VBI
        U032                pVidToMemDelayParam0;
        U032                pVidToMemDelayParam1;
        U032                pVidToMemDelayParam2;
        U032                pVidToMemDelayParam3;
        U032                dwDelayCounter0;        // zero indicates not running, 1 starts running, N completes
        U032                dwDelayCounter1;        
        U032                dwDelayCounter2;        
        U032                dwDelayCounter3;    
        U032                dwHasInited;    
#endif //NV3WDMHACK
    } Video;
    struct _def_mediaport_info
    {
        U032 Size;
        char ID[32];
        U032 CurrentChID;
        U032 Enabled;
        U032 MPCPresent;
        //MEDIAPORTCONTEXT  mpContext[NUM_FIFOS];  //***
    } MediaPort;
    struct _def_dac_info
    {
        U032 Size;
        char ID[32];
        U032 InputWidth;
        U032 PClkVClkRatio;
        U032 VClk;
        U032 MClk;
        U032 PClk;
        U032 VPllM;
        U032 VPllN;
        U032 VPllO;
        U032 VPllP;
        U032 MPllM;
        U032 MPllN;
        U032 MPllO;
        U032 MPllP;
        U032 DpmLevel;
        S032 CursorPosX;
        S032 CursorPosY;
        U032 TVCursorMin;
        U032 TVCursorMax;
        U032 CursorWidth;
        U032 CursorHeight;
        U008 CursorImagePlane[2][32 * sizeof(U032)];
        U032 CursorType;
        U032 CursorColor1;
        U032 CursorColor2;
        U032 CursorColor3;
        U016 CursorColorImage[32][32];
#ifdef SW_CURSOR
        U008 CursorColorImage[32][32 * sizeof(U032)];
        S032 CursorSaveUnderPosX;
        S032 CursorSaveUnderPosY;
        U032 CursorSaveUnderWidth;
        U032 CursorSaveUnderHeight;
        U032 CursorSaveUnder[32][32];
        U032 CursorExclude;
        U032 CursorEmulation;
#endif // SW_CURSOR
        U032 Palette[272];
        U032 Gamma[272];
        U032 UpdateFlags;
        U032 FinishFlags;
        U032 CursorImageInstance;
        U016 CursorImageCache[32][32][MAX_CACHED_CURSORS]; // 32x32 words
        U032 CursorImageCacheInstance[MAX_CACHED_CURSORS];
        U032 CursorAddress[MAX_CACHED_CURSORS];
        // JJV - Cached cursor sum values.
        U032 CursorMaskCRC[MAX_CACHED_CURSORS];
        // JJV - Saved cursor for 8bpp.
        U008 SavedCursor[(32/8)*32 + 32*32];
        U032 CursorCachedExtra;
        U032 CursorCached;
        U032 CursorCacheCount;
        U032 CursorCacheEntry;
        U008 flickertoggle;                //***
        U008 dummy0;                       //Pads for the previous byte ***
        U008 dummy1;                       //Pads for the previous byte ***
        U008 dummy2;                       //Pads for the previous byte ***
        U032 filterCountdown;              //***
#ifdef NV3WDMHACK
        U032 dwImageCtxCount;
#endif
    } Dac;
    struct _def_dgp_chip_info
    {
        U032 Size;
        char ID[32];
        U032 Chip;
        U032 Enable3D;
        U032 Scale;
        U032 HorizDelay;
        U032 HorizOffset;
        U032 HorizScale;
        U032 VertOffset;
        U032 VertScale;
        U032 UpdateFlags;
        U032 FinishFlags;
        
    } Dgp;
    struct _def_timer_info
    {
        U032 Size;
        char ID[32];
        U032 Denominator;
        U032 Numerator;
        U032 ServiceCount;
        U032 UpdateFlags;
        U032 FinishFlags;
        //PTIMERCALLBACK    tmrCallbackList;     //***
        //PTIMERCALLBACK    tmrCallbackFreeList; //***
        //PTIMERCALLBACK    tmrCallbackTable;    //***
        U032              tmrSave[2];          //***
    } Timer;
    struct _def_vga_info
    {
        U032 Size;
        char ID[32];
        U032 Enabled;
#ifdef NV_VGA
        U032 GlobalEnable;
        U032 RomVersion;
        U032 RomFixupCode;
        U032 UpdateFlags;
        U032 FinishFlags;
#endif // NV_VGA
    } Vga;
    struct _def_classes_info
    {
        U032 Size;
        char ID[32];
        U032 UpdateFlags;
        U032 FinishFlags;
    } Classes;
    struct _def_stat_info
    {
        U032 Size;
        char ID[32];
        U032 AudioExceptionCount;
        U032 FifoExceptionCount;
        U032 FramebufferExceptionCount;
        U032 GraphicsExceptionCount;
        U032 TimerExceptionCount;
        U032 TotalExceptionCount;
        U032 IntTimeLo;
        U032 IntTimeHi;
        U032 ExecTimeLo;
        U032 ExecTimeHi;
        U032 MemAlloced;
        U032 MemLocked;
        U032 UpdateLo;
        U032 UpdateHi;
    } Statistics;
    struct _def_null_info
    {
        U032 Size;
        char ID[32];
    } Null;
    struct _def_obsolete_info
    {
      //U032  (*displayModeHook)(U032);   
      //SURFACEATTRIBUTES OverlaySurfaceAttribs[20];
      //SURFACEATTRIBUTES ImageSurfaceAttribs[20];
      //PVBLANKNOTIFY     class63VBlankList[2];
      U032              class63VBlankCount[2];
      
      U032              dwOvMaxBuffer;
      //PVIDEOFROMMEMOBJECT class63ActiveVideo[1];
      U032              dwSchedule_1_ToSurfaceEven;
      U032              dwSchedule_1_ToSurfaceOdd; 
      U032              dwSchedule_0_ToSurfaceEven;
      U032              dwSchedule_0_ToSurfaceOdd;
      //POBJECT           pHardwareObject;
      U032              global_dwVideoFormat;
      U032              dwDigitiserType;
      U032              dwImageCtxCount;
      U032              dwVbiCtxCount;
      U032              FLIP_OVERLAY_SURFACE_0;
      U032              FLIP_OVERLAY_SURFACE_1;
      U032              dwMasterSkipPattern;
      U032              dwTempSkipPattern;
      U032              dwMasterSkipBits;
      U032              dwIndexSkipBits;
      U032              dwImage0Skipped;
      U032              dwImage1Skipped;
      U032              dwOldLength0;
      U032              dwOldLength1;
      U032              dwXres; 
      U032              dwYres; 
      U032              dwIntMasterIndex; // used for interleave mode only
      U032              dwIntBuff0Index;
      U032              dwIntBuff1Index;
      U032              dwMaxBuffers;     // this will be changed for multiple buffer
      U032              dwVbiBufferNumber;
      U032              dwImageBufferNumber;
      //PPARALLELBUSOBJECT pNotifyObject;
      U008              iniFlag;
      U008              dummy3;
      U008              dummy4;
      U008              dummy5;
     #ifdef DEBUG
      U032              dwActiveObjects;
      U032              dwCreatedObjects;
      U032              dwDormantObjects;
      U032              dwVmiInterrupts;
      U032              dwImageInterrupts;
      U032              dwVbiInterrupts;
     #endif   
    }  Obsolete; 
} HWINFO, * PHWINFO;

typedef struct _def_rmInstance_info  *PNvDB, NvDB;

// This is the Master Structure for all of the system globals.
struct _def_rmInstance_info
{
  HWINFO              DBnvInfo;
  U032                *DBApertureTranslationTable;  //***
  POBJECT             *DBhashTable;                 //***
  U008                *DBfbInstBitmap;              //***
  PHWREG              DBnvAddr;                     //***
  PHWREG              DBromAddr;                    //***
  PHWREG              DBfbAddr;                     //***
  PHWREG              DBagpAddr;                    //***
  PHWREG              DBimAddr;                     //***
                                                    
  PFIFO               DBfifoTable;                  //***
  PDMAOBJECT          DBDmaList;                    //***
  PDMAOBJECT          DBVidDmaObject;               //***
  PGRAPHICSCHANNEL    DBgrTable;                    //***
  PCANVAS             DBgrSysCanvas;                //***
  PNODE               DBgrCanvasTree;               //***
  PVBLANKNOTIFY       DBgrVBlankList[2];            //***
  PTIMERCALLBACK      DBtmrCallbackList;            //***
  PTIMERCALLBACK      DBtmrCallbackFreeList;        //***
  PTIMERCALLBACK      DBtmrCallbackTable;           //***
  PVBLANKNOTIFY       DBclass63VBlankList[2];
  PVIDEOFROMMEMOBJECT DBclass63ActiveVideo[1];
  POBJECT             DBpHardwareObject;
  PPARALLELBUSOBJECT  DBpNotifyObject;
  U032                (*DBdisplayModeHook)(U032);   
  MEDIAPORTCONTEXT    DBmpContext[NUM_FIFOS];       //***
  SURFACEATTRIBUTES   DBOverlaySurfaceAttribs[20];
  SURFACEATTRIBUTES   DBImageSurfaceAttribs[20];
} ;

#ifndef JV
#define MAX_INSTANCE 8
#define TEST_DEVICE_NUM 0
extern  int   DeviceInstance;
extern  PNvDB NvDBPtr_Table[MAX_INSTANCE];
#endif // JV

// Multiple instance macros.
// This is on the Ugly side at the moment (Should be cleaned up soon)

//#define nvAddr                      NvDBPtr_Table[DeviceInstance]->DBnvInfo.Mapping.nvAddr
//#define romAddr                   NvDBPtr_Table[DeviceInstance]->DBnvInfo.Mapping.romAddr                  
//#define fbAddr                    NvDBPtr_Table[DeviceInstance]->DBnvInfo.Mapping.fbAddr                   
//#define agpAddr                   NvDBPtr_Table[DeviceInstance]->DBnvInfo.Mapping.agpAddr                  

#define nvPhys                    NvDBPtr_Table[DeviceInstance]->DBnvInfo.Mapping.nvPhys                   
#define fbPhys                    NvDBPtr_Table[DeviceInstance]->DBnvInfo.Mapping.fbPhys                   
#define nvIRQ                     NvDBPtr_Table[DeviceInstance]->DBnvInfo.Mapping.nvIRQ                    
#define dllIpcOffset              NvDBPtr_Table[DeviceInstance]->DBnvInfo.Mapping.dllIpcOffset             
#define dllIpcSelector            NvDBPtr_Table[DeviceInstance]->DBnvInfo.Mapping.dllIpcSelector           
#define dllNotifyOffset           NvDBPtr_Table[DeviceInstance]->DBnvInfo.Mapping.dllNotifyOffset          
#define dllNotifySelector         NvDBPtr_Table[DeviceInstance]->DBnvInfo.Mapping.dllNotifySelector        

//#define nvInfoSelector            NvDBPtr_Table[DeviceInstance]->DBnvInfo.Mapping.nvInfoSelector           
//#define channelInfoSelector       NvDBPtr_Table[DeviceInstance]->DBnvInfo.Mapping.channelInfoSelector      
//#define clientInfoSelector        NvDBPtr_Table[DeviceInstance]->DBnvInfo.Mapping.clientInfoSelector       

#define ChipID                    NvDBPtr_Table[DeviceInstance]->DBnvInfo.Mapping.ChipID                   
//#define ApertureTranslationTable  NvDBPtr_Table[DeviceInstance]->DBnvInfo.Mapping.ApertureTranslationTable
#define hpicIRQ                   NvDBPtr_Table[DeviceInstance]->DBnvInfo.Mapping.hpicIRQ                  
#define hDev                      NvDBPtr_Table[DeviceInstance]->DBnvInfo.Mapping.hDev                  

#define osStartInterrupt          NvDBPtr_Table[DeviceInstance]->DBnvInfo.Chip.osStartInterrupt

//#define fifoTable                 NvDBPtr_Table[DeviceInstance]->DBnvInfo.Fifo.fifoTable
#define fifoAllocateCount         NvDBPtr_Table[DeviceInstance]->DBnvInfo.Fifo.fifoAllocateCount
//#define hashTable                 NvDBPtr_Table[DeviceInstance]->DBnvInfo.Fifo.hashTable
                                  
//#define mpContext                 NvDBPtr_Table[DeviceInstance]->DBnvInfo.MediaPort.mpContext
                                  
//#define grTable                   NvDBPtr_Table[DeviceInstance]->DBnvInfo.Graphics.grTable     
//#define grSysCanvas               NvDBPtr_Table[DeviceInstance]->DBnvInfo.Graphics.grSysCanvas 
//#define grCanvasTree              NvDBPtr_Table[DeviceInstance]->DBnvInfo.Graphics.grCanvasTree
//#define grVBlankList              NvDBPtr_Table[DeviceInstance]->DBnvInfo.Graphics.grVBlankList
#define grSave                    NvDBPtr_Table[DeviceInstance]->DBnvInfo.Graphics.grSave      

//#define fbInstBitmap              NvDBPtr_Table[DeviceInstance]->DBnvInfo.Framebuffer.fbInstBitmap                    
#define fbSave                    NvDBPtr_Table[DeviceInstance]->DBnvInfo.Framebuffer.fbSave   

//#define tmrCallbackList           NvDBPtr_Table[DeviceInstance]->DBnvInfo.Timer.tmrCallbackList    
//#define tmrCallbackFreeList       NvDBPtr_Table[DeviceInstance]->DBnvInfo.Timer.tmrCallbackFreeList
//#define tmrCallbackTable          NvDBPtr_Table[DeviceInstance]->DBnvInfo.Timer.tmrCallbackTable   
#define tmrSave                   NvDBPtr_Table[DeviceInstance]->DBnvInfo.Timer.tmrSave            
                                  
//#define DmaList                   NvDBPtr_Table[DeviceInstance]->DBnvInfo.Dma.DmaList
#define dmaPushPutOffset          NvDBPtr_Table[DeviceInstance]->DBnvInfo.Dma.dmaPushPutOffset
#define dmaPushGetOffset          NvDBPtr_Table[DeviceInstance]->DBnvInfo.Dma.dmaPushGetOffset
#define dmaPushGetOffsetRead      NvDBPtr_Table[DeviceInstance]->DBnvInfo.Dma.dmaPushGetOffsetRead
#define dmaPushJumpOffset         NvDBPtr_Table[DeviceInstance]->DBnvInfo.Dma.dmaPushJumpOffset
#define dmaPushJumpOffsetSet      NvDBPtr_Table[DeviceInstance]->DBnvInfo.Dma.dmaPushJumpOffsetSet        
//#define VidDmaObject              NvDBPtr_Table[DeviceInstance]->DBnvInfo.Dma.VidDmaObject                    
                                  
#define flickertoggle             NvDBPtr_Table[DeviceInstance]->DBnvInfo.Dac.flickertoggle  
#define filterCountdown           NvDBPtr_Table[DeviceInstance]->DBnvInfo.Dac.filterCountdown
#ifdef NV3WDMHACK
#define dwImageCtxCount           NvDBPtr_Table[DeviceInstance]->DBnvInfo.Dac.dwImageCtxCount
#endif
                                  
//#define displayModeHook             NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.displayModeHook
//#define OverlaySurfaceAttribs        NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.OverlaySurfaceAttribs      
//#define ImageSurfaceAttribs          NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.ImageSurfaceAttribs        

//#define class63VBlankList            NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.class63VBlankList          

#define class63VBlankCount           NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.class63VBlankCount         
#define dwOvMaxBuffer                NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwOvMaxBuffer

//#define class63ActiveVideo           NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.class63ActiveVideo         

#define dwSchedule_1_ToSurfaceEven   NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwSchedule_1_ToSurfaceEven 
#define dwSchedule_1_ToSurfaceOdd    NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwSchedule_1_ToSurfaceOdd  
#define dwSchedule_0_ToSurfaceEven   NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwSchedule_0_ToSurfaceEven 
#define dwSchedule_0_ToSurfaceOdd    NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwSchedule_0_ToSurfaceOdd  
     #ifdef DEBUG                                                                   
#define dwActiveObjects              NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwActiveObjects            
#define dwCreatedObjects             NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwCreatedObjects           
#define dwDormantObjects             NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwDormantObjects           
#define dwVmiInterrupts              NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwVmiInterrupts            
#define dwImageInterrupts            NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwImageInterrupts          
#define dwVbiInterrupts              NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwVbiInterrupts            
     #endif                                                                         
//#define pHardwareObject              NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.pHardwareObject            

#define global_dwVideoFormat         NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.global_dwVideoFormat
#define dwDigitiserType              NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwDigitiserType            
#define dwImageCtxCount              NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwImageCtxCount            
#define dwVbiCtxCount                NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwVbiCtxCount              
#define FLIP_OVERLAY_SURFACE_0       NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.FLIP_OVERLAY_SURFACE_0     
#define FLIP_OVERLAY_SURFACE_1       NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.FLIP_OVERLAY_SURFACE_1     
#define dwMasterSkipPattern          NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwMasterSkipPattern        
#define dwTempSkipPattern            NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwTempSkipPattern          
#define dwMasterSkipBits             NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwMasterSkipBits           
#define dwIndexSkipBits              NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwIndexSkipBits            
#define dwImage0Skipped              NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwImage0Skipped            
#define dwImage1Skipped              NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwImage1Skipped            
#define dwOldLength0                 NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwOldLength0               
#define dwOldLength1                 NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwOldLength1               
#define dwXres                       NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwXres                     
#define dwYres                       NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwYres                     
#define dwIntMasterIndex             NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwIntMasterIndex           
#define dwIntBuff0Index              NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwIntBuff0Index            
#define dwIntBuff1Index              NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwIntBuff1Index            
#define dwMaxBuffers                 NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwMaxBuffers               
#define dwVbiBufferNumber            NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwVbiBufferNumber          
#define dwImageBufferNumber          NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwImageBufferNumber        

//#define pNotifyObject                NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.pNotifyObject              
#define iniFlag                      NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.iniFlag                    

#define OverlaySurfaceAttribs        NvDBPtr_Table[DeviceInstance]->DBOverlaySurfaceAttribs
#define ImageSurfaceAttribs          NvDBPtr_Table[DeviceInstance]->DBImageSurfaceAttribs

#define mpContext                    NvDBPtr_Table[DeviceInstance]->DBmpContext

#define displayModeHook              NvDBPtr_Table[DeviceInstance]->DBdisplayModeHook
#define fifoTable                    NvDBPtr_Table[DeviceInstance]->DBfifoTable
#define DmaList                      NvDBPtr_Table[DeviceInstance]->DBDmaList
#define VidDmaObject                 NvDBPtr_Table[DeviceInstance]->DBVidDmaObject
#define grTable                      NvDBPtr_Table[DeviceInstance]->DBgrTable
#define grSysCanvas                  NvDBPtr_Table[DeviceInstance]->DBgrSysCanvas
#define grCanvasTree                 NvDBPtr_Table[DeviceInstance]->DBgrCanvasTree
#define grVBlankList                 NvDBPtr_Table[DeviceInstance]->DBgrVBlankList
#define tmrCallbackList              NvDBPtr_Table[DeviceInstance]->DBtmrCallbackList
#define tmrCallbackFreeList          NvDBPtr_Table[DeviceInstance]->DBtmrCallbackFreeList
#define tmrCallbackTable             NvDBPtr_Table[DeviceInstance]->DBtmrCallbackTable
#define class63VBlankList            NvDBPtr_Table[DeviceInstance]->DBclass63VBlankList
#define class63ActiveVideo           NvDBPtr_Table[DeviceInstance]->DBclass63ActiveVideo
#define pHardwareObject              NvDBPtr_Table[DeviceInstance]->DBpHardwareObject
#define pNotifyObject                NvDBPtr_Table[DeviceInstance]->DBpNotifyObject

#define nvAddr                       NvDBPtr_Table[DeviceInstance]->DBnvAddr 
#define romAddr                      NvDBPtr_Table[DeviceInstance]->DBromAddr
#define fbAddr                       NvDBPtr_Table[DeviceInstance]->DBfbAddr 
#define agpAddr                      NvDBPtr_Table[DeviceInstance]->DBagpAddr
#define imAddr                       NvDBPtr_Table[DeviceInstance]->DBimAddr

#define ApertureTranslationTable     NvDBPtr_Table[DeviceInstance]->DBApertureTranslationTable
#define hashTable                    NvDBPtr_Table[DeviceInstance]->DBhashTable
#define fbInstBitmap                 NvDBPtr_Table[DeviceInstance]->DBfbInstBitmap

#define nvInfo                       NvDBPtr_Table[DeviceInstance]->DBnvInfo 


#endif // _NVRM_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\nvpeos.h ===
#ifndef _NVPEOS_H
#define _NVPEOS_H

///////////
// external services
//
extern void KeClearEvent(void *hEvent);
extern U032 KeSetEvent(void *hEvent, void *Increment, U032 Wait);
extern U032 RmAllocChannelDma(U032, U032, U032,	U032, U032,	U032, U032,	U032 *);
extern U032 RmAllocObject(U032, U032, U032, U032);
extern U032 RmFree(U032, U032, U032);
extern U032 RmAllocContextDma(U032, U032, U032, U032, U032, U032, U032);
extern U032 Nv01AllocEvent(NVOS10_PARAMETERS *);
extern U032 RmAlloc(U032, U032, U032, U032, VOID *);

#if DBG

extern int cur_debuglevel;

// Debug level values
#define DEBUGLEVEL_TRACEINFO    0     // For informational debug trace info
#define DEBUGLEVEL_SETUPINFO    1     // For informational debug setup info
#define DEBUGLEVEL_USERERRORS   2     // For debug info on app level errors
#define DEBUGLEVEL_WARNINGS     3     // For RM debug warning info
#define DEBUGLEVEL_ERRORS       4     // For RM debug error info

VOID osDbgPrintString(int, char*);
VOID osDbgPrintStringValue(int, char*, int);

#define DBG_PRINT_STRING(d,s)           osDbgPrintString((d),(s))
#define DBG_PRINT_STRING_VALUE(d,s,v)   osDbgPrintStringValue((d),(s),(v))

#else

#define DBG_PRINT_STRING(d,s)
#define DBG_PRINT_STRING_VALUE(d,s,v)

#endif // DBG

// local prototypes
U032 osNVPAllocDmaBuffer(void *pContext,U032 dwSize,void **pBuffer);
void osNVPReleaseDmaBuffer(void *pContext,void *pBuffer);
void osNVPClearEvent(void *hEvent);
U032 osNVPSetEvent(void *hEvent);
U032 rmNVPAllocContextDma(U032 hClient,U032 hDma,U032 hClass,U032 flags,U032 selector,U032 base,U032 limit);
U032 rmNVPAllocChannelDma(U032 hClient,U032 hDevice,U032 hDmaChannel,U032 hClass,U032 hErrorContext,U032 hDataContext,U032 offset,U032 *ppControl);
U032 rmNVPAllocObject(U032 hClient,U032 hChannel,U032 hObject,U032 hClass);
U032 rmNVPAllocEvent(NVOS10_PARAMETERS *pEvent);
U032 rmNVPFree(U032 hClient,U032 hParent,U032 hObject);
U032 rmNVPAlloc(U032 hClient, U032 hChannel, U032 hObject, U032 hClass, PVOID pAllocParms);

#endif // _NVPEOS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\nvpeos.c ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

/*
==============================================================================

    NVIDIA Corporation, (C) Copyright 
    1993-1999. All rights reserved.

    nvpeos.c

    VPE kernel wrappers to OS or RM dependent services

    Dec 17, 1999

==============================================================================
*/
#ifdef NVPE

#ifdef _WIN32_WINNT
#include "miniport.h"
#include "ntddvdeo.h"
#include "video.h"
#endif

#include "nvos.h"
#include "nvpeos.h"

#ifdef DBG
U032 DbgPrint(U008 *pchFormat, ...);
#endif // DBG

U032 osNVPAllocDmaBuffer(
	void *pContext, 
	U032 dwSize, 
	void **pBuffer)
{
	return (U032)VideoPortAllocateBuffer(pContext, dwSize, pBuffer);
}

void osNVPReleaseDmaBuffer(
	void *pContext, 
	void *pBuffer)
{
	VideoPortReleaseBuffer(pContext, pBuffer);
}

void osNVPClearEvent(void *hEvent)
{
	KeClearEvent(hEvent);
}

U032 osNVPSetEvent(void *hEvent)
{
	return KeSetEvent(hEvent, NULL, FALSE);
}

U032 rmNVPAllocContextDma(
    U032 hClient,
    U032 hDma,
    U032 hClass,
    U032 flags,
    U032 selector,
    U032 base,
    U032 limit)
{
	return RmAllocContextDma(hClient, hDma, hClass, flags, selector, base, limit);
}

U032 rmNVPAllocChannelDma(
	U032 hClient,
	U032 hDevice,
	U032 hDmaChannel,
	U032 hClass,
	U032 hErrorContext,
	U032 hDataContext,
	U032 offset,
	U032 *ppControl)
{
	return RmAllocChannelDma(hClient, hDevice, hDmaChannel, hClass, hErrorContext, hDataContext, offset, ppControl);
}

U032 rmNVPAllocObject(
	U032 hClient,
	U032 hChannel,
	U032 hObject,
	U032 hClass)
{
	return RmAllocObject(hClient, hChannel, hObject, hClass);

}

U032 rmNVPAllocEvent(
	NVOS10_PARAMETERS *pEvent)
{
	Nv01AllocEvent(pEvent);
	return 0;
}

U032 rmNVPAlloc(
    U032 hClient,
    U032 hChannel,
    U032 hObject,
    U032 hClass,
    PVOID pAllocParms)
{

    return RmAlloc(hClient, hChannel, hObject, hClass, pAllocParms);

}

U032 rmNVPFree(
	U032 hClient,
	U032 hParent,
	U032 hObject)
{
	return RmFree(hClient, hParent, hObject);
}

#ifdef DBG

VOID osDbgPrintString
(
    int debuglevel,
    char* string
)
{
    if (debuglevel >= cur_debuglevel)
    {
        // print formatted string, for checked build
        DbgPrint(string);
    }
}

VOID osDbgPrintStringValue
(
    int debuglevel,
    char *string,
    int value
)
{
    if (debuglevel >= cur_debuglevel)
    {
        // print string and hex value, for checked build
        DbgPrint("%s 0x%x\n", string, value);

    }
}

#endif // DBG

#endif // NVPE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\nvsubch.h ===
//******************************************************************************
//
// Copyright (c) 1992  Microsoft Corporation
//
// Module Name:
//
//     nvsubch.h
//
// Abstract:
//
//     This module contains the object subchannel definitions
//
// Environment:
//
//     Kernel mode
//
// Revision History:
//
//
//******************************************************************************

//******************************************************************************
//
// Copyright (c) 1996,1997  NVidia Corporation. All Rights Reserved
//
//******************************************************************************

#define CLIP_SUBCHANNEL                6
#define IMAGE_PATTERN_SUBCHANNEL       5
#define ROP_SOLID_SUBCHANNEL           4

#define RECTANGLE_SUBCHANNEL           3
#define LUT_CURSOR_DAC_SUBCHANNEL      3                
#define IMAGE_MONO_FROM_CPU_SUBCHANNEL 2
#define RECT_AND_TEXT_SUBCHANNEL       2
#define BLIT_SUBCHANNEL                1
#define IMAGE_FROM_CPU_SUBCHANNEL      0
#define DD_SPARE                       7
#define DD_ROP_RECT_AND_TEXT           2
#define DD_STRETCH                     DD_SPARE

#define SOLID_LIN_SUBCHANNEL           7
//******************************************************************************
// OpenGL SubChannel assignments for objects
//******************************************************************************

#define TRIANGLE_SUBCHANNEL            0
#define D3DTRIANGLE_SUBCHANNEL         0
#define CLEARZ_SUBCHANNEL              2
#define SRCIMAGE_IN_MEMORY_SUBCHANNEL  5
#define D3DTRIANGLE_SYSMEM_SUBCHANNEL  4
#define RENDER_SOLID_LIN_SUBCHANNEL    0

//******************************************************************************
// My 32-bit names for the STATIC image objects
//******************************************************************************

#define MY_IMAGE_SOLID                 0x99990001
#define MY_BLACK_RECTANGLE             0x99990002
#define MY_IMAGE_PATTERN               0x99990003
#define MY_ROP_SOLID                   0x99990004

//******************************************************************************
// My 32-bit names for RENDERING type objects
//******************************************************************************

#define MY_RENDER_SOLID_RECTANGLE      0x34000001
#define MY_RENDER_SOLID_TRIANGLE       0x34000002
#define MY_RENDER_SCRN_TO_SCRN_BLIT    0x34000003
#define MY_IMAGE_FROM_CPU_BLIT         0x34000004
#define MY_IMAGE_MONO_FROM_CPU_BLIT    0x34000005
#define MY_RENDER_D3D_TRIANGLE         0x34000006
#define MY_CLEARZ_RECTANGLE            0x34000007
#define MY_SRCIMAGE_IN_MEMORY          0x34000008
#define MY_DSTIMAGE_IN_MEMORY          0x34000009
#define MY_MEMORY_TO_MEMORY            0x3400000A
#define MY_RENDER_D3D_SYSMEM_TRIANGLE  0x3400000B
#define MY_RENDER_D3D_TRIANGLE_SYSMEM  MY_RENDER_D3D_SYSMEM_TRIANGLE
#define MY_RENDER_SOLID_LIN            0x3400000C
#define MY_STENCIL_TRIANGLE            0x3400000D
#define MY_STENCIL_LIN                 0x3400000E
#define MY_STENCIL_SYSMEM_TRIANGLE     0x3400000F

//****************************************************************************
// object id's (only used by Release driver)
//****************************************************************************
#define DD_IMAGE_FROM_CPU               0x000A0000
#define DD_IMAGE_BLIT                   0x000A0001
#define DD_IMAGE_MONO                   0x000A0002
#define DD_RENDER_SOLID_RECTANGLE       0x000A0003
//#define DD_ROP_SOLID                  0x000A0004 undefined for RIVA (jsw)
#define DD_ROP5_SOLID                   0x000A0004
#define DD_IMAGE_PATTERN                0x000A0005
#define DD_IMAGE_BLACK_RECTANGLE        0x000A0006
#define DD_IMAGE_SOLID                  0x000A0007
#define DD_RENDER_RECT_AND_TEXT         0x000A0008
#define DD_IMAGE_ROP_AND0               0x000A0010
#define DD_IMAGE_ROP_AND1               0x000A0011
#define DD_IMAGE_ROP_AND2               0x000A0012
#define DD_IMAGE_ROP_AND3               0x000A0013
#define DD_IMAGE_ROP_AND4               0x000A0014
#define DD_IMAGE_ROP_AND5               0x000A0015
#define DD_IMAGE_ROP_AND6               0x000A0016
#define DD_IMAGE_STENCIL0               0x000A0020
#define DD_IMAGE_STENCIL1               0x000A0021
#define DD_IMAGE_STENCIL2               0x000A0022
#define DD_IMAGE_STENCIL3               0x000A0023
#define DD_IMAGE_STENCIL4               0x000A0024
#define DD_IMAGE_STENCIL5               0x000A0025
#define DD_IMAGE_STENCIL6               0x000A0026
#define DD_IMAGE_COLOR_KEY0             0x000A0030
#define DD_IMAGE_COLOR_KEY1             0x000A0031
#define DD_IMAGE_COLOR_KEY2             0x000A0032
#define DD_IMAGE_COLOR_KEY3             0x000A0033
#define DD_IMAGE_COLOR_KEY4             0x000A0034
#define DD_IMAGE_COLOR_KEY5             0x000A0035
#define DD_IMAGE_COLOR_KEY6             0x000A0036
#define DD_IMAGE_TO_VIDEO               0x000A00E0
#define DD_VIDEO_SINK                   0x000A00F0
#define DD_PRIMARY_VIDEO_FROM_MEMORY    0x000A00F1
#define DD_PRIMARY_IMAGE_IN_MEMORY      0x000A00F2
#define DD_COLORMAP                     0x000A00F3
#define DD_SRC_IMAGE_IN_MEMORY          0x000A00F4
#define DD_ZETA_BUFFER                  0x000A00F5
#define DD_RENDER_D3D_TRIANGLE          0x000A00F6
#define DD_IMAGE_FROM_MEMORY            0x000A00F7
#define DD_ZBUFFER_IMAGE_IN_MEMORY      0x000A00F8
#define DD_IMAGE_ROP_AND_LIN            0x000A00F9
#define DD_P_V_SHARED_VIDEO_COLORMAP    0x000A00FA
#define DD_INDEXED_IMAGE_FROM_CPU       0x000A00FB
#define DD_INDEXED_IMAGE1_FROM_CPU      0x000A00FC
#define DD_INDEXED_IMAGE2_FROM_CPU      0x000A00FD
#define DD_INDEXED_IMAGE3_FROM_CPU      0x000A00FE
#define DD_INDEXED_IMAGE4_FROM_CPU      0x000A00FF
#define DD_INDEXED_IMAGE5_FROM_CPU      0x000A0100
#define DD_INDEXED_IMAGE6_FROM_CPU      0x000A0101
#define DD_INDEXED_IMAGE7_FROM_CPU      0x000A0102
#define DD_INDEXED_IMAGE8_FROM_CPU      0x000A0103
#define DD_INDEXED_IMAGE9_FROM_CPU      0x000A0104
#define DD_INDEXED_IMAGE10_FROM_CPU     0x000A0105
#define DD_INDEXED_IMAGE11_FROM_CPU     0x000A0106
#define DD_INDEXED_IMAGE12_FROM_CPU     0x000A0107
#define DD_INDEXED_IMAGE13_FROM_CPU     0x000A0108
#define DD_INDEXED_IMAGE14_FROM_CPU     0x000A0109
#define DD_INDEXED_IMAGE15_FROM_CPU     0x000A010A
#define DD_INDEXED_IMAGE16_FROM_CPU     0x000A010B
#define DD_SCALED_IMAGE_FROM_MEMORY     0x000A0110
#define DD_IMAGE_BLIT_COLORKEY          0x000A0111
#define DD_ALPHA_IMAGE_FROM_MEMORY      0x000A0112

// patchcord id's
#define DD_PATCHCORD_IMAGE_FROM_CPU     0x000B0000
#define DD_PATCHCORD_IMAGE_BLIT         0x000B0001
#define DD_PATCHCORD_IMAGE_MONO         0x000B0002
#define DD_PATCHCORD_IMAGE_SOLID_RECT   0x000B0003
#define DD_PATCHCORD_ROP5_SOLID         0x000B0004
#define DD_PATCHCORD_IMAGE_PATTERN      0x000B0005
#define DD_PATCHCORD_IMAGE_BLACK_RECT   0x000B0006
#define DD_PATCHCORD_IMAGE_SOLID        0x000B0007
#define DD_PATCHCORD_IMAGE_RECT_AND_TEXT 0x000B0008
#define DD_PATCHCORD_IMAGE_ROP_AND0     0x000B0010
#define DD_PATCHCORD_IMAGE_ROP_AND1     0x000B0011
#define DD_PATCHCORD_IMAGE_ROP_AND2     0x000B0012
#define DD_PATCHCORD_IMAGE_ROP_AND3     0x000B0013
#define DD_PATCHCORD_IMAGE_ROP_AND4     0x000B0014
#define DD_PATCHCORD_IMAGE_ROP_AND5     0x000B0015
#define DD_PATCHCORD_IMAGE_ROP_AND6     0x000B0016
#define DD_PATCHCORD_IMAGE_STENCIL0     0x000B0020
#define DD_PATCHCORD_IMAGE_STENCIL1     0x000B0021
#define DD_PATCHCORD_IMAGE_STENCIL2     0x000B0022
#define DD_PATCHCORD_IMAGE_STENCIL3     0x000B0023
#define DD_PATCHCORD_IMAGE_STENCIL4     0x000B0024
#define DD_PATCHCORD_IMAGE_STENCIL5     0x000B0025
#define DD_PATCHCORD_IMAGE_STENCIL6     0x000B0026
#define DD_PATCHCORD_IMAGE0             0x000B0030
#define DD_PATCHCORD_IMAGE1             0x000B0031
#define DD_PATCHCORD_IMAGE2             0x000B0032
#define DD_PATCHCORD_IMAGE3             0x000B0033
#define DD_PATCHCORD_IMAGE4             0x000B0034
#define DD_PATCHCORD_IMAGE5             0x000B0035
#define DD_PATCHCORD_IMAGE6             0x000B0036
#define DD_PATCHCORD_IMAGE_FEEDBACK     0x000B00E0
#define DD_PATCHCORD_VIDEO              0x000B00E1
#define DD_PATCHCORD_COLORMAP           0x000B00E2
#define DD_PATCHCORD_SRC_FEEDBACK       0x000B00E3
#define DD_PATCHCORD_ZETA_IN            0x000B00E4
#define DD_PATCHCORD_ZETA_OUT           0x000B00E5
#define DD_PATCHCORD_IMAGE_TRIANGLE     0x000B00E6
#define DD_PATCHCORD_CLEAR_ZBUFFER      0x000B00E7
#define DD_PATCHCORD_IMAGE_SYSMEM_TRIANGLE 0x000B00E8
#define DD_PATCHCORD_ZETA_OUT_SYSMEM    0x000B00E9
#define DD_PATCHCORD_IMAGE_LIN          0x000B00EA
#define DD_PATCHCORD_STENCIL_TRIANGLE   0x000B00EB
#define DD_PATCHCORD_STENCIL_LIN        0x000B00EC
#define DD_PATCHCORD_STENCIL_SYSMEM_TRIANGLE   0x000B00ED

#define DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY    0x00001004
#define NV_WIN_NOTIFIER_CONTEXT_DMA_TO_MEMORY       0x00001005
#define NV_WIN_COLORMAP_CONTEXT                     0x00001010
#define NV_WIN_COLORMAP_CONTEXT_1                   0x00001011
#define NV_WIN_COLORMAP_CONTEXT_2                   0x00001012
#define NV_WIN_COLORMAP_CONTEXT_3                   0x00001013
#define NV_WIN_CONTEXT_DMA_FROM_MEMORY              0x00001015
#define DD_CONTEXT_DMA_NOTIFIER_TRIANGLE            0x00001017
#define DD_NOTIFIER_CONTEXT_DMA_MEMORY_TO_MEMORY_FORMAT 0x00001021
#define DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM          0x00001022
#define DD_CONTEXT_DMA_SYSMEM_TEXTURE_BUFFER        0x00001023
#define DD_NOTIFIER_CONTEXT_DMA_SCALED_IMAGE        0x00001024
#define DD_FIFO_SYNC_NOTIFIER                       0x00001025
#define DD_MEMORY_TO_MEMORY_CONTEXT_DMA_NOTIFIER    0x00001026
#define DD_TEMP_BUFFER_CONTEXT_DMA                  0x00001027
#define NV_WIN_INDEXED_IMAGE_CONTEXT                0x00001028
#define NV_DD_PRIMARY_2D_NOTIFIER_CONTEXT_DMA_TO_MEMORY  0x00001029
#define NV_VIDEO_LUT_CURSOR_DAC                     0x00001030
#define NV_VIDEO_LUT_CURSOR_DAC_2                   0x00001031
#define NV_VIDEO_LUT_CURSOR_DAC_3                   0x00001032
#define NV_VIDEO_LUT_CURSOR_DAC_4                   0x00001033
#define NV_CONTEXT_DMA_CURSOR                       0x00001034
#define NV_CONTEXT_DMA_CURSOR_2                     0x00001035
#define NV_CONTEXT_DMA_VIDEO_LUT_CURSOR_DAC_NOTIFIER     0x00001036

//****************************************************************************
// Dma push specific names
//****************************************************************************

#define NV_CONTEXT_DMA_FROM_MEMORY_PUSHBUF    0x000C0000
#define NV_CONTEXT_DMA_PUSHBUF_ERROR_NOTIFIER 0x000C0001

//****************************************************************************
// Object Instance IDs used by the VPP code on NT4
//****************************************************************************
#define NV_VPP_CHANNEL_IID                              0xEE00A000

#define NV_VPP_3D_OBJECT_IID                            0xEE00A010
#define NV_VPP_DMA_WITHIN_VMEM_IID                      0xEE00A020
#define NV_VPP_DMA_FROM_VMEM_IID                        0xEE00A030
#define NV_VPP_DMA_TO_VMEM_IID                          0xEE00A040
#define NV_VPP_LUT_CURSOR_DAC_IID                       0xEE00A050 // 51,52,53 reserved for additional heads
#define NV_VPP_OVERLAY_NOTIFIER_IID                     0xEE00A060


#define NV_VPP_A_SUBCH                          0
#define NV_VPP_B_SUBCH                          1
#define NV_VPP_C_SUBCH                          2
#define NV_VPP_D_SUBCH                          3
#define NV_VPP_E_SUBCH                          4
#define NV_VPP_F_SUBCH                          5
#define NV_VPP_G_SUBCH                          6
#define NV_VPP_3D_OBJECT_SUBCH                          7


//***************************************************************************************
// NV object names used by the ddraw driver.
//***************************************************************************************
/* Windows 95 Direct Draw Object IDs */
#define NV_DD_DST_IMAGE_IN_MEMORY                               0x80023F00
#define NV_DD_P_I_DST_IMAGE_IN_MEMORY                           0x80023F01
#define NV_DD_SRC_IMAGE_IN_MEMORY                               0x80023F10
#define NV_DD_P_I_SRC_IMAGE_IN_MEMORY                           0x80023F11
#define NV_DD_ZETA_IMAGE_IN_MEMORY                              0x80023F20
#define NV_D3D_ZETA_BUFFER_IN_MEMORY                            0x80023F30
#define NV_D3D_P_Z_ZETA_BUFFER_IN_MEMORY                        0x80023F31

// ELAU from WIN9x
/* Video channel shared Display Driver and DDraw Object IDs */
#define NV_VIDEO_OVERLAY_NOTIFIER_CONTEXT_DMA_TO_MEMORY         0x00008008
#define NV_VIDEO_OVERLAY                                        0x00008030

#define NV_DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM                   0x00002069
#define NV_DD_CONTEXT_DMA_FROM_SYSTEM_MEMORY                    0x00002070
#define NV_DD_WIN_COLORMAP_CONTEXT                              0x00002071
#define NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY             0x00002072

#define NV_DD_FLOATING_FORMAT_CONTEXT_DMA_FROM_SYSTEM_MEMORY    0x80021001
#define NV_DD_CONTEXT_DMA_FROM_VIDEO_MEMORY                     0x80021002
#define NV_DD_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY     0x80021003
#define NV_DD_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY     0x80021004
#define NV_DD_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY     0x80021005
#define NV_DD_FLOATING1_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY     0x80021006
#define NV_DD_FLOATING0_Y420_CONTEXT_DMA_FROM_SYSTEM_MEMORY     0x80021007
#define NV_DD_FLOATING1_Y420_CONTEXT_DMA_FROM_SYSTEM_MEMORY     0x80021008
#define NV_DD_TEXTURE_CONTEXT_DMA_FROM_SYSTEM_MEMORY            0x80021009
#define NV_DD_FLOATING_TEXTURE_CONTEXT_DMA_FROM_SYSTEM_MEMORY   0x8002100A
#define NV_DD_TRIANGLE_CONTEXT_DMA_FROM_SYSTEM_MEMORY           0x8002100B
#define DD_CONTEXT_DMA_FLIP_NOTIFIER                            0x8002100B
#define NV_DD_CONTEXT_DMA_IN_MEMORY                             0x80021010
#define NV_DD_FLIP_PRIMARY_NOTIFIER_CONTEXT_DMA_TO_MEMORY       0x80021016
#define NV_DD_FLIP_OVERLAY_NOTIFIER_CONTEXT_DMA_TO_MEMORY       0x80021017
#define NV_DD_FLIP_VPORT_NOTIFIER_CONTEXT_DMA_TO_MEMORY         0x80021018
#define NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY           0x80021019
#define NV_DD_PUSHER_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY        0x8002101A
#define NV_DD_DUMMY_NOTIFIER_CONTEXT_DMA_TO_MEMORY              0x8002101B
#define NV_DD_CONTEXT_DMA_TO_VIDEO_MEMORY                       0x8002101C
#define NV_DD_VIDEO_MEM_TO_SYSTEM_MEM_FORMAT                    0x80021020
#define NV_DD_ROP5_SOLID                                        0x80021030
#define NV_DD_P_I_ROP5_SOLID                                    0x80021031
#define NV_DD_BETA_SOLID                                        0x80021040
#define NV_DD_P_B_BETA_SOLID                                    0x80021041
#define NV_DD_IMAGE_PATTERN                                     0x80021050
#define NV_DD_P_I_IMAGE_PATTERN                                 0x80021051
#define NV_DD_IMAGE_BLACK_RECTANGLE                             0x80021060
#define NV_DD_P_I_IMAGE_BLACK_RECTANGLE                         0x80021061
#define NV_DD_COLOR_KEY_IMAGE_SOLID                             0x80021070
#define NV_DD_P_I_COLOR_KEY_IMAGE_SOLID                         0x80021071
#define NV_DD_FROM_MEM_INDEXED_IMAGE_NOTIFIER_CONTEXT_DMA_TO_MEMORY   0x80021072
#define NV_DD_FROM_MEM_INDEXED_IMAGE1_NOTIFIER_CONTEXT_DMA_TO_MEMORY  0x80021073
#define NV_DD_FROM_MEM_INDEXED_IMAGE2_NOTIFIER_CONTEXT_DMA_TO_MEMORY  0x80021074
#define NV_DD_FROM_MEM_INDEXED_IMAGE3_NOTIFIER_CONTEXT_DMA_TO_MEMORY  0x80021075
#define NV_DD_FROM_MEM_INDEXED_IMAGE4_NOTIFIER_CONTEXT_DMA_TO_MEMORY  0x80021076
#define NV_DD_FROM_MEM_INDEXED_IMAGE5_NOTIFIER_CONTEXT_DMA_TO_MEMORY  0x80021077
#define NV_DD_FROM_MEM_INDEXED_IMAGE6_NOTIFIER_CONTEXT_DMA_TO_MEMORY  0x80021078
#define NV_DD_FROM_MEM_INDEXED_IMAGE7_NOTIFIER_CONTEXT_DMA_TO_MEMORY  0x80021079
#define NV_DD_FROM_MEM_INDEXED_IMAGE8_NOTIFIER_CONTEXT_DMA_TO_MEMORY  0x8002107A
#define NV_DD_FROM_MEM_INDEXED_IMAGE9_NOTIFIER_CONTEXT_DMA_TO_MEMORY  0x8002107B
#define NV_DD_FROM_MEM_INDEXED_IMAGE10_NOTIFIER_CONTEXT_DMA_TO_MEMORY 0x8002107C
#define NV_DD_FROM_MEM_INDEXED_IMAGE11_NOTIFIER_CONTEXT_DMA_TO_MEMORY 0x8002107D
#define NV_DD_FROM_MEM_INDEXED_IMAGE12_NOTIFIER_CONTEXT_DMA_TO_MEMORY 0x8002107E
#define NV_DD_FROM_MEM_INDEXED_IMAGE13_NOTIFIER_CONTEXT_DMA_TO_MEMORY 0x8002107F
#define NV_DD_FROM_MEM_INDEXED_IMAGE14_NOTIFIER_CONTEXT_DMA_TO_MEMORY 0x80021080
#define NV_DD_FROM_MEM_INDEXED_IMAGE15_NOTIFIER_CONTEXT_DMA_TO_MEMORY 0x80021081
#define NV_DD_FROM_MEM_INDEXED_IMAGE16_NOTIFIER_CONTEXT_DMA_TO_MEMORY 0x80021082

#define NV_DD_ROP_RECT_AND_TEXT_FROM_CPU                        0x80021100
#define NV_DD_P_I_ROP_RECT_AND_TEXT_FROM_CPU                    0x80021101
#define NV_DD_SYNC_RECT_AND_TEXT_FROM_CPU                       0x80021108
#define NV_DD_P_I_SYNC_RECT_AND_TEXT_FROM_CPU                   0x80021109
#define NV_DD_PUSHER_SYNC_RECT_AND_TEXT_FROM_CPU                0x8002110A
#define NV_DD_P_I_PUSHER_SYNC_RECT_AND_TEXT_FROM_CPU            0x8002110B
#define NV_DD_IMAGE_FROM_CPU                                    0x80021200
#define NV_DD_P_I_IMAGE_FROM_CPU                                0x80021201
#define NV_DD_IMAGE_BLEND_FROM_CPU                              0x80021300
#define NV_DD_P_I_IMAGE_BLEND_FROM_CPU                          0x80021301
#define NV_DD_STRETCHED_IMAGE_FROM_CPU                          0x80021400
#define NV_DD_P_I_STRETCHED_IMAGE_FROM_CPU                      0x80021401
#define NV_DD_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY               0x80021500
#define NV_DD_P_I_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY           0x80021501
#define NV_DD_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY                0x80021510
#define NV_DD_P_I_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY            0x80021511
#define NV_DD_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY              0x80021520
#define NV_DD_P_I_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY          0x80021521
#define NV_DD_SCALED_UYVY_IMAGE_FROM_VIDEO_MEMORY               0x80021530
#define NV_DD_P_I_SCALED_UYVY_IMAGE_FROM_VIDEO_MEMORY           0x80021531
#define NV_DD_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY              0x80021540
#define NV_DD_P_I_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY          0x80021541
#define NV_DD_SCALED_YUYV_IMAGE_FROM_VIDEO_MEMORY               0x80021550
#define NV_DD_P_I_SCALED_YUYV_IMAGE_FROM_VIDEO_MEMORY           0x80021551
#define NV_DD_FLOATING0_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY    0x80021560
#define NV_DD_P_I_FLOATING0_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY 0x80021561
#define NV_DD_FLOATING1_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY    0x80021570
#define NV_DD_P_I_FLOATING1_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY 0x80021571
#define NV_DD_FLOATING0_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY    0x80021580
#define NV_DD_P_I_FLOATING0_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY 0x80021581
#define NV_DD_FLOATING1_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY    0x80021590
#define NV_DD_P_I_FLOATING1_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY 0x80021591
#define NV_DD_FLOATING0_SCALED_Y420_IMAGE_FROM_SYSTEM_MEMORY    0x800215A0
#define NV_DD_P_I_FLOATING0_SCALED_Y420_IMAGE_FROM_SYSTEM_MEMORY 0x800215A1
#define NV_DD_FLOATING1_SCALED_Y420_IMAGE_FROM_SYSTEM_MEMORY    0x800215B0
#define NV_DD_P_I_FLOATING1_SCALED_Y420_IMAGE_FROM_SYSTEM_MEMORY 0x800215B1
#define NV_DD_STRETCHED_UV_IMAGE_FROM_CPU                       0x80021600
#define NV_DD_P_I_STRETCHED_UV_IMAGE_FROM_CPU                   0x80021601

#define NV_DD_IMAGE_BLIT                                        0x80021800
#define NV_DD_P_I_IMAGE_BLIT                                    0x80021801
#define NV_DD_ALT_IMAGE_FROM_CPU                                0x80021900
#define NV_DD_P_I_ALT_IMAGE_FROM_CPU                            0x80021901
#define NV_DD_RENDER_SOLID_ZETA_RECTANGLE                       0x80021A00
#define NV_DD_P_I_RENDER_SOLID_ZETA_RECTANGLE                   0x80021A01

#define NV_D3D_RENDER_TRIANGLE_ZETA                             0x80021B00
#define NV_D3D_P_I_RENDER_TRIANGLE_ZETA                         0x80021B01
#define NV_D3D_P_Z_RENDER_TRIANGLE_ZETA                         0x80021B02
#define NV_D3D_RENDER_TRIANGLE_ZETA_FROM_VIDEO_MEMORY           0x80021B03
#define NV_D3D_P_I_RENDER_TRIANGLE_ZETA_FROM_VIDEO_MEMORY       0x80021B04
#define NV_D3D_P_Z_RENDER_TRIANGLE_ZETA_FROM_VIDEO_MEMORY       0x80021B05
#define NV_D3D_FLOATING_RENDER_TRIANGLE_ZETA                    0x80021B06
#define NV_D3D_FLOATING_P_I_RENDER_TRIANGLE_ZETA                0x80021B07
#define NV_D3D_FLOATING_P_Z_RENDER_TRIANGLE_ZETA                0x80021B08

#define NV_DD_VIDEO_COLOR_KEY                                   0x80023FB0
#define NV_DD_YUV422_VIDEO_FROM_MEMORY                          0x80023F90
#define NV_DD_PRIMARY_VIDEO_FROM_MEMORY                         0x80023F80
#define NV_DD_P_V_PRIMARY_VIDEO_FROM_MEMORY                     0x80023F81
#define NV_DD_YUV422_VIDEO_FROM_MEMORY                          0x80023F90
#define NV_DD_P_V_YUV422_VIDEO_FROM_MEMORY                      0x80023F91
#define NV_DD_VIDEO_OVERLAY                                     0x80023F92
#define NV_DD_VIDEO_LUT_CURSOR_DAC                              0x80023F93
#define NV_DD_VIDEO_LUT_CURSOR_DAC_2                            0x80023F94
#define NV_DD_VIDEO_LUT_CURSOR_DAC_3                            0x80023F95
#define NV_DD_VIDEO_LUT_CURSOR_DAC_4                            0x80023F96
#define NV_DD_VIDEO_SCALER                                      0x80023FA0
#define NV_DD_P_V_VIDEO_SCALER                                  0x80023FA1
#define NV_DD_VIDEO_COLOR_KEY                                   0x80023FB0
#define NV_DD_P_V_VIDEO_COLOR_KEY                               0x80023FB1
#define NV_DD_SHARED_VIDEO_COLORMAP                             0x80023FC0
#define NV_DD_P_V_SHARED_VIDEO_COLORMAP                         0x80023FC1

#define NV_DD_SYSTEM_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT            0x80023FD0
#define NV_DD_SYSTEM_MEMORY_U_TO_VIDEO_MEMORY_FORMAT            0x80023FD1
#define NV_DD_SYSTEM_MEMORY_V_TO_VIDEO_MEMORY_FORMAT            0x80023FD2
#define NV_DD_SYSTEM_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT           0x80023FD3
#define NV_DD_VIDEO_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT             0x80023FE0
#define NV_DD_VIDEO_MEMORY_U_TO_VIDEO_MEMORY_FORMAT             0x80023FE1
#define NV_DD_VIDEO_MEMORY_V_TO_VIDEO_MEMORY_FORMAT             0x80023FE2
#define NV_DD_VIDEO_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT            0x80023FE3
#define NV_DD_VIDEO_SINK                                        0x80023FF0
#define NV_DD_CONTEXT_BETA                                      0x80023FF1
#define NV_DD_CONTEXT_BETA4                                     0x80023FF2
#define NV_DD_PRIMARY_SURFACE                                   0x80024000
#define NV_DD_SRC_SURFACE                                       0x80024001
#define NV_DD_IMAGE_SOLID                                       0x80024003
#define NV_DD_RENDER_RECT_AND_TEXT                              0x80024004
#define NV_DD_RENDER_SOLID_RECTANGLE                            0x80024005

// object handle definitions for the new architure
// values start after DMA pushbuf id's
#define DD_CLIENT_OBJECT_HANDLE                 0x000C0002
#ifndef NVD3D
#define DD_DEVICE_OBJECT_HANDLE                 0x000C0003
#else
//
// Use the same device handle as the DX6 driver.
//
#define DD_DEVICE_OBJECT_HANDLE                 0x00002002
#endif // #ifdef NVD3D
#define DD_PIO_CHANNEL_OBJECT_HANDLE            0x000C0004
#define DD_DMA_CHANNEL_OBJECT_HANDLE            0x000C0005
#define DD_FRAME_BUFFER_OBJECT_HANDLE           0x000C0006
#define DD_CURSOR_OBJECT_HANDLE                 0x000C0007
#define NV_DD_DDRAW_PIO_CHANNEL_OBJECT_HANDLE   0x000C0008
#define NV_AGP_PUSHBUF_OBJECT_HANDLE            0x000C0009
#define NV_SYS_PUSHBUF_OBJECT_HANDLE            0x000C000A
#define NV_NOTIFIERS_OBJECT_HANDLE              0x000C000B
#define NV_INDEXED_IMAGE_LUT_OBJECT_HANDLE      0x000C000C
#define NV_MEM_TO_MEM_BUFFER_OBJECT_HANDLE      0x000C000D
#define NV_CLUT_DATA_OBJECT_HANDLE              0x000C000E

//***************************************************************************
// Macros used to create NV objects via the IOCTLs.
//***************************************************************************
#define NV_CREATE_OBJECT_SETUP() \
    NvU32 createObjFail, createObjClass
#define NV_CREATE_OBJECT_INIT() createObjFail = 0
#define NV_CREATE_OBJECT_FAIL() createObjFail
#define NV_CREATE_OBJECT_CLASS() createObjClass

#define NV_CREATE_OBJECT_PIO1(CLASS1, OBJ) {                                 \
    NvU32 classes[] = {CLASS1};                                              \
    NvCreateObject(ppdev,FALSE, NULL, OBJ, &createObjClass, &createObjFail, 1, classes); \
}    

#define NV_CREATE_OBJECT_PIO2(CLASS1, CLASS2, OBJ) {                         \
    NvU32 classes[] = {CLASS1,CLASS2};                                       \
    NvCreateObject(ppdev,FALSE, NULL, OBJ, &createObjClass, &createObjFail, 2, classes); \
}    

#define NV_CREATE_OBJECT_PARM_PIO2(PARM, OBJ, CLASS1, CLASS2) {                             \
    NvU32 classes[] = {CLASS1,CLASS2};                                            \
    NvCreateObject(ppdev,FALSE, PARM, OBJ, &createObjClass, &createObjFail, 2, classes); \
}    

#define NV_CREATE_OBJECT_PARM_PIO3(PARM, OBJ, CLASS1, CLASS2, CLASS3) {                             \
    NvU32 classes[] = {CLASS1,CLASS2,CLASS3};                                            \
    NvCreateObject(ppdev,FALSE, PARM, OBJ, &createObjClass, &createObjFail, 3, classes); \
}    

#define NV_CREATE_DMA1(PARMS,OBJ,CLASS1) {                                          \
    NvU32 classes[] = {CLASS1};                                                     \
    NvCreateObject(ppdev,TRUE, PARMS, OBJ, &createObjClass, &createObjFail, 1, classes);    \
}
#define NV_CREATE_DMA2(PARMS,OBJ,CLASS1,CLASS2) {                                   \
    NvU32 classes[] = {CLASS1,CLASS2};                                              \
    NvCreateObject(ppdev,TRUE, PARMS, OBJ, &createObjClass, &createObjFail, 2, classes);    \
}
#define NV_CREATE_DMA3(PARMS,OBJ,CLASS1,CLASS2,CLASS3) {                            \
    NvU32 classes[] = {CLASS1,CLASS2,CLASS3};                                       \
    NvCreateObject(ppdev,TRUE, PARMS, OBJ, &createObjClass, &createObjFail, 3, classes);    \
}
#define NV_CREATE_DMA4(PARMS,OBJ,CLASS1,CLASS2,CLASS3,CLASS4) {                     \
    NvU32 classes[] = {CLASS1,CLASS2,CLASS3,CLASS4};                                \
    NvCreateObject(ppdev,TRUE, PARMS, OBJ, &createObjClass, &createObjFail, 4, classes);    \
}
#define NV_CREATE_DMA5(PARMS,OBJ,CLASS1,CLASS2,CLASS3,CLASS4,CLASS5) {              \
    NvU32 classes[] = {CLASS1,CLASS2,CLASS3,CLASS4,CLASS5};                         \
    NvCreateObject(ppdev,TRUE, PARMS, OBJ, &createObjClass, &createObjFail, 5, classes);    \
}

#define NV_CREATE_OBJECT_DMA1(OBJ,CLASS1) \
        NV_CREATE_DMA1(NULL,OBJ,CLASS1);
#define NV_CREATE_OBJECT_DMA2(OBJ,CLASS1,CLASS2) \
        NV_CREATE_DMA2(NULL,OBJ,CLASS1,CLASS2);
#define NV_CREATE_OBJECT_DMA3(OBJ,CLASS1,CLASS2,CLASS3) \
        NV_CREATE_DMA3(NULL,OBJ,CLASS1,CLASS2,CLASS3);
#define NV_CREATE_OBJECT_DMA4(OBJ,CLASS1,CLASS2,CLASS3,CLASS4) \
        NV_CREATE_DMA4(NULL,OBJ,CLASS1,CLASS2,CLASS3,CLASS4);
#define NV_CREATE_OBJECT_DMA5(OBJ,CLASS1,CLASS2,CLASS3,CLASS4,CLASS5) \
        NV_CREATE_DMA5(NULL,OBJ,CLASS1,CLASS2,CLASS3,CLASS4,CLASS5);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\nvrmcomm.h ===
// header file for nvrmcomm.c

BOOL NvRmOpen();
BOOL NvRmClose();
BOOL NvRmIoControl(PVIDEO_REQUEST_PACKET RequestPacket);
BOOL NvrmIoctl(PVIDEO_REQUEST_PACKET RequestPacket);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\nvrmcomm.c ===
// this file contans the functions that implement display driver to RM comm

#include <ntddk.h>
#include <windef.h>
#undef WIN32
//#define NTMINIPORT
#include <nvos.h>
#include <nvntioctl.h>

typedef LONG VP_STATUS;
typedef struct _STATUS_BLOCK {
    VP_STATUS Status;
    ULONG Information;
} STATUS_BLOCK, *PSTATUS_BLOCK;
typedef struct _VIDEO_REQUEST_PACKET {
    ULONG IoControlCode;
    PSTATUS_BLOCK StatusBlock;
    PVOID InputBuffer;
    ULONG InputBufferLength;
    PVOID OutputBuffer;
    ULONG OutputBufferLength;
} VIDEO_REQUEST_PACKET, *PVIDEO_REQUEST_PACKET;

PFILE_OBJECT pRmFileObject;
PDEVICE_OBJECT pRmDeviceObject;

// for the new interface:
NVDESCRIPTOR fdNv;

BOOL NvRmOpen()
{
	NTSTATUS ntStatus = STATUS_SUCCESS;
	UNICODE_STRING rmUnicodeString;
	pRmFileObject = NULL;
	pRmDeviceObject = NULL;

	// open the resource manager
	//RtlInitUnicodeString(&rmUnicodeString, L"\\Device\\Nvrm");
	RtlInitUnicodeString(&rmUnicodeString, NVRM_NAME_STRING);
	ntStatus = IoGetDeviceObjectPointer(
		&rmUnicodeString,
	 	FILE_ALL_ACCESS,
		&pRmFileObject,
		&pRmDeviceObject
	);
	if (NT_SUCCESS(ntStatus))
	{
		ntStatus = ObReferenceObjectByPointer(
			pRmDeviceObject,
			FILE_ALL_ACCESS,
			NULL,
			KernelMode
		);
	}

	// for the new interface
	fdNv.pFileObject = pRmFileObject;
	fdNv.pDeviceObject = pRmDeviceObject;

	return (NT_SUCCESS(ntStatus)) ? TRUE : FALSE;

} // end of NvRmOpen()

BOOL NvRmClose()
{
	// close the RM by dereferencing both the device and file objects
	if (pRmDeviceObject)
		ObDereferenceObject(pRmDeviceObject);
	if (pRmFileObject)
		ObDereferenceObject(pRmFileObject);

	return TRUE;

} // end of NvRmClose()

BOOL NvRmIoControl(PVIDEO_REQUEST_PACKET RequestPacket)
{
    //PSTATUS_BLOCK StatusBlock;
	IO_STATUS_BLOCK status;
	PIRP pRmIrp;
	
	pRmIrp = IoBuildDeviceIoControlRequest(
		RequestPacket->IoControlCode,
		pRmDeviceObject,
		(PVOID)(*(DWORD *)(RequestPacket->InputBuffer)),
		RequestPacket->OutputBufferLength,
		(PVOID)(*(DWORD *)(RequestPacket->InputBuffer)),
		RequestPacket->OutputBufferLength,
		FALSE,
		NULL,
		&status
	);
	if (pRmIrp)
	{
		IoCallDriver(
			pRmDeviceObject,
			pRmIrp
		);
	}

	return TRUE;

} // end of NvRmIoControl()

BOOL NvrmIoctl(PVIDEO_REQUEST_PACKET RequestPacket)
{
    switch (RequestPacket->IoControlCode)
	{
	    case NV3_IOCTL_ALLOC_CHANNEL_DMA:
			Nv3AllocChannelDma(fdNv, (*(NVOS07_PARAMETERS **)(RequestPacket->InputBuffer)));
			break;

	    case NV3_IOCTL_DMA_FLOW_CONTROL:
			Nv3DmaFlowControl(fdNv, (*(NVOS08_PARAMETERS **)(RequestPacket->InputBuffer)));
			break;

		default:
			return FALSE;
	}
	return TRUE;

} // end of NvRmIoctl()


// end of nvrmcomm.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\nvsysmem.c ===
//******************************************************************************
//
// Copyright (c) 1992  Microsoft Corporation
//
// Module Name:
//
//     NVSYSMEM.C
//
// Abstract:
//
//     This is a few utility routines that map memory.
//
// Environment:
//
//     kernel mode only
//
// Notes:
//
// Revision History:
//
//******************************************************************************

//******************************************************************************
//
// Copyright (c) 1996,1997,1998  NVidia Corporation. All Rights Reserved
//
//******************************************************************************

#include <ntddk.h>
#include <windef.h>
// jsw...
//#undef WIN32

#include "nvos.h"
#include "dspioctl.h"

// polymorphic type stubs for NT4
#if (_WIN32_WINNT < 0x0500)
#define SIZE_T ULONG
#define ULONG_PTR ULONG
#endif // _WIN32_WINNT < 0x0500

// TO DO: temporary constant until a better place is found (from nvgfx.h)
#define ADDR_SPACE_IO           0x00
#define ADDR_SPACE_MEM          0x01
#define MEMORY_MAPPED_IO        0x00

// Taken from video.h
//
// Debugging statements. This will remove all the debug information from the
// "free" version.
//

#if DBG
#define VideoDebugPrint(arg) VideoPortDebugPrint arg
#else
#define VideoDebugPrint(arg)
#endif

VOID
VideoPortDebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    );

static VOID *mapToUserSpace(int addrSpace, PHYSICAL_ADDRESS addr, int bytes);

//******************************************************************************
//
// Function: NVLockdownMemory()
//
// Routine Description:
//
//     Create MDL and lock down the pages for a user supplied memory address.
//
//     Support function for IOCTL_VIDEO_LOCK_DOWN_MEMORY.
//
// Arguments:
//
//     pLockdownMemory - Pointer to description of user memory to be locked down.
//
// Return Value:
//
//     None.
//
//******************************************************************************

void
NvLockdownMemory(
NV_LOCK_DOWN_MEMORY *pLockdownMemory)
{
    MDL *pMdl;
    PHYSICAL_ADDRESS pa;
    NTSTATUS status;
    PVOID systemAddress;
    ULONG offset;

    pLockdownMemory->pMdl = (PVOID)NULL;

    pMdl = IoAllocateMdl(PAGE_ALIGN(pLockdownMemory->virtualAddress),
                         pLockdownMemory->byteLength, // PAGE_SIZE, 
                         FALSE,
                         FALSE, 
                         NULL);

    if (pMdl)
    {
        try 
        {
            if ( (pMdl->MdlFlags & MDL_PAGES_LOCKED)==0)   
                MmProbeAndLockPages(pMdl, KernelMode, IoModifyAccess);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            status = GetExceptionCode();
            VideoDebugPrint((0, "Exception status = 0x%lx\n", (ULONG)status));
            IoFreeMdl (pMdl);
            pMdl = NULL;
        }

        pLockdownMemory->pMdl = (PVOID)pMdl;

        VideoDebugPrint((0, "pMdl = 0x%p\n", pMdl));
    }
}

//******************************************************************************
//
// Function: NVUnlockMemory()
//
// Routine Description:
//
//     Unlock memory and free associated MDL.
//
//     Support function for IOCTL_VIDEO_UNLOCK_MEMORY.
//
// Arguments:
//
//     pUnlockMemory - Pointer to description of user memory to be unlocked.
//
// Return Value:
//
//     None.
//
//******************************************************************************

void
NvUnlockMemory(
NV_UNLOCK_MEMORY *pUnlockMemory)
{
    NTSTATUS status;
    MDL *pMdl;

    pMdl = (MDL *)pUnlockMemory->pMdl;
    if (pMdl)
        {
        try 
            {
                MmUnlockPages(pMdl);
                IoFreeMdl(pMdl);
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                status = GetExceptionCode();
                VideoDebugPrint((0, "Exception status = 0x%lx\n", (ULONG)status));
            }
        }
}

//******************************************************************************
//
// Function: NVSystemMemoryShare()
//
// Routine Description:
//
//     Share a user process memory address with the display driver.  Lock down the
//     memory and then get a system address for it.  Fill in system memory structure
//     with new system memory address for later use by display driver.
//
//     Support function for IOCTL_VIDEO_SYSMEM_SHARE_MEMORY.
//
// Arguments:
//
//     pSysmemShareMemory - Pointer to description of user memory.
//
// Return Value:
//
//     None.
//
//******************************************************************************

void
NvSystemMemoryShare(
NV_SYSMEM_SHARE_MEMORY *pSysmemShareMemory)
{
    MDL *pSystemMdl;
    PHYSICAL_ADDRESS pa;
    NTSTATUS status;
    PVOID systemAddress;
    ULONG_PTR offset;

    pSysmemShareMemory->pSystemMdl = (PVOID)NULL;
    pSysmemShareMemory->physicalAddress = 0;

    pSystemMdl = IoAllocateMdl(PAGE_ALIGN(pSysmemShareMemory->userVirtualAddress),
                               pSysmemShareMemory->byteLength,
                               FALSE,
                               FALSE, 
                               NULL);

    if (pSystemMdl)
    {
        try 
        {
            if ( (pSystemMdl->MdlFlags & MDL_PAGES_LOCKED)==0)   
                MmProbeAndLockPages(pSystemMdl, KernelMode, IoModifyAccess);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            status = GetExceptionCode();
            VideoDebugPrint((0, "Exception status = 0x%lx\n", (ULONG)status));
        }

        pSysmemShareMemory->pSystemMdl = (PVOID)pSystemMdl;
        pa = MmGetPhysicalAddress((PVOID)(PAGE_ALIGN(pSysmemShareMemory->userVirtualAddress)));

        offset = (ULONG_PTR)pSysmemShareMemory->userVirtualAddress & (PAGE_SIZE - 1);

        systemAddress = MmGetSystemAddressForMdl(pSystemMdl);

        pSysmemShareMemory->ddVirtualAddress = (PUCHAR)systemAddress + offset;
        pSysmemShareMemory->physicalAddress = pa.LowPart;

        VideoDebugPrint((0, "pSystemMdl = 0x%p\n", pSystemMdl));
        VideoDebugPrint((0, "physicalAddress = 0x%p\n", pSysmemShareMemory->physicalAddress));
    }
}


//******************************************************************************
//
// Function: NVSystemMemoryUnShare()
//
// Routine Description:
//
//     Unmap a previous shared address.  Unlock the pages.
//
//     Support function for IOCTL_VIDEO_SYSMEM_UNSHARE_MEMORY.
//
// Arguments:
//
//     pSysmemShareMemory - Pointer to description of user memory.
//
// Return Value:
//
//     None.
//
//******************************************************************************

void
NvSystemMemoryUnShare(
NV_SYSMEM_SHARE_MEMORY *pSysmemShareMemory)
{
    if (pSysmemShareMemory && pSysmemShareMemory->pSystemMdl)
    {
        MDL *pSystemMdl = (MDL *)pSysmemShareMemory->pSystemMdl;

        VideoDebugPrint((0, "pSystemMdl = 0x%p\n", pSystemMdl));
        VideoDebugPrint((0, "physicalAddress = 0x%p\n", pSysmemShareMemory->physicalAddress));

        MmUnlockPages(pSystemMdl);
        IoFreeMdl(pSystemMdl);

        pSysmemShareMemory->pSystemMdl = (PVOID)NULL;
    }
}

//******************************************************************************
//
// Function: NVMapIntoUserSpace()
//
// Routine Description:
//
//     Map a give memory address into user address space.  The incoming address
//     should be a kernel mode address.  
//
//     Support function for IOCTL_VIDEO_MAP_TO_USER.
//
// Arguments:
//
//     pSysmemShareMemory - Pointer to description of user memory.
//
// Return Value:
//
//     None.
//
//******************************************************************************

void
NvMapIntoUserSpace(
NV_SYSMEM_SHARE_MEMORY *pSysmemShareMemory)
{
    PHYSICAL_ADDRESS pa;
    MDL *pSystemMdl;
    NTSTATUS status;

    // we use MmMapLockedPages to map the requested area into user space.
    //
    // THIS IS THE RECOMMENDED WAY TO DO THIS AS DESCRIBED IN 
    // Q191/8/40 Share memory between UserMode and Kernel Mode
    //
    // if we ran NT4 less SP3 with a not page-aligned ddVirtualAddress, we may experience
    // different results. However all mem allocated by the display driver, is aligned
    // to a 32k boundary. So this is not problem so far.
    ASSERT(PAGE_ALIGN(pSysmemShareMemory->ddVirtualAddress) == pSysmemShareMemory->ddVirtualAddress);

    pSystemMdl = pSysmemShareMemory->pSystemMdl;

    if (!pSysmemShareMemory->bDontModifyMDL)
    {
        ASSERT(!pSystemMdl);
        pSysmemShareMemory->physicalAddress = 0;

        pSystemMdl = IoAllocateMdl(PAGE_ALIGN(pSysmemShareMemory->ddVirtualAddress),
                                pSysmemShareMemory->byteLength,
                                FALSE,
                                FALSE, 
                                NULL);
    }

    if (pSystemMdl != NULL)
    {
        try 
        {
            if ( (pSystemMdl->MdlFlags & MDL_PAGES_LOCKED)==0)   
                MmProbeAndLockPages(pSystemMdl, KernelMode, IoModifyAccess);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            status = GetExceptionCode();
            VideoDebugPrint((0, "Exception status = 0x%lx\n", (ULONG)status));
        }

        //
        // Map display driver address into the address space of the current thread.
        //
        pa = MmGetPhysicalAddress((PVOID)(PAGE_ALIGN(pSysmemShareMemory->ddVirtualAddress)));
#if (_WIN32_WINNT >= 0x0500)
        // this method is used to map display driver allocated memory into user space -> MMCached
        // if this methods fails, the display driver has to handle this, no BUGCHECK
        // if we can map the pages and are within a modeswitch ... -> high prio
        // removes driver verifier message
        pSysmemShareMemory->userVirtualAddress = MmMapLockedPagesSpecifyCache(pSystemMdl, UserMode, MmCached, NULL, FALSE, HighPagePriority);
#else
        pSysmemShareMemory->userVirtualAddress = MmMapLockedPages(pSystemMdl, UserMode);
#endif
        pSysmemShareMemory->physicalAddress = pa.LowPart;
        pSysmemShareMemory->pSystemMdl = (PVOID)pSystemMdl;

        VideoDebugPrint((0, "mapped pSystemMdl = 0x%p\n", pSystemMdl));
        VideoDebugPrint((0, "mapped va = 0x%p\n", pSysmemShareMemory->userVirtualAddress));
    }
}

//******************************************************************************
//
// Function: NVUnmapFromUserSpace()
//
// Routine Description:
//
//     Unmap a previously mapped user address.
//
//     Support function for IOCTL_VIDEO_UNMAP_FROM_USER.
//
// Arguments:
//
//     pSysmemShareMemory - Pointer to description of user memory.
//
// Return Value:
//
//     None.
//
//******************************************************************************

void
NvUnmapFromUserSpace(
NV_SYSMEM_SHARE_MEMORY *pSysmemShareMemory)
{
    NTSTATUS status;

    if (pSysmemShareMemory)
    {
        MDL *pSystemMdl = (MDL *)pSysmemShareMemory->pSystemMdl;

        VideoDebugPrint((0, "unmap pSystemMdl = 0x%p\n", pSystemMdl));
        VideoDebugPrint((0, "unmap va = 0x%p\n", pSysmemShareMemory->userVirtualAddress));

        // *remove usermode mapping*
        // if the usermode process crashed, this mapping does not exist anymore,
        // because windows already removed it. The code is protected against this.
        try 
        {
            ASSERT(pSystemMdl);
            if (MmIsAddressValid(pSysmemShareMemory->userVirtualAddress))
            {
                // unfortunately the check above does not gurantee that the address is valid
                // so try/exect will catch this.
                MmUnmapLockedPages(pSysmemShareMemory->userVirtualAddress, pSystemMdl);
            }
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            status = GetExceptionCode();
            VideoDebugPrint((0, "Exception status = 0x%lx\n", (ULONG)status));
        }
        if (!pSysmemShareMemory->bDontModifyMDL)
        {
            try 
                {
                    ASSERT(pSystemMdl);
                    MmUnlockPages(pSystemMdl);
                    IoFreeMdl(pSystemMdl);
                }
            except(EXCEPTION_EXECUTE_HANDLER)
                {
                    status = GetExceptionCode();
                    VideoDebugPrint((0, "Exception status = 0x%lx\n", (ULONG)status));
                }
            pSysmemShareMemory->pSystemMdl = (PVOID)NULL;
        }
    }
}

//******************************************************************************
//
// Function: NVMapPhysIntoUserSpace()
//
// Routine Description:
//
//     Map a physical address and length into a user address space.
//
//     Support function for IOCTL_VIDEO_MAP_NV_PFIFO_USER.
//
// Arguments:
//
//     pa - physical address
//     byteLength - bytes in mapping
//     lowPart - 32-bit return address
//
// Return Value:
//
//     None.
//
//******************************************************************************

void
NVMapPhysIntoUserSpace(
PHYSICAL_ADDRESS pa,
LONG byteLength,
PVOID *userVirtualAddress)
{
    //
    // Map physical address into the address space of the current thread.
    //
    *userVirtualAddress = mapToUserSpace(ADDR_SPACE_MEM, pa, byteLength);
}

//******************************************************************************
//
// Function: NVUnmapPhysFromUserSpace()
//
// Routine Description:
//
//     Unmap a previously mapped user address.
//
//     Support function for IOCTL_VIDEO_UNMAP_NV_PFIFO_USER and
//                          IOCTL_VIDEO_UNMAP_NV_PBUS_USER
//
// Arguments:
//
//     pSysmemShareMemory - Pointer to description of user memory.
//
// Return Value:
//
//     None.
//
//******************************************************************************

void
NvUnmapPhysFromUserSpace(
NV_SYSMEM_SHARE_MEMORY *pSysmemShareMemory)
{
    NTSTATUS status;

    if (pSysmemShareMemory)
    {
        MDL *pSystemMdl = (MDL *)pSysmemShareMemory->pSystemMdl;

        VideoDebugPrint((0, "unmap physical pSystemMdl = 0x%p\n", pSystemMdl));
        VideoDebugPrint((0, "unmap physical va = 0x%p\n", pSysmemShareMemory->userVirtualAddress));

        try 
        {
            ZwUnmapViewOfSection((HANDLE)-1,          // current process handle
                                  (PVOID)pSysmemShareMemory->userVirtualAddress);
            if (!pSysmemShareMemory->bDontModifyMDL)
            {
                ASSERT(pSystemMdl);
                MmUnlockPages(pSystemMdl);
                IoFreeMdl(pSystemMdl);
            }
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            status = GetExceptionCode();
            VideoDebugPrint((0, "Exception status = 0x%lx\n", (ULONG)status));
        }

        pSysmemShareMemory->pSystemMdl = (PVOID)NULL;
    }
}

//******************************************************************************
//
// Function: mapToUserSpace()
//
// Routine Description:
//
//     Map a give memory address into user address space.  The incoming address
//     should be a kernel mode address.
//
//     Support function for IOCTL_VIDEO_MAP_TO_USER.
//
// Arguments:
//
//     pSysmemShareMemory - Pointer to description of user memory.
//
// Return Value:
//
//     None.
//
//******************************************************************************

static VOID *
mapToUserSpace(
    int addrSpace, 
    PHYSICAL_ADDRESS addr, 
    int bytes)
{
    UNICODE_STRING     physicalMemoryUnicodeString;
    OBJECT_ATTRIBUTES  objectAttributes;
    HANDLE             physicalMemoryHandle  = NULL;
    void              *physicalMemorySection = NULL;
    void              *virtualAddress;
    PHYSICAL_ADDRESS   viewBase; 
    SIZE_T             viewSize;
    ULONG              length;
    NTSTATUS ntStatus;

    RtlInitUnicodeString(&physicalMemoryUnicodeString, 
        L"\\Device\\PhysicalMemory"); 
    InitializeObjectAttributes(&objectAttributes, 
        &physicalMemoryUnicodeString, 
        OBJ_CASE_INSENSITIVE, 
        (HANDLE) NULL, 
        (PSECURITY_DESCRIPTOR) NULL); 
 
    ntStatus = ZwOpenSection(&physicalMemoryHandle, 
        SECTION_ALL_ACCESS, &objectAttributes); 
 
    if (!NT_SUCCESS(ntStatus)) { 
        VideoDebugPrint((0, "NV: mapToUser\n"));
        return NULL;
    }

    ntStatus = ObReferenceObjectByHandle(physicalMemoryHandle, 
        SECTION_ALL_ACCESS, (POBJECT_TYPE) NULL, 
        KernelMode, &physicalMemorySection, 
        (POBJECT_HANDLE_INFORMATION) NULL); 
 
    if (!NT_SUCCESS(ntStatus)) { 
        VideoDebugPrint((0, "NV: ObjREferenceObjectByHandle\n"));
        ZwClose(physicalMemoryHandle); 
        return NULL;
    } 

    length = bytes;
    // 
    // initialize view base that will receive the physical mapped 
    // address after the MapViewOfSection call. 
    // 
    viewBase = addr; 
    // 
    // Let ZwMapViewOfSection pick an address 
    // 
    virtualAddress = NULL;
    // 
    // Map the section 
    // 
    viewSize = length;
    ntStatus = ZwMapViewOfSection(
        physicalMemoryHandle, // section handle
        (HANDLE) -1,          // current process handle
        &virtualAddress,      // base address
        0L,                   // zero bits
        length,               // commit size
        &viewBase,            // section offset
        &viewSize,            // view size
        ViewUnmap,            // unmap for children processes
        0,                    // allocation type
        ((addrSpace == ADDR_SPACE_IO) ? (PAGE_READWRITE | PAGE_NOCACHE)
         : PAGE_READWRITE));  // page protection
 
    if (!NT_SUCCESS(ntStatus)) {
        VideoDebugPrint((0, "NV: ZwMapViewOfSection\n"));
        ZwClose(physicalMemoryHandle); 
        return NULL;
    }

    // 
    // Mapping the section above rounded the physical address down to the 
    // nearest 64 K boundary. Now return a virtual address that sits where 
    // we wnat by adding in the offset from the beginning of the section. 
    // 
    (PUCHAR)virtualAddress += addr.LowPart - viewBase.LowPart; 

    ZwClose(physicalMemoryHandle); 

    return virtualAddress;
} // end of mapToUser() 

ULONG NVObReferenceObjectByHandle(HANDLE hRing3, HANDLE* hRing0)
{
    return ObReferenceObjectByHandle(hRing3, 0, NULL, KernelMode, hRing0, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\nv_ref.h ===
//
// (C) Copyright NVIDIA Corporation Inc., 1995,1996. All rights reserved.
//
/***************************************************************************\
*                                                                           *
*               Hardware Reference Manual extracted defines.                *
*                                                                           *
\***************************************************************************/
#ifndef _NV_REF_H_

#ifdef NV1_HW
//
// VGA hardware is supported on NV1
//
#define NV_VGA	1
//#include <nv1b_ref.h>
#include <nv1c_ref.h>
#endif
#ifdef NV2_HW
//
// NV2_REF.H Plus (defines which should be in NV2_REF.H)
// These defines are specific to NV2
//
#define NV_PCART_NVM_TRANSFER_SIZE_MAX	0x1000

#define NV_PGRAPH_CTX_SWITCH_COLOR_BUFFER_R5G5B5	0
#define NV_PGRAPH_CTX_SWITCH_COLOR_BUFFER_R8G8B8	1
#define NV_PGRAPH_CTX_SWITCH_COLOR_BUFFER_R10G10B10	2
#define NV_PGRAPH_CTX_SWITCH_COLOR_BUFFER_Y8	    3
#define NV_PGRAPH_CTX_SWITCH_COLOR_BUFFER_Y16	    4

//
// VGA hardware is not supported on NV2
//
#include <nv2_ref.h>
#endif

#ifdef NV3_HW
//
// VGA hardware is supported on NV1
//
#define NV_VGA	1
#include <nv3_ref.h>

#define NV_PFIFO_CACHE1_SIZE								  32
#else 
//
// NV2_REF.H Plus (defines which should be in NV2_REF.H)
// These defines are common to both NV1 and NV2
//
#define NV_PGRAPH_TRAPPED_ADDR_CLASS                          22:16
#define NV_PFIFO_CACHE1_SIZE								  32
#endif // NV3_HW


//*****************************************************************************
// 
// NV1/NV3/NV4/ conventions....
//
//   This modeset code was originally designed to be compiled for each
//   version of the chip (NV1/NV3/NV4).  However, this miniport was designed
//   to work with ALL versions of the chip.  That is, the original modeset
//   code had to be compiled for each chip.  But since this miniport
//   determines which chip it's running on at RUN time (i.e. we don't
//   compile several versions of the miniport) we need to use the following 
//   convention:
//
//      MODESET.C SHOULD ONLY CONTAIN NV3 SPECIFIC CODE
//      (OR CODE THAT HAS *NOT* CHANGED ACROSS CHIPS) !!
//
//   Mainly because NV_REF.H already includes NV3_REF.H.
//   For code which is different from NV3, that code
//   should exist separately in NV4.C/NV5.C/...etc...
//   
//   We'll follow the convention that the Miniport decides at runtime
//   which chip it's running on (i.e. only ONE miniport instead of 
//   compiling several versions for each type of chip).  
//
//*****************************************************************************


#ifdef BM_BUG
//
// There is a bug in the RevB hardware when bus mastering on certain chip sets.
// These macros enable & disable bus mastering around certain registers that
// could be corrupted by the bug.
//
extern unsigned long pciConfigMasterEnable;
extern unsigned long pciConfigMasterDisable;
extern unsigned long pciBusMasterBug;
#define BUG_BM_OFF()                                                        \
    if (pciBusMasterBug){                                                   \
        REG_WR32(NV_PBUS_PCI_NV_1, pciConfigMasterDisable);                 \
    }
#define BUG_BM_ON()                                                         \
    if (pciBusMasterBug){                                                   \
        REG_WR32(NV_PBUS_PCI_NV_1, pciConfigMasterEnable);                  \
    }
#else
#define BUG_BM_OFF()
#define BUG_BM_ON()
#endif // BM_BUG
#endif // _NV_REF_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\osapiNT.c ===
/*
    FILE:   osapi.c
    DATE:   4/8/99

    This file holds code for functions that are called back to by
    the generic modeset code.
*/

#include "cmntypes.h"
#include "modeext.h"
#include "modeset.h"
#include "debug.h"
#include "nvreg.h"
#include "restime.h"
#include "osapi.h"
#include "utils.h"
#include "edid.h"
#include "gtfmath.h"
#include "dmt.h"

#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"
#include "ntddvdeo.h"
#include "video.h"
#include "nv.h"

// Bring this in to get the flat panel structs
#include "nvcm.h"
#include "cmdcnst.h"
#include "monitor.h"
#include "vesadata.h"
#include "nvMultiMon.h"

extern VP_STATUS NVGetRegistryTwinviewInfo (
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    NVTWINVIEWDATA      *pTwinviewInfo
    );

extern BOOLEAN   TwinViewDataOK(PHW_DEVICE_EXTENSION hwDeviceExtension, NVTWINVIEWDATA *pData);
VOID SetTimingOverRide(PHW_DEVICE_EXTENSION HwDeviceExtension);
ULONG GetBestResolution(PHW_DEVICE_EXTENSION HwDeviceExtension, ULONG ulEDIDIndex, ULONG ulHead, ULONG ulDeviceMask, MODE_ENTRY *pBestMode);
extern int CFUNC EdidFindLargestEdidMode (LPCHAR lpEdidBuffer, ULONG dwEdidSize,LPMODEINFO lpModeInfo);
extern VOID EnterFPCode(VOID *pSave, VOID *pMutex);
extern VOID ExitFPCode(VOID *pSave, VOID *pMutex);
extern ULONG GetTimingDacCommonModesetCode(PHW_DEVICE_EXTENSION HwDeviceExtension, HEAD_RESOLUTION_INFO *pResolution, DAC_TIMING_VALUES * pTimingInfo);

extern VP_STATUS
NVRegistryCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );

extern VP_STATUS
NVReadMonitorTimingModeCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );

//******************************************************************************
//
// External Function Declarations
//
//******************************************************************************

extern BOOL RmConfigGetExKernel
(
    U032 deviceReference,
    U032 index,
    VOID* pParms,
    U032 parmSize
);

extern BOOL RmConfigGetKernel (U032, U032, U032*);


// GK UNDO
float __fltused = 0.0;

// Hack. See the '4' below. Thats because the modeentry structure has 4 ULONG fields in it.
// Later we should dynamically malloc it. For now, we create a static global array.                                                                                                     
#define MAX_VALID_MODE_TABLE_DATA_WORDS_MODESET (MAX_STRING_REGISTRY_LINES * MAX_VALID_MODE_REFRESH_RATES * 4)

ULONG glpModeEntry[MAX_VALID_MODE_TABLE_DATA_WORDS_MODESET];


/*
    GetMasterModeList

    This routine returns a ptr to a an array of MODEENTRY
    structures which describe the list of available modes for
    the board specified. This routine needs to ALWAYS return
    some mode list. If you have to just return a list of safe
    modes like 640,480,8,60Hz.

    You can alloc memory for the mode list because you will be
    given a chance to free the ptr later.
*/
LPMODEENTRY CFUNC
GetMasterModeList (LPDISPDATA lpBoardData)
{
    PHW_DEVICE_EXTENSION hwDeviceExtension;
    ULONG NumRegModes;
    PMODE_ENTRY SrcModeEntry;
    LPMODEENTRY DstModeEntry;
    LPMODEENTRY pRet;
    ULONG i;

    hwDeviceExtension = (PHW_DEVICE_EXTENSION)lpBoardData->dwContext1;
    NumRegModes = hwDeviceExtension->NumRegistryModes;
    SrcModeEntry = (PMODE_ENTRY)&(hwDeviceExtension->ValidModeTable[0]);
    DstModeEntry = (LPMODEENTRY)&glpModeEntry[0];

    
    //Copy the registry mode list into the modeset list.
    for (i=0; i < NumRegModes; i++)
    {
        if (SrcModeEntry->ValidMode)
        {
            // Do not pass spanning resolutions. Limit only to single resolutions.
            if (!MULTIMON_MODE(SrcModeEntry->Width, SrcModeEntry->Height))
            {
                DstModeEntry->dwXRes        = SrcModeEntry->Width;
                DstModeEntry->dwYRes        = SrcModeEntry->Height;
                DstModeEntry->dwBpp         = SrcModeEntry->Depth;
                DstModeEntry->dwRefreshRate = SrcModeEntry->RefreshRate;
                DstModeEntry++;
            }
        }
        SrcModeEntry++;
    }

    // The last entry needs to be zeroed out.
    DstModeEntry->dwXRes        = 0;
    DstModeEntry->dwYRes        = 0;
    DstModeEntry->dwBpp         = 0;
    DstModeEntry->dwRefreshRate = 0;

    // You can't return NULL -- this is just a template.
    pRet = (LPMODEENTRY)&glpModeEntry[0];
    return(pRet);
}


/*
    FreeMasterModeList

    This routine is called when the caller is done with the mode
    list it got earlier.
*/
int CFUNC
FreeMasterModeList (LPMODEENTRY lpModeList)
{
    return  (TRUE);
}

/*
    GetSafeModeList

    This routine just returns a few safe modes in the mode list.
    It always returns TRUE.
*/
int CFUNC GetSafeModeList (LPMODEENTRY lpModeList)
{
    return  (TRUE);
}


// Just in case we can't GlobalAlloc a list, we have a single entry one
// we can use here.
RESTIME     sRTList;

/*
    GetMasterRTList

    This routine returns a ptr to a an array of RESTIME
    structures which describe the list of R&T strings for
    the board specified. This routine needs to ALWAYS return
    some RT list. If you have to just return a blank list.

    You can alloc memory for the mode list because you will be
    given a chance to free the ptr later.
*/
LPRESTIME CFUNC
GetMasterRTList (LPDISPDATA lpBoardData)
{
    LPRESTIME   lpRTList;

    // Here is returning a blank list.
    lpRTList = &sRTList;
    lpRTList[0].dwXRes = 0;
    return  (lpRTList);
}


/*
    FreeMasterRTList

    This routine is called when the caller is done with the RTList.
*/
int CFUNC
FreeMasterRTList (LPRESTIME lpRTList)
{
    return  (TRUE);
}

/*
    GetTimingStandardOverride

    This routine gets any timing standard override for the board
    specified. It should return one of the constants defined in
    restime.h like DMTV_ID. A timing standard override is a
    timing standard that applies to all modes. Just something
    that the user might want to enforce.
*/
ULONG CFUNC
GetTimingStandardOverride (LPDISPDATA lpDispData)
{
    PHW_DEVICE_EXTENSION hwDeviceExtension;
    ULONG ulHead;
    
    hwDeviceExtension = (PHW_DEVICE_EXTENSION)lpDispData->dwContext1;
    ulHead = lpDispData->dwCRTCIndex;

    return(hwDeviceExtension->ulTimingOverrideTwinViewInfo[ulHead]);
    
}


/*
    Function:   GetPitchAndSize

    Purpose:    This routine returns the pitch for a given mode.

    Arguments:  lpDispData  - identifies the specific board that we
                              want the active display port for.
                dwXRes      - The X res in pixels for the mode
                              should be returned.
                dwBpp       - the bits per pixel for the mode

    Returns:    The pitch in bytes
*/

ULONG CFUNC
GetPitchAndSize (LPDISPDATA lpDispData, ULONG dwXRes, ULONG dwYRes, ULONG dwBpp, ULONG *pdwPitch, ULONG *pdwSize)
{
    PHW_DEVICE_EXTENSION hwDeviceExtension;
    NV_CFGEX_GET_SURFACE_DIMENSIONS_PARAMS nvPitch;
    ULONG PitchInBytes;

    hwDeviceExtension = (PHW_DEVICE_EXTENSION)lpDispData->dwContext1;

    nvPitch.Width = dwXRes;
    nvPitch.Height= dwYRes;
    nvPitch.Depth = dwBpp;

    RmConfigGetExKernel(hwDeviceExtension->DeviceReference, NV_CFGEX_GET_SURFACE_DIMENSIONS, &nvPitch, sizeof(NV_CFGEX_GET_SURFACE_DIMENSIONS_PARAMS));
    PitchInBytes = nvPitch.Pitch;

    *pdwPitch = nvPitch.Pitch;
    *pdwSize =  PitchInBytes * dwYRes;
            
    return(PitchInBytes);
}


/*
    Function:   GetMonitorInfRangeLimits

    Purpose:    This routine reads the "MaxResolution" key in the
                active monitor node in the registry to get the
                maximum resolution the monitor can do. It uses
                the maximum resolution itself (like "1600,1200")
                as another subkey under which is typically a
                monitor range limits string which looks like
                "30-95,60-120,-,+" where the first range is
                the horizontal limits inKHz and the second is
                the vertical range in hertz. The last two characters
                are horizontal and vertical sync polarities.
                This range limits string doesn't always exist.

    Arguments:
                lpDispData  - identifies the specific board that we
                              want the active display port for.
                lpML        - ptr to a monitor limits structure
                              that will be filled in with range
                              limits obtained or computed from
                              values stuffed in the registry
                              by the moitor .inf file.
                lpdwXRes    - ptr to a variable that will be set
                              to the maximum X-resolution found
                              for this monitor.
                lpdwYRes    - ptr to a variable that will be set
                              to the maximum Y-resolution found
                              for this monitor.

    Returns:    TRUE    then lpML, lpdwXRes, and lpdwYRes have been
                        filled in correctly.
                FALSE   then there was an error getting some value.
*/
int CFUNC
GetMonitorInfRangeLimits (
    LPDISPDATA      lpDispData,
    LPMONITORLIMITS lpML,
    ULONG           *lpdwXRes,
    ULONG           *lpdwYRes)
{
    return  (TRUE);
}


/*
    Function:   GetMonitorLimitMode

    Purpose:    This routine gets the mode which should be an
                upper bound for a monitor which has no edid and
                no .inf.

    Arguments:  lpDispData  - identifies the specific board that we
                              want the active display port for.
                lpModeInfo  - ptr to a place to store the limit mode

    Returns:    If this routine returns TRUE, then lpModeInfo was
                filled in with the limit mode. If this routine
                returns FALSE, then there is no limit mode.
*/
int CFUNC
GetMonitorLimitMode (LPDISPDATA lpDispData, LPMODEINFO lpModeInfo)
{
    return(FALSE);
}


/*
    Function:   GetAllowAllModesFlag

    Purpose:    WIN9X spacific function for testing only.
        This function get "AllowAllModes" registry key
        for specified DispData.

    Arguments:
                lpRegData  - identifies a specific board
    Returns:    "AllowAllModes" key value or FALSE.
*/
ULONG WINAPI GetAllowAllModesFlag(LPREGDATA lpRegData)
{
return(FALSE);
}


/*
    Function:   IsModeAcceptededByDriver

    Purpose:    This routine allows the display driver to perform any
                other restrictions on a potential mode that it wants to.
                This is the final step in the mode restriction. This
                routine has access to the output timing parameters
                so it can do all sorts of fun checking.

    Arguments:  lpDispData  - identifies the specific board that we
                              want the active display port for.
                lpModeOut   - the timing parameters for the mode
                              you may modify them in place if you
                              want them changed.
                lpEdidBuffer  ptr to the EDID
                dwEdidSize    size of the edid in bytes (0 if no edid)

    Returns:    TRUE    if this mode is allowed
                FALSE   if the mode should be rejected

                Note that it is possible to modify the timings in
                lpModeOut and still return TRUE. Your modified
                timings will be used. However, this capability
                should really only be used in exceptional cases.
                If there is some reason to be modifying timings,
                let's get it into the modeset dll rather than
                having the display driver under every OS do
                something special.
*/
ULONG CFUNC
IsModeAcceptedByDriver (LPDISPDATA lpDispData, LPMODEOUT lpModeOut,
                        LPCHAR lpEdidBuffer, ULONG dwEdidSize)
{
    return  (TRUE);
}


//
// First reads the "TwinViewInfo" registry to get the timing override.
// If there is no such registry entry, then reads the "DMTOVERRIDE" and "MonitorTiming" registry entries.
//
VOID SetTimingOverRide(PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    NVTWINVIEWDATA pInfo;
    ULONG ulHead;
    VP_STATUS status;
    PHW_DEVICE_EXTENSION hwDeviceExtension;
    ULONG i;

    hwDeviceExtension = HwDeviceExtension;

    //**************************************************************************
    // Check to see if VESA DMT monitor timings should be used
    //**************************************************************************
    hwDeviceExtension->bUseDMT = FALSE;
    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       L"DMTOVERRIDE",
                                       FALSE,
                                       NVRegistryCallback,
                                       &(hwDeviceExtension->bUseDMT));


    //**************************************************************************
    // Check to see if there is a GTF method requested by the user instead ( DMTOVERRIDE has priority)
    //**************************************************************************
    hwDeviceExtension->bUseGTF = FALSE;

    // Try and get some kind of monitor timing selection
    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                           L"MonitorTiming",
                                           FALSE,
                                           NVReadMonitorTimingModeCallback,
                                           &(hwDeviceExtension->bUseGTF));


    // The DMT overide has priority
    if(HwDeviceExtension->bUseDMT) {
        HwDeviceExtension->bUseGTF = FALSE;
    }

    
    status = NVGetRegistryTwinviewInfo(HwDeviceExtension, &pInfo);
    if (status == NO_ERROR)
    {
        // See if the twinview data is valid.
        if (TwinViewDataOK(HwDeviceExtension, &pInfo))
        {

            for (i=0; i < HwDeviceExtension->DeskTopInfo.ulNumberDacsOnBoard; i++)
            {
                ulHead = pInfo.dwDeviceDisplay[i];

                switch (pInfo.NVTWINVIEWUNION.nvtwdevdata[ulHead].dwTimingOverRide)
                {
                case TIMING_OVERRIDE_GTF:
                    VideoDebugPrint((5,"GetTimingStandardOverride(): Forced to use GTF\n"));
                    HwDeviceExtension->ulTimingOverrideTwinViewInfo[ulHead] = GTFV_ID;
                    break;
                case TIMING_OVERRIDE_DMT:
                    VideoDebugPrint((5,"GetTimingStandardOverride(): Forced to use DMT\n"));
                    HwDeviceExtension->ulTimingOverrideTwinViewInfo[ulHead] = DMTV_ID;
                    break;
                case TIMING_OVERRIDE_AUTO:
                    HwDeviceExtension->ulTimingOverrideTwinViewInfo[ulHead] = NONE_ID;
                    break;
                default:
                    VideoDebugPrint((5,"Oops! GetTimingStandardOverride(): Invalid TimingOverride from registry: 0x%x\n",
                                     pInfo.NVTWINVIEWUNION.nvtwdevdata[ulHead].dwTimingOverRide));
                    HwDeviceExtension->ulTimingOverrideTwinViewInfo[ulHead] = NONE_ID;
                    break;
                }
            }
            return;
        }
    }

    for (i=0; i < NV_NO_DACS; i++)
    {

        // TwinViewInfo registry entry not found.
        // So look at the old registry entries.
        // Note: Not sure if we should honor the old registry entries. Check with Peter.
        if (hwDeviceExtension->bUseGTF)
        {
            VideoDebugPrint((5,"GetTimingStandardOverride(): Forced to use GTF\n"));
            HwDeviceExtension->ulTimingOverrideTwinViewInfo[i] = GTFV_ID;
        }
        else if (hwDeviceExtension->bUseDMT)
        {
            VideoDebugPrint((5,"GetTimingStandardOverride(): Forced to use DMT\n"));
            HwDeviceExtension->ulTimingOverrideTwinViewInfo[i] = DMTV_ID;
        }
        else
        {
            VideoDebugPrint((5,"GetTimingStandardOverride(): Forced to use NONE_ID\n"));
            HwDeviceExtension->ulTimingOverrideTwinViewInfo[i] = NONE_ID;
        }
    }
    return;
}

//
// Finds the best resolution for the device with the valid EDID index.
// Finds the largest resolution at 16bpp and the highest refresh rate at this resolution.
// Returns TRUE if it finds a best mode. Otherwise returns FALSE.
//
ULONG GetBestResolution(PHW_DEVICE_EXTENSION HwDeviceExtension, ULONG ulEDIDIndex, ULONG ulHead, ULONG ulDeviceMask, MODE_ENTRY *pBestMode)
{
    LPMODEINFO lpModeDesc;
    MODEINFO ModeDesc;
    HEAD_RESOLUTION_INFO sResolution;
    HEAD_RESOLUTION_INFO *pResolution;
    DAC_TIMING_VALUES * pTimingInfo;
    DAC_TIMING_VALUES   sTimingInfo;

    VideoDebugPrint((1,"GetBestResolution for index: %d\n", ulEDIDIndex));
    lpModeDesc = &ModeDesc;
    pTimingInfo = &sTimingInfo;
    pResolution = &sResolution;
    lpModeDesc->dwBpp = 32;
    lpModeDesc->dwRefreshRate = 60;

    EnterFPCode(HwDeviceExtension->pFPStateSave, HwDeviceExtension->pFPMutex);
    EdidFindLargestEdidMode (HwDeviceExtension->EdidCollection->HeadMaps[ulEDIDIndex]->EDIDBuffer,
                             HwDeviceExtension->EdidCollection->HeadMaps[ulEDIDIndex]->Size, lpModeDesc);
    ExitFPCode(HwDeviceExtension->pFPStateSave, HwDeviceExtension->pFPMutex);

    if (lpModeDesc->dwXRes == 640 && lpModeDesc->dwYRes == 480)
    {
        // the common modeset code fell back to defaut res.
        VideoDebugPrint((1,"Failure: FindLargestEdidMode(): (%d, %d), %d bpp, %d Hz\n", 
            lpModeDesc->dwXRes,lpModeDesc->dwYRes,lpModeDesc->dwBpp, lpModeDesc->dwRefreshRate));
        return(FALSE);
    }
    else
    {   
        // Print the mode info.
        VideoDebugPrint((1,"FindLargestEdidMode(): (%d, %d), %d bpp, %d Hz\n", 
            lpModeDesc->dwXRes,lpModeDesc->dwYRes,lpModeDesc->dwBpp, lpModeDesc->dwRefreshRate));

        // What we have now is the best possible mode using EDID only. Now we need to filter it against the other
        // parameters like video memory, pixel clock frequency etc..
        pResolution->ulHead = ulHead;
        pResolution->ulDeviceMask = ulDeviceMask;
        pResolution->ulDisplayWidth = lpModeDesc->dwXRes;
        pResolution->ulDisplayHeight = lpModeDesc->dwYRes;
        pResolution->ulDisplayPixelDepth = lpModeDesc->dwBpp;
        pResolution->ulDisplayRefresh = lpModeDesc->dwRefreshRate;
        pResolution->ulOption = 0;

        GetTimingDacCommonModesetCode(HwDeviceExtension, pResolution, pTimingInfo);

        // If the width, height and depth were maintained, then use the mode. Possibly, the refresh rate 
        // could have changed.
        if (pTimingInfo->HorizontalVisible == lpModeDesc->dwXRes &&
            pTimingInfo->VerticalVisible == lpModeDesc->dwYRes)
        {
            // Copy the info into the BestMode parameter.
            pBestMode->Width = (USHORT)lpModeDesc->dwXRes;
            pBestMode->Height = (USHORT)lpModeDesc->dwYRes;
            pBestMode->Depth = (USHORT)lpModeDesc->dwBpp;
            pBestMode->RefreshRate = (USHORT)pTimingInfo->Refresh;
            pBestMode->ValidMode = 1;
            VideoDebugPrint((1,"Success: GetTimingDac(): (%d, %d), %d bpp, %d Hz\n", 
                pTimingInfo->HorizontalVisible,pTimingInfo->VerticalVisible,
                lpModeDesc->dwBpp, pTimingInfo->Refresh));

            return(TRUE);
        }
        else
        {
            // Could not support the mode.
            VideoDebugPrint((1,"Failure: GetTimingDac(): (%d, %d), %d bpp, %d Hz\n", 
                pTimingInfo->HorizontalVisible,pTimingInfo->VerticalVisible,
                lpModeDesc->dwBpp, pTimingInfo->Refresh));
            return(FALSE);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\oldnv332.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/


//******************************************************************************
// WARNING: !!!                                                     WARNING: !!!
//
//    In order to be able to use this same driver source with older nv3 chips and
//    resource manager, this file includes the following OBSOLETE structure
//    definitions. These structures are OBSOLETE and meant to be used with NV3 only.
//
//      NV_CLASS                            (Class 0x01)
//      NV_CONTEXT_DMA_FROM_MEMORY          (Class 0x02)
//      NV_CONTEXT_DMA_TO_MEMORY            (Class 0x03)
//      NV_PATCHCORD_VIDEO                  (Class 0x0a)
//      NV_VIDEO_SINK                       (Class 0x0b)
//      NV_VIDEO_COLOR_MAP                  (Class 0x0d)
//      NV_PATCHCORD_IMAGE                  (Class 0x0e)
//      NV_IMAGE_STENCIL                    (Class 0x10)
//      NV_IMAGE_ROP_AND                    (Class 0x13)
//      NV_IMAGE_COLOR_KEY                  (Class 0x15)
//      NV_IMAGE_SOLID                      (Class 0x17)
//      NV_IMAGE_PATTERN                    (Class 0x18)
//      NV_IMAGE_BLACK_RECTANGLE            (Class 0x19)
//      NV_RENDER_SOLID_LIN                 (Class 0x1c)
//      NV_RENDER_SOLID_RECTANGLE           (Class 0x1e)
//      NV_IMAGE_BLIT                       (Class 0x1f)
//      NV_IMAGE_FROM_CPU                   (Class 0x21)
//      NV_PATCHCORD_ROP                    (Class 0x33)
//      NV_MEMORY_TO_MEMORY_FORMAT          (Class 0x39)
//      NV_CONTEXT_DMA_IN_MEMORY            (Class 0x3d)
//      IMAGE_IN_MEMORY                     (Class 0x3e)
//      NV_VIDEO_FROM_MEMORY                (Class 0x3f)
//      NV_VIDEO_SCALER                     (Class 0x40)
//      NV_VIDEO_COLOR_KEY                  (Class 0x41)
//      NV_ROP5_SOLID                       (Class 0x43)
//      ZETA_BUFFER_IN_MEMORY               (Class 0x45)
//      NV_PATCHCORD_ZETA                   (Class 0x46)
//      NV_RENDER_D3D0_TRIANGLE_ZETA        (Class 0x48)
//      NV_RENDER_GDI0_RECTANGLE_AND_TEXT   (Class 0x4b)
//
//    The following NV3 VIDEO classes are still supported in NV4 but their
//    CLASS id numbers are DIFFERENT depending on which resman/chip you use !!!!
//    (resman.050 supports NV4 , resman.040 supports NV3)
//
//          RESMAN.050                                  RESMAN.040
//          ----------                                  ----------
//      NV4_VIDEO_COLOR_KEY (class 0xFF6) is same as NV_VIDEO_COLOR_KEY (class 0x41)
//      NV4_VIDEO_SCALER    (class 0xFF7) is same as NV_VIDEO_SCALER    (class 0x40)
//      NV4_VIDEO_COLORMAP  (class 0xFF9) is same as NV_VIDEO_COLORMAP  (class 0xd)
//
//
// WARNING: !!!                                                     WARNING: !!!
//******************************************************************************

#include <nvtypes.h>

//******************************************************************************
// The following classes are no longer supported beginning with NV4 !!!   |
//                                                                        |
// In order to be able to use this driver with the older nv3 chips      | | |
// and resource manager, we include the old obsolete structure           | |
// definitions in this separate header file.                              |
//
//******************************************************************************


/***** SetMonochromeFormat values *****/
#define NV_MONO_LE_M1_P32          0x00000000
#define NV_MONO_CGA6_M1_P32        0x00000001
#define NV_MONOCHROME_FORMAT_LE_M1_P32     0x00000000
#define NV_MONOCHROME_FORMAT_CGA6_M1_P32   0x00000001

//------------------------------------------------------------------------------
// SetColorFormat Values (old style global color format)
//
// The format names precisely specify how the bits are arranged
// in a 32-bit write of a color or colors in that format in a
// little-endian system.  For example NV_COLOR_FORMAT_LE_X17R5G5B5
// means the upper 17 bits are ignored, then 5 bits each of
// Red, Green, and Blue intensity:
//
//   3                             1 1
//   1                             6 5                             0
//  |X X X X X X X X X X X X X X X X X R R R R R G G G G G B B B B B|
//
//------------------------------------------------------------------------------

/* Unpacked color formats */
#define NV_COLOR_FORMAT_LE_X17R5G5B5       0x00000000
#define NV_COLOR_FORMAT_LE_X16A1R5G5B5     0x00100000
#define NV_COLOR_FORMAT_LE_X24Y8           0x00010000
/* Packed color formats -- more than one value per 32-bit write */
#define NV_COLOR_FORMAT_LE_X1R5G5B5_P2     0x01000000
#define NV_COLOR_FORMAT_LE_A1R5G5B5_P2     0x01100000
#define NV_COLOR_FORMAT_LE_Y8_P4           0x01010000
/* No difference between packed and unpacked */
#define NV_COLOR_FORMAT_LE_X8R8G8B8        0x00000001
#define NV_COLOR_FORMAT_LE_A8R8G8B8        0x00100001
#define NV_COLOR_FORMAT_LE_X2R10G10B10     0x00000002
#define NV_COLOR_FORMAT_LE_A2R10G10B10     0x00100002
#define NV_COLOR_FORMAT_LE_X16A8Y8         0x00110000
#define NV_COLOR_FORMAT_LE_X16Y16          0x00010001
#define NV_COLOR_FORMAT_LE_A16Y16          0x00110001

//------------------------------------------------------------------------------
// These defines are not present in the latest nv32.h file.
// So we'll include them here (so we can support old style pre-NV4 drivers).
//------------------------------------------------------------------------------

#define NV_IP_PATTERN_SHAPE_8X_8Y               (0x00000000)
#define NV_IP_PATTERN_SHAPE_64X_1Y              (0x00000001)
#define NV_IP_PATTERN_SHAPE_1X_64Y              (0x00000002)

//------------------------------------------------------------------------------
// Client sets NvNotification.status to NV_STATUS_IN_PROGRESS, NV
// sets to a different value when it notifies.
//------------------------------------------------------------------------------

#define NV_STATUS_IN_PROGRESS      255

//------------------------------------------------------------------------------
// The minimum depth of the NV chip's FIFO -- never wait for the free count
// to reach a value greater than NV_GUARANTEED_FIFO_SIZE (124 bytes)!
//------------------------------------------------------------------------------

#define NV_GUARANTEED_FIFO_SIZE                 (0x007C)

//------------------------------------------------------------------------------
// Obsolete classes (pre-NV4)
// We include them here so we can support old style pre-NV4 drivers, as we
// begin to transition to NV4.
//------------------------------------------------------------------------------

/* class NV_CLASS */
#define NV_CLASS  1
typedef volatile struct tagNvClass {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x07e];
 V032 Create;                  /* 32-bit name of new object       0300-0303*/
 V032 Destroy;                 /* 32-bit name of object           0304-0307*/
 V032 SetNameCtxDma;           /* NV_CONTEXT_DMA_FROM_MEMORY      0308-030b*/
 U032 SetNameStart;            /* offset within ctxdma in bytes   030c-030f*/
 U032 SetNameLength;           /* ASCII O/S name length in bytes  0310-0313*/
 V032 SetEnumerateCtxDma;      /* NV_CONTEXT_DMA_TO_MEMORY        0314-0317*/
 U032 SetEnumerateStart;       /* offset within ctxdma in bytes   0318-031b*/
 U032 SetEnumerateLength;      /* in bytes                        031c-031f*/
 U032 Enumerate;               /* index into instance list        0320-0323*/
 V032 reserved02[0x737];
} NvClass;


/* class NV_CONTEXT_DMA_FROM_MEMORY */
#define NV_CONTEXT_DMA_FROM_MEMORY  2
typedef volatile struct tagNvContextDmaFromMemory {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x07e];
 struct tagNvSetDmaFromSpecifier {
  V032 address[2];               /* On X86, address[1] is the selector */
  U032 limit;                    /* size of data region in bytes - 1 */
 } SetDmaSpecifier;            /* memory region NV will read      0300-030b*/
 V032 reserved02[0x73d];
} NvContextDmaFromMemory;

#define  NV01_CONTEXT_DMA             0x00000002


/* class NV_CONTEXT_DMA_TO_MEMORY */
#define NV_CONTEXT_DMA_TO_MEMORY  3
typedef volatile struct tagNvContextDmaToMemory {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x07e];
 struct tagNvSetDmaToSpecifier {
  V032 address[2];               /* On X86, address[1] is the selector */
  U032 limit;                    /* size of data region in bytes - 1   */
 } SetDmaSpecifier;            /* memory region NV will write     0300-030b*/
 V032 reserved02[0x73d];
} NvContextDmaToMemory;


/* class NV_PATCHCORD_VIDEO */
#define NV_PATCHCORD_VIDEO  10
typedef volatile struct tagNvPatchcordVideo {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x07e];
 V032 Validate;                /* writing any value validates     0300-0303*/
 V032 reserved02[0x73f];
} NvPatchcordVideo;


/* class NV_VIDEO_SINK */
#define NV_VIDEO_SINK  11
typedef volatile struct tagNvVideoSink {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetVideoInput[56];       /* NV_PATCHCORD_VIDEO              0200-02df*/
// V032 SetVideoInputNotifyCtxDma;/*
 V032 reserved02[0x748];
} NvVideoSink;

// Video Class supported in resman.040

/* class NV_VIDEO_COLORMAP */
#define NV_VIDEO_COLORMAP  13
typedef volatile struct tagNvVideoColorMap {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetVideoOutput;          /* NV_PATCHCORD_VIDEO              0200-0203*/
 V032 SetVideoInput;           /* NV_PATCHCORD_VIDEO              0204-0207*/
 V032 reserved02[0x03e];
 V032 SetColormapCtxDma;       /* NV_CONTEXT_DMA_FROM_MEMORY      0300-0303*/
 V032 SetColormapFormat;       /*                                 0304-0307*/
 U032 SetColormapStart;        /* offset in ctxdma in bytes       0308-030b*/
 U032 SetColormapLength;       /* in bytes                        030c-030f*/
 U032 ColormapDirtyStart;      /* start of region to update       0310-0313*/
 U032 ColormapDirtyLength;     /* in bytes, triggers asynch. xfer 0314-0317*/
 V032 reserved03[0x73a];
} NvVideoColorMap;
/* values for NV_VIDEO_COLORMAP SetColormapFormat() */
#define NV_COLORMAP_X8R8G8B8       0x00000000
#define NV_COLORMAP_X2R10G10B10    0x00000001


/* class NV_PATCHCORD_IMAGE */
#define NV_PATCHCORD_IMAGE  14
typedef volatile struct tagNvPatchcordImage {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x07e];
 V032 Validate;                /* validate connections downstream 0300-0303*/
 V032 reserved02[0x73f];
} NvPatchcordImage;


/* class NV_IMAGE_STENCIL */
#define NV_IMAGE_STENCIL  16
typedef volatile struct tagNvImageStencil {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 SetImageInput[2];        /* P_I, 1 is ImageBlackRectangle   0204-020b*/
 V032 reserved02[0x77d];
} NvImageStencil;


/* class NV_IMAGE_ROP_AND */
#define NV_IMAGE_ROP_AND  19
typedef volatile struct tagNvImageRopAnd {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 SetRopInput;             /* NV_PATCHCORD_ROP                0204-0207*/
 V032 SetImageInput[3];        /* 0 is I2V ImageOut, 2 is pattern 0208-0213*/
 V032 reserved02[0x77b];
} NvImageRopAnd;


/* class NV_IMAGE_COLOR_KEY */
#define NV_IMAGE_COLOR_KEY  21
typedef volatile struct tagNvImageColorKey {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 SetImageInput[2];        /* P_I, 1 from ImageSolidColor     0204-020b*/
 V032 reserved02[0x77d];
} NvImageColorKey;


/* class NV_IMAGE_SOLID */
#define NV_IMAGE_SOLID  23
typedef volatile struct tagNvImageSolid {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 reserved02[0x03f];
 V032 SetColorFormat;          /* must be an unpacked format      0300-0303*/
 V032 SetColor;                /* color to fill the image         0304-0307*/
 V032 reserved03[0x73e];
} NvImageSolid;


/* class NV_IMAGE_PATTERN */
#define NV_IMAGE_PATTERN  24
typedef volatile struct tagNvImagePattern {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 reserved02[0x03f];
 V032 SetColorFormat;          /* Color 0/1, must be unpacked fmt 0300-0303*/
 V032 SetMonochromeFormat;     /* a NV_MONOCHROME_FORMAT_XX value 0304-0307*/
 V032 SetPatternShape;         /* NV_PATTERN_SHAPE_{8X8,64X1,1X64}0308-030b*/
 V032 reserved03[0x001];
 V032 SetColor0;               /* "background" color where pat=0  0310-0313*/
 V032 SetColor1;               /* "foreground" color where pat=1  0314-0317*/
 struct tagNvSetPattern {
  V032 monochrome[2];
 } SetPattern;                 /* 64 bits of pattern data         0318-031f*/
 V032 reserved04[0x738];
} NvImagePattern;
/* values for NV_IMAGE_PATTERN SetPatternShape() */
#define NV_PATTERN_SHAPE_8X8   0x00000000
#define NV_PATTERN_SHAPE_64X1  0x00000001
#define NV_PATTERN_SHAPE_1X64  0x00000002


/* class NV_IMAGE_BLACK_RECTANGLE */
#define NV_IMAGE_BLACK_RECTANGLE  25
typedef volatile struct tagNvImageBlackRectangle {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* P_I usually to NV_IMAGE_STENCIL 0200-0203*/
 V032 reserved02[0x03f];
 struct tagNvSetRectangle {
  V032 y_x;                      /* S16_S16 in pixels, 0 at top left 00-03*/
  V032 height_width;             /* U16_U16 in pixels                04-07*/
 } SetRectangle;               /* region in image where alpha=1   0300-0307*/
 V032 reserved03[0x73e];
} NvImageBlackRectangle;


/* class NV_RENDER_SOLID_LIN */
#define NV_RENDER_SOLID_LIN  28
typedef volatile struct tagNvRenderSolidLin {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 reserved02[0x03f];
 V032 SetColorFormat;          /* must be an unpacked format      0300-0303*/
 V032 Color;                   /*                                 0304-0307*/
 V032 reserved03[0x03e];
 struct tagNvLin {
  V032 y0_x0;                    /* S16_S16 in pixels, 0 at top left 00-03*/
  V032 y1_x1;                    /* S16_S16 in pixels, 0 at top left 04-07*/
 } Lin[16];                    /*                                 0400-047f*/
 struct tagNvLin32 {
  S032 x0;                         /*                                 00-03*/
  S032 y0;                         /*                                 04-07*/
  S032 x1;                         /*                                 08-0b*/
  S032 y1;                         /*                                 0c-0f*/
 } Lin32[8];                   /*                                 0480-04ff*/
 V032 PolyLin[32];             /*                                 0500-057f*/
 struct tagNvPolyLin32 {
  S032 x;                          /*                                 00-03*/
  S032 y;                          /*                                 04-07*/
 } PolyLin32[16];              /*                                 0580-05ff*/
 struct tagNvColorPolyLin {
  V032 color;                      /*                                 00-03*/
  V032 y_x;                      /* S16_S16 in pixels, 0 at top left 04-07*/
 } ColorPolyLin[16];           /*                                 0600-067f*/
 V032 reserved04[0x660];
} NvRenderSolidLin;


/* class NV_RENDER_SOLID_RECTANGLE */
#define NV_RENDER_SOLID_RECTANGLE  30
typedef volatile struct tagNvRenderSolidRectangle {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 reserved02[0x03f];
 V032 SetColorFormat;          /*                                 0300-0303*/
 V032 Color;                   /*                                 0304-0307*/
 V032 reserved03[0x03e];
 struct tagNvRectangle {
  V032 y_x;                      /* S16_S16 in pixels, 0 at top left 00-03*/
  V032 height_width;             /* U16_U16 in pixels                04-07*/
 } Rectangle[16];              /*                                 0400-047f*/
 V032 reserved04[0x6e0];
} NvRenderSolidRectangle;


/* class NV_IMAGE_BLIT */
#define NV_IMAGE_BLIT  31
typedef volatile struct tagNvImageBlit {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 SetImageInput;           /* NV_PATCHCORD_IMAGE              0204-0207*/
 V032 reserved02[0x03e];
 V032 ControlPointIn;          /* S16_S16 in pixels, u.r. of src  0300-0303*/
 V032 ControlPointOut;         /* S16_16 in pixels, u.r. of dest  0304-0307*/
 V032 Size;                    /* U16_U16 in pixels               0308-030b*/
 V032 reserved03[0x73d];
} NvImageBlit;


/* class NV_IMAGE_FROM_CPU */
#define NV_IMAGE_FROM_CPU  33
typedef volatile struct tagNvImageFromCpu {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 reserved02[0x03f];
 V032 SetColorFormat;          /* must be a packed format         0300-0303*/
 V032 Point;                   /* y_x S16_S16 in pixels           0304-0307*/
 V032 Size;                    /* height_width U16_U16 in pixels  0308-030b*/
 V032 SizeIn;                  /* height_width U16_U16 in pixels  030c-030f*/
 V032 reserved03[0x03c];
 V032 Color[32];               /* packed pixel(s) to add to image 0400-047f*/
 V032 reserved04[0x6e0];
} NvImageFromCpu;


/* class NV_PATCHCORD_ROP */
#define NV_PATCHCORD_ROP  51
typedef volatile struct tagNvPatchcordRop {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x07e];
 V032 Validate;                /* writing any value validates     0300-0303*/
 V032 reserved02[0x73f];
} NvPatchcordRop;

/* class NV_STRETCHED_IMAGE_FROM_CPU */
#define NV_STRETCHED_IMAGE_FROM_CPU  54
typedef volatile struct {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY          0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS   0104-0107*/
 V032 StopTransfer;            /* writing any value stops transfer  0108-010b*/
 V032 reserved01[0x03d];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE                0200-0203*/
 V032 reserved02[0x03f];
 V032 SetColorFormat;          /* must be a packed format           0300-0303*/
 V032 SizeIn;                  /* height_width U16_U16 in texels    0304-0307*/
 V032 DeltaDxDu;               /* dx/du S12.20                      0308-030b*/
 V032 DeltaDyDv;               /* dy/dv S12.20                      030c-030f*/
 struct {
  V032 y_x;                    /* S16_S16 in pixels, 0 at top left  0310-0313*/
  V032 height_width;           /* U16_U16 in pixels                 0314-0317*/
 } Clip;
 V032 Point12d4;               /* y_x S12.4_S12.4 in pixels         0318-031b*/
 V032 reserved03[0x039];
 V032 Color[1792];             /* packed pixel(s) of one scan line  0400-1fff*/
} NvStretchedImageFromCpu;

/* class NV_SCALED_IMAGE_FROM_MEMORY */
#define NV_SCALED_IMAGE_FROM_MEMORY  55
typedef volatile struct {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY          0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS   0104-0107*/
 V032 StopTransfer;            /* writing any value stops transfer  0108-010b*/
 V032 reserved01[0x03d];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE                0200-0203*/
 V032 reserved02[0x03f];
 V032 SetColorFormat;          /* must be a packed format           0300-0303*/
 V032 SetImageCtxDma;          /* NV_CONTEXT_DMA_FROM_MEMORY        0304-0307*/
 struct {
  V032 y_x;                    /* S16_S16 in pixels, 0 at top left  0308-030b*/
  V032 height_width;           /* U16_U16 in pixels                 030c-030f*/
 } Clip;
 struct {
  V032 y_x;                    /* S16_S16 in pixels, 0 at top left  0310-0313*/
  V032 height_width;           /* U16_U16 in pixels                 0314-0317*/
 } RectangleOut;
 V032 DeltaDuDx;               /* du/dx S12.20                      0318-031b*/
 V032 DeltaDvDy;               /* dv/dy S12.20                      031c-031f*/
 V032 reserved03[0x038];
 struct {
  V032 size;                   /* height_width U16_U16 in texels    0400-0403*/
  U032 pitch;                  /* bytes between lines               0404-0407*/
  U032 offset;                 /* byte offset of top-left texel     0408-040b*/
  V032 point12d4;              /* v_u U12.4_U12.4 in texels         040c-040f*/
 } ImageIn;
 V032 reserved04[0x6fc];
} NvScaledImageFromMemory;
/* additional values for SetColorFormat() */
#define NV_COLOR_FORMAT_LE_V8Y8U8Y8   0x00020000  /* YUYV, YUY2, YUV2 */
#define NV_COLOR_FORMAT_LE_Y8V8Y8U8   0x00020001  /* UYVY, CCIR601    */

/* class NV_SCALED_YUV40_FROM_MEMORY */
#define NV_SCALED_YUV420_FROM_MEMORY  56
typedef volatile struct {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY          0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS   0104-0107*/
 V032 StopTransfer;            /* writing any value stops transfer  0108-010b*/
 V032 reserved01[0x03d];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE                0200-0203*/
 V032 reserved02[0x040];
 V032 SetImageCtxDma;          /* NV_CONTEXT_DMA_FROM_MEMORY        0304-0307*/
 struct {
  V032 y_x;                    /* S16_S16 in pixels, 0 at top left  0308-030b*/
  V032 height_width;           /* U16_U16 in pixels                 030c-030f*/
 } Clip;
 struct {
  V032 y_x;                    /* S16_S16 in pixels, 0 at top left  0310-0313*/
  V032 height_width;           /* U16_U16 in pixels                 0314-0317*/
 } RectangleOut;
 V032 DeltaDuDx;               /* du/dx S12.20                      0318-031b*/
 V032 DeltaDvDy;               /* dv/dy S12.20                      031c-031f*/
 V032 reserved03[0x038];
 struct {
  V032 size;                   /* height_width U16_U16 in texels    0400-0403*/
  V032 pitch;                  /* uv_y U16_U16 bytes between lines  0404-0407*/
  U032 offsety;                /* byte offset of top-left Y texel   0408-040b*/
  U032 offsetu;                /* byte offset of top-left U texel   040c-040f*/
  U032 offsetv;                /* byte offset of top-left V texel   0410-0413*/
  V032 point12d4;              /* v_u U12.4_U12.4 of Y in texels    0414-0417*/
 } ImageIn;
 V032 reserved04[0x6fa];
} NvScaledYuv420FromMemory;

/* class NV_MEMORY_TO_MEMORY_FORMAT */
#define NV_MEMORY_TO_MEMORY_FORMAT  57
typedef volatile struct {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY          0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS   0104-0107*/
 V032 StopTransfer;            /* writing any value stops transfer  0108-010b*/
 V032 reserved01[0x07d];
 V032 SetBufferInCtxDma;       /* NV_CONTEXT_DMA_FROM_MEMORY        0300-0303*/
 V032 SetBufferOutCtxDma;      /* NV_CONTEXT_DMA_TO_MEMORY          0304-0307*/
 V032 SetBufferNotifyCtxDma;   /* NV_CONTEXT_DMA_TO_MEMORY          0308-030b*/
 struct {
  U032 offsetin;               /* input  ctxdma offset in bytes     030c-030f*/
  U032 offsetout;              /* output ctxdma offset in bytes     0310-0313*/
  S032 pitchin;                /* delta in bytes between scan lines 0314-0317*/
  S032 pitchout;               /* delta in bytes between scan lines 0318-031b*/
  U032 linelengthin;           /* in bytes                          031c-031f*/
  U032 linecount;              /* in lines                          0320-0323*/
  V032 format;                 /* ORed NV_MTMF_FORMAT_*             0324-0327*/
  V032 notify;                 /* notification style, varies w/OS   0328-032b*/
 } BufferTransfer;
 V032 reserved02[0x735];
} NvMemoryToMemoryFormat;
/* values for BufferTransfer.format() */
#define NV_MTMF_FORMAT_INPUT_INC_1     0x00000001
#define NV_MTMF_FORMAT_INPUT_INC_2     0x00000002
#define NV_MTMF_FORMAT_INPUT_INC_4     0x00000004
#define NV_MTMF_FORMAT_OUTPUT_INC_1    0x00000100
#define NV_MTMF_FORMAT_OUTPUT_INC_2    0x00000200
#define NV_MTMF_FORMAT_OUTPUT_INC_4    0x00000400


/* class NV_CONTEXT_DMA_IN_MEMORY */
#define NV_CONTEXT_DMA_IN_MEMORY  61
typedef volatile struct tagNvContextDmaInMemory {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY          0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS   0104-0107*/
 V032 reserved01[0x07e];
 struct {
  V032 address[2];             /* On X86 address[1] is the selector 0300-0307*/
  U032 limit;                  /* size of data region in bytes - 1  0308-030b*/
 } SetDmaSpecifier;
 V032 reserved02[0x73d];
} NvContextDmaInMemory;


/* class NV_IMAGE_IN_MEMORY */
#define NV_IMAGE_IN_MEMORY  62
typedef volatile struct {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY          0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS   0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE                0200-0203*/
 V032 SetImageInput[63];       /* NV_PATCHCORD_IMAGEs               0204-02ff*/
 V032 SetColorFormat;          /* must be a packed format           0300-0303*/
 V032 SetImageCtxDma;          /* NV_CONTEXT_DMA_IN_MEMORY          0304-0307*/
 S032 SetImagePitch;           /* gap in bytes between scan lines   0308-030b*/
 U032 SetImageOffset;          /* byte offset of top-left pixel     030c-030f*/
 V032 reserved02[0x73c];
} NvImageInMemory;
/* additional values for SetColorFormat() */
#define NV_COLOR_FORMAT_LE_Y16_P2   0x01010001


/* class NV_VIDEO_FROM_MEMORY */
#define NV_VIDEO_FROM_MEMORY  63
typedef volatile struct {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY          0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS   0104-0107*/
 V032 StopTransfer;            /* writing any value stops transfer  0108-010b*/
 V032 reserved01[0x03d];
 V032 SetVideoOutput;          /* NV_PATCHCORD_VIDEO                0200-0203*/
 V032 reserved02[0x03f];
 V032 SetImageCtxDma[2];       /* NV_CONTEXT_DMA_FROM_MEMORY        0300-0307*/
 V032 SetImageNotifyCtxDma[2]; /* NV_CONTEXT_DMA_TO_MEMORY          0308-030f*/
 struct {                      /*                                   0310-    */
  U032 offset;                 /* byte offset of top-left pixel       00-  03*/
  U032 pitch;                  /* bytes between lines                 04-  07*/
  V032 size;                   /* height_width U16_U16 in pixels      08-  0b*/
  V032 format;                 /* ORed NV_VFM_IMAGE_FORMAT_*          0c-  0f*/
  V032 notify;                 /* notification style, varies w/OS     10-  13*/
 } ImageScan[2];               /*                                       -0337*/
 V032 reserved03[0x732];
} NvVideoFromMemory;
/* values for ImageScan.format() */
#define NV_VFM_FORMAT_NEXT_FIELD_EVEN        0x00000000
#define NV_VFM_FORMAT_NEXT_FIELD_ODD         0x80000000
#define NV_VFM_FORMAT_COLOR_LE_Y8_P4         0x01010000
#define NV_VFM_FORMAT_COLOR_LE_X1R5G5B5_P2   0x01000000
#define NV_VFM_FORMAT_COLOR_LE_X8R8G8B8      0x00000001
#define NV_VFM_FORMAT_COLOR_LE_V8Y8U8Y8      0x00020000
#define NV_VFM_FORMAT_COLOR_LE_Y8V8Y8U8      0x00020001

// Video Class supported in resman.040

/* class NV_VIDEO_SCALER */
#define NV_VIDEO_SCALER  64
typedef volatile struct {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY          0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS   0104-0107*/
 V032 reserved01[0x03e];
 V032 SetVideoOutput;          /* NV_PATCHCORD_VIDEO                0200-0203*/
 V032 SetVideoInput;           /* NV_PATCHCORD_VIDEO                0204-0207*/
 V032 reserved02[0x03e];
 V032 SetDeltaDuDx;            /* du/dx S12.20                      0300-0303*/
 V032 SetDeltaDvDy;            /* dv/dy S12.20                      0304-0307*/
 V032 SetPoint;                /* y_x S16_S16 in pixels of origin   0308-030b*/
 V032 reserved03[0x73d];
} NvVideoScaler;


// Video Class supported in resman.040

/* class NV_VIDEO_COLOR_KEY */
#define NV_VIDEO_COLOR_KEY  65
typedef volatile struct {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY          0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS   0104-0107*/
 V032 reserved01[0x03e];
 V032 SetVideoOutput;          /* NV_PATCHCORD_VIDEO                0200-0203*/
 V032 SetVideoInput[3];        /* NV_PATCHCORD_VIDEO                0204-020f*/
 V032 reserved02[0x03c];
 V032 SetColorFormat;          /* must be an unpacked format        0300-0303*/
 V032 SetColorKey;             /* color to compare with             0304-0307*/
 V032 SetPoint;                /* y_x, S16_S16 in pixels, top left  0308-030b*/
 V032 SetSize;                 /* height_width, U16_U16 in pixels   030c-030f*/
 V032 reserved03[0x73c];
} NvVideoColorKey;

/* class NV_ROP5_SOLID */
#define NV_ROP5_SOLID  67
typedef volatile struct {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY          0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS   0104-0107*/
 V032 reserved01[0x03e];
 V032 SetRopOutput;            /* NV_PATCHCORD_ROP                  0200-0203*/
 V032 reserved02[0x03f];
 V032 SetRop5;                 /* 32-bit ROP5                       0300-0303*/
 V032 reserved03[0x73f];
} NvRop5Solid;


/* class NV_ZETA_BUFFER_IN_MEMORY */
#define NV_ZETA_BUFFER_IN_MEMORY  69
typedef volatile struct {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY          0100-0103*/
 V032 SetNotify;               /* NV_NOTIFY_* varies with OS        0104-0107*/
 V032 reserved01[0x03e];
 V032 SetZetaOutput;           /* NV_PATCHCORD_ZETA                 0200-0203*/
 V032 SetZetaInput[63];        /* NV_PATCHCORD_ZETAs                0204-02ff*/
 V032 SetZetaFormat;           /* NV_ZETA_FORMAT_* (packed)         0300-0303*/
 V032 SetZetaCtxDma;           /* NV_CONTEXT_DMA_IN_MEMORY          0304-0307*/
 S032 SetZetaPitch;            /* bytes, vertical zeta delta        0308-030b*/
 U032 SetZetaOffset;           /* byte offset of top-left zeta      030c-030f*/
 V032 reserved02[0x73c];
} NvZetaBufferInMemory;
/* additional values for SetColorFormat() */
#define NV_ZETA_FORMAT_LE_Z16_P2           0x00000000


/* class NV_PATCHCORD_ZETA */
#define NV_PATCHCORD_ZETA  70
typedef volatile struct {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY          0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS   0104-0107*/
 V032 reserved01[0x07e];
 V032 Validate;                /* writing any value validates       0300-0303*/
 V032 reserved02[0x73f];
} NvPatchcordZeta;


/* class NV_RENDER_D3D0_TRIANGLE_ZETA */
#define NV_RENDER_D3D0_TRIANGLE_ZETA  72
typedef volatile struct {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY          0100-0103*/
 V032 SetNotify;               /* NV_NOTIFY_* varies with OS        0104-0107*/
 V032 StopTransfer;            /* zero, stops transfer              0108-010b*/
 V032 InstantiatePatch;        /* zero, instantiates patch          010c-010f*/
 V032 reserved01[0x03c];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE                0200-0203*/
 V032 SetZetaOutput;           /* NV_PATCHCORD_ZETA                 0204-0207*/
 V032 SetZetaInput;            /* NV_PATCHCORD_ZETA                 0208-020b*/
 V032 reserved02[0x03d];
 V032 SetTextureCtxDma;        /* NV_CONTEXT_DMA_FROM_MEMORY        0300-0303*/
 U032 TextureOffset;           /* offset within ctxdma in bytes     0304-0307*/
 V032 TextureFormat;           /* NV_D3D0_TEXTURE_FORMAT_* OR'd     0308-030b*/
 V032 Filter;                  /* turbo_mipmap_spready_spreadx      030c-030f*/
 V032 FogColor;                /* X8R8G8B8 fog color                0310-0313*/
 V032 Control0;                /* NV_D3D0_CONTROL0_* OR'd           0314-0317*/
 V032 Control1;                /* NV_D3D0_CONTROL1_* OR'd           0318-031b*/
 V032 reserved03[0x339];
 struct {                      /* start of method in array          1000-    */
  V032 specular;               /* fog_i5-i0, U0d8_U004_..._U004       00-  03*/
  V032 color;                  /* X8R8G8B8 or A8R8G8B8, U0d8 chans    04-  07*/
  F032 x;                      /* screen x coordinate                 08-  0b*/
  F032 y;                      /* screen y coordinate                 0c-  0f*/
  F032 z;                      /* screen z coordinate                 10-  13*/
  F032 m;                      /* reciprocal homogenous W (m=1/W)     14-  17*/
  F032 u;                      /* texture u coordinate                18-  1b*/
  F032 v;                      /* texture v coordinate                1c-  1f*/
 } ControlPoint[128];          /* end of method in array                -1fff*/
} NvRenderD3D0TriangleZeta;
/* values for TextureFormat() */
#define NV_D3D0_TEXTURE_FORMAT_COLOR_KEY_COLOR_MASK   0x0000ffff
#define NV_D3D0_TEXTURE_FORMAT_COLOR_KEY_DISABLED     0x00000000
#define NV_D3D0_TEXTURE_FORMAT_COLOR_KEY_ENABLED      0x00010000
#define NV_D3D0_TEXTURE_FORMAT_COLOR_FORMAT_A1R5G5B5  0x00000000
#define NV_D3D0_TEXTURE_FORMAT_COLOR_FORMAT_X1R5G5B5  0x00100000
#define NV_D3D0_TEXTURE_FORMAT_COLOR_FORMAT_A4R4G4G4  0x00200000
#define NV_D3D0_TEXTURE_FORMAT_COLOR_FORMAT_R5G6B5    0x00300000
#define NV_D3D0_TEXTURE_FORMAT_SIZE_MIN_4X4           0x02000000
#define NV_D3D0_TEXTURE_FORMAT_SIZE_MIN_8X8           0x03000000
#define NV_D3D0_TEXTURE_FORMAT_SIZE_MIN_16X16         0x04000000
#define NV_D3D0_TEXTURE_FORMAT_SIZE_MIN_32X32         0x05000000
#define NV_D3D0_TEXTURE_FORMAT_SIZE_MIN_64X64         0x06000000
#define NV_D3D0_TEXTURE_FORMAT_SIZE_MIN_128X128       0x07000000
#define NV_D3D0_TEXTURE_FORMAT_SIZE_MIN_256X256       0x08000000
#define NV_D3D0_TEXTURE_FORMAT_SIZE_MIN_512X512       0x09000000
#define NV_D3D0_TEXTURE_FORMAT_SIZE_MIN_1024X1024     0x0a000000
#define NV_D3D0_TEXTURE_FORMAT_SIZE_MIN_2048X2048     0x0b000000
#define NV_D3D0_TEXTURE_FORMAT_SIZE_MAX_4X4           0x20000000
#define NV_D3D0_TEXTURE_FORMAT_SIZE_MAX_8X8           0x30000000
#define NV_D3D0_TEXTURE_FORMAT_SIZE_MAX_16X16         0x40000000
#define NV_D3D0_TEXTURE_FORMAT_SIZE_MAX_32X32         0x50000000
#define NV_D3D0_TEXTURE_FORMAT_SIZE_MAX_64X64         0x60000000
#define NV_D3D0_TEXTURE_FORMAT_SIZE_MAX_128X128       0x70000000
#define NV_D3D0_TEXTURE_FORMAT_SIZE_MAX_256X256       0x80000000
#define NV_D3D0_TEXTURE_FORMAT_SIZE_MAX_512X512       0x90000000
#define NV_D3D0_TEXTURE_FORMAT_SIZE_MAX_1024X1024     0xa0000000
#define NV_D3D0_TEXTURE_FORMAT_SIZE_MAX_2048X2048     0xb0000000
/* values for Control0() */
#define NV_D3D0_CONTROL0_INTERPOLATOR_ZOH             0x00000000
#define NV_D3D0_CONTROL0_INTERPOLATOR_ZOH_MS          0x00000001
#define NV_D3D0_CONTROL0_INTERPOLATOR_FOH             0x00000002
#define NV_D3D0_CONTROL0_WRAP_U_CYLINDRICAL           0x00000000
#define NV_D3D0_CONTROL0_WRAP_U_WRAP                  0x00000010
#define NV_D3D0_CONTROL0_WRAP_U_MIRROR                0x00000020
#define NV_D3D0_CONTROL0_WRAP_U_CLAMP                 0x00000030
#define NV_D3D0_CONTROL0_WRAP_V_CYLINDRICAL           0x00000000
#define NV_D3D0_CONTROL0_WRAP_V_WRAP                  0x00000040
#define NV_D3D0_CONTROL0_WRAP_V_MIRROR                0x00000080
#define NV_D3D0_CONTROL0_WRAP_V_CLAMP                 0x000000c0
#define NV_D3D0_CONTROL0_COLOR_FORMAT_LE_X8R8G8B8     0x00000000
#define NV_D3D0_CONTROL0_COLOR_FORMAT_LE_A8R8G8B8     0x00000100
#define NV_D3D0_CONTROL0_SRCCOLOR_NORMAL              0x00000000
#define NV_D3D0_CONTROL0_SRCCOLOR_COLOR_INVERSE       0x00000400
#define NV_D3D0_CONTROL0_SRCCOLOR_ALPHA_INVERSE       0x00000800
#define NV_D3D0_CONTROL0_SRCCOLOR_ALPHA_ONE           0x00000c00
#define NV_D3D0_CONTROL0_CULLING_NONE                 0x00001000
#define NV_D3D0_CONTROL0_CULLING_COUNTERCLOCKWISE     0x00002000
#define NV_D3D0_CONTROL0_CULLING_CLOCKWISE            0x00003000
#define NV_D3D0_CONTROL0_ZETA_BUFFER_SCREEN           0x00000000
#define NV_D3D0_CONTROL0_ZETA_BUFFER_LINEAR           0x00008000
#define NV_D3D0_CONTROL0_ZETA_COMPARE_FALSE           0x00010000
#define NV_D3D0_CONTROL0_ZETA_COMPARE_LT              0x00020000
#define NV_D3D0_CONTROL0_ZETA_COMPARE_EQ              0x00030000
#define NV_D3D0_CONTROL0_ZETA_COMPARE_LE              0x00040000
#define NV_D3D0_CONTROL0_ZETA_COMPARE_GT              0x00050000
#define NV_D3D0_CONTROL0_ZETA_COMPARE_NE              0x00060000
#define NV_D3D0_CONTROL0_ZETA_COMPARE_GE              0x00070000
#define NV_D3D0_CONTROL0_ZETA_COMPARE_TRUE            0x00080000
#define NV_D3D0_CONTROL0_ZETA_WRITE_NEVER             0x00000000
#define NV_D3D0_CONTROL0_ZETA_WRITE_ALPHA             0x00100000
#define NV_D3D0_CONTROL0_ZETA_WRITE_ALPHA_ZETA        0x00200000
#define NV_D3D0_CONTROL0_ZETA_WRITE_ZETA              0x00300000
#define NV_D3D0_CONTROL0_ZETA_WRITE_ALWAYS            0x00400000
#define NV_D3D0_CONTROL0_COLOR_WRITE_NEVER            0x00000000
#define NV_D3D0_CONTROL0_COLOR_WRITE_ALPHA            0x01000000
#define NV_D3D0_CONTROL0_COLOR_WRITE_ALPHA_ZETA       0x02000000
#define NV_D3D0_CONTROL0_COLOR_WRITE_ZETA             0x03000000
#define NV_D3D0_CONTROL0_COLOR_WRITE_ALWAYS           0x04000000
#define NV_D3D0_CONTROL0_ROP_BLEND_AND                0x00000000
#define NV_D3D0_CONTROL0_ROP_ADD_WITH_SATURATION      0x10000000
#define NV_D3D0_CONTROL0_BLEND_BETA_SRCALPHA          0x00000000
#define NV_D3D0_CONTROL0_BLEND_BETA_DESTCOLOR         0x20000000
#define NV_D3D0_CONTROL0_BLEND_INPUT0_DESTCOLOR       0x00000000
#define NV_D3D0_CONTROL0_BLEND_INPUT0_ZERO            0x40000000
#define NV_D3D0_CONTROL0_BLEND_INPUT1_SRCCOLOR        0x00000000
#define NV_D3D0_CONTROL0_BLEND_INPUT1_ZERO            0x80000000
/* values for Control1() */
#define NV_D3D0_CONTROL1_ALPHA_KEY_MASK               0x000000ff
#define NV_D3D0_CONTROL1_ALPHA_COMPARE_FALSE          0x00000100
#define NV_D3D0_CONTROL1_ALPHA_COMPARE_LT             0x00000200
#define NV_D3D0_CONTROL1_ALPHA_COMPARE_EQ             0x00000300
#define NV_D3D0_CONTROL1_ALPHA_COMPARE_LE             0x00000400
#define NV_D3D0_CONTROL1_ALPHA_COMPARE_GT             0x00000500
#define NV_D3D0_CONTROL1_ALPHA_COMPARE_NE             0x00000600
#define NV_D3D0_CONTROL1_ALPHA_COMPARE_GE             0x00000700
#define NV_D3D0_CONTROL1_ALPHA_COMPARE_TRUE           0x00000800


/* class NV_RENDER_GDI0_RECTANGLE_AND_TEXT */
#define NV_RENDER_GDI0_RECTANGLE_AND_TEXT  75
typedef volatile struct {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY          0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS   0104-0107*/
 V032 StopTransfer;            /* writing any value stops transfer  0108-010b*/
 V032 reserved01[0x03d];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE                0200-0203*/
 V032 reserved02[0x03f];
 V032 SetColorFormat;          /* unpacked RGB or Y                 0300-0303*/
 V032 SetMonochromeFormat;     /* NV_MONOCHROME_FORMAT_             0304-0307*/
 V032 reserved03[(0x03e)-1];
 V032 Color1A;                 /* rectangle color                   03fc-03ff*/
 struct {                      /*                                   0400-    */
  V032 x_y;                    /* S16_S16 in pixels, 0 at top left     0-   3*/
  V032 width_height;           /* U16_U16 in pixels                    4-   7*/
 } UnclippedRectangle[64];     /*                                       -05ff*/
 V032 reserved04[(0x080)-3];
 struct {
  V032 top_left;               /* S16_S16 in pixels, inclusive      07f4-07f7*/
  V032 bottom_right;           /* S16_S16 in pixels, exclusive      07f8-07fb*/
 } ClipB;
 V032 Color1B;                 /* rectangle color                   07fc-07ff*/
 struct {                      /*                                   0800-    */
  V032 top_left;               /* S16_S16 in pixels, inclusive         0-   3*/
  V032 bottom_right;           /* S16_S16 in pixels, exclusive         4-   7*/
 } ClippedRectangle[64];       /*                                       -09ff*/
 V032 reserved05[(0x080)-5];
 struct {
  V032 top_left;               /* S16_S16 in pixels, inclusive      0bec-0bef*/
  V032 bottom_right;           /* S16_S16 in pixels, exclusive      0bf0-0bf3*/
 } ClipC;
 V032 Color1C;                 /* color of 1 pixels                 0bf4-0bf7*/
 V032 SizeC;                   /* height_width U16_U16 in pixels    0bf8-0bfb*/
 V032 PointC;                  /* y_x S16_S16 in pixels             0bfc-0bff*/
 V032 MonochromeColor1C[128];  /* 32 monochrome pixels per write    0c00-0dff*/
 V032 reserved06[(0x080)-6];
 struct {
  V032 top_left;               /* S16_S16 in pixels, inclusive      0fe8-0feb*/
  V032 bottom_right;           /* S16_S16 in pixels, exclusive      0fec-0fef*/
 } ClipD;
 V032 Color1D;                 /* color of 1 pixels                 0ff0-0ff3*/
 V032 SizeInD;                 /* height_width U16_U16 in pixels    0ff4-0ff7*/
 V032 SizeOutD;                /* height_width U16_U16 in pixels    0ff8-0ffb*/
 V032 PointD;                  /* y_x S16_S16 in pixels             0ffc-0fff*/
 V032 MonochromeColor1D[128];  /* 32 monochrome pixels per write    1000-11ff*/
 V032 reserved07[(0x080)-7];
 struct {
  V032 top_left;               /* S16_S16 in pixels, inclusive      13e4-13e7*/
  V032 bottom_right;           /* S16_S16 in pixels, exclusive      13e8-13eb*/
 } ClipE;
 V032 Color0E;                 /* color of 0 pixels                 13ec-13ef*/
 V032 Color1E;                 /* color of 1 pixels                 13f0-13f3*/
 V032 SizeInE;                 /* height_width U16_U16 in pixels    13f4-13f7*/
 V032 SizeOutE;                /* height_width U16_U16 in pixels    13f8-13fb*/
 V032 PointE;                  /* y_x S16_S16 in pixels             13fc-13ff*/
 V032 MonochromeColor01E[128]; /* 32 monochrome pixels per write    1400-15ff*/
 V032 reserved08[0x280];
} NvRenderGdi0RectangleAndText;




//******************************************************************************
// The above classes are no longer supported beginning with NV4 !!!       |
//                                                                       | |
// In order to be able to use this driver with the older chips          | | |
// and resource manager, we include the old obsolete structure            |
// definitions.  That way, we don't have to include the old               |
// NV1 NV32.H file.  We only want one NV32.H file.
//******************************************************************************


//******************************************************************************
// Additional classes required for NV3 follow below:
//******************************************************************************


/* class NV01_IMAGE_PATTERN */
#define  NV01_IMAGE_PATTERN                              (0x00000018)
#define  NV1_IMAGE_PATTERN                               (0x00000018)
/* NvNotification[] elements */
#define NV018_NOTIFIERS_NOTIFY                           (0)
/* NvNotification[] fields and values */
#define NV018_NOTIFICATION_STATUS_IN_PROGRESS            (0x8000)
#define NV018_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT (0x4000)
#define NV018_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT     (0x2000)
#define NV018_NOTIFICATION_STATUS_ERROR_INVALID_STATE    (0x1000)
#define NV018_NOTIFICATION_STATUS_ERROR_STATE_IN_USE     (0x0800)
#define NV018_NOTIFICATION_STATUS_DONE_SUCCESS           (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV018_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV1_CONTEXT_DMA_TO_MEMORY         0180-0183*/
 V032 Reserved01[0x01f];
 V032 SetImageOutput;          /* NV1_PATCHCORD_IMAGE               0200-0203*/
 V032 Reserved02[0x03f];
 V032 SetColorFormat;          /* NV018_SET_COLOR_FORMAT_*          0300-0303*/
 V032 SetMonochromeFormat;     /* NV018_SET_MONOCHROME_FORMAT_*     0304-0307*/
 V032 SetMonochromeShape;      /* NV018_SET_MONOCHROME_SHAPE_*      0308-030b*/
 V032 Reserved03[0x001];
 V032 SetMonochromeColor0;     /* color of 0 pixels                 0310-0313*/
 V032 SetMonochromeColor1;     /* color of 1 pixels                 0314-0317*/
 V032 SetMonochromePattern0;   /* first  32 bits of pattern data    0318-031b*/
 V032 SetMonochromePattern1;   /* second 32 bits of pattern data    031c-031f*/
 V032 Reserved05[0x738];
} Nv018Typedef, Nv01ImagePattern;
#define Nv1ImagePattern                                  Nv01ImagePattern
#define nv1ImagePattern                                  nv01ImagePattern
#define NV018_TYPEDEF                                    nv01ImagePattern
/* dma method offsets, fields, and values */
#define NV018_SET_OBJECT                                           (0x00000000)
#define NV018_NO_OPERATION                                         (0x00000100)
#define NV018_NOTIFY                                               (0x00000104)
#define NV018_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV018_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV018_SET_COLOR_FORMAT                                     (0x00000300)
#define NV018_SET_COLOR_FORMAT_LE_X16A8Y8                          (0x00000001)
#define NV018_SET_COLOR_FORMAT_LE_X16A1R5G5B5                      (0x00000002)
#define NV018_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000003)
#define NV018_SET_MONOCHROME_FORMAT                                (0x00000304)
#define NV018_SET_MONOCHROME_FORMAT_CGA6_M1                        (0x00000001)
#define NV018_SET_MONOCHROME_FORMAT_LE_M1                          (0x00000002)
#define NV018_SET_MONOCHROME_SHAPE                                 (0x00000308)
#define NV018_SET_MONOCHROME_SHAPE_8X_8Y                           (0x00000000)
#define NV018_SET_MONOCHROME_SHAPE_64X_1Y                          (0x00000001)
#define NV018_SET_MONOCHROME_SHAPE_1X_64Y                          (0x00000002)
#define NV018_SET_MONOCHORME_COLOR0                                (0x00000310)
#define NV018_SET_MONOCHORME_COLOR1                                (0x00000314)
#define NV018_SET_MONOCHORME_PATTERN0                              (0x00000318)
#define NV018_SET_MONOCHORME_PATTERN1                              (0x0000031C)


/* class NV01_IMAGE_BLACK_RECTANGLE */
#define  NV01_IMAGE_BLACK_RECTANGLE                      (0x00000019)
#define  NV1_IMAGE_BLACK_RECTANGLE                       (0x00000019)
/* NvNotification[] elements */
#define NV019_NOTIFIERS_NOTIFY                           (0)
/* NvNotification[] fields and values */
#define NV019_NOTIFICATION_STATUS_IN_PROGRESS            (0x8000)
#define NV019_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT (0x4000)
#define NV019_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT     (0x2000)
#define NV019_NOTIFICATION_STATUS_ERROR_INVALID_STATE    (0x1000)
#define NV019_NOTIFICATION_STATUS_ERROR_STATE_IN_USE     (0x0800)
#define NV019_NOTIFICATION_STATUS_DONE_SUCCESS           (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV019_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV1_CONTEXT_DMA_TO_MEMORY         0180-0183*/
 V032 Reserved01[0x01f];
 V032 SetImageOutput;          /* NV1_PATCHCORD_IMAGE               0200-0203*/
 V032 Reserved02[0x03f];
 V032 SetPoint;                /* y_x S16_S16                       0300-0303*/
 V032 SetSize;                 /* height_width U16_U16              0304-0307*/
 V032 Reserved03[0x73e];
} Nv019Typedef, Nv01ImageBlackRectangle;
#define Nv1ImageBlackRectangle                           Nv01ImageBlackRectangle
#define nv1ImageBlackRectangle                           nv01ImageBlackRectangle
#define NV019_TYPEDEF                                    nv01ImageBlackRectangle
/* dma method offsets, fields, and values */
#define NV019_SET_OBJECT                                           (0x00000000)
#define NV019_NO_OPERATION                                         (0x00000100)
#define NV019_NOTIFY                                               (0x00000104)
#define NV019_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV019_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV019_SET_POINT                                            (0x00000300)
#define NV019_SET_POINT_X                                          15:0
#define NV019_SET_POINT_Y                                          31:16
#define NV019_SET_SIZE                                             (0x00000304)
#define NV019_SET_SIZE_WIDTH                                       15:0
#define NV019_SET_SIZE_HEIGHT                                      31:16



/* class NV01_RENDER_SOLID_RECTANGLE */
#define  NV01_RENDER_SOLID_RECTANGLE                     (0x0000001E)
#define  NV1_RENDER_SOLID_RECTANGLE                      (0x0000001E)
/* NvNotification[] elements */
#define NV01E_NOTIFIERS_NOTIFY                           (0)
/* NvNotification[] fields and values */
#define NV01E_NOTIFICATION_STATUS_IN_PROGRESS            (0x8000)
#define NV01E_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT (0x4000)
#define NV01E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT     (0x2000)
#define NV01E_NOTIFICATION_STATUS_ERROR_INVALID_STATE    (0x1000)
#define NV01E_NOTIFICATION_STATUS_ERROR_STATE_IN_USE     (0x0800)
#define NV01E_NOTIFICATION_STATUS_DONE_SUCCESS           (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV01E_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV1_CONTEXT_DMA_TO_MEMORY         0180-0183*/
 V032 SetContextClipRectangle; /* NV1_IMAGE_BLACK_RECTANGLE         0184-0187*/
 V032 SetContextPattern;       /* NV1_IMAGE_PATTERN                 0188-018b*/
 V032 SetContextRop;           /* NV3_CONTEXT_ROP                   018c-018f*/
 V032 SetContextBeta1;         /* NV1_BETA_SOLID                    0190-0193*/
 V032 SetContextSurface;       /* NV3_CONTEXT_SURFACE_0             0194-0197*/
 V032 Reserved01[0x059];
 V032 SetOperation;            /* NV01E_SET_OPERATION_*             02fc-02ff*/
 V032 SetColorFormat;          /* NV01E_SET_COLOR_FORMAT_*          0300-0303*/
 V032 Color;                   /* source color                      0304-0307*/
 V032 Reserved02[0x03e];
 struct {                      /* start of aliased methods in array 0400-    */
  V032 point;                  /* y_x S16_S16                          0-   3*/
  V032 size;                   /* height_width U16_U16                 4-   7*/
 } Rectangle[16];              /* end of method in array in array       -047f*/
 V032 Reserved03[0x6e0];
} Nv01eTypedef, Nv01RenderSolidRectangle;
#define Nv1RenderSolidRectangle                          Nv01RenderSolidRectangle
#define nv1RenderSolidRectangle                          nv01RenderSolidRectangle
#define NV01E_TYPEDEF                                    nv01RenderSolidRectangle
/* dma method offsets, fields, and values */
#define NV01E_SET_OBJECT                                           (0x00000000)
#define NV01E_NO_OPERATION                                         (0x00000100)
#define NV01E_NOTIFY                                               (0x00000104)
#define NV01E_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV01E_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV01E_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000184)
#define NV01E_SET_CONTEXT_PATTERN                                  (0x00000188)
#define NV01E_SET_CONTEXT_ROP                                      (0x0000018C)
#define NV01E_SET_CONTEXT_BETA1                                    (0x00000190)
#define NV01E_SET_CONTEXT_SURFACE                                  (0x00000194)
#define NV01E_SET_OPERATION                                        (0x000002FC)
#define NV01E_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV01E_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV01E_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV01E_SET_COLOR_FORMAT                                     (0x00000300)
#define NV01E_SET_COLOR_FORMAT_LE_X24Y8                            (0x00000001)
#define NV01E_SET_COLOR_FORMAT_LE_X17R5G5B5                        (0x00000002)
#define NV01E_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000003)
#define NV01E_SET_COLOR_FORMAT_LE_X16Y16                           (0x00000004)
#define NV01E_COLOR                                                (0x00000304)
#define NV01E_RECTANGLE(a)                                         (0x00000400\
                                                                   +(a)*0x0008)
#define NV01E_RECTANGLE_POINT(a)                                   (0x00000400\
                                                                   +(a)*0x0008)
#define NV01E_RECTANGLE_POINT_X                                    15:0
#define NV01E_RECTANGLE_POINT_Y                                    31:16
#define NV01E_RECTANGLE_SIZE(a)                                    (0x00000404\
                                                                   +(a)*0x0008)
#define NV01E_RECTANGLE_SIZE_WIDTH                                 15:0
#define NV01E_RECTANGLE_SIZE_HEIGHT                                31:16


/* class NV01_IMAGE_BLIT */
#define  NV01_IMAGE_BLIT                                 (0x0000001F)
#define  NV1_IMAGE_BLIT                                  (0x0000001F)
/* NvNotification[] elements */
#define NV01F_NOTIFIERS_NOTIFY                           (0)
/* NvNotification[] fields and values */
#define NV01F_NOTIFICATION_STATUS_IN_PROGRESS            (0x8000)
#define NV01F_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT (0x4000)
#define NV01F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT     (0x2000)
#define NV01F_NOTIFICATION_STATUS_ERROR_INVALID_STATE    (0x1000)
#define NV01F_NOTIFICATION_STATUS_ERROR_STATE_IN_USE     (0x0800)
#define NV01F_NOTIFICATION_STATUS_DONE_SUCCESS           (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV01F_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV1_CONTEXT_DMA_TO_MEMORY         0180-0183*/
 V032 SetContextColorKey;      /* NV1_IMAGE_SOLID                   0184-0187*/
 V032 SetContextClipRectangle; /* NV1_IMAGE_BLACK_RECTANGLE         0188-018b*/
 V032 SetContextPattern;       /* NV1_IMAGE_PATTERN                 018c-018f*/
 V032 SetContextRop;           /* NV3_CONTEXT_ROP                   0190-0193*/
 V032 SetContextBeta1;         /* NV1_BETA_SOLID                    0194-0197*/
 V032 SetContextSurfaceSource; /* NV3_CONTEXT_SURFACE_1             0198-019b*/
 V032 SetContextSurfaceDestin; /* NV3_CONTEXT_SURFACE_0             019c-019f*/
 V032 Reserved01[0x057];
 V032 SetOperation;            /* NV01F_SET_OPERATION_*             02fc-02ff*/
 V032 ControlPointIn;          /* y_x U16_U16, pixels, top left src 0300-0303*/
 V032 ControlPointOut;         /* y_x S16_S16, pixels, top left dst 0304-0307*/
 V032 Size;                    /* height_width U16_U16 in pixels    0308-030b*/
 V032 Reserved02[0x73d];
} Nv01fTypedef, Nv01ImageBlit;
#define Nv1ImageBlit                                     Nv01ImageBlit
#define nv1ImageBlit                                     nv01ImageBlit
#define NV01F_TYPEDEF                                    nv01ImageBlit
/* dma method offsets, fields, and values */
#define NV01F_SET_OBJECT                                           (0x00000000)
#define NV01F_NO_OPERATION                                         (0x00000100)
#define NV01F_NOTIFY                                               (0x00000104)
#define NV01F_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV01F_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV01F_SET_CONTEXT_COLOR_KEY                                (0x00000184)
#define NV01F_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000188)
#define NV01F_SET_CONTEXT_PATTERN                                  (0x0000018C)
#define NV01F_SET_CONTEXT_ROP                                      (0x00000190)
#define NV01F_SET_CONTEXT_BETA1                                    (0x00000194)
#define NV01F_SET_CONTEXT_SURFACE_SOURCE                           (0x00000198)
#define NV01F_SET_CONTEXT_SURFACE_DESTIN                           (0x0000019C)
#define NV01F_SET_OPERATION                                        (0x000002FC)
#define NV01F_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV01F_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV01F_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV01F_CONTROL_POINT_IN                                     (0x00000300)
#define NV01F_CONTROL_POINT_IN_X                                   15:0
#define NV01F_CONTROL_POINT_IN_Y                                   31:16
#define NV01F_CONTROL_POINT_OUT                                    (0x00000304)
#define NV01F_CONTROL_POINT_OUT_X                                  15:0
#define NV01F_CONTROL_POINT_OUT_Y                                  31:16
#define NV01F_SIZE                                                 (0x00000308)
#define NV01F_SIZE_WIDTH                                           15:0
#define NV01F_SIZE_HEIGHT                                          31:16


/* class NV01_IMAGE_FROM_CPU */
#define  NV01_IMAGE_FROM_CPU                             (0x00000021)
#define  NV1_IMAGE_FROM_CPU                              (0x00000021)
/* NvNotification[] elements */
#define NV021_NOTIFIERS_NOTIFY                           (0)
/* NvNotification[] fields and values */
#define NV021_NOTIFICATION_STATUS_IN_PROGRESS            (0x8000)
#define NV021_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT (0x4000)
#define NV021_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT     (0x2000)
#define NV021_NOTIFICATION_STATUS_ERROR_INVALID_STATE    (0x1000)
#define NV021_NOTIFICATION_STATUS_ERROR_STATE_IN_USE     (0x0800)
#define NV021_NOTIFICATION_STATUS_DONE_SUCCESS           (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV021_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV1_CONTEXT_DMA_TO_MEMORY         0180-0183*/
 V032 SetContextColorKey;      /* NV1_IMAGE_SOLID                   0184-0187*/
 V032 SetContextClipRectangle; /* NV1_IMAGE_BLACK_RECTANGLE         0188-018b*/
 V032 SetContextPattern;       /* NV1_IMAGE_PATTERN                 018c-018f*/
 V032 SetContextRop;           /* NV3_CONTEXT_ROP                   0190-0193*/
 V032 SetContextBeta1;         /* NV1_BETA_SOLID                    0194-0197*/
 V032 SetContextSurface;       /* NV3_CONTEXT_SURFACE_0             0198-019b*/
 V032 Reserved01[0x058];
 V032 SetOperation;            /* NV021_SET_OPERATION_*             02fc-02ff*/
 V032 SetColorFormat;          /* NV021_SET_COLOR_FORMAT_*          0300-0303*/
 V032 Point;                   /* y_x S16_S16 in pixels             0304-0307*/
 V032 SizeOut;                 /* height_width U16_U16, pixels, dst 0308-030b*/
 V032 SizeIn;                  /* height_width U16_U16, pixels, src 030c-030f*/
 V032 Reserved02[0x03c];
 V032 Color[32];               /* packed pixel(s) to add to image   0400-047f*/
 V032 Reserved03[0x6e0];
} Nv021Typedef, Nv01ImageFromCpu;
#define Nv1ImageFromCpu                                  Nv01ImageFromCpu
#define nv1ImageFromCpu                                  nv01ImageFromCpu
#define NV021_TYPEDEF                                    nv01ImageFromCpu
/* dma method offsets, fields, and values */
#define NV021_SET_OBJECT                                           (0x00000000)
#define NV021_NO_OPERATION                                         (0x00000100)
#define NV021_NOTIFY                                               (0x00000104)
#define NV021_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV021_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV021_SET_CONTEXT_COLOR_KEY                                (0x00000184)
#define NV021_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000188)
#define NV021_SET_CONTEXT_PATTERN                                  (0x0000018C)
#define NV021_SET_CONTEXT_ROP                                      (0x00000190)
#define NV021_SET_CONTEXT_BETA1                                    (0x00000194)
#define NV021_SET_CONTEXT_SURFACE                                  (0x00000198)
#define NV021_SET_OPERATION                                        (0x000002FC)
#define NV021_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV021_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV021_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV021_SET_COLOR_FORMAT                                     (0x00000300)
#define NV021_SET_COLOR_FORMAT_LE_Y8                               (0x00000001)
#define NV021_SET_COLOR_FORMAT_LE_A1R5G5B5                         (0x00000002)
#define NV021_SET_COLOR_FORMAT_LE_X1R5G5B5                         (0x00000003)
#define NV021_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000004)
#define NV021_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000005)
#define NV021_POINT                                                (0x00000304)
#define NV021_POINT_X                                              15:0
#define NV021_POINT_Y                                              31:16
#define NV021_SIZE_OUT                                             (0x00000308)
#define NV021_SIZE_OUT_WIDTH                                       15:0
#define NV021_SIZE_OUT_HEIGHT                                      31:16
#define NV021_SIZE_IN                                              (0x0000030C)
#define NV021_SIZE_IN_WIDTH                                        15:0
#define NV021_SIZE_IN_HEIGHT                                       31:16
#define NV021_COLOR(a)                                             (0x00000400\
                                                                   +(a)*0x0004)

/* class NV03_CONTEXT_ROP */
#define  NV03_CONTEXT_ROP                                (0x00000043)
#define  NV3_CONTEXT_ROP                                 (0x00000043)
/* NvNotification[] elements */
#define NV043_NOTIFIERS_NOTIFY                           (0)
/* NvNotification[] fields and values */
#define NV043_NOTIFICATION_STATUS_IN_PROGRESS            (0x8000)
#define NV043_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT (0x4000)
#define NV043_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT     (0x2000)
#define NV043_NOTIFICATION_STATUS_ERROR_INVALID_STATE    (0x1000)
#define NV043_NOTIFICATION_STATUS_ERROR_STATE_IN_USE     (0x0800)
#define NV043_NOTIFICATION_STATUS_DONE_SUCCESS           (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV043_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV1_CONTEXT_DMA_TO_MEMORY         0180-0183*/
 V032 Reserved01[0x05f];
 V032 SetRop5;                 /* 32-bit ROP5                       0300-0303*/
 V032 Reserved02[0x73f];
} Nv043Typedef, Nv03ContextRop;
#define Nv3ContextRop                                    Nv03ContextRop
#define nv3ContextRop                                    nv03ContextRop
#define NV043_TYPEDEF                                    nv03ContextRop
/* dma method offsets, fields, and values */
#define NV043_SET_OBJECT                                           (0x00000000)
#define NV043_NO_OPERATION                                         (0x00000100)
#define NV043_NOTIFY                                               (0x00000104)
#define NV043_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV043_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV043_SET_ROP5                                             (0x00000300)



/* class NV03_DX3_TEXTURED_TRIANGLE */
#define  NV03_DX3_TEXTURED_TRIANGLE                      (0x00000048)
#define  NV3_DX3_TEXTURED_TRIANGLE                       (0x00000048)
/* NvNotification[] elements */
#define NV048_NOTIFIERS_NOTIFY                           (0)
/* NvNotification[] fields and values */
#define NV048_NOTIFICATION_STATUS_IN_PROGRESS            (0x8000)
#define NV048_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT (0x4000)
#define NV048_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT     (0x2000)
#define NV048_NOTIFICATION_STATUS_ERROR_INVALID_STATE    (0x1000)
#define NV048_NOTIFICATION_STATUS_ERROR_STATE_IN_USE     (0x0800)
#define NV048_NOTIFICATION_STATUS_DONE_SUCCESS           (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV048_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV1_CONTEXT_DMA_TO_MEMORY         0180-0183*/
 V032 SetContextDmaTexture;    /* NV1_CONTEXT_DMA_FROM_MEMORY       0184-0187*/
 V032 SetContextClipRectangle; /* NV1_IMAGE_BLACK_RECTANGLE         0188-018b*/
 V032 SetContextSurfaceColor;  /* NV3_CONTEXT_SURFACE_2             018c-018f*/
 V032 SetContextSurfaceZeta;   /* NV3_CONTEXT_SURFACE_3             0190-0193*/
 V032 Reserved01[0x05c];
 U032 TextureOffset;           /* offset in bytes                   0304-0307*/
 V032 TextureFormat;           /* see text                          0308-030b*/
 V032 TextureFilter;           /* ignore_sizeAdjust_spreadY_spreadX 030c-030f*/
 V032 FogColor;                /* X8R8G8B8 fog color                0310-0313*/
 V032 Control0;                /* see text                          0314-0317*/
 V032 Control1;                /* alphafunc_alpharef V24_U8         0318-031b*/
 V032 Reserved02[0x339];
 struct {                      /* start of method in array          1000-    */
  V032 specular;               /* fog_i5-i0, U0d8_U4_U4_U4_U4_U4_U4   00-  03*/
  V032 color;                  /* X8R8G8B8 or A8R8G8B8                04-  07*/
  F032 sx;                     /* screen x coordinate                 08-  0b*/
  F032 sy;                     /* screen y coordinate                 0c-  0f*/
  F032 sz;                     /* screen z coordinate                 10-  13*/
  F032 rhw;                    /* reciprocal homogeneous W (1/W)      14-  17*/
  F032 tu;                     /* texture u coordinate                18-  1b*/
  F032 tv;                     /* texture v coordinate                1c-  1f*/
 } Tlvertex[128];              /* end of method in array                -1fff*/
} Nv048Typedef, Nv03Dx3TexturedTriangle;
#define Nv3Dx3TexturedTriangle                           Nv03Dx3TexturedTriangle
#define nv3Dx3TexturedTriangle                           nv03Dx3TexturedTriangle
#define NV048_TYPEDEF                                    nv03Dx3TexturedTriangle
/* dma method offsets, fields, and values */
#define NV048_SET_OBJECT                                           (0x00000000)
#define NV048_NO_OPERATION                                         (0x00000100)
#define NV048_NOTIFY                                               (0x00000104)
#define NV048_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV048_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV048_SET_CONTEXT_DMA_TEXTURE                              (0x00000184)
#define NV048_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000188)
#define NV048_SET_CONTEXT_SURFACE_COLOR                            (0x0000018C)
#define NV048_SET_CONTEXT_SURFACE_ZETA                             (0x00000190)
#define NV048_TEXTURE_OFFSET                                       (0x00000304)
#define NV048_TEXTURE_FORMAT                                       (0x00000308)
#define NV048_TEXTURE_FORMAT_VALUE                                 15:0
#define NV048_TEXTURE_FORMAT_KEY                                   19:16
#define NV048_TEXTURE_FORMAT_KEY_DISABLED                          (0x00000000)
#define NV048_TEXTURE_FORMAT_KEY_ENABLED                           (0x00000001)
#define NV048_TEXTURE_FORMAT_COLOR                                 23:20
#define NV048_TEXTURE_FORMAT_COLOR_LE_A1R5G5B5                     (0x00000000)
#define NV048_TEXTURE_FORMAT_COLOR_LE_X1R5G5B5                     (0x00000001)
#define NV048_TEXTURE_FORMAT_COLOR_LE_A4R4G4B4                     (0x00000002)
#define NV048_TEXTURE_FORMAT_COLOR_LE_R5G6B5                       (0x00000003)
#define NV048_TEXTURE_FORMAT_SIZE_MIN                              27:24
#define NV048_TEXTURE_FORMAT_SIZE_MIN_4X4                          (0x00000002)
#define NV048_TEXTURE_FORMAT_SIZE_MIN_8X8                          (0x00000003)
#define NV048_TEXTURE_FORMAT_SIZE_MIN_16X16                        (0x00000004)
#define NV048_TEXTURE_FORMAT_SIZE_MIN_32X32                        (0x00000005)
#define NV048_TEXTURE_FORMAT_SIZE_MIN_64X64                        (0x00000006)
#define NV048_TEXTURE_FORMAT_SIZE_MIN_128X128                      (0x00000007)
#define NV048_TEXTURE_FORMAT_SIZE_MIN_256X256                      (0x00000008)
#define NV048_TEXTURE_FORMAT_SIZE_MIN_512X512                      (0x00000009)
#define NV048_TEXTURE_FORMAT_SIZE_MIN_1024X1024                    (0x0000000A)
#define NV048_TEXTURE_FORMAT_SIZE_MIN_2048X2048                    (0x0000000B)
#define NV048_TEXTURE_FORMAT_SIZE_MAX                              31:28
#define NV048_TEXTURE_FORMAT_SIZE_MAX_4X4                          (0x00000002)
#define NV048_TEXTURE_FORMAT_SIZE_MAX_8X8                          (0x00000003)
#define NV048_TEXTURE_FORMAT_SIZE_MAX_16X16                        (0x00000004)
#define NV048_TEXTURE_FORMAT_SIZE_MAX_32X32                        (0x00000005)
#define NV048_TEXTURE_FORMAT_SIZE_MAX_64X64                        (0x00000006)
#define NV048_TEXTURE_FORMAT_SIZE_MAX_128X128                      (0x00000007)
#define NV048_TEXTURE_FORMAT_SIZE_MAX_256X256                      (0x00000008)
#define NV048_TEXTURE_FORMAT_SIZE_MAX_512X512                      (0x00000009)
#define NV048_TEXTURE_FORMAT_SIZE_MAX_1024X1024                    (0x0000000A)
#define NV048_TEXTURE_FORMAT_SIZE_MAX_2048X2048                    (0x0000000B)
#define NV048_TEXTURE_FILTER                                       (0x0000030C)
#define NV048_TEXTURE_FILTER_SPREAD_X                              4:0
#define NV048_TEXTURE_FILTER_IGNORE0                               7:5
#define NV048_TEXTURE_FILTER_SPREAD_Y                              12:8
#define NV048_TEXTURE_FILTER_IGNORE1                               15:13
#define NV048_TEXTURE_FILTER_SIZE_ADJUST                           23:16
#define NV048_TEXTURE_FILTER_IGNORE2                               31:24
#define NV048_FOG_COLOR                                            (0x00000310)
#define NV048_CONTROL0                                             (0x00000314)
#define NV048_CONTROL0_INTERPOLATOR                                3:0
#define NV048_CONTROL0_INTERPOLATOR_ZOH_CORNER                     (0x00000000)
#define NV048_CONTROL0_INTERPOLATOR_ZOH_CENTER                     (0x00000001)
#define NV048_CONTROL0_INTERPOLATOR_FOH_CENTER                     (0x00000002)
#define NV048_CONTROL0_WRAP_U                                      5:4
#define NV048_CONTROL0_WRAP_U_CYLINDRICAL                          (0x00000000)
#define NV048_CONTROL0_WRAP_U_WRAP                                 (0x00000001)
#define NV048_CONTROL0_WRAP_U_MIRROR                               (0x00000002)
#define NV048_CONTROL0_WRAP_U_CLAMP                                (0x00000003)
#define NV048_CONTROL0_WRAP_V                                      7:6
#define NV048_CONTROL0_WRAP_V_CYLINDRICAL                          (0x00000000)
#define NV048_CONTROL0_WRAP_V_WRAP                                 (0x00000001)
#define NV048_CONTROL0_WRAP_V_MIRROR                               (0x00000002)
#define NV048_CONTROL0_WRAP_V_CLAMP                                (0x00000003)
#define NV048_CONTROL0_COLOR_FORMAT                                9:8
#define NV048_CONTROL0_COLOR_FORMAT_LE_X8R8G8B8                    (0x00000000)
#define NV048_CONTROL0_COLOR_FORMAT_LE_A8R8G8B8                    (0x00000001)
#define NV048_CONTROL0_SOURCE_COLOR                                11:10
#define NV048_CONTROL0_SOURCE_COLOR_NORMAL                         (0x00000000)
#define NV048_CONTROL0_SOURCE_COLOR_COLOR_INVERSE                  (0x00000001)
#define NV048_CONTROL0_SOURCE_COLOR_ALPHA_INVERSE                  (0x00000002)
#define NV048_CONTROL0_SOURCE_COLOR_ALPHA_ONE                      (0x00000003)
#define NV048_CONTROL0_CULLING                                     14:12
#define NV048_CONTROL0_CULLING_NONE                                (0x00000001)
#define NV048_CONTROL0_CULLING_COUNTERCLOCKWISE                    (0x00000002)
#define NV048_CONTROL0_CULLING_CLOCKWISE                           (0x00000003)
#define NV048_CONTROL0_Z_PERSPECTIVE_ENABLE                        15:15
#define NV048_CONTROL0_Z_PERSPECTIVE_ENABLE_FALSE                  (0x00000000)
#define NV048_CONTROL0_Z_PERSPECTIVE_ENABLE_TRUE                   (0x00000001)
#define NV048_CONTROL0_ZFUNC                                       19:16
#define NV048_CONTROL0_ZFUNC_NEVER                                 (0x00000001)
#define NV048_CONTROL0_ZFUNC_LESS                                  (0x00000002)
#define NV048_CONTROL0_ZFUNC_EQUAL                                 (0x00000003)
#define NV048_CONTROL0_ZFUNC_LESSEQUAL                             (0x00000004)
#define NV048_CONTROL0_ZFUNC_GREATER                               (0x00000005)
#define NV048_CONTROL0_ZFUNC_NOTEQUAL                              (0x00000006)
#define NV048_CONTROL0_ZFUNC_GREATEREQUAL                          (0x00000007)
#define NV048_CONTROL0_ZFUNC_ALWAYS                                (0x00000008)
#define NV048_CONTROL0_ZETA_WRITE                                  23:20
#define NV048_CONTROL0_ZETA_WRITE_NEVER                            (0x00000000)
#define NV048_CONTROL0_ZETA_WRITE_ALPHA                            (0x00000001)
#define NV048_CONTROL0_ZETA_WRITE_ALPHA_ZETA                       (0x00000002)
#define NV048_CONTROL0_ZETA_WRITE_ZETA                             (0x00000003)
#define NV048_CONTROL0_ZETA_WRITE_ALWAYS                           (0x00000004)
#define NV048_CONTROL0_COLOR_WRITE                                 27:24
#define NV048_CONTROL0_COLOR_WRITE_NEVER                           (0x00000000)
#define NV048_CONTROL0_COLOR_WRITE_ALPHA                           (0x00000001)
#define NV048_CONTROL0_COLOR_WRITE_ALPHA_ZETA                      (0x00000002)
#define NV048_CONTROL0_COLOR_WRITE_ZETA                            (0x00000003)
#define NV048_CONTROL0_COLOR_WRITE_ALWAYS                          (0x00000004)
#define NV048_CONTROL0_ROP                                         28:28
#define NV048_CONTROL0_ROP_BLEND_AND                               (0x00000000)
#define NV048_CONTROL0_ROP_ADD_WITH_SATURATION                     (0x00000001)
#define NV048_CONTROL0_BLEND_BETA                                  29:29
#define NV048_CONTROL0_BLEND_BETA_SRCALPHA                         (0x00000000)
#define NV048_CONTROL0_BLEND_BETA_DESTCOLOR                        (0x00000001)
#define NV048_CONTROL0_BLEND_INPUT0                                30:30
#define NV048_CONTROL0_BLEND_INPUT0_DESTCOLOR                      (0x00000000)
#define NV048_CONTROL0_BLEND_INPUT0_ZERO                           (0x00000001)
#define NV048_CONTROL0_BLEND_INPUT1                                31:31
#define NV048_CONTROL0_BLEND_INPUT1_SRCCOLOR                       (0x00000000)
#define NV048_CONTROL0_BLEND_INPUT1_ZERO                           (0x00000001)
#define NV048_CONTROL1                                             (0x00000318)
#define NV048_CONTROL1_ALPHAREF                                    7:0
#define NV048_CONTROL1_ALPHAFUNC                                   31:8
#define NV048_CONTROL1_ALPHAFUNC_NEVER                             (0x00000001)
#define NV048_CONTROL1_ALPHAFUNC_LESS                              (0x00000002)
#define NV048_CONTROL1_ALPHAFUNC_EQUAL                             (0x00000003)
#define NV048_CONTROL1_ALPHAFUNC_LESSEQUAL                         (0x00000004)
#define NV048_CONTROL1_ALPHAFUNC_GREATER                           (0x00000005)
#define NV048_CONTROL1_ALPHAFUNC_NOTEQUAL                          (0x00000006)
#define NV048_CONTROL1_ALPHAFUNC_GREATEREQUAL                      (0x00000007)
#define NV048_CONTROL1_ALPHAFUNC_ALWAYS                            (0x00000008)

#define NV048_TLVERTEX(a)                                          (0x00001000\
                                                                   +(a)*0x0020)
#define NV048_TLVERTEX_SPECULAR(a)                                 (0x00001000\
                                                                   +(a)*0x0020)
#define NV048_TLVERTEX_SPECULAR_I0                                 3:0
#define NV048_TLVERTEX_SPECULAR_I1                                 7:4
#define NV048_TLVERTEX_SPECULAR_I2                                 11:8
#define NV048_TLVERTEX_SPECULAR_I3                                 15:12
#define NV048_TLVERTEX_SPECULAR_I4                                 19:16
#define NV048_TLVERTEX_SPECULAR_I5                                 23:20
#define NV048_TLVERTEX_SPECULAR_FOG                                31:24
#define NV048_TLVERTEX_COLOR(a)                                    (0x00001004\
                                                                   +(a)*0x0020)
#define NV048_TLVERTEX_SX(a)                                       (0x00001008\
                                                                   +(a)*0x0020)
#define NV048_TLVERTEX_SY(a)                                       (0x0000100C\
                                                                   +(a)*0x0020)
#define NV048_TLVERTEX_SZ(a)                                       (0x00001010\
                                                                   +(a)*0x0020)
#define NV048_TLVERTEX_RHW(a)                                      (0x00001014\
                                                                   +(a)*0x0020)
#define NV048_TLVERTEX_TU(a)                                       (0x00001018\
                                                                   +(a)*0x0020)
#define NV048_TLVERTEX_TV(a)                                       (0x0000101C\
                                                                   +(a)*0x0020)


/* class NV03_GDI_RECTANGLE_TEXT */
#define  NV03_GDI_RECTANGLE_TEXT                         (0x0000004B)
#define  NV3_GDI_RECTANGLE_TEXT                          (0x0000004B)
/* NvNotification[] elements */
#define NV04B_NOTIFIERS_NOTIFY                           (0)
/* NvNotification[] fields and values */
#define NV04B_NOTIFICATION_STATUS_IN_PROGRESS            (0x8000)
#define NV04B_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT (0x4000)
#define NV04B_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT     (0x2000)
#define NV04B_NOTIFICATION_STATUS_ERROR_INVALID_STATE    (0x1000)
#define NV04B_NOTIFICATION_STATUS_ERROR_STATE_IN_USE     (0x0800)
#define NV04B_NOTIFICATION_STATUS_DONE_SUCCESS           (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV04B_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV1_CONTEXT_DMA_TO_MEMORY         0180-0183*/
 V032 SetContextPattern;       /* NV1_IMAGE_PATTERN                 0184-0187*/
 V032 SetContextRop;           /* NV3_CONTEXT_ROP                   0188-018b*/
 V032 SetContextBeta1;         /* NV1_BETA_SOLID                    018c-018f*/
 V032 SetContextSurface;       /* NV3_CONTEXT_SURFACE_0             0190-0193*/
 V032 Reserved01[0x05a];
 V032 SetOperation;            /* NV04B_SET_OPERATION_*             02fc-02ff*/
 V032 SetColorFormat;          /* NV04B_SET_COLOR_FORMAT_*          0300-0303*/
 V032 SetMonochromeFormat;     /* NV04B_SET_MONOCHROME_FORMAT_*     0304-0307*/
 V032 Reserved02[0x03d];
 V032 Color1A;                 /* rectangle color                   03fc-03ff*/
 struct {                      /* start of aliased methods in array 0400-    */
  V032 point;                  /* x_y S16_S16 in pixels                0-   3*/
  V032 size;                   /* width_height U16_U16 in pixels       4-   7*/
 } UnclippedRectangle[64];     /* end of aliased methods in array       -05ff*/
 V032 Reserved03[0x07D];
 V032 ClipPoint0B;             /* top_left S16_S16 in pixels        07f4-07f7*/
 V032 ClipPoint1B;             /* bottom_right S16_S16 in pixels    07f8-07fb*/
 V032 Color1B;                 /* rectangle color                   07fc-07ff*/
 struct {                      /* start of aliased methods in array 0800-    */
  V032 point0;                 /* top_left S16_S16 in pixels           0-   3*/
  V032 point1;                 /* bottom_right S16_S16 in pixels       4-   7*/
 } ClippedRectangle[64];       /* end of aliased methods in array       -09ff*/
 V032 Reserved04[0x07B];
 V032 ClipPoint0C;             /* top_left S16_S16 in pixels        0bec-0bef*/
 V032 ClipPoint1C;             /* bottom_right S16_S16 in pixels    0bf0-0bf3*/
 V032 Color1C;                 /* color of 1 pixels                 0bf4-0bf7*/
 V032 SizeC;                   /* height_width U16_U16 in pixels    0bf8-0bfb*/
 V032 PointC;                  /* y_x S16_S16 in pixels             0bfc-0bff*/
 V032 MonochromeColor1C[128];  /* 32 monochrome pixels per write    0c00-0dff*/
 V032 Reserved05[0x07A];
 V032 ClipPoint0D;             /* top_left S16_S16 in pixels        0fe8-0feb*/
 V032 ClipPoint1D;             /* bottom_right S16_S16 in pixels    0fec-0fef*/
 V032 Color1D;                 /* color of 1 pixels                 0ff0-0ff3*/
 V032 SizeInD;                 /* height_width U16_U16 in pixels    0ff4-0ff7*/
 V032 SizeOutD;                /* height_width U16_U16 in pixels    0ff8-0ffb*/
 V032 PointD;                  /* y_x S16_S16 in pixels             0ffc-0fff*/
 V032 MonochromeColor1D[128];  /* 32 monochrome pixels per write    1000-11ff*/
 V032 Reserved06[0x079];
 V032 ClipPoint0E;             /* top_left S16_S16 in pixels        13e4-13e7*/
 V032 ClipPoint1E;             /* bottom_right S16_S16 in pixels    13e8-13eb*/
 V032 Color0E;                 /* color of 0 pixels                 13ec-13ef*/
 V032 Color1E;                 /* color of 1 pixels                 13f0-13f3*/
 V032 SizeInE;                 /* height_width U16_U16 in pixels    13f4-13f7*/
 V032 SizeOutE;                /* height_width U16_U16 in pixels    13f8-13fb*/
 V032 PointE;                  /* y_x S16_S16 in pixels             13fc-13ff*/
 V032 MonochromeColor01E[128]; /* 32 monochrome pixels per write    1400-15ff*/
 V032 Reserved07[0x280];
} Nv04bTypedef, Nv03GdiRectangleText;
#define Nv3GdiRectangleText                              Nv03GdiRectangleText
#define nv3GdiRectangleText                              nv03GdiRectangleText
#define NV04B_TYPEDEF                                    nv03GdiRectangleText
/* dma method offsets, fields, and values */
#define NV04B_SET_OBJECT                                           (0x00000000)
#define NV04B_NO_OPERATION                                         (0x00000100)
#define NV04B_NOTIFY                                               (0x00000104)
#define NV04B_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV04B_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV04B_SET_CONTEXT_PATTERN                                  (0x00000184)
#define NV04B_SET_CONTEXT_ROP                                      (0x00000188)
#define NV04B_SET_CONTEXT_BETA1                                    (0x0000018C)
#define NV04B_SET_CONTEXT_SURFACE                                  (0x00000190)
#define NV04B_SET_OPERATION                                        (0x000002FC)
#define NV04B_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV04B_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV04B_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV04B_SET_COLOR_FORMAT                                     (0x00000300)
#define NV04B_SET_COLOR_FORMAT_LE_X24Y8                            (0x00000001)
#define NV04B_SET_COLOR_FORMAT_LE_X17R5G5B5                        (0x00000002)
#define NV04B_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000003)
#define NV04B_SET_MONOCHROME_FORMAT                                (0x00000304)
#define NV04B_SET_MONOCHROME_FORMAT_CGA6_M1                        (0x00000001)
#define NV04B_SET_MONOCHROME_FORMAT_LE_M1                          (0x00000002)
#define NV04B_COLOR1_A                                             (0x000003FC)
#define NV04B_UNCLIPPED_RECTANGLE(a)                               (0x00000400\
                                                                   +(a)*0x0008)
#define NV04B_UNCLIPPED_RECTANGLE_POINT(a)                         (0x00000400\
                                                                   +(a)*0x0008)
#define NV04B_UNCLIPPED_RECTANGLE_POINT_X                          15:0
#define NV04B_UNCLIPPED_RECTANGLE_POINT_Y                          31:16
#define NV04B_UNCLIPPED_RECTANGLE_SIZE(a)                          (0x00000404\
                                                                   +(a)*0x0008)
#define NV04B_UNCLIPPED_RECTANGLE_SIZE_WIDTH                       15:0
#define NV04B_UNCLIPPED_RECTANGLE_SIZE_HEIGHT                      31:16
#define NV04B_CLIP_POINT0_B                                        (0x000007F4)
#define NV04B_CLIP_POINT0_B_LEFT                                   15:0
#define NV04B_CLIP_POINT0_B_TOP                                    31:16
#define NV04B_CLIP_POINT1_B                                        (0x000007F8)
#define NV04B_CLIP_POINT1_B_RIGHT                                  15:0
#define NV04B_CLIP_POINT1_B_BOTTOM                                 31:16
#define NV04B_COLOR1_B                                             (0x000007FC)
#define NV04B_CLIPPED_RECTANGLE(a)                                 (0x00000800\
                                                                   +(a)*0x0008)
#define NV04B_CLIPPED_RECTANGLE_POINT0(a)                          (0x00000800\
                                                                   +(a)*0x0008)
#define NV04B_CLIPPED_RECTANGLE_POINT0_LEFT                        15:0
#define NV04B_CLIPPED_RECTANGLE_POINT0_TOP                         31:16
#define NV04B_CLIPPED_RECTANGLE_POINT1(a)                          (0x00000804\
                                                                   +(a)*0x0008)
#define NV04B_CLIPPED_RECTANGLE_POINT1_RIGHT                       15:0
#define NV04B_CLIPPED_RECTANGLE_POINT1_BOTTOM                      31:16
#define NV04B_CLIP_POINT0_C                                        (0x00000BEC)
#define NV04B_CLIP_POINT0_C_LEFT                                   15:0
#define NV04B_CLIP_POINT0_C_TOP                                    31:16
#define NV04B_CLIP_POINT1_C                                        (0x00000BF0)
#define NV04B_CLIP_POINT1_C_RIGHT                                  15:0
#define NV04B_CLIP_POINT1_C_BOTTOM                                 31:16
#define NV04B_COLOR1_C                                             (0x00000BF4)
#define NV04B_SIZE_C                                               (0x00000BF8)
#define NV04B_SIZE_C_WIDTH                                         15:0
#define NV04B_SIZE_C_HEIGHT                                        31:16
#define NV04B_POINT_C                                              (0x00000BFC)
#define NV04B_POINT_C_X                                            15:0
#define NV04B_POINT_C_Y                                            31:16
#define NV04B_MONOCHROME_COLOR1_C(a)                               (0x00000C00\
                                                                   +(a)*0x0004)
#define NV04B_CLIP_POINT0_D                                        (0x00000FE8)
#define NV04B_CLIP_POINT0_D_LEFT                                   15:0
#define NV04B_CLIP_POINT0_D_TOP                                    31:16
#define NV04B_CLIP_POINT1_D                                        (0x00000FEC)
#define NV04B_CLIP_POINT1_D_RIGHT                                  15:0
#define NV04B_CLIP_POINT1_D_BOTTOM                                 31:16
#define NV04B_COLOR1_D                                             (0x00000FF0)
#define NV04B_SIZE_IN_D                                            (0x00000FF4)
#define NV04B_SIZE_IN_D_WIDTH                                      15:0
#define NV04B_SIZE_IN_D_HEIGHT                                     31:16
#define NV04B_SIZE_OUT_D                                           (0x00000FF8)
#define NV04B_SIZE_OUT_D_WIDTH                                     15:0
#define NV04B_SIZE_OUT_D_HEIGHT                                    31:16
#define NV04B_POINT_D                                              (0x00000FFC)
#define NV04B_POINT_D_X                                            15:0
#define NV04B_POINT_D_Y                                            31:16
#define NV04B_MONOCHROME_COLOR1_D(a)                               (0x00001000\
                                                                   +(a)*0x0004)
#define NV04B_CLIP_POINT0_E                                        (0x000013E4)
#define NV04B_CLIP_POINT0_E_LEFT                                   15:0
#define NV04B_CLIP_POINT0_E_TOP                                    31:16
#define NV04B_CLIP_POINT1_E                                        (0x000013E8)
#define NV04B_CLIP_POINT1_E_RIGHT                                  15:0
#define NV04B_CLIP_POINT1_E_BOTTOM                                 31:16
#define NV04B_COLOR0_E                                             (0x000013EC)
#define NV04B_COLOR1_E                                             (0x000013F0)
#define NV04B_SIZE_IN_E                                            (0x000013F4)
#define NV04B_SIZE_IN_E_WIDTH                                      15:0
#define NV04B_SIZE_IN_E_HEIGHT                                     31:16
#define NV04B_SIZE_OUT_E                                           (0x000013F8)
#define NV04B_SIZE_OUT_E_WIDTH                                     15:0
#define NV04B_SIZE_OUT_E_HEIGHT                                    31:16
#define NV04B_POINT_E                                              (0x000013FC)
#define NV04B_POINT_E_X                                            15:0
#define NV04B_POINT_E_Y                                            31:16
#define NV04B_MONOCHROME_COLOR01_E(a)                              (0x00001400\
                                                                   +(a)*0x0004)

/* class NV03_CONTEXT_SURFACE_0 */
#define  NV03_CONTEXT_SURFACE_0                          (0x00000058)
#define  NV3_CONTEXT_SURFACE_0                           (0x00000058)
/* NvNotification[] elements */
#define NV058_NOTIFIERS_NOTIFY                           (0)
/* NvNotification[] fields and values */
#define NV058_NOTIFICATION_STATUS_IN_PROGRESS            (0x8000)
#define NV058_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT (0x4000)
#define NV058_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT     (0x2000)
#define NV058_NOTIFICATION_STATUS_ERROR_INVALID_STATE    (0x1000)
#define NV058_NOTIFICATION_STATUS_ERROR_STATE_IN_USE     (0x0800)
#define NV058_NOTIFICATION_STATUS_DONE_SUCCESS           (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV058_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV1_CONTEXT_DMA_TO_MEMORY         0180-0183*/
 V032 SetContextDmaImage;      /* NV1_CONTEXT_DMA_IN_MEMORY         0184-0187*/
 V032 Reserved01[0x05e];
 V032 SetColorFormat;          /* NV058_SET_COLOR_FORMAT_*          0300-0303*/
 V032 Reserved02[0x001];
 U032 SetImagePitch;           /* bytes, vertical pixel delta       0308-030b*/
 U032 SetImageOffset;          /* byte offset of top-left pixel     030c-030f*/
 V032 Reserved03[0x73c];
} Nv058Typedef, Nv03ContextSurface0;
#define Nv3ContextSurface0                               Nv03ContextSurface0
#define nv3ContextSurface0                               nv03ContextSurface0
#define NV058_TYPEDEF                                    nv03ContextSurface0
/* dma method offsets, fields, and values */
#define NV058_SET_OBJECT                                           (0x00000000)
#define NV058_NO_OPERATION                                         (0x00000100)
#define NV058_NOTIFY                                               (0x00000104)
#define NV058_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV058_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV058_SET_CONTEXT_DMA_IMAGE                                (0x00000184)
#define NV058_SET_COLOR_FORMAT                                     (0x00000300)
#define NV058_SET_COLOR_FORMAT_LE_Y8                               (0x01010000)
#define NV058_SET_COLOR_FORMAT_LE_Y16                              (0x01010001)
#define NV058_SET_COLOR_FORMAT_LE_X1R5G5B5_Z1R5G5B5                (0x01000000)
#define NV058_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8                (0x00000001)
#define NV058_SET_IMAGE_PITCH                                      (0x00000308)
#define NV058_SET_IMAGE_OFFSET                                     (0x0000030C)


/* class NV03_CONTEXT_SURFACE_1 */
#define  NV03_CONTEXT_SURFACE_1                          (0x00000059)
#define  NV3_CONTEXT_SURFACE_1                           (0x00000059)
/* NvNotification[] elements */
#define NV059_NOTIFIERS_NOTIFY                           (0)
/* NvNotification[] fields and values */
#define NV059_NOTIFICATION_STATUS_IN_PROGRESS            (0x8000)
#define NV059_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT (0x4000)
#define NV059_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT     (0x2000)
#define NV059_NOTIFICATION_STATUS_ERROR_INVALID_STATE    (0x1000)
#define NV059_NOTIFICATION_STATUS_ERROR_STATE_IN_USE     (0x0800)
#define NV059_NOTIFICATION_STATUS_DONE_SUCCESS           (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV059_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV1_CONTEXT_DMA_TO_MEMORY         0180-0183*/
 V032 SetContextDmaImage;      /* NV1_CONTEXT_DMA_IN_MEMORY         0184-0187*/
 V032 Reserved01[0x05e];
 V032 SetColorFormat;          /* NV059_SET_COLOR_FORMAT_*          0300-0303*/
 V032 Reserved02[0x001];
 U032 SetImagePitch;           /* bytes, vertical pixel delta       0308-030b*/
 U032 SetImageOffset;          /* byte offset of top-left pixel     030c-030f*/
 V032 Reserved03[0x73c];
} Nv059Typedef, Nv03ContextSurface1;
#define Nv3ContextSurface1                               Nv03ContextSurface1
#define nv3ContextSurface1                               nv03ContextSurface1
#define NV059_TYPEDEF                                    nv03ContextSurface1
/* dma method offsets, fields, and values */
#define NV059_SET_OBJECT                                           (0x00000000)
#define NV059_NO_OPERATION                                         (0x00000100)
#define NV059_NOTIFY                                               (0x00000104)
#define NV059_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV059_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV059_SET_CONTEXT_DMA_IMAGE                                (0x00000184)
#define NV059_SET_COLOR_FORMAT                                     (0x00000300)
#define NV059_SET_COLOR_FORMAT_LE_Y8                               (0x01010000)
#define NV059_SET_COLOR_FORMAT_LE_Y16                              (0x01010001)
#define NV059_SET_COLOR_FORMAT_LE_X1R5G5B5_Z1R5G5B5                (0x01000000)
#define NV059_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8                (0x00000001)
#define NV059_SET_IMAGE_PITCH                                      (0x00000308)
#define NV059_SET_IMAGE_OFFSET                                     (0x0000030C)


/* class NV03_CONTEXT_SURFACE_3 */
#define  NV03_CONTEXT_SURFACE_3                          (0x0000005B)
#define  NV3_CONTEXT_SURFACE_3                           (0x0000005B)
/* NvNotification[] elements */
#define NV05B_NOTIFIERS_NOTIFY                           (0)
/* NvNotification[] fields and values */
#define NV05B_NOTIFICATION_STATUS_IN_PROGRESS            (0x8000)
#define NV05B_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT (0x4000)
#define NV05B_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT     (0x2000)
#define NV05B_NOTIFICATION_STATUS_ERROR_INVALID_STATE    (0x1000)
#define NV05B_NOTIFICATION_STATUS_ERROR_STATE_IN_USE     (0x0800)
#define NV05B_NOTIFICATION_STATUS_DONE_SUCCESS           (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV05B_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV1_CONTEXT_DMA_TO_MEMORY         0180-0183*/
 V032 SetContextDmaImage;      /* NV1_CONTEXT_DMA_IN_MEMORY         0184-0187*/
 V032 Reserved01[0x05e];
 V032 SetColorFormat;          /* NV05B_SET_COLOR_FORMAT_*          0300-0303*/
 V032 Reserved02[0x001];
 U032 SetImagePitch;           /* bytes, vertical pixel delta       0308-030b*/
 U032 SetImageOffset;          /* byte offset of top-left pixel     030c-030f*/
 V032 Reserved03[0x73c];
} Nv05bTypedef, Nv03ContextSurface3;
#define Nv3ContextSurface3                               Nv03ContextSurface3
#define nv3ContextSurface3                               nv03ContextSurface3
#define NV05B_TYPEDEF                                    nv03ContextSurface3
/* dma method offsets, fields, and values */
#define NV05B_SET_OBJECT                                           (0x00000000)
#define NV05B_NO_OPERATION                                         (0x00000100)
#define NV05B_NOTIFY                                               (0x00000104)
#define NV05B_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV05B_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV05B_SET_CONTEXT_DMA_IMAGE                                (0x00000184)
#define NV05B_SET_COLOR_FORMAT                                     (0x00000300)
#define NV05B_SET_COLOR_FORMAT_LE_W16_0                            (0x01010000)
#define NV05B_SET_COLOR_FORMAT_LE_W16_1                            (0x01010001)
#define NV05B_SET_COLOR_FORMAT_LE_W16_2                            (0x01000000)
#define NV05B_SET_COLOR_FORMAT_LE_W16_3                            (0x00000001)
#define NV05B_DUMMY                                                (0x00000308)
#define NV05B_SET_IMAGE_OFFSET                                     (0x0000030C)


 /***************************************************************************\
|*                                 Channels                                  *|
 \***************************************************************************/

/* class NV03_CHANNEL_PIO */
#define  NV03_CHANNEL_PIO                                (0x0000006A)
#define  NV3_CHANNEL_PIO                                 (0x0000006A)
/* NvNotification[] fields and values */
#define NV06A_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT (0x4000)
#define NV06A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT     (0x2000)
#define NV06A_NOTIFICATION_STATUS_ERROR_FLOW_CONTROL     (0x0200)
/* pio subchannel method data structure */
typedef volatile struct {
 V032 Reserved00[0x003];
 U016 Free;                    /* free count, read only             0010-0011*/
 U016 Zero[3];                 /* zeroes, read only                 0012-0017*/
 V032 Reserved01[0x03A];
} Nv03ControlPio;
#define Nv3ControlPio                                    Nv03ControlPio
typedef volatile struct {
 V032 SetObject;               /* handle of current object          0000-0003*/
 Nv03ControlPio control;       /* flow control                      0000-00ff*/
 union {                       /* start of class methods            0100-    */
  NvClass                   nvClass;
  NvContextDmaFromMemory    nvContextDmaFromMemory;
  NvContextDmaToMemory      nvContextDmaToMemory;
  NvPatchcordVideo          nvPatchcordVideo;
  NvVideoSink               nvVideoSink;
  NvVideoColorMap           nvVideoColorMap;            // Video Class supported in resman.040
  NvPatchcordImage          nvPatchcordImage;
  NvImageStencil            nvImageStencil;
  NvImageRopAnd             nvImageRopAnd;
  NvImageColorKey           nvImageColorKey;
  NvImageSolid              nvImageSolid;
  NvImagePattern            nvImagePattern;
  NvImageBlackRectangle     nvImageBlackRectangle;
  NvRenderSolidLin          nvRenderSolidLin;
  NvRenderSolidRectangle    nvRenderSolidRectangle;
  NvImageBlit               nvImageBlit;
  NvImageFromCpu            nvImageFromCpu;
  NvPatchcordRop            nvPatchcordRop;
  NvMemoryToMemoryFormat    nvMemoryToMemoryFormat;
  NvScaledImageFromMemory   nvScaledImageFromMemory;
  NvScaledYuv420FromMemory  nvScaledYuv420FromMemory;
  NvStretchedImageFromCpu   nvStretchedImageFromCpu;
  NvContextDmaInMemory      nvContextDmaInMemory;
  NvImageInMemory           nvImageInMemory;
  NvVideoFromMemory         nvVideoFromMemory;
  NvVideoScaler             nvVideoScaler;              // Video Class supported in resman.040
  NvVideoColorKey           nvVideoColorKey;            // Video Class supported in resman.040
  NvRop5Solid               nvRop5Solid;
  NvZetaBufferInMemory      nvZetaBufferInMemory;
  NvPatchcordZeta           nvPatchcordZeta;
  NvRenderD3D0TriangleZeta  nvRenderD3D0TriangleZeta;
  NvRenderGdi0RectangleAndText nvRenderGdi0RectangleAndText;

  Nv018Typedef NV018_TYPEDEF;
  Nv019Typedef NV019_TYPEDEF;
  Nv01eTypedef NV01E_TYPEDEF;
  Nv01fTypedef NV01F_TYPEDEF;
  Nv021Typedef NV021_TYPEDEF;
  Nv043Typedef NV043_TYPEDEF;
  Nv048Typedef NV048_TYPEDEF;
  Nv04bTypedef NV04B_TYPEDEF;
  Nv058Typedef NV058_TYPEDEF;
  Nv059Typedef NV059_TYPEDEF;
  Nv05bTypedef NV05B_TYPEDEF;


 } /* cls */;                  /* end of class methods                  -1fff*/
} Nv03SubchannelPio;
#define Nv3SubchannelPio                                 Nv03SubchannelPio
/* pio channel */
typedef volatile struct {      /* start of array of subchannels     0000-    */
 Nv03SubchannelPio subchannel[8];/*subchannel                       0000-1fff*/
} Nv03ChannelPio;              /* end of array of subchannels           -ffff*/
#define Nv3ChannelPio                                    Nv03ChannelPio
/* fields and values */
#define NV06A_FIFO_GUARANTEED_SIZE                       (0x007C)
#define NV06A_FIFO_EMPTY                                 (0x007C)


/* class NV03_CHANNEL_DMA */
#define  NV03_CHANNEL_DMA                                (0x0000006B)
/* NvNotification[] fields and values */
#define NV06B_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT (0x4000)
/* pio method data structure */
typedef volatile struct {
 V032 Reserved00[0x7c0];
} Nv06bTypedef, Nv03ChannelDma;
#define  NV06B_TYPEDEF                                   nv03ChannelDma



 /***************************************************************************\
|*                            Well Known Objects                             *|
 \***************************************************************************/


/* object NV01_NULL_OBJECT */
#define   NV01_NULL_OBJECT                               (0x00000000)
#define   NV1_NULL_OBJECT                                (0x00000000)



 /***************************************************************************\
|*                               Notification                                *|
 \***************************************************************************/


/***** NvNotification Structure *****/
/*
 * NV objects return information about method completion to clients via an
 * array of notification structures in main memory.
 *
 * The client sets the status field to NV???_NOTIFICATION_STATUS_IN_PROGRESS.
 * NV fills in the NvNotification[] data structure in the following order:
 * timeStamp, otherInfo32, otherInfo16, and then status.
 */


/* memory data structures */
typedef volatile struct {
 struct {                      /*                                   0000-    */
  U032 nanoseconds[2];         /* nanoseconds since Jan. 1, 1970       0-   7*/
 } timeStamp;                  /*                                       -0007*/
 V032 info32;                  /* info returned depends on method   0008-000b*/
 V016 info16;                  /* info returned depends on method   000c-000d*/
 V016 status;                  /* user sets bit 15, NV sets status  000e-000f*/
} NvNotification;
/* status values */

/************** WARNING Duplicated from nv32.h ******************************/

/* pio flow control data structure */
typedef volatile struct {
 NvV32 Ignored00[0x010];
 NvU32 Put;                     /* put offset, write only           0040-0043*/
 NvU32 Get;                     /* get offset, read only            0044-0047*/
 NvU32 Reference;               /* reference value, read only       0048-004b*/
 NvV32 Ignored01[0x7ed];
} Nv06eControl, Nv10ControlDma;




//****************************************************************************
// Macros relocated from DRIVER.H. They were moved here to avoid conflicts
// with D3d source files which had defined the same macros.
//****************************************************************************

#define NvGetFreeCount(NN, CH)\
                 (NN)->subchannel[CH].control.Free

/* class NV01_MEMORY_LOCAL_PRIVILEGED */
#define  NV01_MEMORY_LOCAL_PRIVILEGED                              (0x0000003F)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\sgs_dac.h ===
//
// (C) Copyright NVIDIA Corporation Inc., 1995,1996. All rights reserved.
//
//
// SGS Thomson DAC registers.
//
//
// DAC microport registeres.
//
#define SGS_DAC_UPORT_WRITE_PAL_ADDR                    NV_PDAC_DATA(0)
#define SGS_DAC_UPORT_COLOR                             NV_PDAC_DATA(1)
#define SGS_DAC_UPORT_PIXEL_MASK                        NV_PDAC_DATA(2)
#define SGS_DAC_UPORT_READ_PAL_ADDR                     NV_PDAC_DATA(3)
#define SGS_DAC_UPORT_INDEX_LO                          NV_PDAC_DATA(4)
#define SGS_DAC_UPORT_INDEX_HI                          NV_PDAC_DATA(5)
#define SGS_DAC_UPORT_INDEX_DATA                        NV_PDAC_DATA(6)
#define SGS_DAC_UPORT_GAMEPORT                          NV_PDAC_DATA(7)
//
// Indexed registers.
//
#define SGS_DAC_VENDOR_ID                               0x0000
#define SGS_DAC_VENDOR_ID_SGS                           0x44
#define SGS_DAC_DEVICE_ID                               0x0001
#define SGS_DAC_DEVICE_ID_VAN_GOGH                      0x32
#define SGS_DAC_DEVICE_ID_VAN_DYKE                      0x64
#define SGS_DAC_REVISION_ID                             0x0002
#define SGS_DAC_CONFIG_0                                0x0004
#define SGS_DAC_CONFIG_0_VESA_CONNECTOR                 7:7
#define SGS_DAC_CONFIG_0_VESA_CONNECTOR_DISABLED        0x00
#define SGS_DAC_CONFIG_0_VESA_CONNECTOR_ENABLED         0x01
#define SGS_DAC_CONFIG_0_IDC_MODE                       6:6
#define SGS_DAC_CONFIG_0_IDC_MODE_DIRECT_COLOR          0x00
#define SGS_DAC_CONFIG_0_IDC_MODE_INDEX                 0x01
#define SGS_DAC_CONFIG_0_VGA_STATE                      5:5
#define SGS_DAC_CONFIG_0_VGA_STATE_READ_ADRESS          0x00
#define SGS_DAC_CONFIG_0_VGA_STATE_READ_STATE           0x01
#define SGS_DAC_CONFIG_0_PORT_WIDTH                     3:2
#define SGS_DAC_CONFIG_0_PORT_WIDTH_16BIT               0x00
#define SGS_DAC_CONFIG_0_PORT_WIDTH_32BIT               0x01
#define SGS_DAC_CONFIG_0_PORT_WIDTH_64BIT               0x02
#define SGS_DAC_CONFIG_0_PIXEL_DEPTH                    1:0
#define SGS_DAC_CONFIG_0_PIXEL_DEPTH_4BIT               0x00
#define SGS_DAC_CONFIG_0_PIXEL_DEPTH_8BIT               0x01
#define SGS_DAC_CONFIG_0_PIXEL_DEPTH_16BIT              0x02
#define SGS_DAC_CONFIG_0_PIXEL_DEPTH_32BIT              0x03
#define SGS_DAC_CONFIG_1                                0x0005
#define SGS_DAC_CONFIG_1_COMP_VOLTAGE                   7:7
#define SGS_DAC_CONFIG_1_COMP_VOLTAGE_NOT_EXCEEDED      0x00
#define SGS_DAC_CONFIG_1_COMP_VOLTAGE_EXCEEDED          0x01
#define SGS_DAC_CONFIG_1_BLANK_PEDASTAL                 6:6
#define SGS_DAC_CONFIG_1_BLANK_PEDASTAL_ADD_0_5_IRE     0x00
#define SGS_DAC_CONFIG_1_BLANK_PEDASTAL_ADD_7_5_IRE     0x01
#define SGS_DAC_CONFIG_1_REGISTER_INIT                  5:5
#define SGS_DAC_CONFIG_1_REGISTER_INIT_NORMAL           0x00
#define SGS_DAC_CONFIG_1_REGISTER_INIT_RESET            0x01
#define SGS_DAC_CONFIG_1_VCLK_DIRECTION                 4:4
#define SGS_DAC_CONFIG_1_VCLK_DIRECTION_OUTPUT          0x00
#define SGS_DAC_CONFIG_1_VCLK_DIRECTION_INPUT           0x01
#define SGS_DAC_CONFIG_1_VCLK_IMPEDENCE                 3:3
#define SGS_DAC_CONFIG_1_VCLK_IMPEDENCE_HIGH            0x00
#define SGS_DAC_CONFIG_1_VCLK_IMPEDENCE_LOW             0x01
#define SGS_DAC_CONFIG_1_VCLK_DIVIDE                    2:0
#define SGS_DAC_CONFIG_1_VCLK_DIVIDE_BY_1               0x00
#define SGS_DAC_CONFIG_1_VCLK_DIVIDE_BY_2               0x01
#define SGS_DAC_CONFIG_1_VCLK_DIVIDE_BY_4               0x02
#define SGS_DAC_CONFIG_1_VCLK_DIVIDE_BY_8               0x03
#define SGS_DAC_CONFIG_1_VCLK_DIVIDE_BY_16              0x04 
#define SGS_DAC_CONFIG_2                                0x0006
#define SGS_DAC_CONFIG_2_DDC_DATA_IN                    0:0
#define SGS_DAC_ACTIVE_PAL_ADDR                         0x0008
#define SGS_DAC_RGB_EXT_PAL_CTRL                        0x0009
#define SGS_DAC_RGB_EXT_PAL_CTRL_DAC_STATE              5:4
#define SGS_DAC_RGB_EXT_PAL_CTRL_DAC_STATE_WRITE        0x00
#define SGS_DAC_RGB_EXT_PAL_CTRL_DAC_STATE_READ         0x03
#define SGS_DAC_RGB_EXT_PAL_CTRL_INDEX_ACCESS           3:3
#define SGS_DAC_RGB_EXT_PAL_CTRL_INDEX_ACCESS_LOW       0x00
#define SGS_DAC_RGB_EXT_PAL_CTRL_INDEX_ACCESS_HIGH      0x01
#define SGS_DAC_RGB_EXT_PAL_CTRL_RGB_NEXT_ACCESS        2:0
#define SGS_DAC_RGB_EXT_PAL_CTRL_RGB_NEXT_ACCESS_RED    0x01
#define SGS_DAC_RGB_EXT_PAL_CTRL_RGB_NEXT_ACCESS_GREEN  0x02
#define SGS_DAC_RGB_EXT_PAL_CTRL_RGB_NEXT_ACCESS_BLUE   0x04
#define SGS_DAC_RED_PAL_DATA                            0x000A
#define SGS_DAC_GREEN_PAL_DATA                          0x000B
#define SGS_DAC_POWER_MGMNT_A                           0x000C
#define SGS_DAC_POWER_MGMNT_A_TEST_POINT_CTRL           7:7
#define SGS_DAC_POWER_MGMNT_A_TEST_POINT_CTRL_POWER     0x00
#define SGS_DAC_POWER_MGMNT_A_TEST_POINT_CTRL_NO_POWER  0x01
#define SGS_DAC_POWER_MGMNT_A_PIXEL_MUX                 6:6
#define SGS_DAC_POWER_MGMNT_A_PIXEL_MUX_POWER           0x00
#define SGS_DAC_POWER_MGMNT_A_PIXEL_MUX_NO_POWER        0x01
#define SGS_DAC_POWER_MGMNT_A_RAM                       5:5
#define SGS_DAC_POWER_MGMNT_A_RAM_POWER                 0x00
#define SGS_DAC_POWER_MGMNT_A_RAM_NO_POWER              0x01
#define SGS_DAC_POWER_MGMNT_A_POST_RAM                  4:4
#define SGS_DAC_POWER_MGMNT_A_POST_RAM_POWER            0x00
#define SGS_DAC_POWER_MGMNT_A_POST_RAM_NO_POWER         0x01
#define SGS_DAC_POWER_MGMNT_A_CHECKSUM                  3:3
#define SGS_DAC_POWER_MGMNT_A_CHECKSUM_POWER            0x00
#define SGS_DAC_POWER_MGMNT_A_CHECKSUM_NO_POWER         0x01
#define SGS_DAC_POWER_MGMNT_A_DAC                       2:2
#define SGS_DAC_POWER_MGMNT_A_DAC_POWER                 0x00
#define SGS_DAC_POWER_MGMNT_A_DAC_NO_POWER              0x01
#define SGS_DAC_POWER_MGMNT_A_INPUT_PINS                1:1
#define SGS_DAC_POWER_MGMNT_A_INPUT_PINS_POWER          0x00
#define SGS_DAC_POWER_MGMNT_A_INPUT_PINS_NO_POWER       0x01
#define SGS_DAC_POWER_MGMNT_A_FIFO                      0:0
#define SGS_DAC_POWER_MGMNT_A_FIFO_POWER                0x00
#define SGS_DAC_POWER_MGMNT_A_FIFO_NO_POWER             0x01
#define SGS_DAC_POWER_MGMNT_B                           0x000D
#define SGS_DAC_POWER_MGMNT_B_MUX_DPM                   6:6
#define SGS_DAC_POWER_MGMNT_B_MUX_DPM_DISABLED          0x00
#define SGS_DAC_POWER_MGMNT_B_MUX_DPM_ENABLED           0x01
#define SGS_DAC_POWER_MGMNT_B_CHANNEL_DPM               5:5
#define SGS_DAC_POWER_MGMNT_B_CHANNEL_DPM_DISABLED      0x00
#define SGS_DAC_POWER_MGMNT_B_CHANNEL_DPM_ENABLED       0x01
#define SGS_DAC_POWER_MGMNT_B_FIFO_DPM                  4:4
#define SGS_DAC_POWER_MGMNT_B_FIFO_DPM_DISABLED         0x00
#define SGS_DAC_POWER_MGMNT_B_FIFO_DPM_ENABLED          0x01
#define SGS_DAC_POWER_MGMNT_B_CRYSTAL                   3:3
#define SGS_DAC_POWER_MGMNT_B_CRYSTAL_POWER             0x00
#define SGS_DAC_POWER_MGMNT_B_CRYSTAL_NO_POWER          0x01
#define SGS_DAC_POWER_MGMNT_B_APPL                      2:2
#define SGS_DAC_POWER_MGMNT_B_APPL_POWER                0x00
#define SGS_DAC_POWER_MGMNT_B_APPL_NO_POWER             0x01
#define SGS_DAC_POWER_MGMNT_B_VPPL                      1:1
#define SGS_DAC_POWER_MGMNT_B_VPPL_POWER                0x00
#define SGS_DAC_POWER_MGMNT_B_VPPL_NO_POWER             0x01
#define SGS_DAC_POWER_MGMNT_B_MPPL                      0:0
#define SGS_DAC_POWER_MGMNT_B_MPPL_POWER                0x00
#define SGS_DAC_POWER_MGMNT_B_MPPL_NO_POWER             0x01
#define SGS_DAC_POWER_MGMNT_C                           0x000E
#define SGS_DAC_POWER_MGMNT_C_GAMEPORT                  1:1
#define SGS_DAC_POWER_MGMNT_C_GAMEPORT_POWER            0x00
#define SGS_DAC_POWER_MGMNT_C_GAMEPORT_NO_POWER         0x01
#define SGS_DAC_POWER_MGMNT_C_CURSOR                    0:0
#define SGS_DAC_POWER_MGMNT_C_CURSOR_POWER              0x00
#define SGS_DAC_POWER_MGMNT_C_CURSOR_NO_POWER           0x01
#define SGS_DAC_MPLL_M                                  0x0010
#define SGS_DAC_MPLL_N                                  0x0011
#define SGS_DAC_MPLL_O                                  0x0012
#define SGS_DAC_MPLL_P                                  0x0013
#define SGS_DAC_APLL_M                                  0x0014
#define SGS_DAC_APLL_N                                  0x0015
#define SGS_DAC_APLL_O                                  0x0016
#define SGS_DAC_APLL_P                                  0x0017
#define SGS_DAC_VPLL_M                                  0x0018
#define SGS_DAC_VPLL_N                                  0x0019
#define SGS_DAC_VPLL_O                                  0x001A
#define SGS_DAC_VPLL_P                                  0x001B
#define SGS_DAC_VBLANK_CTRL                             0x001C
#define SGS_DAC_VBLANK_CTRL_DETECTION                   1:1
#define SGS_DAC_VBLANK_CTRL_DETECTION_NORMAL            0x00
#define SGS_DAC_VBLANK_CTRL_DETECTION_INHIBIT           0x01
#define SGS_DAC_VBLANK_CTRL_CONDITION                   0:0
#define SGS_DAC_VBLANK_CTRL_CONDITION_NORMAL            0x00
#define SGS_DAC_VBLANK_CTRL_CONDITION_FORCE             0x01
#define SGS_DAC_CURSOR_CTRL                             0x0020
#define SGS_DAC_CURSOR_CTRL_DISPLAY                     1:0
#define SGS_DAC_CURSOR_CTRL_DISPLAY_DISABLED            0x00
#define SGS_DAC_CURSOR_CTRL_DISPLAY_THREE_COLOR         0x01
#define SGS_DAC_CURSOR_CTRL_DISPLAY_TWO_COLOR_XOR       0x02
#define SGS_DAC_CURSOR_CTRL_DISPLAY_TWO_COLOR           0x03
#define SGS_DAC_CURSOR_POS_X_LO                         0x0022
#define SGS_DAC_CURSOR_POS_X_HI                         0x0023
#define SGS_DAC_CURSOR_POS_Y_LO                         0x0024
#define SGS_DAC_CURSOR_POS_Y_HI                         0x0025
#define SGS_DAC_CHECKSUM_CTRL                           0x0030
#define SGS_DAC_CHECKSUM_CTRL_VALUE                     2:2
#define SGS_DAC_CHECKSUM_CTRL_VALUE_NOT_RESET           0x00
#define SGS_DAC_CHECKSUM_CTRL_VALUE_RESET               0x01
#define SGS_DAC_CHECKSUM_CTRL_COLOR                     1:0
#define SGS_DAC_CHECKSUM_CTRL_COLOR_BLUE                0x00
#define SGS_DAC_CHECKSUM_CTRL_COLOR_GREEN               0x01
#define SGS_DAC_CHECKSUM_CTRL_COLOR_RED                 0x02
#define SGS_DAC_CHECKSUM_HI                             0x0031
#define SGS_DAC_CHECKSUM_MID                            0x0032
#define SGS_DAC_CHECKSUM_LO                             0x0033
#define SGS_DAC_GAMEPORT_STATE                          0x003D
#define SGS_DAC_GAMEPORT_STATE_CAPTURE_PHASE            4:4
#define SGS_DAC_GAMEPORT_STATE_CAPTURE_PHASE_ANALOG     0x00
#define SGS_DAC_GAMEPORT_STATE_CAPTURE_PHASE_DIGITAL    0x01
#define SGS_DAC_GAMEPORT_STATE_COUNTER                  3:0
#define SGS_DAC_GAMEPORT_TYPE                           0x003E
#define SGS_DAC_GAMEPORT_TYPE_CHANNEL_7                 7:7
#define SGS_DAC_GAMEPORT_TYPE_CHANNEL_6                 6:6
#define SGS_DAC_GAMEPORT_TYPE_CHANNEL_5                 5:5
#define SGS_DAC_GAMEPORT_TYPE_CHANNEL_4                 4:4
#define SGS_DAC_GAMEPORT_TYPE_CHANNEL_3                 3:3
#define SGS_DAC_GAMEPORT_TYPE_CHANNEL_2                 2:2
#define SGS_DAC_GAMEPORT_TYPE_CHANNEL_1                 1:1
#define SGS_DAC_GAMEPORT_TYPE_CHANNEL_0                 0:0
#define SGS_DAC_GAMEPORT_TYPE_ANALOG                    0x00
#define SGS_DAC_GAMEPORT_TYPE_DIGITAL                   0x01
#define SGS_DAC_GAMEPORT_DIGITAL_INPUT                  0x003F
#define SGS_DAC_GAMEPORT_DIGITAL_INPUT_CHANNEL_7        7:7
#define SGS_DAC_GAMEPORT_DIGITAL_INPUT_CHANNEL_6        6:6
#define SGS_DAC_GAMEPORT_DIGITAL_INPUT_CHANNEL_5        5:5
#define SGS_DAC_GAMEPORT_DIGITAL_INPUT_CHANNEL_4        4:4
#define SGS_DAC_GAMEPORT_DIGITAL_INPUT_CHANNEL_3        3:3
#define SGS_DAC_GAMEPORT_DIGITAL_INPUT_CHANNEL_2        2:2
#define SGS_DAC_GAMEPORT_DIGITAL_INPUT_CHANNEL_1        1:1
#define SGS_DAC_GAMEPORT_DIGITAL_INPUT_CHANNEL_0        0:0
#define SGS_DAC_GAMEPORT_DIGITAL_INPUT_NOT_PRESSED      0x00
#define SGS_DAC_GAMEPORT_DIGITAL_INPUT_PRESSED          0x01
#define SGS_DAC_GAMEPORT_ANALOG_INPUT_0_LO              0x0040
#define SGS_DAC_GAMEPORT_ANALOG_INPUT_0_HI              0x0041
#define SGS_DAC_GAMEPORT_ANALOG_INPUT_1_LO              0x0042
#define SGS_DAC_GAMEPORT_ANALOG_INPUT_1_HI              0x0043
#define SGS_DAC_GAMEPORT_ANALOG_INPUT_2_LO              0x0044
#define SGS_DAC_GAMEPORT_ANALOG_INPUT_2_HI              0x0045
#define SGS_DAC_GAMEPORT_ANALOG_INPUT_3_LO              0x0046
#define SGS_DAC_GAMEPORT_ANALOG_INPUT_3_HI              0x0047
#define SGS_DAC_GAMEPORT_ANALOG_INPUT_4_LO              0x0048
#define SGS_DAC_GAMEPORT_ANALOG_INPUT_4_HI              0x0049
#define SGS_DAC_GAMEPORT_ANALOG_INPUT_5_LO              0x004A
#define SGS_DAC_GAMEPORT_ANALOG_INPUT_5_HI              0x004B
#define SGS_DAC_GAMEPORT_ANALOG_INPUT_6_LO              0x004C
#define SGS_DAC_GAMEPORT_ANALOG_INPUT_6_HI              0x004D
#define SGS_DAC_GAMEPORT_ANALOG_INPUT_7_LO              0x004E
#define SGS_DAC_GAMEPORT_ANALOG_INPUT_7_HI              0x004F
#define SGS_DAC_CURSOR_COLOR_1_RED                      0x0050
#define SGS_DAC_CURSOR_COLOR_1_GREEN                    0x0051
#define SGS_DAC_CURSOR_COLOR_1_BLUE                     0x0052
#define SGS_DAC_CURSOR_COLOR_2_RED                      0x0054
#define SGS_DAC_CURSOR_COLOR_2_GREEN                    0x0055
#define SGS_DAC_CURSOR_COLOR_2_BLUE                     0x0056
#define SGS_DAC_CURSOR_COLOR_3_RED                      0x0057
#define SGS_DAC_CURSOR_COLOR_3_GREEN                    0x0058
#define SGS_DAC_CURSOR_COLOR_3_BLUE                     0x0059
#define SGS_DAC_CURSOR_PLANE_0_WRITE_0                  0x0100
#define SGS_DAC_CURSOR_PLANE_0_WRITE_7F                 0x017F
#define SGS_DAC_CURSOR_PLANE_1_WRITE_0                  0x0180
#define SGS_DAC_CURSOR_PLANE_1_WRITE_7F                 0x01FF
#define SGS_DAC_CURSOR_PLANE_0_READ_0                   0x0500
#define SGS_DAC_CURSOR_PLANE_0_READ_7F                  0x057F
#define SGS_DAC_CURSOR_PLANE_1_READ_0                   0x0580
#define SGS_DAC_CURSOR_PLANE_1_READ_7F                  0x05FF
#define SGS_DAC_TESTPOINT_0_0                           0xF000
#define SGS_DAC_TESTPOINT_0_1                           0xF001
#define SGS_DAC_TESTPOINT_0_2                           0xF002
#define SGS_DAC_TESTPOINT_0_3                           0xF003
#define SGS_DAC_TESTPOINT_0_4                           0xF004
#define SGS_DAC_TESTPOINT_0_5                           0xF005
#define SGS_DAC_TESTPOINT_0_6                           0xF006
#define SGS_DAC_TESTPOINT_0_7                           0xF007
#define SGS_DAC_TESTPOINT_1_0                           0xF008
#define SGS_DAC_TESTPOINT_1_1                           0xF009
#define SGS_DAC_TESTPOINT_1_2                           0xF00A
#define SGS_DAC_TESTPOINT_1_3                           0xF00B
#define SGS_DAC_TESTPOINT_1_4                           0xF00C
#define SGS_DAC_TESTPOINT_1_5                           0xF00D
#define SGS_DAC_TESTPOINT_1_6                           0xF00E
#define SGS_DAC_TESTPOINT_1_7                           0xF00F
#define SGS_DAC_TESTPOINT_3_0                           0xF010
#define SGS_DAC_TESTPOINT_3_1                           0xF011
#define SGS_DAC_TESTPOINT_3_2                           0xF012
#define SGS_DAC_TESTPOINT_3_3                           0xF013
#define SGS_DAC_TESTPOINT_3_4                           0xF014
#define SGS_DAC_TESTPOINT_3_5                           0xF015
#define SGS_DAC_TESTPOINT_3_6                           0xF016
#define SGS_DAC_TESTPOINT_3_7                           0xF017
#define SGS_DAC_TESTPOINT_4_0                           0xF018
#define SGS_DAC_TESTPOINT_4_1                           0xF019
#define SGS_DAC_TESTPOINT_4_2                           0xF01A
#define SGS_DAC_TESTPOINT_4_3                           0xF01B
#define SGS_DAC_TESTPOINT_4_4                           0xF01C
#define SGS_DAC_TESTPOINT_4_5                           0xF01D
#define SGS_DAC_TESTPOINT_4_6                           0xF01E
#define SGS_DAC_TESTPOINT_4_7                           0xF01F
#define SGS_DAC_CURSOR_TEST_0                           0xF028
#define SGS_DAC_CURSOR_TEST_1                           0xF029
#define SGS_DAC_CURSOR_TEST_2                           0xF02A
#define SGS_DAC_CURSOR_TEST_3                           0xF02B
#define SGS_DAC_CURSOR_TEST_4                           0xF02C
#define SGS_DAC_CURSOR_TEST_5                           0xF02D
#define SGS_DAC_CURSOR_TEST_6                           0xF02E
#define SGS_DAC_CURSOR_TEST_7                           0xF02F
#define SGS_DAC_FIFO_TEST_0                             0xF030
#define SGS_DAC_FIFO_TEST_1                             0xF031
#define SGS_DAC_FIFO_TEST_2                             0xF032
#define SGS_DAC_FIFO_TEST_3                             0xF033
#define SGS_DAC_FIFO_TEST_4                             0xF034
#define SGS_DAC_FIFO_TEST_5                             0xF035
#define SGS_DAC_FIFO_TEST_6                             0xF036
#define SGS_DAC_FIFO_TEST_7                             0xF037
#define SGS_DAC_MPLL_TEST_0                             0xF038
#define SGS_DAC_MPLL_TEST_1                             0xF039
#define SGS_DAC_MPLL_TEST_2                             0xF03A
#define SGS_DAC_MPLL_TEST_3                             0xF03B
#define SGS_DAC_MPLL_TEST_4                             0xF03C
#define SGS_DAC_MPLL_TEST_5                             0xF03D
#define SGS_DAC_MPLL_TEST_6                             0xF03E
#define SGS_DAC_MPLL_TEST_7                             0xF03F
#define SGS_DAC_VPLL_TEST_0                             0xF040
#define SGS_DAC_VPLL_TEST_1                             0xF041
#define SGS_DAC_VPLL_TEST_2                             0xF042 
#define SGS_DAC_VPLL_TEST_3                             0xF043
#define SGS_DAC_VPLL_TEST_4                             0xF044
#define SGS_DAC_VPLL_TEST_5                             0xF045
#define SGS_DAC_VPLL_TEST_6                             0xF046
#define SGS_DAC_VPLL_TEST_7                             0xF047
#define SGS_DAC_GAMEPORT_TEST_0                         0xF048
#define SGS_DAC_GAMEPORT_TEST_1                         0xF049
#define SGS_DAC_GAMEPORT_TEST_2                         0xF04A
#define SGS_DAC_GAMEPORT_TEST_3                         0xF04B
#define SGS_DAC_GAMEPORT_TEST_4                         0xF04C
#define SGS_DAC_GAMEPORT_TEST_5                         0xF04D
#define SGS_DAC_GAMEPORT_TEST_6                         0xF04E
#define SGS_DAC_GAMEPORT_TEST_7                         0xF04F
#define SGS_DAC_TESTPOINT_CTRL                          0xF058
#define SGS_DAC_TESTPOINT_TIMER                         0xF059
#define SGS_DAC_TEST_CTRL                               0xF05A
#define SGS_DAC_MISC_TEST_STATE                         0xF05B
#define SGS_DAC_TEST_OUT_CTRL                           0xF05C
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\rm.h ===
/**************************************************************************************************************
*
*   File:  rm.h
*
*   Description:
*       Definitions for the use of and entry points into the resource manager library from the miniport.
*
**************************************************************************************************************/

// notify callback action
#define NV_OS_WRITE_THEN_AWAKEN     0x00000001

// power state definitions used by RmSet/GetPowerState() and RmGetCurrentPowerState()
#define NV_POWER_ADAPTER_STATE_0            0x00000001 // full on
#define NV_POWER_ADAPTER_STATE_1            0x00000002 // slowed clocks
#define NV_POWER_ADAPTER_STATE_2            0x00000004 // slowed clocks, mobile style *** not all devices supported ***
#define NV_POWER_ADAPTER_STATE_3            0x00000008 // very slow clocks, state saved (regs & instance memory)
#define NV_POWER_ADAPTER_STATE_4            0x00000010 // future lower adapter power state
#define NV_POWER_ADAPTER_STATE_5            0x00000020 // future lower adapter power state
#define NV_POWER_ADAPTER_STATE_6            0x00000040 // future lower adapter power state
#define NV_POWER_ADAPTER_STATE_7            0x00000080 // future lower adapter power state
#define NV_POWER_ADAPTER_FEATURE_CTXSAVED   0x00000100 // lowest power consumption state saves device context
#define NV_POWER_ADAPTER_STATE_HIBERNATE    0x00000200 // adapter hibernate
#define NV_POWER_ADAPTER_FEATURE_UNDEF_2    0x00000400 // future feature
#define NV_POWER_ADAPTER_FEATURE_UNDEF_3    0x00000800 // future feature
#define NV_POWER_ADAPTER_FEATURE_UNDEF_4    0x00001000 // future feature
#define NV_POWER_ADAPTER_FEATURE_UNDEF_5    0x00002000 // future feature
#define NV_POWER_ADAPTER_FEATURE_UNDEF_6    0x00004000 // future feature
#define NV_POWER_ADAPTER_FEATURE_UNDEF_7    0x00008000 // future feature
#define NV_POWER_MONITOR_STATE_0            0x00010000 // full on
#define NV_POWER_MONITOR_STATE_1            0x00020000 // no VSYNC nor HSYNC
#define NV_POWER_MONITOR_STATE_2            0x00040000 // future lower monitor power state 

#define NV_POWER_MONITOR_STATE_3            0x00080000 // future lower monitor power state
#define NV_POWER_MONITOR_STATE_4            0x00100000 // future lower monitor power state
#define NV_POWER_MONITOR_STATE_5            0x00200000 // future lower monitor power state
#define NV_POWER_MONITOR_STATE_6            0x00400000 // future lower monitor power state
#define NV_POWER_MONITOR_STATE_7            0x00800000 // future lower monitor power state
#define NV_POWER_MONITOR_STATE_HIBERNATE    0x01000000 // monitor hibernate
#define NV_POWER_UNDEF_1                    0x02000000 // future attribute
#define NV_POWER_UNDEF_2                    0x04000000 // future attribute
#define NV_POWER_UNDEF_3                    0x08000000 // future attribute
#define NV_POWER_UNDEF_4                    0x10000000 // future attribute
#define NV_POWER_UNDEF_5                    0x20000000 // future attribute
#define NV_POWER_UNDEF_6                    0x40000000 // future attribute
#define NV_POWER_UNDEF_7                    0x80000000 // future attribute

// prototype of callback fct -- the parameter is the device extension
typedef VOID (*MINIPORT_CALLBACK)(VOID*);

BOOL    RmInitRm            (VOID);
BOOL    RmInitNvMapping     (VOID*, U032, PHWREG, U032*);
BOOL    RmPostNvDevice      (U032, PHWREG, PHWREG);
BOOL    RmInitNvDevice      (U032, U032, PHWREG);
BOOL    RmInitNvHal         (U032);
BOOL    RmLoadState         (U032, U032, U032, U032, U032, BOOL);
BOOL    RmUnloadState       (U032);
BOOL    RmUpdateAGPConfig   (U032);
BOOL    RmSetMode           (U032,U032,U032,U032,U032,U032,U032,U032,U032,U032,U032,U032,U032,U032,U032,U032,U032,U032,U032,U032,U032);
BOOL    RmIsr               (U032);
BOOL    RmConfigGetKernel   (U032, U032, U032*);
BOOL    RmConfigGetExKernel (U032, U032, VOID*, U032);
BOOL    RmConfigSetKernel   (U032, U032, U032, U032*);
BOOL    RmConfigSetExKernel (U032, U032, VOID*, U032);
#if (_WIN32_WINNT >= 0x0500)
VOID    RmSetAgpServices    (U032, VOID*);
#endif
BOOL    RmPreModeSet        (U032, U032);
BOOL    RmPostModeSet       (U032, U032);

BOOL    RmSetDisplayPowerState      (U032, U032, BOOL);
BOOL    RmEnableHead                (U032, U032);
BOOL    RmSetPowerState             (U032 deviceReference, U032 head, U032 state);
BOOL    RmGetCurrentPowerState      (U032 deviceReference, U032 head, U032* pState);
BOOL    RmGetPowerCaps              (U032 deviceReference, U032 head, U032* pCaps);
BOOL    RmSetDriverHotkeyHandling   (U032 deviceReference, BOOL enabled);
VP_STATUS  RMVideoResetDevice       (U032 deviceReference);

VOID    Nv01AllocRoot       (NVOS01_PARAMETERS*);
VOID    Nv01AllocDevice     (NVOS06_PARAMETERS*);
VOID    Nv01AllocContextDma (NVOS03_PARAMETERS*);
VOID    Nv01AllocChannelPio (NVOS04_PARAMETERS*);
VOID    Nv03AllocChannelDma (NVOS07_PARAMETERS*);
VOID    Nv01AllocMemory     (NVOS02_PARAMETERS*);
VOID    Nv01AllocObject     (NVOS05_PARAMETERS*);
VOID    Nv01AllocEvent      (NVOS10_PARAMETERS*);
VOID    Nv04Alloc           (NVOS21_PARAMETERS*);
VOID    Nv01Free            (NVOS00_PARAMETERS*);
VOID    Nv03DmaFlowControl  (NVOS08_PARAMETERS*);
VOID    Nv03ArchHeap        (NVOS11_PARAMETERS*);
VOID    Nv01ConfigVersion   (NVOS12_PARAMETERS*);
VOID    Nv01ConfigGet       (NVOS13_PARAMETERS*);
VOID    Nv01ConfigSet       (NVOS14_PARAMETERS*);
VOID    Nv04ConfigGetEx     (NVOS_CONFIG_GET_EX_PARAMS*);
VOID    Nv04ConfigSetEx     (NVOS_CONFIG_SET_EX_PARAMS*);
VOID    Nv01ConfigUpdate    (NVOS15_PARAMETERS*);
VOID    Nv01DebugControl    (NVOS20_PARAMETERS*);
VOID    Nv04I2CAccess       (NVOS_I2C_ACCESS_PARAMS *);
VOID    Nv04DirectMethodCall(NVOS1D_PARAMETERS*);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\vpelocal.h ===
/*
==============================================================================

    NVIDIA Corporation, (C) Copyright 
    1996,1997,1998,1999. All rights reserved.

    vpelocal.h

    Local definitions used by vpe and kernel mode video transport

    Jun 08, 1999

==============================================================================
*/

#define INITGUID     // Instantiate GUID_DxApi

#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"
#include "ntddvdeo.h"
#include "video.h"

typedef unsigned long   DWORD;
// Commented out benign redefinition// typedef int              BOOL;

#include "nv.h"
#include "nv32.h"
#include "nvos.h"

#include "dxmini.h"

#ifndef NTSTATUS
typedef LONG NTSTATUS;
#endif
#define PDEVICE_OBJECT  PVOID
#include "i2cgpio.h"

//// VPE/miniport interface 
#include "vpemini.h"

/////// VPP interface
//#include "nvreg.h"
//#include "ddvpp.h"
///////

#ifdef _TIMER_TEST
typedef struct _NVP_INIT_OBJECT
{
    Nv03ChannelPio *pChannel;
    U032 uTimerLo;
    U032 uTimerHi;
} NVP_INIT_OBJECT;
#endif

#define NVP_CLASS04D_MAX_NOTIFIERS          9
#define NVP_CLASS039_MAX_NOTIFIERS          2
#define NVP_CLASS07A_MAX_NOTIFIERS          3

#define NVP_VPP_TIME_OUT    10000

///////
/// BUGBUG: taken from dvp.h !!! 
#define DDVP_AUTOFLIP                   0x00000001l
#define DDVP_INTERLEAVE                 0x00000008l
#define DDVP_SKIPEVENFIELDS             0x00000080l
#define DDVP_SKIPODDFIELDS              0x00000100l
#define DDVPCONNECT_INVERTPOLARITY      0x00000004l
#define DDVPCONNECT_INTERLACED          0x00000020l

#define NV_VFM_FORMAT_BOBFROMINTERLEAVE 0x08000000l

/// equivalent in nvReg.h
#define VPP_ODD            0x001
#define VPP_EVEN           0x002
#define VPP_BOB            0x004
#define VPP_INTERLEAVED    0x008
#define VPP_PRESCALE       0x400

#define NV_PRESCALE_OVERLAY_X           1
#define NV_PRESCALE_OVERLAY_Y           2
#define NV_PRESCALE_OVERLAY_FIELD       4

#define IS_FIELD(f) ((f & (VPP_INTERLEAVED | VPP_BOB)) && (f & (VPP_ODD | VPP_EVEN)))

#ifndef NV_IN_PROGRESS
#define NV_IN_PROGRESS (0x8000)
#endif

#define NV_OVERLAY_BYTE_ALIGNMENT_PAD   63L
#define NV_OVERLAY_BYTE_ALIGNMENT       64L


#ifdef  asmMergeCoords
#undef  asmMergeCoords
#endif
#define asmMergeCoords(LOWWORD, HIWORD) \
        (long)(((long)HIWORD << 16) | (unsigned short)LOWWORD)

///////////
// external services
//
extern void KeClearEvent(void *hEvent);
extern U032 RmAllocChannelDma(U032, U032, U032, U032, U032, U032, U032, U032 *);
extern U032 RmAllocObject(U032, U032, U032, U032);
extern U032 RmFree(U032, U032, U032);
extern U032 RmAllocContextDma(U032, U032, U032, U032, U032, U032, U032);
//extern U032 RmAllocEvent(NVOS10_PARAMETERS *);
extern U032 Nv01AllocEvent(NVOS10_PARAMETERS *);
extern U032 RmInterrupt(NVOS09_PARAMETERS *);
extern NTSTATUS miniI2COpen (PDEVICE_OBJECT pDev, ULONG acquire, PI2CControl pI2CCtrl);
extern NTSTATUS miniI2CAccess (PDEVICE_OBJECT pDev, PI2CControl pI2CCtrl);
//#define _MEASURE_TIMING
#ifdef _MEASURE_TIMING
extern int osGetCurrentTime(U032 *year,U032 *month,U032 *day,U032 *hour,U032 *min,U032 *sec,U032 *msec);
#endif

#ifndef NvGetFreeCount
#if defined NV10 || defined NV4
#define NvGetFreeCount(NN, CH)\
         (NN)->subchannel[CH].control.Free
#else   /* !(NV10 || NV4) */
#define NvGetFreeCount(NN, CH)\
         (NN)->subchannel[CH].control.free
#endif  /* !(NV10 || NV4) */
#endif

//////////
// DMA channel macros
//
#define NVP_JUMP(ADDR)      (0x20000000 | (ADDR))
#define NVP_DECODER_SUBCHANNEL  0
#define NVP_M2M_SUBCHANNEL      1
#define NVP_DMAPUSH_WRITE1(SUBCH, METHOD_OFFSET, METHOD_VALUE)                          \
{\
    pVPEContext->nvDmaFifo[nvDmaCount++] = ((1 <<18) | ((SUBCH)<<13) | (METHOD_OFFSET)); \
    pVPEContext->nvDmaFifo[nvDmaCount++] = METHOD_VALUE;                                    \
}
// assuming the FIFO is at least twice (2x + 1) the size of NEEDED_DWORDS
#define NVP_DMAPUSH_CHECK_FREE_COUNT(NEEDED_DWORDS)     \
{   \
    if ((nvDmaCount + (NEEDED_DWORDS)) >= (pVPEContext->DmaPushBufTotalSize >> 2))  \
    {   \
        pVPEContext->nvDmaFifo[nvDmaCount] = 0x20000000;    \
        nvDmaCount = 0; \
        VideoDebugPrint((0,"VPEMINI: DMA wrap around...\n"));   \
    }   \
}

////////////
// local functions prototypes
//
void VideoField0Notify(PVOID pHwDeviceExtension);
void VideoField1Notify(PVOID pHwDeviceExtension);
void VBIField0Notify(PVOID pHwDeviceExtension);
void VBIField1Notify(PVOID pHwDeviceExtension);
void NVPProgVideoField(PNVP_CONTEXT pVPEContext, PNVP_SURFACE_INFO pSurface, int nFieldId, U032 dwSurfPitch, U032 dwInterleaveOffset, BOOL bGrab);
void NVPProgVBIField(PNVP_CONTEXT pVPEContext, PNVP_SURFACE_INFO pSurface, int nFieldId);
VP_STATUS NVPProcessState(PHW_DEVICE_EXTENSION pHwDevExt, int nFieldId, BOOL bVBIField);
VP_STATUS NVPScheduleOverlayFlip(PNVP_CONTEXT pVPEContext, PNVP_SURFACE_INFO pSurface, int  nImageId, U032 dwSrcPitch, U032 dwMoveDownOffset);
U032 NVPScaleDown(PNVP_CONTEXT pVPEContext, PNVP_OVERLAY pOvr, int nFieldId);
VP_STATUS DoProgressive(PNVP_CONTEXT pVPEContext, int nFieldId);
VP_STATUS DoWeave(PNVP_CONTEXT pVPEContext, int nFieldId);
VP_STATUS DoBob(PNVP_CONTEXT pVPEContext, int nFieldId);
VP_STATUS DoBobFromInterleaved(PNVP_CONTEXT pVPEContext, int nFieldId);
BOOL NVPGetSurface( PNVP_CONTEXT pVPEContext,U032 dwSurfOffset, PNVP_SURFACE_INFO *pSurface);
void NVPTransferNotify(PVOID pHwDevExtension);
DWORD NVPCheckTransferStatus(PHW_DEVICE_EXTENSION pHwDevExt);
DWORD NVPCancelTransfer(PNVP_CONTEXT pVPEContext, PDDTRANSFERININFO pInInfo);
DWORD NVPRemoveTransfer(PNVP_CONTEXT pVPEContext, int nTransferIdx);
DWORD NVPAddTransfer(PNVP_CONTEXT pVPEContext, PDDTRANSFERININFO pInInfo, BOOL bIsOddField);
DWORD NVPGetTransferStatus(PVOID pContext, PVOID pNotUsed, PDDGETTRANSFEROUTINFO pOutInfo);
DWORD NVPCheckForLaunch(PNVP_CONTEXT pVPEContext, PNVP_SURFACE_INFO pSurface);
DWORD NVPRecreateContext(PNVP_CONTEXT pVPEContext, PMDL pDestMDL);
DWORD NVPTransfer(PVOID pContext, PDDTRANSFERININFO pInInfo, PDDTRANSFEROUTINFO pOutInfo);
PVOID GetHwInfo(PVOID HwDevExt);
BOOL NVPPrescaleAndFlip(PNVP_CONTEXT pVPEContext, PNVP_OVERLAY pOverlayInfo, DWORD dwOffset, DWORD dwPitch, DWORD dwIndex, DWORD dwFlags);
VP_STATUS NVPFlipVideoPort(PHW_DEVICE_EXTENSION pHwDevExt, NVP_CMD_OBJECT *pCmdObj);

/////////////////
// prototypes
//
DWORD GetIrqInfo(
    PVOID HwDeviceExtension,
    PVOID lpInput,
    PDDGETIRQINFO GetIrqInfo);

VP_STATUS NVQueryInterface(
    PVOID HwDeviceExtension,
    PQUERY_INTERFACE QueryInterface);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\tv.h ===
#ifndef _TV_H_
#define _TV_H_
//
// (C) Copyright NVIDIA Corporation Inc., 1995,1996. All rights reserved.
//
/***************************************************************************\
*                                                                           *
* Module: TV.H                                                              *
*       The TV flicker filter constants are defined in this module.         *
*                                                                           *
*****************************************************************************
*/

//---------------------------------------------------------------------------
//
//  Defines.
//
//---------------------------------------------------------------------------

#define	MY_SCALED_IMAGE_CTX	0x97100200
#define	X_RES	(640)		// source x
#define	Y_RES	(480)		// source y
//#define DST_X_RES (640)		// destination x
//#define DST_Y_RES (480)		// destination y
#define DST_X_RES (620)		// destination x
#define DST_Y_RES (420)		// destination y
#endif // _TV_H#
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\vpemini.h ===
#define _USE_DMA

#define NVP_MAX_EXTRA_SURF_422    10

// data structure used to communicate with miniport
typedef struct _NVP_CMD_OBJECT {
	U032		dwSize;
	U032		dwChipId;	// chip version Id
	U032		dwPortId;	// usually 0 unless there are more than one VP on the chip
	U032		dwDeviceId;	// NV_WIN_DEVICE
	U032		dwSrvId;	// service ID	
	U032		hClient;
	U032        pChannel;		// VPE pio channel
	U032        pOvrChannel;  	// Overlay channel
	U032		dwOvrSubChannel;
	U032		pFrameBuffer;
	U032		dwFBLen;


	U032		dwOverlayObjectID;
	U032		dwScalerObjectID;
	U032		dwDVDObjectID;
    U032        dwDVDObjectCtxDma;
	// VP flags
	U032		dwVPTypeFlags;	// VP connection flag
	U032		dwVPInfoFlags;

	// image attributes
	U032		dwImageStartLine;
	U032		dwVBIStartLine;
	U032		dwInWidth;
	U032		dwInHeight;
	U032		dwPreWidth;
	U032		dwPreHeight;
	U032		dwOriginX;
	U032		dwOriginY;
	U032		dwVBIHeight;

	// surface
	U032		pSurfVidMem;	// address of surface
	U032		dwSurfaceId;	// 0 based surface index 
	U032		dwSurfPitch;	// in bytes
	U032		dwSurfOffset;	// offset from the beginning of the framebuffer
	U032		bSurfVBI;		// TRUE if VBI surface, FALSE for video
	U032		bSurfUpdate;	// TRUE if updating the surfaces attibutes only

	// overlay
	U032 		dwOverlayFormat;
	U032 		dwOverlaySrcX;
	U032 		dwOverlaySrcY;
	U032 		dwOverlaySrcPitch;
	U032 		dwOverlaySrcSize;
	U032 		dwOverlaySrcWidth;
	U032 		dwOverlaySrcHeight;
	U032 		dwOverlayDstWidth;
	U032 		dwOverlayDstHeight;
	U032        dwOverlayDstX;
    U032        dwOverlayDstY;
	U032        dwOverlayDeltaX;
	U032        dwOverlayDeltaY;
	U032        dwOverlayColorKey;
	U032        dwOverlayMode;
	U032        dwOverlayMaxDownScale;
	U032 		aExtra422OverlayOffset[NVP_MAX_EXTRA_SURF_422];
    U032        dwExtra422NumSurfaces;
	U032        dwExtra422Index;
	U032        dwExtra422Pitch;
    U032        pNvPioFlipOverlayNotifierFlat;

    // VPE vsync events
    U032        hVPSyncEvent;

} NVP_CMD_OBJECT, *PNVP_CMD_OBJECT;

// data structure used to communicate with miniport
typedef struct _NVP_VPP_DISPATCH {
	U032		dwSize;
	U032		dwFlags;
	U032		dwOffset;
	U032		dwWidth;
	U032		dwHeight;
	U032		dwFourCC;
} NVP_VPP_DISPATCH, *PNVP_VPP_DISPATCH;

// Service ID used by NVP_CMD_OBJECT
#define NVP_SRV_INITIALIZE		0x01
#define NVP_SRV_UNINITIALIZE	0x02
#define NVP_SRV_START_VIDEO		0x03
#define NVP_SRV_STOP_VIDEO		0x04
#define NVP_SRV_UPDATE_VIDEO	0x05
#define NVP_SRV_REG_SURFACE		0x06
#define NVP_SRV_UPDATE_OVERLAY	0x07
#define NVP_SRV_PROG_STATE		0x08
#define NVP_SRV_FLIP_VIDEOPORT  0x09

// NVP object, channels and events
#define NVP_VPE_CHANNEL						0xA0010001
#define NVP_EXTERNAL_DECODER_OBJECT			0xA0010002
#define NVP_EXTERNAL_DECODER_NOTIFIER		0xA0010003
#define NVP_VIDEO_FIELD0_BUFFER_CONTEXT		0xA0010004
#define NVP_VIDEO_FIELD1_BUFFER_CONTEXT		0xA0010005
#define NVP_VBI_FIELD0_BUFFER_CONTEXT		0xA0010006
#define NVP_VBI_FIELD1_BUFFER_CONTEXT		0xA0010007
#define NVP_VIDEO_FIELD0_BUFFER_EVENT		0xA0010008
#define NVP_VIDEO_FIELD1_BUFFER_EVENT		0xA0010009
#define NVP_VBI_FIELD0_BUFFER_EVENT			0xA001000A
#define NVP_VBI_FIELD1_BUFFER_EVENT			0xA001000B
#define NVP_M2M_OBJECT						0xA001000C
#define NVP_M2M_NOTIFIER					0xA001000D
#define NVP_M2M_CONTEXT						0xA001000E
#define NVP_M2M_FROM_CONTEXT				0xA001000F
#define NVP_M2M_EVENT						0xA0020001
#define NVP_DMA_PUSHBUF_ERROR_NOTIFIER		0xA0020002
#define NVP_DMA_FROM_MEMORY_PUSHBUF			0xA0020003

#define NVP_OVERLAY_OBJECT                  0xA0020004
#define NVP_DVD_SUBPICTURE_OBJECT           0xA0020005
#define NVP_OVERLAY_NOTIFIER                0xA0020006
#define NVP_DVD_SUBPICTURE_CONTEXT          0xA0020007
#define NVP_OVERLAY_BUFFER_CONTEXT          0xA0020008

#define NVP_VSYNC_EVENT0					0xA0020009
#define NVP_VSYNC_EVENT1					0xA002000A

///// methods are equivalent to NV10_VIDEO_OVERLAY
#ifndef NV04_VIDEO_OVERLAY
#define NV04_VIDEO_OVERLAY (0x00000047)
#endif

// field definition (corresponds to H/W def)
#define NVP_FIELD_EVEN			0x00
#define NVP_FIELD_ODD			0x01

// VP state
#define NVP_STATE_STOPPED		0x01L
#define NVP_STATE_STARTED		0x02L
#define NVP_STATE_STARTED_VIDEO	0x04L
#define NVP_STATE_STARTED_VBI	0x10L

#define NVP_STOP_VIDEO          0x01L
#define NVP_STOP_VBI            0x02L

// End of Queue
#define NVP_EOQ		(-1)
#define NVP_UNDEF	(0xFFFFFFFF)

#define NVPE_VSYNC_EVENT_NAME	L"NVPE_VSYNc_EVENT"

// NV chip versions
#define NVP_GET_CHIP_VER(ver)	((ver) & 0xFFFF)

#define NVP_CHIP_VER_03			0x03
#define NVP_CHIP_VER_04			0x04
#define NVP_CHIP_VER_05			0x05
#define NVP_CHIP_VER_10			0x10

/* NV Device Version Numbers */
#define NV_DEVICE_VERSION_4     0x0004
#define NV_DEVICE_VERSION_5     0x0005
#define NV_DEVICE_VERSION_10    0x0010
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\modeset.mhd\CODE\digmode.h ===
/*
    FILE:   digmode.h
    DATE:   4/8/99

    This file contains the code for mode setting/determination
    ona CRT or FLAT PANEL. OS independent.
*/

extern int CFUNC FindDigModeEntry (LPCHAR lpEdidBuffer, ULONG dwEdidSize,
                        LPDISPDATA lpDispData, LPMODEINFO lpModeDesc,
                        LPMODEOUT lpModeOut, LPMODEENTRY lpModeList,
                        LPRESTIME lpRTList);
extern int CFUNC CheckTimingStandardOverride (LPCHAR lpEdidBuffer,
                        ULONG dwEdidSize, LPDISPDATA lpDispData,
                        LPMODEINFO lpModeDesc, LPMODEOUT lpModeOut);
extern int CFUNC BackOffDigModeEntry (LPMODEENTRY lpModeList,
                        LPMODEINFO lpModeDesc, LPMODEINFO lpModeOrig, int iRRFlag);
extern int CFUNC ProcessRTWithDigModeEntry (LPDISPDATA lpDispData,
                        LPCHAR lpEdidBuffer,
                        ULONG dwEdidSize, LPRESTIME lpRTList,
                        LPMODEINFO lpModeDesc, LPMODEOUT lpModeOut);
extern int CFUNC ModeWithinMonitorTimingLimits (LPDISPDATA lpDispData,
                        LPMODEOUT lpModeOut,
                        LPCHAR lpEdidBuffer, ULONG dwEdidSize);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\vpewrap.c ===
//***************************************************************************
//  Module Name:
//
//      vpewrap.c
//
//  Abstract:
//
//      This module contains the miniport parts of the DXAPI "kernel-mode
//      VPE" interface for the .
//
//      The DirectDraw Video Port Extensions (VPE) are the services that
//      control hardware videoports, where video data is streamed into
//      off-screen memory from an external device such as a TV tuner or
//      MPEG decoder, and then displayed on the screen by a video overlay.
//
//      To support VPE, you'll need the following:
//
//          1. A 2-D driver with DirectDraw overlay support;
//          2. A video input device that interfaces with the videoport;
//          3. A bunch of VPE code in the display driver;
//          4. A bunch of VPE code here in the miniport.
//
//      The miniport code here comprises part of the DXAPI "kernel-mode
//      VPE" interface that can be called by other WDM drivers, such as
//      an MPEG driver.
//
// IMPORTANT NOTE ABOUT HARDWARE REQUIREMENTS:
//
//      Almost all of these miniport "kernel-mode VPE" routines may be
//      called asynchronously to what the display driver is currently
//      doing.  For example, a thread may be in the display driver in the
//      middle of programming an accelerated Blt at the exact moment that
//      the miniport gets called to do a videoport flip call.  Consequently,
//      your hardware MUST be able to handle these commands at any time
//      regardless of the state of the display driver.  So this means:
//
//          1. Your hardware has to be able to allow the programming of any
//             "kernel-mode VPE" command even while Blts or direct frame
//             buffer accesses or DMAs or whatever are occuring, without
//             hanging or incorrect drawing.
//
//          2. The registers used to program any of the "kernel-mode VPE"
//             services must be disjoint and separate from those used by
//             the display driver.  If you must program an indexed register
//             that is also used by the display driver (such as 0x3d4/0x3d5),
//             *YOU ARE PROBABLY TOAST*.  Both a thread in the display driver
//             and a thread calling these miniport services are preemptible,
//             meaning that even if you save and restore the index register,
//             there's no guarantee that the other thread won't wake up in
//             the middle and try to use the same (now incorrectly set)
//             register.
//
//      If your hardware does not guarantee both of the above, you CANNOT
//      support the "kernel-mode VPE" interface!  Go yell at your hardware
//      designers and get them to fix the hardware.  If both of the above
//      are not guaranteed, it's inevitable that your customers will randomly
//      hit system hangs and crashes while using VPE.  Your customers will
//      not be happy!
//
//      Also note that the likelihood of hitting a problem is significantly
//      increased when running on a multiple-processor machine.  Consequently,
//      you should try to test VPE on an MP machine while applications (such
//      as Winstone) are running in the background.
//
//      (Okay, okay, so I exaggerated a bit about pointer number 2.  You can
//      in fact use shared indexed registers in these VPE routines if you do
//      one of the following:
//
//          1. Disable VPE on multiple-processor machines.  (As of the time
//             of this writing, we haven't yet implemented a VideoPort or
//             Eng function that you can call to determine whether you're
//             running on a UP or MP machine, otherwise I would tell you
//             the name of the function to call.  But by the time you read
//             this, it will probably exist -- so have a look through the
//             VideoPort and Eng calls...)
//
//             You'll also have to save and restore the index register when
//             you're done.  Because a thread that calls a miniport function
//             is at raised IRQL, it may interrupt a thread in the display
//             driver at any point, but on a UP machine it's guaranteed that
//             the display driver thread will not interrupt the miniport
//             thread.
//
//          2. Use the CRTC register only in the DxEnableIrq routine --
//             DirectDraw automatically synchronizes with the display driver
//             before calling DxEnableIrq (this is not true for any other
//             Dx miniport calls).
//
// NOTE:
//
//      Most "kernel-mode VPE" routines can be called at raised IRQL, meaning
//      that they MUST be non-paged, and cannot call any pageable functions.
//
//  Environment:
//
//      Kernel mode
//
//  Copyright (c) 1997 Microsoft Corporation
//
//***************************************************************************

#ifdef VPE_NT

#include "dderror.h"
#include "miniport.h"
#include "ntddvdeo.h"
#include "video.h"

typedef unsigned long   DWORD;
// Commented out benign redefinition// typedef int      BOOL;

#define INITGUID     // Instantiate GUID_DxApi
#include "dxmini.h"

#include "nv.h"

DWORD
GetIrqInfo(
    PVOID HwDeviceExtension,
    PVOID lpInput,
    PDDGETIRQINFO GetIrqInfo
    );

VP_STATUS
nvVPEQueryInterface(
    PVOID HwDeviceExtension,
    PQUERY_INTERFACE QueryInterface
    );

//
// Mark those routines that we can as pageable.  Remember that most
// "kernel-mode VPE" routines can be called at raised IRQL, which means
// that they must be kept non-paged.
//
// Note that these are the only two VPE miniport routines which may be
// pageable:
//

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,nvVPEQueryInterface)
#pragma alloc_text(PAGE,GetIrqInfo)
#endif

// !!! Not hooking Lock is success, but not hooking SetPattern is failure?
// !!! Should dwFlags be ANDed or EQUALed?  (SkipNextField)
// !!! Should we mark the interrupt as unsharable?

DWORD
GetIrqInfo(
    PVOID HwDeviceExtension,
    PVOID lpInput,
    PDDGETIRQINFO GetIrqInfo
    )

/*++

Routine Description:

    On NT, the miniport always has to "manage the IRQ" (to borrow from the
    Win95 terminology).  Consequently, this routine simply tells DirectDraw
    what interrupts we support.

    It's actually pretty easy to enable interrupts, in part because you
    don't have to tell the system what interrupt vector you're using, as
    PNP already knows that.  However, you *do* have to check whether PNP
    successfully assigned you an interrupt vector, before you tell DirectDraw
    that you support interrupts.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    GetIrqInfo - Function parameters.

Return Value:

    DX_OK if successful.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    DWORD status = DXERR_UNSUPPORTED;

    //
    // Sometimes, the motherboard BIOS or PNP may conspire to refuse to
    // allocate an interrupt to us.  So before we tell DirectDraw that
    // we support interrupts, we must first check if we've actually been
    // assigned one!
    //

    if ((hwDeviceExtension->BusInterruptLevel != 0) ||
        (hwDeviceExtension->BusInterruptVector != 0)) {

        GetIrqInfo->dwFlags = IRQINFO_HANDLED;

        status = DX_OK;
    }

    return status;
}

BOOLEAN
Interrupt(
    PVOID HwDeviceExtension
    )

/*++

Routine Description:

    This routine is the interrupt service routine for the kernel video
    driver.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's adapter information.

Return Value:

    TRUE if the interrupt is serviced; FALSE if it wasn't ours (this is done
    to support chained interrupts).

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    // add your IRQ handling code here
}

DWORD
EnableIrq(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PDDENABLEIRQINFO EnableIrqInfo,
    PVOID lpOutput
    )

/*++

Routine Description:

    This function notifies the miniport when it should enable or disable
    interrupts for VPE.  If an IRQ is not specified in this call, it
    should be disabled.

    On NT, since miniports always "manage the IRQ", we must call DirectDraw's
    IRQCallback routine from our HwInterrupt routine to notify DirectDraw
    whenever an interrupt occurs.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    EnableIrqInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    //
    // First make sure we stash IRQCallback in our device extension before
    // enabling interrupts for the first time, otherwise we may call a NULL
    // pointer from our HwInterrupt routine!
    //
    // (Note that DirectDraw will give us a valid IRQCallback and lpIRQData
    // even when disabling interrupts, which means we won't crash if an
    // interrupt is taken between this point and the actual disabling of the
    // interrupt.)
    //

    hwDeviceExtension->IRQCallback = EnableIrqInfo->IRQCallback;
    hwDeviceExtension->pIRQData = EnableIrqInfo->lpIRQData;

    //
    // Clear any existing interrupts, turn off all interrupts by default,
    // and enable the new requested interrupts.
    //
    // NOTE: Be very careful if your driver uses interrupts for purposes
    //       other than VPE.  For example, if your display driver uses DMA,
    //       you probably won't want to clear the DMA interrupt flag here!
    //

    // Now enable the master interrupt switch.  Again, be careful if your
    // display driver uses interrupt for purposes other than VPE -- you
    // probably won't want to disable all video interrupts here like we
    // do!
    //
    // Note: DxEnableIrq is the only routine that may access the CRTC
    //       registers!  For more details, read the large note at the
    //       top of this file.
    //

    // If the vsync interrupt has been disabled, but a deferred overlay
    // offset is pending, flush it now.
    //

    return DX_OK;
}


DWORD
FlipVideoPort(
    PVOID HwDeviceExtension,
    PDDFLIPVIDEOPORTINFO FlipVideoPortInfo,
    PVOID lpOutput
    )

/*++

Routine Description:

    This function flips the video port to the target surface.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    FlipVideoPortInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    ULONG offset;

    //
    // Get offset (from framebuffer) and add offset from surface:
    //

    offset = FlipVideoPortInfo->lpTargetSurface->dwSurfaceOffset
           + FlipVideoPortInfo->lpVideoPortData->dwOriginOffset;

    // flip the actual hw surface here

    return DX_OK;
}


DWORD
FlipOverlay(
    PVOID HwDeviceExtension,
    PDDFLIPOVERLAYINFO FlipOverlayInfo,
    PVOID lpOutput
    )

/*++

Routine Description:

    This function flips the overlay to the target surface.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    FlipOverlayInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    return DX_OK;
}


DWORD
BobNextField(
    PVOID HwDeviceExtension,
    PDDBOBNEXTFIELDINFO BobNextFieldInfo,
    PVOID lpOutput
    )

/*++

Routine Description:

    This function is called when "bob" is used and a VPORT VSYNC occurs
    that does not cause a flip to occur (e.g., bobbing while interleaved).
    When bobbing, the overlay must adjust itself on every VSYNC, so this
    function notifies it of the VSYNCs that it doesn't already know about
    (e.g., VSYNCs that trigger a flip to occur).

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    BobNextFieldInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    return DX_OK;
}


DWORD
SetState(
    PVOID HwDeviceExtension,
    PDDSETSTATEININFO SetStateInInfo,
    PDDSETSTATEOUTINFO SetStateOutInfo
    )

/*++

Routine Description:

    This function is called when the client wants to switch from bob to
    weave.  The overlay flags indicate which state to use.  This is only
    called for interleaved surfaces.

    Note that when this is called, the specified surface may not be
    displaying the overlay (due to a flip).  Instead of failing the call,
    change the bob/weave state for the overlay that would be used if the
    overlay was flipped again to the specified surface.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    SetStateInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    return DX_OK;
}


DWORD
SkipNextField(
    PVOID HwDeviceExtension,
    PDDSKIPNEXTFIELDINFO SkipNextFieldInfo,
    PVOID lpOutput
    )

/*++

Routine Description:

    This function is called when the client wants to skip the next field,
    usually to undo a 3:2 pulldown but also for decreasing the frame
    rate.  The driver should not lose the VBI lines if dwVBIHeight contains
    a valid value.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    SkipNextFieldInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    return DX_OK;
}


DWORD
GetPolarity(
    PVOID HwDeviceExtension,
    PDDGETPOLARITYININFO GetPolarityInInfo,
    PDDGETPOLARITYOUTINFO GetPolarityOutInfo
    )

/*++

Routine Description:

    This function returns the polarity of the current field being written
    to the specified video port.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    GetPolarityInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    return DX_OK;
}

DWORD
GetCurrentAutoflip(
    PVOID HwDeviceExtension,
    PDDGETCURRENTAUTOFLIPININFO GetCurrentAutoflipInInfo,
    PDDGETCURRENTAUTOFLIPOUTINFO GetCurrentAutoflipOutInfo
    )

/*++

Routine Description:

    This function returns the current surface receiving data from the
    video port while autoflipping is taking place.  Only called when
    hardware autoflipping.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    GetCurrentAutoflipInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    return DX_OK;
}


DWORD
GetPreviousAutoflip(
    PVOID HwDeviceExtension,
    PDDGETPREVIOUSAUTOFLIPININFO GetPreviousAutoflipInInfo,
    PDDGETPREVIOUSAUTOFLIPOUTINFO GetPreviousAutoflipOutInfo
    )

/*++

Routine Description:

    This function returns the current surface receiving data from the
    video port while autoflipping is taking place.  Only called when
    hardware autoflipping.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    GetPreviousAutoflipInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    return DX_OK;
}


VP_STATUS
nvVPEQueryInterface(
    PVOID HwDeviceExtension,
    PQUERY_INTERFACE QueryInterface
    )

/*++

Routine Description:

    Generic method for obtaining interfaces from the miniport.

    Among other things, it's used for exporting the DXAPI "kernel-mode
    VPE" interface.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    QueryInterface - Pointer to structure that describes the requested
        interface.

Return Value:

    DX_OK if successful.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    PDXAPI_INTERFACE DxApiInterface;
    VP_STATUS status;

    status = DXERR_UNSUPPORTED;

    if (IsEqualGUID(QueryInterface->InterfaceType, &GUID_DxApi)) {

        DxApiInterface = (PDXAPI_INTERFACE) QueryInterface->Interface;

        //
        // We are queried here for our "kernel-mode VPE" support only after
        // the display driver has already enabled VPE.  Consequently, we let
        // the display driver control what chips VPE is enabled on -- we
        // don't have to do that here.
        //

        DxApiInterface->Size    = sizeof(DXAPI_INTERFACE);
        DxApiInterface->Version = DXAPI_HALVERSION;
        DxApiInterface->Context = hwDeviceExtension;

        DxApiInterface->DxGetIrqInfo          = GetIrqInfo;
        DxApiInterface->DxEnableIrq           = EnableIrq;
        DxApiInterface->DxSkipNextField       = SkipNextField;
        DxApiInterface->DxBobNextField        = BobNextField;
        DxApiInterface->DxSetState            = SetState;
        DxApiInterface->DxFlipOverlay         = FlipOverlay;
        DxApiInterface->DxFlipVideoPort       = FlipVideoPort;
        DxApiInterface->DxGetPolarity         = GetPolarity;
        DxApiInterface->DxGetCurrentAutoflip  = GetCurrentAutoflip;
        DxApiInterface->DxGetPreviousAutoflip = GetPreviousAutoflip;

        status = DX_OK;
    }

    return status;
}

#endif /* VPE_NT */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\vpemini.c ===
//***************************************************************************
//  Module Name:
//
//      vpemini.c
//
//  Abstract:
//
//      This module contains the miniport parts of the DXAPI "kernel-mode
//      VPE" interface for the .
//
//      The DirectDraw Video Port Extensions (VPE) are the services that
//      control hardware videoports, where video data is streamed into
//      off-screen memory from an external device such as a TV tuner or
//      MPEG decoder, and then displayed on the screen by a video overlay.
//
//      To support VPE, you'll need the following:
//
//          1. A 2-D driver with DirectDraw overlay support;
//          2. A video input device that interfaces with the videoport;
//          3. A bunch of VPE code in the display driver;
//          4. A bunch of VPE code here in the miniport.
//
//      The miniport code here comprises part of the DXAPI "kernel-mode
//      VPE" interface that can be called by other WDM drivers, such as
//      an MPEG driver.
//
// IMPORTANT NOTE ABOUT HARDWARE REQUIREMENTS:
//
//      Almost all of these miniport "kernel-mode VPE" routines may be
//      called asynchronously to what the display driver is currently
//      doing.  For example, a thread may be in the display driver in the
//      middle of programming an accelerated Blt at the exact moment that
//      the miniport gets called to do a videoport flip call.  Consequently,
//      your hardware MUST be able to handle these commands at any time
//      regardless of the state of the display driver.  So this means:
//
//          1. Your hardware has to be able to allow the programming of any
//             "kernel-mode VPE" command even while Blts or direct frame
//             buffer accesses or DMAs or whatever are occuring, without
//             hanging or incorrect drawing.
//
//          2. The registers used to program any of the "kernel-mode VPE"
//             services must be disjoint and separate from those used by
//             the display driver.  If you must program an indexed register
//             that is also used by the display driver (such as 0x3d4/0x3d5),
//             *YOU ARE PROBABLY TOAST*.  Both a thread in the display driver
//             and a thread calling these miniport services are preemptible,
//             meaning that even if you save and restore the index register,
//             there's no guarantee that the other thread won't wake up in
//             the middle and try to use the same (now incorrectly set)
//             register.
//
//      If your hardware does not guarantee both of the above, you CANNOT
//      support the "kernel-mode VPE" interface!  Go yell at your hardware
//      designers and get them to fix the hardware.  If both of the above
//      are not guaranteed, it's inevitable that your customers will randomly
//      hit system hangs and crashes while using VPE.  Your customers will
//      not be happy!
//
//      Also note that the likelihood of hitting a problem is significantly
//      increased when running on a multiple-processor machine.  Consequently,
//      you should try to test VPE on an MP machine while applications (such
//      as Winstone) are running in the background.
//
//      (Okay, okay, so I exaggerated a bit about pointer number 2.  You can
//      in fact use shared indexed registers in these VPE routines if you do
//      one of the following:
//
//          1. Disable VPE on multiple-processor machines.  (As of the time
//             of this writing, we haven't yet implemented a VideoPort or
//             Eng function that you can call to determine whether you're
//             running on a UP or MP machine, otherwise I would tell you
//             the name of the function to call.  But by the time you read
//             this, it will probably exist -- so have a look through the
//             VideoPort and Eng calls...)
//
//             You'll also have to save and restore the index register when
//             you're done.  Because a thread that calls a miniport function
//             is at raised IRQL, it may interrupt a thread in the display
//             driver at any point, but on a UP machine it's guaranteed that
//             the display driver thread will not interrupt the miniport
//             thread.
//
//          2. Use the CRTC register only in the DxEnableIrq routine --
//             DirectDraw automatically synchronizes with the display driver
//             before calling DxEnableIrq (this is not true for any other
//             Dx miniport calls).
//
// NOTE:
//
//      Most "kernel-mode VPE" routines can be called at raised IRQL, meaning
//      that they MUST be non-paged, and cannot call any pageable functions.
//
//  Environment:
//
//      Kernel mode
//
//  Copyright (c) 1997 Microsoft Corporation
//
//***************************************************************************

#ifdef NVPE

// Temporary fix for Compile error...ask!
#define NvGetFreeCount(NN, CH)\
                 (NN)->subchannel[CH].control.Free

#include "vpelocal.h"

//#define _NVP_DTRACE

#ifdef _NVP_DTRACE
#define DEFINE_GLOBALS
#include "dtrace.h"
#endif


////////// globals
BOOL g_bFlip = FALSE;

extern void KeClearEvent(void *hEvent);


//
// Mark those routines that we can as pageable.  Remember that most
// "kernel-mode VPE" routines can be called at raised IRQL, which means
// that they must be kept non-paged.
//
// Note that these are the only two VPE miniport routines which may be
// pageable:
//

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,NVQueryInterface)
#pragma alloc_text(PAGE,GetIrqInfo)
#endif

// !!! Not hooking Lock is success, but not hooking SetPattern is failure?
// !!! Should dwFlags be ANDed or EQUALed?  (SkipNextField)
// !!! Should we mark the interrupt as unsharable?


/*++

Routine Description:

    On NT, the miniport always has to "manage the IRQ" (to borrow from the
    Win95 terminology).  Consequently, this routine simply tells DirectDraw
    what interrupts we support.

    It's actually pretty easy to enable interrupts, in part because you
    don't have to tell the system what interrupt vector you're using, as
    PNP already knows that.  However, you *do* have to check whether PNP
    successfully assigned you an interrupt vector, before you tell DirectDraw
    that you support interrupts.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    GetIrqInfo - Function parameters.

Return Value:

    DX_OK if successful.

--*/

DWORD GetIrqInfo(
    PVOID HwDeviceExtension,
    PVOID lpInput,
    PDDGETIRQINFO GetIrqInfo)
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    DWORD status = DXERR_UNSUPPORTED;

    //
    // Sometimes, the motherboard BIOS or PNP may conspire to refuse to
    // allocate an interrupt to us.  So before we tell DirectDraw that
    // we support interrupts, we must first check if we've actually been
    // assigned one!
    //

//     if ((hwDeviceExtension->BusInterruptLevel != 0) ||
//        (hwDeviceExtension->BusInterruptVector != 0)) 
	{

        GetIrqInfo->dwFlags = IRQINFO_HANDLED;

        status = DX_OK;
	}

    return status;
}

/*++

Routine Description:

    This routine is the interrupt service routine for the kernel video
    driver.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's adapter information.

Return Value:

    TRUE if the interrupt is serviced; FALSE if it wasn't ours (this is done
    to support chained interrupts).

--*/

BOOLEAN Interrupt(PVOID HwDeviceExtension)
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    // add your IRQ handling code here
	return FALSE;
}

/*++

Routine Description:

    This function notifies the miniport when it should enable or disable
    interrupts for VPE.  If an IRQ is not specified in this call, it
    should be disabled.

    On NT, since miniports always "manage the IRQ", we must call DirectDraw's
    IRQCallback routine from our HwInterrupt routine to notify DirectDraw
    whenever an interrupt occurs.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    EnableIrqInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/

DWORD EnableIrq(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PDDENABLEIRQINFO EnableIrqInfo,
    PVOID lpOutput)
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    //
    // First make sure we stash IRQCallback in our device extension before
    // enabling interrupts for the first time, otherwise we may call a NULL
    // pointer from our HwInterrupt routine!
    //
    // (Note that DirectDraw will give us a valid IRQCallback and lpIRQData
    // even when disabling interrupts, which means we won't crash if an
    // interrupt is taken between this point and the actual disabling of the
    // interrupt.)
    //

    hwDeviceExtension->IRQCallback = EnableIrqInfo->IRQCallback;
    hwDeviceExtension->pIRQData = EnableIrqInfo->lpIRQData;
	hwDeviceExtension->dwIRQSources = EnableIrqInfo->dwIRQSources;

    //
    // Clear any existing interrupts, turn off all interrupts by default,
    // and enable the new requested interrupts.
    //
    // NOTE: Be very careful if your driver uses interrupts for purposes
    //       other than VPE.  For example, if your display driver uses DMA,
    //       you probably won't want to clear the DMA interrupt flag here!
    //

    // Now enable the master interrupt switch.  Again, be careful if your
    // display driver uses interrupt for purposes other than VPE -- you
    // probably won't want to disable all video interrupts here like we
    // do!
    //
    // Note: DxEnableIrq is the only routine that may access the CRTC
    //       registers!  For more details, read the large note at the
    //       top of this file.
    //

    // If the vsync interrupt has been disabled, but a deferred overlay
    // offset is pending, flush it now.
    //

    return DX_OK;
}

/*++

Routine Description:

    This function flips the video port to the target surface.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    FlipVideoPortInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/

DWORD FlipVideoPort(
    PVOID HwDeviceExtension,
    PDDFLIPVIDEOPORTINFO FlipVideoPortInfo,
    PVOID lpOutput)
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    ULONG offset;

	VideoDebugPrint((0,"VPEMINI: FlipVideoPort()\n"));

    //
    // Get offset (from framebuffer) and add offset from surface:
    //

    offset = FlipVideoPortInfo->lpTargetSurface->dwSurfaceOffset
           + FlipVideoPortInfo->lpVideoPortData->dwOriginOffset;

    // flip the actual hw surface here

    return DX_OK;
}

/*++

Routine Description:

    This function flips the overlay to the target surface.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    FlipOverlayInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/
DWORD FlipOverlay(
    PVOID HwDeviceExtension,
    PDDFLIPOVERLAYINFO pFlipOverlayInfo,
    PVOID lpOutput)
{
#if 0
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)HwDeviceExtension;
	DDSURFACEDATA* pCurSurf =	(DDSURFACEDATA*) pFlipOverlayInfo->lpCurrentSurface;
	DDSURFACEDATA* pTargSurf =	(DDSURFACEDATA*) pFlipOverlayInfo->lpTargetSurface;
	PNVP_CONTEXT pVPEContext;
	U032 dwFlags;
	NVP_OVERLAY pOvInfo;

	VideoDebugPrint((1,"VPEMINI: FlipOverlay()\n"));

	// get a pointer to the appropriate VPE context (assume VPE 0)
	pVPEContext = &(pHwDevExt->avpContexts[0]);

	pOvInfo = &(pVPEContext->nvpOverlay);

    // VPP flags
	dwFlags = VPP_PRESCALE;

	if (pTargSurf->dwOverlayFlags & DDOVER_INTERLEAVED)
	   dwFlags |= VPP_INTERLEAVED;

	if (pTargSurf->dwOverlayFlags & DDOVER_BOB)
	   dwFlags |= VPP_BOB;

    if (pFlipOverlayInfo->dwFlags & DDFLIP_ODD)
	   dwFlags |= VPP_ODD;
	else if (pFlipOverlayInfo->dwFlags & DDFLIP_EVEN)
	   dwFlags |= VPP_EVEN;


    // if not initialized 
/*
    NVP_CMD_OBJECT cmdObj;
	cmdObj.dwPortId = 0;
	cmdObj.dwChipId = pHwDevExt->ulChipID;
	cmdObj.dwDeviceId = ppdev->hDriver;
	cmdObj.hClient = ppdev->hClient;

    NVPInitialize(pHwDevExt, &cmdObj);
*/
    // initialize index 
    if (pVPEContext->nvpOverlay.dwOverlayBufferIndex == NVP_UNDEF)
        pVPEContext->nvpOverlay.dwOverlayBufferIndex = 0;

    // flip overlay here !
	if (NVPPrescaleAndFlip(pVPEContext, pOvInfo, pTargSurf->dwOverlayOffset, pTargSurf->lPitch, 0, dwFlags))
	    return DX_OK;

    return DXERR_GENERIC;
#else
	return DX_OK;
#endif
}


/*++

Routine Description:

    This function is called when "bob" is used and a VPORT VSYNC occurs
    that does not cause a flip to occur (e.g., bobbing while interleaved).
    When bobbing, the overlay must adjust itself on every VSYNC, so this
    function notifies it of the VSYNCs that it doesn't already know about
    (e.g., VSYNCs that trigger a flip to occur).

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    BobNextFieldInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/

DWORD BobNextField(
    PVOID HwDeviceExtension,
    PDDBOBNEXTFIELDINFO BobNextFieldInfo,
    PVOID lpOutput)
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

	VideoDebugPrint((2,"VPEMINI: BobNextField()\n"));

    return DX_OK;
}

/*++

Routine Description:

    This function is called when the client wants to switch from bob to
    weave.  The overlay flags indicate which state to use.  This is only
    called for interleaved surfaces.

    Note that when this is called, the specified surface may not be
    displaying the overlay (due to a flip).  Instead of failing the call,
    change the bob/weave state for the overlay that would be used if the
    overlay was flipped again to the specified surface.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    SetStateInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/
DWORD SetState(
    PVOID HwDeviceExtension,
    PDDSETSTATEININFO SetStateInInfo,
    PDDSETSTATEOUTINFO SetStateOutInfo)
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

	VideoDebugPrint((0,"VPEMINI: SetState()\n"));

    return DX_OK;
}


/*++

Routine Description:

    This function is called when the client wants to skip the next field,
    usually to undo a 3:2 pulldown but also for decreasing the frame
    rate.  The driver should not lose the VBI lines if dwVBIHeight contains
    a valid value.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    SkipNextFieldInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/

DWORD SkipNextField(
    PVOID HwDeviceExtension,
    PDDSKIPNEXTFIELDINFO SkipNextFieldInfo,
    PVOID lpOutput)
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

	VideoDebugPrint((0,"VPEMINI: SkipNextField()\n"));

    return DX_OK;
}


/*++

Routine Description:

    This function returns the polarity of the current field being written
    to the specified video port.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    GetPolarityInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/

DWORD GetPolarity(
    PVOID HwDeviceExtension,
    PDDGETPOLARITYININFO pGetPolarityInInfo,
    PDDGETPOLARITYOUTINFO pGetPolarityOutInfo)
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION) HwDeviceExtension;
	PNVP_CONTEXT pVPEContext;

	VideoDebugPrint((3,"VPEMINI: GetPolarity()\n"));

	// get a handle to current VPE context (BUGBUG: assume index 0 for now !)
	pVPEContext = &(pHwDevExt->avpContexts[0]);

	// check video first !
	if (pVPEContext->nNumVidSurf)
	{
		// TRUE for Even, FALSE for Odd
		if (pVPEContext->aVideoSurfaceInfo[pVPEContext->nVidSurfIdx].dwFieldType == NVP_FIELD_ODD)
			pGetPolarityOutInfo->bPolarity = FALSE;
		else
			pGetPolarityOutInfo->bPolarity = TRUE;
	}
	// vbi polarity 
	else if (pVPEContext->nNumVBISurf)
	{
		if (pVPEContext->aVBISurfaceInfo[pVPEContext->nVBISurfIdx].dwFieldType == NVP_FIELD_ODD)
			pGetPolarityOutInfo->bPolarity = FALSE;
		else
			pGetPolarityOutInfo->bPolarity = TRUE;
	}
	else
		return DXERR_GENERIC;

    return DX_OK;
}

/*++

Routine Description:

    This function returns the current surface receiving data from the
    video port while autoflipping is taking place.  Only called when
    hardware autoflipping.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    GetCurrentAutoflipInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/
DWORD GetCurrentAutoflip(
    PVOID HwDeviceExtension,
    PDDGETCURRENTAUTOFLIPININFO pGetCurrentAutoflipInInfo,
    PDDGETCURRENTAUTOFLIPOUTINFO pGetAutoFlipInfoOut)
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)HwDeviceExtension;
	PNVP_CONTEXT pVPEContext;
	NvNotification *avpNotifiers;
	int nNotifyIdx;

	VideoDebugPrint((3,"VPEMINI: GetCurrentAutoflip()\n"));

	// get a handle to current VPE context (BUGBUG: assume index 0 for now !)
	pVPEContext = &(pHwDevExt->avpContexts[0]);
	avpNotifiers = (NvNotification *) (pVPEContext->avpNotifiers);

	pGetAutoFlipInfoOut->dwSurfaceIndex = NVP_UNDEF;
	// check out video 
	if (pVPEContext->nNumVidSurf)
	{
		nNotifyIdx = NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(pVPEContext->aVideoSurfaceInfo[pVPEContext->nVidSurfIdx].dwFieldType);
		// check progress status of current surface
		if (avpNotifiers[nNotifyIdx].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS)
			pGetAutoFlipInfoOut->dwSurfaceIndex = (ULONG)(pVPEContext->nVidSurfIdx);
		else
			// assume it is the next surface then !
			pGetAutoFlipInfoOut->dwSurfaceIndex = (ULONG)(pVPEContext->aVideoSurfaceInfo[pVPEContext->nVidSurfIdx].nNextSurfaceIdx);
	}

	pGetAutoFlipInfoOut->dwVBISurfaceIndex = NVP_UNDEF;
	// check out vbi
	if (pVPEContext->nNumVBISurf)
	{
		nNotifyIdx = NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(pVPEContext->aVBISurfaceInfo[pVPEContext->nVBISurfIdx].dwFieldType);
		// check progress status of current surface
		if (avpNotifiers[nNotifyIdx].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS)
			pGetAutoFlipInfoOut->dwVBISurfaceIndex = (ULONG)(pVPEContext->nVBISurfIdx);
		else
			// assume it is the next surface then !
			pGetAutoFlipInfoOut->dwVBISurfaceIndex = (ULONG)(pVPEContext->aVBISurfaceInfo[pVPEContext->nVBISurfIdx].nNextSurfaceIdx);
	}

    return DX_OK;
}


/*++

Routine Description:

    This function returns the current surface receiving data from the
    video port while autoflipping is taking place.  Only called when
    hardware autoflipping.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    GetPreviousAutoflipInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/
DWORD GetPreviousAutoflip(
    PVOID HwDeviceExtension,
    PDDGETPREVIOUSAUTOFLIPININFO pGetAutoflipInInfo,
    PDDGETPREVIOUSAUTOFLIPOUTINFO pGetAutoFlipInfoOut)
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)HwDeviceExtension;
	PNVP_CONTEXT pVPEContext;
	NvNotification *avpNotifiers;
	int nNotifyIdx;

	VideoDebugPrint((3,"VPEMINI: GetPreviousAutoflip()\n"));

	// get a handle to current VPE context (BUGBUG: assume index 0 for now !)
	pVPEContext = &(pHwDevExt->avpContexts[0]);
	avpNotifiers = (NvNotification *) (pVPEContext->avpNotifiers);

	pGetAutoFlipInfoOut->dwSurfaceIndex = NVP_UNDEF;
	// check out video 
	if (pVPEContext->nNumVidSurf)
	{
		nNotifyIdx = NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(pVPEContext->aVideoSurfaceInfo[pVPEContext->nVidSurfIdx].dwFieldType);
		// check progress status of current surface
		if (avpNotifiers[nNotifyIdx].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS)
			// if in progress, return index of previous surface
			pGetAutoFlipInfoOut->dwSurfaceIndex = (ULONG)((pVPEContext->nVidSurfIdx == 0) ? (pVPEContext->nNumVidSurf - 1): (pVPEContext->nVidSurfIdx - 1));
		else
			// assume this is the "previous"ly autoflipped surface then !
			pGetAutoFlipInfoOut->dwSurfaceIndex = (ULONG)(pVPEContext->nVidSurfIdx);
	}

	pGetAutoFlipInfoOut->dwVBISurfaceIndex = NVP_UNDEF;
	// check out vbi
	if (pVPEContext->nNumVBISurf)
	{
		nNotifyIdx = NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(pVPEContext->aVBISurfaceInfo[pVPEContext->nVBISurfIdx].dwFieldType);
		// check progress status of current surface
		if (avpNotifiers[nNotifyIdx].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS)
			// if in progress, return index of previous surface
			pGetAutoFlipInfoOut->dwVBISurfaceIndex = (ULONG)((pVPEContext->nVBISurfIdx == 0) ? (pVPEContext->nNumVBISurf - 1): (pVPEContext->nVBISurfIdx - 1));
		else
			// assume this is the "previous"ly autoflipped surface then !
			pGetAutoFlipInfoOut->dwVBISurfaceIndex = (ULONG)(pVPEContext->nVBISurfIdx);
	}

    return DX_OK;
}


/*++

Routine Description:

    Generic method for obtaining interfaces from the miniport.

    Among other things, it's used for exporting the DXAPI "kernel-mode
    VPE" interface.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    QueryInterface - Pointer to structure that describes the requested
        interface.

Return Value:

    DX_OK if successful.

--*/
VP_STATUS NVQueryInterface(
    PVOID HwDeviceExtension,
    PQUERY_INTERFACE QueryInterface)
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    VP_STATUS status;

    status = DXERR_UNSUPPORTED;

    if (IsEqualGUID(QueryInterface->InterfaceType, &GUID_DxApi)) 
    {
	    PDXAPI_INTERFACE DxApiInterface;
        DxApiInterface = (PDXAPI_INTERFACE) QueryInterface->Interface;

        //
        // We are queried here for our "kernel-mode VPE" support only after
        // the display driver has already enabled VPE.  Consequently, we let
        // the display driver control what chips VPE is enabled on -- we
        // don't have to do that here.
        //

        DxApiInterface->Size    = sizeof(DXAPI_INTERFACE);
        DxApiInterface->Version = DXAPI_HALVERSION;
        DxApiInterface->Context = hwDeviceExtension;

        DxApiInterface->DxGetIrqInfo          = GetIrqInfo;
        DxApiInterface->DxEnableIrq           = EnableIrq;
        DxApiInterface->DxSkipNextField       = SkipNextField;
        DxApiInterface->DxBobNextField        = BobNextField;
        DxApiInterface->DxSetState            = SetState;
        DxApiInterface->DxFlipOverlay         = FlipOverlay;
        DxApiInterface->DxFlipVideoPort       = FlipVideoPort;
        DxApiInterface->DxGetPolarity         = GetPolarity;
        DxApiInterface->DxGetCurrentAutoflip  = GetCurrentAutoflip;
        DxApiInterface->DxGetPreviousAutoflip = GetPreviousAutoflip;
		DxApiInterface->DxTransfer			  = NVPTransfer;
		DxApiInterface->DxGetTransferStatus	  = NVPGetTransferStatus;

        status = DX_OK;
    }
	// I2c Interface
	else if (IsEqualGUID(QueryInterface->InterfaceType, &GUID_I2C_INTERFACE))
	{
		I2CINTERFACE *pI2cInterface;
        pI2cInterface = (I2CINTERFACE *) QueryInterface->Interface;


		//pI2cInterface->_vddInterface;
    	pI2cInterface->i2cOpen = (I2COPEN) miniI2COpen;
    	pI2cInterface->i2cAccess = (I2CACCESS) miniI2CAccess;

        status = DX_OK;
	}

    return status;
}

/*
==============================================================================
	
	NVP3Initialize

	Description:	Initializes the NV video port. Creates channels and DMA
					contexts. Create Video and VBI objects.
					NV3 version uses PIO channel

	Date:			Feb 03, 1999
	
	Author:			H. Azar

==============================================================================
*/
VP_STATUS NVP3Initialize(
	PHW_DEVICE_EXTENSION pHwDevExt,
	NVP_CMD_OBJECT *pCmdObj)
{
	PNVP_CONTEXT pVPEContext;
	NvNotification *avpNotifiers;
	NVOS10_PARAMETERS evParam;
	int nFreeCount;
	U032 status;
	NVOS09_PARAMETERS ntfParam;
	Nv03ChannelPio *pNVPChannel = (Nv03ChannelPio *) (pCmdObj->pChannel);

//////////// HACK
	g_bFlip = FALSE;
///////////

	VideoDebugPrint((3,"VPEMINI: NVP3Initialize()\n"));

	// get a pointer to the appropriate VPE context
	pVPEContext = &(pHwDevExt->avpContexts[pCmdObj->dwPortId]);
	// initialize context
	pVPEContext->pNVPChannel = (ULONG) pNVPChannel;	// keep a copy of the pio channel pointer
	pVPEContext->nvDmaFifo = NULL;
	pVPEContext->dwDeviceId = pCmdObj->dwDeviceId;
	pVPEContext->hClient = pCmdObj->hClient;
	pVPEContext->pOverlayChannel = pCmdObj->pOvrChannel;
	pVPEContext->dwOvrSubChannel = pCmdObj->dwOvrSubChannel;
	pVPEContext->dwOverlayObjectID = pCmdObj->dwOverlayObjectID;
	pVPEContext->dwScalerObjectID = pCmdObj->dwScalerObjectID;
	pVPEContext->dwDVDSubPicObjectID = pCmdObj->dwDVDObjectID;
    pVPEContext->dwDVDObjectCtxDma = pCmdObj->dwDVDObjectCtxDma;
	pVPEContext->nvpOverlay.pNvPioFlipOverlayNotifierFlat = pCmdObj->pNvPioFlipOverlayNotifierFlat;
	pVPEContext->nNumVidSurf = 0;
	pVPEContext->nNumVBISurf = 0;
	pVPEContext->dwVPState = NVP_STATE_STOPPED;
	pVPEContext->dwVPConFlags = pCmdObj->dwVPTypeFlags;
	pVPEContext->dwVPFlags = 0; //pCmdObj->dwVPInfoFlags;
	pVPEContext->nCurTransferIdx = NVP_EOQ;
	pVPEContext->nLastTransferIdx = NVP_EOQ;
	pVPEContext->nRecentTransferIdx = NVP_EOQ;
	pVPEContext->nNumTransfer = 0;
	pVPEContext->bxfContextCreated = FALSE;
	pVPEContext->bxfContextFlushed = FALSE;
	avpNotifiers = (NvNotification *) (pVPEContext->avpNotifiers);

	// alloc external decoder object
	if (RmAllocObject(
				pCmdObj->hClient,
				NVP_VPE_CHANNEL,
	            NVP_EXTERNAL_DECODER_OBJECT,
				NV03_EXTERNAL_VIDEO_DECODER) != 0)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate External Decoder Object 0x%X\n", NVP_EXTERNAL_DECODER_OBJECT));
		return FALSE;
	}

	// allocate transfer object (used for vbi and video capture)
	if (RmAllocObject(
				pCmdObj->hClient,
				NVP_VPE_CHANNEL,
	            NVP_M2M_OBJECT,
				NV03_MEMORY_TO_MEMORY_FORMAT) != 0)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate Mem to mem transfer Object 0x%X\n", NVP_M2M_OBJECT));
		return FALSE;
	}

    // allocate the transfer FROM context
    if (RmAllocContextDma(
						pCmdObj->hClient,
                        NVP_M2M_FROM_CONTEXT,
                        NV01_CONTEXT_DMA_FROM_MEMORY,       //NV_CONTEXT_DMA_FROM_MEMORY ?
                        0, // (ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
						0, // selector
                        (U032)pCmdObj->pFrameBuffer,
                        pCmdObj->dwFBLen - 1) != 0)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate notifiers for M2M transfer Object\n"));
        return FALSE;
	}

    // allocate a notify context for transfer object
    if (RmAllocContextDma(
    					pCmdObj->hClient,
                        NVP_M2M_NOTIFIER,
                        NV01_CONTEXT_DMA_FROM_MEMORY,
                        0, 	//(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                        0,  // selector
                        (U032)(pVPEContext->axfNotifiers),
                        (sizeof( NvNotification)*NVP_CLASS039_MAX_NOTIFIERS  - 1)) != 0)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate notifiers for M2M transfer Object\n"));
        return FALSE;
    }
	
	// allocate a notify context for external decoder
	if (RmAllocContextDma(
					pCmdObj->hClient,
	         		NVP_EXTERNAL_DECODER_NOTIFIER,
	         		NV01_CONTEXT_DMA_FROM_MEMORY,
	         		0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
					0, // selector
	         		(U032)(pVPEContext->avpNotifiers),
	         		(sizeof(NvNotification)*NVP_CLASS04D_MAX_NOTIFIERS - 1)) != 0) //ALLOC_CTX_DMA_STATUS_SUCCESS)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate notifiers for external decoder object\n"));
		return FALSE;
	}

	// context DMA for video field0
	if (RmAllocContextDma(
				pCmdObj->hClient,
				NVP_VIDEO_FIELD0_BUFFER_CONTEXT,
				NV01_CONTEXT_DMA_FROM_MEMORY,
				0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
				0, // selector
				(U032) (pCmdObj->pFrameBuffer),
				pCmdObj->dwFBLen - 1) != 0)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate context DMA for video field0\n"));
		return FALSE;
	}

	// context DMA for video field1	
	if (RmAllocContextDma(
				pCmdObj->hClient,
				NVP_VIDEO_FIELD1_BUFFER_CONTEXT,
				NV01_CONTEXT_DMA_FROM_MEMORY,
				0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
				0, // selector
				(U032) (pCmdObj->pFrameBuffer),
	            pCmdObj->dwFBLen - 1) != 0)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate context DMA for video field1\n"));
		return FALSE;
	}
	
	// context DMA for video field0
	if (RmAllocContextDma(
				pCmdObj->hClient,
				NVP_VBI_FIELD0_BUFFER_CONTEXT,
				NV01_CONTEXT_DMA_FROM_MEMORY, //NV01_CONTEXT_DMA,
				0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
				0, // selector
				(U032) (pCmdObj->pFrameBuffer),
				pCmdObj->dwFBLen - 1) != 0)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate context DMA for VBI field0\n"));
		return FALSE;
	}

	// context DMA for video field1
	if (RmAllocContextDma(
				pCmdObj->hClient,
				NVP_VBI_FIELD1_BUFFER_CONTEXT,
				NV01_CONTEXT_DMA_FROM_MEMORY, //NV01_CONTEXT_DMA,
				0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
				0, // selector
				(U032) (pCmdObj->pFrameBuffer),
	            pCmdObj->dwFBLen - 1) != 0) //ALLOC_CTX_DMA_STATUS_SUCCESS)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate context DMA for VBI field1\n"));
		return FALSE;
	}

	//CHECK_FREE_COUNT(pNVPChannel,10*5);
	nFreeCount = NvGetFreeCount(pNVPChannel, 0);
	while (nFreeCount < 13*4) 
	{
		//RmInterrupt(&ntfParam);
		nFreeCount = NvGetFreeCount(pNVPChannel, 0);
	}			
	pVPEContext->nFreeCount = nFreeCount - (13*4);

	avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
	avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
	avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(0)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
	avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(1)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;

	// transfer object setup
    pNVPChannel->subchannel[5].SetObject  = NVP_M2M_OBJECT;
    pNVPChannel->subchannel[5].nv03MemoryToMemoryFormat.SetContextDmaNotifies = NVP_M2M_NOTIFIER;
    pNVPChannel->subchannel[5].nv03MemoryToMemoryFormat.SetContextDmaBufferIn = NVP_M2M_FROM_CONTEXT;
	
	// make sure decoder object is in the channel....
	pNVPChannel->subchannel[0].SetObject = NVP_EXTERNAL_DECODER_OBJECT;
	pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaNotifies = NVP_EXTERNAL_DECODER_NOTIFIER;

	// plug in our buffer contexts
	pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaImage[0] = NVP_VIDEO_FIELD0_BUFFER_CONTEXT;
	pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaImage[1] = NVP_VIDEO_FIELD1_BUFFER_CONTEXT;
	pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaVbi[0]   = NVP_VBI_FIELD0_BUFFER_CONTEXT;
	pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaVbi[1]   = NVP_VBI_FIELD1_BUFFER_CONTEXT;
	
	// NB: we don't want to launch any captures at this point

	// setup the transfer callback
	evParam.hRoot = pCmdObj->hClient;
  	evParam.hObjectParent = NVP_M2M_OBJECT;
  	evParam.hObjectNew = NVP_M2M_EVENT;
  	evParam.hClass = NV01_EVENT_KERNEL_CALLBACK;
  	evParam.index = NV039_NOTIFIERS_BUFFER_NOTIFY;
  	evParam.hEvent.low = (ULONG) NVPTransferNotify;
	status = Nv01AllocEvent(&evParam);
	if (status)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot create callback for m2m transfer 0\n"));
		return FALSE;
	}

	// setup fields callbacks
	evParam.hRoot = pCmdObj->hClient;
  	evParam.hObjectParent = NVP_EXTERNAL_DECODER_OBJECT;
  	evParam.hObjectNew = NVP_VIDEO_FIELD0_BUFFER_EVENT;
  	evParam.hClass = NV01_EVENT_KERNEL_CALLBACK;
  	evParam.index = NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0);
  	evParam.hEvent.low = (ULONG) VideoField0Notify;

	// video field0
	status = Nv01AllocEvent(&evParam);
	if (status)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot create callback for video field 0\n"));
		return FALSE;
	}

	// video field1
	evParam.hRoot = pCmdObj->hClient;
  	evParam.hObjectParent = NVP_EXTERNAL_DECODER_OBJECT;
  	evParam.hObjectNew = NVP_VIDEO_FIELD1_BUFFER_EVENT;
  	evParam.hClass = NV01_EVENT_KERNEL_CALLBACK;
  	evParam.index = NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1);
  	evParam.hEvent.low = (ULONG) VideoField1Notify;

	status = Nv01AllocEvent(&evParam);
	if (status)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot create callback for video field 1\n"));
		return FALSE;
	}

	// vbi field0
	evParam.hRoot = pCmdObj->hClient;
  	evParam.hObjectParent = NVP_EXTERNAL_DECODER_OBJECT;
  	evParam.hObjectNew = NVP_VBI_FIELD0_BUFFER_EVENT;
  	evParam.hClass = NV01_EVENT_KERNEL_CALLBACK;
  	evParam.index = NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(0);
  	evParam.hEvent.low = (ULONG) VBIField0Notify;

	status = Nv01AllocEvent(&evParam);
	if (status)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot create callback for VBI field 0\n"));
		return FALSE;
	}
			
	// vbi field1
	evParam.hRoot = pCmdObj->hClient;
  	evParam.hObjectParent = NVP_EXTERNAL_DECODER_OBJECT;
  	evParam.hObjectNew = NVP_VBI_FIELD1_BUFFER_EVENT;
  	evParam.hClass = NV01_EVENT_KERNEL_CALLBACK;
  	evParam.index = NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(1);
  	evParam.hEvent.low = (ULONG) VBIField1Notify;

	status = Nv01AllocEvent(&evParam);
	if (status)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot create callback for VBI field 1\n"));
		return FALSE;
	}

	return NO_ERROR;
}


/*
==============================================================================
	
	NVPInitialize

	Description:	Initializes the NV video port. Creates channels and DMA
					contexts. Create Video and VBI objects.
					DMA push buffer version (NV ver >= 0x04)

	Date:			Feb 03, 1999
	
	Author:			H. Azar

==============================================================================
*/
VP_STATUS NVPInitialize(
	PHW_DEVICE_EXTENSION pHwDevExt,
	NVP_CMD_OBJECT *pCmdObj)
{
	PNVP_CONTEXT pVPEContext;
	NvNotification *avpNotifiers;
    NvNotification *aovNotifiers;
	U032 dwOvObj;
	NVOS10_PARAMETERS evParam;
	Nv4ControlDma *pDmaChannel;
	U032 nvDmaCount;
	U032 status;

	// NV3 specific code
	if (NVP_GET_CHIP_VER(pCmdObj->dwChipId) <= NVP_CHIP_VER_03)
		return NVP3Initialize(pHwDevExt, pCmdObj);

//////////// HACK
	g_bFlip = FALSE;
///////////

	VideoDebugPrint((3,"VPEMINI: NVPInitialize()\n"));

	// get a pointer to the appropriate VPE context
	pVPEContext = &(pHwDevExt->avpContexts[pCmdObj->dwPortId]);
	// initialize context
	//pVPEContext->pNVPChannel = (ULONG) 0;
	pVPEContext->dwChipId = pCmdObj->dwChipId;
	pVPEContext->dwDeviceId = pCmdObj->dwDeviceId;
	pVPEContext->hClient = pCmdObj->hClient;
	pVPEContext->pOverlayChannel = pCmdObj->pOvrChannel;
	pVPEContext->dwOvrSubChannel = pCmdObj->dwOvrSubChannel;
	pVPEContext->dwOverlayObjectID = pCmdObj->dwOverlayObjectID;
	pVPEContext->dwScalerObjectID = pCmdObj->dwScalerObjectID;
	pVPEContext->dwDVDSubPicObjectID = pCmdObj->dwDVDObjectID;
    pVPEContext->dwDVDObjectCtxDma = pCmdObj->dwDVDObjectCtxDma;
	pVPEContext->nvpOverlay.pNvPioFlipOverlayNotifierFlat = pCmdObj->pNvPioFlipOverlayNotifierFlat;
	pVPEContext->nNumVidSurf = 0;
	pVPEContext->nNumVBISurf = 0;
	pVPEContext->dwVPState = NVP_STATE_STOPPED;
	pVPEContext->dwVPConFlags = pCmdObj->dwVPTypeFlags;
	pVPEContext->dwVPFlags = 0; //pCmdObj->dwVPInfoFlags;
	pVPEContext->nCurTransferIdx = NVP_EOQ;
	pVPEContext->nLastTransferIdx = NVP_EOQ;
	pVPEContext->nRecentTransferIdx = NVP_EOQ;
	pVPEContext->nNumTransfer = 0;
	pVPEContext->bxfContextCreated = FALSE;
	pVPEContext->bxfContextFlushed = FALSE;
	pVPEContext->hVPSyncEvent = pCmdObj->hVPSyncEvent;

	pVPEContext->nvDmaFifo = NULL;
	pVPEContext->DmaPushBufTotalSize = 32*1024*4;	// 32k DWORDs
	if (VideoPortAllocateBuffer((PVOID)pHwDevExt, pVPEContext->DmaPushBufTotalSize, (PVOID *)&(pVPEContext->nvDmaFifo)) != NO_ERROR)
		return FALSE;

    if (RmAllocContextDma(  pCmdObj->hClient,
                            NVP_DMA_FROM_MEMORY_PUSHBUF,
                            NV01_CONTEXT_DMA,
                            NVOS03_FLAGS_ACCESS_READ_ONLY,
							0, // selector
                            (U032)(pVPEContext->nvDmaFifo),
                            pVPEContext->DmaPushBufTotalSize - 1) != 0)
    {
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate Context Dma for PushBuffer Object\n"));
		return FALSE;
    }

    // Allocate the DMA push buffer ERROR notifier
    if (RmAllocContextDma(  pCmdObj->hClient,
                            NVP_DMA_PUSHBUF_ERROR_NOTIFIER,
                            NV01_CONTEXT_DMA,
                            NVOS03_FLAGS_ACCESS_WRITE_ONLY,
							0, // selector
                            (U032)(&(pVPEContext->DmaPushBufErrNotifier[0])),
                            sizeof(NvNotification) - 1) != 0)
    {
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate PushBuffer notifier\n"));
		return FALSE;
    }

	// allocate DMA channel here !
    if (RmAllocChannelDma(  pCmdObj->hClient,
                            pCmdObj->dwDeviceId,
                            NVP_VPE_CHANNEL,
                            NV4_CHANNEL_DMA,
                            NVP_DMA_PUSHBUF_ERROR_NOTIFIER,
                            NVP_DMA_FROM_MEMORY_PUSHBUF,
                            0,
                            (PVOID)&(pVPEContext->pDmaChannel)) != 0)
    {
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate Dma Channel 0x%X\n", NVP_VPE_CHANNEL));
		return FALSE;
    }

	// alloc external decoder object
	if (RmAllocObject(
				pCmdObj->hClient,
				NVP_VPE_CHANNEL,
	            NVP_EXTERNAL_DECODER_OBJECT,
				NV03_EXTERNAL_VIDEO_DECODER) != 0)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate External Decoder Object 0x%X\n", NVP_EXTERNAL_DECODER_OBJECT));
		return FALSE;
	}

	// allocate transfer object (used for vbi and video capture)
	if (RmAllocObject(
				pCmdObj->hClient,
				NVP_VPE_CHANNEL,
	            NVP_M2M_OBJECT,
				NV03_MEMORY_TO_MEMORY_FORMAT) != 0)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate Mem to mem transfer Object 0x%X\n", NVP_M2M_OBJECT));
		return FALSE;
	}

    dwOvObj = (pCmdObj->dwChipId < NV_DEVICE_VERSION_10) ? NV04_VIDEO_OVERLAY : NV10_VIDEO_OVERLAY;

	// alloc overlay object 
	if (RmAllocObject(
				pCmdObj->hClient,
				NVP_VPE_CHANNEL,
	            NVP_OVERLAY_OBJECT,
				dwOvObj) != 0)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate Overlay Object 0x%X\n", NVP_OVERLAY_OBJECT));
		return FALSE;
	}


	// alloc DVD subpicture object 
	if (RmAllocObject(
				pCmdObj->hClient,
				NVP_VPE_CHANNEL,
	            NVP_DVD_SUBPICTURE_OBJECT,
				NV4_DVD_SUBPICTURE) != 0)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate DVD subpicture Object 0x%X\n", NVP_DVD_SUBPICTURE_OBJECT));
		return FALSE;
	}

    // allocate the transfer FROM context
    if (RmAllocContextDma(
						pCmdObj->hClient,
                        NVP_M2M_FROM_CONTEXT,
                        NV01_CONTEXT_DMA_FROM_MEMORY,       //NV_CONTEXT_DMA_FROM_MEMORY ?
                        0, // (ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
						0, // selector
                        (U032)pCmdObj->pFrameBuffer,
                        pCmdObj->dwFBLen - 1) != 0)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate notifiers for M2M transfer Object\n"));
        return FALSE;
	}

    // allocate a notify context for transfer object
    if (RmAllocContextDma(
    					pCmdObj->hClient,
                        NVP_M2M_NOTIFIER,
                        NV01_CONTEXT_DMA_FROM_MEMORY,
                        0, 	//(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                        0,  // selector
                        (U032)(pVPEContext->axfNotifiers),
                        (sizeof( NvNotification)*NVP_CLASS039_MAX_NOTIFIERS  - 1)) != 0)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate notifiers for M2M transfer Object\n"));
        return FALSE;
    }
	
	// allocate a notify context for external decoder
	if (RmAllocContextDma(
					pCmdObj->hClient,
	         		NVP_EXTERNAL_DECODER_NOTIFIER,
	         		NV01_CONTEXT_DMA_FROM_MEMORY,
	         		0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
					0, // selector
	         		(U032)(pVPEContext->avpNotifiers),
	         		(sizeof(NvNotification)*NVP_CLASS04D_MAX_NOTIFIERS - 1)) != 0) //ALLOC_CTX_DMA_STATUS_SUCCESS)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate notifiers for external decoder object\n"));
		return FALSE;
	}

	// context DMA for video field0
	if (RmAllocContextDma(
				pCmdObj->hClient,
				NVP_VIDEO_FIELD0_BUFFER_CONTEXT,
				NV01_CONTEXT_DMA_FROM_MEMORY,
				0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
				0, // selector
				(U032) (pCmdObj->pFrameBuffer),
				pCmdObj->dwFBLen - 1) != 0)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate context DMA for video field0\n"));
		return FALSE;
	}

	// context DMA for video field1	
	if (RmAllocContextDma(
				pCmdObj->hClient,
				NVP_VIDEO_FIELD1_BUFFER_CONTEXT,
				NV01_CONTEXT_DMA_FROM_MEMORY,
				0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
				0, // selector
				(U032) (pCmdObj->pFrameBuffer),
	            pCmdObj->dwFBLen - 1) != 0)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate context DMA for video field1\n"));
		return FALSE;
	}
	
	// context DMA for video field0
	if (RmAllocContextDma(
				pCmdObj->hClient,
				NVP_VBI_FIELD0_BUFFER_CONTEXT,
				NV01_CONTEXT_DMA_FROM_MEMORY, //NV01_CONTEXT_DMA,
				0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
				0, // selector
				(U032) (pCmdObj->pFrameBuffer),
				pCmdObj->dwFBLen - 1) != 0)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate context DMA for VBI field0\n"));
		return FALSE;
	}

	// context DMA for video field1
	if (RmAllocContextDma(
				pCmdObj->hClient,
				NVP_VBI_FIELD1_BUFFER_CONTEXT,
				NV01_CONTEXT_DMA_FROM_MEMORY, //NV01_CONTEXT_DMA,
				0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
				0, // selector
				(U032) (pCmdObj->pFrameBuffer),
	            pCmdObj->dwFBLen - 1) != 0) //ALLOC_CTX_DMA_STATUS_SUCCESS)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate context DMA for VBI field1\n"));
		return FALSE;
	}

    // allocate a context for overlay object
    if (RmAllocContextDma(
    					pCmdObj->hClient,
                        NVP_OVERLAY_BUFFER_CONTEXT,
                        NV01_CONTEXT_DMA,
                        0, 	//(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                        0,  // selector
                        (U032) (pCmdObj->pFrameBuffer),
                        pCmdObj->dwFBLen - 1) != 0)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate dma context for overlay buffer0\n"));
        return FALSE;
    }

    // allocate a context for DVD subpicture object
    if (RmAllocContextDma(
    					pCmdObj->hClient,
                        NVP_DVD_SUBPICTURE_CONTEXT,
                        NV01_CONTEXT_DMA,
                        0, 	//(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                        0,  // selector
                        (U032) (pCmdObj->pFrameBuffer),
                        pCmdObj->dwFBLen - 1) != 0)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate dma context for DVD subpicture Object\n"));
        return FALSE;
    }

	// allocate a notify context for overlay notifiers
	if (RmAllocContextDma(
					pCmdObj->hClient,
	         		NVP_OVERLAY_NOTIFIER,
	         		NV01_CONTEXT_DMA_FROM_MEMORY,
	         		0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
					0, // selector
	         		(U032)(pVPEContext->aovNotifiers),
	         		(sizeof(NvNotification)*NVP_CLASS07A_MAX_NOTIFIERS - 1)) != 0) //ALLOC_CTX_DMA_STATUS_SUCCESS)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate notifiers for external decoder object\n"));
		return FALSE;
	}


    // reset media port notifiers
	avpNotifiers = (NvNotification *) (pVPEContext->avpNotifiers);
	avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
	avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
	avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(0)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
	avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(1)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
    // reset overlay notifiers
    aovNotifiers = (NvNotification *) (pVPEContext->aovNotifiers);
    aovNotifiers[NV07A_NOTIFIERS_SET_OVERLAY(0)].status = 0;
    aovNotifiers[NV07A_NOTIFIERS_SET_OVERLAY(1)].status = 0;

	pVPEContext->nvpOverlay.pNvPioFlipOverlayNotifierFlat = (U032) (pVPEContext->aovNotifiers);

	// init Dma channel pointers
	pDmaChannel = (Nv4ControlDma *)(pVPEContext->pDmaChannel);
    pDmaChannel->Put = 0;
    nvDmaCount = 0;

	// set m2m object context
    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_SET_OBJECT, NVP_M2M_OBJECT);
    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_SET_CONTEXT_DMA_NOTIFIES, NVP_M2M_NOTIFIER);
    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_SET_CONTEXT_DMA_BUFFER_IN, NVP_M2M_FROM_CONTEXT);

	// make sure decoder object is in the channel....
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_OBJECT , NVP_EXTERNAL_DECODER_OBJECT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_CONTEXT_DMA_NOTIFIES, NVP_EXTERNAL_DECODER_NOTIFIER);
	// plug in our buffer contexts
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_CONTEXT_DMA_IMAGE(0), NVP_VIDEO_FIELD0_BUFFER_CONTEXT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_CONTEXT_DMA_IMAGE(1), NVP_VIDEO_FIELD1_BUFFER_CONTEXT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_CONTEXT_DMA_VBI(0), NVP_VBI_FIELD0_BUFFER_CONTEXT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_CONTEXT_DMA_VBI(1), NVP_VBI_FIELD1_BUFFER_CONTEXT);

    // set overlay contexts
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OBJECT, NVP_OVERLAY_OBJECT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_CONTEXT_DMA_NOTIFIES, NVP_OVERLAY_NOTIFIER);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_CONTEXT_DMA_OVERLAY(0), NVP_OVERLAY_BUFFER_CONTEXT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_CONTEXT_DMA_OVERLAY(1), NVP_OVERLAY_BUFFER_CONTEXT);

    // same for DVD subpicture context
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_SET_OBJECT, NVP_DVD_SUBPICTURE_OBJECT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_SET_CONTEXT_DMA_OVERLAY, NVP_DVD_SUBPICTURE_CONTEXT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_SET_CONTEXT_DMA_IMAGE_IN, NVP_DVD_SUBPICTURE_CONTEXT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_SET_CONTEXT_DMA_IMAGE_OUT, NVP_DVD_SUBPICTURE_CONTEXT);

	pVPEContext->nvDmaCount = nvDmaCount;
    pDmaChannel->Put = nvDmaCount << 2;

	// NB: we don't want to launch any captures at this point

	// setup the transfer callback
	evParam.hRoot = pCmdObj->hClient;
  	evParam.hObjectParent = NVP_M2M_OBJECT;
  	evParam.hObjectNew = NVP_M2M_EVENT;
  	evParam.hClass = NV01_EVENT_KERNEL_CALLBACK;
  	evParam.index = NV039_NOTIFIERS_BUFFER_NOTIFY;
  	evParam.hEvent.low = (ULONG) NVPTransferNotify;
	status = Nv01AllocEvent(&evParam);
	if (status)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot create callback for m2m transfer 0\n"));
		return FALSE;
	}

	// setup fields callbacks
	evParam.hRoot = pCmdObj->hClient;
  	evParam.hObjectParent = NVP_EXTERNAL_DECODER_OBJECT;
  	evParam.hObjectNew = NVP_VIDEO_FIELD0_BUFFER_EVENT;
  	evParam.hClass = NV01_EVENT_KERNEL_CALLBACK;
  	evParam.index = NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0);
  	evParam.hEvent.low = (ULONG) VideoField0Notify;

	// video field0
	status = Nv01AllocEvent(&evParam);
	if (status)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot create callback for video field 0\n"));
		return FALSE;
	}

	// video field1
	evParam.hRoot = pCmdObj->hClient;
  	evParam.hObjectParent = NVP_EXTERNAL_DECODER_OBJECT;
  	evParam.hObjectNew = NVP_VIDEO_FIELD1_BUFFER_EVENT;
  	evParam.hClass = NV01_EVENT_KERNEL_CALLBACK;
  	evParam.index = NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1);
  	evParam.hEvent.low = (ULONG) VideoField1Notify;

	status = Nv01AllocEvent(&evParam);
	if (status)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot create callback for video field 1\n"));
		return FALSE;
	}

	// vbi field0
	evParam.hRoot = pCmdObj->hClient;
  	evParam.hObjectParent = NVP_EXTERNAL_DECODER_OBJECT;
  	evParam.hObjectNew = NVP_VBI_FIELD0_BUFFER_EVENT;
  	evParam.hClass = NV01_EVENT_KERNEL_CALLBACK;
  	evParam.index = NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(0);
  	evParam.hEvent.low = (ULONG) VBIField0Notify;

	status = Nv01AllocEvent(&evParam);
	if (status)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot create callback for VBI field 0\n"));
		return FALSE;
	}
			
	// vbi field1
	evParam.hRoot = pCmdObj->hClient;
  	evParam.hObjectParent = NVP_EXTERNAL_DECODER_OBJECT;
  	evParam.hObjectNew = NVP_VBI_FIELD1_BUFFER_EVENT;
  	evParam.hClass = NV01_EVENT_KERNEL_CALLBACK;
  	evParam.index = NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(1);
  	evParam.hEvent.low = (ULONG) VBIField1Notify;

	status = Nv01AllocEvent(&evParam);
	if (status)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot create callback for VBI field 1\n"));
		return FALSE;
	}

	// vsync event
	if (pCmdObj->hVPSyncEvent)
	{
	    // field 0
		evParam.hRoot = pCmdObj->hClient;
	  	evParam.hObjectParent = NVP_EXTERNAL_DECODER_OBJECT;
	  	evParam.hObjectNew = NVP_VSYNC_EVENT0;
	  	evParam.hClass = NV01_EVENT_WIN32_EVENT;
	  	evParam.index = NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0);
	  	evParam.hEvent.low = (ULONG) pCmdObj->hVPSyncEvent;

		status = Nv01AllocEvent(&evParam);
		if (status)
		{
	    	VideoDebugPrint((0,"VPEMINI: Cannot set event for video field 0\n"));
			return FALSE;
		}

        // field 1 (use same event for both fields)
		evParam.hRoot = pCmdObj->hClient;
	  	evParam.hObjectParent = NVP_EXTERNAL_DECODER_OBJECT;
	  	evParam.hObjectNew = NVP_VSYNC_EVENT1;
	  	evParam.hClass = NV01_EVENT_WIN32_EVENT;
	  	evParam.index = NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1);
	  	evParam.hEvent.low = (ULONG) pCmdObj->hVPSyncEvent;

		status = Nv01AllocEvent(&evParam);
		if (status)
		{
	    	VideoDebugPrint((0,"VPEMINI: Cannot set event for video field 0\n"));
			return FALSE;
		}

	}

	return NO_ERROR;
}

/*
==============================================================================
	
	NVPUninitialize

	Description:	Free channels, DMA contexts and objects created by a 
					previous call to NVPInitialize

	Date:			Feb 03, 1999
	
	Author:			H. Azar

==============================================================================
*/
VP_STATUS NVPUninitialize(
    PHW_DEVICE_EXTENSION pHwDevExt,
	NVP_CMD_OBJECT *pCmdObj)
{
	PNVP_CONTEXT pVPEContext;

	VideoDebugPrint((3,"VPEMINI: NVPUninitialize()\n"));

	// get a pointer to the appropriate VPE context
	pVPEContext = &(pHwDevExt->avpContexts[pCmdObj->dwPortId]);

	// free allocated resources
	////////// shouldn't we wait for completion (either grab of transfer ?!)
	RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_VIDEO_FIELD0_BUFFER_CONTEXT);
	RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_VIDEO_FIELD1_BUFFER_CONTEXT);
	RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_VBI_FIELD0_BUFFER_CONTEXT);
	RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_VBI_FIELD1_BUFFER_CONTEXT);
	RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_VBI_FIELD0_BUFFER_EVENT);
	RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_VBI_FIELD1_BUFFER_EVENT);
	RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_VIDEO_FIELD0_BUFFER_EVENT);
	RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_VIDEO_FIELD1_BUFFER_EVENT);
	RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_EXTERNAL_DECODER_NOTIFIER);
	RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_EXTERNAL_DECODER_OBJECT);
	RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_OVERLAY_BUFFER_CONTEXT);
	RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_DVD_SUBPICTURE_CONTEXT);
	RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_OVERLAY_NOTIFIER);
	RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_OVERLAY_OBJECT);
	RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_DVD_SUBPICTURE_OBJECT);

	// free transfer object resources
	if (pVPEContext->bxfContextCreated)
		RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_M2M_CONTEXT);

	RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_M2M_NOTIFIER);
	RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_M2M_FROM_CONTEXT);
	RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_M2M_EVENT);
	RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_M2M_OBJECT);

	if (pVPEContext->hVPSyncEvent)
	{
		RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_VSYNC_EVENT0);
		RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_VSYNC_EVENT1);
		pVPEContext->hVPSyncEvent = 0;
	}

	if (pVPEContext->nvDmaFifo != NULL)
	{
		RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_VPE_CHANNEL);
		RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_DMA_FROM_MEMORY_PUSHBUF);
		RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_DMA_PUSHBUF_ERROR_NOTIFIER);
		VideoPortReleaseBuffer((PVOID)(pHwDevExt), (PVOID)(pVPEContext->nvDmaFifo));
	}

    pVPEContext->pOverlayChannel = 0;
    pVPEContext->nvDmaFifo = NULL;

    pVPEContext->nvpOverlay.dwOverlayBufferIndex = NVP_UNDEF;

	return NO_ERROR;
}

/*
==============================================================================
	
	NVPUpdate

	Description:	Updates the NV video port data.

	Date:			Feb 03, 1999
	
	Author:			H. Azar

==============================================================================
*/
VP_STATUS NVPUpdate(
    PHW_DEVICE_EXTENSION pHwDevExt,
	NVP_CMD_OBJECT *pCmdObj)
{
	PNVP_CONTEXT pVPEContext;
	PNVP_OVERLAY pnvOverlay;
    int i;

	VideoDebugPrint((3,"VPEMINI: NVPUpdate()\n"));

	// get a pointer to the appropriate VPE context
	pVPEContext = &(pHwDevExt->avpContexts[pCmdObj->dwPortId]);

	pVPEContext->dwVPFlags = pCmdObj->dwVPInfoFlags;
	pVPEContext->pOverlayChannel = pCmdObj->pOvrChannel;

    if (pCmdObj->dwExtra422NumSurfaces > NVP_MAX_EXTRA422)
	{
		VideoDebugPrint((0,"VPEMINI: Error in 'NVPUpdate' >>> exceeded number of extra 422 surfaces \n"));
		return ERROR_INVALID_PARAMETER;
	}

	// get a pointer to the overlay object in VPE context
	pnvOverlay = &(pVPEContext->nvpOverlay);

	// update overlay info: extra 422 surfaces used for prescaling
	pnvOverlay->dwExtra422NumSurfaces = pCmdObj->dwExtra422NumSurfaces;
	pnvOverlay->dwExtra422Index = pCmdObj->dwExtra422Index;
	pnvOverlay->dwExtra422Pitch = pCmdObj->dwExtra422Pitch;            // extra surface pitch

    for (i = 0; i < (int)pCmdObj->dwExtra422NumSurfaces; i++)
	{
        pnvOverlay->aExtra422OverlayOffset[i] = pCmdObj->aExtra422OverlayOffset[i];	// extra memory space used for prescaling
    }

	// start video grabbing here if not already done in NVPStart
	if ((pVPEContext->nNumVidSurf > 0) && !(pVPEContext->dwVPState & NVP_STATE_STARTED_VIDEO))
	{
		// start VBI at the same time as video if vbi is not already enabled !
		if (pVPEContext->nNumVBISurf > 0)
		{
		    // is it already started, then no need to do it again...
		    if (!(pVPEContext->dwVPState & NVP_STATE_STARTED_VBI))
			{
				(pVPEContext->aVBISurfaceInfo[pVPEContext->nNumVBISurf - 1]).nNextSurfaceIdx = 0;
				pVPEContext->nNextVBISurfId = 1;
			}
			pVPEContext->dwVPState = (NVP_STATE_STARTED | NVP_STATE_STARTED_VIDEO | NVP_STATE_STARTED_VBI);
		}
		else
	    	pVPEContext->dwVPState = (NVP_STATE_STARTED | NVP_STATE_STARTED_VIDEO);
		 
		(pVPEContext->aVideoSurfaceInfo[pVPEContext->nNumVidSurf - 1]).nNextSurfaceIdx = 0;
		// kick off VP 
		pVPEContext->nNextVideoSurfId = 1;
        pnvOverlay->dwOverlayBufferIndex = NVP_UNDEF;
		// we OR 0x80 to tell function this is not a notifier calling !
		NVPProcessState(pHwDevExt, NVP_FIELD_EVEN | 0x80, FALSE);
		NVPProcessState(pHwDevExt, NVP_FIELD_ODD | 0x80, FALSE);
	}
	// start VBI grabbing here if not already done in NVPStart
    else if ((pVPEContext->nNumVBISurf > 0) && !(pVPEContext->dwVPState & NVP_STATE_STARTED_VBI))
	{
	    // if video already started, then only enable VBI state flag
        if (pVPEContext->dwVPState & NVP_STATE_STARTED_VIDEO)
		{
		    pVPEContext->dwVPState |= NVP_STATE_STARTED_VBI;
		}
		else
		{
			pVPEContext->dwVPState = (NVP_STATE_STARTED | NVP_STATE_STARTED_VBI);
			(pVPEContext->aVBISurfaceInfo[pVPEContext->nNumVBISurf - 1]).nNextSurfaceIdx = 0;
			pVPEContext->nNextVBISurfId = 1;
			// kick off VP 
			NVPProcessState(pHwDevExt, NVP_FIELD_EVEN, TRUE);
			NVPProcessState(pHwDevExt, NVP_FIELD_ODD, TRUE);
		}
	}

	return NO_ERROR;
}

/*
==============================================================================
	
	NVPStart

	Description:	Tells the NV video port to start grabbing video

	Date:			Feb 03, 1999
	
	Author:			H. Azar

==============================================================================
*/
VP_STATUS NVPStart(
    PHW_DEVICE_EXTENSION pHwDevExt,
	NVP_CMD_OBJECT *pCmdObj)
{
	PNVP_CONTEXT pVPEContext;
	PNVP_OVERLAY pnvOverlay;
    int i;

	VideoDebugPrint((3,"VPEMINI: NVPStart()\n"));

	// get a pointer to the appropriate VPE context
	pVPEContext = &(pHwDevExt->avpContexts[pCmdObj->dwPortId]);

	// aleady started ?! it must be an UpdateVideo then...
	if (pVPEContext->dwVPState & NVP_STATE_STARTED)
		return NVPUpdate(pHwDevExt,	pCmdObj);

	// current
	pVPEContext->nVidSurfIdx = 0;
	pVPEContext->nVBISurfIdx = 0;
	// next in the list
	pVPEContext->nNextVideoSurfId = 0;
	pVPEContext->nNextVBISurfId = 0;

	// update overlay channel pointer ! 
	/////// NVPUpdate() must be the place for this !?
	pVPEContext->pOverlayChannel = pCmdObj->pOvrChannel;

	pVPEContext->dwVPState = NVP_STATE_STARTED;
	pVPEContext->dwVPFlags = pCmdObj->dwVPInfoFlags;
//	pVPEContext->aExtra422OverlayOffset[0] = pCmdObj->aExtra422OverlayOffset[0];
//	pVPEContext->aExtra422OverlayOffset[1] = pCmdObj->aExtra422OverlayOffset[1];

    if (pCmdObj->dwExtra422NumSurfaces > NVP_MAX_EXTRA422)
	{
		VideoDebugPrint((0,"VPEMINI: Error in 'NVPStart' >>> exceeded number of extra 422 surfaces \n"));
		return ERROR_INVALID_PARAMETER;
	}

	// get a pointer to the overlay object in VPE context
	pnvOverlay = &(pVPEContext->nvpOverlay);

	// update overlay info: extra 422 surfaces used for prescaling
	pnvOverlay->dwExtra422NumSurfaces = pCmdObj->dwExtra422NumSurfaces;
	pnvOverlay->dwExtra422Index = pCmdObj->dwExtra422Index;
	pnvOverlay->dwExtra422Pitch = pCmdObj->dwExtra422Pitch;            // extra surface pitch

    for (i = 0; i < (int)pCmdObj->dwExtra422NumSurfaces; i++)
	{
        pnvOverlay->aExtra422OverlayOffset[i] = pCmdObj->aExtra422OverlayOffset[i];	// extra memory space used for prescaling
    }

	// make a cyclic chain with surfaces 
	if (pVPEContext->nNumVidSurf > 0)
	{
		pVPEContext->dwVPState |= NVP_STATE_STARTED_VIDEO;
		(pVPEContext->aVideoSurfaceInfo[pVPEContext->nNumVidSurf - 1]).nNextSurfaceIdx = 0;
		// kick off VP 
		pVPEContext->nNextVideoSurfId = 1;
        pnvOverlay->dwOverlayBufferIndex = NVP_UNDEF;
		// before kicking off the media port, check out VBI setting
		if (pVPEContext->nNumVBISurf > 0)
		{
			pVPEContext->dwVPState |= NVP_STATE_STARTED_VBI;
			(pVPEContext->aVBISurfaceInfo[pVPEContext->nNumVBISurf - 1]).nNextSurfaceIdx = 0;
			pVPEContext->nNextVBISurfId = 1;
		}
		// we OR 0x80 to tell function this is not a notifier calling !
		NVPProcessState(pHwDevExt, NVP_FIELD_EVEN | 0x80, FALSE);
		NVPProcessState(pHwDevExt, NVP_FIELD_ODD | 0x80, FALSE);
	}
	else if (pVPEContext->nNumVBISurf > 0)
	{
		pVPEContext->dwVPState |= NVP_STATE_STARTED_VBI;
		(pVPEContext->aVBISurfaceInfo[pVPEContext->nNumVBISurf - 1]).nNextSurfaceIdx = 0;
		pVPEContext->nNextVBISurfId = 1;
		// kick off VP 
		NVPProcessState(pHwDevExt, NVP_FIELD_EVEN, TRUE);
		NVPProcessState(pHwDevExt, NVP_FIELD_ODD, TRUE);
	}

	return NO_ERROR;
}

/*
==============================================================================
	
	NVP3Stop

	Description:	Tells the NV video port to stop grabbing. PIO channel 
					version

	Date:			Feb 03, 1999
	
	Author:			H. Azar

==============================================================================
*/
VP_STATUS NVP3Stop(
    PHW_DEVICE_EXTENSION pHwDevExt,
	NVP_CMD_OBJECT *pCmdObj)
{
	Nv03ChannelPio *pNVPChannel = (Nv03ChannelPio *) (pCmdObj->pChannel);
	PNVP_CONTEXT pVPEContext;
	NvNotification *avpNotifiers;
	NVOS09_PARAMETERS ntfParam;
	U032 i = 0;

	VideoDebugPrint((3,"VPEMINI: NVP3Stop()\n"));

	// get a pointer to the appropriate VPE context
	pVPEContext = &(pHwDevExt->avpContexts[pCmdObj->dwPortId]);
	// aleady stopped ?!
	if (pVPEContext->dwVPState & NVP_STATE_STOPPED)
		return NO_ERROR;
	else
		pVPEContext->dwVPState = NVP_STATE_STOPPED;

	g_bFlip = FALSE;

	pVPEContext->pNVPChannel = (ULONG) pNVPChannel;	// get a copy of the pio channel pointer
	avpNotifiers = (NvNotification *) (pVPEContext->avpNotifiers);

	// tell VP to stop grabbing !
	pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.StopTransferImage = 0;
	pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.StopTransferVbi = 0;


// NO LONGER EXISTS IN OFFICIAL NVOS.H....ASK!!!

//	ntfParam.hObjectParent = pCmdObj->dwDeviceId;


#define NVP_NOTIFY_TIMEOUT 100000
	// wait for the last few notifies to show up...
	while ((((avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS) ||
	         (avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS)) &&
		   ((avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(0)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS) || 
		   (avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(1)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS)) &&
		   (i < NVP_NOTIFY_TIMEOUT)))
	{
		i++;
		//RmInterrupt(&ntfParam);
	}

	// reset surfaces counters
	pVPEContext->nNumVBISurf = 0;
	pVPEContext->nNumVidSurf = 0;

	return NO_ERROR;
}


/*
==============================================================================
	
	NVPStop

	Description:	Tells the NV video port to stop grabbing

	Date:			Feb 03, 1999
	
	Author:			H. Azar

==============================================================================
*/
VP_STATUS NVPStop(
    PHW_DEVICE_EXTENSION pHwDevExt,
	NVP_CMD_OBJECT *pCmdObj)
{
	PNVP_CONTEXT pVPEContext;
	NvNotification *avpNotifiers;
    Nv03ChannelPio *pOvChannel;
	Nv4ControlDma *pDmaChannel;
	U032 nvDmaCount;
    NvNotification *pPioFlipOverlayNotifier;
	U032 i;

	// get a pointer to the appropriate VPE context
	pVPEContext = &(pHwDevExt->avpContexts[pCmdObj->dwPortId]);

    // overlay channel
    pOvChannel = (Nv03ChannelPio *) (pVPEContext->pOverlayChannel);	// get a pointer to the overlay channel

	// NV3 specific code
	if (NVP_GET_CHIP_VER(pVPEContext->dwChipId) <= NVP_CHIP_VER_03)
		return NVP3Stop(pHwDevExt, pCmdObj);

	VideoDebugPrint((3,"VPEMINI: NVPStop()\n"));

	// aleady stopped ?!
	if (pVPEContext->dwVPState & NVP_STATE_STOPPED)
		return NO_ERROR;
	else
		pVPEContext->dwVPState = NVP_STATE_STOPPED;

    // channel
	pDmaChannel = (Nv4ControlDma *)(pVPEContext->pDmaChannel);
	nvDmaCount = pVPEContext->nvDmaCount;

	// stop overlay engine
	if (pOvChannel && g_bFlip)
	{
	    g_bFlip = FALSE;

	    NVP_DMAPUSH_CHECK_FREE_COUNT(6);
        NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OBJECT, NVP_OVERLAY_OBJECT); //pOverlayInfo->dwOverlayObjectID);
        NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_STOP_OVERLAY(0), NV07A_STOP_OVERLAY_BETWEEN_BUFFERS);
        NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_STOP_OVERLAY(1), NV07A_STOP_OVERLAY_BETWEEN_BUFFERS);
		pDmaChannel->Put = nvDmaCount << 2;
	    pVPEContext->nvDmaCount = nvDmaCount;

		// reset notifiers
        pPioFlipOverlayNotifier = (NvNotification *)pVPEContext->nvpOverlay.pNvPioFlipOverlayNotifierFlat;

        i = 0;
        while (((pPioFlipOverlayNotifier[1].status == NV_IN_PROGRESS) || (pPioFlipOverlayNotifier[2].status == NV_IN_PROGRESS)) && (i < NVP_VPP_TIME_OUT))
            i++;

        // timed-out... 
        if (i >= NVP_VPP_TIME_OUT)
	        VideoDebugPrint((0,"VPEMINI: waiting for overlay flip notifiers timed-out....\n"));

        pPioFlipOverlayNotifier[1].status = 0;
        pPioFlipOverlayNotifier[2].status = 0;
    }

	avpNotifiers = (NvNotification *) (pVPEContext->avpNotifiers);

	// tell VP to stop grabbing !
	nvDmaCount = pVPEContext->nvDmaCount;
	NVP_DMAPUSH_CHECK_FREE_COUNT(6);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_OBJECT , NVP_EXTERNAL_DECODER_OBJECT);
	//if (pCmdObj->dwStopStrm & NVP_STOP_VIDEO)
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_STOP_TRANSFER_IMAGE , 0);
	//if (pCmdObj->dwStopStrm & NVP_STOP_VBI)
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_STOP_TRANSFER_VBI , 0);
    pDmaChannel->Put = nvDmaCount << 2;
	pVPEContext->nvDmaCount = nvDmaCount;

#define NVP_NOTIFY_TIMEOUT 100000
    i = 0;
	// wait for the last few notifies to show up...
	while ((((avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS) ||
	         (avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS)) &&
		   ((avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(0)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS) || 
		   (avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(1)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS)) &&
		   (i < NVP_NOTIFY_TIMEOUT)))
	{
		i++;
		//RmInterrupt(&ntfParam);
	}

    // timed-out... 
    if (i >= NVP_NOTIFY_TIMEOUT)
        VideoDebugPrint((0,"VPEMINI: waiting for MediaPort notifiers timed-out....\n"));

	avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
	avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
	avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(0)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
	avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(1)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;

	// reset surfaces counters
	pVPEContext->nNumVBISurf = 0;
	pVPEContext->nNumVidSurf = 0;

    // clear/reset sync event 
	KeClearEvent((PVOID)pVPEContext->hVPSyncEvent);

	return NO_ERROR;
}

/*
==============================================================================
	
	NVPRegSurface

	Description:	register a DDraw surface. Insert in list and update 
					attributes

	Date:			Feb 18, 1999
	
	Author:			H. Azar

==============================================================================
*/
VP_STATUS NVPRegSurface(
    PHW_DEVICE_EXTENSION pHwDevExt,
	NVP_CMD_OBJECT *pCmdObj)
{
	PNVP_CONTEXT pVPEContext;
	PNVP_SURFACE_INFO pSurface;
	BOOL bVideoStarted, bVBIStarted;

	VideoDebugPrint((3,"VPEMINI: NVPRegSurface()\n"));

	// get a pointer to the appropriate VPE context
	pVPEContext = &(pHwDevExt->avpContexts[pCmdObj->dwPortId]);

    bVideoStarted = (pVPEContext->dwVPState & NVP_STATE_STARTED_VIDEO);
    bVBIStarted = (pVPEContext->dwVPState & NVP_STATE_STARTED_VBI);

	// update attributes of already existing surfaces ?!
	if (pCmdObj->bSurfUpdate)
	{
		// vbi surfaces ?!
		if (pCmdObj->bSurfVBI)
		{
			if (pCmdObj->dwSurfaceId < (ULONG)pVPEContext->nNumVBISurf)
			{
				pSurface = &(pVPEContext->aVBISurfaceInfo[pCmdObj->dwSurfaceId]);
				// check for mem offset in framebuffer !
				if (pSurface->pVidMem == pCmdObj->pSurfVidMem)
				{
				    pSurface->dwHeight = pCmdObj->dwVBIHeight;
				    pSurface->dwStartLine = pCmdObj->dwVBIStartLine; 		// startline for vbi

				}
				else
				{
					VideoDebugPrint((0,"VPEMINI: can't update VBI surface data !\n"));
					return ERROR_INVALID_PARAMETER;
				}

			}
			else
			{
				// new vbi surfaces
				pSurface = &(pVPEContext->aVBISurfaceInfo[pCmdObj->dwSurfaceId]);
				(pVPEContext->nNumVBISurf)++;
			    pSurface->pVidMem = pCmdObj->pSurfVidMem;				// Flat pointer to the surface
			    pSurface->dwOffset = pCmdObj->dwSurfOffset;         	// Offset from the base of the frame buffer
			    pSurface->dwPitch = pCmdObj->dwSurfPitch;
			    pSurface->dwHeight = pCmdObj->dwVBIHeight;
			    pSurface->dwStartLine = pCmdObj->dwVBIStartLine; 		// Programs Y-crop for image, and startline for vbi
			    pSurface->nNextSurfaceIdx = pCmdObj->dwSurfaceId + 1;	// the next surface idx in the chain
				pSurface->bIsFirstFieldCaptured = FALSE;				// reset value

			}
		}
		else	// video surface
		{
			if (pCmdObj->dwSurfaceId < (ULONG)pVPEContext->nNumVidSurf)
			{
				//////////
				///// I assume something changing in the following values only !
				pSurface = &(pVPEContext->aVideoSurfaceInfo[pCmdObj->dwSurfaceId]);
				if (pSurface->pVidMem == pCmdObj->pSurfVidMem)
				{
				    pSurface->dwHeight = pCmdObj->dwInHeight;
				    pSurface->dwWidth = pCmdObj->dwInWidth;            		// Ignored for VBI
				    pSurface->dwStartLine = pCmdObj->dwImageStartLine; 		// Programs Y-crop for image, and startline for vbi
				    pSurface->dwPreScaleSizeX = pCmdObj->dwPreWidth;    	// Ignored for VBI.. prescale size width
				    pSurface->dwPreScaleSizeY = pCmdObj->dwPreHeight;   	// Ignored for VBI.. prescale size height
				}
				else
				{
					VideoDebugPrint((0,"VPEMINI: can't update video surface data !\n"));
					return ERROR_INVALID_PARAMETER;
				}
			}
			else
			{
				// new video surfaces
				pSurface = &(pVPEContext->aVideoSurfaceInfo[pCmdObj->dwSurfaceId]);
				(pVPEContext->nNumVidSurf)++;
			    pSurface->pVidMem = pCmdObj->pSurfVidMem;				// Flat pointer to the surface
			    pSurface->dwOffset = pCmdObj->dwSurfOffset;         	// Offset from the base of the frame buffer
			    pSurface->dwPitch = pCmdObj->dwSurfPitch;
			    pSurface->dwHeight = pCmdObj->dwInHeight;
			    pSurface->dwWidth = pCmdObj->dwInWidth;            		// Ignored for VBI
			    pSurface->dwStartLine = pCmdObj->dwImageStartLine; 		// Programs Y-crop for image, and startline for vbi
			    pSurface->dwPreScaleSizeX = pCmdObj->dwPreWidth;    	// Ignored for VBI.. prescale size width
			    pSurface->dwPreScaleSizeY = pCmdObj->dwPreHeight;   	// Ignored for VBI.. prescale size height
			    pSurface->nNextSurfaceIdx = pCmdObj->dwSurfaceId + 1;	// the next surface idx in the chain
				pSurface->bIsFirstFieldCaptured = FALSE;				// reset value

			}
		}
	}
	else	// new surfaces !
	{
		if (pVPEContext->dwVPState & NVP_STATE_STARTED)
		{
			VideoDebugPrint((0,"VPEMINI: can't register new DD surfaces while Video Port is running !\n"));
			return ERROR_INVALID_PARAMETER;
		}

		// vbi surfaces ?!
		if (pCmdObj->bSurfVBI)
		{
			pSurface = &(pVPEContext->aVBISurfaceInfo[pCmdObj->dwSurfaceId]);
			(pVPEContext->nNumVBISurf)++;
		    pSurface->dwStartLine = pCmdObj->dwVBIStartLine; 		// startline for vbi
		}
		else	// video surface
		{
			pSurface = &(pVPEContext->aVideoSurfaceInfo[pCmdObj->dwSurfaceId]);
			(pVPEContext->nNumVidSurf)++;
		    pSurface->dwStartLine = pCmdObj->dwImageStartLine; 		// startline for video
		}

	    pSurface->pVidMem = pCmdObj->pSurfVidMem;				// Flat pointer to the surface
	    pSurface->dwOffset = pCmdObj->dwSurfOffset;         	// Offset from the base of the frame buffer
	    pSurface->dwPitch = pCmdObj->dwSurfPitch;
	    pSurface->dwHeight = pCmdObj->dwInHeight;
	    pSurface->dwWidth = pCmdObj->dwInWidth;            		// Ignored for VBI
	    pSurface->dwPreScaleSizeX = pCmdObj->dwPreWidth;    	// Ignored for VBI.. prescale size width
	    pSurface->dwPreScaleSizeY = pCmdObj->dwPreHeight;   	// Ignored for VBI.. prescale size height
	    pSurface->nNextSurfaceIdx = pCmdObj->dwSurfaceId + 1;	// the next surface idx in the chain
		pSurface->bIsFirstFieldCaptured = FALSE;				// reset value
	}

	return NO_ERROR;
}

/*
==============================================================================
	
	NVPUpdateOverlay

	Description:	update the overlay info structure

	Date:			Mar 01, 1999
	
	Author:			H. Azar

==============================================================================
*/
VP_STATUS NVPUpdateOverlay(
    PHW_DEVICE_EXTENSION pHwDevExt,
	NVP_CMD_OBJECT *pCmdObj)
{
	PNVP_CONTEXT pVPEContext = &(pHwDevExt->avpContexts[pCmdObj->dwPortId]);
    Nv03ChannelPio *pChannel = (Nv03ChannelPio *) (pVPEContext->pOverlayChannel);	// get a pointer to the overlay channel;
	PNVP_OVERLAY pnvOverlay =  &(pVPEContext->nvpOverlay);
    NvNotification *pPioFlipOverlayNotifier;
	Nv4ControlDma *pDmaChannel;
	U032 nvDmaCount;
	int i = 0;

	VideoDebugPrint((3,"VPEMINI: NVPUpdateOverlay()\n"));

	if ((pCmdObj->dwOverlayDstWidth != 0) && (pCmdObj->dwOverlayDstHeight != 0))
	{
		// I must rather have a structure memcpy !
		pnvOverlay->dwOverlayFormat = pCmdObj->dwOverlayFormat;
		pnvOverlay->dwOverlaySrcX = pCmdObj->dwOverlaySrcX;
		pnvOverlay->dwOverlaySrcY = pCmdObj->dwOverlaySrcY;
		pnvOverlay->dwOverlaySrcPitch = pCmdObj->dwOverlaySrcPitch;
		pnvOverlay->dwOverlaySrcSize = pCmdObj->dwOverlaySrcSize;
		pnvOverlay->dwOverlaySrcWidth = pCmdObj->dwOverlaySrcWidth;
		pnvOverlay->dwOverlaySrcHeight = pCmdObj->dwOverlaySrcHeight;
		pnvOverlay->dwOverlayDstWidth = pCmdObj->dwOverlayDstWidth;
		pnvOverlay->dwOverlayDstHeight = pCmdObj->dwOverlayDstHeight;
		pnvOverlay->dwOverlayDstX = pCmdObj->dwOverlayDstX;
	    pnvOverlay->dwOverlayDstY = pCmdObj->dwOverlayDstY;
		pnvOverlay->dwOverlayDeltaX = pCmdObj->dwOverlayDeltaX;
		pnvOverlay->dwOverlayDeltaY = pCmdObj->dwOverlayDeltaY;
		pnvOverlay->dwOverlayColorKey = pCmdObj->dwOverlayColorKey;
		pnvOverlay->dwOverlayMode = pCmdObj->dwOverlayMode;
	    pnvOverlay->dwOverlayMaxDownScale = pCmdObj->dwOverlayMaxDownScale;

		VideoDebugPrint((3,"VPEMINI: overlay flipping enabled....\n"));
		g_bFlip = TRUE;
	}
	else
	{
		VideoDebugPrint((3,"VPEMINI: overlay flipping disabled....\n"));
		g_bFlip = FALSE;	// no autoflip !
		// stop overlay engine
		if (pChannel)
		{
		    // channel
			pDmaChannel = (Nv4ControlDma *)(pVPEContext->pDmaChannel);
			nvDmaCount = pVPEContext->nvDmaCount;

		    NVP_DMAPUSH_CHECK_FREE_COUNT(6);
	        NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OBJECT, NVP_OVERLAY_OBJECT); //pOverlayInfo->dwOverlayObjectID);
	        NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_STOP_OVERLAY(0), NV07A_STOP_OVERLAY_BETWEEN_BUFFERS);
	        NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_STOP_OVERLAY(1), NV07A_STOP_OVERLAY_BETWEEN_BUFFERS);
			pDmaChannel->Put = nvDmaCount << 2;
		    pVPEContext->nvDmaCount = nvDmaCount;

			// reset notifiers
            pPioFlipOverlayNotifier = (NvNotification *)pnvOverlay->pNvPioFlipOverlayNotifierFlat;

            while (((pPioFlipOverlayNotifier[1].status == NV_IN_PROGRESS) || (pPioFlipOverlayNotifier[2].status == NV_IN_PROGRESS)) && (i < NVP_VPP_TIME_OUT))
                i++;
            // timed-out... 
            if (i >= NVP_VPP_TIME_OUT)
		        VideoDebugPrint((0,"VPEMINI: waiting for overlay flip notifiers timed-out....\n"));

	        pPioFlipOverlayNotifier[1].status = 0;
            pPioFlipOverlayNotifier[2].status = 0;
		}
	}

	return NO_ERROR;
}

/*
==============================================================================
	
	NVPFlipVideoPort

	Description:	start capturing in specified surface 

	Date:			Mar 01, 1999
	
	Author:			H. Azar

==============================================================================
*/
VP_STATUS NVPFlipVideoPort(
    PHW_DEVICE_EXTENSION pHwDevExt,
	NVP_CMD_OBJECT *pCmdObj)
{
	PNVP_CONTEXT pVPEContext;
	PNVP_SURFACE_INFO pSurface;
	NvNotification *avpNotifiers;
	int i;

	VideoDebugPrint((3,"VPEMINI: NVPFlipVideoPort()\n"));

	// get a pointer to the appropriate VPE context
	pVPEContext = &(pHwDevExt->avpContexts[pCmdObj->dwPortId]);

	// NVP_UNDEF tells us to lookup the surface in list
	if (pCmdObj->dwSurfaceId == NVP_UNDEF)
	{
		for (i = 0; i < pVPEContext->nNumVidSurf; i++)
		{
				//////////
				///// I assume nothing changing in the surfaces values 
				pSurface = &(pVPEContext->aVideoSurfaceInfo[i]);
				if (pSurface->pVidMem == pCmdObj->pSurfVidMem)
				{
				    // clear/reset sync event 
					KeClearEvent((PVOID)pVPEContext->hVPSyncEvent);
					// found target surface, so update index of video surface we're currently capturing into
					pVPEContext->nVidSurfIdx = i;
					return NO_ERROR;
				}
		}
	}
	else
	{
		// check for weird values !
		if ((pCmdObj->dwSurfaceId >= 0) && 
			(pCmdObj->dwSurfaceId < pVPEContext->nNumVidSurf) && 
			(pVPEContext->aVideoSurfaceInfo[pCmdObj->dwSurfaceId].pVidMem == pCmdObj->pSurfVidMem))
		{
			    // clear/reset sync event 
				KeClearEvent((PVOID)pVPEContext->hVPSyncEvent);
				// update index of video surface we're currently capturing into
				pVPEContext->nVidSurfIdx = (int)(pCmdObj->dwSurfaceId);
				return NO_ERROR;
		}
	}

	////// if we got here, it means the target surface wasn't found in list... 
	// so add it at the end of the list  
	i = pVPEContext->nNumVidSurf;
	pSurface = &(pVPEContext->aVideoSurfaceInfo[i]);
	(pVPEContext->nNumVidSurf)++;
	pSurface->dwStartLine = pCmdObj->dwImageStartLine; 		// startline for video
    pSurface->pVidMem = pCmdObj->pSurfVidMem;				// Flat pointer to the surface
    pSurface->dwOffset = pCmdObj->dwSurfOffset;         	// Offset from the base of the frame buffer
    pSurface->dwPitch = pCmdObj->dwSurfPitch;
    pSurface->dwHeight = pCmdObj->dwInHeight;
    pSurface->dwWidth = pCmdObj->dwInWidth;            		// Ignored for VBI
    pSurface->dwPreScaleSizeX = pCmdObj->dwPreWidth;    	// Ignored for VBI.. prescale size width
    pSurface->dwPreScaleSizeY = pCmdObj->dwPreHeight;   	// Ignored for VBI.. prescale size height
    pSurface->nNextSurfaceIdx = 0;							// the next surface idx in the chain
	pSurface->bIsFirstFieldCaptured = FALSE;				// reset value
    // clear/reset sync event 
	KeClearEvent((PVOID)pVPEContext->hVPSyncEvent);
	// flip to surface !
	pVPEContext->nVidSurfIdx = i;							

	return NO_ERROR;
}

/*
==============================================================================
	
	NVP3ProgVideoField

	Description:	programs the vp to capture the specified video field

	Date:			Feb 19, 1999
	
	Author:			H. Azar

==============================================================================
*/
void NVP3ProgVideoField(
	PNVP_CONTEXT pVPEContext,
	PNVP_SURFACE_INFO pSurface,
	int nFieldId,
	U032 dwSurfPitch,
	U032 dwInterleaveOffset,
	BOOL bGrab)
{
	Nv03ChannelPio *pNVPChannel;
	NvNotification *avpNotifiers;
	int nFreeCount;
	NVOS09_PARAMETERS ntfParam;

	pSurface->dwFieldType = (ULONG)nFieldId;

	// get a pointer to the appropriate VPE context
	pNVPChannel = (Nv03ChannelPio *)(pVPEContext->pNVPChannel) ;	// get a copy of the pio channel pointer

#ifdef _NV_DPC
	//CHECK_FREE_COUNT(pNVPChannel,6*4);
	ntfParam.hObjectParent = pVPEContext->dwDeviceId;
	nFreeCount = pVPEContext->nFreeCount;
	while (nFreeCount < 7*4) 
	{
		//RmInterrupt(&ntfParam);
		nFreeCount = NvGetFreeCount(pNVPChannel, 0);
	}			
	pVPEContext->nFreeCount = nFreeCount - (7*4);
#endif

	avpNotifiers = (NvNotification *) (pVPEContext->avpNotifiers);
	// program the VP to grab in the next surface
	avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(nFieldId)].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;

	pNVPChannel->subchannel[0].SetObject = NVP_EXTERNAL_DECODER_OBJECT;
	pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetImage[nFieldId].sizeIn  = (pSurface->dwWidth) | (pSurface->dwHeight << 16);
	pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetImage[nFieldId].sizeOut = (pSurface->dwPreScaleSizeX) | (pSurface->dwPreScaleSizeY << 16);

	pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetImageStartLine = pSurface->dwStartLine;
	pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetImage[nFieldId].offset  = pSurface->dwOffset + dwInterleaveOffset; 

	pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetImage[nFieldId].format =
			(dwSurfPitch & 0xFFFF)  |
			((((nFieldId == NVP_FIELD_EVEN) ? NV04D_SET_IMAGE_FORMAT_FIELD_EVEN_FIELD : NV04D_SET_IMAGE_FORMAT_FIELD_ODD_FIELD) << 16) & 0xFF0000) |
			((NV04D_SET_IMAGE_FORMAT_NOTIFY_WRITE_THEN_AWAKEN << 24 ) & 0xFF000000);
}

/*
==============================================================================
	
	NVP3ProgVBIField

	Description:	programs the vp to capture the specified VBI field.
					PIO channel version.

	Date:			Feb 19, 1999
	
	Author:			H. Azar

==============================================================================
*/
void NVP3ProgVBIField(
	PNVP_CONTEXT pVPEContext,
	PNVP_SURFACE_INFO pSurface,
	int nFieldId)
{
	Nv03ChannelPio *pNVPChannel;
	int nFreeCount;
	NVOS09_PARAMETERS ntfParam;
	NvNotification *avpNotifiers;

	pSurface->dwFieldType = (ULONG)nFieldId;

	// get a pointer to the appropriate VPE context
	pNVPChannel = (Nv03ChannelPio *)(pVPEContext->pNVPChannel) ;	// get a copy of the pio channel pointer

#ifdef _NV_DPC
	//CHECK_FREE_COUNT(pNVPChannel,5*4);
	ntfParam.hObjectParent = pVPEContext->dwDeviceId;
	nFreeCount = pVPEContext->nFreeCount;
	while (nFreeCount < 5*4) 
	{
		//RmInterrupt(&ntfParam);
		nFreeCount = NvGetFreeCount(pNVPChannel, 0);
	}
	pVPEContext->nFreeCount = nFreeCount - (5*4);
#endif
	avpNotifiers = (NvNotification *) (pVPEContext->avpNotifiers);
	avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(nFieldId)].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;

	pNVPChannel->subchannel[0].SetObject = NVP_EXTERNAL_DECODER_OBJECT;
	pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetVbi[nFieldId].size  = (pSurface->dwStartLine) | (pSurface->dwHeight << 16);
	pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetVbi[nFieldId].offset  = pSurface->dwOffset;
	pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetVbi[nFieldId].format =
			(pSurface->dwPitch & 0xFFFF)  |
			((((nFieldId == NVP_FIELD_EVEN) ? NV04D_SET_VBI_FORMAT_FIELD_EVEN_FIELD : NV04D_SET_VBI_FORMAT_FIELD_ODD_FIELD) << 16) & 0xFF0000) |
			((NV04D_SET_VBI_FORMAT_NOTIFY_WRITE_THEN_AWAKEN << 24) & 0xFF000000);
}

/*
==============================================================================
	
	NVPProgVideoField

	Description:	programs the vp to capture the specified video field

	Date:			Apr 19, 1999
	
	Author:			H. Azar

==============================================================================
*/
void NVPProgVideoField(
	PNVP_CONTEXT pVPEContext,
	PNVP_SURFACE_INFO pSurface,
	int nFieldId,
	U032 dwSurfPitch,
	U032 dwInterleaveOffset,
	BOOL bGrab)
{
	Nv4ControlDma *pDmaChannel;
	NvNotification *avpNotifiers;
	U032 dwFormat;
	U032 nvDmaCount;

	// NV3 specific code
	if (NVP_GET_CHIP_VER(pVPEContext->dwChipId) <= NVP_CHIP_VER_03)
	{
		NVP3ProgVideoField(pVPEContext, pSurface, nFieldId, dwSurfPitch, dwInterleaveOffset, bGrab);
		return;
	}

	// update type of field we're capturing
	pSurface->dwFieldType = (ULONG)nFieldId;

	pDmaChannel = (Nv4ControlDma *)(pVPEContext->pDmaChannel);
    nvDmaCount = pVPEContext->nvDmaCount;
	NVP_DMAPUSH_CHECK_FREE_COUNT(12);

	// reset notifier
	avpNotifiers = (NvNotification *) (pVPEContext->avpNotifiers);
	avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(nFieldId)].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;

	// program the VP to grab in the next surface
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_OBJECT , NVP_EXTERNAL_DECODER_OBJECT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_IMAGE_SIZE_IN(nFieldId), ((pSurface->dwWidth) | (pSurface->dwHeight << 16)));
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_IMAGE_SIZE_OUT(nFieldId), ((pSurface->dwPreScaleSizeX) | (pSurface->dwPreScaleSizeY << 16)));
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_IMAGE_START_LINE, pSurface->dwStartLine);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_IMAGE_OFFSET(nFieldId), (pSurface->dwOffset + dwInterleaveOffset));
	dwFormat = ((dwSurfPitch & 0xFFFF) |
				((((nFieldId == NVP_FIELD_EVEN) ? NV04D_SET_IMAGE_FORMAT_FIELD_EVEN_FIELD : NV04D_SET_IMAGE_FORMAT_FIELD_ODD_FIELD) << 16) & 0xFF0000) |
				((NV04D_SET_IMAGE_FORMAT_NOTIFY_WRITE_THEN_AWAKEN << 24 ) & 0xFF000000));

	NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_IMAGE_FORMAT(nFieldId), dwFormat);

    pDmaChannel->Put = nvDmaCount << 2;
	pVPEContext->nvDmaCount = nvDmaCount;
}

/*
==============================================================================
	
	NVPProgVBIField

	Description:	programs the vp to capture the specified VBI field

	Date:			Apr 22, 1999
	
	Author:			H. Azar

==============================================================================
*/
void NVPProgVBIField(
	PNVP_CONTEXT pVPEContext,
	PNVP_SURFACE_INFO pSurface,
	int nFieldId)
{
	Nv4ControlDma *pDmaChannel;
	NvNotification *avpNotifiers;
	U032 dwFormat;
	U032 nvDmaCount;

	// NV3 specific code
	if (NVP_GET_CHIP_VER(pVPEContext->dwChipId) <= NVP_CHIP_VER_03)
	{
		NVP3ProgVBIField(pVPEContext, pSurface, nFieldId);
		return;
	}

	// update type of field we're capturing
	pSurface->dwFieldType = (ULONG)nFieldId;

	pDmaChannel = (Nv4ControlDma *)(pVPEContext->pDmaChannel);
    nvDmaCount = pVPEContext->nvDmaCount;
	NVP_DMAPUSH_CHECK_FREE_COUNT(8);

	// reset notifier
	avpNotifiers = (NvNotification *) (pVPEContext->avpNotifiers);
	avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(nFieldId)].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;

	// program the VP to grab in the next surface
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_OBJECT , NVP_EXTERNAL_DECODER_OBJECT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_VBI_SIZE(nFieldId), ((pSurface->dwStartLine) | (pSurface->dwHeight << 16)));
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_VBI_OFFSET(nFieldId), pSurface->dwOffset);
	dwFormat = (pSurface->dwPitch & 0xFFFF)  |
			((((nFieldId == NVP_FIELD_EVEN) ? NV04D_SET_VBI_FORMAT_FIELD_EVEN_FIELD : NV04D_SET_VBI_FORMAT_FIELD_ODD_FIELD) << 16) & 0xFF0000) |
			((NV04D_SET_VBI_FORMAT_NOTIFY_WRITE_THEN_AWAKEN << 24) & 0xFF000000);
	NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_VBI_FORMAT(nFieldId), dwFormat);

    pDmaChannel->Put = nvDmaCount << 2;
	pVPEContext->nvDmaCount = nvDmaCount;
}


/*
==============================================================================
	
	NVPProcessState

	Description:	programs the video port grab in a surface and determines
					which surface is next.

	Date:			Feb 03, 1999
	
	Author:			H. Azar

==============================================================================
*/
VP_STATUS NVPProcessState(
	PHW_DEVICE_EXTENSION pHwDevExt,
	int nIndex,
	BOOL bVBIField)
{
	PNVP_CONTEXT pVPEContext;
	PNVP_SURFACE_INFO pSurface;
	int nFieldId = nIndex & 1;
	U032 status;
	BOOL bIRQCallback;

	VideoDebugPrint((3,"VPEMINI: NVPProcessState()\n"));

	// get a pointer to the appropriate VPE context
	pVPEContext = &(pHwDevExt->avpContexts[0]);

    // setting nIndex to greater than 1 (nField | any_value) means that the caller is NVPStart or NVPUpdate
	// so first time initialize the dwOverlayIndex to match up with the nFieldId (notifier)
    if ((pVPEContext->nvpOverlay.dwOverlayBufferIndex == NVP_UNDEF) && (nIndex <= 1))
       pVPEContext->nvpOverlay.dwOverlayBufferIndex = nFieldId;

	// calling IRQCallback must be done only at the end of video field or at end of vbi when
	// capturing vbi only 
	bIRQCallback = (!bVBIField) || (pVPEContext->nNumVidSurf == 0);
	// any transfer request of already captured vbi/video data ?!
	if (bIRQCallback)
		NVPCheckForLaunch(pVPEContext, NULL);


	if (pVPEContext->dwVPState != NVP_STATE_STOPPED)
    {
        if (pVPEContext->dwVPState & NVP_STATE_STARTED_VIDEO)
	    {
		    // program VBI here. This way VBI is synchronized with the video thus we eliminate the need 
		    // for a seperate VBI notifications routine unless we're streaming VBI only
		    if (!bVBIField)
			{
			    if (pVPEContext->dwVPState & NVP_STATE_STARTED_VBI)
				{
					pSurface = &(pVPEContext->aVBISurfaceInfo[pVPEContext->nNextVBISurfId]);
					// program the VP to grab in the next surface
					NVPProgVBIField(pVPEContext, pSurface, nFieldId);

					// next surface in the chain !
					pVPEContext->nVBISurfIdx = pVPEContext->nNextVBISurfId;
					pVPEContext->nNextVBISurfId = pSurface->nNextSurfaceIdx;
				}

				if (pVPEContext->dwVPConFlags & DDVPCONNECT_INTERLACED)
				{
					if (pVPEContext->dwVPFlags & DDVP_INTERLEAVE)
					{
						if (pVPEContext->nvpOverlay.dwOverlayMode & NV_VFM_FORMAT_BOBFROMINTERLEAVE)
						{
							// Bob from interleaved surfaces (skip even/odd included here too)
							DoBobFromInterleaved(pVPEContext, nFieldId);
						}
						else
						{
							// Weave
							DoWeave(pVPEContext, nFieldId);
						}
					}
					else
					{
						// Bob from non-interleaved (separate) surfaces (skip even/odd included here too)
						DoBob(pVPEContext, nFieldId);
					}
				}
				else
				{
					// Progressive 
					DoProgressive(pVPEContext, nFieldId);
				}
			}
		}
        else if (pVPEContext->dwVPState & NVP_STATE_STARTED_VBI)
		{
			pSurface = &(pVPEContext->aVBISurfaceInfo[pVPEContext->nNextVBISurfId]);
			// program the VP to grab in the next surface
			NVPProgVBIField(pVPEContext, pSurface, nFieldId);

			// next surface in the chain !
			pVPEContext->nVBISurfIdx = pVPEContext->nNextVBISurfId;
			pVPEContext->nNextVBISurfId = pSurface->nNextSurfaceIdx;
		}
    }

	//
	// calling IRQCallback must be done only at the end of video field or at end of vbi when
	// capturing vbi only 
	if (bIRQCallback)
	{
		// can we pass on the interrupt !
		if ((pHwDevExt->IRQCallback) && (pHwDevExt->dwIRQSources & DDIRQ_VPORT0_VSYNC))
		{
			PDX_IRQDATA pIRQData;
			pIRQData = (PDX_IRQDATA)(pHwDevExt->pIRQData);
			pIRQData->dwIrqFlags |= DDIRQ_VPORT0_VSYNC;
			((PDX_IRQCALLBACK)(pHwDevExt->IRQCallback))(pIRQData);
		}
	}

	return NO_ERROR;
}


/*
==============================================================================
	
	NVPEProcessCommand

	Description:	dispatches commands sent via IOCTL to the appropriate 
					NVP function

	Date:			Feb 03, 1999
	
	Author:			H. Azar

==============================================================================
*/
VP_STATUS NVPEProcessCommand(
    PVOID pHwDeviceExtension,
    PVIDEO_REQUEST_PACKET pRequestPacket)
{
	U032 status = 0;
	NVP_CMD_OBJECT *pnvCmdObj;
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pHwDeviceExtension;

	VideoDebugPrint((3,"VPEMINI: NVPEProcessCommand()\n"));

	pnvCmdObj = (NVP_CMD_OBJECT *)(pRequestPacket->InputBuffer);
	// some arguments validation
	if ((pnvCmdObj->dwPortId < 0) || (pnvCmdObj->dwPortId >= NVP_MAX_VPORTS)) 
		return ERROR_INVALID_PARAMETER;

	// dispatch call
	switch (pnvCmdObj->dwSrvId)
	{
		case NVP_SRV_INITIALIZE:
			status = NVPInitialize(pHwDevExt, pnvCmdObj);
			break;
		case NVP_SRV_UNINITIALIZE:
			status = NVPUninitialize(pHwDevExt, pnvCmdObj);
			break;
		case NVP_SRV_START_VIDEO:
			status = NVPStart(pHwDevExt, pnvCmdObj);
			break;
		case NVP_SRV_STOP_VIDEO:
			status = NVPStop(pHwDevExt, pnvCmdObj);
			break;
		case NVP_SRV_UPDATE_VIDEO:
			status = NVPUpdate(pHwDevExt, pnvCmdObj);
			break;
		case NVP_SRV_REG_SURFACE:
			status = NVPRegSurface(pHwDevExt, pnvCmdObj);
			break;
		case NVP_SRV_UPDATE_OVERLAY:
			status = NVPUpdateOverlay(pHwDevExt, pnvCmdObj);
			break;
		case NVP_SRV_FLIP_VIDEOPORT:
			status = NVPFlipVideoPort(pHwDevExt, pnvCmdObj);
			break;
		default:
			VideoDebugPrint((0,"VPEMINI: invalid VPE command !\n"));
			return ERROR_INVALID_PARAMETER;
	}

	return status;
}

/*
==============================================================================
	
	VideoField0Notify

	Description:	callback function. Called after a video buffer gets filled

	Date:			Feb 16, 1999
	
	Author:			H. Azar

==============================================================================
*/
void VideoField0Notify(PVOID pHwDeviceExtension)
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pHwDeviceExtension;

	NVPProcessState(pHwDevExt, 0, FALSE);
}

/*
==============================================================================
	
	VideoField1Notify

	Description:	callback function. Called after a vbi buffer gets filled

	Date:			Feb 16, 1999
	
	Author:			H. Azar

==============================================================================
*/
void VideoField1Notify(PVOID pHwDeviceExtension)
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pHwDeviceExtension;

	NVPProcessState(pHwDevExt, 1, FALSE);
}


/*
==============================================================================
	
	VBIField0Notify

	Description:	callback function. Called after a vbi buffer gets filled

	Date:			Feb 16, 1999
	
	Author:			H. Azar

==============================================================================
*/
void VBIField0Notify(PVOID pHwDeviceExtension)
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pHwDeviceExtension;

	NVPProcessState(pHwDevExt, 0, TRUE);
}

/*
==============================================================================
	
	VBIField1Notify

	Description:	callback function. Called after a vbi buffer gets filled

	Date:			Feb 16, 1999
	
	Author:			H. Azar

==============================================================================
*/
void VBIField1Notify(PVOID pHwDeviceExtension)
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pHwDeviceExtension;

	NVPProcessState(pHwDevExt, 1, TRUE);
}


/*
==============================================================================
	
	NVPScheduleOverlayFlip

	Description:	program overlay object to flip surface

	Date:			Feb 25, 1999
	
	Author:			H. Azar

==============================================================================
*/
VP_STATUS NVPScheduleOverlayFlip(
	PNVP_CONTEXT pVPEContext,
	PNVP_SURFACE_INFO pSurface,
	int  nImageId,
	U032 dwSrcPitch,
	U032 dwMoveDownOffset)
{
	NVP_OVERLAY ovOverlayInfo;
	Nv03ChannelPio *pOvrChannel;
	U032 dwFlags = 0;
	U032 dwSubChn;
	U032 dwSrcDeltaY;
	U032 dwSrcOffset;

	if (!g_bFlip)
		return NO_ERROR;

	VideoDebugPrint((3,"VPEMINI: NVPScheduleOverlayFlip()\n"));


	dwFlags = VPP_PRESCALE;

	if (pVPEContext->dwVPFlags & DDVP_INTERLEAVE)
	   dwFlags |= VPP_INTERLEAVED;
	else 
	   dwFlags |= VPP_BOB;

	if (pVPEContext->nvpOverlay.dwOverlayMode & NV_VFM_FORMAT_BOBFROMINTERLEAVE)
	   dwFlags |= VPP_BOB;

    if (nImageId == NVP_FIELD_ODD)
	   dwFlags |= VPP_ODD;
	else if (nImageId == NVP_FIELD_EVEN)
	   dwFlags |= VPP_EVEN;
    
    NVPPrescaleAndFlip(
	    pVPEContext, 
	    &(pVPEContext->nvpOverlay), 
	    pSurface->dwOffset, 
	    pSurface->dwPitch, // source pitch
        nImageId,
        dwFlags);          // VPP flags

	return NO_ERROR;
}


/*
==============================================================================
	
	DoProgressive

	Description:	displays progressive video

	Date:			Mar 08, 1999
	
	Author:			H. Azar

==============================================================================
*/
VP_STATUS DoProgressive(
	PNVP_CONTEXT pVPEContext,
	int nFieldId)
{
	PNVP_SURFACE_INFO pSurface;
	int nTargetSurfId = pVPEContext->nVidSurfIdx;
	U032 dwSrcPitch;
	int nImage = nFieldId;

	pSurface = &(pVPEContext->aVideoSurfaceInfo[pVPEContext->nVidSurfIdx]);
		// if autoflip, CS = next(CS)    (otherwise stay within the same surface until VideoPortFlip is called !!!)
	if (pVPEContext->dwVPFlags & DDVP_AUTOFLIP)
		nTargetSurfId = pSurface->nNextSurfaceIdx;

	dwSrcPitch = pSurface->dwPitch;

	// Overlay Image n from CS
	NVPScheduleOverlayFlip(pVPEContext,	pSurface, nImage, dwSrcPitch, 0);

	pVPEContext->nVidSurfIdx = nTargetSurfId;

	// Grab Image n in TS
	pSurface = &(pVPEContext->aVideoSurfaceInfo[nTargetSurfId]);
	NVPProgVideoField(pVPEContext, pSurface, nImage, dwSrcPitch, 0, TRUE);

	return NO_ERROR;
}

/*
==============================================================================
	
	DoWeave

	Description:	use weave method to display video

	Date:			Mar 08, 1999
	
	Author:			H. Azar

==============================================================================
*/
VP_STATUS DoWeave(
	PNVP_CONTEXT pVPEContext,
	int nFieldId)
{
	PNVP_SURFACE_INFO pSurface;
	int nTargetSurfId = pVPEContext->nVidSurfIdx;
	U032 dwSrcPitch, dwOffset = 0;
	int nImage = nFieldId;

	pSurface = &(pVPEContext->aVideoSurfaceInfo[pVPEContext->nVidSurfIdx]);
	// if autoflip, TS = next(CS)    (otherwise stay within the same surface until VideoPortFlip is called !!!)
	if (pVPEContext->dwVPFlags & DDVP_AUTOFLIP)
		nTargetSurfId = pSurface->nNextSurfaceIdx;
	// double pitch (interleaved data)
	dwSrcPitch = 2*(pSurface->dwPitch);

	if (nFieldId == NVP_FIELD_ODD)
	{
		// Invert Polarity ?!
		if (pVPEContext->dwVPConFlags & DDVPCONNECT_INVERTPOLARITY)
		{
			// change vp grab offset one line down
			dwOffset = pSurface->dwPitch;
			// Shift Down Image destination by 1 line !
			/////// the following code uses an "undocumented feature" in the RM to achieve the 1 line shift down effect !
			//dwSrcPitch = (dwSrcPitch & 0xFFFFFFFC) | 0x2;
		}
	}
	else
	{
		// not Invert Polarity ?!
		if (!(pVPEContext->dwVPConFlags & DDVPCONNECT_INVERTPOLARITY))
		{
			// offset vp grab one line down
			dwOffset = pSurface->dwPitch;

			// Shift Down Image destination by 1 line !
			/////// the following code uses an "undocumented feature" in the RM to achieve the 1 line shift down effect !
			//dwSrcPitch = (dwSrcPitch & 0xFFFFFFFC) | 0x2;
		}
	}

	// whole frame captured ?!
	if (pSurface->bIsFirstFieldCaptured)
	{
		// Overlay Image n from CS
		NVPScheduleOverlayFlip(pVPEContext,	pSurface, NVP_UNDEF, pSurface->dwPitch, 0);
		// NVPScheduleOverlayFlip(pVPEContext, pSurface, nImage ^ 1, dwSrcPitch, dwOffset);

		pSurface->bIsFirstFieldCaptured = FALSE;	// reset flag (for the next time)

		// if autoflip, CS = next(CS)    (otherwise stay within the same surface until VideoPortFlip is called !!!)
		if (pVPEContext->dwVPFlags & DDVP_AUTOFLIP)
			pVPEContext->nVidSurfIdx = pSurface->nNextSurfaceIdx;
	}
	else
		pSurface->bIsFirstFieldCaptured = TRUE;	// set flag (for the next time)

	// Grab Image n in TS
	pSurface = &(pVPEContext->aVideoSurfaceInfo[nTargetSurfId]);
	NVPProgVideoField(pVPEContext, pSurface, nImage, dwSrcPitch, dwOffset, TRUE);

	return NO_ERROR;
}

/*
==============================================================================
	
	DoBobFromInterleaved

	Description:	use bob from interleaved input to display video

	Date:			Mar 08, 1999
	
	Author:			H. Azar

==============================================================================
*/
VP_STATUS DoBobFromInterleaved(
	PNVP_CONTEXT pVPEContext,
	int nFieldId)
{
	PNVP_SURFACE_INFO pSurface;
	int nTargetSurfId = pVPEContext->nVidSurfIdx;
	U032 dwSrcPitch, dwOffset = 0;
	int nImage = nFieldId;

	// Current Surface (CS)
	pSurface = &(pVPEContext->aVideoSurfaceInfo[pVPEContext->nVidSurfIdx]);
	// NewPitch = OldPitch
	dwSrcPitch = pSurface->dwPitch;	// interleaved
	// if autoflip, TS = next(CS)    (otherwise stay within the same surface until VideoPortFlip is called !!!)
	if (pVPEContext->dwVPFlags & DDVP_AUTOFLIP)
		nTargetSurfId = pSurface->nNextSurfaceIdx;

#if 0
	if (pVPEContext->dwVPFlags & DDVP_SKIPEVENFIELDS)
	{
		if (nFieldId == NVP_FIELD_EVEN)
		{
			// VP minimum programming to issue an interrupt at end of field !
			NVPProgVideoField(pVPEContext, pSurface, nImage, dwSrcPitch, 0, FALSE);
			return NO_ERROR;
		}
	}
	else if (pVPEContext->dwVPFlags & DDVP_SKIPODDFIELDS)
	{
		if (nFieldId == NVP_FIELD_ODD)
		{
			// VP minimum programming to issue an interrupt at end of field !
			NVPProgVideoField(pVPEContext, pSurface, nImage, dwSrcPitch, 0, FALSE);
			return NO_ERROR;
		}
	}
	else
#endif
	{
		// double pitch (interleaved data)
		dwSrcPitch = 2*dwSrcPitch;
		if (nFieldId == NVP_FIELD_ODD)
		{
			// Invert Polarity ?!
			if (pVPEContext->dwVPConFlags & DDVPCONNECT_INVERTPOLARITY)
			{
				// change vp grab offset one line down
				dwOffset = pSurface->dwPitch;
			}
		}
		else
		{
			// Invert Polarity ?!
			// for the even field (bottom) shift down overlay destination if invert polarity flag is not set !
			if (!(pVPEContext->dwVPConFlags & DDVPCONNECT_INVERTPOLARITY))
			{
				dwOffset = pSurface->dwPitch;

			}
		}

	}

	if (!((pVPEContext->dwVPFlags & DDVP_SKIPEVENFIELDS) && (nFieldId == NVP_FIELD_EVEN)) &&
		!((pVPEContext->dwVPFlags & DDVP_SKIPODDFIELDS) && (nFieldId == NVP_FIELD_ODD)))
	{
		// Overlay Image n from CS
		NVPScheduleOverlayFlip(pVPEContext,	pSurface, nImage, dwSrcPitch, dwOffset);
		// NVPScheduleOverlayFlip(pVPEContext, pSurface, nImage ^ 1, dwSrcPitch, dwOffset);
	}

	// whole frame captured ?!
	if (pSurface->bIsFirstFieldCaptured)
	{
		pSurface->bIsFirstFieldCaptured = FALSE;	// reset (for the next time)
		// if autoflip, CS = next(CS)    (otherwise stay within the same surface until VideoPortFlip is called !!!)
		if (pVPEContext->dwVPFlags & DDVP_AUTOFLIP)
			pVPEContext->nVidSurfIdx = pSurface->nNextSurfaceIdx;
	}
	else
		pSurface->bIsFirstFieldCaptured = TRUE;	// for the next time

	// Grab Image n in TS
	pSurface = &(pVPEContext->aVideoSurfaceInfo[nTargetSurfId]);
	NVPProgVideoField(pVPEContext, pSurface, nImage, dwSrcPitch, dwOffset, TRUE);

	return NO_ERROR;
}

/*
==============================================================================
	
	DoBob

	Description:	use bob from non-interleaved input to display video

	Date:			Mar 08, 1999
	
	Author:			H. Azar

==============================================================================
*/
VP_STATUS DoBob(
	PNVP_CONTEXT pVPEContext,
	int nFieldId)
{
	PNVP_SURFACE_INFO pSurface;
	int nTargetSurfId = pVPEContext->nVidSurfIdx;
	U032 dwSrcPitch;
	int nImage = nFieldId;

	pSurface = &(pVPEContext->aVideoSurfaceInfo[pVPEContext->nVidSurfIdx]);
	dwSrcPitch = pSurface->dwPitch;
#if 0
	if (pVPEContext->dwVPFlags & DDVP_SKIPEVENFIELDS)
	{
		if (nFieldId == NVP_FIELD_EVEN)
		{
			// VP minimum programming to issue an interrupt at end of field !
			// TS = next2(CS)
			nTargetSurfId = pVPEContext->aVideoSurfaceInfo[pSurface->nNextSurfaceIdx].nNextSurfaceIdx;
			pSurface = &(pVPEContext->aVideoSurfaceInfo[nTargetSurfaceId]);
			NVPProgVideoField(pVPEContext, pSurface, nImage, dwSrcPitch, 0, TRUE);
			return NO_ERROR;
		}
		else
			// TS = next(CS)
			nTargetSurfId = pSurface->nNextSurfaceIdx;
	}
	else if (pVPEContext->dwVPFlags & DDVP_SKIPODDFIELDS)
	{
		if (nFieldId == NVP_FIELD_ODD)
		{
			// VP minimum programming to issue an interrupt at end of field !
			nTargetSurfId = pVPEContext->aVideoSurfaceInfo[pSurface->nNextSurfaceIdx].nNextSurfaceIdx;
			pSurface = &(pVPEContext->aVideoSurfaceInfo[nTargetSurfaceId]);
			NVPProgVideoField(pVPEContext, pSurface, nImage, dwSrcPitch, 0, TRUE);
			return NO_ERROR;
		}
		else
			// TS = next(CS)
			nTargetSurfId = pSurface->nNextSurfaceIdx;
	}
	else
#endif
	{
		// if autoflip, TS = next2(CS)    (otherwise stay within the same surface until VideoPortFlip is called !!!)
		if (pVPEContext->dwVPFlags & DDVP_AUTOFLIP)
			nTargetSurfId = pVPEContext->aVideoSurfaceInfo[pSurface->nNextSurfaceIdx].nNextSurfaceIdx;
	}

	if (!((pVPEContext->dwVPFlags & DDVP_SKIPEVENFIELDS) && (nFieldId == NVP_FIELD_EVEN)) &&
		!((pVPEContext->dwVPFlags & DDVP_SKIPODDFIELDS) && (nFieldId == NVP_FIELD_ODD)))
	{
		// Overlay Image n from CS
		NVPScheduleOverlayFlip(pVPEContext,	pSurface, nImage, dwSrcPitch, 0);
	}

	// if autoflip, CS = next(CS)    (otherwise stay within the same surface until VideoPortFlip is called !!!)
	if (pVPEContext->dwVPFlags & DDVP_AUTOFLIP)
		pVPEContext->nVidSurfIdx = pSurface->nNextSurfaceIdx;

	// Grab Image n in TS
	pSurface = &(pVPEContext->aVideoSurfaceInfo[nTargetSurfId]);
	NVPProgVideoField(pVPEContext, pSurface, nImage, dwSrcPitch, 0, TRUE);

	return NO_ERROR;
}

/*
==============================================================================
	
	NVPTransfer

	Description:	transfers content of video or vbi field to specified
					buffer (usually system memory buffer)

	Date:			Mar 16, 1999
	
	Author:			H. Azar

==============================================================================
*/
DWORD NVPTransfer(
	PVOID pContext, 
	PDDTRANSFERININFO pInInfo, 
	PDDTRANSFEROUTINFO pOutInfo)
{
	PNVP_CONTEXT pVPEContext;
	PNVP_TRANSFER_BUFFER pTransfer;
	PNVP_SURFACE_INFO pSurface = NULL;
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pContext;
	BOOL bVal;
	int i;

	VideoDebugPrint((3,"VPEMINI: NVPTransfer()\n"));

	// get a pointer to the appropriate VPE context (BUGBUG: use index 0 for now !!!)
	pVPEContext = &(pHwDevExt->avpContexts[0]);

	if (pInInfo->dwTransferFlags & DDTRANSFER_NONLOCALVIDMEM)
		return DXERR_UNSUPPORTED;
	
	// we DO handle cancels for transfer buffers not "in progress" !
	if (pInInfo->dwTransferFlags & DDTRANSFER_CANCEL)
		return NVPCancelTransfer(pVPEContext, pInInfo);

	// determine polarity, TRUE for Even, FALSE for Odd !
	NVPGetSurface(pVPEContext, ((DDSURFACEDATA*) pInInfo->lpSurfaceData)->dwSurfaceOffset, &pSurface);
	if ((pSurface != NULL) && (pSurface->dwFieldType == NVP_FIELD_ODD))
		pOutInfo->dwBufferPolarity = FALSE;
	else
		pOutInfo->dwBufferPolarity = TRUE;
	
	// queue request
	if (NVPAddTransfer(pVPEContext, pInInfo, !(pOutInfo->dwBufferPolarity)))
		return DXERR_GENERIC;

	if (pVPEContext->nCurTransferIdx != -1)
	{
		pTransfer = &(pVPEContext->aTransferBuffers[pVPEContext->nCurTransferIdx]);
		// Recreate context dma for MDL
		NVPRecreateContext(pVPEContext, (PMDL)(pTransfer->pDestMDL));
	}

	return DX_OK;
}

/*
==============================================================================
	
	NVPGetSurface

	Description:	looks for surface that has the specified offset. pSurface
					is set to NULL if no surface is found.


	Date:			Mar 18, 1999
	
	Author:			H. Azar

==============================================================================
*/
BOOL NVPGetSurface(
	PNVP_CONTEXT pVPEContext,
	U032 dwSurfOffset,
	PNVP_SURFACE_INFO *pSurface)
{
	int i;

	VideoDebugPrint((3,"VPEMINI: NVPGetSurface()\n"));

	*pSurface = NULL;

	// why VBI first ! well, this is most probably what we're transfering... kinda optimization !
	for (i = 0; i < pVPEContext->nNumVBISurf; i++)
	{
		if (pVPEContext->aVBISurfaceInfo[i].dwOffset == dwSurfOffset)
		{
			*pSurface = &(pVPEContext->aVBISurfaceInfo[i]);
			return FALSE;	// FALSE means VBI
		}
	}

	for (i = 0; i < pVPEContext->nNumVidSurf; i++)
	{
		if (pVPEContext->aVideoSurfaceInfo[i].dwOffset == dwSurfOffset)
		{
			*pSurface = &(pVPEContext->aVideoSurfaceInfo[i]);
			return TRUE;	// TRUE means VIDEO
		}
	}

	return FALSE;	// return something ! (pSurface is NULL anyway)
}

/*
==============================================================================
	
	NVP3RecreateContext

	Description:	if necessary, create context DMA for mem to mem object
					PIO channel version.

	Date:			Mar 18, 1999
	
	Author:			H. Azar

==============================================================================
*/
DWORD NVP3RecreateContext(
	PNVP_CONTEXT pVPEContext,
	PMDL pDestMDL) 
{
	Nv03ChannelPio *pChan;
	NVOS09_PARAMETERS ntfParam;
	U032 dwStart;
	U032 dwLimit;
	int nFreeCount;

	pChan = (Nv03ChannelPio *)(pVPEContext->pNVPChannel);

	// first check to see if we can reuse the OLD context... since context creation is expensive.
	dwStart = (U032)(pDestMDL->lpMappedSystemVa);
	dwLimit = (pDestMDL->ByteCount) - 1;
	
	if (pVPEContext->bxfContextCreated)
	{
		// do not recreate if same context
		if ((dwStart == pVPEContext->dwTransferCtxStart) && (dwLimit == pVPEContext->dwTransferCtxSize))
			return DX_OK;
	}

#ifdef _NV_DPC
	// FIFO free count check up
	ntfParam.hObjectParent = pVPEContext->dwDeviceId;
	nFreeCount = pVPEContext->nFreeCount;
	while (nFreeCount < 4*4) 
	{
		//RmInterrupt(&ntfParam);
		nFreeCount = NvGetFreeCount(pChan, 5);
	}
	pVPEContext->nFreeCount = nFreeCount - (4*4);
#endif

	// free the old context first
	if (pVPEContext->bxfContextCreated)
	{
		pChan->subchannel[5].SetObject = NVP_M2M_OBJECT;
		pChan->subchannel[5].nv03MemoryToMemoryFormat.SetContextDmaBufferOut = 0;
#ifdef _NV_DPC
		// Do a software method flush here
		ntfParam.hObjectParent = pVPEContext->dwDeviceId;
		nFreeCount = pVPEContext->nFreeCount;
		while (nFreeCount < NV06A_FIFO_GUARANTEED_SIZE) 
		{
			//RmInterrupt(&ntfParam);
			nFreeCount = NvGetFreeCount(pChan, 5);
		}
		pVPEContext->nFreeCount = nFreeCount - NV06A_FIFO_GUARANTEED_SIZE;
#endif
		RmFree(pVPEContext->hClient, pVPEContext->dwDeviceId, NVP_M2M_CONTEXT);

		pVPEContext->bxfContextCreated = FALSE;
	}
	
	// setup Notify Context
	if (RmAllocContextDma(
					pVPEContext->hClient,
	         		NVP_M2M_CONTEXT,
	         		NV01_CONTEXT_DMA_FROM_MEMORY,
	         		0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
					0, // selector
	         		dwStart,
	         		dwLimit) != 0) //ALLOC_CTX_DMA_STATUS_SUCCESS)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate mem 2 mem context\n"));
		return DXERR_GENERIC;
	}

	// set context of M2M object
	pChan->subchannel[5].SetObject  = NVP_M2M_OBJECT;
	pChan->subchannel[5].nv03MemoryToMemoryFormat.SetContextDmaBufferOut = NVP_M2M_CONTEXT;

	pVPEContext->dwTransferCtxStart = dwStart;
	pVPEContext->dwTransferCtxSize = dwLimit;
	pVPEContext->bxfContextCreated = TRUE;

	return DX_OK;
}

/*
==============================================================================
	
	NVP3CheckForLaunch

	Description:	try to launch another mem transfer if engine not busy
					(PIO version)

	Date:			Mar 18, 1999
	
	Author:			H. Azar

==============================================================================
*/
DWORD NVP3CheckForLaunch(
	PNVP_CONTEXT pVPEContext,
	PNVP_SURFACE_INFO pSurface)
{
	Nv03ChannelPio *pChan;
	PNVP_TRANSFER_BUFFER pTransfer;
	LPDDSURFACEDATA pSurfaceData;
	NVOS09_PARAMETERS ntfParam;
	NvNotification *aM2MNotifiers;
	PMDL pDestMDL;
	U032 dwOffsetStartByte;
	LONG lLength, lPitch, lCount;
	int nFreeCount;
	PNVP_SURFACE_INFO pSurf = NULL;

	VideoDebugPrint((3,"VPEMINI: NVP3CheckForLaunch()\n"));

	aM2MNotifiers = (NvNotification *)(pVPEContext->axfNotifiers);

	// is transfer in progress ?
	if ((aM2MNotifiers[NV039_NOTIFIERS_BUFFER_NOTIFY].status == NV039_NOTIFICATION_STATUS_IN_PROGRESS) ||
		// or no transfer request !?
		(pVPEContext->nCurTransferIdx == -1))
		return DXERR_GENERIC;

	// get a pointer to the VP pio channel
	pChan = (Nv03ChannelPio *)(pVPEContext->pNVPChannel);
	// which surface are we transferring from ?
	pTransfer = &(pVPEContext->aTransferBuffers[pVPEContext->nCurTransferIdx]);
	pSurfaceData = (LPDDSURFACEDATA) (pTransfer->pSurfaceData);
	if (pSurface == NULL)
	{
		NVPGetSurface(pVPEContext, pSurfaceData->dwSurfaceOffset, &pSurf);
		if (pSurf == NULL)
		{
			VideoDebugPrint((0,"VPEMINI: NVPCheckForLaunch() can't get pointer to surface\n"));
			return DXERR_GENERIC;
		}
	}
	else
		pSurf = pSurface;

	// Recreate context dma for MDL
	NVPRecreateContext(pVPEContext, (PMDL)(pTransfer->pDestMDL));
	
	// reset notifier status
	aM2MNotifiers[NV039_NOTIFIERS_BUFFER_NOTIFY].status = NV039_NOTIFICATION_STATUS_IN_PROGRESS;

#ifdef _NV_DPC
	//CHECKFREECOUNT(pMyNvChan,9*4);
	ntfParam.hObjectParent = pVPEContext->dwDeviceId;
	nFreeCount = pVPEContext->nFreeCount;
	while (nFreeCount < 9*4) 
	{
		//RmInterrupt(&ntfParam);
		nFreeCount = NvGetFreeCount(pChan, 5);
	}
	pVPEContext->nFreeCount = nFreeCount - (9*4);
#endif

	// start at given line
	dwOffsetStartByte = pSurfaceData->dwSurfaceOffset + (pSurfaceData->lPitch * pTransfer->lStartLine);

	// lLength and lPitch might not be the same (case of interleaved fields !!!)
	lLength = (pSurfaceData->dwWidth)*(pSurfaceData->dwFormatBitCount >> 3);
	lPitch = pSurfaceData->lPitch;
			
	// SMAC@microsoft.com  :  Yes, you should transfer the end line.  
	// Therefore, if we only wanted you to transfer a single line, start line would equal end line.	
	lCount = (pTransfer->lEndLine - pTransfer->lStartLine + 1);
	if (pTransfer->dwTransferFlags & DDTRANSFER_INVERT)
	{
		// if we want to invert things, then we should 
		// negate the pitch and put the start offset at the end.
		
		dwOffsetStartByte = dwOffsetStartByte + lPitch * (lCount - 1);
		lPitch = -lPitch;
	}

	pDestMDL = (PMDL)(pTransfer->pDestMDL);
	if (pDestMDL->ByteCount < (ULONG)(lLength * lCount))
	{ 
		VideoDebugPrint((0,"VPEMINI: NVPCheckForLaunch() - Destination memory is not large enough to hold this image, truncating line count\n"));
	//	lCount = (pTransfer->pDestMDL->ByteCount + pTransfer->pDestMDL->ByteOffset) / lLength;
		lCount = pDestMDL->ByteCount / lLength;
	}

#ifdef _NV_DPC
	ntfParam.hObjectParent = pVPEContext->dwDeviceId;
	nFreeCount = pVPEContext->nFreeCount;
	while (nFreeCount < 8*4) 
	{
		//RmInterrupt(&ntfParam);
		nFreeCount = NvGetFreeCount(pChan, 5);
	}
	pVPEContext->nFreeCount = nFreeCount - (8*4);
#endif

	// set mem to mem transfer object !
	pChan->subchannel[NVP_M2M_SUBCHANNEL].SetObject = NVP_M2M_OBJECT;
	pChan->subchannel[NVP_M2M_SUBCHANNEL].nv03MemoryToMemoryFormat.OffsetIn	= dwOffsetStartByte;
	//pChan->subchannel[NVP_M2M_SUBCHANNEL].nv03MemoryToMemoryFormat.OffsetOut = (unsigned long)pTheTransfer->DestMDL->ByteOffset;
	pChan->subchannel[NVP_M2M_SUBCHANNEL].nv03MemoryToMemoryFormat.OffsetOut = 0;
	pChan->subchannel[NVP_M2M_SUBCHANNEL].nv03MemoryToMemoryFormat.PitchIn	= lPitch;	// use the pitch in so that we can do interleaved
	pChan->subchannel[NVP_M2M_SUBCHANNEL].nv03MemoryToMemoryFormat.PitchOut	= lLength;  // use line length on pitch out so that it squishes together
	pChan->subchannel[NVP_M2M_SUBCHANNEL].nv03MemoryToMemoryFormat.LineLengthIn = lLength; 
	
	pChan->subchannel[NVP_M2M_SUBCHANNEL].nv03MemoryToMemoryFormat.LineCount 	= lCount;
	pChan->subchannel[NVP_M2M_SUBCHANNEL].nv03MemoryToMemoryFormat.Format 		=  ( 1 | (1 << 8));
	pChan->subchannel[NVP_M2M_SUBCHANNEL].nv03MemoryToMemoryFormat.BufferNotify = NV039_NOTIFY_WRITE_THEN_AWAKEN_1;

	pTransfer->dwTransferStatus = NVP_TRANSFER_IN_PROGRESS;

	return DX_OK;
}

/*
==============================================================================
	
	NVPRecreateContext

	Description:	if necessary, create context DMA for mem to mem object
					(DMA version)

	Date:			Apr 22, 1999
	
	Author:			H. Azar

==============================================================================
*/
DWORD NVPRecreateContext(
	PNVP_CONTEXT pVPEContext,
	PMDL pDestMDL) 
{
	U032 dwStart;
	U032 dwLimit;

	// NV3 specific code
	if (NVP_GET_CHIP_VER(pVPEContext->dwChipId) <= NVP_CHIP_VER_03)
		return NVP3RecreateContext(pVPEContext, pDestMDL);

	// first check to see if we can reuse the OLD context... since context creation is expensive.
	dwStart = (U032)(pDestMDL->lpMappedSystemVa);
	dwLimit = (pDestMDL->ByteCount) - 1;
	
	if (pVPEContext->bxfContextCreated)
	{
		// do not recreate if same context
		if ((dwStart == pVPEContext->dwTransferCtxStart) && (dwLimit == pVPEContext->dwTransferCtxSize))
			return DX_OK;
	}

	// free the old context first
	if (pVPEContext->bxfContextCreated)
	{
		// free m2m dma context
		RmFree(pVPEContext->hClient, pVPEContext->dwDeviceId, NVP_M2M_CONTEXT);

		pVPEContext->bxfContextCreated = FALSE;
	}
	
	// setup Notify Context
	if (RmAllocContextDma(
					pVPEContext->hClient,
	         		NVP_M2M_CONTEXT,
	         		NV01_CONTEXT_DMA_FROM_MEMORY,
	         		0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
					0, // selector
	         		dwStart,
	         		dwLimit) != 0) //ALLOC_CTX_DMA_STATUS_SUCCESS)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate mem 2 mem context\n"));
		return DXERR_GENERIC;
	}

	pVPEContext->dwTransferCtxStart = dwStart;
	pVPEContext->dwTransferCtxSize = dwLimit;
	pVPEContext->bxfContextFlushed = FALSE;
	pVPEContext->bxfContextCreated = TRUE;

	return DX_OK;
}

/*
==============================================================================
	
	NVPCheckForLaunch

	Description:	try to launch another mem transfer if engine not busy
					(DMA version)

	Date:			Apr 22, 1999
	
	Author:			H. Azar

==============================================================================
*/
DWORD NVPCheckForLaunch(
	PNVP_CONTEXT pVPEContext,
	PNVP_SURFACE_INFO pSurface)
{
	PNVP_TRANSFER_BUFFER pTransfer;
	LPDDSURFACEDATA pSurfaceData;
	NvNotification *aM2MNotifiers;
	PMDL pDestMDL;
	U032 dwOffsetStartByte;
	LONG lLength, lPitch, lCount;
	PNVP_SURFACE_INFO pSurf = NULL;
	Nv4ControlDma *pDmaChannel;
	U032 nvDmaCount;

	// NV3 specific code
	if (NVP_GET_CHIP_VER(pVPEContext->dwChipId) <= NVP_CHIP_VER_03)
		return NVP3CheckForLaunch(pVPEContext, pSurface);

//	VideoDebugPrint((3,"VPEMINI: NVPCheckForLaunch()\n"));

	aM2MNotifiers = (NvNotification *)(pVPEContext->axfNotifiers);

	// is transfer in progress ?
	if (aM2MNotifiers[NV039_NOTIFIERS_BUFFER_NOTIFY].status == NV039_NOTIFICATION_STATUS_IN_PROGRESS)
		return DXERR_GENERIC;

	// or no transfer request !?
	if ((pVPEContext->nCurTransferIdx == -1) || !(pVPEContext->bxfContextCreated))
	{
		return DXERR_GENERIC;
	}

	// which surface are we transferring from ?
	pTransfer = &(pVPEContext->aTransferBuffers[pVPEContext->nCurTransferIdx]);
	pSurfaceData = (LPDDSURFACEDATA) (pTransfer->pSurfaceData);
	if (pSurface == NULL)
	{
		NVPGetSurface(pVPEContext, pSurfaceData->dwSurfaceOffset, &pSurf);
		if (pSurf == NULL)
		{
			VideoDebugPrint((0,"VPEMINI: NVPCheckForLaunch() can't get pointer to surface\n"));
			return DXERR_GENERIC;
		}
	}
	else
		pSurf = pSurface;

	// reset notifier status
	aM2MNotifiers[NV039_NOTIFIERS_BUFFER_NOTIFY].status = NV039_NOTIFICATION_STATUS_IN_PROGRESS;

	// start at given line
	dwOffsetStartByte = pSurfaceData->dwSurfaceOffset + (pSurfaceData->lPitch * pTransfer->lStartLine);

	// lLength and lPitch might not be the same (case of interleaved fields !!!)
	lLength = (pSurfaceData->dwWidth)*(pSurfaceData->dwFormatBitCount >> 3);
	lPitch = pSurfaceData->lPitch;
			
	// SMAC@microsoft.com  :  Yes, you should transfer the end line.  
	// Therefore, if we only wanted you to transfer a single line, start line would equal end line.	
	lCount = (pTransfer->lEndLine - pTransfer->lStartLine + 1);
	if (pTransfer->dwTransferFlags & DDTRANSFER_INVERT)
	{
		// if we want to invert things, then we should 
		// negate the pitch and put the start offset at the end.
		
		dwOffsetStartByte = dwOffsetStartByte + lPitch * (lCount - 1);
		lPitch = -lPitch;
	}

	pDestMDL = (PMDL)(pTransfer->pDestMDL);
	if (pDestMDL->ByteCount < (ULONG)(lLength * lCount))
	{ 
		VideoDebugPrint((0,"VPEMINI: NVPCheckForLaunch() - Destination memory is not large enough to hold this image, truncating line count\n"));
	//	lCount = (pTransfer->pDestMDL->ByteCount + pTransfer->pDestMDL->ByteOffset) / lLength;
		lCount = pDestMDL->ByteCount / lLength;
	}

	// get a pointer to the VPE dma channel
	pDmaChannel = (Nv4ControlDma *)(pVPEContext->pDmaChannel);
    nvDmaCount = pVPEContext->nvDmaCount;
	NVP_DMAPUSH_CHECK_FREE_COUNT(20);

	NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_SET_OBJECT, NVP_M2M_OBJECT);
	NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_SET_CONTEXT_DMA_BUFFER_OUT, NVP_M2M_CONTEXT);
    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_OFFSET_IN, dwOffsetStartByte);
    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_OFFSET_OUT, 0);	//(unsigned long)pTransfer->DestMDL->ByteOffset
    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_PITCH_IN, lPitch);
    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_PITCH_OUT, lLength);

    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_LINE_LENGTH_IN, lLength);
    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_LINE_COUNT, lCount);
    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_FORMAT, ( 1 | (1 << 8)));
    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_BUFFER_NOTIFY, NV039_NOTIFY_WRITE_THEN_AWAKEN_1);

	pTransfer->dwTransferStatus = NVP_TRANSFER_IN_PROGRESS;
	// go !
    pDmaChannel->Put = nvDmaCount << 2;
	pVPEContext->nvDmaCount = nvDmaCount;

	return DX_OK;
}


/*
==============================================================================
	
	NVPGetTransferStatus

	Description:	returns status of buffer transfer (from video mem to 
					system mem)

	Date:			Mar 16, 1999
	
	Author:			H. Azar

==============================================================================
*/
DWORD NVPGetTransferStatus(
	PVOID pContext, 
	PVOID pNotUsed, 
	PDDGETTRANSFEROUTINFO pOutInfo)
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pContext;
	PNVP_TRANSFER_BUFFER pTransfer;
	PNVP_CONTEXT pVPEContext;

//	VideoDebugPrint((3,"VPEMINI: NVPGetTransferStatus()\n"));

	// get a pointer to the appropriate VPE context (BUGBUG: use index 0 for now !!!)
	pVPEContext = &(pHwDevExt->avpContexts[0]);

	if (pVPEContext->nRecentTransferIdx == NVP_EOQ)
		return DXERR_GENERIC;

	pTransfer = &(pVPEContext->aTransferBuffers[pVPEContext->nRecentTransferIdx]);

	if (pTransfer->dwTransferStatus == NVP_TRANSFER_DONE)
	{
		// return MS transfer ID
		pOutInfo->dwTransferID = pTransfer->dwTransferId;
		NVPRemoveTransfer(pVPEContext, pVPEContext->nRecentTransferIdx);

	}
	else 
		return DXERR_GENERIC;

	return DX_OK;
}

/*
==============================================================================
	
	NVPAddTransfer

	Description:	adds transfer buffer to queue

	Date:			Mar 16, 1999
	
	Author:			H. Azar

==============================================================================
*/
DWORD NVPAddTransfer(
	PNVP_CONTEXT pVPEContext,
	PDDTRANSFERININFO pInInfo,
	BOOL bIsOddField)
{
	PNVP_TRANSFER_BUFFER pNewTransfer;
	int i = pVPEContext->nCurTransferIdx;

	VideoDebugPrint((3,"VPEMINI: NVPAddTransfer()\n"));

	if (pVPEContext->nNumTransfer >= NVP_MAX_TRANSFER_BUFFERS)
		return DXERR_GENERIC;
	
	while (i != NVP_EOQ)
	{
		if (pVPEContext->aTransferBuffers[i].dwTransferId == pInInfo->dwTransferID)
			// a transfer request with same ID is already queued !!!
			return DXERR_GENERIC;
		else 
			i = pVPEContext->aTransferBuffers[i].nNextTransferIdx;
	}

		
	// queue new transfer request !
	i = pVPEContext->nLastTransferIdx;
	pVPEContext->nLastTransferIdx = ++(pVPEContext->nLastTransferIdx) % NVP_MAX_TRANSFER_BUFFERS;
	pNewTransfer = &(pVPEContext->aTransferBuffers[pVPEContext->nLastTransferIdx]);
	if (i != NVP_EOQ)
		pVPEContext->aTransferBuffers[i].nNextTransferIdx = pVPEContext->nLastTransferIdx;
	pNewTransfer->nNextTransferIdx = NVP_EOQ;
	pNewTransfer->nPrevTransferIdx = i;
	(pVPEContext->nNumTransfer)++;
	if (pVPEContext->nCurTransferIdx == NVP_EOQ)
		pVPEContext->nCurTransferIdx = pVPEContext->nLastTransferIdx;

    // DDTRANSFER_HALFLINES indicates that, due to half line issues, the odd field contains an 
    // extra line of useless data at the top that the driver must account for
	if ((pInInfo->dwTransferFlags & DDTRANSFER_HALFLINES) && (bIsOddField))
	{
		pNewTransfer->lStartLine = (LONG)(pInInfo->dwStartLine) + 1;
		pNewTransfer->lEndLine = (LONG)(pInInfo->dwEndLine) + 1;
	} 
	else 
	{
		pNewTransfer->lStartLine = (LONG)(pInInfo->dwStartLine);
		pNewTransfer->lEndLine = (LONG)(pInInfo->dwEndLine);
	}

	// copy input data...
	pNewTransfer->pSurfaceData = (ULONG) (pInInfo->lpSurfaceData);
	pNewTransfer->dwTransferId = pInInfo->dwTransferID;
	pNewTransfer->dwTransferFlags = pInInfo->dwTransferFlags;
	pNewTransfer->pDestMDL = (ULONG) (pInInfo->lpDestMDL);
	pNewTransfer->dwTransferStatus = NVP_TRANSFER_QUEUED;

	return DX_OK;
}


/*
==============================================================================
	
	NVPCancelTransfer

	Description:	cancels transfer request before it gets processed 

	Date:			Mar 16, 1999
	
	Author:			H. Azar

==============================================================================
*/
DWORD NVPCancelTransfer(
	PNVP_CONTEXT pVPEContext,
	PDDTRANSFERININFO pInInfo)
{
	PNVP_TRANSFER_BUFFER pTransfer = NULL;
	int i = pVPEContext->nCurTransferIdx;

	VideoDebugPrint((3,"VPEMINI: NVPCancelTransfer()\n"));

	// look for transfer in queue
	while (i != NVP_EOQ)
	{
		if (pVPEContext->aTransferBuffers[i].dwTransferId == pInInfo->dwTransferID)
		{
			pTransfer = &(pVPEContext->aTransferBuffers[i]);
			break;
		}
		i = pVPEContext->aTransferBuffers[i].nNextTransferIdx;
	}

	if ((pTransfer) && (pTransfer->dwTransferStatus == NVP_TRANSFER_QUEUED))
		return NVPRemoveTransfer(pVPEContext, i);
	else
		return DXERR_GENERIC;
}

/*
==============================================================================
	
	NVPRemoveTransfer

	Description:	removes transfer request from queue

	Date:			Mar 16, 1999
	
	Author:			H. Azar

==============================================================================
*/
DWORD NVPRemoveTransfer(
	PNVP_CONTEXT pVPEContext,
	int nTransferIdx)
{
	PNVP_TRANSFER_BUFFER pTransfer = &(pVPEContext->aTransferBuffers[nTransferIdx]);

	VideoDebugPrint((3,"VPEMINI: NVPRemoveTransfer()\n"));

	// check limits
	if (nTransferIdx == pVPEContext->nCurTransferIdx)
		pVPEContext->nCurTransferIdx = pTransfer->nNextTransferIdx;
	else if (nTransferIdx == pVPEContext->nLastTransferIdx)
		pVPEContext->nLastTransferIdx = pTransfer->nPrevTransferIdx;
	// reset values
	pTransfer->dwTransferId = NVP_UNDEF;
	pTransfer->dwTransferStatus = NVP_TRANSFER_FREE;
	// re-map indices
	if (pTransfer->nPrevTransferIdx != NVP_EOQ)
	{
		pVPEContext->aTransferBuffers[pTransfer->nPrevTransferIdx].nNextTransferIdx = pTransfer->nNextTransferIdx;
		pTransfer->nPrevTransferIdx = NVP_EOQ;
	}
	if (pTransfer->nNextTransferIdx != NVP_EOQ)
	{
		pVPEContext->aTransferBuffers[pTransfer->nNextTransferIdx].nPrevTransferIdx = pTransfer->nPrevTransferIdx;
		pTransfer->nNextTransferIdx = NVP_EOQ;
	}

	// one down !
	(pVPEContext->nNumTransfer)--;

	return DX_OK;
}
	

/*
==============================================================================
	
	NVPCheckTransferStatus

	Description:	checks for transfer status. Calls MS callback. 

	Date:			Mar 16, 1999
	
	Author:			H. Azar

==============================================================================
*/
DWORD NVPCheckTransferStatus(
	PHW_DEVICE_EXTENSION pHwDevExt)
{
	NvNotification *aM2MNotifiers;
	PNVP_CONTEXT pVPEContext;
	PDX_IRQDATA pIRQData;
	PNVP_TRANSFER_BUFFER pTransfer;
	U032 status;

	VideoDebugPrint((3,"VPEMINI: NVPCheckTransferStatus()\n"));

	// get a pointer to the appropriate VPE context (BUGBUG: use index 0 for now !!!)
	pVPEContext = &(pHwDevExt->avpContexts[0]);

	aM2MNotifiers = (NvNotification *)(pVPEContext->axfNotifiers);

	status = aM2MNotifiers[NV039_NOTIFIERS_BUFFER_NOTIFY].status;
	
	if (status == NV039_NOTIFICATION_STATUS_IN_PROGRESS)
		// still in progress
		return FALSE;
	else if (status == NV039_NOTIFICATION_STATUS_DONE_SUCCESS)
	{
		pTransfer = &(pVPEContext->aTransferBuffers[pVPEContext->nCurTransferIdx]);

		// finished ok!
		if (pTransfer->dwTransferStatus == NVP_TRANSFER_IN_PROGRESS)
			pTransfer->dwTransferStatus = NVP_TRANSFER_DONE;

		pVPEContext->nRecentTransferIdx = pVPEContext->nCurTransferIdx;
	} 
	else
	{
		VideoDebugPrint((0,"VPEMINI: NVPCheckTransferStatus() - memory transfer failed error %d\n", status));

		pTransfer = &(pVPEContext->aTransferBuffers[pVPEContext->nCurTransferIdx]);

		// finished with an error !
		if (pTransfer->dwTransferStatus == NVP_TRANSFER_IN_PROGRESS)
			pTransfer->dwTransferStatus = NVP_TRANSFER_FAILURE;

	}

	// move to next transfer in queue (*** not sure whether I should do this even when an error had occured ?!?!?!?)
	pVPEContext->nCurTransferIdx = pTransfer->nNextTransferIdx;

	// we pass on the interrupt
	if (pHwDevExt->IRQCallback) //&& (pHwDevExt->dwIRQSources & DDIRQ_BUSMASTER))
	{
		pIRQData = (PDX_IRQDATA)(pHwDevExt->pIRQData);
		pIRQData->dwIrqFlags |= DDIRQ_BUSMASTER;
		((PDX_IRQCALLBACK)(pHwDevExt->IRQCallback))(pIRQData);
	}
	
	return DX_OK;
}

/*
==============================================================================
	
	NVPTransferNotify

	Description:	checks for transfer status. Calls MS callback. 

	Date:			Mar 16, 1999
	
	Author:			H. Azar

==============================================================================
*/
void NVPTransferNotify(
	PVOID pHwDevExtension)
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION) pHwDevExtension;
	PNVP_CONTEXT pVPEContext;

	// call MS callback if done with transfer
	if (NVPCheckTransferStatus(pHwDevExt) == DX_OK)
	{
		// get a pointer to the appropriate VPE context (BUGBUG: use index 0 for now !!!)
		pVPEContext = &(pHwDevExt->avpContexts[0]);
		//  transfer next in queue !
//		NVPCheckForLaunch(pVPEContext, NULL);
	}
}




//---------------------------------------------------------------------------
// vddPreScale
//      Prescales YUV422 surface.  The new width and height are returned.  If
//      this routine does the field prescaling, it flips off the field flags
//      to indicate that the flip should not bob.
//

BOOL NVPPreScale(
    PNVP_CONTEXT  pVPEContext, 
	PNVP_OVERLAY  pOverlayInfo,
    DWORD         dwSrcOffset, 
    DWORD         dwSrcPitch,
    DWORD         dwDstOffset, 
    DWORD         dwDstPitch,
    DWORD         *pWidth, 
    DWORD         *pHeight,
    DWORD         *pField)
{
    DWORD preScaleDeltaX;
    DWORD preScaleDeltaY;
    DWORD preScaleOverlay;
    DWORD dwDeltaX, dwDeltaY;
    DWORD dwOutSizeX, dwOutSizeY, dwOutFormat;
    DWORD dwInPitch, dwInOffset, dwInPoint, dwInSize;
    BOOL isField;
	Nv4ControlDma *pDmaChannel;
	U032 nvDmaCount;

    if (pOverlayInfo->dwOverlayDstWidth == 0 ||
        pOverlayInfo->dwOverlayDstHeight == 0)
        return FALSE;

    isField = IS_FIELD(*pField);

    if (pOverlayInfo->dwOverlayDstWidth <= 1) 
    {
        dwDeltaX = 0x100000;
	}
	else
	{
	    dwDeltaX = (pOverlayInfo->dwOverlaySrcWidth - 1) << 16;
	    dwDeltaX /= pOverlayInfo->dwOverlayDstWidth - 1;
	    dwDeltaX <<= 4;
	}

    if (pOverlayInfo->dwOverlayDstHeight <= 1) 
    {
        dwDeltaY = 0x100000;
	}
	else
	{
	    dwDeltaY = (pOverlayInfo->dwOverlaySrcHeight - 1) << 16; //(*pHeight - 1) << 16; //
	    // err on the side of caution, need to do this because of the 1/4 pixel offset
	    // ????? why is NV4 different from NV5?  NV4 HW must be a little wonky
	    if (pVPEContext->dwChipId <= NV_DEVICE_VERSION_4) {
	        dwDeltaY /= pOverlayInfo->dwOverlayDstHeight + 2;
	    } else {
	        dwDeltaY /= pOverlayInfo->dwOverlayDstHeight + 1;
	    }
	    dwDeltaY <<= 4;
    }

    preScaleOverlay = 0;

    if (pOverlayInfo->dwOverlaySrcWidth > (pOverlayInfo->dwOverlayDstWidth * pOverlayInfo->dwOverlayMaxDownScale)) 
    {
        // use X prescaler
        preScaleOverlay |= NV_PRESCALE_OVERLAY_X;
        dwOutSizeX = (pOverlayInfo->dwOverlayDstWidth + 2) & ~1;
        preScaleDeltaX = dwDeltaX;
        pOverlayInfo->dwOverlayDeltaX = 0x100000;
    } else {
        // use X overlay scaler
        dwOutSizeX = (*pWidth + 2) & ~1;
        preScaleDeltaX = 0x100000;
        pOverlayInfo->dwOverlayDeltaX = dwDeltaX;
    }

    if (pOverlayInfo->dwOverlaySrcHeight > (pOverlayInfo->dwOverlayDstHeight * pOverlayInfo->dwOverlayMaxDownScale))
	{
        // use Y prescaler
        preScaleOverlay |= NV_PRESCALE_OVERLAY_Y;
        dwOutSizeY = pOverlayInfo->dwOverlayDstHeight;
        preScaleDeltaY = dwDeltaY;
        pOverlayInfo->dwOverlayDeltaY = 0x100000;
    } 
    else 
    {
        // use Y overlay scaler
        dwOutSizeY = *pHeight;
        preScaleDeltaY = 0x100000;
        pOverlayInfo->dwOverlayDeltaY = dwDeltaY;
    }

    if ((pVPEContext->dwChipId < NV_DEVICE_VERSION_10) || (preScaleOverlay & NV_PRESCALE_OVERLAY_Y)) 
    {
        if (isField) 
        {
            preScaleOverlay |= NV_PRESCALE_OVERLAY_FIELD;
            if (*pField & VPP_INTERLEAVED)
                preScaleDeltaY >>= 1;
        }
    }

    if (preScaleOverlay == 0)
        return FALSE;

    dwInSize = asmMergeCoords(*pWidth, *pHeight);
    dwInPoint = 0;
    dwInPitch = dwSrcPitch;
    dwInOffset = dwSrcOffset;
    if (isField && (preScaleOverlay & NV_PRESCALE_OVERLAY_FIELD)) {
        if (*pField & VPP_INTERLEAVED) {
            dwInPitch <<= 1;
            *pHeight >>= 1;
            // if (*pField & VPP_ODD) {
            if (*pField & VPP_EVEN) {
                dwInOffset += dwSrcPitch;
            }
        }
        if (*pField & VPP_BOB) {
            // use -1/4, +1/4 biasing for bob fields
            // if (*pField & VPP_ODD) {
            if (*pField & VPP_EVEN) {
                dwInPoint = 0xFFFC0000;
            } else {
                dwInPoint = 0x00040000;
            }
        }
    }

//    if (dwFourCC == FOURCC_UYVY) {
        dwOutFormat = NV038_IMAGE_OUT_FORMAT_COLOR_LE_YB8V8YA8U8;
//    } else {
//        dwOutFormat = NV038_IMAGE_OUT_FORMAT_COLOR_LE_V8YB8U8YA8;
//    }

	pDmaChannel = (Nv4ControlDma *)(pVPEContext->pDmaChannel);
    nvDmaCount = pVPEContext->nvDmaCount;
	NVP_DMAPUSH_CHECK_FREE_COUNT(38);

	// program the VP to grab in the next surface
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_SET_OBJECT , NVP_DVD_SUBPICTURE_OBJECT); // pVPEContext->dwDVDSubPicObjectID);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_IMAGE_OUT_POINT, 0);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_IMAGE_OUT_SIZE, (asmMergeCoords(dwOutSizeX, dwOutSizeY)));
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_IMAGE_OUT_FORMAT, ((dwOutFormat << 16) | dwDstPitch));
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_IMAGE_OUT_OFFSET, dwDstOffset);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_IMAGE_IN_DELTA_DU_DX, preScaleDeltaX);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_IMAGE_IN_DELTA_DV_DY, preScaleDeltaY);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_IMAGE_IN_SIZE, dwInSize);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_IMAGE_IN_FORMAT, ((dwOutFormat << 16) | dwInPitch));
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_IMAGE_IN_OFFSET, dwInOffset);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_IMAGE_IN_POINT, dwInPoint);

    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_OVERLAY_DELTA_DU_DX, preScaleDeltaX);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_OVERLAY_DELTA_DV_DY, preScaleDeltaY);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_OVERLAY_SIZE, dwInSize);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_OVERLAY_FORMAT, ((NV038_OVERLAY_FORMAT_COLOR_LE_TRANSPARENT << 16) | dwInPitch));
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_OVERLAY_OFFSET, dwInOffset);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_OVERLAY_POINT, 0);

    //NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_NOTIFY, NV038_NOTIFY_WRITE_THEN_AWAKEN);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_NO_OPERATION, 0);

    // this forces the H/W to serialize
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_SET_CONTEXT_DMA_OVERLAY, NVP_DVD_SUBPICTURE_CONTEXT);

//    NVP_DMAPUSH_START();
    pDmaChannel->Put = nvDmaCount << 2;
	pVPEContext->nvDmaCount = nvDmaCount;

    // return changes in state
    if (//(pDriverData->regOverlayMode & NV4_REG_OVL_MODE_VUPSCALE) ||
        (preScaleOverlay & NV_PRESCALE_OVERLAY_FIELD)) {
        // with HQVUp, we no longer use the overlay to bob
        *pField &= ~(VPP_ODD | VPP_EVEN | VPP_BOB | VPP_INTERLEAVED);
    }

    *pHeight = dwOutSizeY;
    *pWidth  = dwOutSizeX;

    return TRUE;
}

//---------------------------------------------------------------------------
// vddFlip
//      Flip to surface.
//

BOOL NVPFlip(
    PNVP_CONTEXT  pVPEContext, 
	PNVP_OVERLAY  pOverlayInfo,
    DWORD         dwOffset,        // source surface offset 
    DWORD         dwPitch,         // source pitch
	DWORD         dwWidth,         // source width
	DWORD         dwHeight,        // source height
    DWORD         dwIndex,         // overlay buffer index
    DWORD         dwFlags)         // VPP flags
{
    NvNotification *pPioFlipOverlayNotifier = (NvNotification *)pOverlayInfo->pNvPioFlipOverlayNotifierFlat;
    DWORD dwPointIn, dwOverlayFormat, dwSizeIn;
    DWORD dwDeltaX, dwDeltaY;
	Nv4ControlDma *pDmaChannel;
	U032 nvDmaCount;

    dwPointIn = (dwOffset & NV_OVERLAY_BYTE_ALIGNMENT_PAD) << 3;  // << 3 insteed of << 4 because YUYV is 2 bytes wide
    dwSizeIn = asmMergeCoords((dwWidth & ~1), (dwHeight & ~1));
    dwSizeIn += dwPointIn;
    dwOffset &= ~NV_OVERLAY_BYTE_ALIGNMENT_PAD;

    // Remember this in case we get a SetOverlayPosition call
    //pOverlayInfo->dwOverlaySrcOffset = dwOffset;
    //pOverlayInfo->dwOverlaySrcPitch = dwPitch;

    dwDeltaX = pOverlayInfo->dwOverlayDeltaX;
    dwDeltaY = pOverlayInfo->dwOverlayDeltaY;

    if (IS_FIELD(dwFlags)) {
        if (dwFlags & VPP_INTERLEAVED) {
            // if (dwFlags & VPP_ODD) { 
            if (dwFlags & VPP_EVEN) {
                dwOffset += dwPitch;
            }
            dwPitch <<= 1;
            dwHeight >>= 1;
            dwDeltaY >>= 1;
        }
        if (dwFlags & VPP_BOB) {
            // if (dwFlags & VPP_ODD) {
            if (dwFlags & VPP_EVEN) {
                dwPointIn += 0xFFFC0000;
            } else {
                dwPointIn += 0x00040000;
            }
        }
    }

    // replace old surface pitch value with current pitch value
    dwOverlayFormat = pOverlayInfo->dwOverlayFormat;
    dwOverlayFormat &= 0xFFFF0000;
    dwOverlayFormat |= dwPitch;
    dwOverlayFormat |= (1 << 31);

/*

    if (pVPEContext->dwVPConnectFlags & NVP_CONNECT_HDTV) // progressive (non-interlaced) and 16bit VIP
        dwOverlayFormat |= (NV07A_SET_OVERLAY_FORMAT_MATRIX_ITURBT709 << 24);
*/
    if (dwIndex & 0x1) {
        pPioFlipOverlayNotifier[2].status = NV_IN_PROGRESS;
    } else {
        pPioFlipOverlayNotifier[1].status = NV_IN_PROGRESS;
    }

	// program overlay to flip
	pDmaChannel = (Nv4ControlDma *)(pVPEContext->pDmaChannel);
    nvDmaCount = pVPEContext->nvDmaCount;
	NVP_DMAPUSH_CHECK_FREE_COUNT(20);

	// program the VP to grab in the next surface
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OBJECT, NVP_OVERLAY_OBJECT); //pOverlayInfo->dwOverlayObjectID);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OVERLAY_SIZE_IN(dwIndex), dwSizeIn);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OVERLAY_SIZE_OUT(dwIndex), (asmMergeCoords(pOverlayInfo->dwOverlayDstWidth, pOverlayInfo->dwOverlayDstHeight)));
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OVERLAY_POINT_IN(dwIndex), dwPointIn);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OVERLAY_POINT_OUT(dwIndex), (asmMergeCoords(pOverlayInfo->dwOverlayDstX, pOverlayInfo->dwOverlayDstY)));

    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OVERLAY_OFFSET(dwIndex), dwOffset);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OVERLAY_COLORKEY(dwIndex), pOverlayInfo->dwOverlayColorKey);

    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OVERLAY_DU_DX(dwIndex), dwDeltaX);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OVERLAY_DV_DY(dwIndex), dwDeltaY);

    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OVERLAY_FORMAT(dwIndex), dwOverlayFormat);

//    NVP_DMAPUSH_START();
    pDmaChannel->Put = nvDmaCount << 2;
	pVPEContext->nvDmaCount = nvDmaCount;

    return TRUE;
}

//---------------------------------------------------------------------------
// vddPrescaleAndFlip
//
//      VPE implementation of selected parts of DDRAW's VPP pipe.  Only 
//      prescaling and flip are performed.
//

#define NEXT_SURFACE { \
            dwSrcOffset = dwDstOffset;  \
            dwSrcPitch = dwDstPitch;    \
            dwDstOffset = dwNextOffset; \
            dwDstPitch = dwNextPitch;   \
            dwNextOffset = dwSrcOffset; \
            dwNextPitch = dwSrcPitch;   \
            dwOpCount++;                \
        }

#define NV_WIN_DEVICE    0x00002002

BOOL NVPPrescaleAndFlip(
    PNVP_CONTEXT  pVPEContext, 
	PNVP_OVERLAY  pOverlayInfo,
    DWORD         dwOffset,        // source surface offset 
    DWORD         dwPitch,         // source pitch
    DWORD         dwOvIndex,         // overlay buffer index
    DWORD         dwFlags)         // VPP flags
{
	DWORD dwHeight, dwWidth, i = 0;
    DWORD dwSrcOffset, dwSrcPitch;
    DWORD dwDstOffset, dwDstPitch;
    DWORD dwNextOffset, dwNextPitch;
    DWORD dwOpCount;
    DWORD dwWorkSurfaces;
    BOOL  doXPreScale, doYPreScale, doPreScale;
    BOOL  isDownScale;
    DWORD dwRoundX, dwRoundY;
    DWORD vppExec;
    BOOL  isField;
    NvNotification *pPioFlipOverlayNotifier = (NvNotification *)pOverlayInfo->pNvPioFlipOverlayNotifierFlat;


#if 0 //#ifdef DEBUG
    char debugstr[256];

    debugstr[0] = '\0';
    if (dwFlags & VPP_ODD)          strcat(debugstr, "odd  ");
    if (dwFlags & VPP_EVEN)         strcat(debugstr, "even ");
    if (dwFlags & VPP_BOB)          strcat(debugstr, "bob ");
    if (dwFlags & VPP_INTERLEAVED)  strcat(debugstr, "int ");
    if (dwFlags & VPP_VIDEOPORT)    strcat(debugstr, "vp ");
    if (dwFlags & VPP_WAIT)         strcat(debugstr, "wait ");
    if (dwFlags & VPP_OPTIMIZEFLIP) strcat(debugstr, "opt ");
    strcat(debugstr, "REQ: ");
    if (dwFlags & VPP_CONVERT)      strcat(debugstr, "cvt ");
    if (dwFlags & VPP_SUBPICTURE)   strcat(debugstr, "sp ");
    if (dwFlags & VPP_PRESCALE)     strcat(debugstr, "ps ");
    if (dwFlags & VPP_COLOURCONTROL) strcat(debugstr, "cc ");
    if (dwFlags & VPP_TEMPORAL)     strcat(debugstr, "tf ");
    if (dwFlags & VPP_DEINTERLACE)  strcat(debugstr, "df ");
#endif

    //assert(pDriverData);

    // XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
    // find out if overlay hardware is busy, if so return "overlay busy" error code.
    // Perhaps check a "number of overlay buffers programmed" count.  When this count is less 
    // than 2, the overlay hardare is not busy and when it's equal to 2, the hardwar is busy. 
    // If it's not busy, then program it up here and increment the count.  Then use a kernel 
    // callback to decrement this count upon buffer complete.
    //
    
    DWORD dwIndex = pOverlayInfo->dwOverlayBufferIndex;

#ifdef _NVP_DTRACE
    DTRACE(0xdead0001);
    DTRACE_CYCLE_DELTA();
    DTRACE(dwOffset);
    DTRACE(dwIndex);

//    return TRUE;
#endif

/*
        while ((pPioFlipOverlayNotifier[dwIndex + 1].status == NV_IN_PROGRESS) && (i < VDD_VPP_TIME_OUT))
            i++;
        // timed-out... stop the appropriate buffer and return error
        if (i >= VDD_VPP_TIME_OUT)
*/
    // drop field if previous one is still being drawn (same overlay buffer) !
    if (pPioFlipOverlayNotifier[dwIndex + 1].status == NV_IN_PROGRESS)
        return 1;

    dwWorkSurfaces = pOverlayInfo->dwExtra422NumSurfaces;
    vppExec = 0;
    dwOpCount = 0;
    dwSrcOffset = dwOffset;
    dwSrcPitch = dwPitch;
    dwDstOffset = pOverlayInfo->aExtra422OverlayOffset[pOverlayInfo->dwExtra422Index];
    dwDstPitch = pOverlayInfo->dwExtra422Pitch;
    dwNextOffset = pOverlayInfo->aExtra422OverlayOffset[pOverlayInfo->dwExtra422Index + 1];
    dwNextPitch = pOverlayInfo->dwExtra422Pitch;

    isField = IS_FIELD(dwFlags);

    doXPreScale = (pOverlayInfo->dwOverlaySrcWidth > (pOverlayInfo->dwOverlayDstWidth * pOverlayInfo->dwOverlayMaxDownScale));
    doYPreScale = (pOverlayInfo->dwOverlaySrcHeight > (pOverlayInfo->dwOverlayDstHeight * pOverlayInfo->dwOverlayMaxDownScale));
  
    if (pVPEContext->dwChipId < NV_DEVICE_VERSION_10) {
        // NV4/5 also prescales:
        //  - all BOBed fields
        //  - vertical upscales when HQVUp is enabled
        doYPreScale = TRUE; //doYPreScale || isField; //|| (pOverlayInfo->regOverlayMode & NV4_REG_OVL_MODE_VUPSCALE)
    }

    doPreScale = (dwFlags & VPP_PRESCALE) &&
                 (doXPreScale || doYPreScale);

    isDownScale = FALSE;
    if (doPreScale) 
    {
        DWORD dwSrcArea, dwDstArea;

        dwSrcArea = pOverlayInfo->dwOverlaySrcHeight * pOverlayInfo->dwOverlaySrcWidth;
        if ((dwFlags & (VPP_ODD | VPP_EVEN)) && (dwFlags & VPP_INTERLEAVED)) 
        {
            // bob mode
			dwSrcArea >>= 1;
        }
        dwDstArea = pOverlayInfo->dwOverlayDstHeight * pOverlayInfo->dwOverlayDstWidth;
        if (dwSrcArea > dwDstArea) 
        {
            isDownScale = TRUE;
        }
    }

    if (dwWorkSurfaces < 2) {
        // no work surfaces, can't do anything
        doPreScale = FALSE;
    }

    // adjust for the subrectangle
    dwRoundX = pOverlayInfo->dwOverlaySrcX & 0x1;
    dwRoundY = pOverlayInfo->dwOverlaySrcY & 0x1;
    dwSrcOffset += (pOverlayInfo->dwOverlaySrcY & ~0x1) * dwSrcPitch;
    dwSrcOffset += (pOverlayInfo->dwOverlaySrcX & ~0x1) << 1;   // always YUV422
    dwWidth = pOverlayInfo->dwOverlaySrcSize & 0xFFFF;
    dwHeight = pOverlayInfo->dwOverlaySrcSize >> 16;
    if (dwWidth & 1)
        dwWidth += 1;
    if (dwRoundY)
        dwHeight += 1;

    // do the prescaling now
    if (doPreScale) 
    {
        if (NVPPreScale(pVPEContext, pOverlayInfo, 
                        dwSrcOffset, dwSrcPitch, dwDstOffset, dwDstPitch, &dwWidth, &dwHeight, 
                        &dwFlags)) {
            NEXT_SURFACE;
            vppExec |= VPP_PRESCALE;
        }
    }

    if (dwRoundY) 
    {
        dwSrcOffset += dwSrcPitch;
        dwHeight -= 1;
    }

//    if (dwRoundX)
//        dwWidth -= 1;

    // always do the flip, even if we are not flipping
    if (NVPFlip(pVPEContext, pOverlayInfo, dwSrcOffset,
                dwSrcPitch, dwWidth, dwHeight, dwIndex, dwFlags)) 
    {
        pOverlayInfo->dwOverlayBufferIndex ^= 1;
        if (dwWorkSurfaces == 0) 
        {
            pOverlayInfo->dwExtra422Index = 0;
        }
        else if (dwWorkSurfaces <= 3)
        {
            pOverlayInfo->dwExtra422Index = (pOverlayInfo->dwExtra422Index + 1) % dwWorkSurfaces;
        } 
        else 
        {
            pOverlayInfo->dwExtra422Index = (pOverlayInfo->dwExtra422Index + 2) % dwWorkSurfaces;
        }
    } 
    else 
    {
        return FALSE;
    }

    return TRUE;
}


#endif // #ifdef NVPE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\modeset.mhd\CODE\digmode.c ===
/*
    FILE:   digmode.c
    DATE:   4/8/99

    This file contains the code for mode setting/determination
    ona CRT or FLAT PANEL.
*/

#include "cmntypes.h"
#include "modeext.h"
#include "modeset.h"
#include "debug.h"
#include "restime.h"
#include "digmode.h"
#include "dmt.h"
#include "edid.h"
#include "gtf.h"
#include "gtfmath.h"
#include "osapi.h"

#define     BACKOFF_MODE        0x01
#define     GOT_TIMINGS         0x02
#define     RANGE_CHECK_MODE    0x04

/*==========================================================================
    Function:   FindDigModeEntry

    Purpose:    Finds a set of timings for a mode for a CRT or DFP
                that will work on the device.

    Arguments:
                lpEdidBuffer    ptr to an EDID (or NULL if no edid)
                dwEdidSize      length of edid in bytes (or 0 if no edid)
                lpDispData      ptr to DISPDATA struct descirbing board
                lpModeOrig      ptr to MODEINFO desribing requested mode
                lpModeOut       ptr to place to store timings for final
                                mode decided upon (not necessarily the
                                same mode as given by lpModeOrig)
                lpModeList      ptr to a MODEENTRY array -- master mode list
                lpRTList        ptr to a RESTIME array -- R&T list

    Returns:    some bitwise ORing of the flags in modeext.h
                MODE_EXACT_MATCH
                MODE_RESOLUTION_ADJUSTED
                MODE_PIXEL_DEPTH_ADJUSTED
                MODE_REFRESH_RATE_ADJUSTED

    Preserve:
===========================================================================*/
int CFUNC
FindDigModeEntry (
    LPCHAR      lpEdidBuffer,
    ULONG       dwEdidSize,
    LPDISPDATA  lpDispData,
    LPMODEINFO  lpModeOrig,
    LPMODEOUT   lpModeOut,
    LPMODEENTRY lpModeList,
    LPRESTIME   lpRTList)
{
    int             i, nFlag, nIndex, bDoneRT, iRRFlag;
    MODEINFO        ModeDesc, LimitMode, ModeDFP;
    RTMODE          sRTMode;
    ULONG           dwMonitorID, dwMemoryUsed, dwPitch, dwDirection;
    ULONG           dwDacSpeedInHertz, dwDacSpeedLimitInHertz;
    USHORT          wActFlags;
    ULONG           wAllowAllModes;

    // Put out a bit of useful logging information.
    DBG_PRINT0(DL_0, "\r\nEntering FindDigModeEntry.");

    // Make a copy so we can modify the mode as we go along without
    // changing the original requested mode.
    ModeDesc = lpModeOrig[0];

    wAllowAllModes = GetAllowAllModesFlag(lpDispData->lpBoardRegistryData);

    // Decrease refresh rate in BackOffDigModeEntry() by default.
    iRRFlag = 1;
    // Set positive direction
    dwDirection = 1;

  do
  {
    // We will be modifying this as we go along.
    wActFlags = RANGE_CHECK_MODE;

    /////////////////////////////////////////////////////////////////
    // First, see if this mode is in the master mode list
    DBG_PRINT0(DL_1, "\r\nSearching for Mode in Master Mode List.");
    DBG_PRINT1(DL_1, "\r\nXRes = %ld", ModeDesc.dwXRes);
    DBG_PRINT1(DL_1, "\r\nYRes = %ld", ModeDesc.dwYRes);
    DBG_PRINT1(DL_1, "\r\nBpp  = %ld", ModeDesc.dwBpp);
    DBG_PRINT1(DL_1, "\r\nRefR = %ld", ModeDesc.dwRefreshRate);
    if (!wAllowAllModes)
    {
        for (i = 0; lpModeList[i].dwXRes != 0; i++)
        {
            if  ((lpModeList[i].dwXRes == ModeDesc.dwXRes) &&
                 (lpModeList[i].dwYRes == ModeDesc.dwYRes) &&
                 (lpModeList[i].dwBpp  == ModeDesc.dwBpp)  &&
                 (lpModeList[i].dwRefreshRate  == ModeDesc.dwRefreshRate))
                break;
        }

        // Did we find the mode in the list?
        if  (lpModeList[i].dwXRes == 0)
        {
            DBG_PRINT0(DL_1, "\r\nFound Mode in Master List.");
            wActFlags |= BACKOFF_MODE;
        }
    }
    /////////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////
    // NO EDID AND NO INF blocks certain modes
    if  (!(wAllowAllModes) && !(wActFlags & BACKOFF_MODE) && (dwEdidSize == 0) &&
          (lpDispData->dwMonitorInfType != SPECIFIC_DEVICE))
    {
        if  (ModeDesc.MIDevData.cType == DEVTYPE_CRT)
        {
            // If the CRT has no inf and no edid, then we
            // check the registry to see what the upper limit
            // should be in this situation.
            if  (GetMonitorLimitMode (lpDispData, &LimitMode))
            {
                if  ((ModeDesc.dwRefreshRate > LimitMode.dwRefreshRate) ||
                     (ModeDesc.dwXRes > LimitMode.dwXRes) ||
                     (ModeDesc.dwYRes > LimitMode.dwYRes))
                {
                    wActFlags |= BACKOFF_MODE;
                }
                else
                {
                    wActFlags &= ~RANGE_CHECK_MODE;
                }
            }
            else
            {
                wActFlags &= ~RANGE_CHECK_MODE;
            }
        }

        if  (ModeDesc.MIDevData.cType == DEVTYPE_DFP)
        {
            // If the DFP has no inf and no edid, then we block any
            // refreshrate higher than 60Hz and block all resolutions
            // higher than 1024x768.
            if  ((ModeDesc.dwRefreshRate > 60) ||
                 (ModeDesc.dwXRes > 1024) ||
                 (ModeDesc.dwYRes > 768))
            {
                wActFlags |= BACKOFF_MODE;
            }
            else
            {
                wActFlags &= ~RANGE_CHECK_MODE;
            }
        }
    }
    /////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////
    // NO EDID AND YES INF means trust the INF on everything.
    if  (!(wAllowAllModes) && !(wActFlags & BACKOFF_MODE) && (dwEdidSize == 0) &&
          (lpDispData->dwMonitorInfType == SPECIFIC_DEVICE))
    {
        // Nothing to do here right now.
        // We just assume that whatever we are asked to set
        // can be done because Windows wouldn't call us with
        // some mode that is not in the .inf.
    }
    /////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////
    // YES EDID AND NO INF means trust the EDID on everything.
    if  (!(wAllowAllModes) && !(wActFlags & BACKOFF_MODE) && (dwEdidSize != 0) &&
          (lpDispData->dwMonitorInfType != SPECIFIC_DEVICE))
    {
        // Nothing to do here right now.
    }
    /////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////
    // YES EDID AND YES INF case. Edid range limits have top priority
    // and, if they exist, ModeWithinMonitorTimingLimits will check
    // against those later. If there are no range limits in the EDID,
    // then we will use the range string from the .inf file.
    if  (!(wAllowAllModes) && !(wActFlags & BACKOFF_MODE) && (dwEdidSize != 0) &&
          (lpDispData->dwMonitorInfType == SPECIFIC_DEVICE))
    {
        // Note that there is nothing to do here right now.
    }
    /////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////////
    // We need to block certain modes on DFPs.
    if  (!(wAllowAllModes) && !(wActFlags & BACKOFF_MODE) && (ModeDesc.MIDevData.cType == DEVTYPE_DFP))
    {
        // Block 480x360 and 960x720. DFPs often have trouble
        // with these modes.
        if  (((ModeDesc.dwXRes == 480) && (ModeDesc.dwYRes == 360)) ||
            ((ModeDesc.dwXRes == 960) && (ModeDesc.dwYRes == 720)))
            wActFlags |= BACKOFF_MODE;

        // HACK!!! We will fix this for real shortly, but this should
        // work for now.
        //
        // On DFPs, block any X,Y res that is bigger than the largest
        // mode in the EDID. Any mode that is smaller can still be
        // blocked by the pixel frequency range of the chip's DFP
        // scaler which is 8Mhz - 350Mhz.
        //
        // I'm not worried about any mode exceeding 350Mhz right now,
        // so I am going to omit the check for it. The check would
        // have to be put into ModeWithinMonitorTimingLimits() and
        // I'm trying to keep this hack localized.
        if  (dwEdidSize != 0)
        {
            EdidFindLargestEdidMode (lpEdidBuffer, dwEdidSize, &ModeDFP);
            if  ((ModeDesc.dwXRes > ModeDFP.dwXRes) ||
                 (ModeDesc.dwYRes > ModeDFP.dwYRes))
            {
                // Block modes that are larger than largest EDID mode.
                wActFlags |= BACKOFF_MODE;
            }
            else
            {
                // Let any smaller X,Y res go through. The refresh
                // rate is irrelevant right now, because the RM is
                // currently assuming fixed frequency DFPs at 60Hz.
                wActFlags &= ~RANGE_CHECK_MODE;
            }
        }
    }
    /////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////
    // We need to block certain modes according to restriction
    // and timing strings.

    if  (!(wAllowAllModes) && !(wActFlags & BACKOFF_MODE))
    {
        // See if we find a matching R&T string
        sRTMode.dwXRes = ModeDesc.dwXRes;
        sRTMode.dwYRes = ModeDesc.dwYRes;
        sRTMode.dwBpp  = ModeDesc.dwBpp;
        sRTMode.dwRefreshRate = ModeDesc.dwRefreshRate;

        if  (dwEdidSize)
            dwMonitorID = EdidGetMonitorId (lpEdidBuffer, dwEdidSize);
        else
            dwMonitorID = UKWN_ID;

        for (nIndex = 0, bDoneRT = FALSE; !bDoneRT;)
        {
            nIndex = RTFindNextMatchingString (lpRTList, nIndex + 1,
                        lpDispData, &sRTMode, dwMonitorID);

            if  (nIndex != RTERR_NOT_FOUND)
            {
                DBG_PRINT1(DL_0, "\r\nFound R&T string matching board data # %ld", (ULONG) nIndex);

                // There was. Let's see what that tells us.
                nFlag = ProcessRTWithDigModeEntry (lpDispData,
                                lpEdidBuffer, dwEdidSize,
                                lpRTList + nIndex, &ModeDesc, lpModeOut);

                // > 0 means that the R&T string accepted the mode and
                // we have a set of timings in lpModeOut. We're done!
                if  (nFlag > 0)
                {
                    wActFlags |= GOT_TIMINGS;
                    bDoneRT = TRUE;
                }

                if  (nFlag == 2)
                    wActFlags &= ~RANGE_CHECK_MODE;

                // < 0 means that this mode was explicitly rejected by
                // the R&T string -- probably a NONE in the Timing
                // Standard field. We need to back off the mode.
                if  (nFlag < 0)
                {
                    wActFlags |= BACKOFF_MODE;
                    bDoneRT = TRUE;
                }
            }
            else
                bDoneRT = TRUE;
        }
    }
    /////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////
    // At this point, check to see if we want to override any
    // timing standards that were already selected.
    if  (!(wActFlags & BACKOFF_MODE) && !(wActFlags & GOT_TIMINGS))
    {
        nFlag = CheckTimingStandardOverride (lpEdidBuffer, dwEdidSize,
                                    lpDispData, &ModeDesc, lpModeOut);
        if  (nFlag > 0)
        {
            wActFlags |= GOT_TIMINGS;
            DBG_PRINT0(DL_0, "\r\nOverride Timing Found!");
        }

        if  (nFlag == 2)
            wActFlags &= ~RANGE_CHECK_MODE;
    }
    /////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////
    // If an R&T string established the timing parameters, we
    // would not have gotten here. So at this point, just use
    // the "normal" logic to get the timing parameters.

    if  ((!(wActFlags & BACKOFF_MODE)) && !(wActFlags & GOT_TIMINGS) && (dwEdidSize == 0))
    {
        if  (DmtFindMode (&ModeDesc, lpModeOut))
        {
            wActFlags |= GOT_TIMINGS;
            wActFlags |= RANGE_CHECK_MODE;
            DBG_PRINT0(DL_0, "\r\nDmt timing found.");
        }

        if  (!(wActFlags & GOT_TIMINGS))
        {
            if  (GtfFindMode (&ModeDesc, lpModeOut))
            {
                wActFlags |= GOT_TIMINGS;
                wActFlags |= RANGE_CHECK_MODE;
                DBG_PRINT0(DL_0, "\r\nGtf timing found.");
            }
        }
    }
    /////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////
    // If an R&T string established the timing parameters, we
    // would not have gotten here. So at this point, just use
    // the "normal" logic to get the timing parameters.

    if  ((!(wActFlags & BACKOFF_MODE)) && (!(wActFlags & GOT_TIMINGS)) && (dwEdidSize != 0))
    {
        if  (EdidFindDetailedMode (lpEdidBuffer, dwEdidSize, &ModeDesc, lpModeOut))
        {
            DBG_PRINT0(DL_0, "\r\nEdidDetailedTiming Found!");
            wActFlags = (wActFlags & ~RANGE_CHECK_MODE) | GOT_TIMINGS;
        }
        else if  (EdidFindStandardMode (lpEdidBuffer, dwEdidSize, &ModeDesc, lpModeOut))
        {
            DBG_PRINT0(DL_0, "\r\nEdidStandardTiming Found!");
            wActFlags = (wActFlags & ~RANGE_CHECK_MODE) | GOT_TIMINGS;
        }
        else if  (EdidFindEstablishedMode (lpEdidBuffer, dwEdidSize, &ModeDesc, lpModeOut))
        {
            DBG_PRINT0(DL_0, "\r\nEdidEstablishedTiming Found!");
            wActFlags = (wActFlags & ~RANGE_CHECK_MODE) | GOT_TIMINGS;
        }
        else if  ((EdidIsGtfMonitor (lpEdidBuffer, dwEdidSize)) && GtfFindMode (&ModeDesc, lpModeOut)
                  && (ModeDesc.dwXRes > 400) && (ModeDesc.dwYRes > 300))
        {
            wActFlags |= GOT_TIMINGS;
            DBG_PRINT0(DL_0, "\r\nGtf timing found.");
        }
        else if  (DmtFindMode (&ModeDesc, lpModeOut))
        {
            wActFlags |= GOT_TIMINGS;
            DBG_PRINT0(DL_0, "\r\nDmt timing found.");
        }
        else if  (GtfFindMode (&ModeDesc, lpModeOut))
        {
            wActFlags |= GOT_TIMINGS;
            DBG_PRINT0(DL_0, "\r\nGtf timing found.");
        }
    }
    /////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////
    if  (!(wActFlags & BACKOFF_MODE) && (wActFlags & GOT_TIMINGS))
    {
        if (!wAllowAllModes)
        {
            // We weren't explicitly asked to back off and we have some
            // timings, so range check them if requested.
            if  (!(wActFlags & RANGE_CHECK_MODE) ||
                (iRRFlag = ModeWithinMonitorTimingLimits (lpDispData, lpModeOut, lpEdidBuffer, dwEdidSize)) == 0)
            {
                // Now verify that there is enough memory and that
                // the DAC is fast enough to handle the mode.
                GetPitchAndSize (lpDispData, ModeDesc.dwXRes,
                                    ModeDesc.dwYRes, ModeDesc.dwBpp,
                                    &dwPitch, &dwMemoryUsed);
                dwDacSpeedInHertz = Multiply32By32 (lpModeOut->dwPixelClock, 10000);

                // Get the dac speed limit for the given pixel depth
                if  (ModeDesc.dwBpp == 8)
                    dwDacSpeedLimitInHertz = lpDispData->dwMaxDacSpeedInHertz8bpp;

                if  ((ModeDesc.dwBpp == 16) || (ModeDesc.dwBpp == 15))
                    dwDacSpeedLimitInHertz = lpDispData->dwMaxDacSpeedInHertz16bpp;

                if  ((ModeDesc.dwBpp == 32) || (ModeDesc.dwBpp == 24))
                    dwDacSpeedLimitInHertz = lpDispData->dwMaxDacSpeedInHertz32bpp;

                if  ((lpDispData->dwVideoMemoryInBytes >= dwMemoryUsed) &&
                     (dwDacSpeedLimitInHertz >= dwDacSpeedInHertz))
                    return  (GetModeFlags (lpModeOrig, &ModeDesc));
                else
                {
                    iRRFlag = 1;
                    wActFlags |= BACKOFF_MODE;
                }
            }
            else
            {
                if(iRRFlag < 0)
                    dwDirection = 0;

                wActFlags |= BACKOFF_MODE;
            }
        }
        else
            return  (GetModeFlags (lpModeOrig, &ModeDesc));
    }

    if  ((wActFlags & BACKOFF_MODE) || !(wActFlags & GOT_TIMINGS))
    {
        // If we are directed to backoff explicitly, or we didn't
        // find any timings, then go ahead and backoff.
        if  ((dwDirection == 0 && iRRFlag > 0) ||
            !BackOffDigModeEntry (lpModeList, &ModeDesc, lpModeOrig, iRRFlag))
        {
            // Just return safe settings if we couldn't back off
            return  (GetSafeTiming (&ModeDesc, lpModeOut));
        }
    }
    /////////////////////////////////////////////////////////////

  } while (TRUE);

}


/*==========================================================================
    Function:   CheckTimingStandardOverride

    Purpose:    Checks to see if we are supposed to use a particular
                timing standard (like DMT or GTF). If we are, sees if
                there is a set of timings to match the requested mode.

    Arguments:
                lpEdidBuffer    ptr to an EDID (or NULL if no edid)
                dwEdidSize      length of edid in bytes (or 0 if no edid)
                lpDispData      ptr to DISPDATA struct descirbing board
                lpModeDesc      ptr to MODEINFO desribing requested mode
                lpModeOut       ptr to place to store timings for
                                lpModeDesc mode if needed.

    Returns:    > 0     then a timing standard override was requested
                        and lpModeOut has the set of timings for the
                        mode passed in in lpModeDesc
                        if 1 then range check mode
                        if 2 then dont range check mode
                0       Either no timing standard override was requested
                        or one was but there was no set of timings in
                        that timing standard for the mode given by
                        lpModeDesc

    Preserve:
===========================================================================*/
int CFUNC
CheckTimingStandardOverride (
    LPCHAR      lpEdidBuffer,
    ULONG       dwEdidSize,
    LPDISPDATA  lpDispData,
    LPMODEINFO  lpModeDesc,
    LPMODEOUT   lpModeOut)
{
    ULONG   dwTimingStandard;
    MODEOUT sModeOutTemp;
    int     nRet;

    dwTimingStandard = GetTimingStandardOverride (lpDispData);

    if  (dwTimingStandard == DMTV_ID)
    {
        if  (DmtFindMode (lpModeDesc, lpModeOut))
        {
            nRet = 1;

            if  (dwEdidSize)
            {
                if  (EdidFindStandardMode (lpEdidBuffer, dwEdidSize,lpModeDesc,lpModeOut))
                    nRet = 2;
                
                if  (EdidFindEstablishedMode (lpEdidBuffer, dwEdidSize, lpModeDesc, lpModeOut))
                    nRet = 2;
            }
    
            DBG_PRINT0(DL_0, "\r\nDmt Timing Found!");
            return  (nRet);
        }
    }

    if  (dwTimingStandard == GTFV_ID)
    {
        if  (GtfFindMode (lpModeDesc, lpModeOut))
        {
            nRet = 1;

            if  (dwEdidSize &&
				EdidFindStandardMode (lpEdidBuffer, dwEdidSize, lpModeDesc, &sModeOutTemp) &&
                !DmtFindMode (lpModeDesc, &sModeOutTemp))
                    nRet = 2;

            DBG_PRINT0(DL_0, "\r\nGtf Timing Found!");
            return  (nRet);
        }
    }

    return  (FALSE);
}



/*==========================================================================
    Functiom:   ProcessRTWithDigModeEntry

    Purpose:    Checks to see if we are supposed to use a particular
                timing standard (like DMT or GTF). If we are, sees if
                there is a set of timings to match the requested mode.

    Arguments:
                lpEdidBuffer    ptr to an EDID (or NULL if no edid)
                dwEdidSize      length of edid in bytes (or 0 if no edid)
                lpRTList        ptr to RESTIME structure we are processing
                lpModeDesc      ptr to MODEINFO desribing requested mode
                lpModeOut       ptr to place to store timings for
                                lpModeDesc mode if needed.

    Returns:
        There are three return values possible.
        > 0     This indicates that the mode was accepted by the R&T
                string and a set of timings have been placed in
                lpModeOut.
                If 2 then mode must not be range checked
                if 1, then mode should be range checked
        = 0     This R&T string did not apply to the lpModeDesc.
        < 0     The lpModeDesc mode was rejected by the R&T string.

    Preserve:
===========================================================================*/
int CFUNC
ProcessRTWithDigModeEntry (
            LPDISPDATA  lpDispData,
            LPCHAR      lpEdidBuffer,
            ULONG       dwEdidSize,
            LPRESTIME   lpRTList,
            LPMODEINFO  lpModeDesc,
            LPMODEOUT   lpModeOut)
{
    int i;

    // R&T string applies to this mode.
    // Let's walk through the timing standards.
    for (i = 0; i < MAX_DOT_FIELDS; i++)
    {
        switch (lpRTList->dwTimingStandard[i])
        {
            case NONE_ID:
                // This mode is prohibited. Fail it.
                DBG_PRINT0(DL_0, "\r\nR&T string specifies NONE timing.");
                return  (-1);

            case EDID_ID:
                DBG_PRINT0(DL_0, "\r\nR&T string specifies EDID timing.");

                if  (dwEdidSize)
                {
                    // Use an EDID detailed timing if present
                    if  (EdidFindDetailedMode (lpEdidBuffer,
                            dwEdidSize, lpModeDesc, lpModeOut))
                    {
                        DBG_PRINT0(DL_0, "\r\nEdidDetailedTiming Found!");
                        return  (1);
                    }

                    if  (EdidFindStandardMode (lpEdidBuffer,
                            dwEdidSize, lpModeDesc, lpModeOut))
                    {
                        DBG_PRINT0(DL_0, "\r\nEdidStandardTiming Found!");
                        return  (1);
                    }

                    if  (EdidFindEstablishedMode (lpEdidBuffer,
                            dwEdidSize, lpModeDesc, lpModeOut))
                    {
                        DBG_PRINT0(DL_0, "\r\nEdidEstablishedTiming Found!");
                        return  (1);
                    }
                }
                break;

            case DMTV_ID:
            case DMTR_ID:
                // Use a DMT timing if present
                DBG_PRINT0(DL_0, "\r\nR&T string specifies DMT timing.");

                if  (DmtFindMode (lpModeDesc, lpModeOut))
                {
                    if  (lpRTList->dwTimingStandard[i] == DMTR_ID)
                    {
                        // If there is an EDID, then make sure we
                        // are within the monitor limits
                        if  (!ModeWithinMonitorTimingLimits (lpDispData,
                                            lpModeOut, lpEdidBuffer,
                                            dwEdidSize))
                        {
                            DBG_PRINT0(DL_0, "\r\nDmt Timing rejected by monitor limits!");
                            break;
                        }
                    }

                    DBG_PRINT0(DL_0, "\r\nDmt Timing Found!");
                    if  (lpRTList->dwTimingStandard[i] == DMTR_ID)
                        return  (1);
                    else
                        return  (2);
                }
                break;

            case GTFV_ID:
            case GTFR_ID:
                // Use GTF unless we couldn't get an
                // Edid or unless the Edid indicated
                // the monitor was not GTF.
                DBG_PRINT0(DL_0, "\r\nR&T string specifies GTF timing.");

                if  (!dwEdidSize)
                {
                    DBG_PRINT0(DL_0, "\r\nNo Edid: Cannot use GTFV timing.");
                    break;
                }

                if  (!EdidIsGtfMonitor (lpEdidBuffer, dwEdidSize))
                {
                    DBG_PRINT0(DL_0, "\r\nNot GTF monitor: Cannot use GTFV timing.");
                    break;
                }

            // Fall through to FGTF case
            case FGTF_ID:
            case FGTR_ID:
                // Use a GTF timing regardless
                DBG_PRINT0(DL_0, "\r\nR&T string specifies FGTF timing.");

                if  (GtfFindMode (lpModeDesc, lpModeOut))
                {
                    if  ((lpRTList->dwTimingStandard[i] == GTFR_ID) ||
                         (lpRTList->dwTimingStandard[i] == FGTR_ID))
                    {
                        // If there is an EDID, then make sure we
                        // are within the monitor limits
                        if  (!ModeWithinMonitorTimingLimits (lpDispData,
                                            lpModeOut, lpEdidBuffer,
                                            dwEdidSize))
                        {
                            DBG_PRINT0(DL_0, "\r\nGtf Timing rejected by monitor limits!");
                            break;
                        }
                    }

                    // If there is no edid, or there are no
                    // monitor limits, or the GTF mode is
                    // within the monitor limits, then we
                    // have found the mode and are done!
                    DBG_PRINT0(DL_0, "\r\nGtf Timing found!");
                    if  ((lpRTList->dwTimingStandard[i] == FGTR_ID) ||
                         (lpRTList->dwTimingStandard[i] == GTFR_ID))
                        return  (1);
                    else
                        return  (2);
                }
                break;

            case OEMX_ID:
            case OEMR_ID:
                // Use the OEM timing in the TimingParameters
                DBG_PRINT0(DL_0, "\r\nR&T string specifies OEM timing.");

                lpModeOut[0] = lpRTList->sModeOut;

                if  (lpRTList->dwTimingStandard[i] == OEMR_ID) 
                {
                    // If there is an EDID, then make sure we
                    // are within the monitor limits
                    if  (!ModeWithinMonitorTimingLimits (lpDispData,
                                        lpModeOut, lpEdidBuffer,
                                        dwEdidSize))
                    {
                        DBG_PRINT0(DL_0, "\r\nOem Timing rejected by monitor limits!");
                        break;
                    }
                }

                DBG_PRINT0(DL_0, "\r\nOem Timing Found!");
                if  (lpRTList->dwTimingStandard[i] == OEMR_ID)                
                    return  (1);
                else
                    return  (2);

            default:
                // Bad Timing Standard Encountered
                DBG_PRINT0(DL_0, "\r\nBad Timing Standard. Ignoring it.");
        }
    }

    return  (0);
}


/*==========================================================================
;
; Function: BackOffDigModeEntry
;
; Purpose:  This routine backs off the current mode, first by the
;           refresh rate. If it can't do that, then it restores the
;           original refresh rate and backs off on the spatial
;           resolution. If it can't do that, then it returns a failure
;           code.
;
; Arguments:
;       lpModeList  LPMODEENTRY ptr points to mode list used to
;                   fetch next lower refresh rate/resolution from
;       lpModeDesc  Description of mode from which we should back off.
;       lpModeOrig  This was the original mode that the user called
;                   the modeset DLL with originally. It can be used
;                   in the back off algorithm as well. For example
;                   when the refresh rate cannot be backed off
;                   anymore, it may be desirable to restore the
;                   original refresh rate the user requested and
;                   then back off the reolution one notch.
;
; Returns:      0   this indicates that there was no mode that could
;                   be backed off to. We are at the end of our rope.
;               1   then lpModeDesc has been modified to hold the new
;                   backed off mode.
;
; Preserve:     All registers
;==========================================================================*/
int CFUNC
BackOffDigModeEntry (
        LPMODEENTRY lpModeList,
        LPMODEINFO  lpModeDesc,
        LPMODEINFO  lpModeOrig,
    int         iRRFlag)
{
    if(iRRFlag < 0 && FindNextLargerRefreshRate (lpModeList, lpModeDesc))
    {
    DBG_PRINT0(DL_0, "\r\nBacking off to mode with a larger refresh rate.");
    }
    else if (iRRFlag > 0 && FindNextSmallerRefreshRate (lpModeList, lpModeDesc))
    {
    DBG_PRINT0(DL_0, "\r\nBacking off to mode with a lower refresh rate.");
    }
    else
    {
        // We couldn't find a the same resolution and pixel depth
        // with a lower refresh rate. This may happen, for example,
        // if we were already at 60Hz. Let's reset the refresh rate
        // to what was originally requested and find the next lower
        // spatial resolution resolution at the same pixel depth.
        lpModeDesc[0].dwRefreshRate = lpModeOrig[0].dwRefreshRate;

        if  (FindNextSmallerResolution (lpModeList, lpModeDesc))
        {
            DBG_PRINT0(DL_0, "\r\nBacking off to mode with a lower resolution.");
        }
        else
        {
            // OK, if this doesn't happen, then we had already
            // scanned down from the mode/refresh rate requested
            // through all all lower resolutions/refresh rates and
            // none of them were settable.
            // Inidicate that there are no more modes to try.
            return  (FALSE);
        }
    }

    return  (TRUE);
}


/*==========================================================================
    Function:   ModeWithinMonitorTimingLimits

    Purpose:    Checks to see if a given mode is within the timing
                limits for the monitor.

    Arguments:
                lpEdidBuffer    ptr to an EDID (or NULL if no edid)
                dwEdidSize      length of edid in bytes (or 0 if no edid)
                lpModeOut       timings to check

    Returns:    0   mode is within monitor limits
                #0   mode is not within limits
        ( > 0 - try to decrease refresh rate first )

    Preserve:
===========================================================================*/
int CFUNC
ModeWithinMonitorTimingLimits (
                LPDISPDATA  lpDispData,
                LPMODEOUT lpModeOut,
                LPCHAR    lpEdidBuffer,
                ULONG     dwEdidSize)
{
    ULONG           dwPixelClockInHertz;
    ULONG           dwHorzRate, dwMaxXRes, dwMaxYRes;
    USHORT          wGotRangeLimits;
    MONITORLIMITS   sML;

    // Assume that we don't find any range limits
    wGotRangeLimits = FALSE;

    if  (dwEdidSize == 0)
    {
        // No EDID ... if there is no INF, just say YES
        if  (lpDispData->dwMonitorInfType != SPECIFIC_DEVICE)
            return  (0);

        // Does the inf file have range limits?
        if  (GetMonitorInfRangeLimits (lpDispData, &sML, &dwMaxXRes, &dwMaxYRes))
            wGotRangeLimits = TRUE;
        else
            return  (0);
    }
    else
    {
        // There is an EDID ... Are there range limits?
        if  (EdidGetMonitorLimits (lpEdidBuffer, dwEdidSize, &sML))
        {
            // There are range limits, so don't use the .inf file
            wGotRangeLimits = TRUE;
        }
        else
        {
            // There are no range limits ... is there an .inf file?
            if  (lpDispData->dwMonitorInfType == SPECIFIC_DEVICE)
            {
                // Does the inf file have range limits?
                if  (GetMonitorInfRangeLimits (lpDispData, &sML, &dwMaxXRes, &dwMaxYRes))
                    wGotRangeLimits = TRUE;
                else
                    wGotRangeLimits = FALSE;
            }
        }
    }

    if  (!wGotRangeLimits)
    {
        // We didn't get range limits, but we wouldn't have gotten here,
        // if there had not been an EDID. SO, we must use the modes given
        // in the EDID to determine approximate range limits. We need to
        // find the standard, established or detailed mode that has the:
        // 1) largest pixel clock
        // 2) smallest pixel clock
        // 3) largest horizontal refresh rate
        // 4) smallest horizontal refresh rate
        // 5) largest vertical refresh rate
        // 6) smallest vertical refresh rate
        //
        // The particular mode in the EDID that gives each
        // of these values may be a different one.

        EdidBuildRangeLimits (lpEdidBuffer, dwEdidSize, &sML);
    }

    // First check the pixel clock
    dwPixelClockInHertz = Multiply32By32 (lpModeOut->dwPixelClock, 10000);
    if  (dwPixelClockInHertz > sML.dwMaxPixelClock)
        return  1;

    // If the maximum vertical is not zero, check the vertical
    // refresh rate directly. If the maximum vertical refresh rate
    // is zero, there are no limits so skip check.
    if (sML.dwMaxVert)
    {
        // If the minimum vertical is the same as the maximum vertical,
        // only check against the maximum vertical.
        if (sML.dwMinVert == sML.dwMaxVert)
        {
            if (lpModeOut->wRefreshRate > sML.dwMaxVert)
                return 1;
        }
        else
        {
            if  (lpModeOut->wRefreshRate < sML.dwMinVert)
        return -1;
            if  (lpModeOut->wRefreshRate > sML.dwMaxVert)
        return 1;
        }
    }

    // The horizontal refresh rate is the scan rate per frame.
    dwHorzRate = Divide32By32 (dwPixelClockInHertz + ((ULONG)lpModeOut->wHTotal / 2), (ULONG)lpModeOut->wHTotal);

    // Use integer part only
    dwHorzRate = Divide32By32(dwHorzRate , 1000) ;
    dwHorzRate = Multiply32By32(dwHorzRate , 1000) ;

    // If the maximum horizontal is not zero, check the horizontal
    // refresh rate directly. If the maximum horizontal refresh rate
    // is zero, there are no limits so skip check.
    if (sML.dwMaxHorz)
    {
        if (sML.dwMinHorz == sML.dwMaxHorz)
        {
            if  (dwHorzRate > sML.dwMaxHorz)
                return 1;
        }
        else
        {
            if  (dwHorzRate < sML.dwMinHorz)
                return -1;
        if  (dwHorzRate > sML.dwMaxHorz)
                return 1;
        }
    }

    return  0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\modeset.mhd\CODE\DMT.C ===
/*
    FILE:   dmt.c
    DATE:   4/8/99

    This file is the generic entry point for the dmt modeset code.
*/

#include "cmntypes.h"
#include "modeext.h"
#include "modeset.h"
#include "utils.h"
#include "debug.h"

//*****************************************************************************
//
// VESA 1.0 rev 0.7 DMT timings
//
// DMT timing calculations were produced with the VESA DMT 1.0 rev 0.7
// Monitor Timing Specifications.
//
// Horizontal Visible, Vertical Visible
// Refresh (Hz * 100)
// Horizontal Total, Blank Start, Sync Start, Sync End, Blank End
// Vertical Total, Blank Start, Sync Start, Sync End, Blank End
// DotClock (MHz * 100)
// HSync polarity
// VSync polarity
//
// NOTE: Unlike GTF timings, DMT does not dictate zero border widths.
// Therefore we must include blank start and end positions.
//
MODESTRUC    DMTTimingTable[] =
{
    // Settings for 320x200 (mode doubled 640x400):
    //  NOTE: There is no 60Hz 320x200, so use 70Hz if anyone wants 60Hz
    320,200,60,800/2,640/2,656/2,752/2,288/2,449,400,412,414,449,2518/2,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_NEGATIVE,
    320,200,70,800/2,640/2,656/2,752/2,288/2,449,400,412,414,449,2518/2,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_NEGATIVE,
    320,200,85,832/2,640/2,672/2,736/2,832/2,445,400,401,404,445,3150/2,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_NEGATIVE,

    // Settings for 320x240 (mode doubled 640x480):
    320,240,60,800/2,648/2,656/2,752/2,792/2,525,488,490,492,517,2518/2,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE,
    320,240,72,832/2,648/2,664/2,704/2,824/2,520,488,489,492,512,3150/2,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE,
    320,240,75,840/2,640/2,656/2,720/2,840/2,500,480,481,484,500,3150/2,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE,
    320,240,85,832/2,640/2,696/2,752/2,832/2,509,480,481,484,509,3600/2,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE,

    // Settings for 400x300 (mode doubled 800x600):
    400,300,60,1056/2,800/2,840/2,968/2,1056/2,628,600,601,605,628,4000/2,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    400,300,72,1040/2,800/2,856/2,976/2,1040/2,666,600,637,643,666,5000/2,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    400,300,75,1056/2,800/2,816/2,896/2,1056/2,625,600,601,604,625,4950/2,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    400,300,85,1048/2,800/2,832/2,896/2,1048/2,631,600,601,604,631,5625/2,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,

    // Settings for 512x384 (mode doubled 1024x768):
    512,384,60,1344/2,1024/2,1048/2,1184/2,1344/2,806,768,771,777,806,6500/2,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE,
    512,384,70,1328/2,1024/2,1048/2,1184/2,1328/2,806,768,771,777,806,7500/2,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE,
    512,384,75,1312/2,1024/2,1040/2,1136/2,1312/2,800,768,769,772,800,7875/2,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    512,384,85,1376/2,1024/2,1072/2,1168/2,1376/2,808,768,769,772,808,9450/2,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,

    // Settings for 640x350:
    640,350,85,832,640,672,736,832,445,350,382,385,445,3150,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_NEGATIVE,

    // Settings for 640x400:
    640,400,60,800,640,656,752,288,449,400,412,414,449,2518,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_NEGATIVE,
    640,400,85,832,640,672,736,832,445,400,401,404,445,3150,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    // Settings for 640x480:
    640,480,60,800,648,656,752,792,525,488,490,492,517,2518,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE,
    640,480,72,832,648,664,704,824,520,488,489,492,512,3150,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE,
    640,480,75,840,640,656,720,840,500,480,481,484,500,3150,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE,
    640,480,85,832,640,696,752,832,509,480,481,484,509,3600,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE,

    // Settings for 720x400:
    720,400,85,936,720,756,828,936,446,400,401,404,446,3550,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    // Settings for 720x480
    720,480,60,800,728,744,776,792,525,488,490,492,517,2518,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,

    // Settings for 800x600:
    800,600,56,1024,800,824,896,1024,625,600,601,603,625,3600,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    800,600,60,1056,800,840,968,1056,628,600,601,605,628,4000,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    800,600,72,1040,800,856,976,1040,666,600,637,643,666,5000,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    800,600,75,1056,800,816,896,1056,625,600,601,604,625,4950,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    800,600,85,1048,800,832,896,1048,631,600,601,604,631,5625,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,

    // Settings for 1024x768:
    1024,768,60,1344,1024,1048,1184,1344,806,768,771,777,806,6500,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE,
    1024,768,70,1328,1024,1048,1184,1328,806,768,771,777,806,7500,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE,
    1024,768,75,1312,1024,1040,1136,1312,800,768,769,772,800,7875,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    1024,768,85,1376,1024,1072,1168,1376,808,768,769,772,808,9450,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,

    // Settings for 1152x864:
    1152,864,75,1600,1152,1216,1344,1600,900,864,865,868,900,10800,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,

    // Settings for 1280x960:
    1280,960,60,1800,1280,1376,1488,1800,1000,960,961,964,1000,10800,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    1280,960,85,1728,1280,1344,1504,1728,1011,960,961,964,1011,14850,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,

    // Settings for 1280x1024:
    1280,1024,60,1688,1280,1328,1440,1688,1066,1024,1025,1028,1066,10800,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    1280,1024,75,1688,1280,1296,1440,1688,1066,1024,1025,1028,1066,13500,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    1280,1024,85,1728,1280,1344,1504,1728,1072,1024,1025,1028,1072,15750,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,

    // Settings for 1600x1200:
    1600,1200,60,2160,1600,1664,1856,2160,1250,1200,1201,1204,1250,16200,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    1600,1200,65,2160,1600,1664,1856,2160,1250,1200,1201,1204,1250,17550,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    1600,1200,70,2160,1600,1664,1856,2160,1250,1200,1201,1204,1250,18900,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    1600,1200,75,2160,1600,1664,1856,2160,1250,1200,1201,1204,1250,20250,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    1600,1200,85,2160,1600,1664,1856,2160,1250,1200,1201,1204,1250,22950,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,

    // Settings for 1792x1344:
    1792,1344,60,2448,1792,1920,2120,2448,1394,1344,1345,1348,1394,20475,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1792,1344,75,2456,1792,1888,2104,2456,1417,1344,1345,1348,1417,26100,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    // Settings for 1856x1392:
    1856,1392,60,2528,1856,1952,2176,2528,1439,1392,1393,1396,1439,21825,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1856,1392,75,2560,1856,1984,2208,2560,1500,1392,1393,1396,1500,28800,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    // Settings for 1920x1440:
    1920,1440,60,2600,1920,2048,2256,2600,1500,1440,1441,1444,1500,23400,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1920,1440,75,2640,1920,2064,2288,2640,1500,1440,1441,1444,1500,29700,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    // Flag end of table
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00
};
                   
/*
    Function:   DmtFindMode

    Purpose:    This routine looks for a mode in the DMT list of modes.

    Arguments:  lpModeIn    ptr to MODEINFO structure
                lpModeOut   ptr to MODEOUT  structure

    Returns:    If an DMT mode is found which matches the dwXRes, dwYRes,
                dwBpp, and dwRefreshRate fields in the MODEINFO structure
                pointed to by lpModeIn, then fill in the timing parameters
                in the lpModeOut structure and return TRUE.

                If there is no DMT mode match found, then return FALSE.

    Preserve:   Do not change any fields in lpModeIn.
*/

int CFUNC
DmtFindMode (LPMODEINFO lpModeIn, LPMODEOUT lpModeOut)
{
    int     i;

    i = FindMode(DMTTimingTable, lpModeIn->dwXRes,
                    lpModeIn->dwYRes, lpModeIn->dwRefreshRate);

    // Was the mode found?
    if  (i < 0)
        return  (FALSE);

    // Yes! Convert to final output format
    SetupParamsForVidLutClass (DMTTimingTable + i, lpModeOut, lpModeIn);

    return  (TRUE);
}


/*
    Function:   DmtGetDmtTablePointer

    Purpose:    This routine returns a long pointer to the DMTTimingTable.

    Arguments:  lplpDmtTable    ptr to DMT Table pointer

    Returns:    Pointer to the DMT table.
*/

int CFUNC
DmtGetDmtTablePointer (LPMODESTRUC FAR *lplpDmtTable)
{

    *lplpDmtTable = DMTTimingTable;
    return  (TRUE);
}


/*
    DmtGetMaximumRefreshRate

    This routine calculates the maximum refresh rate for the target mode
    specified given the maimum XRes and YRes, and the maximum horizontal
    and vertical frequencies.

*/
#pragma warning(disable: 4296)

int CFUNC
DmtGetMaximumRefreshRate (ULONG dwXRes, ULONG dwYRes, ULONG dwPixelClk,
                          ULONG *dwRefreshRate)
{
    ULONG   i;

    // Assume at least 60 Hz.
    *dwRefreshRate = 60;

    i = FindModeWithoutRR(DMTTimingTable, dwXRes, dwYRes);

    // Was the mode found?
    if  (i < 0)
        return  (FALSE);

    // Find the mode with the greatest refresh rate which has a pixel
    // clock less than or equal to dwPixelClock.
    for (;DMTTimingTable[i].wHorizVisible != 0x00; i++)
    {
        if ((DMTTimingTable[i].wHorizVisible == (USHORT) dwXRes) &&
            (DMTTimingTable[i].wVertVisible == (USHORT) dwYRes))
        {
            if ((ULONG)DMTTimingTable[i].wDotClock <= dwPixelClk)
                *dwRefreshRate = (ULONG) DMTTimingTable[i].wRefresh;
        }
    }

    return  (TRUE);
}

#pragma warning(default: 4296)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\modeset.mhd\CODE\DMT.H ===
/*
    FILE:   dmt.h
    DATE:   4/8/99

    This file is the dmt find or set mode code.
*/

extern int CFUNC DmtFindMode (LPMODEINFO lpModeIn, LPMODEOUT lpModeOut);

extern int CFUNC DmtGetDmtTablePointer (LPMODESTRUC FAR *lplpDmtTable);

extern int CFUNC DmtGetMaximumRefreshRate (ULONG dwXRes, ULONG dwYRes,
                                           ULONG dwPixelClk,
                                           ULONG *dwRefreshRate);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\modeset.mhd\CODE\GTF.H ===
/*
    FILE:   gtf.h
    DATE:   4/8/99

    This file is the gtf find or set mode code.
*/

extern int CFUNC GtfFindMode (LPMODEINFO lpModeIn, LPMODEOUT lpModeOut);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\modeset.mhd\CODE\EDID.C ===
/*
    FILE:   edid.c
    DATE:   4/8/99

    This file is the generic entry point for the edid modeset code.
*/

#include "cmntypes.h"
#include "modeext.h"
#include "modeset.h"
#include "debug.h"
#include "edid.h"
#include "dmt.h"
#include "gtf.h"
#include "gtfmath.h"
#include "restime.h"
#include "utils.h"

//*****************************************************************************
//
// EDID Established Timings
//
// These are the timings from the VESA Monitor Timing Specification
// (Version 1.0, Revision 0.8) which correspond to the modes in the
// Established Timings block of the EDID.
//
// Horizontal Visible, Vertical Visible
// Refresh (Hz * 100)
// Horizontal Total, Blank Start, Sync Start, Sync End, Blank End
// Vertical Total, Blank Start, Sync Start, Sync End, Blank End
// DotClock (MHz * 100)
// HSync polarity
// VSync polarity
//
// NOTE: GTF Timings dictate no borders, so Blank Start == Visible and
// Blank End == Total.
//

MODESTRUC sZeroMode[] =
{
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

MODESTRUC EDIDEstablishedTimingTbl[] =
{
    // Settings for 1280x1024:
    1280,1024,75, 1688,1280,1296,1440,1688,1066,1024,1025,1028,1066,13500,BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,

    // Settings for 1024x768:
    1024,768,75, 1312,1024,1040,1136,1312,800,768,769,772,800,7875,BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    1024,768,70, 1328,1024,1048,1184,1328,806,768,771,777,806,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE,
    1024,768,60, 1344,1024,1048,1184,1344,806,768,771,777,806,6500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE,

    // Settings for 800x600:
    800,600,75, 1056,800,816,896,1056,625,600,601,604,625,4950,BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    800,600,72, 1040,800,856,976,1040,666,600,637,643,666,5000,BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    800,600,60, 1056,800,840,968,1056,628,600,601,605,628,4000,BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    800,600,56, 1024,800,824,896,1040,625,600,601,603,625,3600,BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,

    // Settings for 640x480:
    640,480,75, 840,640,656,720,840,500,480,481,484,500,3150,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE,
    640,480,72, 832,648,664,704,824,520,488,489,492,512,3150,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE,

    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

MODESTRUC EDIDDetailedTimingTable[9] =
{
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};

MODESTRUC EDIDEstablishedTimingTable[11] =
{
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};

MODESTRUC EDIDStandardTimingTable[9] =
{
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};



/*
    Function:   EdidGetVersion

    Purpose:    Returns EDID version multiplied by 0x100 so 1.10 is 0x110.

    Arguments:  NONE

    Returns:    EDID version multiplied by 100 if one exists.
                FALSE if no valid EDID

    Preserve:
*/
int CFUNC
EdidGetVersion (LPCHAR lpEdidBuffer, ULONG dwEdidSize)
{
    int     nEdidVersion;

    // Edid Version is 1.x if the very first byte is a 0.
    if (lpEdidBuffer[0] == 0x00)
    {
        LPEDIDV1STRUC   lpV1;

        lpV1 = (LPEDIDV1STRUC) lpEdidBuffer;

        // For Version 1.x, first 8 bytes of EDID must be
        // 00h, FFh, FFh, FFh, FFh, FFh, FFh, 00h
        if  ((lpEdidBuffer[1] != 0x0FF) || (lpEdidBuffer[2] != 0x0FF) ||
             (lpEdidBuffer[3] != 0x0FF) || (lpEdidBuffer[4] != 0x0FF) ||
             (lpEdidBuffer[5] != 0x0FF) || (lpEdidBuffer[6] != 0x0FF) ||
             (lpEdidBuffer[7] != 0x000))
        {
            DBG_PRINT0(DL_1, "\r\nBad Edid Version 1.X");
            return  (FALSE);
        }

        nEdidVersion = (int) ((((USHORT) lpV1->bVersionNumber) << 8) +
                       ((USHORT) lpV1->bRevisionNumber));
    }
    else
    {
        if ((lpEdidBuffer[0] & 0xF0) == 0x20)     // Version 2.x?
        {
            nEdidVersion = (int) ((USHORT) lpEdidBuffer[0] << 4);
        }
        else                                    // Invalid Version number
        {
            DBG_PRINT0(DL_1, "\r\nBad Edid Version 2.X");
            return  (FALSE);
        }
    }

    DBG_PRINT1(DL_1, "\r\nEdid Version %x", nEdidVersion);
    return (nEdidVersion);
}


/*
    Function:   EdidFindNumTimingCodes

    Purpose:    Finds the number of luminance tables, size of luminance
                table, number of frequency ranges, number of detailed
                range limits, number of timing codes, and number of
                detailed timings. This is only valid for Version 2.x
                EDIDs.

    Arguments:  lpEdidBuffer    EDID data
                dwEdidSize      length of EDID
                lpTC            Ptr to array for Timing Code return values.

    Returns:    TRUE    timing codes were located and lpTC was fiiled in
                FALSE   no timing codes were found

    Preserve:
*/

int CFUNC
EdidFindNumTimingCodes (
    LPCHAR          lpEdidBuffer,
    ULONG           dwEdidSize,
    LPTIMINGCODES   lpTC)
{
    ULONG           dwInfo;
    USHORT          wLuminanceInfo;
    LPEDIDV2STRUC   lpV2 = (LPEDIDV2STRUC) lpEdidBuffer;

    dwInfo = (ULONG) lpV2->wTimingInfoMap;

    // Calculate Luminance Table. There is one table if bit 5 is set.
    if (dwInfo & 0x20)
    {
        lpTC->dwNumLuminanceTables = 1;

        // Let n = EdidBuffer[0x80] bits [4:0]
        // if EdidBuffer[0x80] bit 7 = 0
        //    then the size of the luminance table is n + 1
        // if EdidBuffer[0x80] bit 7 = 1
        //    then the size of the luminance table is 3n + 1
        wLuminanceInfo = (USHORT) lpV2->bTableDescriptors[0];
        if (wLuminanceInfo & 0x80)
            lpTC->dwSizeLuminanceTables =
                        (ULONG) (3 * (wLuminanceInfo & 0x1F) + 1);
        else
            lpTC->dwSizeLuminanceTables = (ULONG) (wLuminanceInfo + 1);
    }
    else
    {
        lpTC->dwNumLuminanceTables  = 0;
        lpTC->dwSizeLuminanceTables = 0;
    }

    lpTC->dwNumFreqRanges      = (dwInfo  >> 2) & 7;
    lpTC->dwNumRangeLimits     = dwInfo & 0x03;
    lpTC->dwNumTimingCodes     = (dwInfo >> (8 + 3)) & 0x1F;
    lpTC->dwNumDetailedTimings = (dwInfo >> 8) & 0x07;

    return  (TRUE);
}


/*
    Function:   EdidGetMonitorLimits

    Purpose:    Find the limits of operation by searching for a Monitor
                Descriptor Block with a Data Tag of FDh (Monitor Range
                Limits).

    Arguments:  EdidVersion     Version of EDID block.
                MonitorLimits   Ptr to array of monitor limits.

    Returns:    TRUE    Monitor Limits
                FALSE   No Monitor Limits

    Preserve:
*/

int CFUNC
EdidGetMonitorLimits (
    LPCHAR          lpEdidBuffer,
    ULONG           dwEdidSize,
    LPMONITORLIMITS lpML)
{
    int             i;
    int             nEdidVersion;
    TIMINGCODES     TimingCodes;
    ULONG           dwMinFrame, dwMaxFrame;
    ULONG           dwMinLine, dwMaxLine;
    ULONG           dwMinClock, dwMaxClock;

    nEdidVersion = EdidGetVersion (lpEdidBuffer, dwEdidSize);

    // If we couldn't figure out what version it was, then say that
    // there are no monitor range limits.
    if  (!nEdidVersion)
        return  (FALSE);

    if  (nEdidVersion < 0x200)
    {
        LPEDIDV1STRUC       lpV1 = (LPEDIDV1STRUC) lpEdidBuffer;
        LPMONITORDESCRITOR  lpMD = (LPMONITORDESCRITOR) lpV1->DetailedTimingDesc;

        // Start all the mins high and the maxs low, so they
        // will get changed when we find something more restrictive.
        lpML->dwMinHorz = 0x00;
        lpML->dwMaxHorz = 0x0FFFFFFFF;
        lpML->dwMinVert = 0x00;
        lpML->dwMaxVert = 0x0FFFFFFFF;

        // Start out with the maximum pixel clock being the largest
        // pixel clock found in all EDID timings.
        lpML->dwMaxPixelClock = EdidFindLargestPixelClock (lpEdidBuffer, dwEdidSize);
        lpML->dwMaxPixelClock = Multiply32By32 (lpML->dwMaxPixelClock, 10000);

        // There are 4 detailed timing descriptors in a version 1.X edid.
        // The detailed timing descriptor blocks do double duty as a
        // monitor range descriptor block when the first three bytes are 0,
        // and the fourth byte is FDh.
        for (i = 0; i < 4; i++, lpMD++)
        {
           // For Monitor Descriptor, the first 3 bytes must all be zero
           // and the monitor descriptor type must be a range limit.
           if   ((lpMD->wZeroFlag == 0) && (lpMD->bZeroFlag == 0) &&
                 (lpMD->bTypeDescriptorBlock == DT_MONITOR_RANGE_LIMITS))
           {
                dwMinLine  = Multiply32By32 (lpMD->bMinHorzRateInKHz, 1000);
                dwMaxLine  = Multiply32By32 (lpMD->bMaxHorzRateInKHz, 1000);
                dwMinFrame = (ULONG) lpMD->bMinVertRateInHz;
                dwMaxFrame = (ULONG) lpMD->bMaxVertRateInHz;

                // Now do an intersection
                if  (dwMinFrame > lpML->dwMinVert)
                    lpML->dwMinVert = dwMinFrame;

                if  (dwMaxFrame < lpML->dwMaxVert)
                    lpML->dwMaxVert = dwMaxFrame;

                if  (dwMinLine > lpML->dwMinHorz)
                    lpML->dwMinHorz = dwMinLine;

                if  (dwMaxLine < lpML->dwMaxHorz)
                    lpML->dwMaxHorz = dwMaxLine;

                // If the bMaxPixelClockInCKHz in the EDID range limits is
                // 0xFF, then the pixel clock is not specified.
                if (lpMD->bMaxPixelClockInCKHz != 0xFF)
                {
                    dwMaxClock = Multiply32By32 (lpMD->bMaxPixelClockInCKHz, 10000000);
                    if  (dwMaxClock > lpML->dwMaxPixelClock)
                        lpML->dwMaxPixelClock = dwMaxClock;
                }
                else
                {
                    MODEINFO    sMI;

                    // Find a pixel clock using largest mode from EDID. 
                    // GetMaximumRefreshRate fills out lpML->dwMaxPixelClock.
                    // 640 and 480 are being used for dwTargetXRes and
                    // dwTargetYRes respectively, but these parameters are
                    // irrelevant because we just want the pixel clock and
                    // not the refresh rate. Be sure to zero out
                    // lpML->dwMaxPixelClock, or GetMaximumRefreshRate will
                    // not a calculate a pixel clock.
                    sMI.dwRefreshRate = 0;
                    EdidFindLargestEdidMode (lpEdidBuffer, dwEdidSize, &sMI);

                    lpML->dwMaxPixelClock = 0;
                    GetMaximumRefreshRate (sMI.dwXRes, sMI.dwYRes,
                                           sMI.dwRefreshRate, lpML, 640, 480);

                }
            }
        }

        // If we didn't find any reasonable values, then outta here
        if  ((lpML->dwMinVert == 0x00) ||
             (lpML->dwMaxVert == 0x0FFFFFFFF))
        {
            return  (FALSE);
        }

        return  (TRUE);
    }


    if  (nEdidVersion >= 0x200)
    {
        LPEDIDV2STRUC           lpV2 = (LPEDIDV2STRUC) lpEdidBuffer;
        LPDISPLAYTIMINGRANGE    lpTR;
        LPDETAILEDTIMINGRANGE   lpDT;
        ULONG                   dwExtra;
        ULONG                   dwClockExtra;
        ULONG                   dwLargestHBlank, dwLargestVBlank;
        ULONG                   dwLargestHTotal, dwLargestVTotal;
        ULONG                   dwSmallestHBlank, dwSmallestVBlank;
        ULONG                   dwSmallestHTotal, dwSmallestVTotal;
        ULONG                   j, k;
        LPCHAR                  lpC;
        int                     nSum;

        EdidFindNumTimingCodes (lpEdidBuffer, dwEdidSize, &TimingCodes);

        // If there were no monitor range limits, then outta here
        if  ((TimingCodes.dwNumFreqRanges == 0) &&
             (TimingCodes.dwNumRangeLimits == 0))
            return  (FALSE);

        // There are two types of monitor range limits in a
        // version 2.XX EDID. The first is a simple min/max
        // horz frequemcy, min/max vertical frequency, and
        // min/max pixel clock. The second includes this
        // and also specifies min/max values for sync offsets,
        // sync pulse widths, blanking, image size, borders
        // interlaced/non-interlaced, and sync polarities.
        // In any case, what we want to do is return a
        // MONITORLIMITS structure that is the intersection
        // of any and all these. The point is that we assume
        // that all of them apply and hence we want to restrict
        // by every one of them. NOTE that MONITORLIMITS
        // doesn't deal with all the blanking, sync pulses,
        // etc in the more detailed type of range limit struct
        // in the EDID, so we will ignore that for now. All
        // we care about are the min and max for each of
        // pixel clock, horz freq and vert freq.

        // In version 2.XX of the EDID, there is a section which
        // can contain 5 different types of objects. The first,
        // if it exists, are luminance tables which we just skip over.

        i = (int) (TimingCodes.dwNumLuminanceTables *
                 TimingCodes.dwSizeLuminanceTables);

        // Start all the mins high and the maxs low, so they
        // will get changed when we find something more restrictive.
        lpML->dwMinHorz = 0x00;
        lpML->dwMaxHorz = 0x0FFFFFFFF;
        lpML->dwMinVert = 0x00;
        lpML->dwMaxVert = 0x0FFFFFFFF;
        lpML->dwMaxPixelClock = 0x0FFFFFFFF;

        // The next is the simple range limit structures
        // There can be more than one.
        for (j = 0; j < TimingCodes.dwNumFreqRanges; j++)
        {
            lpTR = (LPDISPLAYTIMINGRANGE) &(lpV2->bTableDescriptors[i]);
            lpC  = (LPCHAR) lpTR;

            // Be careful here. For fixed frequency devices, all these
            // fields are set to 0.
            for (nSum = 0, k = 0; k < 8; k++)
                nSum += (int) lpC[k];

            if  (nSum != 0)
            {
                dwExtra    = ((ULONG) lpTR->bLoHV);
                dwMinFrame = (((ULONG) lpTR->bHiMinVert) << 2) + ((dwExtra >> 6) & 0x03);
                dwMaxFrame = (((ULONG) lpTR->bHiMaxVert) << 2) + ((dwExtra >> 4) & 0x03);
                dwMinLine  = (((ULONG) lpTR->bHiMinHorz) << 2) + ((dwExtra >> 2) & 0x03);
                dwMinLine  = Multiply32By32 (dwMinLine, 1000);
                dwMaxLine  = (((ULONG) lpTR->bHiMaxHorz) << 2) + ((dwExtra >> 0) & 0x03);
                dwMaxLine  = Multiply32By32 (dwMaxLine, 1000);

                dwClockExtra = ((ULONG) lpTR->bHiMinMaxPixClock);
                dwMaxClock   = ((ULONG) lpTR->bLoMaxPixClock) + ((dwClockExtra & 0x0F) << 8);
                dwMaxClock   = Multiply32By32 (dwMaxClock, 1000000);

                // Now do an intersection
                if  (dwMinFrame > lpML->dwMinVert)
                    lpML->dwMinVert = dwMinFrame;

                if  (dwMaxFrame < lpML->dwMaxVert)
                    lpML->dwMaxVert = dwMaxFrame;

                if  (dwMinLine > lpML->dwMinHorz)
                    lpML->dwMinHorz = dwMinLine;

                if  (dwMaxLine < lpML->dwMaxHorz)
                    lpML->dwMaxHorz = dwMaxLine;

                if  (dwMaxClock < lpML->dwMaxPixelClock)
                    lpML->dwMaxPixelClock = dwMaxClock;
            }

            i += sizeof(DISPLAYTIMINGRANGE);
        }

        // Now, handle any of the more complicated monitor limit structs.
        for (j = 0; j < TimingCodes.dwNumRangeLimits; j++)
        {
            lpDT = (LPDETAILEDTIMINGRANGE) &(lpV2->bTableDescriptors[i]);

            dwMinClock = ((ULONG) lpDT->wMinPixelClock) * 10000;
            dwMaxClock = ((ULONG) lpDT->wMaxPixelClock) * 10000;

            // The highest vertical frequency is obtained by using
            // dividing the maximum pixel clock by the smallest
            // total pixel count.
            dwSmallestHBlank = ((ULONG) lpDT->bLowMinHBlank) +
                                ((((ULONG) lpDT->bHiMinHVBlank) & 0xF0) << 4);
            dwSmallestVBlank = ((ULONG) lpDT->bLowMinVBlank) +
                                ((((ULONG) lpDT->bHiMinHVBlank) & 0x0F) << 8);
            dwSmallestHTotal = dwSmallestHBlank + ((ULONG) lpDT->bLowHActive)
                                + ((((ULONG) lpDT->bHiHVActive) & 0xF0) << 4);
            dwSmallestVTotal = dwSmallestVBlank + ((ULONG) lpDT->bLowVActive)
                                + ((((ULONG) lpDT->bHiHVActive) & 0x0F) << 8);
            dwMaxFrame = dwMaxClock / (dwSmallestVTotal * dwSmallestHTotal);
            dwMaxLine  = dwMaxClock / dwSmallestHTotal;

            dwLargestHBlank = ((ULONG) lpDT->bLowMaxHBlank) +
                                ((((ULONG) lpDT->bHiMaxHVBlank) & 0xF0) << 4);
            dwLargestVBlank = ((ULONG) lpDT->bLowMaxVBlank) +
                                ((((ULONG) lpDT->bHiMaxHVBlank) & 0x0F) << 8);
            dwLargestHTotal = dwLargestHBlank + ((ULONG) lpDT->bLowHActive)
                                + ((((ULONG) lpDT->bHiHVActive) & 0xF0) << 4);
            dwLargestVTotal = dwLargestVBlank + ((ULONG) lpDT->bLowVActive)
                                + ((((ULONG) lpDT->bHiHVActive) & 0x0F) << 8);
            dwMinFrame = dwMinClock / (dwLargestVTotal * dwLargestHTotal);
            dwMinLine  = dwMinClock / dwLargestHTotal;

            // Now do an intersection
            if  (dwMinFrame > lpML->dwMinVert)
                lpML->dwMinVert = dwMinFrame;

            if  (dwMaxFrame < lpML->dwMaxVert)
                lpML->dwMaxVert = dwMaxFrame;

            if  (dwMinLine > lpML->dwMinHorz)
                lpML->dwMinHorz = dwMinLine;

            if  (dwMaxLine < lpML->dwMaxHorz)
                lpML->dwMaxHorz = dwMaxLine;

            if  (dwMaxClock < lpML->dwMaxPixelClock)
            {
                // Add about 5% to their max pixel clock because
                // if this is a fixed freq timing, will never match
                // it exactly.
                lpML->dwMaxPixelClock = (dwMaxClock * 21) / 20;
            }

            i += sizeof(DETAILEDTIMINGRANGE);
        }

        // If we didn't find any reasonable values, then outta here
        if  ((lpML->dwMinVert == 0x00) ||
             (lpML->dwMaxVert == 0x0FFFFFFFF))
        {
            return  (FALSE);
        }

        return  (TRUE);
    }

    return (FALSE);
}



/*
    Function:   EdidIsGtfMonitor

    Purpose:    Checks EDID block to see if display type supports GTF.

    Arguments:  lpEdidBuffer    The EDID
                dwEdidSize      EDID size in bytes

    Returns:    TRUE            Display type supports GTF.
                FALSE           Display type does not support GTF.

    Preserve:
*/

int CFUNC
EdidIsGtfMonitor (LPCHAR lpEdidBuffer, ULONG dwEdidSize)
{
    int             nEdidVersion;
    MONITORLIMITS   sML;

    // Get the EDID version
    nEdidVersion = EdidGetVersion (lpEdidBuffer, dwEdidSize);

    // If we couldn't figure out what version it was, then say that
    // the monitor is not GTF.
    if  (!nEdidVersion)
        return  (FALSE);

    if  (nEdidVersion < 0x200)
    {
        LPEDIDV1STRUC lpV1 = (LPEDIDV1STRUC) lpEdidBuffer;

        // Edid version 1.X check for GTF monitor
        if  (lpV1->bFeatureSupport & 0x01)
            return  (TRUE);

        return (FALSE);
    }

    if (nEdidVersion >= 0x200)
    {
        LPEDIDV2STRUC lpV2 = (LPEDIDV2STRUC) lpEdidBuffer;

        // Edid version 2.X check for GTF monitor
        if  (lpV2->bGTFSupportInfo & 0xF0)
        {
            // The GTF monitor bits are set! But the spec also
            // says that the monitor is not truly GTF compliant
            // unless there is also a MONITORLIMITS descriptor
            if  (EdidGetMonitorLimits(lpEdidBuffer, dwEdidSize, &sML))
            {
                return  (TRUE);
            }
        }

        return (FALSE);
    }

    return  (FALSE);
}



/*
    Function:   EdidGetMonitorId

    Purpose:    This returns the monitorID from the EDID. The monitor
                ID is defined as a DWORD from high byte to low byte
                as follows:
                high byte of product code, low byte of product code, high
                byte of manufacturer code, low byte of manufacturer code.

                If there is any kind of error then return UKWN_ID which
                is defined in restime.h  It means any monitor for which
                an EDID is not defined. Since you can't parse the EDID
                for some reason, this is a reasonable return value.

    Arguments:  lpEdidBuffer    The EDID
                dwEdidSize      EDID size in bytes

    Returns:    TRUE            Display type supports GTF.
                FALSE           Display type does not support GTF.

    Preserve:
*/

ULONG CFUNC
EdidGetMonitorId (LPCHAR lpEdidBuffer, ULONG dwEdidSize)
{
    int     nEdidVersion;
    ULONG   dwMonitorID;

    // Get the EDID version
    nEdidVersion = EdidGetVersion (lpEdidBuffer, dwEdidSize);

    // If we couldn't figure out what version it was, then say that
    // the monitor is not GTF.
    if  (!nEdidVersion)
        return  (UKWN_ID);

    if  (nEdidVersion < 0x200)
    {
        LPEDIDV1STRUC lpV1 = (LPEDIDV1STRUC) lpEdidBuffer;

        dwMonitorID = (((ULONG) lpV1->wIDProductCode) << 16) |
                      ((ULONG) lpV1->wIDManufName);

        return  (dwMonitorID);
    }

    if (nEdidVersion >= 0x200)
    {
        LPEDIDV2STRUC lpV2 = (LPEDIDV2STRUC) lpEdidBuffer;

        dwMonitorID = (((ULONG) lpV2->wIDProductCode) << 16) |
                      ((ULONG) lpV2->wIDManufName);

        return  (dwMonitorID);
    }

    return  (UKWN_ID);
}



/*
    Function:   EdidBuildStandardTimingTable

    Purpose:    Using the Standard Timings field of the EDID block,
                create a table for the standard timings. NOTE: This
                procedure is only valid for Version 1.x EDID structures
                and the timings associated with these modes are assumed
                to be GTF timings.

    Arguments:  NONE

    Returns:    Nothing but copies supported modes to EDIDStandardTimingTable.

    Preserve:
*/

int CFUNC
EdidBuildStandardTimingTable (LPCHAR lpEdidBuffer, ULONG dwEdidSize)
{
    USHORT          wHorizontalRes;
    USHORT          wVerticalRes;
    USHORT          wRefreshRate;
    int             i, j, nIndex;
    int             FoundMode;
    int             nEdidVersion;
    GTFIN           GTFIn;
    GTFOUT          GTFOut;
    MODESTRUC       sGTF;
    LPMODESTRUC     lpDmtTable;
    LPEDIDV1STRUC   lpV1;

    lpV1 = (LPEDIDV1STRUC) lpEdidBuffer;

    // First, zero out all entries
    for (i = 0; i < 8; i++)
        EDIDStandardTimingTable[i] = sZeroMode[0];

    nEdidVersion = EdidGetVersion (lpEdidBuffer, dwEdidSize);

    // Please note that Standard timings are only valid on Version 1.x
    // EDIDs. Zeroing out the table above provides protection for
    // Version 2.x EDIDs.
    if  (nEdidVersion < 0x200)
    {
        for (nIndex = 0, i = 0; i < 8; i++)
        {
            wHorizontalRes = lpV1->wStandardTimingID[i] & 0x0FF;
            if  (wHorizontalRes != 0x01)                // Unused fields = 01
            {
                // The value in the EDID = (Horizontal active pixels/8) - 31
                wHorizontalRes += 31;
                wHorizontalRes <<= 3;
                wVerticalRes = lpV1->wStandardTimingID[i] >> 8;
                wRefreshRate = (wVerticalRes & 0x1F) + 60;

                switch (wVerticalRes & 0xC0)         // Aspect Ratio in 7:6
                {
                    case    0x00:
                        wVerticalRes = wHorizontalRes;          // 1:1
                        break;
                    case    0x40:
                        wVerticalRes = wHorizontalRes * 3 / 4;  // 4:3
                        break;
                    case    0x80:
                        wVerticalRes = wHorizontalRes * 4 / 5;  // 5:4
                        break;
                    case    0xC0:
                        wVerticalRes = wHorizontalRes * 9 / 16; // 16:9
                        break;
                }

                FoundMode = FALSE;

                // If monitor is not GTF, try DMT timings first.
                if (!EdidIsGtfMonitor (lpEdidBuffer, dwEdidSize))
                {
                    //First try to find matching DMT mode.
                    DmtGetDmtTablePointer (&lpDmtTable);

                    j = FindMode(lpDmtTable, (ULONG) wHorizontalRes,
                                    (ULONG) wVerticalRes, (ULONG) wRefreshRate);

                    // If a DMT mode was found.
                    if  (j >= 0)
                    {
                        sGTF.wHorizVisible    = lpDmtTable[j].wHorizVisible;
                        sGTF.wVertVisible     = lpDmtTable[j].wVertVisible;
                        sGTF.wRefresh         = lpDmtTable[j].wRefresh;
                        sGTF.wHorizTotal      = lpDmtTable[j].wHorizTotal;
                        sGTF.wHorizBlankStart = lpDmtTable[j].wHorizBlankStart;
                        sGTF.wHorizSyncStart  = lpDmtTable[j].wHorizSyncStart;
                        sGTF.wHorizSyncEnd    = lpDmtTable[j].wHorizSyncEnd;
                        sGTF.wHorizBlankEnd   = lpDmtTable[j].wHorizBlankEnd;
                        sGTF.wVertTotal       = lpDmtTable[j].wVertTotal;
                        sGTF.wVertBlankStart  = lpDmtTable[j].wVertBlankStart;
                        sGTF.wVertSyncStart   = lpDmtTable[j].wVertSyncStart;
                        sGTF.wVertSyncEnd     = lpDmtTable[j].wVertSyncEnd;
                        sGTF.wVertBlankEnd    = lpDmtTable[j].wVertBlankEnd;
                        sGTF.wDotClock        = lpDmtTable[j].wDotClock;
                        sGTF.wHSyncPolarity   = lpDmtTable[j].wHSyncPolarity;
                        sGTF.wVSyncPolarity   = lpDmtTable[j].wVSyncPolarity;

                        FoundMode = TRUE;
                    }

                }

                // No DMT mode was found--use GTF.
                if (!FoundMode)
                {
                    // Get GTF timings for mode.
                    GTFIn.dwHPixels      = (ULONG) wHorizontalRes;
                    GTFIn.dwVLines       = (ULONG) wVerticalRes;
                    GTFIn.dwMarginsRqd   = FALSE;
                    GTFIn.dwIntRqd       = FALSE;
                    GTFIn.dwIPParmType   = IPTYPE_VERTICAL_REFRESH_RATE;
                    GTFIn.dwIPFreqRqd    = (ULONG) wRefreshRate;
                    ComputeGTFParameters(&GTFIn, &GTFOut);

                    // Store all parameters in temporary MODESTRUC buffer. Note that
                    // horizontal GTF parameters are returned in character clocks and
                    // need to be converted to pixels.
                    sGTF.wHorizVisible    = (USHORT) (GTFOut.dwHActiveChars << 3);
                    sGTF.wVertVisible     = (USHORT) GTFOut.dwVActiveScans;
                    sGTF.wRefresh         = (USHORT) wRefreshRate;
                    sGTF.wHorizTotal      = (USHORT) (GTFOut.dwHTotalChars << 3);
                    sGTF.wHorizBlankStart = (USHORT) (GTFOut.dwHBlankStartChar << 3);
                    sGTF.wHorizSyncStart  = (USHORT) ((GTFOut.dwHBlankStartChar
                                                     + GTFOut.dwHFrontPorchChars) << 3);
                    sGTF.wHorizSyncEnd    = (USHORT) (sGTF.wHorizSyncStart
                                                     + (GTFOut.dwHSyncChars << 3));
                    sGTF.wHorizBlankEnd   = (USHORT) (GTFOut.dwHBlankEndChar << 3);
                    sGTF.wVertTotal       = (USHORT) GTFOut.dwVTotalScans;
                    sGTF.wVertBlankStart  = (USHORT) GTFOut.dwVBlankStartScan;
                    sGTF.wVertSyncStart   = (USHORT) (GTFOut.dwVBlankStartScan
                                                     + GTFOut.dwVFrontPorchScans);
                    sGTF.wVertSyncEnd     = (USHORT) (sGTF.wVertSyncStart
                                                     + GTFOut.dwVSyncScans);
                    sGTF.wVertBlankEnd    = (USHORT) GTFOut.dwVBlankEndScan;
                    sGTF.wDotClock        = (USHORT) GTFOut.dwPixelClockIn10KHertz;
                    sGTF.wHSyncPolarity   = BUFFER_HSYNC_NEGATIVE;
                    sGTF.wVSyncPolarity   = BUFFER_VSYNC_POSITIVE;


                }

                EDIDStandardTimingTable[nIndex++] = sGTF;
            }
        }
    }


    return  (TRUE);
}


/*
    Function:   EdidFindStandardMode

    Purpose:    This routine finds if the mode exists in the EDID
                standard mode table.

    Arguments:  lpEdidBuffer    EDID
                dwEdidSize      size of EDID buffer
                lpModeDesc      mode to match
                lpModeOut       ptr to MODEOUT structure
                                put timing argumetns here if there is
                                a match on the input mode

    Returns:    TRUE if there was a match and lpModeOut was filled
                FALSE if there was no match

    Preserve:   Do not change any fields in lpModeDesc.
*/
int CFUNC
EdidFindStandardMode (
        LPCHAR      lpEdidBuffer,
        ULONG       dwEdidSize,
        LPMODEINFO  lpModeDesc,
        LPMODEOUT   lpModeOut)
{
    int i, nEdidVersion;

    // First, zero out all entries
    for (i = 0; i < 8; i++)
        EDIDStandardTimingTable[i] = sZeroMode[0];

    nEdidVersion = EdidGetVersion (lpEdidBuffer, dwEdidSize);

    // Please note that Standard timings are only valid on Version 1.x
    // EDIDs. Zeroing out the table above provides protection for
    // Version 2.x EDIDs.
    if  (nEdidVersion < 0x200)
    {
        EdidBuildStandardTimingTable (lpEdidBuffer, dwEdidSize);
    }

    i = FindMode (EDIDStandardTimingTable, lpModeDesc->dwXRes,
                    lpModeDesc->dwYRes, lpModeDesc->dwRefreshRate);

    if  (i < 0)
        return  (FALSE);

    SetupParamsForVidLutClass (EDIDStandardTimingTable + i, lpModeOut,
                               lpModeDesc);

    return  (TRUE);
}


/*
    Function:   EdidBuildEstablishedTimingTable

    Purpose:    Using the Established Timings field of the EDID block,
                create a table for the established timings. NOTE: This
                procedure is only valid for Version 1.x EDID structures.

    Arguments:  NONE

    Returns:    Nothing but copies supported modes from
                EDIDEstablishedTimingTable to EDIDEstablishedTimingTbl.

    Preserve:
*/

int CFUNC
EdidBuildEstablishedTimingTable (LPCHAR lpEdidBuffer, ULONG dwEdidSize)
{
    ULONG           dwTimingBits, dwT1, dwT2;
    int             i, nIndex;
    int             nEdidVersion;
    LPEDIDV1STRUC   lpV1;

    // Only use VESA Established timings and put them in contiguous
    // order from highest resolution to lowest resolution so they will
    // match the order of EDIDEstablishedTimingTable[].
    lpV1 = (LPEDIDV1STRUC) lpEdidBuffer;

    dwT1 = (ULONG) (lpV1->bEstablishedTimings1);
    dwT2 = (ULONG) (lpV1->bEstablishedTimings2);
    dwTimingBits  =  (dwT2 & 0x0F) + ((dwT2 & 0xC0) >> 2);
    dwTimingBits  |= ((dwT1 & 0x0F) << 6);

    // First, zero out all entries
    for (i = 0; i < 10; i++)
        EDIDEstablishedTimingTable[i] = sZeroMode[0];

    nEdidVersion = EdidGetVersion (lpEdidBuffer, dwEdidSize);

    // Please note that Standard timings are only valid on Version 1.x
    // EDIDs. Zeroing out the table above provides protection for
    // Version 2.x EDIDs.
    if  (nEdidVersion < 0x200)
    {
        for (nIndex = 0, i = 9; i >= 0; i--)
        {
            if (dwTimingBits & (1 << i))    // is this mode supported?
            {
                EDIDEstablishedTimingTable[nIndex++] = EDIDEstablishedTimingTbl[i];
            }
        }
    }

    return  (TRUE);
}


/*
    Function:   EdidFindEstablishedMode

    Purpose:    This routine finds if the mode exists in the EDID
                established mode table.

    Arguments:  lpEdidBuffer    EDID
                dwEdidSize      size of EDID buffer
                lpModeDesc      mode to match
                lpModeOut       ptr to MODEOUT structure
                                put timing argumetns here if there is
                                a match on the input mode

    Returns:    TRUE if there was a match and lpModeOut was filled
                FALSE if there was no match

    Preserve:   Do not change any fields in lpModeDesc.
*/
int CFUNC
EdidFindEstablishedMode (
        LPCHAR      lpEdidBuffer,
        ULONG       dwEdidSize,
        LPMODEINFO  lpModeDesc,
        LPMODEOUT   lpModeOut)
{
    int i, nEdidVersion;

    // First, zero out all entries
    for (i = 0; i < 10; i++)
        EDIDEstablishedTimingTable[i] = sZeroMode[0];

    nEdidVersion = EdidGetVersion (lpEdidBuffer, dwEdidSize);

    // Please note that Established timings are only valid on Version 1.x
    // EDIDs. Zeroing out the table above provides protection for
    // Version 2.x EDIDs.
    if  (nEdidVersion < 0x200)
    {
        EdidBuildEstablishedTimingTable (lpEdidBuffer, dwEdidSize);
    }

    i = FindMode (EDIDEstablishedTimingTable, lpModeDesc->dwXRes,
                    lpModeDesc->dwYRes, lpModeDesc->dwRefreshRate);

    if  (i < 0)
        return  (FALSE);

    SetupParamsForVidLutClass (EDIDEstablishedTimingTable + i, lpModeOut,
                               lpModeDesc);

    return  (TRUE);
}



/*
    Function:   EdidBuildDetailedTimingTable

    Purpose:    Using the Detailed Timing section of the EDID block,
                create a table for the detailed timings.

    Arguments:  EdidVersion     Version of EDID block.

    Returns:    Nothing but copies detailed timing modes to
                EDIDDetailedTimingTable.

    Preserve:
*/

int CFUNC
EdidBuildDetailedTimingTable(LPCHAR lpEdidBuffer, ULONG dwEdidSize)
{
    int         nEdidVersion;
    ULONG       dwNumTimings;
    ULONG       dwOffset;
    ULONG       i, j;
    ULONG       dwPixelClock;
    ULONG       dwHorizVertTotal;
    MODESTRUC   sTS;
    LPDETAILEDTIMINGDESCRIPTOR  lpDTD;
    LPEDIDV1STRUC   lpV1;
    TIMINGCODES     tc;
    LPCHAR          lpB;

    // First, zero out all entries in the detailed timing table
    for (i = 0; i < 10; i++)
        EDIDDetailedTimingTable[i] = sZeroMode[0];

    // Get the version
    nEdidVersion = EdidGetVersion (lpEdidBuffer, dwEdidSize);

    if  (nEdidVersion < 0x200)
    {
        // Version 1.x
        lpV1 = (LPEDIDV1STRUC) lpEdidBuffer;

        // In version 1.XX, the detailed timings are at a fixed offset
        dwOffset = (ULONG)((LPCHAR) &(lpV1->DetailedTimingDesc[0]) - (LPCHAR) lpV1);

        // With version 1.XX of the EDID, there are 4 detailed timing
        // descriptor slots. Any or all of them can be used. Unused
        // ones are marked with a 0 in the first three bytes.
        dwNumTimings = 4;
    }
    else
    {
        // Version 2.XX of the EDID
        EdidFindNumTimingCodes (lpEdidBuffer, dwEdidSize, &tc);

        // In version 2.XX, the detailed timings are in a section of
        // the EDID which holds many items that are not required.
        // Hence, it is necessary to compute the offset based upon
        // which of the optional items is present. These items begin
        // at offset 80h in the EDID.
        dwOffset = (tc.dwNumLuminanceTables * tc.dwSizeLuminanceTables +
                   tc.dwNumFreqRanges * 8 + tc.dwNumRangeLimits * 27 +
                   tc.dwNumTimingCodes * 4) + 0x80;

        // With version 2.XX of the EDID, there are a variable number
        // of detailed timing descriptor slots. All of them are used.
        // There needn't be any checking for leading zeros.
        dwNumTimings = tc.dwNumDetailedTimings;
    }

    for (j = 0, i = 0; i < dwNumTimings; i++)
    {
        lpDTD = (LPDETAILEDTIMINGDESCRIPTOR) &(lpEdidBuffer[dwOffset]);
        lpB = (LPCHAR) lpDTD;

        // Although technically we should only do the "three leading zeros"
        // check for version 1 of the EDID, if the first three bytes of a
        // detailed timing are zeros, then we should probably ignore the
        // timing for version 2.XX of the EDID since the first two bytes
        // are the pixel clock!
        if  ((lpB[0]) || (lpB[1]) || (lpB[2]))
        {
            sTS.wHorizVisible    = (USHORT) (lpDTD->bDTHorizontalActive
                                    + ((lpDTD->bDTHorizActiveBlank & 0xF0) << 4));
            sTS.wVertVisible     = (USHORT)(lpDTD->bDTVerticalActive
                                    + ((lpDTD->bDTVertActiveBlank & 0xF0) << 4));
            sTS.wHorizTotal      = sTS.wHorizVisible
                                    + (USHORT)(lpDTD->bDTHorizontalBlanking
                                    + ((lpDTD->bDTHorizActiveBlank & 0x0F) << 8));
            sTS.wHorizBlankStart = sTS.wHorizVisible;
            sTS.wHorizSyncStart  = sTS.wHorizBlankStart
                                    + (USHORT)(lpDTD->bDTHorizontalSync
                                    + ((lpDTD->bDTHorizVertSyncOverFlow & 0xC0) << 2));
            sTS.wHorizSyncEnd    = sTS.wHorizSyncStart
                                    + (USHORT)(lpDTD->bDTHorizontalSyncWidth
                                    + ((lpDTD->bDTHorizVertSyncOverFlow & 0x30) << 4));
            sTS.wHorizBlankEnd   = sTS.wHorizTotal;
            sTS.wVertTotal       = sTS.wVertVisible
                                    + (USHORT)(lpDTD->bDTVerticalBlanking
                                    + ((lpDTD->bDTVertActiveBlank & 0x0F) << 8));
            sTS.wVertBlankStart  = sTS.wVertVisible;
            sTS.wVertSyncStart   = sTS.wVertBlankStart
                                    + (USHORT)(((lpDTD->bDTVerticalSync & 0xF0) >> 4)
                                    + ((lpDTD->bDTHorizVertSyncOverFlow & 0x0C) << 2));
            sTS.wVertSyncEnd     = sTS.wVertSyncStart
                                    + (USHORT)((lpDTD->bDTVerticalSync & 0x0F)
                                    + ((lpDTD->bDTHorizVertSyncOverFlow & 0x03) << 4));
            sTS.wVertBlankEnd    = sTS.wVertTotal;
            sTS.wDotClock        = lpDTD->wDTPixelClock;

            if ((lpDTD->bDTFlags & 0x18) == 0x18)
            {
                sTS.wHSyncPolarity  = (lpDTD->bDTFlags & 0x2) >> 1;
                sTS.wVSyncPolarity  = (lpDTD->bDTFlags & 0x4) >> 2;
            }
            else if ((lpDTD->bDTFlags & 0x18) == 0x10)
            {
                sTS.wHSyncPolarity  = (lpDTD->bDTFlags & 0x2) >> 1;
                sTS.wVSyncPolarity  = BUFFER_VSYNC_POSITIVE;
            }
            else
            {
                sTS.wHSyncPolarity  = BUFFER_HSYNC_NEGATIVE;
                sTS.wVSyncPolarity  = BUFFER_VSYNC_POSITIVE;
            }

            dwPixelClock = Multiply32By32 (lpDTD->wDTPixelClock, 10000);
            dwHorizVertTotal = Multiply32By32 (sTS.wHorizTotal, sTS.wVertTotal);
            sTS.wRefresh = (USHORT) Divide32By32 (dwPixelClock +
                                    dwHorizVertTotal / 2, dwHorizVertTotal);

            EDIDDetailedTimingTable[j++] = sTS;
        }

        dwOffset += sizeof(DETAILEDTIMINGDESCRIPTOR);
    }

    return  (TRUE);
}


/*
    Function:   EdidFindDetailedMode

    Purpose:    This routine finds if the mode exists in the EDID
                detailed mode table.

    Arguments:  lpEdidBuffer    EDID
                dwEdidSize      size of EDID buffer
                lpModeDesc      mode to match
                lpModeOut       ptr to MODEOUT structure
                                put timing argumetns here if there is
                                a match on the input mode

    Returns:    TRUE if there was a match and lpModeOut was filled
                FALSE if there was no match

    Preserve:   Do not change any fields in lpModeDesc.
*/
int CFUNC
EdidFindDetailedMode (
        LPCHAR      lpEdidBuffer,
        ULONG       dwEdidSize,
        LPMODEINFO  lpModeDesc,
        LPMODEOUT   lpModeOut)
{
    int i;

    if  (!EdidBuildDetailedTimingTable (lpEdidBuffer, dwEdidSize))
        return  (FALSE);

    i = FindMode (EDIDDetailedTimingTable, lpModeDesc->dwXRes,
                    lpModeDesc->dwYRes, lpModeDesc->dwRefreshRate);

    if  (i < 0)
        return  (FALSE);

    SetupParamsForVidLutClass (EDIDDetailedTimingTable + i, lpModeOut,
                               lpModeDesc);

    return  (TRUE);
}


/*
    Function:   EdidFindExactModeWithHighestRR

    Purpose:    This routine searches for the highest refresh rate
                in the detailed, established, or standard timing
                sections that has a resolution exactly equal to the
                dwXRes and dwYRes in lpModeDesc. The refresh rate
                for that mode is returned. If there is no matching xres,
                yres, then 0 is returned.

    Arguments:  lpEdidBuffer    EDID
                dwEdidSize      size of EDID buffer
                lpModeDesc      mode to match

    Returns:    a non-0 is the highest refresh rate found in the detailed,
                established, or standard timing sections greater than
                or equal to the XRES, YRES given.
                0 if there was an error or a matching mode was not found

    Preserve:   Do not change any fields in lpModeDesc.
*/
int CFUNC
EdidFindExactModeWithHighestRR (
        LPCHAR      lpEdidBuffer,
        ULONG       dwEdidSize,
        LPMODEINFO  lpModeDesc)
{
    int             i, nHighestRR;

    nHighestRR = 0;

    EdidBuildDetailedTimingTable (lpEdidBuffer, dwEdidSize);
    if ((i = FindModeWithoutRR (EDIDDetailedTimingTable, lpModeDesc->dwXRes,
                      lpModeDesc->dwYRes)) != -1)
        nHighestRR = EDIDDetailedTimingTable[i].wRefresh;

    EdidBuildEstablishedTimingTable (lpEdidBuffer, dwEdidSize);
    if ((i = FindModeWithoutRR (EDIDEstablishedTimingTable, lpModeDesc->dwXRes,
                      lpModeDesc->dwYRes)) != -1)
        if  (EDIDEstablishedTimingTable[i].wRefresh > (USHORT) nHighestRR)
            nHighestRR = EDIDEstablishedTimingTable[i].wRefresh;

    EdidBuildStandardTimingTable (lpEdidBuffer, dwEdidSize);
    if ((i = FindModeWithoutRR (EDIDStandardTimingTable, lpModeDesc->dwXRes,
                      lpModeDesc->dwYRes)) != -1)
        if  (EDIDStandardTimingTable[i].wRefresh > (USHORT) nHighestRR)
            nHighestRR = EDIDStandardTimingTable[i].wRefresh;

    if  (nHighestRR)
        return (nHighestRR);

    return  (FALSE);
}


/*
    Function:   EdidFindSameModeOrLargerWithHighestRR

    Purpose:    This routine searches for the highest refresh rate
                in the detailed, established, or standard timing
                sections that has a resolution greater than or equal
                to the dwXRes and dwYRes in lpModeDesc. The refresh rate
                for that mode is returned. If there is no matching xres,
                yres, then 0 is returned.

    Arguments:  lpEdidBuffer    EDID
                dwEdidSize      size of EDID buffer
                lpModeDesc      mode to match

    Returns:    a non-0 is the highest refresh rate found in the detailed,
                established, or standard timing sections greater than
                or equal to the XRES, YRES given.
                0 if there was an error or a matching mode was not found

    Preserve:   Do not change any fields in lpModeDesc.
*/
int CFUNC
EdidFindSameModeOrLargerWithHighestRR (
        LPCHAR      lpEdidBuffer,
        ULONG       dwEdidSize,
        LPMODEINFO  lpModeDesc)
{
    int             nHighestRR, nCurrentRR;
    MONITORLIMITS   ML;

    EdidBuildDetailedTimingTable (lpEdidBuffer, dwEdidSize);
    nHighestRR = EdidFindHighestRRinTable (EDIDDetailedTimingTable, lpModeDesc);

    EdidBuildEstablishedTimingTable (lpEdidBuffer, dwEdidSize);
    nCurrentRR = EdidFindHighestRRinTable (EDIDEstablishedTimingTable, lpModeDesc);
    if  (nCurrentRR > nHighestRR)
        nHighestRR = nCurrentRR;

    EdidBuildStandardTimingTable (lpEdidBuffer, dwEdidSize);
    nCurrentRR = EdidFindHighestRRinTable (EDIDStandardTimingTable, lpModeDesc);
    if  (nCurrentRR > nHighestRR)
        nHighestRR = nCurrentRR;

    if  (nHighestRR < 60)
        nHighestRR = 60;

    if  (!EdidGetMonitorLimits (lpEdidBuffer, dwEdidSize, &ML))
        return (nHighestRR);

    if  ((ML.dwMaxHorz) && (ML.dwMaxVert))
    {
        // NOTE: If the MonitorLimits ptr passed in to the function
        // GetMaximumRefreshRate has a non-0 dwMaxPixelClock field,
        // then the first three arguments to GetMaximumRefreshRate
        // are irrelevant. We know that ML.dwMaxPixelClock is non-0
        // at this time, so we just pass in 0s for the parameters.
        nCurrentRR = (int) GetMaximumRefreshRate (0, 0, 0, &ML,
                                lpModeDesc->dwXRes, lpModeDesc->dwYRes);


        if (nCurrentRR > nHighestRR)
            nHighestRR = nCurrentRR;
    }

    return  (nHighestRR);
}


/*
    Function:   EdidFindHighestRRinTable

    Purpose:    This routine searches for the highest refresh rate
                in the table passed in. If there is no mode mode greater
                than or equal to dwXRes dwYres, then 0 is returned.

    Arguments:  lpEdidBuffer    EDID
                dwEdidSize      size of EDID buffer
                lpModeDesc      mode to match

    Returns:    a non-0 is the highest refresh rate found in the detailed,
                established, or standard timing sections greater than
                or equal to the XRES, YRES given.
                0 if there was an error or a matching mode was not found

    Preserve:   Do not change any fields in lpModeDesc.
*/
int CFUNC
EdidFindHighestRRinTable (
        LPMODESTRUC lpMS,
        LPMODEINFO  lpModeDesc)
{
    int          i, nBestIndex;

    nBestIndex = -1;

    for (i = 0; lpMS[i].wHorizVisible != 0x00; i++)
    {
        if (((ULONG) lpMS[i].wHorizVisible >= lpModeDesc->dwXRes) &&
            ((ULONG) lpMS[i].wVertVisible >= lpModeDesc->dwYRes))
        {
            if  (nBestIndex != -1)
            {
                if  (lpMS[i].wRefresh > lpMS[nBestIndex].wRefresh)
                    nBestIndex = i;
            }
            else
            {
                nBestIndex = i;
            }
        }
    }

    // If we didn't even find a mode greater than or equal to dwXRes
    // and dwYRes ...
    if  (nBestIndex == -1)
        return  (0);

    // We found one. Return the refresh rate.
    return  ((int) lpMS[nBestIndex].wRefresh);
}


/*
    Function:   EdidFindLargestEdidMode

    Purpose:    This routine searches the EDID for the largest mode of
                the detailed, established, and standard timings.

    Arguments:  lpEdidBuffer    EDID
                dwEdidSize      size of EDID buffer
                lpModeInfo      pointer to buffer for return parameters

    Returns:    TRUE and lpModeInfo filled out with largest XRes and YRes
                     found in EDID or 640x480.

*/
int CFUNC
EdidFindLargestEdidMode (
        LPCHAR      lpEdidBuffer,
        ULONG       dwEdidSize,
        LPMODEINFO  lpModeInfo)
{
    // Start with 640x480. Color depth is specified in registry.
    lpModeInfo->dwXRes          = 640;
    lpModeInfo->dwYRes          = 480;

    EdidBuildDetailedTimingTable (lpEdidBuffer, dwEdidSize);
    EdidFindLargestModeinTable (EDIDDetailedTimingTable, lpModeInfo);

    EdidBuildEstablishedTimingTable (lpEdidBuffer, dwEdidSize);
    EdidFindLargestModeinTable (EDIDEstablishedTimingTable, lpModeInfo);

    EdidBuildStandardTimingTable (lpEdidBuffer, dwEdidSize);
    EdidFindLargestModeinTable (EDIDStandardTimingTable, lpModeInfo);

    return  (TRUE);
}


/*
    Function:   EdidFindLargestModeinTable

    Purpose:    This routine searches the table pointed to by lpMS for
                a mode that is larger than the mode pointed to by
                lpModeInfo.

    Arguments:  lpMS            pointer to table to search
                lpModeInfo      pointer to mode to compare and to return
                                parameters.

    Returns:    TRUE and lpModeInfo filled out with largest XRes and YRes
                     found in table or mode originally in ModeInfo.

*/
int CFUNC
EdidFindLargestModeinTable (
        LPMODESTRUC lpMS,
        LPMODEINFO  lpModeInfo)
{
    int i;

    for (i = 0; lpMS[i].wHorizVisible != 0x00; i++)
    {
        if ((ULONG) lpMS[i].wHorizVisible >= lpModeInfo->dwXRes)
        {
            if ((ULONG) lpMS[i].wVertVisible >= lpModeInfo->dwYRes)
            {
                lpModeInfo->dwXRes = (ULONG) lpMS[i].wHorizVisible;
                lpModeInfo->dwYRes = (ULONG) lpMS[i].wVertVisible;
                if (lpMS[i].wRefresh > (USHORT) lpModeInfo->dwRefreshRate)
                     lpModeInfo->dwRefreshRate = (ULONG) lpMS[i].wRefresh;
            }
        }
    }

    return  (TRUE);
}


/*
    Function:   EdidBuildRangeLimits

    Purpose:    This routine builds a MONITORLIMITS structure
                out of the modes in the EDID.

    Arguments:  lpEdidBuffer    EDID
                dwEdidSize      size of EDID buffer
                lpML            LPMONITORLIMITS

    Returns:
                TRUE
                lpML is filled in with a range limits built from
                     all the modes in the EDID

    Preserve:
*/
int CFUNC
EdidBuildRangeLimits (
    LPCHAR      lpEdidBuffer,
    ULONG       dwEdidSize,
    LPMONITORLIMITS  lpML)
{
    int         i, j;
    LPMODESTRUC lpMS;
    ULONG       dwHorzRate;

    // Build all EDID tables.
    EdidBuildDetailedTimingTable (lpEdidBuffer, dwEdidSize);
    EdidBuildEstablishedTimingTable (lpEdidBuffer, dwEdidSize);
    EdidBuildStandardTimingTable (lpEdidBuffer, dwEdidSize);

    lpML->dwMinHorz = 0x0FFFFFFFF;
    lpML->dwMaxHorz = 0x00;
    lpML->dwMinVert = 0x0FFFFFFFF;
    lpML->dwMaxVert = 0x00;
    lpML->dwMaxPixelClock = 0x00;

    for (j = 0; j < 3; j++)
    {
        if  (j == 0)
            lpMS = EDIDDetailedTimingTable;
        else if  (j == 1)
            lpMS = EDIDEstablishedTimingTable;
        else if  (j == 2)
            lpMS = EDIDStandardTimingTable;

        for (i = 0; lpMS[i].wHorizVisible != 0x00; i++)
        {
            // Find the largest pixel clock of the modes in this list
            if (lpMS[i].wDotClock > (lpML->dwMaxPixelClock / 10000))
                lpML->dwMaxPixelClock = ((ULONG) lpMS[i].wDotClock) * 10000;

            dwHorzRate = ((ULONG) lpMS[i].wDotClock) * 10000 /
                                    (ULONG) lpMS[i].wVertTotal;

            if  (dwHorzRate < lpML->dwMinHorz)
                lpML->dwMinHorz = dwHorzRate;

            if  (dwHorzRate > lpML->dwMaxHorz)
                lpML->dwMaxHorz = dwHorzRate;

            if  (lpMS[i].wRefresh < lpML->dwMinVert)
                lpML->dwMinVert = lpMS[i].wRefresh;

            if  (lpMS[i].wRefresh > lpML->dwMaxVert)
                lpML->dwMaxVert = lpMS[i].wRefresh;
        }
    }

    return  (TRUE);
}


/*
    Function:   EdidFindLargestPixelClock

    Purpose:    This routine searches the EDID for the mode
                with the largest pixel clock and returns that
                largest pixel clock.

    Arguments:  lpEdidBuffer    EDID
                dwEdidSize      size of EDID buffer

    Returns:    largest pixel clock (may be 0 if the EDID has
                no modes init)

    Preserve:
*/
ULONG CFUNC
EdidFindLargestPixelClock (
    LPCHAR      lpEdidBuffer,
    ULONG       dwEdidSize)
{
    ULONG   dwMaxPixelClock;
    int     j;

    // Start out at 0
    dwMaxPixelClock = 0;

    EdidBuildDetailedTimingTable (lpEdidBuffer, dwEdidSize);
    for (j = 0; EDIDDetailedTimingTable[j].wHorizVisible != 0x00; j++)
        if  (dwMaxPixelClock < (ULONG) EDIDDetailedTimingTable[j].wDotClock)
            dwMaxPixelClock = (ULONG) EDIDDetailedTimingTable[j].wDotClock;

    EdidBuildEstablishedTimingTable (lpEdidBuffer, dwEdidSize);
    for (j = 0; EDIDEstablishedTimingTable[j].wHorizVisible != 0x00; j++)
        if  (dwMaxPixelClock < (ULONG) EDIDEstablishedTimingTable[j].wDotClock)
            dwMaxPixelClock = (ULONG) EDIDEstablishedTimingTable[j].wDotClock;

    EdidBuildStandardTimingTable (lpEdidBuffer, dwEdidSize);
    for (j = 0; EDIDStandardTimingTable[j].wHorizVisible != 0x00; j++)
        if  (dwMaxPixelClock < (ULONG) EDIDStandardTimingTable[j].wDotClock)
            dwMaxPixelClock = (ULONG) EDIDStandardTimingTable[j].wDotClock;

    return  (dwMaxPixelClock);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\modeset.mhd\CODE\EDID.H ===
/*
    FILE:   edid.h
    DATE:   4/8/99

    This file contains the includes for the EDID code.
    Os Independent
*/

#ifdef WINNT
// This disables any packing optimizations of the compiler.
// We achieve this by telling the compiler to pack on a 1-byte boundary.
// Note: There must be a corresponding pragma call at the end of this file to
// restore the default compiler packing (specified by /Zp).
#pragma pack(1)
#endif

struct  _tagDETAILEDTIMINGDESCRIPTOR
{
    USHORT  wDTPixelClock;              // 0x00
    UCHAR   bDTHorizontalActive;        // 0x02
    UCHAR   bDTHorizontalBlanking;      // 0x03
    UCHAR   bDTHorizActiveBlank;        // 0x04
    UCHAR   bDTVerticalActive;          // 0x05
    UCHAR   bDTVerticalBlanking;        // 0x06
    UCHAR   bDTVertActiveBlank;         // 0x07
    UCHAR   bDTHorizontalSync;          // 0x08
    UCHAR   bDTHorizontalSyncWidth;     // 0x09
    UCHAR   bDTVerticalSync;            // 0x0A
    UCHAR   bDTHorizVertSyncOverFlow;   // 0x0B
    UCHAR   bDTHorizontalImage;         // 0x0C
    UCHAR   bDTVerticalImage;           // 0x0D
    UCHAR   bDTHorizVertImage;          // 0x0E
    UCHAR   bDTHorizontalBorder;        // 0x0F
    UCHAR   bDTVerticalBorder;          // 0x10
    UCHAR   bDTFlags;                   // 0x11
} __STRUCTURE_PACKING__;

typedef struct _tagDETAILEDTIMINGDESCRIPTOR DETAILEDTIMINGDESCRIPTOR;
typedef DETAILEDTIMINGDESCRIPTOR FAR *LPDETAILEDTIMINGDESCRIPTOR;


struct  _tagMONITORDESCRITOR
{
    USHORT  wZeroFlag;                  // 0x00
    UCHAR   bZeroFlag;                  // 0x02
    UCHAR   bTypeDescriptorBlock;       // 0x03
    UCHAR   bZeroFlag2;                 // 0x04
    UCHAR   bMinVertRateInHz;           // 0x05
    UCHAR   bMaxVertRateInHz;           // 0x06
    UCHAR   bMinHorzRateInKHz;          // 0x07
    UCHAR   bMaxHorzRateInKHz;          // 0x08
    UCHAR   bMaxPixelClockInCKHz;       // 0x09
    UCHAR   bUnused[8];                 // 0x0A
} __STRUCTURE_PACKING__;

typedef struct _tagMONITORDESCRITOR MONITORDESCRITOR;
typedef MONITORDESCRITOR FAR *LPMONITORDESCRITOR;

// Note: The bMaxPixelClockInCKHz is in centi-kilohertz which is
// Megahertz divided by 10. This field may not be specified in which
// case it is set to 0x0FF.

// These are the values that can be in the bTypeDescriptorBlock field.
// Note: 0x10-0xF9 are currently undefined. 0x00-0x09 are monitor-
// manufacturer specific.
#define DT_MONITOR_SERIAL_NUMBER        0x0FF
#define DT_ASCII_STRING_DATA            0x0FE
#define DT_MONITOR_RANGE_LIMITS         0x0FD
#define DT_MONITOR_NAME_AS_ASCII        0x0FC
#define DT_EXTRA_COLOR_POINT_DATA       0x0FB
#define DT_EXTRA_STANDARD_TIMINGS       0x0FA


struct  _tagEDIDV1STRUC
{
    UCHAR   bHeaderByte0;               // 0x00
    UCHAR   bHeaderByte1;               // 0x01
    UCHAR   bHeaderByte2;               // 0x02
    UCHAR   bHeaderByte3;               // 0x03
    UCHAR   bHeaderByte4;               // 0x04
    UCHAR   bHeaderByte5;               // 0x05
    UCHAR   bHeaderByte6;               // 0x06
    UCHAR   bHeaderByte7;               // 0x07
    USHORT  wIDManufName;               // 0x08
    USHORT  wIDProductCode;             // 0x0A
    ULONG   wIDSerialNumber;            // 0x0C
    UCHAR   bWeekManuf;                 // 0x10
    UCHAR   bYearManuf;                 // 0x11
    UCHAR   bVersionNumber;             // 0x12
    UCHAR   bRevisionNumber;            // 0x13
    UCHAR   bVideoInputDef;             // 0x14
    UCHAR   bMaxHorizImageSize;         // 0x15
    UCHAR   bMaxVertImageSize;          // 0x16
    UCHAR   bDisplayXferChar;           // 0x17
    UCHAR   bFeatureSupport;            // 0x18
    UCHAR   bRedGreenLowBits;           // 0x19
    UCHAR   bBlueWhiteLowBits;          // 0x1A
    UCHAR   bRedX;                      // 0x1B
    UCHAR   bRedY;                      // 0x1C
    UCHAR   bGreenX;                    // 0x1D
    UCHAR   bGreenY;                    // 0x1E
    UCHAR   bBlueX;                     // 0x1F
    UCHAR   bBlueY;                     // 0x20
    UCHAR   bWhiteX;                    // 0x21
    UCHAR   bWhiteY;                    // 0x22
    UCHAR   bEstablishedTimings1;       // 0x23
    UCHAR   bEstablishedTimings2;       // 0x24
    UCHAR   bManufReservedTimings;      // 0x25
    USHORT  wStandardTimingID[8];       // 0x26
    DETAILEDTIMINGDESCRIPTOR    DetailedTimingDesc[4];  // 0x36
    UCHAR   bExtensionFlag;             // 0x7E
    UCHAR   bChecksum;                  // 0x7F
} __STRUCTURE_PACKING__;

typedef struct _tagEDIDV1STRUC EDIDV1STRUC;
typedef EDIDV1STRUC FAR *LPEDIDV1STRUC;


struct  _tagEDIDV2STRUC
{
    UCHAR   bHeader;                        // 0x00
    USHORT  wIDManufName;                   // 0x01
    USHORT  wIDProductCode;                 // 0x03
    UCHAR   bWeekManuf;                     // 0x05
    USHORT  wYearManuf;                     // 0x06
    UCHAR   bProductIDString[32];           // 0x08
    UCHAR   bSerialNumber[16];              // 0x28
    UCHAR   bReserved1[8];                  // 0x38
    UCHAR   bPhysicalInterfaceType;         // 0x40
    UCHAR   bVideoInterfaceType;            // 0x41
    UCHAR   bInterfaceDataFormat[8];        // 0x42
    UCHAR   bInterfaceColor[5];             // 0x4A
    UCHAR   bDisplayTechType;               // 0x4F
    UCHAR   bMajorDisplayChar;              // 0x50
    UCHAR   bFeaturesSupported[3];          // 0x51
    USHORT  wDisplayResponseTime;           // 0x54
    ULONG   dwDisplayXferChar;              // 0x56
    ULONG   dwMaxLuminance;                 // 0x5A
    UCHAR   bColorimetry[20];               // 0x5E
    ULONG   dwMaxImageSize;                 // 0x72
    ULONG   dwMaxAddressability;            // 0x76
    USHORT  wDotPixelPitch;                 // 0x7A
    UCHAR   bReserved2;                     // 0x7C
    UCHAR   bGTFSupportInfo;                // 0x7D
    USHORT  wTimingInfoMap;                 // 0x7E
    UCHAR   bTableDescriptors[127];         // 0x80
    UCHAR   bChecksum;                      // 0xFF
} __STRUCTURE_PACKING__;

typedef struct _tagEDIDV2STRUC EDIDV2STRUC;
typedef EDIDV2STRUC FAR *LPEDIDV2STRUC;


struct  _tagTIMINGCODES
{
    ULONG   dwNumLuminanceTables;
    ULONG   dwSizeLuminanceTables;
    ULONG   dwNumFreqRanges;
    ULONG   dwNumRangeLimits;
    ULONG   dwNumTimingCodes;
    ULONG   dwNumDetailedTimings;
} __STRUCTURE_PACKING__;

typedef struct _tagTIMINGCODES TIMINGCODES;
typedef TIMINGCODES FAR *LPTIMINGCODES;


struct  _tagDISPLAYTIMINGRANGE
{
    UCHAR   bHiMinVert;
    UCHAR   bHiMaxVert;
    UCHAR   bHiMinHorz;
    UCHAR   bHiMaxHorz;
    UCHAR   bLoHV;
    UCHAR   bLoMinPixClock;
    UCHAR   bLoMaxPixClock;
    UCHAR   bHiMinMaxPixClock;
}  __STRUCTURE_PACKING__;

typedef struct _tagDISPLAYTIMINGRANGE DISPLAYTIMINGRANGE;
typedef DISPLAYTIMINGRANGE FAR *LPDISPLAYTIMINGRANGE;


struct  _tagDETAILEDTIMINGRANGE
{
    USHORT  wMinPixelClock;
    UCHAR   bLowMinHBlank;
    UCHAR   bLowMinVBlank;
    UCHAR   bHiMinHVBlank;
    UCHAR   bMinHSyncOffsetFromBlankStart;
    UCHAR   bLowMinHSyncPulseWidth;
    UCHAR   bLowMinVSyncPulseOffsetAndWidth;
    UCHAR   bHiMinSyncPulseOffsetsAndWidths;
    USHORT  wMaxPixelClock;
    UCHAR   bLowMaxHBlank;
    UCHAR   bLowMaxVBlank;
    UCHAR   bHiMaxHVBlank;
    UCHAR   bMaxHSyncOffset;
    UCHAR   bLowMaxHSyncPulseWidth;
    UCHAR   bLowMaxVSyncPulseOffsetAndWidth;
    UCHAR   bHiMaxSyncPulseOffsetsAndWidths;
    UCHAR   bLowHImageSizeInMM;
    UCHAR   bLowVImageSizeInMM;
    UCHAR   bHiHVImageSizeInMM;
    UCHAR   bLowHActive;
    UCHAR   bLowVActive;
    UCHAR   bHiHVActive;
    UCHAR   bHBorder;
    UCHAR   bVBorder;
    UCHAR   bFlags;
}   __STRUCTURE_PACKING__;

typedef struct _tagDETAILEDTIMINGRANGE DETAILEDTIMINGRANGE;
typedef DETAILEDTIMINGRANGE FAR *LPDETAILEDTIMINGRANGE;


extern int CFUNC EdidFindDetailedMode (LPCHAR lpEdidBuffer, ULONG dwEdidSize,
                            LPMODEINFO lpModeDesc, LPMODEOUT lpModeOut);
extern int CFUNC EdidFindStandardMode (LPCHAR lpEdidBuffer, ULONG dwEdidSize,
                            LPMODEINFO lpModeDesc, LPMODEOUT lpModeOut);
extern int CFUNC EdidFindEstablishedMode (LPCHAR lpEdidBuffer,
                            ULONG dwEdidSize, LPMODEINFO lpModeDesc,
                            LPMODEOUT lpModeOut);
extern int CFUNC EdidIsGtfMonitor (LPCHAR lpEdidBuffer, ULONG dwEdidSize);
// This routine returns TRUE if the Monitor is a GTF monitor and
// FALSE, otherwise. Remember that the DOCS said that technically,
// a monitor is not fully GTF compliant unless in addition to the
// GTF bit, there was also a MONITORRANGELIMITS structure.

extern int CFUNC EdidGetMonitorLimits (LPCHAR lpEdidBuffer,
                            ULONG dwEdidSize, LPMONITORLIMITS lpML);
// This routine gets a MONITORLIMITS structure out of the EDID if
// the EDID is the correct version and a MONITORLIMITS structure
// is present (the structure is optional in v 2.x). If one is
// obtained the function returns TRUE; else it returns FALSE.

extern int CFUNC EdidFindSameModeOrLargerWithHighestRR (LPCHAR lpEdidBuffer,
                    ULONG dwEdidSize, LPMODEINFO lpModeDesc);
// EdidFindModeHighestRR should find a the highest refresh rate in
// the detailed, established, or standard timing sections that has a
// resolution greater than or equal to the dwXRes and dwYRes in
// lpModeDesc. The refresh rate for that mode is returned. If there
// is no matching xres, yres, then 0 is returned.

extern int CFUNC EdidFindHighestRRinTable (LPMODESTRUC lpMS,
                    LPMODEINFO  lpModeDesc);
// EdidFindHighestRRinTable should return the highest refresh rate
// in the table passed in which corresponds to a resolution which is
// greater than or equal to the requested mode.

extern int CFUNC EdidFindLargestEdidMode (LPCHAR lpEdidBuffer,
                    ULONG dwEdidSize, LPMODEINFO lpModeInfo);
// EdidFindLargestEdidMode should return the largest XRes and YRes
// that can be found in the EDID.

extern int CFUNC EdidFindLargestModeinTable (LPMODESTRUC lpMS,
                    LPMODEINFO lpModeInfo);
// EdidFindLargestModeinTable should return the largest XRes and YRes
// that can be found in the table.

// This looks through all the modes listed in the EDID to build a
// range limits structure (by finding the mode with the largest
// pixel clock, largest HFreq, smallest HFreq, largest VFreq,
// smallest VFreq).
extern int CFUNC EdidBuildRangeLimits (LPCHAR lpEdidBuffer, ULONG dwEdidSize,
                                LPMONITORLIMITS lpML);

extern int CFUNC EdidCheckIfModeIsSmaller (LPMODESTRUC lpMS,
                    LPMODEINFO  lpModeDesc);
// EdidCheckIfModeIsSmaller should return TRUE if an lpMS timing
// mode exists which is greater than or equal to the requested mode.

extern int CFUNC EdidFindTimingCodesHighestRR (LPCHAR lpEdidBuffer,
                        ULONG dwEdidSize, LPMODEINFO lpModeDesc,
                        LPMODEOUT lpModeOut);
// EdidTimingCodesHighestRR should find a mode in the timing codes
// section (only in version 2.X of the EDID) that matches the dwXRes
// and dwYRes in lpModeDesc and has the highest refresh rate. That
// mode should be returned in lpModeOut.

extern int CFUNC EdidGetVersion (LPCHAR lpEdidBuffer, ULONG dwEdidSize);
// This routine should return the EDID version multiplied by 0x100.
// So, for example, version 1.10 should be returned as 0x110.

extern ULONG CFUNC EdidGetMonitorId (LPCHAR lpEdidBuffer, ULONG dwEdidSize);
// This routine should return the monitorID from the EDID. This is
// defined as a DWORD from high byte to low byte as follows:
// high byte of product code, low byte of product code, high byte of
// manufacturer code, low byte of manufacturer code. ASsemble these
// four bytes into a ULONG and return. If there is any kind of error
// then return XXXX_ID which is defined in restime.h  It means any
// monitor for which an EDID is not defined. Since you can't parse
// the EDID for some reason, this is a reasonable return value.

extern ULONG CFUNC EdidFindLargestPixelClock (LPCHAR lpEdidBuffer, ULONG dwEdidSize);
// Finds the EDID mode with the largest pixel clock and returns
// the pixel clock.

extern int CFUNC EdidFindExactModeWithHighestRR (LPCHAR lpEdidBuffer,
                        ULONG dwEdidSize, LPMODEINFO lpModeDesc);
// This routine searches for the highest refresh rate in the detailed,
// established, or standard timing sections that has a resolution exactly
// equal to the dwXRes and dwYRes in lpModeDesc. The refresh rate for that
// mode is returned. If there is no matching Xres, Yres, then 0 is returned.

#ifdef WINNT
// Restore the compiler's default specified packing mode (specified by /Zp).
// This directive needs the corresponding directive in the beginning of this file.
#pragma pack()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\modeset.mhd\CODE\GTF.C ===
/*
    FILE:   gtf.c
    DATE:   4/8/99

    This file is the generic entry point for the gtf modeset code.
*/

#include "cmntypes.h"
#include "modeext.h"
#include "modeset.h"
#include "gtf.h"
#include "gtfmath.h"
#include "utils.h"

/*
    Function:   GtfFindMode

    Purpose:    This routine looks for a mode in the GTF list of modes.

    Arguments:  lpModeIn    ptr to MODEINFO structure
                lpModeOut   ptr to MODEOUT structure

    Returns:    Gtf is a formula based mode computation. Given a set
                of input parameters which describe the mode, the
                set of timing parameters to display the mode is
                computed.

                Hence, this routine always returns TRUE and lpModeOut
                is filled in with the corret timing parameters.

    Preserve:   Do not change any fields in lpModeIn.
*/

int CFUNC
GtfFindMode (LPMODEINFO lpModeIn, LPMODEOUT lpModeOut)
{
    GTFIN       GTFIn;
    GTFOUT      GTFOut;
    MODESTRUC   sGTF;

    GTFIn.dwHPixels      = lpModeIn->dwXRes;
    GTFIn.dwVLines       = lpModeIn->dwYRes;
    GTFIn.dwMarginsRqd   = FALSE;
    GTFIn.dwIntRqd       = FALSE;
    GTFIn.dwIPParmType   = IPTYPE_VERTICAL_REFRESH_RATE;
    GTFIn.dwIPFreqRqd    = lpModeIn->dwRefreshRate;

    // Be careful of double scan modes. 512x384 needs to be calculated
    // as if it is 1024x768.
    if (lpModeIn->dwYRes < 400)
    {
        GTFIn.dwHPixels = (GTFIn.dwHPixels * 2);
        GTFIn.dwVLines  = (GTFIn.dwVLines  * 2);
    }

    // Get the timing parameters.
    ComputeGTFParameters(&GTFIn, &GTFOut);

    // Store all parameters in temporary MODESTRUC buffer. Note that
    // horizontal GTF parameters are returned in character clocks and
    // need to be converted to pixels.
    sGTF.wHorizVisible    = (USHORT) (GTFOut.dwHActiveChars << 3);
    sGTF.wVertVisible     = (USHORT) GTFOut.dwVActiveScans;
    sGTF.wRefresh         = (USHORT) lpModeIn->dwRefreshRate;
    sGTF.wHorizTotal      = (USHORT) (GTFOut.dwHTotalChars << 3);
    sGTF.wHorizBlankStart = (USHORT) (GTFOut.dwHBlankStartChar << 3);
    sGTF.wHorizSyncStart  = (USHORT) ((GTFOut.dwHBlankStartChar
                                     + GTFOut.dwHFrontPorchChars) << 3);
    sGTF.wHorizSyncEnd    = (USHORT) (sGTF.wHorizSyncStart
                                     + (GTFOut.dwHSyncChars << 3));
    sGTF.wHorizBlankEnd   = (USHORT) (GTFOut.dwHBlankEndChar << 3);
    sGTF.wVertTotal       = (USHORT) GTFOut.dwVTotalScans;
    sGTF.wVertBlankStart  = (USHORT) GTFOut.dwVBlankStartScan;
    sGTF.wVertSyncStart   = (USHORT) (GTFOut.dwVBlankStartScan
                                     + GTFOut.dwVFrontPorchScans);
    sGTF.wVertSyncEnd     = (USHORT) (sGTF.wVertSyncStart
                                     + GTFOut.dwVSyncScans);
    sGTF.wVertBlankEnd    = (USHORT) GTFOut.dwVBlankEndScan;
    sGTF.wDotClock        = (USHORT) GTFOut.dwPixelClockIn10KHertz;
    sGTF.wHSyncPolarity   = BUFFER_HSYNC_NEGATIVE;
    sGTF.wVSyncPolarity   = BUFFER_VSYNC_POSITIVE;

    // Be careful of double scan modes. Need to reduce the horizontals and
    // pixel clock by half since the GTF calculations were done with
    // GTFIn.dwHPixels and GTFIn.dwVLines doubled. All verticals except
    // VertVisible remain the same.
    if (lpModeIn->dwYRes < 400)
    {
        // Add 1 to account for rounding off--otherwise values will
        // be truncated.
        sGTF.wHorizVisible    = ((sGTF.wHorizVisible + 1)/2);
        sGTF.wVertVisible     = ((sGTF.wVertVisible + 1)/2);
        sGTF.wHorizTotal      = ((sGTF.wHorizTotal + 1)/2);
        sGTF.wHorizBlankStart = ((sGTF.wHorizBlankStart + 1)/2);
        sGTF.wHorizSyncStart  = ((sGTF.wHorizSyncStart + 1)/2);
        sGTF.wHorizSyncEnd    = ((sGTF.wHorizSyncEnd + 1)/2);
        sGTF.wHorizBlankEnd   = ((sGTF.wHorizBlankEnd + 1)/2);
        sGTF.wDotClock        = ((sGTF.wDotClock + 1)/2);
    }

    // Convert to final output format
    SetupParamsForVidLutClass (&sGTF, lpModeOut, lpModeIn);

    return  (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\modeset.mhd\CODE\GTFMATH.H ===
/*==========================================================================
;
; Copyright (C) 1999, Nvidia Corporation
;
; File:     gtf.h
;
; Purpose:  This file implements the GTF algorithm
==========================================================================*/

typedef struct  tagGTFIN
{
    ULONG   dwHPixels;
    ULONG   dwVLines;
    ULONG   dwMarginsRqd;
    ULONG   dwIntRqd;
    ULONG   dwIPParmType;
    ULONG   dwIPFreqRqd;
} GTFIN;

typedef GTFIN   FAR *LPGTFIN;

// The entire GTF based computation is based upon the variables provided
// in the GTFIN structure. They are defined as follows:
// HPixels      - the horizontal resolution in Pixels
// VLines       - the vertical resolution in scanlines
// MarginsRqd   - this is a flag -- TRUE if borders should be present
//                FALSE if they shouldn't be. Borders are also referred
//                to as the overscan area.
// IntRqd       - this is a flag -- TRUE if interlace mode is desired
//                FALSE if non-interlace mode is desired.
// IPParmType   - this indicates what the dwIPFreqRqd variables means.
//                assording to the following table.
//  If IPParm is this           IPFreqRqd is this
//  1                           vertical refresh rate in hz
//  2                           horizontal refresh rate in Khz
//  3                           pixel clock rate in Mhz

// These are the tree values that can be assumed by the
// dwIPParmType file din the GTFIN structure.
#define IPTYPE_VERTICAL_REFRESH_RATE    1
#define IPTYPE_HORIZONTAL_REFRESH_RATE  2
#define IPTYPE_PIXEL_CLOCK_RATE         3


typedef struct  tagGTFOUT
{
    ULONG   dwHTotalChars;
    ULONG   dwVTotalScans;
    ULONG   dwHActiveChars;
    ULONG   dwVActiveScans;
    ULONG   dwHBlankStartChar;
    ULONG   dwHFrontPorchChars;
    ULONG   dwHSyncChars;
    ULONG   dwHBackPorchChars;
    ULONG   dwHBlankEndChar;
    ULONG   dwVBlankStartScan;
    ULONG   dwVFrontPorchScans;
    ULONG   dwVSyncScans;
    ULONG   dwVBackPorchScans;
    ULONG   dwVBlankEndScan;
    ULONG   dwPixelClockIn10KHertz;
} GTFOUT;

typedef GTFOUT  FAR *LPGTFOUT;

// For those display devices which don't really need front and back
// porches, those fields can be ignored but they are always valid.


extern ULONG WINAPI ComputeGTFParameters(LPGTFIN lpGtfIn, LPGTFOUT lpGtfOut);
extern ULONG WINAPI Divide32By32(ULONG dwDividend, ULONG dwDivisor);
extern ULONG WINAPI Multiply32By32(ULONG dwMult1, ULONG dwMult2);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\modeset.mhd\CODE\GTFMATH.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gtf.asm
;
; Purpose:      This file implements the GTF algorithm
;
;       Just come important comments and definitions I extracted from
;       the GTF document.
;
;       Horizontal - negative
;       Vertical - positive
;       composite - negative
;
;       Blanking Duty Cycle = (1 - tA / T) * 100%
;                     = (       1 - (F * n) / p) * 100%
;               tA = active video time
;               T  = Horizontal period
;               F  = horizontal frequency
;               n  = number of active pixels (Xresolution)
;               p = pixel clock frequency
;
;       Basic form of equation is:
;       Blanking Duty Cycle = C' - (M' / F)
;
;       C' = ((C - J) * (K / 256) + J
;       M' = (K / 256) * M
;
;       Margin% = 1.8%
;       size of top and bottom overscan margin as % of active vertical
;       size of left and right overscan margin as % of active vertical
;
;       CellGran = 8 pixels
;       character cell granularity
;
;       MinPorch = 1 line / 1 char cell
;       Minimum front porch in lines and character cells
;
;       VsyncRqd = 3 lines
;       width of the vsync pulse in scanlines
;
;       HSyncPercent = 8%
;       The width of HSync as a percentage of the total line period
;
;       MinVSyncPlusBackPorch  550us
;       minimum time for vertical sync plus back porch
;
;       M       600% / Khz
;       blanking formula gradient
;
;       C       40%
;       blanking formula offset
;
;       K       128
;       blanking formula scaling factor
;
;       J       20%
;       blanking formula scaling factor weighting
;
;       HPixels    - the horizontal resolution
;       VLines     - the vertical resolution
;       MarginsRqd - this is a flag -- TRUE if borders, FLASE if none
;       IntRqd     - this is a flag -- TRUE if interlace, FALSE otherwise
;       IPParm     - this indicates what the last specifying parm will be
;               1  - VFrameRateRqd
;               2  - HFreq
;               3  - PixelClock
;       IPFreqRqd  - Depends upon VPParm
;               If IPParm is this       IPFreqRqd is this
;               1                       vertical refresh rate in hz
;               2                       horizontal refresh rate in Kilohz
;               3                       pixel clock rate in Megahz
;
;       Interestingly enough, the GTF spec says that any monitor that
;       has the GTF bit set, MUST have a Monitor Description Block in
;       the EDID that tells the monitor frequency limits. If this block
;       does not exist, then the monitor should be trated as non-GTF
;       compliant. Byte 10, bit 0 = 1 means that overscan margins are
;       required.
;==============================================================================
.586
include macros.dat
include gtfmath.inc

.listall

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, USE32, CODE

fZeroPointFour                  REAL4   0.4
fZeroPointFive                  REAL4   0.5
fOne                            REAL4   1.0
fOnePointEight                  REAL4   1.8
fTwo                            REAL4   2.0
fThree                          REAL4   3.0
fEight                          REAL4   8.0
fTwenty                         REAL4   20.0
fForty                          REAL4   40.0
fOneHundred                     REAL4   100.0
fOneHundredTwentyEight          REAL4   128.0
fTwoHundredFiftySix             REAL4   256.0
fFiveHundredFifty               REAL4   550.0
fSixHundred                     REAL4   600.0
fOneThousand                    REAL4   1000.0
fOneMillion                     REAL4   1000000.0

;==============================================================================
;
; Function:     ComputeGTFParameters
;
; Purpose:      This function computes the data for the GTFOut structure
;               from the arguments in the GTFIn structure provided
;               according to the GTF formula.
;
; Arguments:    lpGTFIn         FAR ptr to GTFIN structure
;               lpGTFOut        FAR ptr to GTFOUT structure
;
; Returns:      eax     0       failure and lpGTFOut was not filled in
;                       non-0   success and lpGTFOut was filled in
;
; Preserve:     All registers
;==============================================================================
IFDEF  _WIN32
DECPROC ComputeGTFParameters, STANDARD, FRAME, NEAR
ELSE
DECPROC ComputeGTFParameters, PASCAL, FRAME, FAR16
ENDIF
PARMD   lpGTFIn
PARMD   lpGTFOut
OPENPROC
        PUSHR   ds,ebx,esi,edi
IFDEF _WIN32
        mov     ebx,lpGTFIn
        mov     esi,lpGTFOut
ELSE
        sub     ebx,ebx
        lds     bx,lpGTFIn
        sub     esi,esi
        les     si,lpGTFOut
ENDIF
        call    ComputeGTFParameters1
        POPR    ds,ebx,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     ComputeGTFParameters1
;
; Purpose:      This function computes the data for the GTFOut structure
;               from teh arguments in the GTFIn structure provided
;               according to the GTF formula.
;
; Arguments:    ds:ebx  GTFIN ptr
;               es:esi  GTFOUT ptr
;
; Returns:      eax     0       failure and lpGTFOut was not filled in
;                       non-0   success and lpGTFOut was filled in
;
; Preserve:     All registers
;==============================================================================
DECPROC ComputeGTFParameters1, PASCAL, FRAME, NEAR
LOCALD  dwTemp
LOCALR4 fVLinesRnd
LOCALR4 fAddrLinesPerFrame
LOCALR4 fCellGran
LOCALR4 fPixelFreq
LOCALR4 fCharTime
LOCALR4 fTopMarginLines
LOCALR4 fBottomMarginLines
LOCALR4 fVSyncPlusBackPorch
LOCALR4 fMinPorch
LOCALR4 fInterlace
LOCALR4 fTotalLinesPerFrame
LOCALR4 fTotalPixels
LOCALR4 fTotalHTimeChars
LOCALR4 fHPixelsRnd
LOCALR4 fHAddrTime
LOCALR4 fHAddrTimeChars
LOCALR4 fHBlankPixels
LOCALR4 fHBlank
LOCALR4 fHBlankChars
LOCALR4 fLeftMarginPixels
LOCALR4 fRightMarginPixels
LOCALR4 fHBlankPlusMargin
LOCALR4 fHBlankPlusMarginChars
LOCALR4 fActualDutyCycle
LOCALR4 fBlankPlusMarginDutyCycle
LOCALR4 fLeftMargin
LOCALR4 fLeftMarginChars
LOCALR4 fRightMargin
LOCALR4 fRightMarginChars
LOCALR4 fHSyncPercent
LOCALR4 fHSyncPixels
LOCALR4 fHFrontPorchPixels
LOCALR4 fHBackPorchPixels
LOCALR4 fHSyncChars
LOCALR4 fHSync
LOCALR4 fHFrontPorchChars
LOCALR4 fHFrontPorch
LOCALR4 fHBackPorchChars
LOCALR4 fHBackPorch
LOCALR4 fTotalVLines
LOCALR4 fHPeriod
LOCALR4 fVFramePeriod
LOCALR4 fVFieldPeriod
LOCALR4 fVAddrTimePerFrame
LOCALR4 fVAddrTimePerField
LOCALR4 fVOddBlankingLines
LOCALR4 fVOddBlanking
LOCALR4 fVEvenBlankingLines
LOCALR4 fVEvenBlanking
LOCALR4 fTopMargin
LOCALR4 fVOddFrontPorch
LOCALR4 fVOddFrontPorchLines
LOCALR4 fVEvenFrontPorch
LOCALR4 fVSyncRqd
LOCALR4 fVSync
LOCALR4 fVBackPorch
LOCALR4 fVEvenBackPorch
LOCALR4 fVBackPorch
LOCALR4 fVEvenBackPorchLines
LOCALR4 fVOddBackPorch
LOCALR4 fBottomMargin
LOCALR4 fMarginPercent
LOCALR4 fMinVSyncPlusBackPorch
LOCALR4 fGTF_M
LOCALR4 fGTF_C
LOCALR4 fGTF_J
LOCALR4 fGTF_K
LOCALR4 fGTF_CPrime
LOCALR4 fGTF_MPrime
LOCALR4 fVFieldRateRqd
LOCALR4 fHPeriodEst
LOCALR4 fVFieldRateEst
LOCALR4 fVFieldRate
LOCALR4 fVFrameRate
LOCALR4 fTotalActivePixels
LOCALR4 fIdealDutyCycle
LOCALR4 fHFreq
LOCALR4 fIdealHPeriod
OPENPROC
        PUSHR   ds,ebx,esi,edi

        ; Reset the floating point unit
        fninit

        ; Set up all the constants we need
        call    SetupGTFConstants

        ; Now we compute the stage 1 parameters. There are three cases
        ; depending upon the IPParm which gives the type of the IPFreqRqd.
        push    OFFSET DoneStage1Parms
        cmp     ds:[ebx].GTFIN.dwIPParmType,IPTYPE_VERTICAL_REFRESH_RATE
        je      VerticalRefreshToStage1Parameters
        cmp     ds:[ebx].GTFIN.dwIPParmType,IPTYPE_HORIZONTAL_REFRESH_RATE
        je      HorizontalRefreshToStage1Parameters
        cmp     ds:[ebx].GTFIN.dwIPParmType,IPTYPE_PIXEL_CLOCK_RATE
        je      PixelClockToStage1Parameters
        pop     eax
        sub     eax,eax
        jmp     Done

DoneStage1Parms:
        ; Convert stage 1 to stage 2 parameters

        ; 1) Find the adressable lines per frame
        fld     fVLinesRnd
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fadd    ST(0),ST(0)
@@:     fstp    fAddrLinesPerFrame

        ; 2) Find the character time in nanoseconds
        fld     fCellGran
        fdiv    fPixelFreq
        fmul    fOneThousand
        fstp    fCharTime

        ; 3) Find total number of lines in a frame
        fld     fVLinesRnd
        fadd    fTopMarginLines
        fadd    fBottomMarginLines
        fadd    fVSyncPlusBackPorch
        fadd    fMinPorch
        fadd    fInterlace
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fadd    ST(0),ST(0)
@@:     fstp    fTotalLinesPerFrame

        ; 4) Find total number of chars in a horizontal line
        fld     fTotalPixels
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fstp    fTotalHTimeChars

        ; 5) Find the horizontal addressable time in microseconds
        fld     fHPixelsRnd
        fdiv    fPixelFreq
        fstp    fHAddrTime

        ; 6) Find the horizontal addressable time in chars
        fld     fHPixelsRnd
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fstp    fHAddrTimeChars

        ; 7) Find horizontal blanking time in microseconds
        fld     fHBlankPixels
        fdiv    fPixelFreq
        fstp    fHBlank

        ; 8) Find horizontal blanking time in chars
        fld     fHBlankPixels
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fstp    fHBlankChars

        ; 9) Find the horizontal blanking plus margin time in microseconds
        fld     fHBlankPixels
        fadd    fLeftMarginPixels
        fadd    fRightMarginPixels
        fdiv    fPixelFreq
        fstp    fHBlankPlusMargin

        ; 10) Find the horizontal blanking plus margin time in chars
        fld     fHBlankPixels
        fadd    fLeftMarginPixels
        fadd    fRightMarginPixels
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fstp    fHBlankPlusMarginChars

        ; 11) Find the actual horizontal active video duty cycle in %
        fld     fHBlankChars
        fdiv    fTotalHTimeChars
        fmul    fOneHundred
        fstp    fActualDutyCycle

        ; 12) Find the image video duty cycle in %
        fld     fHBlankPlusMarginChars
        fdiv    fTotalHTimeChars
        fmul    fOneHundred
        fstp    fBlankPlusMarginDutyCycle

        ; 13) Find the left margin time in microseconds
        fld     fLeftMarginPixels
        fmul    fPixelFreq
        fmul    fOneThousand
        fstp    fLeftMargin

        ; 14) Find the number of chars in the left margin
        fld     fLeftMarginPixels
        fdiv    fCellGran
        fstp    fLeftMarginChars

        ; 15) Find the right margin time in microseconds
        fld     fRightMarginPixels
        fmul    fPixelFreq
        fmul    fOneThousand
        fstp    fRightMargin

        ; 16) Find the number of chars in the rightt margin
        fld     fRightMarginPixels
        fdiv    fCellGran
        fstp    fRightMarginChars

        ; 17) Find the number of pixels inteh horizontal sync period
        fld     fHSyncPercent
        fdiv    fOneHundred
        fmul    fTotalPixels
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
        fstp    fHSyncPixels

        ; 18) Find number of pixels in horizontal front porch period
        fld     fHBlankPixels
        fdiv    fTwo
        fsub    fHSyncPixels
        fstp    fHFrontPorchPixels

        ; 19) Find number of pixels in horizontal front porch period
        fld     fHFrontPorchPixels
        fadd    fHSyncPixels
        fstp    fHBackPorchPixels

        ; 20) Find number of characters in the horizontal sync period
        fld     fHSyncPixels
        fdiv    fCellGran
        fstp    fHSyncChars

        ; 21) Find the horizontal sync period in microseconds
        fld     fHSyncPixels
        fdiv    fPixelFreq
        fstp    fHSync

        ; 22) Find the number of chars in the horizontal front porch
        fld     fHFrontPorchPixels
        fdiv    fCellGran
        fstp    fHFrontPorchChars

        ; 23) Find the horizontal front porch period in microseconds
        fld     fHFrontPorchPixels
        fdiv    fPixelFreq
        fstp    fHFrontPorch

        ; 24) Find the number of chars in the horizontal back porch
        fld     fHBackPorchPixels
        fdiv    fCellGran
        fstp    fHBackPorchChars

        ; 25) Find the horizontal front back period in microseconds
        fld     fHBackPorchPixels
        fdiv    fPixelFreq
        fstp    fHBackPorch

        ; 26) Find the vertical frame period in milliseconds
        fld     fTotalVLines
        fmul    fHPeriod
        fdiv    fOneThousand
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fmul    fTwo
@@:     fstp    fVFramePeriod

        ; 27) Find the vertical field period in milliseconds
        fld     fTotalVLines
        fmul    fHPeriod
        fdiv    fOneThousand
        fstp    fVFieldPeriod

        ; 28) Find the addressable vertical period per frame in milliseconds
        fld     fVLinesRnd
        fmul    fHPeriod
        fdiv    fOneThousand
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fmul    fTwo
@@:     fstp    fVAddrTimePerFrame

        ; 29) Find the addressable vertical period per field in milliseconds
        fld     fVLinesRnd
        fmul    fHPeriod
        fdiv    fOneThousand
        fstp    fVAddrTimePerField

        ; 30) Find the number of lines in teh odd blanking period
        fld     fVSyncPlusBackPorch
        fadd    fMinPorch
        fstp    fVOddBlankingLines

        ; 31) Find the odd blanking period in milliseconds
        fld     fVSyncPlusBackPorch
        fadd    fMinPorch
        fmul    fHPeriod
        fdiv    fOneThousand
        fstp    fVOddBlanking

        ; 32) Find the number of lines in the even blanking period
        fld     fVSyncPlusBackPorch
        fadd    fMinPorch
        fadd    fInterlace
        fadd    fInterlace
        fstp    fVEvenBlankingLines

        ; 33) Find the even blanking period in milliseconds
        fld     fVSyncPlusBackPorch
        fadd    fMinPorch
        fadd    fInterlace
        fadd    fInterlace
        fmul    fHPeriod
        fdiv    fOneThousand
        fstp    fVEvenBlanking

        ; 34) Find the top margin period in microseconds
        fld     fTopMarginLines
        fmul    fHPeriod
        fstp    fTopMargin

        ; 35) Find the odd front porch in microseconds
        fld     fMinPorch
        fadd    fInterlace
        fmul    fHPeriod
        fstp    fVOddFrontPorch

        ; 36) Find the number of lines in the odd front porch period
        fld     fMinPorch
        fadd    fInterlace
        fstp    fVOddFrontPorchLines

        ; 37) Find the even front porch period
        fld     fMinPorch
        fmul    fHPeriod
        fstp    fVEvenFrontPorch

        ; 38) Find the vertcial sync period in microseconds
        fld     fVSyncRqd
        fmul    fHPeriod
        fstp    fVSync

        ; 39) Find the even front porch period in microseconds
        fld     fVBackPorch
        fadd    fInterlace
        fmul    fHPeriod
        fstp    fVEvenBackPorch

        ; 40) Find the number of lines in the even fron tporch period
        fld     fVBackPorch
        fadd    fInterlace
        fstp    fVEvenBackPorchLines

        ; 41) Find the odd back porch period in microseconds
        fld     fVBackPorch
        fmul    fHPeriod
        fstp    fVOddBackPorch

        ; 42) Find the bottom margin period in microseconds
        fld     fBottomMarginLines
        fmul    fHPeriod
        fstp    fBottomMargin

        ; Cram all the data into GTFOut
        fld     fTotalHTimeChars
        fistp   es:[esi].GTFOUT.dwHTotalChars
        fld     fTotalLinesPerFrame
        fistp   es:[esi].GTFOUT.dwVTotalScans
        fld     fHAddrTimeChars
        fistp   es:[esi].GTFOUT.dwHActiveChars
        fld     fVLinesRnd
        fistp   es:[esi].GTFOUT.dwVActiveScans
        fld     fHAddrTimeChars
        fadd    fRightMarginChars
        fistp   es:[esi].GTFOUT.dwHBlankStartChar
        fld     fHFrontPorchChars
        fistp   es:[esi].GTFOUT.dwHFrontPorchChars
        fld     fHSyncChars
        fistp   es:[esi].GTFOUT.dwHSyncChars
        fld     fHBackPorchChars
        fistp   es:[esi].GTFOUT.dwHBackPorchChars
        fld     fTotalHTimeChars
        fsub    fLeftMarginChars
        fistp   es:[esi].GTFOUT.dwHBlankEndChar
        fld     fVLinesRnd
        fadd    fBottomMarginLines
        fistp   es:[esi].GTFOUT.dwVBlankStartScan
        fld     fVOddFrontPorchLines
        fistp   es:[esi].GTFOUT.dwVFrontPorchScans
        fld     fVSyncRqd
        fistp   es:[esi].GTFOUT.dwVSyncScans
        fld     fVEvenBackPorchLines
        fistp   es:[esi].GTFOUT.dwVBackPorchScans
        fld     fTotalLinesPerFrame
        fsub    fTopMarginLines
        fistp   es:[esi].GTFOUT.dwVBlankEndScan
        fld     fPixelFreq
;;;        fmul    fOneMillion
        fmul    fOneHundred
        fistp   es:[esi].GTFOUT.dwPixelClockIn10KHertz

        ; Return success
        mov     eax,1

Done:
        POPR    ds,ebx,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     SetupGTFConstants
;
; Purpose:      This function sets up all the "constants" used by
;               the GTF calculation. I make these constants into
;               variables because the spec says to -- at some point
;               in the future the GTF spec may be extended and they
;               want the flexibility to adjust these "constants" to
;               new values. By making the constants into variables
;               I just make the upgrade path easy.
;
;
; Arguments:
;
; Returns:      None
;
; Preserve:     ds,ebx,es,esi
;==============================================================================
DECPROC SetupGTFConstants, PASCAL, NOFRAME, NEAR
OPENPROC
        PUSHR   ds,ebx,es,esi

        ; This is the size of the top (or bottom -- they are the same)
        ; overscan area as a percentage of the total vertcical time.
        fld     fOnePointEight
        fstp    fMarginPercent

        ; Number of pixels per character cell
        fld     fEight
        fstp    fCellGran

        ; Minimum horizontal front porch in character cells and
        ; minimum vertical front porch in scanlines (they are the same.)
        fld     fOne
        fstp    fMinPorch

        ; Width of vsync pulse in scanlines
        fld     fThree
        fstp    fVSyncRqd

        ; Width of the hsync pulse as a percentage of horizontal line time
        fld     fEight
        fstp    fHSyncPercent

        ; minimum time for vertical sync plus back porch in microseconds
        fld     fFiveHundredFifty
        fstp    fMinVSyncPlusBackPorch

        ; These apply to the Basic Blanking Duty Cycle Equation.
        ; See the top of the file.
        fld     fSixHundred
        fstp    fGTF_M
        fld     fForty
        fstp    fGTF_C
        fld     fOneHundredTwentyEight
        fstp    fGTF_K
        fld     fTwenty
        fstp    fGTF_J

        ; This is forced by GTF definitions
        ; C' = ((C - J) * (K / 256) + J
        fld     fGTF_K
        fdiv    fTwoHundredFiftySix
        fld     fGTF_C
        fsub    fGTF_J
        fmulp   ST(1),ST(0)
        fadd    fGTF_J
        fstp    fGTF_CPrime

        ; This is forced by GTF definitions
        ; M' = (K / 256) * M
        fld     fGTF_K
        fdiv    fTwoHundredFiftySix
        fmul    fGTF_M
        fstp    fGTF_MPrime

        POPR    ds,ebx,es,esi
CLOSEPROC


;==============================================================================
;
; Function:     VerticalRefreshToStage1Parameters
;
; Purpose:      This function compautes GTF stage 1 parameters assuming
;               that the following parameters are given in the GTFIn struct.
;
;               These are always required by GTF:
;               HPixels    - the horizontal resolution
;               VLines     - the vertical resolution
;               MarginsRqd - this is a flag -- TRUE if borders, FLASE if none
;               IntRqd     - this is a flag -- TRUE if interlace, else FALSE
;
;               For this computation these parameters are:
;               IPParm     - This value is IPTYPE_VERTICAL_REFRESH_RATE
;               IPFreqRqd  - vertical refresh rate in hertz
;
; Arguments:    ds:ebx  ptr to lpGTFIn structure
;               You have the stack frame available to ComputeGTFParameters
;               but be careful about ptrs, because they are flat 32bit ptrs
;               if you are running under WinNT and 16:16 ptrs if you are
;               running under Win9X. You shouldn't need to load any ptrs
;               since lpGTFIn is already passed into this routine in the
;               correct format.
;
; Returns:      None
;
; Preserve:     ds,esi,edi,ebx
;==============================================================================
DECPROC VerticalRefreshToStage1Parameters, PASCAL, NOFRAME, NEAR
OPENPROC
        PUSHR   ds,ebx,es,esi

        ; 1) Make sure that the XResolution is a multiple of char cell size
        fild    ds:[ebx].GTFIN.dwHPixels
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
        fstp    fHPixelsRnd

        ; 2) If interlace is requested, half the number of vertical lines
        ;    since the calculation is really vertical lines per field
        fild    ds:[ebx].GTFIN.dwVLines
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fdiv    fTwo
@@:     fstp    fVLinesRnd

        ; 3) Find the frame rate required
        fild    ds:[ebx].GTFIN.dwIPFreqRqd
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fadd    ST(0),ST(0)
@@:     fstp    fVFieldRateRqd

        ; 4) Find the number of lines in the top margin
        fldz
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fMarginPercent
        fdiv    fOneHundred
        fmul    fVLinesRnd
@@:     fstp    fTopMarginLines

        ; 5) Find the number of lines in the bottom margin
        fldz
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fMarginPercent
        fdiv    fOneHundred
        fmul    fVLinesRnd
@@:     fstp    fBottomMarginLines

        ; 6) If interlace is required, set dwInterlace to 0.5
        fldz
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fZeroPointFive
@@:     fstp    fInterlace

        ; 7) Estimate the horizontal period
        fld1
        fdiv    fVFieldRateRqd
        fld     fMinVSyncPlusBackPorch
        fdiv    fOneMillion
        fsubp   ST(1),ST(0)
        fld     fVLinesRnd
        fadd    fTopMarginLines
        fadd    fTopMarginLines
        fadd    fMinPorch
        fadd    fInterlace
        fdivp   ST(1),ST(0)
        fmul    fOneMillion
        fstp    fHPeriodEst

        ; 8) Find the number of lines in fMinVSyncPlusBackPorch
        fld     fMinVSyncPlusBackPorch
        fdiv    fHPeriodEst
        fistp   dwTemp
        fild    dwTemp
        fstp    fVSyncPlusBackPorch

        ; 9) Find the number of lines in VBackPorch alone
        fld     fVSyncPlusBackPorch
        fsub    fVSyncRqd
        fstp    fVBackPorch

        ; 10) Find the total number of lines in the vertical field
        fld     fVLinesRnd
        fadd    fTopMarginLines
        fadd    fBottomMarginLines
        fadd    fVSyncPlusBackPorch
        fadd    fMinPorch
        fadd    fInterlace
        fstp    fTotalVLines

        ; 11) Estimate the vertical field frequency
        fld1
        fdiv    fHPeriodEst
        fdiv    fTotalVLines
        fmul    fOneMillion
        fstp    fVFieldRateEst

        ; 12) Find the actual horizontal period
        fld     fHPeriodEst
        fmul    fVFieldRateEst
        fdiv    fVFieldRateRqd
        fstp    fHPeriod

        ; 13) Find the actual vertical field frequency
        fld1
        fdiv    fHPeriod
        fdiv    fTotalVLines
        fmul    fOneMillion
        fstp    fVFieldRate

        ; 14) Find the vertical frame frequency
        fld     fVFieldRate
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fdiv    fTwo
@@:     fstp    fVFrameRate

        ; 15) Find the number of pixels in the left margin
        fldz
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fHPixelsRnd
        fmul    fMarginPercent
        fdiv    fOneHundred
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
@@:     fstp    fLeftMarginPixels

        ; 16) Find the number of pixels in the right margin
        fldz
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fHPixelsRnd
        fmul    fMarginPercent
        fdiv    fOneHundred
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
@@:     fstp    fRightMarginPixels

        ; 17) Find total number of active pixels in image+left+right margin
        fld     fHPixelsRnd
        fadd    fLeftMarginPixels
        fadd    fRightMarginPixels
        fstp    fTotalActivePixels

        ; 18) Find the ideal Blanking duty cycle
        fld     fGTF_CPrime
        fld     fGTF_MPrime
        fmul    fHPeriod
        fdiv    fOneThousand
        fsubp   ST(1),ST(0)
        fstp    fIdealDutyCycle

        ; 19) Find the number of pixels in the blanking time to the
        ; nearest double character cell
        fld     fTotalActivePixels
        fmul    fIdealDutyCycle
        fld     fOneHundred
        fsub    fIdealDutyCycle
        fdivp   ST(1),ST(0)
        fld     fCellGran
        fadd    ST(0),ST(0)
        fdivp   ST(1),ST(0)
        fistp   dwTemp
        fild    dwTemp
        fadd    ST(0),ST(0)
        fmul    fCellGran
        fstp    fHBlankPixels

        ; 20) Find the total number of pixels
        fld     fTotalActivePixels
        fadd    fHBlankPixels
        fstp    fTotalPixels

        ; 21) Find the pixel clock frequency
        fld     fTotalPixels
        fdiv    fHPeriod
        fstp    fPixelFreq

        ; 22) Find the horizontal frequency
        fld     fOneThousand
        fdiv    fHPeriod
        fstp    fHFreq

        POPR    ds,ebx,es,esi
CLOSEPROC


;==============================================================================
;
; Function:     HorizontalRefreshToStage1Parameters
;
; Purpose:      This function compautes GTF stage 1 parameters assuming
;               that the following parameters are given:
;
;               These are always required by GTF:
;               HPixels    - the horizontal resolution
;               VLines     - the vertical resolution
;               MarginsRqd - this is a flag -- TRUE if borders, FLASE if none
;               IntRqd     - this is a flag -- TRUE if interlace, else FALSE
;
;               For this computation these parameters are:
;               IPParm     - IPTYPE_HORIZONTAL_REFRESH_RATE
;               IPFreqRqd  - horizontal refresh rate in Kilohertz
;
; Arguments:
;
; Returns:      None
;
; Preserve:     ds,ebx,es,esi
;==============================================================================
DECPROC HorizontalRefreshToStage1Parameters, PASCAL, NOFRAME, NEAR
OPENPROC
        PUSHR   ds,ebx,es,esi

        ; 1) Make sure that the XResolution is a multiple of char cell size
        fild    ds:[ebx].GTFIN.dwHPixels
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
        fstp    fHPixelsRnd

        ; 2) If interlace is requested, half the number of vertical lines
        ;    since the calculation is really vertical lines per field
        fild    ds:[ebx].GTFIN.dwVLines
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fdiv    fTwo
@@:     fstp    fVLinesRnd

        ; 3) Find the horizontal freqency required
        fild    ds:[ebx].GTFIN.dwIPFreqRqd
        fstp    fHFreq

        ; 4) Find the number of lines in the top margin
        sub     eax,eax
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        fld     fMarginPercent
        fmul    fVLinesRnd
        fdiv    fOneHundred
@@:     fstp    fTopMarginLines

        ; 5) Find the number of lines in the bottom margin
        sub     eax,eax
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        fld     fMarginPercent
        fmul    fVLinesRnd
        fdiv    fOneHundred
@@:     fstp    fBottomMarginLines

        ; 6) If interlace is required, set dwInterlace to 0.5
        fldz
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fZeroPointFive
@@:     fstp    fInterlace

        ; 7) Find the number of lines in fMinVSyncPlusBackPorch
        fld     fMinVSyncPlusBackPorch
        fmul    fHFreq
        fdiv    fOneThousand
        fistp   dwTemp
        fild    dwTemp
        fstp    fVSyncPlusBackPorch

        ; 8) Find the number of lines in VBackPorch alone
        fld     fVSyncPlusBackPorch
        fsub    fVSyncRqd
        fstp    fVBackPorch

        ; 9) Find the total number of lines in the vertical field
        fld     fVLinesRnd
        fadd    fTopMarginLines
        fadd    fBottomMarginLines
        fadd    fVSyncPlusBackPorch
        fadd    fMinPorch
        fadd    fInterlace
        fstp    fTotalVLines

        ; 10) Find the actual vertical field frequency
        fld     fHFreq
        fdiv    fTotalVLines
        fmul    fOneThousand
        fstp    fVFieldRate

        ; 11) Find the vertical frame frequency
        fld     fVFieldRate
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fdiv    fTwo
@@:     fstp    fVFrameRate

        ; 12) Find the number of pixels in the left margin
        fldz
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fHPixelsRnd
        fmul    fMarginPercent
        fdiv    fOneHundred
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
@@:     fstp    fLeftMarginPixels

        ; 13) Find the number of pixels in the right margin
        fldz
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fHPixelsRnd
        fmul    fMarginPercent
        fdiv    fOneHundred
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
@@:     fstp    fRightMarginPixels

        ; 14) Find total number of active pixels in image+left+right margin
        fld     fHPixelsRnd
        fadd    fLeftMarginPixels
        fadd    fRightMarginPixels
        fstp    fTotalActivePixels

        ; 15) Find the ideal Blanking duty cycle
        fld     fGTF_CPrime
        fld     fGTF_MPrime
        fdiv    fHFreq
        fsubp   ST(1),ST(0)
        fstp    fIdealDutyCycle

        ; 16) Find the number of pixels in the blanking time to the
        ; nearest double character cell
        fld     fTotalActivePixels
        fmul    fIdealDutyCycle
        fld     fOneHundred
        fsub    fIdealDutyCycle
        fdivp   ST(1),ST(0)
        fld     fCellGran
        fadd    ST(0),ST(0)
        fdivp   ST(1),ST(0)
        fistp   dwTemp
        fild    dwTemp
        fadd    ST(0),ST(0)
        fmul    fCellGran
        fstp    fHBlankPixels

        ; 17) Find the total number of pixels
        fld     fTotalActivePixels
        fadd    fHBlankPixels
        fstp    fTotalPixels

        ; 18) Find the horizontal frequency
        fld     fOneThousand
        fdiv    fHFreq
        fstp    fHPeriod

        ; 19) Find the pixel clock frequency
        fld     fTotalPixels
        fmul    fHFreq
        fdiv    fOneThousand
        fstp    fPixelFreq

        POPR    ds,ebx,es,esi
CLOSEPROC


;==============================================================================
;
; Function:     PixelClockToStage1Parameters
;
; Purpose:      This function compautes GTF stage 1 parameters assuming
;               that the following parameters are given:
;
;               These are always required by GTF:
;               HPixels    - the horizontal resolution
;               VLines     - the vertical resolution
;               MarginsRqd - this is a flag -- TRUE if borders, FLASE if none
;               IntRqd     - this is a flag -- TRUE if interlace, else FALSE
;
;               For this computation these parameters are:
;               IPParm     - IPTYPE_PIXEL_CLOCK_RATE
;               IPFreqRqd  - pixel clock rate in Megahertz
;
; Arguments:
;
; Returns:      None
;
; Preserve:     ds,ebx,es,esi
;==============================================================================
DECPROC PixelClockToStage1Parameters, PASCAL, NOFRAME, NEAR
OPENPROC
        PUSHR   ds,ebx,es,esi

        ; 1) Make sure that the XResolution is a multiple of char cell size
        fild    ds:[ebx].GTFIN.dwHPixels
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
        fstp    fHPixelsRnd

        ; 2) If interlace is requested, half the number of vertical lines
        ;    since the calculation is really vertical lines per field
        fild    ds:[ebx].GTFIN.dwVLines
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fdiv    fTwo
@@:     fstp    fVLinesRnd

        ; 3) Find the horizontal freqency required
        fild    ds:[ebx].GTFIN.dwIPFreqRqd
        fstp    fPixelFreq

        ; 4) Find the number of pixels in the left margin
        fldz
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fHPixelsRnd
        fmul    fMarginPercent
        fdiv    fOneHundred
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
@@:     fstp    fLeftMarginPixels

        ; 5) Find the number of pixels in the right margin
        fldz
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fHPixelsRnd
        fmul    fMarginPercent
        fdiv    fOneHundred
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
@@:     fstp    fRightMarginPixels

        ; 6) Find total number of active pixels in image+left+right margin
        fld     fHPixelsRnd
        fadd    fLeftMarginPixels
        fadd    fRightMarginPixels
        fstp    fTotalActivePixels

        ; 7) Find the ideal horizontal period from blanking duty cycle Eq
        fld     fOneHundred
        fsub    fGTF_CPrime
        fmul    ST(0),ST(0)
        fld     fTotalActivePixels
        fadd    fLeftMarginPixels
        fadd    fRightMarginPixels
        fmul    fGTF_MPrime
        fmul    fZeroPointFour
        fdiv    fPixelFreq
        faddp   ST(1),ST(0)
        fsqrt
        fadd    fGTF_CPrime
        fsub    fOneHundred
        fdiv    fTwo
        fdiv    fGTF_MPrime
        fmul    fOneThousand
        fstp    fIdealHPeriod

        ; 8) Find the ideal Blanking duty cycle
        fld     fGTF_CPrime
        fld     fGTF_MPrime
        fmul    fIdealHPeriod
        fdiv    fOneThousand
        fsubp   ST(1),ST(0)
        fstp    fIdealDutyCycle

        ; 9) Find the number of pixels in the blanking time to the
        ; nearest double character cell
        fld     fTotalActivePixels
        fmul    fIdealDutyCycle
        fld     fOneHundred
        fsub    fIdealDutyCycle
        fdivp   ST(1),ST(0)
        fld     fCellGran
        fadd    ST(0),ST(0)
        fdivp   ST(1),ST(0)
        fistp   dwTemp
        fild    dwTemp
        fadd    ST(0),ST(0)
        fmul    fCellGran
        fstp    fHBlankPixels

        ; 10) Find the total number of pixels
        fld     fTotalActivePixels
        fadd    fHBlankPixels
        fstp    fTotalPixels

        ; 11) Find the horizontal frequency
        fld     fPixelFreq
        fdiv    fTotalPixels
        fmul    fOneThousand
        fstp    fHFreq

        ; 12) Find the horizontal period
        fld     fOneThousand
        fdiv    fHFreq
        fstp    fHPeriod

        ; 13) Find the number of lines in the top margin
        fldz    
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        fld     fMarginPercent
        fmul    fVLinesRnd
        fdiv    fOneHundred
@@:     fstp    fTopMarginLines

        ; 14) Find the number of lines in the bottom margin
        fldz
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        fld     fMarginPercent
        fmul    fVLinesRnd
        fdiv    fOneHundred
@@:     fstp    fBottomMarginLines

        ; 15) If interlace is required, set dwInterlace to 0.5
        fldz
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fZeroPointFive
@@:     fstp    fInterlace

        ; 16) Find the number of lines in fMinVSyncPlusBackPorch
        fld     fMinVSyncPlusBackPorch
        fmul    fHFreq
        fdiv    fOneThousand
        fstp    fVSyncPlusBackPorch

        ; 17) Find the number of lines in VBackPorch alone
        fld     fVSyncPlusBackPorch
        fsub    fVSyncRqd
        fstp    fVBackPorch

        ; 18) Find the total number of lines in the vertical field
        fld     fVLinesRnd
        fadd    fTopMarginLines
        fadd    fBottomMarginLines
        fadd    fVSyncPlusBackPorch
        fadd    fMinPorch
        fadd    fInterlace
        fstp    fTotalVLines

        ; 19) Find the actual vertical field frequency
        fld     fHFreq
        fdiv    fTotalVLines
        fmul    fOneThousand
        fstp    fVFieldRate

        ; 20) Find the vertical frame frequency
        fld     fVFieldRate
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fdiv    fTwo
@@:     fstp    fVFrameRate

        POPR    ds,ebx,es,esi
CLOSEPROC


;==============================================================================
;
; Function:     Divide32By32
;
; Purpose:      This function divides a 32bit number by another 32bit
;               number. The problem is that the 16bit compiler can't do
;               this without linking in a library.
;
; Arguments:
;
; Returns:      quotient.
;
; Preserve:     All registers
;==============================================================================
IFDEF _WIN32
DECPROC Divide32By32, STANDARD, FRAME, NEAR
ELSE
DECPROC Divide32By32, PASCAL, FRAME, FAR16
ENDIF
PARMD   dwDividend
PARMD   dwDivisor
OPENPROC
        sub     edx,edx
        mov     eax,dwDividend
        cmp     dwDivisor,edx
        jne     valid
divbyzero:
        cmp     eax,edx                 ; is numerator zero?
        je      done                    ; yes - eax:edx = 0
        mov     eax,-1                  ; no - call it infinity
        mov     edx,-1                  ; eax:edx = -1
        jmp     done
valid:  
        div     dwDivisor
done:
IFNDEF _WIN32
        mov     edx,eax
        shr     edx,10H
ENDIF
CLOSEPROC


;==============================================================================
;
; Function:     Multiply32By32
;
; Purpose:      This function multiplies a 32bit number by another 32bit
;               number. The problem is that the 16bit compiler can't do
;               this without linking in a library.
;
; Arguments:
;
; Returns:      quotient.
;
; Preserve:     All registers
;==============================================================================
IFDEF _WIN32
DECPROC Multiply32By32, STANDARD, FRAME, NEAR
ELSE
DECPROC Multiply32By32, PASCAL, FRAME, FAR16
ENDIF
PARMD   dwMult1
PARMD   dwMult2
OPENPROC
        mov     eax,dwMult1
        imul    eax,dwMult2
IFNDEF _WIN32
        mov     edx,eax
        shr     edx,10H
ENDIF
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\modeset.mhd\CODE\gtfmathc.c ===
#if !defined(_WIN32) || defined(_WIN64)
/*
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gtfmath.c (ported from gtfmath.asm)
;
; Purpose:      This file implements the GTF algorithm
;
;       Just some important comments and definitions extracted from
;       the GTF document.
;
;       Horizontal - negative
;       Vertical - positive
;       composite - negative
;
;       Blanking Duty Cycle = (1 - tA / T) * 100%
;                     = (       1 - (F * n) / p) * 100%
;               tA = active video time
;               T  = Horizontal period
;               F  = horizontal frequency
;               n  = number of active pixels (Xresolution)
;               p = pixel clock frequency
;
;       Basic form of equation is:
;       Blanking Duty Cycle = C' - (M' / F)
;
;       C' = ((C - J) * (K / 256) + J
;       M' = (K / 256) * M
;
;       Margin% = 1.8%
;       size of top and bottom overscan margin as % of active vertical
;       size of left and right overscan margin as % of active vertical
;
;       CellGran = 8 pixels
;       character cell granularity
;
;       MinPorch = 1 line / 1 char cell
;       Minimum front porch in lines and character cells
;
;       VsyncRqd = 3 lines
;       width of the vsync pulse in scanlines
;
;       HSyncPercent = 8%
;       The width of HSync as a percentage of the total line period
;
;       MinVSyncPlusBackPorch  550us
;       minimum time for vertical sync plus back porch
;
;       M       600% / Khz
;       blanking formula gradient
;
;       C       40%
;       blanking formula offset
;
;       K       128
;       blanking formula scaling factor
;
;       J       20%
;       blanking formula scaling factor weighting
;
;       HPixels    - the horizontal resolution
;       VLines     - the vertical resolution
;       MarginsRqd - this is a flag -- TRUE if borders, FLASE if none
;       IntRqd     - this is a flag -- TRUE if interlace, FALSE otherwise
;       IPParm     - this indicates what the last specifying parm will be
;               1  - VFrameRateRqd
;               2  - HFreq
;               3  - PixelClock
;       IPFreqRqd  - Depends upon VPParm
;               If IPParm is this       IPFreqRqd is this
;               1                       vertical refresh rate in hz
;               2                       horizontal refresh rate in Kilohz
;               3                       pixel clock rate in Megahz
;
;       Interestingly enough, the GTF spec says that any monitor that
;       has the GTF bit set, MUST have a Monitor Description Block in
;       the EDID that tells the monitor frequency limits. If this block
;       does not exist, then the monitor should be trated as non-GTF
;       compliant. Byte 10, bit 0 = 1 means that overscan margins are
;       required.
;==============================================================================
*/
#include "cmntypes.h"
#include "gtfmath.h"

/*
 * These math routines need to be defined in the OS specific code.
 */
float calcROUND(float);
float calcFLOOR(float);
float calcSQRT(float);

#define const_fZero                     0.0f
#define const_fZeroPointFour            0.4f
#define const_fZeroPointFive            0.5f
#define const_fOne                      1.0f
#define const_fOnePointEight            1.8f
#define const_fTwo                      2.0f
#define const_fThree                    3.0f
#define const_fEight                    8.0f
#define const_fTwenty                   20.0f
#define const_fForty                    40.0f
#define const_fOneHundred               100.0f
#define const_fOneHundredTwentyEight    128.0f
#define const_fTwoHundredFiftySix       256.0f
#define const_fFiveHundredFifty         550.0f
#define const_fSixHundred               600.0f
#define const_fOneThousand              1000.0f
#define const_fOneMillion               1000000.0f

static float    fTemp;
static float    fVLinesRnd;
static float    fAddrLinesPerFrame;
static float    fCellGran;
static float    fPixelFreq;
static float    fCharTime;
static float    fTopMarginLines;
static float    fBottomMarginLines;
static float    fVSyncPlusBackPorch;
static float    fMinPorch;
static float    fInterlace;
static float    fTotalLinesPerFrame;
static float    fTotalPixels;
static float    fTotalHTimeChars;
static float    fHPixelsRnd;
static float    fHAddrTime;
static float    fHAddrTimeChars;
static float    fHBlankPixels;
static float    fHBlank;
static float    fHBlankChars;
static float    fLeftMarginPixels;
static float    fRightMarginPixels;
static float    fHBlankPlusMargin;
static float    fHBlankPlusMarginChars;
static float    fActualDutyCycle;
static float    fBlankPlusMarginDutyCycle;
static float    fLeftMargin;
static float    fLeftMarginChars;
static float    fRightMargin;
static float    fRightMarginChars;
static float    fHSyncPercent;
static float    fHSyncPixels;
static float    fHFrontPorchPixels;
static float    fHBackPorchPixels;
static float    fHSyncChars;
static float    fHSync;
static float    fHFrontPorchChars;
static float    fHFrontPorch;
static float    fHBackPorchChars;
static float    fHBackPorch;
static float    fTotalVLines;
static float    fHPeriod;
static float    fVFramePeriod;
static float    fVFieldPeriod;
static float    fVAddrTimePerFrame;
static float    fVAddrTimePerField;
static float    fVOddBlankingLines;
static float    fVOddBlanking;
static float    fVEvenBlankingLines;
static float    fVEvenBlanking;
static float    fTopMargin;
static float    fVOddFrontPorch;
static float    fVOddFrontPorchLines;
static float    fVEvenFrontPorch;
static float    fVSyncRqd;
static float    fVSync;
static float    fVEvenBackPorch;
static float    fVBackPorch;
static float    fVEvenBackPorchLines;
static float    fVOddBackPorch;
static float    fBottomMargin;
static float    fMarginPercent;
static float    fMinVSyncPlusBackPorch;
static float    fGTF_M;
static float    fGTF_C;
static float    fGTF_J;
static float    fGTF_K;
static float    fGTF_CPrime;
static float    fGTF_MPrime;
static float    fVFieldRateRqd;
static float    fHPeriodEst;
static float    fVFieldRateEst;
static float    fVFieldRate;
static float    fVFrameRate;
static float    fTotalActivePixels;
static float    fIdealDutyCycle;
static float    fHFreq;
static float    fIdealHPeriod;
/*
;==============================================================================
;
; Function:     SetupGTFConstants
;
; Purpose:      This function sets up all the "constants" used by
;               the GTF calculation. I make these constants into
;               variables because the spec says to -- at some point
;               in the future the GTF spec may be extended and they
;               want the flexibility to adjust these "constants" to
;               new values. By making the constants into variables
;               I just make the upgrade path easy.
;
; Returns:      None
;
;==============================================================================
*/
static void SetupGTFConstants
(
    void
)
{
    /*
     * This is the size of the top (or bottom -- they are the same)
     * overscan area as a percentage of the total vertcical time.
     */
    fMarginPercent = const_fOnePointEight;
    /*
     * Number of pixels per character cell
     */
    fCellGran = const_fEight;
    /*
     * Minimum horizontal front porch in character cells and
     * minimum vertical front porch in scanlines (they are the same.)
     */
    fMinPorch = const_fOne;
    /*
     * Width of vsync pulse in scanlines
     */
    fVSyncRqd = const_fThree;
    /*
     * Width of the hsync pulse as a percentage of horizontal line time
     */
    fHSyncPercent = const_fEight;
    /*
     * minimum time for vertical sync plus back porch in microseconds
     */
    fMinVSyncPlusBackPorch = const_fFiveHundredFifty;
    /*
     * These apply to the Basic Blanking Duty Cycle Equation.
     * See the top of the file.
     */
    fGTF_M = const_fSixHundred;
    fGTF_C = const_fForty;
    fGTF_K = const_fOneHundredTwentyEight;
    fGTF_J = const_fTwenty;
    /*
     * This is forced by GTF definitions
     * C' = ((C - J) * (K / 256) + J
     *         fld     fGTF_K
     *         fdiv    fTwoHundredFiftySix
     *         fld     fGTF_C
     *         fsub    fGTF_J
     *         fmulp   ST(1),ST(0)
     *         fadd    fGTF_J
     *         fstp    fGTF_CPrime
     */
    fGTF_CPrime = ((fGTF_C - fGTF_J) 
                *  (fGTF_K / const_fTwoHundredFiftySix))
                + fGTF_J;
    /*
     * This is forced by GTF definitions
     * M' = (K / 256) * M
     */
    fGTF_MPrime = (fGTF_K / const_fTwoHundredFiftySix) * fGTF_M;
    return;
}
/*
;==============================================================================
;
; Function:     VerticalRefreshToStage1Parameters
;
; Purpose:      This function compautes GTF stage 1 parameters assuming
;               that the following parameters are given in the GTFIn struct.
;
;               These are always required by GTF:
;               HPixels    - the horizontal resolution
;               VLines     - the vertical resolution
;               MarginsRqd - this is a flag -- TRUE if borders, FLASE if none
;               IntRqd     - this is a flag -- TRUE if interlace, else FALSE
;
;               For this computation these parameters are:
;               IPParm     - This value is IPTYPE_VERTICAL_REFRESH_RATE
;               IPFreqRqd  - vertical refresh rate in hertz
;
; Returns:      None
;
;==============================================================================
*/
static void VerticalRefreshToStage1Parameters
(
    LPGTFIN  lpGtfIn
)
{
    /*
     * 1) Make sure that the XResolution is a multiple of char cell size
     *
     * [H PIXELS RND] = ROUND([H PIXELS] / [CELL GRAN RND], 0) * [CELL GRAN RND]
     */
    fHPixelsRnd = calcROUND((float)lpGtfIn->dwHPixels / fCellGran) * fCellGran;
    /*
     * 2) If interlace is requested, half the number of vertical lines
     *    since the calculation is really vertical lines per field
     *
     * [V LINES RND] = IF([INT RQD?]="y", ROUND([V LINES] / 2, 0),
     *                                    ROUND([V LINES], 0))
     */
    fVLinesRnd = (float)lpGtfIn->dwVLines;
    if (lpGtfIn->dwIntRqd != 0)
        fVLinesRnd /= const_fTwo;
    fVLinesRnd = calcROUND(fVLinesRnd);
    /*
     * 3) Find the frame rate required
     *
     * [V FIELD RATE RQD] = IF([INT RQD?]="y", [I/P FREQ RQD] * 2,
     *                                         [I/P FREQ RQD])
     */
    fVFieldRateRqd = (float)lpGtfIn->dwIPFreqRqd;
    if (lpGtfIn->dwIntRqd != 0)
        fVFieldRateRqd += fVFieldRateRqd;
    /*
     * 4) Find the number of lines in the top margin
     *
     * [TOP MARGIN (LINES)] = IF([MARGINS RQD?]="Y", ROUND(([MARGIN%] / 100 * [V LINES RND]), 0),
     *                                               0)
     */
    if (lpGtfIn->dwMarginsRqd != 0)
        fTopMarginLines = calcROUND(fMarginPercent / const_fOneHundred * fVLinesRnd);
    else
        fTopMarginLines = const_fZero;
    /*
     * 5) Find the number of lines in the bottom margin
     *
     * [BOT MARGIN (LINES)] = IF([MARGINS RQD?]="Y", ROUND(([MARGIN%] / 100 * [V LINES RND]), 0),
     *                                               0)
     */
    if (lpGtfIn->dwMarginsRqd != 0)
        fBottomMarginLines = calcROUND(fMarginPercent / const_fOneHundred * fVLinesRnd);
    else
        fBottomMarginLines = const_fZero;
    /*
     * 6) If interlace is required, set dwInterlace to 0.5
     *
     * [INTERLACE]=IF([INT RQD?] = "y", 0.5,
     *                                  0)
     */
    if (lpGtfIn->dwIntRqd != 0)
        fInterlace = const_fZeroPointFive;
    else
        fInterlace = const_fZero;
    /*
     * 7) Estimate the horizontal period
     *
     * [H PERIOD EST] = ((1 / [V FIELD RATE RQD]) - [MIN VSYNC+BP] / 1000000)
     *                / ([V LINES RND] + (2 * [TOP MARGIN (LINES)]) + [MIN PORCH RND] + [INTERLACE])
     *                * 1000000
     */
    fHPeriodEst = ((const_fOne / fVFieldRateRqd) - fMinVSyncPlusBackPorch / const_fOneMillion)
                / (fVLinesRnd + (const_fTwo * fTopMarginLines) + fMinPorch + fInterlace)
                * const_fOneMillion;
    /*
     * 8) Find the number of lines in fMinVSyncPlusBackPorch
     *
     * [V SYNC+BP] = ROUND(([MIN VSYNC+BP] / [H PERIOD EST]) ,0)
     */
    fVSyncPlusBackPorch = calcROUND(fMinVSyncPlusBackPorch / fHPeriodEst);
    /*
     * 9) Find the number of lines in VBackPorch alone
     *
     * [V BACK PORCH] = [V SYNC+BP] - [V SYNC RND]
     */
    fVBackPorch = fVSyncPlusBackPorch - fVSyncRqd;
    /*
     * 10) Find the total number of lines in the vertical field
     *
     * [TOTAL V LINES] = [V LINES RND] + [TOP MARGIN (LINES)] + [BOT MARGIN (LINES)]
     *                 + [V SYNC+BP] + [INTERLACE] + [MIN PORCH RND]
     */
    fTotalVLines = fVLinesRnd
                 + fTopMarginLines
                 + fBottomMarginLines
                 + fVSyncPlusBackPorch
                 + fInterlace
                 + fMinPorch;
    /*
     * 11) Estimate the vertical field frequency
     *
     * [V FIELD RATE EST] = 1 / [H PERIOD EST] / [TOTAL V LINES] * 1000000
     */
    fVFieldRateEst = const_fOne / fHPeriodEst / fTotalVLines * const_fOneMillion;
    /*
     * 12) Find the actual horizontal period
     *
     * [H PERIOD] = [H PERIOD EST] / ([V FIELD RATE RQD] / [V FIELD RATE EST])
     */
    fHPeriod = fHPeriodEst / (fVFieldRateRqd / fVFieldRateEst);
    /*
     * 13) Find the actual vertical field frequency
     *
     * [V FIELD RATE] = 1 / [H PERIOD] / [TOTAL V LINES] * 1000000
     */
    fVFieldRate = const_fOne / fHPeriod / fTotalVLines * const_fOneMillion;
    /*
     * 14) Find the vertical frame frequency
     *
     * [V FRAME RATE] = IF([INT RQD?]="y", [V FIELD RATE] / 2,
     *                                     [V FIELD RATE])
     */
    fVFrameRate = fVFieldRate;
    if (lpGtfIn->dwIntRqd != 0)
        fVFrameRate /= const_fTwo;
    /*
     * 15) Find the number of pixels in the left margin
     *
     * [LEFT MARGIN (PIXELS)] = IF([MARGINS RQD?]="Y", ROUND([H PIXELS RND] * [MARGIN%] / 100 / [CELL GRAN RND], 0) * [CELL GRAN RND],
     *                                                 0)
     */
    if (lpGtfIn->dwMarginsRqd)
    {
        fLeftMarginPixels = calcROUND(fHPixelsRnd * fMarginPercent / const_fOneHundred / fCellGran)
                          * fCellGran;
    }
    else
        fLeftMarginPixels = const_fZero;
    /*
     * 16) Find the number of pixels in the right margin
     *
     * [RIGHT MARGIN (PIXELS)] = IF([MARGINS RQD?]="Y", ROUND([H PIXELS RND] * [MARGIN%] / 100 / [CELL GRAN RND], 0) * [CELL GRAN RND],
     *                                                  0)
     */
    if (lpGtfIn->dwMarginsRqd != 0)
    {
        fRightMarginPixels = calcROUND(fHPixelsRnd * fMarginPercent / const_fOneHundred / fCellGran)
                           * fCellGran;
    }
    else
        fRightMarginPixels = const_fZero;
    /*
     * 17) Find total number of active pixels in image+left+right margin
     *
     * [TOTAL ACTIVE PIXELS] = [H PIXELS RND] + [LEFT MARGIN (PIXELS)] + [RIGHT MARGIN (PIXELS)]
     */
    fTotalActivePixels = fHPixelsRnd
                       + fLeftMarginPixels
                       + fRightMarginPixels;
    /*
     * 18) Find the ideal Blanking duty cycle
     *
     * [IDEAL DUTY CYCLE] = [C'] - ([M'] * [H PERIOD] / 1000)
     */
    fIdealDutyCycle = fGTF_CPrime
                    - (fGTF_MPrime * fHPeriod / const_fOneThousand);
    /*
     * 19) Find the number of pixels in the blanking time to the
     * nearest double character cell
     *
     * [H BLANK (PIXELS)] = ROUND([TOTAL ACTIVE PIXELS] * [IDEAL DUTY CYCLE]
     *                    /       (100 - [IDEAL DUTY CYCLE])
     *                    /       (2 * [CELL GRAN RND]), 0)
     *                    * (2 * [CELL GRAN RND])
     */
    fHBlankPixels = calcROUND((fTotalActivePixels * fIdealDutyCycle
                  /            (const_fOneHundred - fIdealDutyCycle)
                  /            (const_fTwo * fCellGran)))
                  * (const_fTwo * fCellGran);
    /*
     * 20) Find the total number of pixels
     *
     * [TOTAL PIXELS] = [TOTAL ACTIVE PIXELS] + [H BLANK (PIXELS)]
     */
    fTotalPixels = fTotalActivePixels + fHBlankPixels;
    /*
     * 21) Find the pixel clock frequency
     *
     * [PIXEL FREQ] = [TOTAL PIXELS] / [H PERIOD]
     */
    fPixelFreq = fTotalPixels / fHPeriod;
    /*
     * 22) Find the horizontal frequency
     *
     * [H FREQ] = 1000 / [H PERIOD]
     */
    fHFreq = const_fOneThousand / fHPeriod;
    return;
}
/*
;==============================================================================
;
; Function:     HorizontalRefreshToStage1Parameters
;
; Purpose:      This function compautes GTF stage 1 parameters assuming
;               that the following parameters are given:
;
;               These are always required by GTF:
;               HPixels    - the horizontal resolution
;               VLines     - the vertical resolution
;               MarginsRqd - this is a flag -- TRUE if borders, FLASE if none
;               IntRqd     - this is a flag -- TRUE if interlace, else FALSE
;
;               For this computation these parameters are:
;               IPParm     - IPTYPE_HORIZONTAL_REFRESH_RATE
;               IPFreqRqd  - horizontal refresh rate in Kilohertz
;
; Returns:      None
;
;==============================================================================
*/
static void HorizontalRefreshToStage1Parameters
(
    LPGTFIN  lpGtfIn
)
{
    /*
     * 1) Make sure that the XResolution is a multiple of char cell size
     *         fild    ds:[ebx].GTFIN.dwHPixels
     *         fdiv    fCellGran
     *         fistp   dwTemp
     *         fild    dwTemp
     *         fmul    fCellGran
     *         fstp    fHPixelsRnd
     */
    fHPixelsRnd = calcROUND((float)lpGtfIn->dwHPixels / fCellGran)
                * fCellGran;
    /*
     * 2) If interlace is requested, half the number of vertical lines
     *    since the calculation is really vertical lines per field
     *         fild    ds:[ebx].GTFIN.dwVLines
     *         cmp     ds:[ebx].GTFIN.dwIntRqd,0
     *         je      @F
     *         fdiv    fTwo
     * @@:     fstp    fVLinesRnd
     */
    fVLinesRnd = (float)lpGtfIn->dwVLines;
    if (lpGtfIn->dwIntRqd != 0)
        fVLinesRnd /= const_fTwo;
    fVLinesRnd = calcROUND(fVLinesRnd);
    /*
     * 3) Find the horizontal freqency required
     *         fild    ds:[ebx].GTFIN.dwIPFreqRqd
     *         fstp    fHFreq
     */
    fHFreq = (float)lpGtfIn->dwIPFreqRqd;
    /*
     * 4) Find the number of lines in the top margin
     *         sub     eax,eax
     *         cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
     *         je      @F
     *         fld     fMarginPercent
     *         fmul    fVLinesRnd
     *         fdiv    fOneHundred
     * @@:     fstp    fTopMarginLines
     */
    if (lpGtfIn->dwMarginsRqd != 0)
        fTopMarginLines = calcROUND(fMarginPercent / const_fOneHundred * fVLinesRnd);
    else
        fTopMarginLines = const_fZero;
    /*
     * 5) Find the number of lines in the bottom margin
     *         sub     eax,eax
     *         cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
     *         je      @F
     *         fld     fMarginPercent
     *         fmul    fVLinesRnd
     *         fdiv    fOneHundred
     * @@:     fstp    fBottomMarginLines
     */
    if (lpGtfIn->dwMarginsRqd != 0)
        fBottomMarginLines = fMarginPercent / const_fOneHundred * fVLinesRnd;
    else
        fBottomMarginLines = const_fZero;
    /*
     * 6) If interlace is required, set dwInterlace to 0.5
     *         fldz
     *         cmp     ds:[ebx].GTFIN.dwIntRqd,0
     *         je      @F
     *         faddp   ST(0),ST(0)             ; pop the stack
     *         fld     fZeroPointFive
     * @@:     fstp    fInterlace
     */
    if (lpGtfIn->dwIntRqd != 0)
        fInterlace = const_fZeroPointFive;
    else
        fInterlace = const_fZero;
    /*
     * 7) Find the number of lines in fMinVSyncPlusBackPorch
     *         fld     fMinVSyncPlusBackPorch
     *         fmul    fHFreq
     *         fdiv    fOneThousand
     *         fistp   dwTemp
     *         fild    dwTemp
     *         fstp    fVSyncPlusBackPorch
     */
    fVSyncPlusBackPorch = calcROUND(fMinVSyncPlusBackPorch * fHFreq / const_fOneThousand);
    /*
     * 8) Find the number of lines in VBackPorch alone
     *         fld     fVSyncPlusBackPorch
     *         fsub    fVSyncRqd
     *         fstp    fVBackPorch
     */
    fVBackPorch = fVSyncPlusBackPorch - fVSyncRqd;
    /*
     * 9) Find the total number of lines in the vertical field
     *         fld     fVLinesRnd
     *         fadd    fTopMarginLines
     *         fadd    fBottomMarginLines
     *         fadd    fVSyncPlusBackPorch
     *         fadd    fMinPorch
     *         fadd    fInterlace
     *         fstp    fTotalVLines
     */
    fTotalVLines = fVLinesRnd
                 + fTopMarginLines
                 + fBottomMarginLines
                 + fInterlace
                 + fVSyncPlusBackPorch
                 + fMinPorch;
    /*
     * 10) Find the actual vertical field frequency
     *         fld     fHFreq
     *         fdiv    fTotalVLines
     *         fmul    fOneThousand
     *         fstp    fVFieldRate
     */
    fVFieldRate = fHFreq / fTotalVLines * const_fOneThousand;
    /*
     * 11) Find the vertical frame frequency
     *         fld     fVFieldRate
     *         cmp     ds:[ebx].GTFIN.dwIntRqd,0
     *         je      @F
     *         fdiv    fTwo
     * @@:     fstp    fVFrameRate
     */
    fVFrameRate = fVFieldRate;
    if (lpGtfIn->dwIntRqd != 0)
        fVFrameRate /= const_fTwo;
    /*
     * 12) Find the number of pixels in the left margin
     *         fldz
     *         cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
     *         je      @F
     *         faddp   ST(0),ST(0)             ; pop the stack
     *         fld     fHPixelsRnd
     *         fmul    fMarginPercent
     *         fdiv    fOneHundred
     *         fdiv    fCellGran
     *         fistp   dwTemp
     *         fild    dwTemp
     *         fmul    fCellGran
     * @@:     fstp    fLeftMarginPixels
     */
    if (lpGtfIn->dwMarginsRqd != 0)
    {
        fLeftMarginPixels = calcROUND(fHPixelsRnd * fMarginPercent / const_fOneHundred / fCellGran)
                          * fCellGran;
    }
    else
        fLeftMarginPixels = const_fZero;
    /*
     * 13) Find the number of pixels in the right margin
     *         fldz
     *         cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
     *         je      @F
     *         faddp   ST(0),ST(0)             ; pop the stack
     *         fld     fHPixelsRnd
     *         fmul    fMarginPercent
     *         fdiv    fOneHundred
     *         fdiv    fCellGran
     *         fistp   dwTemp
     *         fild    dwTemp
     *         fmul    fCellGran
     * @@:     fstp    fRightMarginPixels
     */
    if (lpGtfIn->dwMarginsRqd != 0)
    {
        fRightMarginPixels = calcROUND(fHPixelsRnd * fMarginPercent / const_fOneHundred / fCellGran)
                           * fCellGran;
    }
    else
        fRightMarginPixels = const_fZero;
    /*
     * 14) Find total number of active pixels in image+left+right margin
     *         fld     fHPixelsRnd
     *         fadd    fLeftMarginPixels
     *         fadd    fRightMarginPixels
     *         fstp    fTotalActivePixels
     */
    fTotalActivePixels = fHPixelsRnd
                       + fLeftMarginPixels
                       + fRightMarginPixels;
    /*
     * 15) Find the ideal Blanking duty cycle
     *         fld     fGTF_CPrime
     *         fld     fGTF_MPrime
     *         fdiv    fHFreq
     *         fsubp   ST(1),ST(0)
     *         fstp    fIdealDutyCycle
     */
    fIdealDutyCycle = fGTF_CPrime - (fGTF_MPrime / fHFreq);
    /*
     * 16) Find the number of pixels in the blanking time to the
     * nearest double character cell
     *         fld     fTotalActivePixels
     *         fmul    fIdealDutyCycle
     *         fld     fOneHundred
     *         fsub    fIdealDutyCycle
     *         fdivp   ST(1),ST(0)
     *         fld     fCellGran
     *         fadd    ST(0),ST(0)
     *         fdivp   ST(1),ST(0)
     *         fistp   dwTemp
     *         fild    dwTemp
     *         fadd    ST(0),ST(0)
     *         fmul    fCellGran
     *         fstp    fHBlankPixels
     */
    fHBlankPixels = calcROUND((fTotalActivePixels * fIdealDutyCycle
                  /            (const_fOneHundred - fIdealDutyCycle)
                  /            (const_fTwo * fCellGran)))
                  * (const_fTwo *fCellGran);
    /*
     * 17) Find the total number of pixels
     *         fld     fTotalActivePixels
     *         fadd    fHBlankPixels
     *         fstp    fTotalPixels
     */
    fTotalPixels = fTotalActivePixels + fHBlankPixels;
    /*
     * 18) Find the horizontal frequency
     *         fld     fOneThousand
     *         fdiv    fHFreq
     *         fstp    fHPeriod
     */
    fHPeriod = const_fOneThousand / fHFreq;
    /*
     * 19) Find the pixel clock frequency
     *         fld     fTotalPixels
     *         fmul    fHFreq
     *         fdiv    fOneThousand
     *         fstp    fPixelFreq
     */
    fPixelFreq = fTotalPixels * fHFreq / const_fOneThousand;
    return;
}
/*
;==============================================================================
;
; Function:     PixelClockToStage1Parameters
;
; Purpose:      This function compautes GTF stage 1 parameters assuming
;               that the following parameters are given:
;
;               These are always required by GTF:
;               HPixels    - the horizontal resolution
;               VLines     - the vertical resolution
;               MarginsRqd - this is a flag -- TRUE if borders, FLASE if none
;               IntRqd     - this is a flag -- TRUE if interlace, else FALSE
;
;               For this computation these parameters are:
;               IPParm     - IPTYPE_PIXEL_CLOCK_RATE
;               IPFreqRqd  - pixel clock rate in Megahertz
;
; Returns:      None
;
;==============================================================================
*/
static void PixelClockToStage1Parameters
(
    LPGTFIN  lpGtfIn
)
{
    /*
     * 1) Make sure that the XResolution is a multiple of char cell size
     *         fild    ds:[ebx].GTFIN.dwHPixels
     *         fdiv    fCellGran
     *         fistp   dwTemp
     *         fild    dwTemp
     *         fmul    fCellGran
     *         fstp    fHPixelsRnd
     */
    fHPixelsRnd = calcROUND((float)lpGtfIn->dwHPixels / fCellGran)
                * fCellGran;
    /*
     * 2) If interlace is requested, half the number of vertical lines
     *    since the calculation is really vertical lines per field
     *         fild    ds:[ebx].GTFIN.dwVLines
     *         cmp     ds:[ebx].GTFIN.dwIntRqd,0
     *         je      @F
     *         fdiv    fTwo
     * @@:     fstp    fVLinesRnd
     */
    fVLinesRnd = (float)lpGtfIn->dwVLines;
    if (lpGtfIn->dwIntRqd != 0)
        fVLinesRnd /= const_fTwo;
    fVLinesRnd = calcROUND(fVLinesRnd);
    /*
     * 3) Find the horizontal freqency required
     *         fild    ds:[ebx].GTFIN.dwIPFreqRqd
     *         fstp    fPixelFreq
     */
    fPixelFreq = (float)lpGtfIn->dwIPFreqRqd;
    /*
     * 4) Find the number of pixels in the left margin
     *         fldz
     *         cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
     *         je      @F
     *         faddp   ST(0),ST(0)             ; pop the stack
     *         fld     fHPixelsRnd
     *         fmul    fMarginPercent
     *         fdiv    fOneHundred
     *         fdiv    fCellGran
     *         fistp   dwTemp
     *         fild    dwTemp
     *         fmul    fCellGran
     * @@:     fstp    fLeftMarginPixels
     */
    if (lpGtfIn->dwMarginsRqd != 0)
    {
        fLeftMarginPixels = calcROUND(fHPixelsRnd * fMarginPercent / const_fOneHundred / fCellGran)
                          * fCellGran;
    }
    else
        fLeftMarginPixels = const_fZero;
    /*
     * 5) Find the number of pixels in the right margin
     *         fldz
     *         cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
     *         je      @F
     *         faddp   ST(0),ST(0)             ; pop the stack
     *         fld     fHPixelsRnd
     *         fmul    fMarginPercent
     *         fdiv    fOneHundred
     *         fdiv    fCellGran
     *         fistp   dwTemp
     *         fild    dwTemp
     *         fmul    fCellGran
     * @@:     fstp    fRightMarginPixels
     */
    if (lpGtfIn->dwMarginsRqd != 0)
    {
        fRightMarginPixels = calcROUND(fHPixelsRnd * fMarginPercent / const_fOneHundred / fCellGran)
                           * fCellGran;
    }
    else
        fRightMarginPixels = const_fZero;
    /*
     * 6) Find total number of active pixels in image+left+right margin
     *         fld     fHPixelsRnd
     *         fadd    fLeftMarginPixels
     *         fadd    fRightMarginPixels
     *         fstp    fTotalActivePixels
     */
    fTotalActivePixels = fHPixelsRnd
                       + fLeftMarginPixels
                       + fRightMarginPixels;
    /*
     * 7) Find the ideal horizontal period from blanking duty cycle Eq
     *         fld     fOneHundred
     *         fsub    fGTF_CPrime
     *         fmul    ST(0),ST(0)
     *         fld     fTotalActivePixels
     *         fadd    fLeftMarginPixels
     *         fadd    fRightMarginPixels
     *         fmul    fGTF_MPrime
     *         fmul    fZeroPointFour
     *         fdiv    fPixelFreq
     *         faddp   ST(1),ST(0)
     *         fsqrt
     *         fadd    fGTF_CPrime
     *         fsub    fOneHundred
     *         fdiv    fTwo
     *         fmul    fGTF_MPrime
     *         fmul    fOneThousand
     *         fstp    fIdealHPeriod
     */
    fTemp         = const_fOneHundred - fGTF_CPrime;
    fTemp        *= fTemp;
    fTemp         = fTemp
                  + (const_fZeroPointFour * fGTF_MPrime 
                  *  (fTotalActivePixels + fLeftMarginPixels + fRightMarginPixels)
                  /  fPixelFreq);
    fIdealHPeriod = ((fGTF_CPrime - const_fOneHundred)
                  +  (float)calcSQRT(fTemp))
                  / const_fTwo
                  / fGTF_MPrime
                  * const_fOneThousand;
    /*
     * 8) Find the ideal Blanking duty cycle
     *         fld     fGTF_CPrime
     *         fld     fGTF_MPrime
     *         fmul    fIdealHPeriod
     *         fdiv    fOneThousand
     *         fsubp   ST(1),ST(0)
     *         fstp    fIdealDutyCycle
     */

    fIdealDutyCycle = fGTF_CPrime - 
                      (fGTF_MPrime * fIdealHPeriod / const_fOneThousand);
    /*
     * 9) Find the number of pixels in the blanking time to the
     * nearest double character cell
     *         fld     fTotalActivePixels
     *         fmul    fIdealDutyCycle
     *         fld     fOneHundred
     *         fsub    fIdealDutyCycle
     *         fdivp   ST(1),ST(0)
     *         fld     fCellGran
     *         fadd    ST(0),ST(0)
     *         fdivp   ST(1),ST(0)
     *         fistp   dwTemp
     *         fild    dwTemp
     *         fadd    ST(0),ST(0)
     *         fmul    fCellGran
     *         fstp    fHBlankPixels
     */
    fHBlankPixels = calcROUND((fTotalActivePixels * fIdealDutyCycle
                  /            (const_fOneHundred - fIdealDutyCycle)
                  /            (const_fTwo * fCellGran)))
                  * (const_fTwo * fCellGran);
    /*
     * 10) Find the total number of pixels
     *         fld     fTotalActivePixels
     *         fadd    fHBlankPixels
     *         fstp    fTotalPixels
     */
    fTotalPixels = fTotalActivePixels + fHBlankPixels;
    /*
     * 11) Find the horizontal frequency
     *         fld     fPixelFreq
     *         fdiv    fTotalPixels
     *         fmul    fOneThousand
     *         fstp    fHFreq
     */
    fHFreq = fPixelFreq / fTotalPixels * const_fOneThousand;
    /*
     * 12) Find the horizontal period
     *         fld     fOneThousand
     *         fdiv    fHFreq
     *         fstp    fHPeriod
     */
    fHPeriod = const_fOneThousand / fHFreq;
    /*
     * 13) Find the number of lines in the top margin
     *         sub     eax,eax
     *         cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
     *         je      @F
     *         fld     fMarginPercent
     *         fmul    fVLinesRnd
     *         fdiv    fOneHundred
     * @@:     fstp    fTopMarginLines
     */
    if (lpGtfIn->dwMarginsRqd != 0)
        fTopMarginLines = calcROUND(fMarginPercent / const_fOneHundred * fVLinesRnd);
    else
        fTopMarginLines = const_fZero;
    /*
     * 14) Find the number of lines in the bottom margin
     *         sub     eax,eax
     *         cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
     *         je      @F
     *         fld     fMarginPercent
     *         fmul    fVLinesRnd
     *         fdiv    fOneHundred
     * @@:     fstp    fBottomMarginLines
     */
    if (lpGtfIn->dwMarginsRqd != 0)
        fBottomMarginLines = calcROUND(fMarginPercent / const_fOneHundred * fVLinesRnd);
    else
        fBottomMarginLines = const_fZero;
    /*
     * 15) If interlace is required, set dwInterlace to 0.5
     *         fldz
     *         cmp     ds:[ebx].GTFIN.dwIntRqd,0
     *         je      @F
     *         faddp   ST(0),ST(0)             ; pop the stack
     *         fld     fZeroPointFive
     * @@:     fstp    fInterlace
     */
    if (lpGtfIn->dwIntRqd != 0)
        fInterlace = const_fZeroPointFive;
    else
        fInterlace = const_fZero;
    /*
     * 16) Find the number of lines in fMinVSyncPlusBackPorch
     *         fld     fMinVSyncPlusBackPorch
     *         fmul    fHFreq
     *         fdiv    fOneThousand
     *         fstp    fVSyncPlusBackPorch
     */
    fVSyncPlusBackPorch = calcROUND(fMinVSyncPlusBackPorch * fHFreq / const_fOneThousand);
    /*
     * 17) Find the number of lines in VBackPorch alone
     *         fld     fVSyncPlusBackPorch
     *         fsub    fVSyncRqd
     *         fstp    fVBackPorch
     */
    fVBackPorch = fVSyncPlusBackPorch - fVSyncRqd;
    /*
     * 18) Find the total number of lines in the vertical field
     *         fld     fVLinesRnd
     *         fadd    fTopMarginLines
     *         fadd    fBottomMarginLines
     *         fadd    fVSyncPlusBackPorch
     *         fadd    fMinPorch
     *         fadd    fInterlace
     *         fstp    fTotalVLines
     */
    fTotalVLines = fVLinesRnd
                 + fTopMarginLines
                 + fBottomMarginLines
                 + fVSyncPlusBackPorch
                 + fMinPorch
                 + fInterlace;
    /*
     * 19) Find the actual vertical field frequency
     *         fld     fHFreq
     *         fdiv    fTotalVLines
     *         fmul    fOneThousand
     *         fstp    fVFieldRate
     */
    fVFieldRate = fHFreq /fTotalVLines * const_fOneThousand;
    /*
     * 20) Find the vertical frame frequency
     *         fld     fVFieldRate
     *         cmp     ds:[ebx].GTFIN.dwIntRqd,0
     *         je      @F
     *         fdiv    fTwo
     * @@:     fstp    fVFrameRate
     */
    fVFrameRate = fVFieldRate;
    if (lpGtfIn->dwIntRqd != 0)
        fVFrameRate /= const_fTwo;
    return;
}
/*
;==============================================================================
;
; Function:     ComputeGTFParameters
;
; Purpose:      This function computes the data for the GTFOut structure
;               from the arguments in the GTFIn structure provided
;               according to the GTF formula.
;
; Returns:      0       failure and lpGTFOut was not filled in
;               non-0   success and lpGTFOut was filled in
;
;==============================================================================
*/
ULONG WINAPI ComputeGTFParameters
(
        LPGTFIN  lpGtfIn,
        LPGTFOUT lpGtfOut
)
{
    /*
     * Set up all the constants we need
     */
    SetupGTFConstants();
    /*
     * Now we compute the stage 1 parameters. There are three cases
     * depending upon the IPParm which gives the type of the IPFreqRqd.
     */
    switch (lpGtfIn->dwIPParmType)
    {
        case IPTYPE_VERTICAL_REFRESH_RATE:
            VerticalRefreshToStage1Parameters(lpGtfIn);
            break;
        case IPTYPE_HORIZONTAL_REFRESH_RATE:
            HorizontalRefreshToStage1Parameters(lpGtfIn);
            break;
        case IPTYPE_PIXEL_CLOCK_RATE:
            PixelClockToStage1Parameters(lpGtfIn);
            break;
    }
    /*
     * Convert stage 1 to stage 2 parameters
     *
     * 1) Find the adressable lines per frame
     *
     * [ADDR LINES PER FRAME] = IF([INT RQD?]="y", [V LINES RND] * 2,
     *                                             [V LINES RND])
     */
    fAddrLinesPerFrame = fVLinesRnd;
    if (lpGtfIn->dwIntRqd != 0)
        fAddrLinesPerFrame += fVLinesRnd;
    /*
     * 2) Find the character time in nanoseconds
     *
     * [CHAR TIME] = [CELL GRAN RND] / [PIXEL FREQ] * 1000
     */
    fCharTime = fCellGran / fPixelFreq * const_fOneThousand;
    /*
     * 3) Find total number of lines in a frame
     *
     * [TOTAL LINES PER FRAME] = IF([INT RQD?]="y", 2 * ([V LINES RND] + [TOP MARGIN (LINES)] + [BOT MARGIN (LINES)] + [V SYNC+BP] + [INTERLACE] + [MIN PORCH RND]),
     *                                              ([V LINES RND] + [TOP MARGIN (LINES)] + [BOT MARGIN (LINES)] + [V SYNC+BP] + [INTERLACE] + [MIN PORCH RND]))
     */
    fTotalLinesPerFrame = fVLinesRnd
                        + fTopMarginLines
                        + fBottomMarginLines
                        + fVSyncPlusBackPorch
                        + fInterlace
                        + fMinPorch;
    if (lpGtfIn->dwIntRqd != 0)
        fTotalLinesPerFrame += fTotalLinesPerFrame;
    /*
     * 4) Find total number of chars in a horizontal line
     *
     * [TOTAL H TIME (CHARS)] = ROUND([TOTAL PIXELS] / [CELL GRAN RND], 0)
     */
    fTotalHTimeChars = calcROUND(fTotalPixels / fCellGran);
    /*
     * 5) Find the horizontal addressable time in microseconds
     *
     * [H ADDR TIME] = [H PIXELS RND] / [PIXEL FREQ]
     */
    fHAddrTime = fHPixelsRnd / fPixelFreq;
    /*
     * 6) Find the horizontal addressable time in chars
     *
     * [H ADDR TIME (CHARS)] = ROUND([H PIXELS RND] / [CELL GRAN RND], 0)
     */
    fHAddrTimeChars = calcROUND(fHPixelsRnd / fCellGran);
    /*
     * 7) Find horizontal blanking time in microseconds
     *
     * [H BLANK] = [H BLANK (PIXELS)] / [PIXEL FREQ]
     */
    fHBlank = fHBlankPixels / fPixelFreq;
    /*
     * 8) Find horizontal blanking time in chars
     *
     * [H BLANK (CHARS)] = ROUND([H BLANK (PIXELS)] / [CELL GRAN RND], 0)
     */
    fHBlankChars = calcROUND(fHBlankPixels / fCellGran);
    /*
     * 9) Find the horizontal blanking plus margin time in microseconds
     *
     * [H BLANK + MARGIN] = ([H BLANK (PIXELS)] + [RIGHT MARGIN (PIXELS)] + [LEFT MARGIN (PIXELS)])
     *                    / [PIXEL FREQ]
     */
    fHBlankPlusMargin = (fHBlankPixels + fRightMarginPixels + fLeftMarginPixels)
                      / fPixelFreq;
    /*
     * 10) Find the horizontal blanking plus margin time in chars
     *
     * [H BLANK + MARGIN(CHARS)] = ROUND(([H BLANK (PIXELS)] + [RIGHT MARGIN (PIXELS)] + [LEFT MARGIN (PIXELS)]) / [CELL GRAN RND], 0)
     */
    fHBlankPlusMarginChars = calcROUND((fHBlankPixels + fRightMarginPixels + fLeftMarginPixels) / fCellGran);
    /*
     * 11) Find the actual horizontal active video duty cycle in %
     *
     * [ACTUAL DUTY CYCLE] = [H BLANK (CHARS)] / [TOTAL H TIME (CHARS)] * 100
     */
    fActualDutyCycle = fHBlankChars / fTotalHTimeChars * const_fOneHundred;
    /*
     * 12) Find the image video duty cycle in %
     *
     * [BLANK + MARGIN DUTY CYCLE] = [H BLANK + MARGIN(CHARS)] / [TOTAL H TIME (CHARS)] * 100
     */
    fBlankPlusMarginDutyCycle = fHBlankPlusMarginChars / fTotalHTimeChars * const_fOneHundred;
    /*
     * 13) Find the left margin time in microseconds
     *
     * [LEFT MARGIN] = [LEFT MARGIN (PIXELS)] / [PIXEL FREQ] * 1000
     */
    fLeftMargin = fLeftMarginPixels * fPixelFreq * const_fOneThousand;
    /*
     * 14) Find the number of chars in the left margin
     *
     * [LEFT MARGIN (CHARS)] = [LEFT MARGIN (PIXELS)] / [CELL GRAN RND]
     */
    fLeftMarginChars = fLeftMarginPixels / fCellGran;
    /*
     * 15) Find the right margin time in microseconds
     *
     * [RIGHT MARGIN] = [RIGHT MARGIN (PIXELS)] / [PIXEL FREQ] * 1000
     */
    fRightMargin = fRightMarginPixels * fPixelFreq * const_fOneThousand;
    /*
     * 16) Find the number of chars in the rightt margin
     *
     * [RIGHT MARGIN (CHARS)] = [RIGHT MARGIN (PIXELS)] / [CELL GRAN RND]
     */
    fRightMarginChars = fRightMarginPixels / fCellGran;
    /*
     * 17) Find the number of pixels inteh horizontal sync period
     *
     * [H SYNC (PIXELS)] = ROUND(([H SYNC%] / 100 * [TOTAL PIXELS] / [CELL GRAN RND]), 0)
     *                   * [CELL GRAN RND]
     */
    fHSyncPixels = calcROUND(fHSyncPercent / const_fOneHundred * fTotalPixels / fCellGran)
                 * fCellGran;
    /*
     * 18) Find number of pixels in horizontal front porch period
     *
     * [H FRONT PORCH (PIXELS)] = ([H BLANK (PIXELS)] / 2) - [H SYNC (PIXELS)]
     */
    fHFrontPorchPixels = (fHBlankPixels / const_fTwo) - fHSyncPixels;
    /*
     * 19) Find number of pixels in horizontal front porch period
     *
     * [H BACK PORCH (PIXELS)] = [H FRONT PORCH (PIXELS)] + [H SYNC (PIXELS)]
     */
    fHBackPorchPixels = fHFrontPorchPixels + fHSyncPixels;
    /*
     * 20) Find number of characters in the horizontal sync period
     *
     * [H SYNC (CHARS)] = [H SYNC (PIXELS)] / [CELL GRAN RND]
     */
    fHSyncChars = fHSyncPixels / fCellGran;
    /*
     * 21) Find the horizontal sync period in microseconds
     *
     * [H SYNC] = [H SYNC (PIXELS)] / [PIXEL FREQ]
     */
    fHSync = fHSyncPixels / fPixelFreq;
    /*
     * 22) Find the number of chars in the horizontal front porch
     *
     * [H FRONT PORCH (CHARS)] = [H FRONT PORCH (PIXELS)] / [CELL GRAN RND]
     */
    fHFrontPorchChars = fHFrontPorchPixels / fCellGran;
    /*
     * 23) Find the horizontal front porch period in microseconds
     *
     * [H FRONT PORCH] = [H FRONT PORCH (PIXELS)] / [PIXEL FREQ]
     */
    fHFrontPorch = fHFrontPorchPixels / fPixelFreq;
    /*
     * 24) Find the number of chars in the horizontal back porch
     *
     * [H BACK PORCH (CHARS)] = [H BACK PORCH (PIXELS)] / [CELL GRAN RND]
     */
    fHBackPorchChars = fHBackPorchPixels / fCellGran;
    /*
     * 25) Find the horizontal front back period in microseconds
     *
     * [H BACK PORCH] = [H BACK PORCH (PIXELS)] / [PIXEL FREQ]
     */
    fHBackPorch = fHBackPorchPixels / fPixelFreq;
    /*
     * 26) Find the vertical frame period in milliseconds
     *
     * [V FRAME PERIOD] = IF([INT RQD?]="y", [TOTAL V LINES] * [H PERIOD] / 1000 * 2,
     *                                       [TOTAL V LINES] * [H PERIOD] / 1000)
     */
    fVFramePeriod = fTotalVLines * fHPeriod / const_fOneThousand;
    if (lpGtfIn->dwIntRqd != 0)
        fVFramePeriod += fVFramePeriod;
    /*
     * 27) Find the vertical field period in milliseconds
     *
     * [V FIELD PERIOD] = [TOTAL V LINES] * [H PERIOD] / 1000
     */
    fVFieldPeriod = fTotalVLines * fHPeriod / const_fOneThousand;
    /*
     * 28) Find the addressable vertical period per frame in milliseconds
     *
     * [V ADDR TIME PER FRAME] = IF([INT RQD?]="y", [V LINES RND] * [H PERIOD] / 1000 * 2,
     *                                              [V LINES RND] * [H PERIOD] / 1000)
     */
    fVAddrTimePerFrame = fVLinesRnd * fHPeriod / const_fOneThousand;
    if (lpGtfIn->dwIntRqd != 0)
        fVAddrTimePerFrame += fVAddrTimePerFrame;
    /*
     * 29) Find the addressable vertical period per field in milliseconds
     *
     * [V ADDR TIME PER FIELD] = [V LINES RND] * [H PERIOD] / 1000
     */
    fVAddrTimePerField = fVLinesRnd * fHPeriod / const_fOneThousand;
    /*
     * 30) Find the number of lines in teh odd blanking period
     *
     * [V ODD BLANKING (LINES)] = [V SYNC+BP] + [MIN PORCH RND]
     */
    fVOddBlankingLines = fVSyncPlusBackPorch + fMinPorch;
    /*
     * 31) Find the odd blanking period in milliseconds
     *
     * [V ODD BLANKING] = ([V SYNC+BP] + [MIN PORCH RND]) * [H PERIOD] / 1000
     */
    fVOddBlanking = (fVSyncPlusBackPorch + fMinPorch) * fHPeriod / const_fOneThousand;
    /*
     * 32) Find the number of lines in the even blanking period
     *
     * [V EVEN BLANKING (LINES)] = [V SYNC+BP] + (2 * [INTERLACE]) + [MIN PORCH RND]
     */
    fVEvenBlankingLines = fVSyncPlusBackPorch
                        + (const_fTwo * fInterlace)
                        + fMinPorch;
    /*
     * 33) Find the even blanking period in milliseconds
     *
     * [V EVEN BLANKING] = ([V SYNC+BP] + (2 * [INTERLACE]) + [MIN PORCH RND])
     *                   / 1000 * [H PERIOD]
     */
    fVEvenBlanking = (fVSyncPlusBackPorch + (const_fTwo * fInterlace) + fMinPorch)
                   / const_fOneThousand
                   *  fHPeriod;
    /*
     * 34) Find the top margin period in microseconds
     *
     * [TOP MARGIN ] = [TOP MARGIN (LINES)] * [H PERIOD]
     */
    fTopMargin = fTopMarginLines * fHPeriod;
    /*
     * 35) Find the odd front porch in microseconds
     *
     * [V ODD FRONT PORCH] = ([MIN PORCH RND] + [INTERLACE]) * [H PERIOD]
     */
    fVOddFrontPorch = (fMinPorch + fInterlace) * fHPeriod;
    /*
     * 36) Find the number of lines in the odd front porch period
     *
     * [V ODD FRONT PORCH(LINES)] = [MIN PORCH RND] + [INTERLACE]
     */
    fVOddFrontPorchLines = fMinPorch + fInterlace;
    /*
     * 37) Find the even front porch period
     *
     * [V EVEN FRONT PORCH] = [MIN PORCH RND] * [H PERIOD]
     */
    fVEvenFrontPorch = fMinPorch * fHPeriod;
    /*
     * 38) Find the vertcial sync period in microseconds
     *
     * [V SYNC] = [V SYNC RND] * [H PERIOD]
     */
    fVSync = fVSyncRqd * fHPeriod;
    /*
     * 39) Find the even front porch period in microseconds
     *
     * [V EVEN BACK PORCH] = ([V BACK PORCH] + [INTERLACE]) * [H PERIOD]
     */
    fVEvenBackPorch = (fVBackPorch + fInterlace) * fHPeriod;
    /*
     * 40) Find the number of lines in the even fron tporch period
     *
     * [V EVEN BACK PORCH (LINES)] = [V BACK PORCH] + [INTERLACE]
     */
    fVEvenBackPorchLines = fVBackPorch + fInterlace;
    /*
     * 41) Find the odd back porch period in microseconds
     *
     * [V ODD BACK PORCH] = [V BACK PORCH] * [H PERIOD]
     */
    fVOddBackPorch = fVBackPorch * fHPeriod;
    /*
     * 42) Find the bottom margin period in microseconds
     *
     * [BOT MARGIN] = [BOT MARGIN (LINES)] * [H PERIOD]
     */
    fBottomMargin = fBottomMarginLines * fHPeriod;
    /*
     * Cram all the data into GTFOut
     */
    lpGtfOut->dwHTotalChars          = (ULONG)fTotalHTimeChars;
    lpGtfOut->dwVTotalScans          = (ULONG)fTotalLinesPerFrame;
    lpGtfOut->dwHActiveChars         = (ULONG)fHAddrTimeChars;
    lpGtfOut->dwVActiveScans         = (ULONG)fVLinesRnd;
    lpGtfOut->dwHBlankStartChar      = (ULONG)(fHAddrTimeChars + fRightMarginChars);
    lpGtfOut->dwHFrontPorchChars     = (ULONG)fHFrontPorchChars;
    lpGtfOut->dwHSyncChars           = (ULONG)fHSyncChars;
    lpGtfOut->dwHBackPorchChars      = (ULONG)fHBackPorchChars;
    lpGtfOut->dwHBlankEndChar        = (ULONG)(fTotalHTimeChars - fLeftMarginChars);
    lpGtfOut->dwVBlankStartScan      = (ULONG)(fVLinesRnd + fBottomMarginLines);
    lpGtfOut->dwVFrontPorchScans     = (ULONG)fVOddFrontPorchLines;
    lpGtfOut->dwVSyncScans           = (ULONG)fVSyncRqd;
    lpGtfOut->dwVBackPorchScans      = (ULONG)fVEvenBackPorchLines;
    lpGtfOut->dwVBlankEndScan        = (ULONG)(fTotalLinesPerFrame - fTopMarginLines);
    lpGtfOut->dwPixelClockIn10KHertz = (ULONG)(fPixelFreq * const_fOneHundred);
    /*
     * Return success
     */
    return(1);
}
ULONG WINAPI Divide32By32
(
        ULONG dwDividend,
        ULONG dwDivisor
)
{
    return (dwDividend / dwDivisor);
}
ULONG WINAPI Multiply32By32
(
        ULONG dwMult1,
        ULONG dwMult2
)
{
    return (dwMult1 * dwMult2);
}
#endif /* !defined(_WIN32)  || defined(_WIN64) */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\modeset.mhd\CODE\tvmode.h ===
/*
    FILE:   tvmode.h
    DATE:   4/8/99

    This file contains the high level logic for the tv modeset code.
    OS Independent.
*/

extern int CFUNC FindTVModeEntry (LPDISPDATA lpDispData,
                                LPMODEINFO lpModeDesc, LPMODEOUT lpModeOut,
                                LPMODEENTRY lpModeList, LPRESTIME lpRTList);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\modeset.mhd\CODE\RESTIME.C ===
/*
    FILE:   restime.c
    DATE:   4/8/99

    This file holds code to process restriction and timing lists
    and also a few utility routines to get mode lists from the
    registry, etc.
*/

#include "cmntypes.h"
#include "modeext.h"
#include "modeset.h"
#include "utils.h"
#include "restime.h"
#include "debug.h"

// Just in cae we can't GlobalAlloc a list, we have a single entry one
// we can use here.
RESTIME     sRTList;

/*
    ParseRTString

    This routine parses an R&T string given by szRTString into the
    RESTIME structure pointed to by lpRT. The function returns
    TRUE if the szRTString was a valid R&T string and parsed with
    no errors. Otherwise the routine returns FALSE.
*/
int CFUNC
ParseRTString (LPRESTIME lpRT, LPCHAR szRTString)
{
    int     nRet;
    ULONG   dwIndex;

    DBG_PRINT1(DL_5, "\r\nParsing R&T string %s", szRTString);

    // dwIndex is the offset into the szRTString we are currently looking at
    dwIndex = 0;

    // The first thing in an R&T string is the X-resolution. Make sure
    // it is there and get its value.
    if  (!ParseDecimalNumberComma (szRTString, &dwIndex, &(lpRT->dwXRes)))
        return  (FALSE);
    DBG_PRINT1(DL_5, "\r\nXRes found to be %ld", lpRT->dwXRes);

    // The next thing in an R&T string is the Y-resolution. Make sure
    // it is there and get its value.
    if  (!ParseDecimalNumberComma (szRTString, &dwIndex, &(lpRT->dwYRes)))
        return  (FALSE);
    DBG_PRINT1(DL_5, "\r\nYRes found to be %ld", lpRT->dwYRes);

    // The next thing in an R&T string is the pixel depth. This
    // is also allowed to be a wildcard indicating everything.
    if  (!ParseDecimalNumberOrWildcard (szRTString, &dwIndex, &(lpRT->dwPixelDepth)))
        return  (FALSE);
    DBG_PRINT1(DL_5, "\r\nPixelDepth found to be %ld", lpRT->dwPixelDepth);

    // The next thing in an R&T string is the refresh rate. This
    // is also allowed to be a wildcard indicating everything.
    if  (!ParseDecimalNumberOrWildcard (szRTString, &dwIndex, &(lpRT->dwRefreshRate)))
        return  (FALSE);
    DBG_PRINT1(DL_5, "\r\nRefreshRate found to be %ld", lpRT->dwRefreshRate);

    // The next thing in an R&T string is a dot separated list
    // of Device IDs.
    if  (!ParseDeviceIDs (szRTString, &dwIndex, lpRT->wDeviceID))
        return  (FALSE);

    // The next thing in an R&T string is a dot separated list
    // of Monitor IDs.
    if  (!ParseMonitorIDs (szRTString, &dwIndex, lpRT->dwMonitorID))
        return  (FALSE);

    // The next thing in an R&T string is a dot separated list
    // of Timing Standards.
    nRet = ParseTimingStandards (szRTString, &dwIndex, lpRT->dwTimingStandard);
    if  (!nRet)
        return  (FALSE);

    // If one of the timing standards was OEM, then there must be a set
    // of timing parameters in a MODEOUT format as the last thing in the
    // R&T string. We know if there was an OEM timing standard because
    // ParseTimingStandard returns a number greater than 1 if there was
    // an OEM timing standard listed.
    if  (nRet > 1)
    {
        // The timing parameter format is hexdigits;hexdigits; etc
        if  (!ParseHexWord (szRTString, &dwIndex, &(lpRT->sModeOut.wHBlankStart)))
            return  (FALSE);
        DBG_PRINT1(DL_5, "\r\nHBlankStart found to be %lx", (ULONG) lpRT->sModeOut.wHBlankStart);

        if  (!ParseHexWord (szRTString, &dwIndex, &(lpRT->sModeOut.wHBlankWidth)))
            return  (FALSE);
        DBG_PRINT1(DL_5, "\r\nHblankWidth found to be %lx", (ULONG) lpRT->sModeOut.wHBlankWidth);

        if  (!ParseHexWord (szRTString, &dwIndex, &(lpRT->sModeOut.wHSyncStart)))
            return  (FALSE);
        DBG_PRINT1(DL_5, "\r\nHSyncStart found to be %lx", (ULONG) lpRT->sModeOut.wHSyncStart);

        if  (!ParseHexWord (szRTString, &dwIndex, &(lpRT->sModeOut.wHSyncWidth)))
            return  (FALSE);
        DBG_PRINT1(DL_5, "\r\nHSyncWidth found to be %lx", (ULONG) lpRT->sModeOut.wHSyncWidth);

        if  (!ParseHexWord (szRTString, &dwIndex, &(lpRT->sModeOut.wVBlankStart)))
            return  (FALSE);
        DBG_PRINT1(DL_5, "\r\nVBlankStart found to be %lx", (ULONG) lpRT->sModeOut.wVBlankStart);

        if  (!ParseHexWord (szRTString, &dwIndex, &(lpRT->sModeOut.wVBlankWidth)))
            return  (FALSE);
        DBG_PRINT1(DL_5, "\r\nHblankWidth found to be %lx", (ULONG) lpRT->sModeOut.wVBlankWidth);

        if  (!ParseHexWord (szRTString, &dwIndex, &(lpRT->sModeOut.wVSyncStart)))
            return  (FALSE);
        DBG_PRINT1(DL_5, "\r\nVSyncStart found to be %lx", (ULONG) lpRT->sModeOut.wVSyncStart);

        if  (!ParseHexWord (szRTString, &dwIndex, &(lpRT->sModeOut.wVSyncWidth)))
            return  (FALSE);
        DBG_PRINT1(DL_5, "\r\nVSyncWidth found to be %lx", (ULONG) lpRT->sModeOut.wVSyncWidth);

        if  (!ParseHexWord (szRTString, &dwIndex, &(lpRT->sModeOut.wHTotal)))
            return  (FALSE);
        DBG_PRINT1(DL_5, "\r\nXTotal found to be %lx", (ULONG) lpRT->sModeOut.wHTotal);

        if  (!ParseHexWord (szRTString, &dwIndex, &(lpRT->sModeOut.wVTotal)))
            return  (FALSE);
        DBG_PRINT1(DL_5, "\r\nYTotal found to be %lx", (ULONG) lpRT->sModeOut.wVTotal);

        if  (!ParseHexDWord (szRTString, &dwIndex, &(lpRT->sModeOut.dwPixelClock)))
            return  (FALSE);
        DBG_PRINT1(DL_5, "\r\nPixelClock found to be %lx", lpRT->sModeOut.dwPixelClock);

        if  (!ParseHexDWord (szRTString, &dwIndex, &(lpRT->sModeOut.dwFormat)))
            return  (FALSE);
        DBG_PRINT1(DL_5, "\r\nFormat found to be %lx", lpRT->sModeOut.dwFormat);

        lpRT->sModeOut.wXRes = (USHORT) lpRT->dwXRes;
        lpRT->sModeOut.wYRes = (USHORT) lpRT->dwYRes;
        lpRT->sModeOut.wRefreshRate = (USHORT) lpRT->dwRefreshRate;
    }

    return  (TRUE);
}


/*
    ParseDecimalNumberComma

    This routine parses a field that can either be a decimal number
    or the wildcard character. Basically, if it isn't the wildcard
    character, then it is assumed to be a decimal number
    This routine parses a decimal number from the string passed in.
    It assigns it into lpNum. Upkn returning lpIndex is adjusted so
    that it points to the first char after the comma following the
    number parsed. If the number was bad, could not be found before
    the end of the string or before the next comma, FALSE is returned.
    If a number was found and everything is fine, TRUE is returned.
    in RESTIME structures of the array pointed to by lpRTList.
*/
int CFUNC
ParseDecimalNumberComma (LPCHAR szRTString, LPULONG lpIndex, LPULONG lpNum)
{
    return  (ParseDecimalSeparator (szRTString, lpIndex, lpNum, ',', ','));
}



/*
    ParseDecimalNumberOrWildcard

    This routine parses a field that can either be a decimal number
    or the wildcard character. Basically, if it isn't the wildcard
    character, then it is assumed to be a decimal number
    This routine parses a decimal number from the string passed in.
    It assigns it into lpNum. Upkn returning lpIndex is adjusted so
    that it points to the first char after the comma following the
    number parsed. If the number was bad, could not be found before
    the end of the string or before the next comma, FALSE is returned.
    If a number was found and everything is fine, TRUE is returned.
    in RESTIME structures of the array pointed to by lpRTList.
*/
int CFUNC
ParseDecimalNumberOrWildcard (LPCHAR szRTString, LPULONG lpIndex, LPULONG lpNum)
{
    if  (szRTString[*lpIndex] == ALL_WILDCARD)
    {
        *lpNum = ALL_WILDCARD;

        // If the next char is not immediately a comma, then error
        if  (szRTString[*lpIndex + 1] != ',')
        {
            DBG_PRINT1(DL_5, "\r\nComma not found after wildcard number in %s.", szRTString);
            return  (FALSE);
        }

        *lpIndex += 2;
    }
    else
    {
        // Not a wildcard, so parse a number
        if  (!ParseDecimalNumberComma (szRTString, lpIndex, lpNum))
            return  (FALSE);
    }

    return  (TRUE);
}



/*
    ParseDeviceIDs

    This routine parses a '.' separated list of DeviceIDs. There can
    be up to MAX_DOT_FIELDS deviceIDs. Any more than this constitutes
    a parse error. Each deviceID is assumed to be exactly four hex
    digits long. The alphabetic characters can be upper or lower case.
*/
int CFUNC
ParseDeviceIDs (LPCHAR szRTString, LPULONG lpIndex, LPUSHORT lpNum)
{
    int     nRet;
    ULONG   dwID, dwNum;

    // Set all the device IDs to 0
    for (dwID = 0; dwID < MAX_DOT_FIELDS; dwID++)
        lpNum[dwID] = 0;

    for (dwID = 0; TRUE; dwID++)
    {
        // The deviceID can be a WILDCARD char
        if  (szRTString[*lpIndex] == ALL_WILDCARD)
        {
            lpNum[dwID] = ALL_WILDCARD;
            *lpIndex += 1;
        }
        else
        {
            nRet = ParseHexSeparator (szRTString, lpIndex,
                                     &dwNum, 4, ',', '.');

            if  (!nRet)
            {
                DBG_PRINT1(DL_5, "\r\nBad DeviceID in %s", szRTString);
                return  (FALSE);
            }

            // We found a number!
            lpNum[dwID] = (USHORT) dwNum;

            // Backup pointer to put to separator.
            *lpIndex = *lpIndex - 1;
        }

        // If the next char is not either a '.' indicating another
        // deviceID follows, or a ',' indicating we are done with the
        // deviceID parsing, then there is a parse error.
        if  (szRTString[*lpIndex] == ',')
        {
            *lpIndex += 1;
            DBG_PRINT1(DL_5, "\r\nFound %ld DeviceIDs.", dwID + 1);
            return  (TRUE);
        }

        if  (szRTString[*lpIndex] != '.')
        {
            DBG_PRINT1(DL_5, "\r\nBad DeviceID separator in %s", szRTString);
            return  (FALSE);
        }

        // Skip over the '.' and keep going for the next deviceID
        *lpIndex += 1;

    }

    DBG_PRINT1(DL_5, "\r\nFound %ld deviceIDs.", dwID + 1);
    return  (TRUE);
}


/*
    ParseMonitorIDs

    This routine parses a '.' separated list of MonitorIDs. There can
    be up to MAX_DOT_FIELDS deviceIDs. Any more than this constitutes
    a parse error. Each MonitorID is assumed to be exactly four byte
    characters long. An ALL_WILDCARD character is allowed.
*/
ULONG CFUNC
ParseIsHexChar (UCHAR c)
{
    if  ((c >= '0') && (c <= '9'))
        return  (c - '0');

    if  ((c >= 'A') && (c <= 'F'))
        return  ((c - 'A') + 10);
    
    if  ((c >= 'a') && (c <= 'f'))
        return  ((c - 'a') + 10);

    return  (0xFFFFFFFF);
}


/*
    ParseMonitorIDs

    This routine parses a '.' separated list of MonitorIDs. There can
    be up to MAX_DOT_FIELDS deviceIDs. Any more than this constitutes
    a parse error. Each MonitorID is assumed to be exactly four byte
    characters long. An ALL_WILDCARD character is allowed.
*/
int CFUNC
ParseMonitorIDs (LPCHAR szRTString, LPULONG lpIndex, LPULONG lpNum)
{
    ULONG   c1, c2;
    int     i;
    ULONG   dwID;

    // Set all the monitor IDs to 0
    for (dwID = 0; dwID < MAX_DOT_FIELDS; dwID++)
        lpNum[dwID] = 0;

    for (dwID = 0; TRUE; dwID++)
    {
        // The monitorID can be a WILDCARD char
        if  (szRTString[*lpIndex] == ALL_WILDCARD)
        {
            lpNum[dwID] = ALL_WILDCARD;
            *lpIndex += 1;
        }
        else
        {
            for (i = 0; i < 4; i++)
            {
                c1 = ParseIsHexChar(szRTString[*lpIndex + i * 2 + 0]);
                c2 = ParseIsHexChar(szRTString[*lpIndex + i * 2 + 1]);

                if  ((c1 == 0xFFFFFFFF) || (c2 == 0xFFFFFFFF))
    
                {
                    DBG_PRINT1(DL_5, "\r\nBad MonitorID in %s", szRTString);
                    return  (FALSE);
                }

                lpNum[dwID] |= ((c1 * 0x10) + c2) << (24 - i * 8);
            }

            *lpIndex += 8;
        }

        // If the next char is not either a '.' indicating another
        // monitorID follows, or a ',' indicating we are done with the
        // monitorID parsing, then there is a parse error.
        if  (szRTString[*lpIndex] == ',')
        {
            *lpIndex += 1;
            DBG_PRINT1(DL_5, "\r\nFound %ld monitorIDs.", dwID + 1);
            return  (TRUE);
        }

        if  (szRTString[*lpIndex] != '.')
        {
            DBG_PRINT1(DL_5, "\r\nBad MonitorID separator in %s", szRTString);
            return  (FALSE);
        }

        // Skip over the '.' and keep going for the next monitorID
        *lpIndex += 1;
    }

    return  (TRUE);
}


/*
    ParseTimingStandards

    This routine parses a '.' separated list of Timing Standards. There
    can be up to MAX_DOT_FIELDS Timing Standards. Any more than this
    constitutes a parse error. Each Timing Standard is up to four
    characters long. The permissable ones are in restime.h

    Returns: 0 is returned if there was any parse error
             1 is returned if there were no parse errors but OEMN was
                 not one of the timing standards
             2 is returned if there were no parse errors and OEMN was
                 one of the timing standards.
*/
int CFUNC
ParseTimingStandards (LPCHAR szRTString, LPULONG lpIndex, LPULONG lpNum)
{
    ULONG   dwID, dwTS;
    int     nRet;

    nRet = 1;

    // Set all the Timing Standards to 0
    for (dwID = 0; dwID < MAX_DOT_FIELDS; dwID++)
        lpNum[dwID] = 0;

    for (dwID = 0; TRUE; dwID++)
    {
        // Make sure the next thing is a Timing Stndard
        dwTS = * ((LPULONG) (szRTString + *lpIndex));

        if  ((dwTS != NONE_ID) &&
             (dwTS != EDID_ID) &&
             (dwTS != DMTV_ID) &&
             (dwTS != DMTR_ID) &&
             (dwTS != GTFV_ID) &&
             (dwTS != GTFR_ID) &&
             (dwTS != OEMX_ID) &&
             (dwTS != OEMR_ID) &&
             (dwTS != FGTF_ID) &&
             (dwTS != FGTR_ID))
        {
            DBG_PRINT1(DL_5, "\r\nBad Timing Standard in %s", szRTString);
            return  (0);
        }

        if  ((dwTS == OEMX_ID) || (dwTS == OEMR_ID))
            nRet = 2;

        lpNum[dwID] = dwTS;
        *lpIndex += 4;

        // If the next char is not either a '.' indicating another
        // TimingStandard follows, or a ',' indicating we are done
        // with the TimingStandard parsing, then there is a parse error.
        if  ((szRTString[*lpIndex] == ',') || (szRTString[*lpIndex] == 0))
        {
            DBG_PRINT1(DL_5, "\r\nFound %ld Timing Standards.", dwID + 1);

            // If a comma follows, skip over it
            if  (szRTString[*lpIndex] == ',')
                *lpIndex += 1;

            return  (nRet);
        }

        if  (szRTString[*lpIndex] != '.')
        {
            DBG_PRINT1(DL_5, "\r\nBad Timing Standard separator in %s", szRTString);
            return (0);
        }

        // Skip over the '.' and keep going for the next timing standard
        *lpIndex += 1;
    }

    return  (TRUE);
}




/*
    RTFindNextMatchingString

    This procedure finds a string in the RTList that matches all the
    parameters in the R&T string. This is board data, mode, and
    monitor id. It returns an index into the list. If no match is
    found, then RTERR_NOT_FOUND is returned.
*/

int CFUNC
RTFindNextMatchingString (
    LPRESTIME   lpRTList,
    int         nIndex,
    LPDISPDATA  lpDispData,
    LPRTMODE    lpRTMode,
    ULONG       dwMonitorID)
{
    int i, b;
    int bMatchDevice, bMatchMode, bMatchMonitor;

    if  ((ULONG) nIndex > lpRTList->dwXRes)
    {
        // The requested index of the string at which to begin
        // searching is larger than the total number of R&T
        // strings in the array. So return error.
        return  (RTERR_NOT_FOUND);
    }

    for  (i = nIndex; i <= (int) lpRTList->dwXRes; i++)
    {
        bMatchDevice  = FALSE;
        bMatchMode    = FALSE;
        bMatchMonitor = FALSE;
        for (b = 0; b < MAX_DOT_FIELDS; b++)
        {
            // Return index if there is a wildcard match
            if  (lpRTList[i].wDeviceID[b] == ALL_WILDCARD)
                bMatchDevice = TRUE;

            // Return index if there is an exact match
            if  (lpRTList[i].wDeviceID[b] == (USHORT) lpDispData->dwDeviceID)
                bMatchDevice = TRUE;
        }

        // Match on the mode
        if  ((lpRTList[i].dwXRes == lpRTMode->dwXRes) &&
             (lpRTList[i].dwYRes == lpRTMode->dwYRes) &&
             ((lpRTList[i].dwPixelDepth == ALL_WILDCARD) ||
              (lpRTList[i].dwPixelDepth == lpRTMode->dwBpp)) &&
             ((lpRTList[i].dwRefreshRate == ALL_WILDCARD) ||
              (lpRTList[i].dwRefreshRate == lpRTMode->dwRefreshRate)))
            bMatchMode = TRUE;

        for (b = 0; b < MAX_DOT_FIELDS; b++)
        {
            // Return success on a wildcard match
            if  (lpRTList[i].dwMonitorID[b] == ALL_WILDCARD)
                bMatchMonitor = TRUE;;

            // Return success on an exact match
            if  (lpRTList[i].dwMonitorID[b] == dwMonitorID)
                bMatchMonitor = TRUE;;
        }
        
        if  (bMatchDevice && bMatchMode & bMatchMonitor)
            return  (i);
    }

    return  (RTERR_NOT_FOUND);
}


/*
    RTRestrictByTimingStandard

    This procedure looks at the R&T string given by nIndex in the
    lpRTList and sees if there is a match on the TimingStandard given
    by dwTimingStandard. If there is, TRUE is returned, else FALSE is
    returned.
*/
int CFUNC
RTRestrictByTimingStandard (
    LPRESTIME   lpRTList,
    int         nIndex,
    ULONG       dwTimingStandard)
{
    int b;

    for (b = 0; b < MAX_DOT_FIELDS; b++)
        if  (lpRTList[1].dwTimingStandard[b] == dwTimingStandard)
            return  (TRUE);

    return  (FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\modeset.mhd\CODE\i386\gtfmath.inc ===
option expr32
option casemap:none

; Begin of file temp.h
ULONG		TYPEDEF		DWORD

tagGTFIN		STRUCT 2t
dwHPixels		ULONG		?
dwVLines		ULONG		?
dwMarginsRqd		ULONG		?
dwIntRqd		ULONG		?
dwIPParmType		ULONG		?
dwIPFreqRqd		ULONG		?
tagGTFIN		ENDS

GTFIN		TYPEDEF		tagGTFIN

LPGTFIN		TYPEDEF		PTR GTFIN

IPTYPE_VERTICAL_REFRESH_RATE		EQU		1t
IPTYPE_HORIZONTAL_REFRESH_RATE		EQU		2t
IPTYPE_PIXEL_CLOCK_RATE		EQU		3t
tagGTFOUT		STRUCT 2t
dwHTotalChars		ULONG		?
dwVTotalScans		ULONG		?
dwHActiveChars		ULONG		?
dwVActiveScans		ULONG		?
dwHBlankStartChar		ULONG		?
dwHFrontPorchChars		ULONG		?
dwHSyncChars		ULONG		?
dwHBackPorchChars		ULONG		?
dwHBlankEndChar		ULONG		?
dwVBlankStartScan		ULONG		?
dwVFrontPorchScans		ULONG		?
dwVSyncScans		ULONG		?
dwVBackPorchScans		ULONG		?
dwVBlankEndScan		ULONG		?
dwPixelClockIn10KHertz		ULONG		?
tagGTFOUT		ENDS

GTFOUT		TYPEDEF		tagGTFOUT

LPGTFOUT		TYPEDEF		PTR GTFOUT

; End of file temp.h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\modeset.mhd\CODE\UTILS.C ===
/*
    FILE:   utils.c
    DATE:   4/8/99

    This file provides common utilities other modules.
*/

#include "cmntypes.h"
#include "modeext.h"
#include "modeset.h"
#include "utils.h"
#include "debug.h"
#include "gtfmath.h"

/*
    Function:   FindMode

    Purpose:    This routine searches the table passed in lpMS for the
                XRes, YRes, and RRate specified.

    Arguments:  lpMS        ptr to current MODESTRUC table
                lpModeOut   ptr to MODEOUT structure where timing
                            parameters are placed if the mode given
                            by lpMS is found.
                dwXRes      X-Resolution
                dwYRes      Y-Resolution
                dwRRate     Refresh Rate

    Returns:    Index into MODESTRUC table if a matching mode is found.
                -1 if no matching mode is found.
*/

int CFUNC
FindMode (
    LPMODESTRUC lpMS,
    ULONG       dwXRes,
    ULONG       dwYRes,
    ULONG       dwRRate)
{
    int     i;

    for (i = 0; lpMS[i].wHorizVisible != 0x00; i++)
    {
        if (((ULONG) lpMS[i].wHorizVisible == dwXRes) &&
            ((ULONG) lpMS[i].wVertVisible == dwYRes)  &&
            ((ULONG) lpMS[i].wRefresh == dwRRate))
        return  (i);
    }

    return  (-1);
}



/*
    Function:   FindModeWithoutRR

    Purpose:    This routine searches the table passed in lpMS for the
                XRes, YRes specified with the highest RRate.

    Arguments:  lpMS        ptr to current MODESTRUC table
                dwXRes      X-Resolution
                dwYRes      Y-Resolution
                dwRRate     Refresh Rate

    Returns:    Index into MODESTRUC table if a matching mode is found.
                -1 if no matching mode is found.
*/

int CFUNC
FindModeWithoutRR (
    LPMODESTRUC lpMS,
    ULONG       dwXRes,
    ULONG       dwYRes)
{
    int     i;

    for (i = 0; lpMS[i].wHorizVisible != 0x00; i++)
    {
        if (((ULONG) lpMS[i].wHorizVisible == dwXRes) &&
            ((ULONG) lpMS[i].wVertVisible == dwYRes))
        return  (i);
    }

    return  (-1);
}



/*
    Function:   SetupParamsForVidLutClass

    Purpose:    This routine translates the mode found into the
                parameter format of the VIDEOLUTCURSORDAC class.

    Arguments:  lpMS        ptr to MODESTRUC structure
                lpModeOut   ptr to MODEOUT structure where parameters go.
                lpModeIn    MODEINFO ptr describing mode

    Returns:    Ptr to table with parameters in proper format for the
                VIDEOLUTCURSORDAC class.
*/

int CFUNC
SetupParamsForVidLutClass (
    LPMODESTRUC         lpMS,
    LPMODEOUT           lpModeOut,
    LPMODEINFO          lpModeIn)
{
    ULONG   dwFormat;

    lpModeOut->wXRes        = lpMS->wHorizVisible;
    lpModeOut->wYRes        = lpMS->wVertVisible;
    lpModeOut->wRefreshRate = lpMS->wRefresh;
    lpModeOut->wHBlankStart = lpMS->wHorizBlankStart;
    lpModeOut->wHBlankWidth = lpMS->wHorizBlankEnd - lpMS->wHorizBlankStart;
    lpModeOut->wHSyncStart  = lpMS->wHorizSyncStart;
    lpModeOut->wHSyncWidth  = lpMS->wHorizSyncEnd - lpMS->wHorizSyncStart;
    lpModeOut->wVBlankStart = lpMS->wVertBlankStart;
    lpModeOut->wVBlankWidth = lpMS->wVertBlankEnd - lpMS->wVertBlankStart;
    lpModeOut->wVSyncStart  = lpMS->wVertSyncStart;
    lpModeOut->wVSyncWidth  = lpMS->wVertSyncEnd - lpMS->wVertSyncStart;
    lpModeOut->wHTotal      = lpMS->wHorizTotal;
    lpModeOut->wVTotal      = lpMS->wVertTotal;

    lpModeOut->dwPixelClock = (ULONG) lpMS->wDotClock;

    dwFormat = 0;
    if  (lpModeOut->wYRes < 400)    // if YRes < 400 then this is a double
        dwFormat |= 1;              // scan mode, set dwFormat[0] = 1
    if  (!lpMS->wHSyncPolarity)     // 1 = positive polarity in tbl
        dwFormat |= 4;              // 1 = negative polarity in format field
    if  (!lpMS->wVSyncPolarity)     // 1 = positive polarity in tbl
        dwFormat |= 8;              // 1 = negative polarity in format field

    if  (lpModeIn->dwBpp == 15)
        dwFormat |= 0x20000;        // 15 BPP
    if  (lpModeIn->dwBpp == 16)
        dwFormat |= 0x10000;        // 16 BPP
    if  (lpModeIn->dwBpp == 32)
        dwFormat |= 0x30000;        // 32 BPP

    // Set the display type. Note: DEVTYPE_CRT = 0 so no bits need to be
    // set in dwFormat.
    if  (lpModeIn->MIDevData.cType == DEVTYPE_DFP)
        dwFormat |= 0x300000;
    if  (lpModeIn->MIDevData.cType == DEVTYPE_TV)
    {
        dwFormat |= 0x100000;
        // Set the TV Format
        dwFormat |= ((ULONG) (lpModeIn->MIDevData.cFormat)) << 22;
    }

    lpModeOut->dwFormat = dwFormat; // Store Format

    return  (TRUE);
}



/*
    Function:   SetupParamsForModeINfo

    Purpose:    This routine translates the mode found into the
                parameter format of the MODEINFO structure.

    Arguments:  lpModeOut   MODEOUT ptr to mode found
                lpModeOrig  This is the originally requested mode
                lpModeIn    This will be a MODEINFO structure that
                            describes the same thing as the lpModeOut
                            describes

    Returns:    dwXRes, dwYRes, dwBpp, dwRefreshRate from MODEOUT structure
                in MODEINFO structure.
*/

int CFUNC
SetupParamsForModeInfo (
    LPMODEOUT           lpModeOut,
    LPMODEINFO          lpModeOrig,
    LPMODEINFO          lpModeIn)
{
    ULONG   dwBpp;

    *lpModeIn = *lpModeOrig;

    dwBpp = 0;
    if ((lpModeOut->dwFormat & 0x30000) == 0x00000)
        dwBpp = 8;
    if ((lpModeOut->dwFormat & 0x30000) == 0x20000)
        dwBpp = 15;
    if ((lpModeOut->dwFormat & 0x30000) == 0x10000)
        dwBpp = 16;
    if ((lpModeOut->dwFormat & 0x30000) == 0x30000)
        dwBpp = 32;

    if (lpModeOut->wXRes == 720 && lpModeOut->wYRes == 544) {
        lpModeIn->dwXRes = 720;
        lpModeIn->dwYRes = 576;
    } else {
        lpModeIn->dwXRes = (ULONG) lpModeOut->wXRes;
        lpModeIn->dwYRes = (ULONG) lpModeOut->wYRes;
    }
    lpModeIn->dwBpp         = dwBpp;
    lpModeIn->dwRefreshRate = (ULONG) lpModeOut->wRefreshRate;

    return  (TRUE);
}


/*
    ParseDecimalSeparator

    This routine parses a decimal number from the string passed in. It
    assigns it into lpNum. Upon returning lpIndex is adjusted so that it
    points to the first char after the separator following the number
    parsed. If a NULL followed the number parse (i.e. end of the string),
    lpIndex is left pointing to the NULL, but the routine still
    succeeds. If the number was bad or wasn't found before the comma
    separatorthe separator wasn't a could not be found before the end of
    the string or before the next comma, FALSE is returned. If a number
    was found and everything is fine, TRUE is returned.
*/
int CFUNC
ParseDecimalSeparator (
    LPCHAR  lpStr,
    LPULONG lpIndex,
    LPULONG lpNum,
    char    cSeparator1,
    char    cSeparator2)
{
    ULONG   dwIsNum;
    USHORT  wDec;

    *lpNum  = 0;
    dwIsNum = FALSE;
    while   (TRUE)
    {
        if  ((lpStr[*lpIndex] == cSeparator1) ||
             (lpStr[*lpIndex] == cSeparator2))
        {
            // If we did not find at least one decimal digit, then
            // the Num field was not present -- this is an error.
            if  (!dwIsNum)
            {
                DBG_PRINT1(DL_5, "\r\nNo Num found before comma in %s", lpStr);
                return  (FALSE);
            }

            DBG_PRINT1(DL_5, "\r\nParseDecimal found %ld.", *lpNum);

            // Only bump to after the separator if the separator was
            // not the end of the string
            if  (lpStr[*lpIndex] != 0)
                *lpIndex += 1;

            return  (TRUE);
        }

        wDec = (USHORT) GetDecimalValue (lpStr[*lpIndex]);
        if  (wDec == 0x0FFFF)
        {
			if  (!dwIsNum)
            {
                DBG_PRINT1(DL_5, "\r\nNo Num found before comma in %s", lpStr);
                return  (FALSE);
            }
			else
                return  (TRUE);
        }

        // We have found at least one decimal digit
        dwIsNum = TRUE;

        // Keep a running computation going here.
        *lpNum = *lpNum * 10 + (ULONG) wDec;

        // go to next char
        *lpIndex += 1;
    }

    return  (TRUE);
}


/*
    ParseDecimalNumberAndFractionAndSeparator

    This routine parses a decimal number from the string passed in. It
    assigns it into lpNum. Upon returning lpIndex is adjusted so that it
    points to the first char after the separator following the number
    parsed. If the number has a decimal point and some fraction following
    it, like 50.03, the fractional portion is parsed but discarded and
    *lpIndex is updated to the first character after the separator
    following 50.03
    If a NULL followed the number parse (i.e. end of the string),
    lpIndex is left pointing to the NULL, but the routine still
    succeeds. If the number was bad or wasn't found before the
    separator or the separator couldd not be found before the end of
    the string , FALSE is returned. If a number
    was found and everything is fine, TRUE is returned.
*/
int CFUNC
ParseDecimalNumberAndFractionAndSeparator (
    LPCHAR  lpStr,
    LPULONG lpIndex,
    LPULONG lpNum,
    char    cSeparator1,
    char    cSeparator2)
{

    ParseDecimalSeparator (lpStr, lpIndex, lpNum, cSeparator1, cSeparator2);

    if  (lpStr[*lpIndex] == '.')
    {
        do
        {
            (*lpIndex)++;
        }
        while   ((lpStr[*lpIndex] != '-') && (lpStr[*lpIndex] != ','));

        (*lpIndex)++;
    }

    return  (TRUE);
}


/*
    GetDecimalValue

    This routine accepts a single char as an argument and returns
    the decimal value of that character.  If the char is not
    0-9 then 0x0FFFF is returned.
*/
ULONG CFUNC
GetDecimalValue (char cDigit)
{
    if  ((cDigit >= '0') && (cDigit <= '9'))
    {
        return  ((ULONG) (cDigit - '0'));
    }

    return  (0x0FFFFFFFF);
}


/*
    GetHexValue

    This routine accepts a single char as an argument and returns
    the hexidecimal value of that character.  If the char is not
    0-9,A-F,or a-f, then 0x0FFFF is returned.
*/
ULONG CFUNC
GetHexValue (char cDigit)
{
    if  ((cDigit >= '0') && (cDigit <= '9'))
    {
        return  ((ULONG) (cDigit - '0'));
    }
    else
    {
        if  ((cDigit >= 'A') && (cDigit <= 'F'))
        {
            return  ((ULONG) (cDigit - 'A' + 10));
        }
        else
        {
            if  ((cDigit >= 'a') && (cDigit <= 'f'))
            {
                return  ((ULONG) (cDigit - 'a' + 10));
            }
            else
            {
                return  (0x0FFFFFFFF);
            }
        }
    }
}


/*
    ParseHexSeparator

    This routine parses up to 8 hex digits from the string passed in.
    It assigns it into lpNum. Upon returning lpIndex is adjusted so
    that it points to the first char after the separator following the
    number parsed. If the number was bad, or if the separator was not
    one of two possible types or if the end of string was not found
    (i.e. NULL) immediately after it, then a FALSE is returned.
    Otherwise TRUE is returned.
*/
int CFUNC
ParseHexSeparator (
        LPCHAR  lpStr,
        LPULONG lpIndex,
        LPULONG lpNum,
        ULONG   dwLen,
        char    cSeparator1,
        char    cSeparator2)
{
    ULONG   dwI;
    ULONG   bFoundDigit;
    ULONG   dwHex;

    // We have to find at least one digit or there is an error.
    bFoundDigit = FALSE;

    // Start off lpNum at 0
    *lpNum = 0;

    // Get the value of the next eight hex digits.
    for (dwI = 0; dwI < dwLen; dwI++)
    {
        if  ((lpStr[*lpIndex] == cSeparator1) ||
             (lpStr[*lpIndex] == cSeparator2))
        {
            if  (!bFoundDigit)
            {
                DBG_PRINT1(DL_5, "\r\nBad Hex value in %s", lpStr);
                return  (FALSE);
            }

            DBG_PRINT1(DL_5, "\r\nParseHex found %lx.", *lpNum);

            // Only bump to after the separator if the separator was
            // not the end of the string
            if  (lpStr[*lpIndex] != 0)
                *lpIndex += 1;

            return  (TRUE);
        }

        // See if it is a hex digit
        dwHex = GetHexValue(lpStr[*lpIndex]);
        if  (dwHex == 0x0FFFFFFFF)
        {
            DBG_PRINT1(DL_5, "\r\nBad Hex value in %s", lpStr);
            return  (FALSE);
        }

        // We have found at least one decimal digit
        bFoundDigit = TRUE;

        *lpNum = (*lpNum << 4) + dwHex;

        // go to next char
        *lpIndex += 1;
    }

    // We fell out of the loop. That means that the maximum number of
    // hex digits has been seen. That is OK, but if the next char is
    // not one of the separators, then there is a parse error.
    if  ((lpStr[*lpIndex] != cSeparator1) &&
         (lpStr[*lpIndex] != cSeparator2))
    {
        DBG_PRINT1(DL_5, "\r\nHex value too big in %s", lpStr);
        return (FALSE);
    }

    // Only bump to after the separator if it was there
    if  ((lpStr[*lpIndex] == cSeparator1) ||
         (lpStr[*lpIndex] == cSeparator2))
        *lpIndex += 1;

    return  (TRUE);
}


/*
    ParseHexWord

    This routine parses up to 4 hex digits from the string passed in.
    If there are more than 4, then it is a parse error.
    It assigns it into lpNum. Upon returning lpIndex is adjusted so
    that it points to the first char after the semicolon following the
    number parsed. If the number was bad, or there was no semicolon
    or end of string (i.e. NULL) immediately after it, then a FALSE
    is returned. Otherwise TRUE is returned.
*/
int CFUNC
ParseHexWord (LPCHAR lpStr, LPULONG lpIndex, LPUSHORT lpNum)
{
    int     nRet;
    ULONG   dwNum;

    nRet = ParseHexSeparator (lpStr, lpIndex, &dwNum, 4, ';', ';');
    *lpNum = (USHORT) dwNum;

    return  (nRet);
}


/*
    ParseHexDWord

    This routine parses up to 8 hex digits from the string passed in.
    If there are more than 8, then it is a parse error.
    It assigns it into lpNum. Upon returning lpIndex is adjusted so
    that it points to the first char after the semicolon following the
    number parsed. If the number was bad, or there was no semicolon
    or end of string (i.e. NULL) immediately after it, then a FALSE
    is returned. Otherwise TRUE is returned.
*/
int CFUNC
ParseHexDWord (LPCHAR lpStr, LPULONG lpIndex, LPULONG lpNum)
{
    return  (ParseHexSeparator (lpStr, lpIndex, lpNum, 8, ';', 0));
}


/*
    GetMaximumRefreshRate

    This routine calculates the maximum refresh rate for the target mode
    specified given the maimum XRes and YRes, and the maximum horizontal
    and vertical frequencies.

*/

ULONG CFUNC
GetMaximumRefreshRate (ULONG dwPixelClkXRes,
                       ULONG dwPixelClkYRes,
                       ULONG dwPixelClkRR,
                       LPMONITORLIMITS lpML,
                       ULONG dwTargetXRes,
                       ULONG dwTargetYRes)
{
    ULONG   i;
    ULONG   dwRefreshRate;
    GTFIN   GTFIn;
    GTFOUT  GTFOut;
    ULONG   dwTotalPixels;
    ULONG   dwPixelClockInHz;
    ULONG   dwPixelClockInMHz;
    ULONG   dwHorizRR;
    ULONG   dwHTotalPixels;
    char    FoundRR;

    // If no pixel clock was passed in, calculate one.
    if (!lpML->dwMaxPixelClock)
    {
        // Find a pixel clock from the dwPixelClkXRes, dwPixelClkXRes, and
        // dwPixelClkRR.
        GTFIn.dwHPixels      = dwPixelClkXRes;
        GTFIn.dwVLines       = dwPixelClkYRes;
        GTFIn.dwMarginsRqd   = FALSE;
        GTFIn.dwIntRqd       = FALSE;
        GTFIn.dwIPParmType   = IPTYPE_VERTICAL_REFRESH_RATE;
        GTFIn.dwIPFreqRqd    = dwPixelClkRR;

        // Get the timing parameters.
        ComputeGTFParameters(&GTFIn, &GTFOut);
        dwPixelClockInHz = Multiply32By32(GTFOut.dwPixelClockIn10KHertz,
                                          10000);
        lpML->dwMaxPixelClock = dwPixelClockInHz;
    }
    else
        dwPixelClockInHz = lpML->dwMaxPixelClock;

    for (i = 0, FoundRR = FALSE; (FoundRR != TRUE) && i < 50; i++)
    {
        dwPixelClockInMHz = Divide32By32(dwPixelClockInHz + 1000000/2, 1000000);
    
        GTFIn.dwHPixels      = dwTargetXRes;
        GTFIn.dwVLines       = dwTargetYRes;
        GTFIn.dwMarginsRqd   = FALSE;
        GTFIn.dwIntRqd       = FALSE;
        GTFIn.dwIPParmType   = IPTYPE_PIXEL_CLOCK_RATE;
        GTFIn.dwIPFreqRqd    = dwPixelClockInMHz;
    
        // Get the timing parameters.
        ComputeGTFParameters(&GTFIn, &GTFOut);
    
        dwTotalPixels = Multiply32By32((GTFOut.dwHTotalChars << 3), GTFOut.dwVTotalScans);
    
        dwPixelClockInHz = Multiply32By32(GTFOut.dwPixelClockIn10KHertz, 10000);
        dwRefreshRate = Divide32By32(dwPixelClockInHz + dwTotalPixels/2, dwTotalPixels);
    
        if (dwRefreshRate < 56)
          dwRefreshRate = 60;

        dwHTotalPixels = GTFOut.dwHTotalChars << 3;
        dwHorizRR = Divide32By32(dwPixelClockInHz + dwHTotalPixels/2, dwHTotalPixels);
        if (dwHorizRR > lpML->dwMaxHorz)
        {
          dwPixelClockInHz = Multiply32By32(lpML->dwMaxHorz, dwHTotalPixels);
        }
        else if (dwRefreshRate > lpML->dwMaxVert)
        {
          dwPixelClockInHz = Multiply32By32(lpML->dwMaxVert, dwHTotalPixels);
          dwPixelClockInHz = Multiply32By32(dwPixelClockInHz, GTFOut.dwVTotalScans);
        }
        else
          FoundRR = TRUE;
    }
            
    if  (dwRefreshRate != 0)
        return  (dwRefreshRate);

    return  (60);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\modeset.mhd\CODE\MODESET.C ===
/*
    FILE:   modeset.c
    DATE:   4/8/99

    This file is the generic entry point for the modeset code.
    It contains all the high level logic when modesetting.

    The main entry point is
    FindModeEntry (lpDispData,lpEdidBuffer,dwEdidSize,lpModeDesc,lpModeOut);

    You should consult the header for FindModeEntry for specific details
    about the arguments.
*/

#include "cmntypes.h"
#include "modeext.h"
#include "modeset.h"
#include "debug.h"
#include "restime.h"
#include "tvmode.h"
#include "digmode.h"
#include "dmt.h"
#include "osapi.h"
#include "utils.h"

char    szDebug[512];
ULONG   dwDebugLevel = 0;

/*
    Function:   FindModeEntry

    Purpose:

    This routine validates and/or sets the mode. General idea:

    1) For NTSC and PAL devices, the requested mode is compared
       against the restriction list and the master mode list.
       The resolution is adjusted downward as necessary to find
       a mode that is allowed. If no mode is found that is
       permitted, the safe timing is returned.
       MODE_RESOLUTION_ADJUSTED is the actual return value if
       the mode timings returned are not for the mode that was
       requested.

       For NTSC and PAL, the only relevant input fields are:
       lpDispData (all fields), lpEdidBuffer should be NULL,
       dwEdidSize should be 0, lpModeDesc->nXRes, lpModeDesc->nYRes,
       lpModeDesc->nBpp, lpModeDesc->dwDevType should be DEVTYPE_NTSC
       or DEVTYPE_PAL as appropriate.

       On Exit, lpModeOut->rXRes and lpModeOut->rYRes will be assigned
       with the "best fit" mode that can be set. If you are validating
       an NTSC or PAL mode, then if this routine returns anything
       except MODE_EXACT_MATCH, the mode did not validate.

    2) For CRT and PANEL devices, the requested mode is compared
       against the restriction list and the master mode list.
       If necessary, first the refresh rate and as a last resort
       the resolution can be adjusted downward to find a mode that
       is allowed. If no mode is found that is permitted, a set of
       safe settings for some default mode is returned.

       For CRT and PANEL, the only relevant input fields are:
       lpDispData (all fields), lpEdidBuffer should point to a
       valid EDID if the device has one -- otherwise it shoud be NULL,
       dwEdidSize should be the size of the EDID in bytes -- otherwise
       it should be 0, lpModeDesc->nXRes, lpModeDesc->nYRes,
       lpModeDesc->nBpp, lpModeDesc->dwRefreshRate, lpModeDesc->dwDevType
       should be DEVTYPE_CRT or DEVTYPE_PANEL as appropriate,
       lpModeDesc->dwRefreshRate is a specific refresh rate value.

       For CRT and PANEL, the only possible return values are:
       MODE_RESOLUTION_ADJUSTED, MODE_REFRESH_RATE_ADJUSTED,
       or MODE_RESOLUTION_ADJUSTED | MODE_REFRESH_RATE_ADJUSTED.
       This flavor of the routine can NEVER fail. The lpModeOut
       structure should be filled out in its entirety -- all fields
       need to have describe a coherent valid timing. No exceptions.

    Arguments:
        LPDISPDATA      lpDispData
        LPCHAR          lpEdidBuffer
        ULONG           dwEdidSize
        LPMODEINFO      lpModeDesc
        LPMODEOUT       lpModeOut

    Preserve:   Do not change any fields in any of the arguments except
                to pass back the actual mode that was set in lpModeOut.
*/

int WINAPI
FindModeEntry (
    LPDISPDATA lpDispData,
    LPCHAR      lpEdidBuffer,
    ULONG       dwEdidSize,
    LPMODEINFO  lpModeDesc,
    LPMODEOUT   lpModeOut,
    LPMODEINFO  lpModeNew)
{
    int         nRet;
    LPRESTIME   lpRTList;
    LPMODEENTRY lpModeList;
    MODEINFO    ModeDesc;
    ULONG       dwModeSize;

    // Dump out what we are searching for
    DBG_PRINT0(DL_0, "\r\nSearching to match the following mode:");
    DBG_PRINT1(DL_0, "\r\nXRes           = %ld", lpModeDesc->dwXRes);
    DBG_PRINT1(DL_0, "\r\nYRes           = %ld", lpModeDesc->dwYRes);
    DBG_PRINT1(DL_0, "\r\nBpp            = %ld", lpModeDesc->dwBpp);
    DBG_PRINT1(DL_0, "\r\nRefreshRate    = %ld", lpModeDesc->dwRefreshRate);
    DBG_PRINT1(DL_0, "\r\ndwDevType      = %ld", lpModeDesc->MIDevData.cType);

    DBG_PRINT0(DL_0, "\r\n\nFor the following board:");
    DBG_PRINT1(DL_0, "\r\nDeviceID                = %lx", lpDispData->dwDeviceID);
    DBG_PRINT1(DL_0, "\r\nMaxDacSpeedInHertz8bpp  = %lx", lpDispData->dwMaxDacSpeedInHertz8bpp);
    DBG_PRINT1(DL_0, "\r\nMaxDacSpeedInHertz16bpp = %lx", lpDispData->dwMaxDacSpeedInHertz16bpp);
    DBG_PRINT1(DL_0, "\r\nMaxDacSpeedInHertz32bpp = %lx", lpDispData->dwMaxDacSpeedInHertz32bpp);
    DBG_PRINT1(DL_0, "\r\nVideoMemorySize         = %lx", lpDispData->dwVideoMemoryInBytes);

    // Grab the restriction and timing list
    lpRTList = GetMasterRTList (lpDispData);

    // Next, grab the mode list
    lpModeList = GetMasterModeList (lpDispData);

    // Let's assign this to a local so we can change it if we need
    // to without affecting the source.
    ModeDesc = lpModeDesc[0];

    // Let's handle the NTSC/PAL cases here, and be done with them.
    if  (lpModeDesc->MIDevData.cType == DEVTYPE_TV)
    {
        DBG_PRINT0 (DL_0, "\r\nDevice type is NTSC or PAL.");
        nRet = FindTVModeEntry (lpDispData, &ModeDesc, lpModeOut,
                                lpModeList, lpRTList);
    }
    else
    {
        // At this point, we know we are a CRT or FLAT PANEL.
        DBG_PRINT0 (DL_0, "\r\nDevice type is CRT or FLAT PANEL.");

        nRet = FindDigModeEntry (lpEdidBuffer, dwEdidSize, lpDispData,
                          &ModeDesc, lpModeOut, lpModeList, lpRTList);
    }

    // We need to set the pitch in the MODEOUT
    GetPitchAndSize (lpDispData, ModeDesc.dwXRes, ModeDesc.dwYRes,
                ModeDesc.dwBpp, &(lpModeOut->dwPitchInBytes), &dwModeSize);

    // Convert the MODEOUT structure back into a MODEINFO structure
    SetupParamsForModeInfo (lpModeOut, &ModeDesc, lpModeNew);

    FreeMasterRTList (lpRTList);
    FreeMasterModeList (lpModeList);

    return  (nRet);
}


/*
    Function:   FindVirtualModeEntry

    Purpose:

    This routine validates modes just against the amount of memory
    they will consume.No checking is done to see if the mode is
    settable on a CRTC or to get timing parameters for the mode.

    If the mode does not fit in the size specified, the mode is
    backed off progressively in resolution until it will fit.

    Arguments:
                lpRegData       LPREGDATA
                lpModeToTest    LPMODEINFO desribing the mode we want to
                                start out with
                lpModeThatFit   This will hold the mode that actually
                                will fit in dwAvailableMemory. It might
                                be the same as lpModeToTest.
                dwAvailableMemory memory available for the mode
                pfnGetModeMemory  Callback function to get the amount
                                of memory a mode takes up
                dwContext1      data to be passed into callback
                dwContext2      data to be passed into callback

        The format of the callback is:
        pfnGetModeMemory (dwContext1, dwContext2, xres, yres, bpp)
        It returns a ULONG that specifies the memory required to set
        the mode.

    Returns:    TRUE
    Preserve:
*/
typedef int (WINAPI *PFNGETMODEMEMORY) (ULONG, ULONG, ULONG, ULONG, ULONG);

int WINAPI
FindVirtualModeEntry (LPDISPDATA lpDispData, LPMODEINFO lpModeToTest,
                      LPMODEINFO lpModeThatFit, ULONG dwAvailableMemory)
{
    LPMODEENTRY lpModeList;
    ULONG       dwModeMemory, dwPitch;

    // Next, grab the mode list
    lpModeList = GetMasterModeList (lpDispData);

    // Let's assign this to a local so we can change it if we need
    // to without affecting the source.
    *lpModeThatFit = *lpModeToTest;

    do
    {
        GetPitchAndSize (lpDispData, lpModeThatFit->dwXRes,
                        lpModeThatFit->dwYRes, lpModeThatFit->dwBpp,
                        &dwPitch, &dwModeMemory);

        if  (dwModeMemory <= dwAvailableMemory)
            break;
    }
    while   (BackOffDigModeEntry (lpModeList, lpModeThatFit, lpModeToTest, 0));

    // Free this up
    FreeMasterModeList (lpModeList);

    return  (TRUE);
}


/*
    Function:   FindNextSmallerResolution

    Purpose:    This routine finds the next lower resolution at the
                same refresh rate and pixel depth as requested. If
                it finds one, it modifies lpModeDesc to reflect the
                new mode and returns TRUE, else it returns FALSE.

                There are certain modes that the other code in the
                modeset DLL will accept if they are received exactly
                as requested, but which we will never "back off" to
                reach. These modes are the non-desktop modes --
                things like modes smaller.than 640x480 and also the
                960x720 mode for DirectX. These modes will not be
                "found" as next smaller resolutions.

    Arguments:
                lpModeList  ptr to MODEENTRY array -- master mode list
                lpModeDesc  ptr to MODEINFO -- mode to back off

    Returns:    TRUE    lpModeDesc has new backed off mode
                FALSE   there was no smaller mode in the lpModeList

    Preserve:
*/
int CFUNC
FindNextSmallerResolution (
    LPMODEENTRY lpModeList,
    LPMODEINFO  lpModeDesc)
{
    int         i;
    MODEINFO    ModeIn, ModeSmaller;

    // This should be easy. We look at the mode in lpModeDesc and
    // Find the next smaller spatial resolution mode in lpModeList
    // that is at the same pixel depth. Smaller mode is defined as:
    // A lower value for the X-Res is definitely smaller
    // A same value for the X-Res forces a look at the Y-Res
    //      A lower value for the Y-Res is smaller

    // Save the passed in mode because we are going to change it.
    ModeIn = lpModeDesc[0];

    // Set up the smaller mode to be 0 initially
    ModeSmaller.dwXRes = 0;
    ModeSmaller.dwYRes = 0;

    for (i = 0; lpModeList[i].dwXRes != 0; i++)
    {
        if  ((lpModeList[i].dwBpp == ModeIn.dwBpp) &&
             (lpModeList[i].dwXRes >= 640) &&
             (lpModeList[i].dwYRes >= 480) &&
             (lpModeList[i].dwXRes != 960) &&
             (((lpModeList[i].dwXRes <= ModeIn.dwXRes) && (lpModeList[i].dwYRes <  ModeIn.dwYRes)) ||
              ((lpModeList[i].dwXRes < ModeIn.dwXRes) && (lpModeList[i].dwYRes <=  ModeIn.dwYRes)) ||
              ((lpModeList[i].dwXRes * lpModeList[i].dwYRes) < (ModeIn.dwXRes * ModeIn.dwYRes))))
        {
            // The lpModeList resolution is smaller. But is it the
            // largest of the smaller modes? Remember we are looking
            // for the next immediate smaller mode.
            if  ((ModeSmaller.dwXRes < lpModeList[i].dwXRes) ||
                 ((ModeSmaller.dwXRes == lpModeList[i].dwXRes) &&
                  (ModeSmaller.dwYRes <  lpModeList[i].dwYRes)))
            {
                ModeSmaller.dwXRes = lpModeList[i].dwXRes;
                ModeSmaller.dwYRes = lpModeList[i].dwYRes;
                ModeSmaller.dwBpp  = lpModeList[i].dwBpp;
                ModeSmaller.dwRefreshRate  = lpModeList[i].dwRefreshRate;
            }
        }
    }

    if  (ModeSmaller.dwXRes != 0)
    {
        ModeSmaller.MIDevData.cType = lpModeDesc->MIDevData.cType;
        lpModeDesc[0] = ModeSmaller;
        return  (TRUE);
    }

    return  (FALSE);
}


/*
    FindNextSmallerRefreshRate

    Purpose:    This routine finds the next lower refresh rate at
                the same resolution and pixel depth as requested.
                If it finds one, it modifies lpModeDesc to reflect
                the new mode and returns TRUE, else it returns FALSE.

    Arguments:
                lpModeList  ptr to MODEENTRY array -- master mode list
                lpModeDesc  ptr to MODEINFO -- mode to back off

    Returns:    TRUE    lpModeDesc has new backed off mode
                FALSE   there was no smaller mode in the lpModeList

    Preserve:
*/

int CFUNC
FindNextSmallerRefreshRate (
    LPMODEENTRY lpModeList,
    LPMODEINFO  lpModeDesc)
{
    int         i;
    MODEINFO    ModeIn, ModeSmaller;

    // This should be easy. We look at the mode in lpModeDesc and
    // Find the next smaller spatial resolution mode in lpModeList
    // that is at the same pixel depth. Smaller mode is defined as:
    // A lower value for the X-Res is definitely smaller
    // A same value for the X-Res forces a look at the Y-Res
    //      A lower value for the Y-Res is smaller

    // Save the passed in mode because we are going to change it.
    ModeIn = lpModeDesc[0];

    // Set up the smaller mode to be 0 initially
    ModeSmaller.dwRefreshRate = 0;

    for (i = 0; lpModeList[i].dwXRes != 0; i++)
    {
        if  ((lpModeList[i].dwBpp == ModeIn.dwBpp) &&
             (lpModeList[i].dwXRes == ModeIn.dwXRes) &&
             (lpModeList[i].dwYRes == ModeIn.dwYRes) &&
             (lpModeList[i].dwRefreshRate < ModeIn.dwRefreshRate))
        {
            // The lpModeList refreshRate is smaller. But is it the
            // largest of the smaller modes? Remember we are looking
            // for the next immediate smaller mode.
            if  ((ModeSmaller.dwRefreshRate < lpModeList[i].dwRefreshRate))
            {
                ModeSmaller.dwXRes = lpModeList[i].dwXRes;
                ModeSmaller.dwYRes = lpModeList[i].dwYRes;
                ModeSmaller.dwBpp  = lpModeList[i].dwBpp;
                ModeSmaller.dwRefreshRate  = lpModeList[i].dwRefreshRate;
            }
        }
    }

    if  (ModeSmaller.dwRefreshRate != 0)
    {
        ModeSmaller.MIDevData.cType = lpModeDesc->MIDevData.cType;
        lpModeDesc[0] = ModeSmaller;
        return  (TRUE);
    }

    return  (FALSE);
}


/*
    FindNextLargerRefreshRate

    Purpose:    This routine finds the next higher refresh rate at
                the same resolution and pixel depth as requested.
                If it finds one, it modifies lpModeDesc to reflect
                the new mode and returns TRUE, else it returns FALSE.

    Arguments:
                lpModeList  ptr to MODEENTRY array -- master mode list
                lpModeDesc  ptr to MODEINFO -- mode to back off

    Returns:    TRUE    lpModeDesc has new backed off mode
                FALSE   there was no smaller mode in the lpModeList

    Preserve:
*/

int CFUNC
FindNextLargerRefreshRate (
    LPMODEENTRY lpModeList,
    LPMODEINFO  lpModeDesc)
{
    int         i;
    MODEINFO    ModeIn, ModeLarger;

    // This should be easy. We look at the mode in lpModeDesc and
    // Find the next larger spatial resolution mode in lpModeList
    // that is at the same pixel depth. Larger mode is defined as:
    // A lower value for the X-Res is definitely smaller
    // A same value for the X-Res forces a look at the Y-Res
    //      A lower value for the Y-Res is smaller

    // Save the passed in mode because we are going to change it.
    ModeIn = lpModeDesc[0];

    for (i = 0; lpModeList[i].dwXRes != 0; i++)
    {
        if  ((lpModeList[i].dwBpp == ModeIn.dwBpp) &&
             (lpModeList[i].dwXRes == ModeIn.dwXRes) &&
             (lpModeList[i].dwYRes == ModeIn.dwYRes) &&
             (lpModeList[i].dwRefreshRate > ModeIn.dwRefreshRate))
        {
            // The lpModeList refreshRate is larger.
            ModeLarger.dwXRes = lpModeList[i].dwXRes;
            ModeLarger.dwYRes = lpModeList[i].dwYRes;
            ModeLarger.dwBpp  = lpModeList[i].dwBpp;
            ModeLarger.dwRefreshRate  = lpModeList[i].dwRefreshRate;
            ModeLarger.MIDevData.cType = lpModeDesc->MIDevData.cType;
            lpModeDesc[0] = ModeLarger;
            return  (TRUE);
        }
    }

    return  (FALSE);
}


/*
    Function:   GetSafeTiming

    Purpose:    This routine returns a "safe" set of timings for
                a special default mode. At the time this was
                written, that was 640x480 @ 60Hz DMT timing.

    Arguments:
                lpModeOrig  ptr to MODEINFO -- requested mode
                lpModeOut   ptr to MODEOUT  -- place to store
                            timings for safe mode

    Returns:    This routine returns the difference betweeen the
                mode specified by lpModeDesc and the mode
                specified by lpModeOut as logical ORs of the
                flags in modeext.h.
                MODE_EXACT_MATCH
                MODE_RESOLUTION_ADJUSTED
                MODE_PIXEL_DEPTH_ADJUSTED
                MODE_REFRESH_RATE_ADJUSTED

    Preserve:
*/
int WINAPI
GetSafeTiming (LPMODEINFO lpModeOrig, LPMODEOUT lpModeOut)
{
    MODEINFO    ModeDesc;

    DBG_PRINT0(DL_0, "\r\nEntering GetSafeTiming.");

    ModeDesc.dwXRes = 640;
    ModeDesc.dwYRes = 480;
    ModeDesc.dwBpp  = lpModeOrig->dwBpp;
    ModeDesc.dwRefreshRate = 60;
    ModeDesc.MIDevData.cType = lpModeOrig->MIDevData.cType;
    ModeDesc.dwOriginalRefreshRate = lpModeOrig->dwOriginalRefreshRate;

    // Account for case where pixel depth is 24-bit which is not supported.
    if  (lpModeOrig->dwBpp == 24)
        ModeDesc.dwBpp  = 16;

    DmtFindMode (&ModeDesc, lpModeOut);

    return  (GetModeFlags (lpModeOrig, &ModeDesc));
}


/*
    Function:   GetModeFlags

    Purpose:    This routine computes the difference betweeen the
                mode specified by lpModeOrig and the mode
                specified by lpModeFound as logical ORs of the
                flags in modeext.h.

    Purpose:    This routine returns a "safe" set of timings for
                a special default mode. At the time this was
                written, that was 640x480 @ 60Hz DMT timing.

    Arguments:
                lpModeDesc  ptr to MODEINFO -- requested mode
                lpModeOut   ptr to MODEOUT  -- place to store
                            timings for safe mode

    Returns:    This routine returns the difference betweeen the
                mode specified by lpModeOrig and the mode
                specified by lpModeFound as logical ORs of the
                flags in modeext.h.
                MODE_EXACT_MATCH
                MODE_RESOLUTION_ADJUSTED
                MODE_PIXEL_DEPTH_ADJUSTED
                MODE_REFRESH_RATE_ADJUSTED

    Preserve:
*/
int CFUNC
GetModeFlags (LPMODEINFO lpModeOrig, LPMODEINFO lpModeFound)
{
    int     nRet;

    // Figure out how the input mode differs from the safe mode and
    // return flags indicating the differences.
    nRet = 0;

    if  ((lpModeOrig->dwXRes != lpModeFound->dwXRes) ||
         (lpModeOrig->dwYRes != lpModeFound->dwYRes))
        nRet |= MODE_RESOLUTION_ADJUSTED;

    if  (lpModeOrig->dwRefreshRate != lpModeFound->dwRefreshRate)
        nRet |= MODE_REFRESH_RATE_ADJUSTED;

    if  (lpModeOrig->dwBpp != lpModeFound->dwBpp)
        nRet |= MODE_PIXEL_DEPTH_ADJUSTED;

    return  (nRet);
}


/*
    FormatModeList

    This routine parses the passed in modelist into the desired
    mode structure format.

    The modes are returned as either MODEENTRY, MODEENTRYNORR, or
    MODEENTRYANDPITCH structures depending upon the value of dwType.

    If dwType is MODETYPE_MODEENTRY, then MODEENTRY structures are
    returned. If dwType is MODETYPE_MODEENTRYNORR, then MODEENTRYNORR
    structures are returned. If dwType is MODETYPE_MODEENTRYANDPITCH,
    then MODEENTRYANDPITCH structures are returned.
*/
int WINAPI
FormatModeList (LPDISPDATA lpDispData, LPCHAR lpModes, ULONG dwType, LPMODEENTRY lpME)
{
    int         j;
    ULONG       dwModeSize;

    switch  (dwType)
    {
        case MODETYPE_MODEENTRY:
        {
            LPMODEENTRY lpDst;
            lpDst = (LPMODEENTRY) lpModes;

            // Just copy the list if they provide a ptr
            // If not, at least count the items
            for (j = 0; lpME[j].dwXRes != 0; j++)
                if  (lpDst)
                    lpDst[j] = lpME[j];

            break;
        }

        case MODETYPE_MODEENTRYNORR:
        {
            // Only one mode per refresh rate

            int             k, l;
            int             nDuplicate;
            LPMODEENTRYNORR lpDst;

            lpDst = (LPMODEENTRYNORR) lpModes;
            j = 0;

            for (k = 0; lpME[k].dwXRes != 0; k++)
            {
                nDuplicate = FALSE;

                for (l = 0; l < j; l++)
                {
                    if  ((lpDst[l].dwXRes == lpME[k].dwXRes) &&
                         (lpDst[l].dwYRes == lpME[k].dwYRes) &&
                         (lpDst[l].dwBpp  == lpME[k].dwBpp))
                    {
                        nDuplicate = TRUE;
                        break;
                    }
                }

                if  (!nDuplicate)
                {
                    // Copy the entry if it is a valid ptr.
                    // Otherwise just count them.
                    if  (lpDst)
                    {
                        lpDst[j].dwXRes = lpME[k].dwXRes;
                        lpDst[j].dwYRes = lpME[k].dwYRes;
                        lpDst[j].dwBpp  = lpME[k].dwBpp;
                    }
                    j++;
                }
            }
            break;
        }

        case MODETYPE_MODEENTRYANDPITCH:
        {
            // We don't actually fill in the pitch here, but
            // we use the correct structure so that the caller can.
            // Only one mode per refresh rate

            int                 k, l;
            int                 nDuplicate;
            LPMODEENTRYANDPITCH lpDst;

            lpDst = (LPMODEENTRYANDPITCH) lpModes;
            j = 0;

            for (k = 0; lpME[k].dwXRes != 0; k++)
            {
                nDuplicate = FALSE;

                for (l = 0; l < j; l++)
                {
                    if  ((lpDst[l].dwXRes == lpME[k].dwXRes) &&
                         (lpDst[l].dwYRes == lpME[k].dwYRes) &&
                         (lpDst[l].dwBpp  == lpME[k].dwBpp))
                    {
                        nDuplicate = TRUE;
                        break;
                    }
                }

                if  (!nDuplicate)
                {
                    // Copy the entry if it is a valid ptr.
                    // Otherwise just count them.
                    if  (lpDst)
                    {
                        lpDst[j].dwXRes  = lpME[k].dwXRes;
                        lpDst[j].dwYRes  = lpME[k].dwYRes;
                        lpDst[j].dwBpp   = lpME[k].dwBpp;
                        GetPitchAndSize (lpDispData, lpME[k].dwXRes,
                                    lpME[k].dwYRes, lpME[k].dwBpp,
                                    &(lpDst[j].dwPitch), &dwModeSize);
                    }
                    j++;
                }
            }
            break;
        }
    }

    return  (j);
}


/*
    GetModeList

    This routine gets the master mode list and returns it.

    The modes are returned as either MODEENTRY, MODEENTRYNORR, or
    MODEENTRYANDPITCH structures depending upon the value of dwType.

    If dwType is MODETYPE_MODEENTRY, then MODEENTRY structures are
    returned. If dwType is MODETYPE_MODEENTRYNORR, then MODEENTRYNORR
    structures are returned. If dwType is MODETYPE_MODEENTRYANDPITCH,
    then MODEENTRYANDPITCH structures are returned.
*/
int WINAPI
GetModeList (LPDISPDATA lpDispData, LPCHAR lpModes, ULONG dwType)
{
    LPMODEENTRY lpME;
    int         j;

    lpME = GetMasterModeList (lpDispData);

    j = FormatModeList (lpDispData, lpModes, dwType, lpME);

    FreeMasterModeList (lpME);
    return  (j);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\modeset.mhd\CODE\i386\gtfmath.asm ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gtf.asm
;
; Purpose:      This file implements the GTF algorithm
;
;       Just come important comments and definitions I extracted from
;       the GTF document.
;
;       Horizontal - negative
;       Vertical - positive
;       composite - negative
;
;       Blanking Duty Cycle = (1 - tA / T) * 100%
;                     = (       1 - (F * n) / p) * 100%
;               tA = active video time
;               T  = Horizontal period
;               F  = horizontal frequency
;               n  = number of active pixels (Xresolution)
;               p = pixel clock frequency
;
;       Basic form of equation is:
;       Blanking Duty Cycle = C' - (M' / F)
;
;       C' = ((C - J) * (K / 256) + J
;       M' = (K / 256) * M
;
;       Margin% = 1.8%
;       size of top and bottom overscan margin as % of active vertical
;       size of left and right overscan margin as % of active vertical
;
;       CellGran = 8 pixels
;       character cell granularity
;
;       MinPorch = 1 line / 1 char cell
;       Minimum front porch in lines and character cells
;
;       VsyncRqd = 3 lines
;       width of the vsync pulse in scanlines
;
;       HSyncPercent = 8%
;       The width of HSync as a percentage of the total line period
;
;       MinVSyncPlusBackPorch  550us
;       minimum time for vertical sync plus back porch
;
;       M       600% / Khz
;       blanking formula gradient
;
;       C       40%
;       blanking formula offset
;
;       K       128
;       blanking formula scaling factor
;
;       J       20%
;       blanking formula scaling factor weighting
;
;       HPixels    - the horizontal resolution
;       VLines     - the vertical resolution
;       MarginsRqd - this is a flag -- TRUE if borders, FLASE if none
;       IntRqd     - this is a flag -- TRUE if interlace, FALSE otherwise
;       IPParm     - this indicates what the last specifying parm will be
;               1  - VFrameRateRqd
;               2  - HFreq
;               3  - PixelClock
;       IPFreqRqd  - Depends upon VPParm
;               If IPParm is this       IPFreqRqd is this
;               1                       vertical refresh rate in hz
;               2                       horizontal refresh rate in Kilohz
;               3                       pixel clock rate in Megahz
;
;       Interestingly enough, the GTF spec says that any monitor that
;       has the GTF bit set, MUST have a Monitor Description Block in
;       the EDID that tells the monitor frequency limits. If this block
;       does not exist, then the monitor should be trated as non-GTF
;       compliant. Byte 10, bit 0 = 1 means that overscan margins are
;       required.
;==============================================================================
.586
include ..\include\macros.dat
include gtfmath.inc

.listall

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, USE32, CODE

fZeroPointFour                  REAL4   0.4
fZeroPointFive                  REAL4   0.5
fOne                            REAL4   1.0
fOnePointEight                  REAL4   1.8
fTwo                            REAL4   2.0
fThree                          REAL4   3.0
fEight                          REAL4   8.0
fTwenty                         REAL4   20.0
fForty                          REAL4   40.0
fOneHundred                     REAL4   100.0
fOneHundredTwentyEight          REAL4   128.0
fTwoHundredFiftySix             REAL4   256.0
fFiveHundredFifty               REAL4   550.0
fSixHundred                     REAL4   600.0
fOneThousand                    REAL4   1000.0
fOneMillion                     REAL4   1000000.0

;==============================================================================
;
; Function:     ComputeGTFParameters
;
; Purpose:      This function computes the data for the GTFOut structure
;               from the arguments in the GTFIn structure provided
;               according to the GTF formula.
;
; Arguments:    lpGTFIn         FAR ptr to GTFIN structure
;               lpGTFOut        FAR ptr to GTFOUT structure
;
; Returns:      eax     0       failure and lpGTFOut was not filled in
;                       non-0   success and lpGTFOut was filled in
;
; Preserve:     All registers
;==============================================================================
IFDEF  _WIN32
DECPROC ComputeGTFParameters, STANDARD, FRAME, NEAR
ELSE
DECPROC ComputeGTFParameters, PASCAL, FRAME, FAR16
ENDIF
PARMD   lpGTFIn
PARMD   lpGTFOut
OPENPROC
        PUSHR   ds,ebx,esi,edi
IFDEF _WIN32
        mov     ebx,lpGTFIn
        mov     esi,lpGTFOut
ELSE
        sub     ebx,ebx
        lds     bx,lpGTFIn
        sub     esi,esi
        les     si,lpGTFOut
ENDIF
        call    ComputeGTFParameters1
        POPR    ds,ebx,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     ComputeGTFParameters1
;
; Purpose:      This function computes the data for the GTFOut structure
;               from teh arguments in the GTFIn structure provided
;               according to the GTF formula.
;
; Arguments:    ds:ebx  GTFIN ptr
;               es:esi  GTFOUT ptr
;
; Returns:      eax     0       failure and lpGTFOut was not filled in
;                       non-0   success and lpGTFOut was filled in
;
; Preserve:     All registers
;==============================================================================
DECPROC ComputeGTFParameters1, PASCAL, FRAME, NEAR
LOCALD  dwTemp
LOCALR4 fVLinesRnd
LOCALR4 fAddrLinesPerFrame
LOCALR4 fCellGran
LOCALR4 fPixelFreq
LOCALR4 fCharTime
LOCALR4 fTopMarginLines
LOCALR4 fBottomMarginLines
LOCALR4 fVSyncPlusBackPorch
LOCALR4 fMinPorch
LOCALR4 fInterlace
LOCALR4 fTotalLinesPerFrame
LOCALR4 fTotalPixels
LOCALR4 fTotalHTimeChars
LOCALR4 fHPixelsRnd
LOCALR4 fHAddrTime
LOCALR4 fHAddrTimeChars
LOCALR4 fHBlankPixels
LOCALR4 fHBlank
LOCALR4 fHBlankChars
LOCALR4 fLeftMarginPixels
LOCALR4 fRightMarginPixels
LOCALR4 fHBlankPlusMargin
LOCALR4 fHBlankPlusMarginChars
LOCALR4 fActualDutyCycle
LOCALR4 fBlankPlusMarginDutyCycle
LOCALR4 fLeftMargin
LOCALR4 fLeftMarginChars
LOCALR4 fRightMargin
LOCALR4 fRightMarginChars
LOCALR4 fHSyncPercent
LOCALR4 fHSyncPixels
LOCALR4 fHFrontPorchPixels
LOCALR4 fHBackPorchPixels
LOCALR4 fHSyncChars
LOCALR4 fHSync
LOCALR4 fHFrontPorchChars
LOCALR4 fHFrontPorch
LOCALR4 fHBackPorchChars
LOCALR4 fHBackPorch
LOCALR4 fTotalVLines
LOCALR4 fHPeriod
LOCALR4 fVFramePeriod
LOCALR4 fVFieldPeriod
LOCALR4 fVAddrTimePerFrame
LOCALR4 fVAddrTimePerField
LOCALR4 fVOddBlankingLines
LOCALR4 fVOddBlanking
LOCALR4 fVEvenBlankingLines
LOCALR4 fVEvenBlanking
LOCALR4 fTopMargin
LOCALR4 fVOddFrontPorch
LOCALR4 fVOddFrontPorchLines
LOCALR4 fVEvenFrontPorch
LOCALR4 fVSyncRqd
LOCALR4 fVSync
LOCALR4 fVBackPorch
LOCALR4 fVEvenBackPorch
LOCALR4 fVBackPorch
LOCALR4 fVEvenBackPorchLines
LOCALR4 fVOddBackPorch
LOCALR4 fBottomMargin
LOCALR4 fMarginPercent
LOCALR4 fMinVSyncPlusBackPorch
LOCALR4 fGTF_M
LOCALR4 fGTF_C
LOCALR4 fGTF_J
LOCALR4 fGTF_K
LOCALR4 fGTF_CPrime
LOCALR4 fGTF_MPrime
LOCALR4 fVFieldRateRqd
LOCALR4 fHPeriodEst
LOCALR4 fVFieldRateEst
LOCALR4 fVFieldRate
LOCALR4 fVFrameRate
LOCALR4 fTotalActivePixels
LOCALR4 fIdealDutyCycle
LOCALR4 fHFreq
LOCALR4 fIdealHPeriod
OPENPROC
        PUSHR   ds,ebx,esi,edi

        ; Reset the floating point unit
        fninit

        ; Set up all the constants we need
        call    SetupGTFConstants

        ; Now we compute the stage 1 parameters. There are three cases
        ; depending upon the IPParm which gives the type of the IPFreqRqd.
        push    OFFSET DoneStage1Parms
        cmp     ds:[ebx].GTFIN.dwIPParmType,IPTYPE_VERTICAL_REFRESH_RATE
        je      VerticalRefreshToStage1Parameters
        cmp     ds:[ebx].GTFIN.dwIPParmType,IPTYPE_HORIZONTAL_REFRESH_RATE
        je      HorizontalRefreshToStage1Parameters
        cmp     ds:[ebx].GTFIN.dwIPParmType,IPTYPE_PIXEL_CLOCK_RATE
        je      PixelClockToStage1Parameters
        pop     eax
        sub     eax,eax
        jmp     Done

DoneStage1Parms:
        ; Convert stage 1 to stage 2 parameters

        ; 1) Find the adressable lines per frame
        fld     fVLinesRnd
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fadd    ST(0),ST(0)
@@:     fstp    fAddrLinesPerFrame

        ; 2) Find the character time in nanoseconds
        fld     fCellGran
        fdiv    fPixelFreq
        fmul    fOneThousand
        fstp    fCharTime

        ; 3) Find total number of lines in a frame
        fld     fVLinesRnd
        fadd    fTopMarginLines
        fadd    fBottomMarginLines
        fadd    fVSyncPlusBackPorch
        fadd    fMinPorch
        fadd    fInterlace
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fadd    ST(0),ST(0)
@@:     fstp    fTotalLinesPerFrame

        ; 4) Find total number of chars in a horizontal line
        fld     fTotalPixels
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fstp    fTotalHTimeChars

        ; 5) Find the horizontal addressable time in microseconds
        fld     fHPixelsRnd
        fdiv    fPixelFreq
        fstp    fHAddrTime

        ; 6) Find the horizontal addressable time in chars
        fld     fHPixelsRnd
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fstp    fHAddrTimeChars

        ; 7) Find horizontal blanking time in microseconds
        fld     fHBlankPixels
        fdiv    fPixelFreq
        fstp    fHBlank

        ; 8) Find horizontal blanking time in chars
        fld     fHBlankPixels
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fstp    fHBlankChars

        ; 9) Find the horizontal blanking plus margin time in microseconds
        fld     fHBlankPixels
        fadd    fLeftMarginPixels
        fadd    fRightMarginPixels
        fdiv    fPixelFreq
        fstp    fHBlankPlusMargin

        ; 10) Find the horizontal blanking plus margin time in chars
        fld     fHBlankPixels
        fadd    fLeftMarginPixels
        fadd    fRightMarginPixels
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fstp    fHBlankPlusMarginChars

        ; 11) Find the actual horizontal active video duty cycle in %
        fld     fHBlankChars
        fdiv    fTotalHTimeChars
        fmul    fOneHundred
        fstp    fActualDutyCycle

        ; 12) Find the image video duty cycle in %
        fld     fHBlankPlusMarginChars
        fdiv    fTotalHTimeChars
        fmul    fOneHundred
        fstp    fBlankPlusMarginDutyCycle

        ; 13) Find the left margin time in microseconds
        fld     fLeftMarginPixels
        fmul    fPixelFreq
        fmul    fOneThousand
        fstp    fLeftMargin

        ; 14) Find the number of chars in the left margin
        fld     fLeftMarginPixels
        fdiv    fCellGran
        fstp    fLeftMarginChars

        ; 15) Find the right margin time in microseconds
        fld     fRightMarginPixels
        fmul    fPixelFreq
        fmul    fOneThousand
        fstp    fRightMargin

        ; 16) Find the number of chars in the rightt margin
        fld     fRightMarginPixels
        fdiv    fCellGran
        fstp    fRightMarginChars

        ; 17) Find the number of pixels inteh horizontal sync period
        fld     fHSyncPercent
        fdiv    fOneHundred
        fmul    fTotalPixels
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
        fstp    fHSyncPixels

        ; 18) Find number of pixels in horizontal front porch period
        fld     fHBlankPixels
        fdiv    fTwo
        fsub    fHSyncPixels
        fstp    fHFrontPorchPixels

        ; 19) Find number of pixels in horizontal front porch period
        fld     fHFrontPorchPixels
        fadd    fHSyncPixels
        fstp    fHBackPorchPixels

        ; 20) Find number of characters in the horizontal sync period
        fld     fHSyncPixels
        fdiv    fCellGran
        fstp    fHSyncChars

        ; 21) Find the horizontal sync period in microseconds
        fld     fHSyncPixels
        fdiv    fPixelFreq
        fstp    fHSync

        ; 22) Find the number of chars in the horizontal front porch
        fld     fHFrontPorchPixels
        fdiv    fCellGran
        fstp    fHFrontPorchChars

        ; 23) Find the horizontal front porch period in microseconds
        fld     fHFrontPorchPixels
        fdiv    fPixelFreq
        fstp    fHFrontPorch

        ; 24) Find the number of chars in the horizontal back porch
        fld     fHBackPorchPixels
        fdiv    fCellGran
        fstp    fHBackPorchChars

        ; 25) Find the horizontal front back period in microseconds
        fld     fHBackPorchPixels
        fdiv    fPixelFreq
        fstp    fHBackPorch

        ; 26) Find the vertical frame period in milliseconds
        fld     fTotalVLines
        fmul    fHPeriod
        fdiv    fOneThousand
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fmul    fTwo
@@:     fstp    fVFramePeriod

        ; 27) Find the vertical field period in milliseconds
        fld     fTotalVLines
        fmul    fHPeriod
        fdiv    fOneThousand
        fstp    fVFieldPeriod

        ; 28) Find the addressable vertical period per frame in milliseconds
        fld     fVLinesRnd
        fmul    fHPeriod
        fdiv    fOneThousand
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fmul    fTwo
@@:     fstp    fVAddrTimePerFrame

        ; 29) Find the addressable vertical period per field in milliseconds
        fld     fVLinesRnd
        fmul    fHPeriod
        fdiv    fOneThousand
        fstp    fVAddrTimePerField

        ; 30) Find the number of lines in teh odd blanking period
        fld     fVSyncPlusBackPorch
        fadd    fMinPorch
        fstp    fVOddBlankingLines

        ; 31) Find the odd blanking period in milliseconds
        fld     fVSyncPlusBackPorch
        fadd    fMinPorch
        fmul    fHPeriod
        fdiv    fOneThousand
        fstp    fVOddBlanking

        ; 32) Find the number of lines in the even blanking period
        fld     fVSyncPlusBackPorch
        fadd    fMinPorch
        fadd    fInterlace
        fadd    fInterlace
        fstp    fVEvenBlankingLines

        ; 33) Find the even blanking period in milliseconds
        fld     fVSyncPlusBackPorch
        fadd    fMinPorch
        fadd    fInterlace
        fadd    fInterlace
        fmul    fHPeriod
        fdiv    fOneThousand
        fstp    fVEvenBlanking

        ; 34) Find the top margin period in microseconds
        fld     fTopMarginLines
        fmul    fHPeriod
        fstp    fTopMargin

        ; 35) Find the odd front porch in microseconds
        fld     fMinPorch
        fadd    fInterlace
        fmul    fHPeriod
        fstp    fVOddFrontPorch

        ; 36) Find the number of lines in the odd front porch period
        fld     fMinPorch
        fadd    fInterlace
        fstp    fVOddFrontPorchLines

        ; 37) Find the even front porch period
        fld     fMinPorch
        fmul    fHPeriod
        fstp    fVEvenFrontPorch

        ; 38) Find the vertcial sync period in microseconds
        fld     fVSyncRqd
        fmul    fHPeriod
        fstp    fVSync

        ; 39) Find the even front porch period in microseconds
        fld     fVBackPorch
        fadd    fInterlace
        fmul    fHPeriod
        fstp    fVEvenBackPorch

        ; 40) Find the number of lines in the even fron tporch period
        fld     fVBackPorch
        fadd    fInterlace
        fstp    fVEvenBackPorchLines

        ; 41) Find the odd back porch period in microseconds
        fld     fVBackPorch
        fmul    fHPeriod
        fstp    fVOddBackPorch

        ; 42) Find the bottom margin period in microseconds
        fld     fBottomMarginLines
        fmul    fHPeriod
        fstp    fBottomMargin

        ; Cram all the data into GTFOut
        fld     fTotalHTimeChars
        fistp   es:[esi].GTFOUT.dwHTotalChars
        fld     fTotalLinesPerFrame
        fistp   es:[esi].GTFOUT.dwVTotalScans
        fld     fHAddrTimeChars
        fistp   es:[esi].GTFOUT.dwHActiveChars
        fld     fVLinesRnd
        fistp   es:[esi].GTFOUT.dwVActiveScans
        fld     fHAddrTimeChars
        fadd    fRightMarginChars
        fistp   es:[esi].GTFOUT.dwHBlankStartChar
        fld     fHFrontPorchChars
        fistp   es:[esi].GTFOUT.dwHFrontPorchChars
        fld     fHSyncChars
        fistp   es:[esi].GTFOUT.dwHSyncChars
        fld     fHBackPorchChars
        fistp   es:[esi].GTFOUT.dwHBackPorchChars
        fld     fTotalHTimeChars
        fsub    fLeftMarginChars
        fistp   es:[esi].GTFOUT.dwHBlankEndChar
        fld     fVLinesRnd
        fadd    fBottomMarginLines
        fistp   es:[esi].GTFOUT.dwVBlankStartScan
        fld     fVOddFrontPorchLines
        fistp   es:[esi].GTFOUT.dwVFrontPorchScans
        fld     fVSyncRqd
        fistp   es:[esi].GTFOUT.dwVSyncScans
        fld     fVEvenBackPorchLines
        fistp   es:[esi].GTFOUT.dwVBackPorchScans
        fld     fTotalLinesPerFrame
        fsub    fTopMarginLines
        fistp   es:[esi].GTFOUT.dwVBlankEndScan
        fld     fPixelFreq
;;;        fmul    fOneMillion
        fmul    fOneHundred
        fistp   es:[esi].GTFOUT.dwPixelClockIn10KHertz

        ; Return success
        mov     eax,1

Done:
        POPR    ds,ebx,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     SetupGTFConstants
;
; Purpose:      This function sets up all the "constants" used by
;               the GTF calculation. I make these constants into
;               variables because the spec says to -- at some point
;               in the future the GTF spec may be extended and they
;               want the flexibility to adjust these "constants" to
;               new values. By making the constants into variables
;               I just make the upgrade path easy.
;
;
; Arguments:
;
; Returns:      None
;
; Preserve:     ds,ebx,es,esi
;==============================================================================
DECPROC SetupGTFConstants, PASCAL, NOFRAME, NEAR
OPENPROC
        PUSHR   ds,ebx,es,esi

        ; This is the size of the top (or bottom -- they are the same)
        ; overscan area as a percentage of the total vertcical time.
        fld     fOnePointEight
        fstp    fMarginPercent

        ; Number of pixels per character cell
        fld     fEight
        fstp    fCellGran

        ; Minimum horizontal front porch in character cells and
        ; minimum vertical front porch in scanlines (they are the same.)
        fld     fOne
        fstp    fMinPorch

        ; Width of vsync pulse in scanlines
        fld     fThree
        fstp    fVSyncRqd

        ; Width of the hsync pulse as a percentage of horizontal line time
        fld     fEight
        fstp    fHSyncPercent

        ; minimum time for vertical sync plus back porch in microseconds
        fld     fFiveHundredFifty
        fstp    fMinVSyncPlusBackPorch

        ; These apply to the Basic Blanking Duty Cycle Equation.
        ; See the top of the file.
        fld     fSixHundred
        fstp    fGTF_M
        fld     fForty
        fstp    fGTF_C
        fld     fOneHundredTwentyEight
        fstp    fGTF_K
        fld     fTwenty
        fstp    fGTF_J

        ; This is forced by GTF definitions
        ; C' = ((C - J) * (K / 256) + J
        fld     fGTF_K
        fdiv    fTwoHundredFiftySix
        fld     fGTF_C
        fsub    fGTF_J
        fmulp   ST(1),ST(0)
        fadd    fGTF_J
        fstp    fGTF_CPrime

        ; This is forced by GTF definitions
        ; M' = (K / 256) * M
        fld     fGTF_K
        fdiv    fTwoHundredFiftySix
        fmul    fGTF_M
        fstp    fGTF_MPrime

        POPR    ds,ebx,es,esi
CLOSEPROC


;==============================================================================
;
; Function:     VerticalRefreshToStage1Parameters
;
; Purpose:      This function compautes GTF stage 1 parameters assuming
;               that the following parameters are given in the GTFIn struct.
;
;               These are always required by GTF:
;               HPixels    - the horizontal resolution
;               VLines     - the vertical resolution
;               MarginsRqd - this is a flag -- TRUE if borders, FLASE if none
;               IntRqd     - this is a flag -- TRUE if interlace, else FALSE
;
;               For this computation these parameters are:
;               IPParm     - This value is IPTYPE_VERTICAL_REFRESH_RATE
;               IPFreqRqd  - vertical refresh rate in hertz
;
; Arguments:    ds:ebx  ptr to lpGTFIn structure
;               You have the stack frame available to ComputeGTFParameters
;               but be careful about ptrs, because they are flat 32bit ptrs
;               if you are running under WinNT and 16:16 ptrs if you are
;               running under Win9X. You shouldn't need to load any ptrs
;               since lpGTFIn is already passed into this routine in the
;               correct format.
;
; Returns:      None
;
; Preserve:     ds,esi,edi,ebx
;==============================================================================
DECPROC VerticalRefreshToStage1Parameters, PASCAL, NOFRAME, NEAR
OPENPROC
        PUSHR   ds,ebx,es,esi

        ; 1) Make sure that the XResolution is a multiple of char cell size
        fild    ds:[ebx].GTFIN.dwHPixels
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
        fstp    fHPixelsRnd

        ; 2) If interlace is requested, half the number of vertical lines
        ;    since the calculation is really vertical lines per field
        fild    ds:[ebx].GTFIN.dwVLines
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fdiv    fTwo
@@:     fstp    fVLinesRnd

        ; 3) Find the frame rate required
        fild    ds:[ebx].GTFIN.dwIPFreqRqd
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fadd    ST(0),ST(0)
@@:     fstp    fVFieldRateRqd

        ; 4) Find the number of lines in the top margin
        fldz
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fMarginPercent
        fdiv    fOneHundred
        fmul    fVLinesRnd
@@:     fstp    fTopMarginLines

        ; 5) Find the number of lines in the bottom margin
        fldz
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fMarginPercent
        fdiv    fOneHundred
        fmul    fVLinesRnd
@@:     fstp    fBottomMarginLines

        ; 6) If interlace is required, set dwInterlace to 0.5
        fldz
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fZeroPointFive
@@:     fstp    fInterlace

        ; 7) Estimate the horizontal period
        fld1
        fdiv    fVFieldRateRqd
        fld     fMinVSyncPlusBackPorch
        fdiv    fOneMillion
        fsubp   ST(1),ST(0)
        fld     fVLinesRnd
        fadd    fTopMarginLines
        fadd    fTopMarginLines
        fadd    fMinPorch
        fadd    fInterlace
        fdivp   ST(1),ST(0)
        fmul    fOneMillion
        fstp    fHPeriodEst

        ; 8) Find the number of lines in fMinVSyncPlusBackPorch
        fld     fMinVSyncPlusBackPorch
        fdiv    fHPeriodEst
        fistp   dwTemp
        fild    dwTemp
        fstp    fVSyncPlusBackPorch

        ; 9) Find the number of lines in VBackPorch alone
        fld     fVSyncPlusBackPorch
        fsub    fVSyncRqd
        fstp    fVBackPorch

        ; 10) Find the total number of lines in the vertical field
        fld     fVLinesRnd
        fadd    fTopMarginLines
        fadd    fBottomMarginLines
        fadd    fVSyncPlusBackPorch
        fadd    fMinPorch
        fadd    fInterlace
        fstp    fTotalVLines

        ; 11) Estimate the vertical field frequency
        fld1
        fdiv    fHPeriodEst
        fdiv    fTotalVLines
        fmul    fOneMillion
        fstp    fVFieldRateEst

        ; 12) Find the actual horizontal period
        fld     fHPeriodEst
        fmul    fVFieldRateEst
        fdiv    fVFieldRateRqd
        fstp    fHPeriod

        ; 13) Find the actual vertical field frequency
        fld1
        fdiv    fHPeriod
        fdiv    fTotalVLines
        fmul    fOneMillion
        fstp    fVFieldRate

        ; 14) Find the vertical frame frequency
        fld     fVFieldRate
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fdiv    fTwo
@@:     fstp    fVFrameRate

        ; 15) Find the number of pixels in the left margin
        fldz
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fHPixelsRnd
        fmul    fMarginPercent
        fdiv    fOneHundred
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
@@:     fstp    fLeftMarginPixels

        ; 16) Find the number of pixels in the right margin
        fldz
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fHPixelsRnd
        fmul    fMarginPercent
        fdiv    fOneHundred
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
@@:     fstp    fRightMarginPixels

        ; 17) Find total number of active pixels in image+left+right margin
        fld     fHPixelsRnd
        fadd    fLeftMarginPixels
        fadd    fRightMarginPixels
        fstp    fTotalActivePixels

        ; 18) Find the ideal Blanking duty cycle
        fld     fGTF_CPrime
        fld     fGTF_MPrime
        fmul    fHPeriod
        fdiv    fOneThousand
        fsubp   ST(1),ST(0)
        fstp    fIdealDutyCycle

        ; 19) Find the number of pixels in the blanking time to the
        ; nearest double character cell
        fld     fTotalActivePixels
        fmul    fIdealDutyCycle
        fld     fOneHundred
        fsub    fIdealDutyCycle
        fdivp   ST(1),ST(0)
        fld     fCellGran
        fadd    ST(0),ST(0)
        fdivp   ST(1),ST(0)
        fistp   dwTemp
        fild    dwTemp
        fadd    ST(0),ST(0)
        fmul    fCellGran
        fstp    fHBlankPixels

        ; 20) Find the total number of pixels
        fld     fTotalActivePixels
        fadd    fHBlankPixels
        fstp    fTotalPixels

        ; 21) Find the pixel clock frequency
        fld     fTotalPixels
        fdiv    fHPeriod
        fstp    fPixelFreq

        ; 22) Find the horizontal frequency
        fld     fOneThousand
        fdiv    fHPeriod
        fstp    fHFreq

        POPR    ds,ebx,es,esi
CLOSEPROC


;==============================================================================
;
; Function:     HorizontalRefreshToStage1Parameters
;
; Purpose:      This function compautes GTF stage 1 parameters assuming
;               that the following parameters are given:
;
;               These are always required by GTF:
;               HPixels    - the horizontal resolution
;               VLines     - the vertical resolution
;               MarginsRqd - this is a flag -- TRUE if borders, FLASE if none
;               IntRqd     - this is a flag -- TRUE if interlace, else FALSE
;
;               For this computation these parameters are:
;               IPParm     - IPTYPE_HORIZONTAL_REFRESH_RATE
;               IPFreqRqd  - horizontal refresh rate in Kilohertz
;
; Arguments:
;
; Returns:      None
;
; Preserve:     ds,ebx,es,esi
;==============================================================================
DECPROC HorizontalRefreshToStage1Parameters, PASCAL, NOFRAME, NEAR
OPENPROC
        PUSHR   ds,ebx,es,esi

        ; 1) Make sure that the XResolution is a multiple of char cell size
        fild    ds:[ebx].GTFIN.dwHPixels
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
        fstp    fHPixelsRnd

        ; 2) If interlace is requested, half the number of vertical lines
        ;    since the calculation is really vertical lines per field
        fild    ds:[ebx].GTFIN.dwVLines
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fdiv    fTwo
@@:     fstp    fVLinesRnd

        ; 3) Find the horizontal freqency required
        fild    ds:[ebx].GTFIN.dwIPFreqRqd
        fstp    fHFreq

        ; 4) Find the number of lines in the top margin
        sub     eax,eax
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        fld     fMarginPercent
        fmul    fVLinesRnd
        fdiv    fOneHundred
@@:     fstp    fTopMarginLines

        ; 5) Find the number of lines in the bottom margin
        sub     eax,eax
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        fld     fMarginPercent
        fmul    fVLinesRnd
        fdiv    fOneHundred
@@:     fstp    fBottomMarginLines

        ; 6) If interlace is required, set dwInterlace to 0.5
        fldz
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fZeroPointFive
@@:     fstp    fInterlace

        ; 7) Find the number of lines in fMinVSyncPlusBackPorch
        fld     fMinVSyncPlusBackPorch
        fmul    fHFreq
        fdiv    fOneThousand
        fistp   dwTemp
        fild    dwTemp
        fstp    fVSyncPlusBackPorch

        ; 8) Find the number of lines in VBackPorch alone
        fld     fVSyncPlusBackPorch
        fsub    fVSyncRqd
        fstp    fVBackPorch

        ; 9) Find the total number of lines in the vertical field
        fld     fVLinesRnd
        fadd    fTopMarginLines
        fadd    fBottomMarginLines
        fadd    fVSyncPlusBackPorch
        fadd    fMinPorch
        fadd    fInterlace
        fstp    fTotalVLines

        ; 10) Find the actual vertical field frequency
        fld     fHFreq
        fdiv    fTotalVLines
        fmul    fOneThousand
        fstp    fVFieldRate

        ; 11) Find the vertical frame frequency
        fld     fVFieldRate
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fdiv    fTwo
@@:     fstp    fVFrameRate

        ; 12) Find the number of pixels in the left margin
        fldz
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fHPixelsRnd
        fmul    fMarginPercent
        fdiv    fOneHundred
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
@@:     fstp    fLeftMarginPixels

        ; 13) Find the number of pixels in the right margin
        fldz
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fHPixelsRnd
        fmul    fMarginPercent
        fdiv    fOneHundred
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
@@:     fstp    fRightMarginPixels

        ; 14) Find total number of active pixels in image+left+right margin
        fld     fHPixelsRnd
        fadd    fLeftMarginPixels
        fadd    fRightMarginPixels
        fstp    fTotalActivePixels

        ; 15) Find the ideal Blanking duty cycle
        fld     fGTF_CPrime
        fld     fGTF_MPrime
        fdiv    fHFreq
        fsubp   ST(1),ST(0)
        fstp    fIdealDutyCycle

        ; 16) Find the number of pixels in the blanking time to the
        ; nearest double character cell
        fld     fTotalActivePixels
        fmul    fIdealDutyCycle
        fld     fOneHundred
        fsub    fIdealDutyCycle
        fdivp   ST(1),ST(0)
        fld     fCellGran
        fadd    ST(0),ST(0)
        fdivp   ST(1),ST(0)
        fistp   dwTemp
        fild    dwTemp
        fadd    ST(0),ST(0)
        fmul    fCellGran
        fstp    fHBlankPixels

        ; 17) Find the total number of pixels
        fld     fTotalActivePixels
        fadd    fHBlankPixels
        fstp    fTotalPixels

        ; 18) Find the horizontal frequency
        fld     fOneThousand
        fdiv    fHFreq
        fstp    fHPeriod

        ; 19) Find the pixel clock frequency
        fld     fTotalPixels
        fmul    fHFreq
        fdiv    fOneThousand
        fstp    fPixelFreq

        POPR    ds,ebx,es,esi
CLOSEPROC


;==============================================================================
;
; Function:     PixelClockToStage1Parameters
;
; Purpose:      This function compautes GTF stage 1 parameters assuming
;               that the following parameters are given:
;
;               These are always required by GTF:
;               HPixels    - the horizontal resolution
;               VLines     - the vertical resolution
;               MarginsRqd - this is a flag -- TRUE if borders, FLASE if none
;               IntRqd     - this is a flag -- TRUE if interlace, else FALSE
;
;               For this computation these parameters are:
;               IPParm     - IPTYPE_PIXEL_CLOCK_RATE
;               IPFreqRqd  - pixel clock rate in Megahertz
;
; Arguments:
;
; Returns:      None
;
; Preserve:     ds,ebx,es,esi
;==============================================================================
DECPROC PixelClockToStage1Parameters, PASCAL, NOFRAME, NEAR
OPENPROC
        PUSHR   ds,ebx,es,esi

        ; 1) Make sure that the XResolution is a multiple of char cell size
        fild    ds:[ebx].GTFIN.dwHPixels
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
        fstp    fHPixelsRnd

        ; 2) If interlace is requested, half the number of vertical lines
        ;    since the calculation is really vertical lines per field
        fild    ds:[ebx].GTFIN.dwVLines
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fdiv    fTwo
@@:     fstp    fVLinesRnd

        ; 3) Find the horizontal freqency required
        fild    ds:[ebx].GTFIN.dwIPFreqRqd
        fstp    fPixelFreq

        ; 4) Find the number of pixels in the left margin
        fldz
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fHPixelsRnd
        fmul    fMarginPercent
        fdiv    fOneHundred
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
@@:     fstp    fLeftMarginPixels

        ; 5) Find the number of pixels in the right margin
        fldz
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fHPixelsRnd
        fmul    fMarginPercent
        fdiv    fOneHundred
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
@@:     fstp    fRightMarginPixels

        ; 6) Find total number of active pixels in image+left+right margin
        fld     fHPixelsRnd
        fadd    fLeftMarginPixels
        fadd    fRightMarginPixels
        fstp    fTotalActivePixels

        ; 7) Find the ideal horizontal period from blanking duty cycle Eq
        fld     fOneHundred
        fsub    fGTF_CPrime
        fmul    ST(0),ST(0)
        fld     fTotalActivePixels
        fadd    fLeftMarginPixels
        fadd    fRightMarginPixels
        fmul    fGTF_MPrime
        fmul    fZeroPointFour
        fdiv    fPixelFreq
        faddp   ST(1),ST(0)
        fsqrt
        fadd    fGTF_CPrime
        fsub    fOneHundred
        fdiv    fTwo
        fdiv    fGTF_MPrime
        fmul    fOneThousand
        fstp    fIdealHPeriod

        ; 8) Find the ideal Blanking duty cycle
        fld     fGTF_CPrime
        fld     fGTF_MPrime
        fmul    fIdealHPeriod
        fdiv    fOneThousand
        fsubp   ST(1),ST(0)
        fstp    fIdealDutyCycle

        ; 9) Find the number of pixels in the blanking time to the
        ; nearest double character cell
        fld     fTotalActivePixels
        fmul    fIdealDutyCycle
        fld     fOneHundred
        fsub    fIdealDutyCycle
        fdivp   ST(1),ST(0)
        fld     fCellGran
        fadd    ST(0),ST(0)
        fdivp   ST(1),ST(0)
        fistp   dwTemp
        fild    dwTemp
        fadd    ST(0),ST(0)
        fmul    fCellGran
        fstp    fHBlankPixels

        ; 10) Find the total number of pixels
        fld     fTotalActivePixels
        fadd    fHBlankPixels
        fstp    fTotalPixels

        ; 11) Find the horizontal frequency
        fld     fPixelFreq
        fdiv    fTotalPixels
        fmul    fOneThousand
        fstp    fHFreq

        ; 12) Find the horizontal period
        fld     fOneThousand
        fdiv    fHFreq
        fstp    fHPeriod

        ; 13) Find the number of lines in the top margin
        fldz    
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        fld     fMarginPercent
        fmul    fVLinesRnd
        fdiv    fOneHundred
@@:     fstp    fTopMarginLines

        ; 14) Find the number of lines in the bottom margin
        fldz
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        fld     fMarginPercent
        fmul    fVLinesRnd
        fdiv    fOneHundred
@@:     fstp    fBottomMarginLines

        ; 15) If interlace is required, set dwInterlace to 0.5
        fldz
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fZeroPointFive
@@:     fstp    fInterlace

        ; 16) Find the number of lines in fMinVSyncPlusBackPorch
        fld     fMinVSyncPlusBackPorch
        fmul    fHFreq
        fdiv    fOneThousand
        fstp    fVSyncPlusBackPorch

        ; 17) Find the number of lines in VBackPorch alone
        fld     fVSyncPlusBackPorch
        fsub    fVSyncRqd
        fstp    fVBackPorch

        ; 18) Find the total number of lines in the vertical field
        fld     fVLinesRnd
        fadd    fTopMarginLines
        fadd    fBottomMarginLines
        fadd    fVSyncPlusBackPorch
        fadd    fMinPorch
        fadd    fInterlace
        fstp    fTotalVLines

        ; 19) Find the actual vertical field frequency
        fld     fHFreq
        fdiv    fTotalVLines
        fmul    fOneThousand
        fstp    fVFieldRate

        ; 20) Find the vertical frame frequency
        fld     fVFieldRate
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fdiv    fTwo
@@:     fstp    fVFrameRate

        POPR    ds,ebx,es,esi
CLOSEPROC


;==============================================================================
;
; Function:     Divide32By32
;
; Purpose:      This function divides a 32bit number by another 32bit
;               number. The problem is that the 16bit compiler can't do
;               this without linking in a library.
;
; Arguments:
;
; Returns:      quotient.
;
; Preserve:     All registers
;==============================================================================
IFDEF _WIN32
DECPROC Divide32By32, STANDARD, FRAME, NEAR
ELSE
DECPROC Divide32By32, PASCAL, FRAME, FAR16
ENDIF
PARMD   dwDividend
PARMD   dwDivisor
OPENPROC
        sub     edx,edx
        mov     eax,dwDividend
        cmp     dwDivisor,edx
        jne     valid
divbyzero:
        cmp     eax,edx                 ; is numerator zero?
        je      done                    ; yes - eax:edx = 0
        mov     eax,-1                  ; no - call it infinity
        mov     edx,-1                  ; eax:edx = -1
        jmp     done
valid:  
        div     dwDivisor
done:
IFNDEF _WIN32
        mov     edx,eax
        shr     edx,10H
ENDIF
CLOSEPROC


;==============================================================================
;
; Function:     Multiply32By32
;
; Purpose:      This function multiplies a 32bit number by another 32bit
;               number. The problem is that the 16bit compiler can't do
;               this without linking in a library.
;
; Arguments:
;
; Returns:      quotient.
;
; Preserve:     All registers
;==============================================================================
IFDEF _WIN32
DECPROC Multiply32By32, STANDARD, FRAME, NEAR
ELSE
DECPROC Multiply32By32, PASCAL, FRAME, FAR16
ENDIF
PARMD   dwMult1
PARMD   dwMult2
OPENPROC
        mov     eax,dwMult1
        imul    eax,dwMult2
IFNDEF _WIN32
        mov     edx,eax
        shr     edx,10H
ENDIF
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\modeset.mhd\CODE\tvmode.c ===
/*
    FILE:   tvmode.c
    DATE:   4/8/99

    This file contains the high level logic for the tv modeset code.
*/

#include "cmntypes.h"
#include "modeext.h"
#include "modeset.h"
#include "debug.h"
#include "restime.h"
#include "tvmode.h"
#include "dmt.h"
#include "gtf.h"

extern int CFUNC IsTvModeAccepted (LPDISPDATA lpDispData,
                                   LPMODEINFO lpModeDesc, LPRESTIME lpRTList);

extern int CFUNC SetupParamsForVidLutClass (LPMODESTRUC         lpMS,
                                            LPMODEOUT           lpModeOut,
                                            LPMODEINFO          lpModeIn);

/*
    FindTVModeEntry

    Timing info for NTSC and PAL modes is always DMT. The thing
    to remember here is that both are restricted to be 800x600
    or less.
*/

int CFUNC
FindTVModeEntry (
    LPDISPDATA  lpDispData,
    LPMODEINFO  lpModeDesc,
    LPMODEOUT   lpModeOut,
    LPMODEENTRY lpModeList,
    LPRESTIME   lpRTList)
{
    int         nRet, nIsNtsc;
    ULONG       MaxXRes;
    ULONG       MaxYRes;
    MODEINFO    ModeDesc;

    // Copy to a local
    MaxXRes = (lpDispData->dwMaxTVOutResolution >> 16) & 0xffff;
    MaxYRes = lpDispData->dwMaxTVOutResolution & 0xffff;
    ModeDesc = lpModeDesc[0];

    // Since this is a TV, which is a fixed frequency device, force the
    // refresh rate to appropriate refresh rate.
    if  ((lpModeDesc->MIDevData.cFormat == TVTYPE_NTSCM) ||
         (lpModeDesc->MIDevData.cFormat == TVTYPE_NTSCJ))
        nIsNtsc = TRUE;
    else
        nIsNtsc = FALSE;


    if  (nIsNtsc)
    {
        ModeDesc.dwRefreshRate = 60;
    }
    else
    {
        // 60 Hz works, 50 Hz doesn't (on Bt869), don't know why
        ModeDesc.dwRefreshRate = 60;
    }

    // Set this up
    nRet = MODE_EXACT_MATCH;

    // If the input resolution is greater than 800x600,
    // then drop it to 800x600.
    if  ((ModeDesc.dwXRes > MaxXRes) || (ModeDesc.dwYRes > MaxYRes))
    {
        ModeDesc.dwXRes = MaxXRes;
        ModeDesc.dwYRes = MaxYRes;
        nRet |= MODE_RESOLUTION_ADJUSTED;
    }

    do
    {
        // Start with the current mode. See if we can set this mode.
        // To do this, we process the RTList and see if this mode is
        // allowed or restricted in some way. At the time of this
        // writing the only way to restrict a TV mode is if there is
        // a NONE in the TimingStandard field of an R&T string. Then
        // the mode is rejected. Let's see if this happens with the
        // requested mode.
        if  (IsTvModeAccepted (lpDispData, &ModeDesc, lpRTList))
        {
            // Great! Return appropriately.
            if  (!DmtFindMode (&ModeDesc, lpModeOut))
            {
                // Bt 868/9
                MODESTRUC ntscModeBt = {720,512,60,870,720,770,820,870,525,512,518,520,525,2738,
                                        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE};
                MODESTRUC palModeBt = {720,544,60,840,720,770,820,840,550,544,546,548,550,2775,
                                       BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE};
                // Chrontel 7007/8
                MODESTRUC ntscModeChrontel = {720,576,60,880,720,760,840,880,597,576,585,588,597,3150,
                                              BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE};
                MODESTRUC palModeChrontel = {720,576,60,880,720,760,840,880,597,576,585,588,597,3150,
                                             BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE};

                MODESTRUC *pNtscMode, *pPalMode, *pMode;
                switch (lpDispData->dwTVEncoderType & 0xFF00) {
                case TV_ENCODER_BROOKTREE:
                    pNtscMode = &ntscModeBt;
                    pPalMode = &palModeBt;
                    break;
                case TV_ENCODER_CHRONTEL:
                default:
                    pNtscMode = &ntscModeChrontel;
                    pPalMode = &palModeChrontel;
                    break;
                }

                pMode = nIsNtsc ? pNtscMode : pPalMode;

                // safe mode is 720x480 on NTSC, or 720x576 on PAL
                SetupParamsForVidLutClass (pMode, lpModeOut, lpModeDesc);
	        if(lpModeOut->wXRes != lpModeDesc->dwXRes)
	            nRet |= MODE_RESOLUTION_ADJUSTED;
            }
            return  (nRet);
        }

        // The TV mode wasn't accepted. Go to the registry mode
        // list and get the next lower resolution mode at the
        // pixel depth requested. We shall try that for the TV.
        nRet |= MODE_RESOLUTION_ADJUSTED;

        if  (!FindNextSmallerResolution (lpModeList, &ModeDesc))
        {
            // OK, if this doesn't happen, then we are already at
            // the losest mode available. Use a safe setting.
            DBG_PRINT0(DL_0, "\r\nNo lower resolution found.");
            DBG_PRINT0 (DL_0, "\r\nFailing TV Timing Standards. Use Safe Settings.");
            nRet = GetSafeTiming (lpModeDesc, lpModeOut);
            return  (nRet);
        }
    }
    while (TRUE);
}


/*
    IsTvModeAccepted

    This routine determines whether the mode in lpModeDesc is
    a valid TV mode (PAL or NTSC as determined by lpModeDesc->dwDevType.)
*/
int CFUNC
IsTvModeAccepted (
    LPDISPDATA  lpDispData,
    LPMODEINFO  lpModeDesc,
    LPRESTIME   lpRTList)
{
    int     nIndex, nIsNtsc;
    RTMODE  sRTMode;
    ULONG   dwMonitorID;

    // Start with the first restriction string
    nIndex = 1;

    if  ((lpModeDesc->MIDevData.cFormat == TVTYPE_NTSCM) ||
         (lpModeDesc->MIDevData.cFormat == TVTYPE_NTSCJ))
        nIsNtsc = TRUE;
    else
        nIsNtsc = FALSE;

    do
    {
        // There is an R&T string for this graphics board.
        // Does this string also match the mode requested?
        sRTMode.dwXRes = lpModeDesc->dwXRes;
        sRTMode.dwYRes = lpModeDesc->dwYRes;
        sRTMode.dwBpp  = lpModeDesc->dwBpp;
        sRTMode.dwRefreshRate = lpModeDesc->dwRefreshRate;


	// Reject the modes 720x576 & 720x480 for unsupported encoders
	if  ((lpDispData->dwTVEncoderType & 0xFF00) != TV_ENCODER_BROOKTREE &&
         (lpDispData->dwTVEncoderType & 0xFF00) != TV_ENCODER_CHRONTEL &&
	      sRTMode.dwXRes == 720)
		return  (FALSE);

        if  (nIsNtsc)
	{
            dwMonitorID = NTSC_ID;

	    // Reject 720x576 for NTSC
//	    if(sRTMode.dwXRes == 720 && sRTMode.dwYRes == 576)
//		return  (FALSE);
	}
        else
	{
            dwMonitorID = PALX_ID;

	    // Reject 720x480 for PAL
//	    if(sRTMode.dwXRes == 720 && sRTMode.dwYRes == 480)
//		return  (FALSE);
	}

        // Find a restriction string that matches the board data.
        nIndex = RTFindNextMatchingString (lpRTList, nIndex,
                    lpDispData, &sRTMode, dwMonitorID);

        if  (nIndex == RTERR_NOT_FOUND)
        {
            // If there were no R&T strings found for the graphics board
            // installed, then the mode is OK.
            return  (TRUE);
        }

        // See if there is a NONE entry in the TimingStandard
        // Field. If there isn't then the mode is OK
        if  (RTRestrictByTimingStandard (lpRTList, nIndex, NONE_ID))
            return  (FALSE);

        // This R&T string did not prohibit this mode. However,
        // since there might be another R&T string that restricts
        // NTSC or PAL, we continue with the rest of the RTList.
        nIndex++;
    }
    while   (nIndex <= (int) lpRTList[0].dwXRes);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\modeset.mhd\INCLUDE\cmntypes.h ===
/*
    FILE:   cmntypes.h
    DATE:   10/12/1999

    This file contains common type definitions needed in other
    include files and source files so that they don't need to be
    defined in multiple places.
*/

// A few constants
#define TRUE    1
#define FALSE   0
#ifndef NULL
#define NULL    0
#endif

// Need these for C To ASM conversion reason.
#ifndef FAR
#ifdef _WIN32
#define FAR
#define CFUNC   __cdecl
#define WINAPI  _stdcall
#else   // !_WIN32

#if     defined(LINUX) | defined(MAC)

#define FAR 
#define CFUNC
#define WINAPI

#else   // !LINUX
#define FAR __far
#define CFUNC   __cdecl  _loadds
#define WINAPI  _far _pascal  _loadds
#endif  // !LINUX
#endif  // !WIN32
#endif  // FAR

// A few basic types
#ifndef ULONG
typedef unsigned char   UCHAR;
typedef unsigned short  USHORT;
typedef unsigned long   ULONG;
typedef UCHAR  FAR *    LPCHAR;
typedef USHORT FAR *    LPUSHORT;
typedef ULONG  FAR *    LPULONG;
typedef void       *    PVOID;
#endif  // ULONG



#ifdef LINUX
#define __STRUCTURE_PACKING__ __attribute__((packed))
#else
#define __STRUCTURE_PACKING__
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\modeset.mhd\INCLUDE\DEBUG.H ===
/*
    FILE:   debug.h
    DATE:   4/8/99

    This file has some things in it for debug.  Since the debug
    facilities are OS dependent, the macros invoke functions that
    can be written in the OS specific libraries.
*/

extern  char    szDebug[512];
extern  ULONG   dwDebugLevel;

// A little bit of debugging support.
#ifdef DEBUG
#define DL_0    1
#define DL_1    2
#define DL_2    3
#define DL_3    4
#define DL_4    5
#define DL_5    6

#ifdef LINUX
#include "os.h" // Xserver header file for definition of ErrorF
#define PrintString0(y)     ErrorF (y);
#define PrintString1(y,z)   ErrorF (y,z);
#endif

#define DBG_PRINT0(x,y)     {                                   \
                                if  ((x) <= dwDebugLevel)       \
                                    PrintString0(y);            \
                            }

#define DBG_PRINT1(x,y,z)   {                                   \
                                if  ((x) <= dwDebugLevel)       \
                                    PrintString1(y,z);          \
                            }
#else
#define DBG_PRINT0(x,y)
#define DBG_PRINT1(x,y,z)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\modeset.mhd\INCLUDE\MODEEXT.H ===
/*
    FILE:   modeext.h
    DATE:   4/8/99

    This file is the external API to the world for the
    FindModeExtry and GetModeList functions in the modeset DLL.
    There can be other EXTERNAL function that are OS specific,
    but they should be defined in other header files.
*/


#ifndef __MODEEXT_H__
#define __MODEEXT_H__

#if defined(LINUX) | defined(MAC)

#define FAR

#if defined(MAC)
typedef unsigned short  USHORT;
#endif

#else
// Need these for C To ASM conversion reason.
#ifndef ULONG
#ifndef FAR
#ifdef _WIN32
#define FAR
#else
#define FAR             __far
#endif
#endif

typedef unsigned short  USHORT;
typedef unsigned long   ULONG;
typedef unsigned char   UCHAR;
typedef UCHAR FAR   *   LPCHAR;
typedef void        *   PVOID;
#endif
#endif  // !linux


// Here is the calling format for both 16bit and 32bit land.
// ULONG __cdecl
// FindModeEntry (
//              LPDISPDATA  lpDispData,
//              LPCHAR      lpEdidBuffer,
//              ULONG       dwEdidSize,
//              LPMODEINFO  lpModeDesc,
//              LPMODEOUT   lpModeOut)
//
// All the structures and types you need are defined in this file.
//
// The FindModeEntry function will always return some legal set of
// values to program in the lpModeOut structure. It may not be the
// requested mode, but the function will never fail to return some
// legitimate values. The actual number returned by the function can
// be a logical OR of the following to indicate whether the parameters
// being returned in lpModeOut are for the requested mode or are for
// a different mode (because the requested mode was not allowed.)
// Note that the return value tells you how different the mode
// returned is from the requested mode -- i.e. whether the mode is
// the same, differes only in the resolution, differes in the pixel
// depth, differs in the refresh rate or some combination thereof.

#define MODE_EXACT_MATCH            0x00
#define MODE_RESOLUTION_ADJUSTED    0x01
#define MODE_PIXEL_DEPTH_ADJUSTED   0x02
#define MODE_REFRESH_RATE_ADJUSTED  0x04

// Although this is kind of Win9X/WinNT specific, it won't hurt to
// put in here. This structure is only used for some calls in the
// Win9X and WinNT specific portion of the modeset dll.
typedef struct  tagREGDATA
{
    ULONG   dwMainKey;
    char    szRegPath[128];
}   REGDATA;
typedef REGDATA FAR *LPREGDATA;

typedef struct  tagDISPDATA
{
    // Every OS probably uses these
    ULONG       dwDeviceID;
    ULONG       dwCRTCIndex;
    ULONG       dwMaxTVOutResolution;
    ULONG       dwVideoMemoryInBytes;
    ULONG       dwMaxDacSpeedInHertz8bpp;
    ULONG       dwMaxDacSpeedInHertz16bpp;
    ULONG       dwMaxDacSpeedInHertz32bpp;
    ULONG       dwMaxDfpScaledXResInPixels;
    ULONG       dwTVEncoderType;
    PVOID       lpfnGetModeSize;
    PVOID       dwContext1;
    PVOID       dwContext2;
    PVOID       lpRTList;
    PVOID       lpModeList;

    /////////////////////////////////////////////////////////////
    // Win9X uses these
    // Registry base path to ...DISPLAY\000X and MONITOR\000X key.
    REGDATA     *lpBoardRegistryData;
    REGDATA     *lpMonitorRegistryData;
    ULONG       dwMonitorInfType;
    ULONG       lpDevData;
    /////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////
    // MAC uses these
    ULONG       edidSize;
    // MAC Done
    /////////////////////////////////////////////////////////////
}   DISPDATA;

typedef DISPDATA FAR *LPDISPDATA;

// dwInfType can have one of the following three values
#define SPECIFIC_DEVICE         0
#define UNKNOWN_DEVICE          1
#define PLUG_AND_PLAY_DEVICE    2

typedef struct  tagDEVDATA
{
    char    cType;
    char    cNumber;
    char    cFormat;
    char    cReserved;
}   DEVDATA;

typedef DEVDATA   FAR *LPDEVDATA;


// Unfortunately we need to pass the TVEncoderType in here. Optimal
// mode timing paramteres for the different TVEncoders are different.
// I hate having aliased constant, but I dont wat to include the
// RM files right now. I'm thinking about how to do this whole thing
// in a bit better a fashion.
#define TV_ENCODER_NONE                 0x000
#define TV_ENCODER_BROOKTREE            0x100
#define TV_ENCODER_CHRONTEL             0x200
#define TV_ENCODER_PHILIPS              0x400
#define NV_ENCODER_NONE                 TV_ENCODER_NONE
#define NV_ENCODER_BROOKTREE_868        (TV_ENCODER_BROOKTREE + 1)
#define NV_ENCODER_BROOKTREE_869        (TV_ENCODER_BROOKTREE + 2)
#define NV_ENCODER_BROOKTREE_871        (TV_ENCODER_BROOKTREE + 3)
#define NV_ENCODER_CHRONTEL_7003        (TV_ENCODER_CHRONTEL + 3)
#define NV_ENCODER_CHRONTEL_7004        (TV_ENCODER_CHRONTEL + 4)
#define NV_ENCODER_CHRONTEL_7005        (TV_ENCODER_CHRONTEL + 5)
#define NV_ENCODER_CHRONTEL_7006        (TV_ENCODER_CHRONTEL + 6)
#define NV_ENCODER_CHRONTEL_7007        (TV_ENCODER_CHRONTEL + 7)
#define NV_ENCODER_CHRONTEL_7008        (TV_ENCODER_CHRONTEL + 8)
#define NV_ENCODER_PHILIPS_7102	        (TV_ENCODER_PHILIPS + 2)
#define NV_ENCODER_PHILIPS_7103	        (TV_ENCODER_PHILIPS + 3)
// = 7102 encoder + 7114 decoder
#define NV_ENCODER_PHILIPS_7108	        (TV_ENCODER_PHILIPS + 8)
// = 7103 encoder + 7114 decoder
#define NV_ENCODER_PHILIPS_7109	        (TV_ENCODER_PHILIPS + 9)
// early version of 7108 with clock active edge reversed
#define NV_ENCODER_PHILIPS_7108B        (TV_ENCODER_PHILIPS + 8 + 0x10)


// This is a description of the incoming mode to try and validate/set.
// The dwXRes, dwYRes, and dwBpp fields should be filled in with the
// desired values. dwRefreshRate must be an actual refresh rate in hertz.
// dwDevType should be set to one of the special device type constants
// (CRT, NTSC, PAL, FLAT_PANEL, etc.) given later in this file.
// The dwOriginalRefreshRate is not used as an input parameter, but
// some of the functions in the modeset DLL that return a MODEINFO
// structure return information in this field. Also, dwCRTCIndex is
// not used by the modeset DLL, but by other modules that utilize
// this structure.
typedef struct  tagMODEINFO
{
    ULONG   dwXRes;
    ULONG   dwYRes;
    ULONG   dwBpp;
    ULONG   dwRefreshRate;
    ULONG   dwDevType;
    ULONG   dwTVFormat;
    DEVDATA MIDevData;
    ULONG   dwOriginalRefreshRate;
}   MODEINFO;

typedef MODEINFO FAR *LPMODEINFO;

// Display Device Types which can be in MODEINFO.dwDevType
#define DEVTYPE_CRT         0x00
#define DEVTYPE_TV          0x01
#define DEVTYPE_DFP         0x02
#define MAX_DEVTYPES        0x03

// These are for the TvType -- they weren't being used in the generic
// code at the time they were added, but they may be needed in the
// future, or the OS-specific sections may need them. We might as well
// all agree on their values.
#define TVTYPE_NTSCM                0x00
#define TVTYPE_NTSCJ                0x01
#define TVTYPE_PALM                 0x02
#define TVTYPE_PALA                 0x03
#define TVTYPE_PALN                 0x04
#define TVTYPE_PALNC                0x05
#define MAX_TVTYPES                 0x06

// This is the format that the mode timing parameters are handed back
// to the caller. This format was chosen because, as of the time of
// this writing, it matches the format of an NVidia object -- class 46.
typedef struct  _tagMODEOUT
{
    USHORT  wXRes;
    USHORT  wYRes;
    USHORT  wHBlankStart;
    USHORT  wHBlankWidth;
    USHORT  wHSyncStart;
    USHORT  wHSyncWidth;
    USHORT  wVBlankStart;
    USHORT  wVBlankWidth;
    USHORT  wVSyncStart;
    USHORT  wVSyncWidth;
    USHORT  wHTotal;
    USHORT  wVTotal;
    ULONG   dwPixelClock;
    ULONG   dwFormat;
    USHORT  wRefreshRate;
    ULONG   dwPitchInBytes;
} MODEOUT;

typedef MODEOUT FAR *LPMODEOUT;


// There is an API call in this DLL --
// int GetModeList (LPDISPDATA lpDD, LPCHAR lpModes, ULONG dwType)
// lpDD specifies the board to fetch the modelist for.
// If lpModes is NULL, the routine returns the number of modes.
// If lpModes is not NULL, the routine returns the number of modes
// and fills in lpModes with an array of either MODEENTRY, MODEENTRYNORR,
// or MODEENTRYANDPITCH structures depending upon the value of dwType.

// The routine will never return more than this number of modes
#define MAX_MODEENTRYS  2048

// dwType can be one of these values.
#define MODETYPE_MODEENTRYNORR      0
#define MODETYPE_MODEENTRY          1
#define MODETYPE_MODEENTRYANDPITCH  2

// dwType of MODETYPE_MODEENTRYNORR causes these structurs to be returned
typedef struct  tagMODEENTRYNORR
{
    ULONG   dwXRes;
    ULONG   dwYRes;
    ULONG   dwBpp;
} MODEENTRYNORR;

typedef MODEENTRYNORR FAR *LPMODEENTRYNORR;

// dwType of MODETYPE_MODEENTRY causes these structurs to be returned
typedef struct  tagMODEENTRY
{
    ULONG   dwXRes;
    ULONG   dwYRes;
    ULONG   dwBpp;
    ULONG   dwRefreshRate;
} MODEENTRY;

typedef MODEENTRY FAR *LPMODEENTRY;

// dwType of MODETYPE_MODEENTRYANDPITCH causes these structurs to be returned
typedef struct  tagMODEENTRYANDPITCH
{
    ULONG   dwXRes;
    ULONG   dwYRes;
    ULONG   dwBpp;
    ULONG   dwPitch;
} MODEENTRYANDPITCH;

typedef MODEENTRYANDPITCH FAR *LPMODEENTRYANDPITCH;

#endif /* __MODEEXT_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\modeset.mhd\INCLUDE\OSAPI.H ===
/*
    FILE:   osapi.h
    DATE:   4/8/99

    This file holds the externs for the os-specific routines that
    support the mode set code.
*/

extern LPMODEENTRY CFUNC GetMasterModeList (LPDISPDATA lpDispData);
extern int CFUNC FreeMasterModeList (LPMODEENTRY lpModeList);

extern LPRESTIME CFUNC GetMasterRTList (LPDISPDATA lpDispData);
extern int CFUNC FreeMasterRTList (LPRESTIME lpRTList);

extern ULONG CFUNC GetTimingStandardOverride (LPDISPDATA lpDispData);
extern ULONG CFUNC GetPitchAndSize (LPDISPDATA lpDispData, ULONG dwXRes,
            ULONG dwYRes, ULONG dwBpp, ULONG *dwPitch, ULONG *dwModeSize);

extern int CFUNC GetMonitorLimitMode (LPDISPDATA lpDispData, LPMODEINFO lpModeInfo);

int CFUNC GetMonitorInfRangeLimits (LPDISPDATA lpDispData,
                     LPMONITORLIMITS lpML, ULONG *lpdwXRes, ULONG *lpdwYRes);

ULONG WINAPI GetAllowAllModesFlag(LPREGDATA lpRegData);

#ifdef LINUX
void SetMonitorLimitMode (void *lpModeLimit, int display_device);
void SetMonitorInfRangeLimits (void *lpRangeLimits, int display_device);
void SetMasterModeList (void *lpModeList, int display_device);
void SetMasterRTList (void *lpRtList, int display_device);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\modeset.mhd\INCLUDE\UTILS.H ===
/*
    FILE:   utils.h

    DATE:   4/8/99

    This file holds some utility routines.  OS independent
*/

extern int CFUNC FindMode (LPMODESTRUC lpMS, ULONG dwXRes,
                            ULONG dwYRes, ULONG dwRRate);
extern int CFUNC FindModeWithoutRR (LPMODESTRUC lpMS, ULONG dwXRes,
                            ULONG dwYRes);
extern int CFUNC SetupParamsForVidLutClass (LPMODESTRUC lpMS,
                            LPMODEOUT lpModeOut,
                            LPMODEINFO lpModeIn);
extern int CFUNC SetupParamsForModeInfo (LPMODEOUT lpModeOut,
                            LPMODEINFO lpModeOrig, LPMODEINFO lpModeIn);
extern int CFUNC ParseDecimalNumber (LPCHAR szRTString, LPULONG lpIndex,
                            LPULONG lpNum);
extern ULONG CFUNC GetDecimalValue (char cDigit);
extern int CFUNC ParseHexWord (LPCHAR szRTString, LPULONG lpIndex,
                            LPUSHORT lpNum);
extern int CFUNC ParseHexDWord (LPCHAR szRTString, LPULONG lpIndex,
                            LPULONG lpNum);
extern int CFUNC ParseDecimalSeparator (LPCHAR lpStr, LPULONG lpIndex,
                            LPULONG lpNum, char cSeparator1,
                            char cSeparator2);
extern int CFUNC ParseDecimalNumberAndFractionAndSeparator (LPCHAR  lpStr,
                            LPULONG lpIndex, LPULONG lpNum,
                            char    cSeparator1, char    cSeparator2);
extern int CFUNC ParseHexSeparator (LPCHAR  lpStr, LPULONG lpIndex,
                            LPULONG lpNum, ULONG   dwLen,
                            char cSeparator1, char cSeparator2);
extern ULONG CFUNC GetHexValue (char cDigit);

extern ULONG CFUNC GetMaximumRefreshRate (ULONG dwPixelClkXRes,
                            ULONG dwPixelClkYRes, ULONG dwPixelClkRR,
                            LPMONITORLIMITS lpML, ULONG dwTargetXRes,
                            ULONG dwTargetYRes);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\modeset.mhd\linux\getit.c ===
#include "cmntypes.h"
#include "modeext.h"
#include "restime.h"

/*
    Function:   GetPitch

    Purpose:    This routine returns the pitch for a given mode.

    Arguments:  lpBoardData - identifies the specific board that we
                              want the active display port for.
                dwXRes      - The X res in pixels for the mode
                              should be returned.
                dwBpp       - the bits per pixel for the mode

    Returns:    The pitch in bytes
*/
typedef ULONG   (*LPFNGETPITCH) (ULONG, ULONG);

ULONG CFUNC
GetPitch (LPBOARDDATA lpBoardData, ULONG dwXRes, ULONG dwBpp)
{
    LPFNGETPITCH    lpfnGetPitchNew;

    lpfnGetPitchNew = (LPFNGETPITCH) lpBoardData->lpfnGetDisplayPitch;
    return  ((*lpfnGetPitchNew) (dwXRes, dwBpp));
}
/*
    GetTimingStandardOverride

    This routine gets any timing standard override for the board
    specified. It should return one of the constants defined in
    restime.h like DMTV_ID. A timing standard override is a
    timing standard that applies to all modes. Just something
    that the user might want to enforce.
*/
ULONG CFUNC
GetTimingStandardOverride (LPBOARDDATA lpBoardData)
{
    return  (NONE_ID);
}

/*
    Function:   GetMonitorLimitMode

    Purpose:    This routine gets the mode which should be an
                upper bound for a monitor which has no edid and
                no .inf.

    Arguments:  lpBoardData - identifies the specific board that we
                              want the active display port for.
                lpModeInfo  - ptr to a place to store the limit mode

    Returns:    If this routine returns TRUE, then lpModeInfo was
                filled in with the limit mode. If this routine
                returns FALSE, then there is no limit mode.
*/
int CFUNC
GetMonitorLimitMode (LPBOARDDATA lpBoardData, LPMODEINFO lpModeInfo)
{
    /*
     * CHASCHAS - not yet implemented!!!
     */
//    return  (GrabModeInfoString (lpBoardData, NV4_REG_DRV_MONITOR_LIMIT_MODE, lpModeInfo));
    return (FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\modeset.mhd\linux\mathrtns.c ===
/*
    FILE:   mathrtns.c
    DATE:   12/22/99

    This file contains math routines which need to be handled in an OS
    specific manner.  The X driver should not include system header files,
    so we have to include "xf86_ansic.h".
*/

#include "xf86_ansic.h"


float calcFLOOR(float fInput)
{
    return (floor(fInput));
}

float calcROUND(float fInput)
{
    return (calcFLOOR(fInput+0.5f));
}

float calcSQRT(float fInput)
{
    return ((float)sqrt((double)fInput));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\modeset.mhd\linux\MODELIST.C ===
/*
    FILE:   modelist.c
    DATE:   4/8/99

    This file holds code to get the master mode list.
*/

#include "cmntypes.h"
#include "modeext.h"
#include "modeset.h"
#include "debug.h"
#include "restime.h"
#include "osapi.h"

/*
 * List of safe modes...
 */
MODEENTRY   modeEntries[] = 
{
    {640,   480,  8, 60},
    {800,   600,  8, 60},
    {1024,  768,  8, 60},
    {1152,  864,  8, 60},
    {1280, 1024,  8, 60},
    {640,   480, 16, 60},
    {800,   600, 16, 60},
    {1024,  768, 16, 60},
    {1152,  864, 16, 60},
    {1280, 1024, 16, 60},
    {640,   480, 32, 60},
    {800,   600, 32, 60},
    {1024,  768, 32, 60},
    {1152,  864, 32, 60},
    {1280, 1024, 32, 60},
    {1152,  864, 32, 60},
    {1280, 1024, 32, 60},
    {   0,    0,  0,  0}
};
LPMODEENTRY lpMasterModeList = modeEntries;

/*
 * SetMasterModeList
 *
 * The XServer needs to be able to pass in a list of available modes.
 */
void SetMasterModeList(void *lpModeList)
{
    /*
     * Store the pointer to the master mode list.
     */
    lpMasterModeList = (LPMODEENTRY)lpModeList;
}


/*
    GetMasterModeList

    This routine returns a ptr to a an array of MODEENTRY
    structures which describe the list of available modes for
    the board specified. This routine needs to ALWAYS return
    some mode list. If you have to just return a list of safe
    modes like 640,480,8,60Hz.

    You can alloc memory for the mode list because you will be
    given a chance to free the ptr later.
*/
LPMODEENTRY CFUNC
GetMasterModeList (LPBOARDDATA lpBoardData)
{
    // You can't return NULL -- this is just a template.
    return  (lpMasterModeList);
}


/*
    FreeMasterModeList

    This routine is called when the caller is done with the mode
    list it got earlier.
*/
int CFUNC
FreeMasterModeList (LPMODEENTRY lpModeList)
{
    /*
     * Reset the master mode list to the default mode list.
     */
    lpMasterModeList = modeEntries;
    return  (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\modeset.mhd\INCLUDE\MODESET.H ===
/*
    FILE:   modeset.h
    DATE:   4/8/99

    This file holds the format for some tables and structures used
    internally by the DLL. OS independent.
*/

// This is the structure format in which we the mode timing tables
// in this DLL are stored. This should never need to be changed.
typedef struct  _tagMODESTRUC
{
    USHORT  wHorizVisible;
    USHORT  wVertVisible;
    USHORT  wRefresh;
    USHORT  wHorizTotal;
    USHORT  wHorizBlankStart;
    USHORT  wHorizSyncStart;
    USHORT  wHorizSyncEnd;
    USHORT  wHorizBlankEnd;
    USHORT  wVertTotal;
    USHORT  wVertBlankStart;
    USHORT  wVertSyncStart;
    USHORT  wVertSyncEnd;
    USHORT  wVertBlankEnd;
    USHORT  wDotClock;
    USHORT  wHSyncPolarity;
    USHORT  wVSyncPolarity;
} MODESTRUC;

typedef MODESTRUC FAR *LPMODESTRUC;

// These constants are used in internal tables
#define BUFFER_HSYNC_NEGATIVE           0
#define BUFFER_HSYNC_POSITIVE           1
#define BUFFER_VSYNC_NEGATIVE           0
#define BUFFER_VSYNC_POSITIVE           1


// This information can often be gotten from an EDID. It can be
// used to restrict mode settings.
typedef struct  _tagMONITORLIMITS
{
    ULONG   dwMinHorz;
    ULONG   dwMaxHorz;
    ULONG   dwMinVert;
    ULONG   dwMaxVert;
    ULONG   dwMaxPixelClock;
} MONITORLIMITS;

typedef MONITORLIMITS FAR *LPMONITORLIMITS;


// Here are the external functions
extern int CFUNC  FindNextSmallerResolution (LPMODEENTRY lpModeList,
                                            LPMODEINFO lpModeDesc);

extern int CFUNC  FindNextSmallerRefreshRate (LPMODEENTRY lpModeList,
                                            LPMODEINFO  lpModeDesc);
extern int CFUNC  FindNextLargerRefreshRate (LPMODEENTRY lpModeList,
                                            LPMODEINFO  lpModeDesc);
extern int WINAPI GetSafeTiming (LPMODEINFO lpModeDesc, LPMODEOUT lpModeOut);
extern int CFUNC  GetModeFlags (LPMODEINFO lpModeOrig, LPMODEINFO lpModeFound);
extern int WINAPI FormatModeList (LPDISPDATA lpDispData, LPCHAR lpModes, ULONG dwType, LPMODEENTRY lpME);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\modeset.mhd\INCLUDE\RESTIME.H ===
/*
    FILE:   restime.h
    DATE:   4/8/99

    This file has routines to support getting and parsing the restriction
    and timing strings. OS independent stuff.
*/

// This is the maximum number of R&T strings allowed.
#define MAX_RESTIMES    128

// For any of the fields in the R&T string that can be separated by a
// '.' (see specification for details), there can be at most the
// following number of DOT separated values per field. For example,
// the MonitorID field can have up to MAX_DOT_FIELDS monitorIDs.
// Example DT71.SN17.VS85 is three monitor IDS.
#define MAX_DOT_FIELDS  16

// For those R&T strings which allow a wildcard indicating ALL, this
// is the wildcard character.
#define ALL_WILDCARD    ('*')

// For each restriction and timing string that gets parsed, the string
// is parsed into the following structure.
typedef struct  tagRESTIME
{
    ULONG   dwXRes;
    ULONG   dwYRes;
    ULONG   dwPixelDepth;
    ULONG   dwRefreshRate;
    USHORT  wDeviceID[MAX_DOT_FIELDS];
    ULONG   dwMonitorID[MAX_DOT_FIELDS];
    ULONG   dwTimingStandard[MAX_DOT_FIELDS];
    MODEOUT sModeOut;
} RESTIME;

typedef RESTIME FAR *LPRESTIME;

// A couple of special MonitorIDs. UKWN_ID is a monitor ID which matches
// all monitors that do not have an EDID.
// A couple of special MonitorIDs. UKWN_ID is a monitor ID which matches
// all monitors that do not have an EDID.
#define UKWN_ID ((ULONG) 'U') + (((ULONG) 'K') << 8) + (((ULONG) 'W') << 16) + (((ULONG) 'N') << 24)
#define NTSC_ID ((ULONG) 'N') + (((ULONG) 'T') << 8) + (((ULONG) 'S') << 16) + (((ULONG) 'C') << 24)
#define PALX_ID ((ULONG) 'P') + (((ULONG) 'A') << 8) + (((ULONG) 'L') << 16) + (((ULONG) 'X') << 24)
#define PANL_ID ((ULONG) 'P') + (((ULONG) 'A') << 8) + (((ULONG) 'N') << 16) + (((ULONG) 'L') << 24)

// Several TimingStandardIDs.
#define NONE_ID ((ULONG) 'N') + (((ULONG) 'O') << 8) + (((ULONG) 'N') << 16) + (((ULONG) 'E') << 24)
#define EDID_ID ((ULONG) 'E') + (((ULONG) 'D') << 8) + (((ULONG) 'I') << 16) + (((ULONG) 'D') << 24)
#define DMTV_ID ((ULONG) 'D') + (((ULONG) 'M') << 8) + (((ULONG) 'T') << 16) + (((ULONG) 'V') << 24)
#define DMTR_ID ((ULONG) 'D') + (((ULONG) 'M') << 8) + (((ULONG) 'T') << 16) + (((ULONG) 'R') << 24)
#define GTFV_ID ((ULONG) 'G') + (((ULONG) 'T') << 8) + (((ULONG) 'F') << 16) + (((ULONG) 'V') << 24)
#define GTFR_ID ((ULONG) 'G') + (((ULONG) 'T') << 8) + (((ULONG) 'F') << 16) + (((ULONG) 'R') << 24)
#define OEMX_ID ((ULONG) 'O') + (((ULONG) 'E') << 8) + (((ULONG) 'M') << 16) + (((ULONG) 'X') << 24)
#define OEMR_ID ((ULONG) 'O') + (((ULONG) 'E') << 8) + (((ULONG) 'M') << 16) + (((ULONG) 'R') << 24)
#define FGTF_ID ((ULONG) 'F') + (((ULONG) 'G') << 8) + (((ULONG) 'T') << 16) + (((ULONG) 'F') << 24)
#define FGTR_ID ((ULONG) 'F') + (((ULONG) 'G') << 8) + (((ULONG) 'T') << 16) + (((ULONG) 'R') << 24)

// A few of the R&T parsing functions require that a mode be passed in.
// This is the structure that the R&T functions require the mode to be in.
typedef struct  tagRTMODE
{
    ULONG   dwXRes;
    ULONG   dwYRes;
    ULONG   dwBpp;
    ULONG   dwRefreshRate;
} RTMODE;

typedef RTMODE FAR *LPRTMODE;

extern int CFUNC RTFindNextMatchingString (LPRESTIME lpRTList,
                        int nIndex, LPDISPDATA lpDispData,
                        LPRTMODE lpRTMode, ULONG dwMonitorID);;

// Return values for a successful RTFindNextMatchingString are any
// positive integer which represents the index of the RTstring in the
// RTList that was a match. The value below is returned if there was no
// match.
#define RTERR_NOT_FOUND -1

extern int CFUNC RTRestrictByTimingStandard (LPRESTIME lpRTList, int nIndex,
                                    ULONG dwTimingStandard);

int CFUNC ParseRTString (LPRESTIME lpRT, LPCHAR szRTString);
int CFUNC ParseDecimalNumberOrWildcard (LPCHAR szRTString, LPULONG lpIndex,
                                LPULONG lpNum);
int CFUNC ParseDeviceIDs (LPCHAR szRTString, LPULONG lpIndex,
                                LPUSHORT lpNum);
int CFUNC ParseMonitorIDs (LPCHAR szRTString, LPULONG lpIndex,
                                LPULONG lpNum);
int CFUNC ParseTimingStandards (LPCHAR szRTString,
                                LPULONG lpIndex, LPULONG lpNum);
int CFUNC ParseDecimalNumberComma (LPCHAR szRTString, LPULONG lpIndex,
                                LPULONG lpNum);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\modeset.mhd\linux\osapi.c ===
#include "cmntypes.h"
#include "modeext.h"
#include "modeset.h"
#include "debug.h"
#include "restime.h"
#include "osapi.h"

#include "xf86_ansic.h" // need the declaration of xf86memcpy()	

/*****************************************************************************/
/*

  osapi.c - this source file contains the linux implementation of the following
  functions:

  GetPitchAndSize ()
  SetMonitorLimitMode ()
  GetMonitorLimitMode ()
  SetMonitorInfRangeLimits ()
  GetMonitorInfRangeLimits ()
  SetMasterModeList ()
  GetMasterModeList ()
  FreeMasterModeList ()
  SetMasterRTList ()
  GetMasterRTList ()
  FreeMasterRTList ()  
  GetTimingStandardOverride ()
  GetAllowAllModesFlag ()


*/
/*****************************************************************************/




typedef ULONG   (*LPFNGETMODESIZE) (PVOID, PVOID, ULONG, ULONG,
                                    ULONG, ULONG *, ULONG *);


  
/* List of safe modes; these are the defaults, in case a good master mode
   list isn't set with a call to SetMasterModeList () */

MODEENTRY defaultModeEntries[] = 
{
	{640,   480,  0, 60},
	{640,   480,  0, 72},
	{640,   480,  0, 75},
	{640,   480,  0, 85},
	{800,   600,  0, 56},
	{800,   600,  0, 60},
	{800,   600,  0, 72},
	{800,   600,  0, 75},
	{800,   600,  0, 85},
	{1024,  768,  0, 60},
	{1024,  768,  0, 70},
	{1024,  768,  0, 75},
	{1024,  768,  0, 85},
	{1152,  864,  0, 75},
	{1280, 1024,  0, 60},
	{1280, 1024,  0, 75},
	{1280, 1024,  0, 85},
	{1600, 1024,  0, 60},
	{1600, 1024,  0, 65},
	{1600, 1024,  0, 70},
	{1600, 1024,  0, 75},
	{1600, 1024,  0, 85},
	{1600, 1200,  0, 60},
	{1600, 1200,  0, 65},
	{1600, 1200,  0, 70},
	{1600, 1200,  0, 75},
	{1600, 1200,  0, 85},
	{1792, 1344,  0, 60},
	{1792, 1344,  0, 75},
	{1856, 1392,  0, 60},
	{1856, 1392,  0, 75},
	{1920, 1440,  0, 60},
	{1920, 1440,  0, 75},
	{   0,    0,  0,  0}
};

RESTIME defaultRTList [] =
{
    { 0, 0, 0, 0,
      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
      { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }
    }
};


/* data that is global to these routines */

MONITORLIMITS *lpMonitorRangeLimits[8] = {NULL, NULL, NULL, NULL,
                                          NULL, NULL, NULL, NULL};

MODEINFO *lpMonitorLimitMode[8] = {NULL, NULL, NULL, NULL,
                                   NULL, NULL, NULL, NULL};

MODEENTRY *lpMasterModeList[8] = {NULL, NULL, NULL, NULL,
                                  NULL, NULL, NULL, NULL};

RESTIME *lpResTimeList[8] = {NULL, NULL, NULL, NULL,
                             NULL, NULL, NULL, NULL};









/*****************************************************************************/
/* GetPitchAndSize () - This routine returns the pitch for a given mode;
   this implementation assumes that the function pointer
   pDispData->lpfnGetModeSize has been set by the caller of FindModeEntry.

   Arguments:  lpDispData  - identifies the specific board that we
                             want the active display port for.
               dwXRes      - The X res in pixels for the mode
                             should be returned.
               dwBpp       - the bits per pixel for the mode

   Returns:    The pitch in bytes */
/*****************************************************************************/

ULONG GetPitchAndSize (LPDISPDATA lpDispData, ULONG dwXRes, ULONG dwYRes,
                       ULONG dwBpp, ULONG *dwPitch, ULONG *dwModeSize)
{
    LPFNGETMODESIZE lpfnGetModeSize;
    
    lpfnGetModeSize = (LPFNGETMODESIZE) lpDispData->lpfnGetModeSize;
    return  ((*lpfnGetModeSize) (lpDispData->dwContext1,
                                 lpDispData->dwContext2,
                                 dwXRes, dwYRes, dwBpp, dwPitch, dwModeSize));
} // GetPitchAndSize




/*****************************************************************************/
/* SetMonitorLimitMode ()
   GetMonitorLimitMode ()

   This pair of functions provides a means for the caller of modeset code to
   define a mode which should be used as an upper bound for a specific
   display device (aka. physical head).  In general, the user should only
   need to call SetMonitorLimitMode, and GetMonitorLimitMode will be used
   internally by modeset.

   Note that GetMonitorLimitMode is currently only called if both EDIDs and
   inf fail to define maximum mode values. */
/*****************************************************************************/

void SetMonitorLimitMode (void *lpModeLimit, int display_device)
{
    lpMonitorLimitMode[display_device] = (LPMODEINFO)lpModeLimit;
}


int GetMonitorLimitMode (LPDISPDATA lpDispData, LPMODEINFO lpModeInfo)
{
    int display_device = lpDispData->dwDeviceID;
    
    if (lpMonitorLimitMode[display_device]) {
        xf86memcpy (lpModeInfo, lpMonitorLimitMode[display_device],
                sizeof (MODEINFO));
        return (TRUE);
    }
    return (FALSE);
}



/*****************************************************************************/
/* SetMonitorInfRangeLimits ()
   GetMonitorInfRangeLimits ()

   This pair of functions provides a means for the caller of modeset code to
   define range limits for a specific display device (aka. physical head).
   In general, the user should only need to call SetMonitorInfRangeLimits,
   and GetMonitorInfRangeLimits will be called internally by modeset.

   Note that the implementation of GetMonitorInfRangeLimits requires both
   the lpMonitorRangeLimits AND lpMonitorLimitMode arrays to be defined
   for the given display device (the user should be calling both
   SetMonitorInfRangeLimits and SetMonitorLimitMode).

   Note also that these range limits are only used if no EDIDs are available
   (see ModeWithinMonitorTimingLimits() in digmode.c) */
/*****************************************************************************/

void SetMonitorInfRangeLimits (void *lpRangeLimits, int display_device)
{
    lpMonitorRangeLimits[display_device] = (LPMONITORLIMITS)lpRangeLimits;
}

int GetMonitorInfRangeLimits (LPDISPDATA lpDispData, LPMONITORLIMITS lpML,
                              ULONG *lpdwXRes, ULONG *lpdwYRes)
{
    int display_device = lpDispData->dwDeviceID;

    if ((lpMonitorRangeLimits[display_device]) &&
        (lpMonitorLimitMode[display_device])) {
        xf86memcpy (lpML, lpMonitorRangeLimits[display_device],
                sizeof (MONITORLIMITS));
        
        *lpdwXRes = lpMonitorLimitMode[display_device]->dwXRes;
        *lpdwYRes = lpMonitorLimitMode[display_device]->dwYRes;
        
        return (TRUE);
    }
    return FALSE;
}



/*****************************************************************************/
/* SetMasterModeList ()
   GetMasterModeList ()
   FreeMasterModeList ()

   This set of functions provides a mechanism for the user to define the master
   list of modes for a specific display device.

   SetMasterModeList should be called to set the modelist for a given display
   device; GetMasterModeList is called internally by modeset to retrieve the
   list set by the user (a default is supplied because GetMasterModeList is
   not allowed to fail); and finally, FreeMasterModeList is called internally
   by modeset to free any memory allocated by the implementation of the
   {Set,Get}MasterModeList routines. */
/*****************************************************************************/

void SetMasterModeList (void *lpModeList, int display_device)
{
    lpMasterModeList[display_device] = (LPMODEENTRY)lpModeList;
}

LPMODEENTRY GetMasterModeList (LPDISPDATA lpDispData)
{
    int display_device = lpDispData->dwDeviceID;

    if (lpMasterModeList[display_device])
        return (lpMasterModeList[display_device]);

    return (defaultModeEntries);
}

int FreeMasterModeList (LPMODEENTRY lpModeList)
{
    return (TRUE);
}







/*****************************************************************************/
/* SetMasterRTList ()
   GetMasterRTList ()
   FreeMasterRTList ()

   This set of functions provides an interface for the user of modeset to
   define a restriction and timing list for a specific head.  

   SetMasterRTList should be called to set the RT list for a given display
   device; GetMasterRTList is called internally by modeset to retrieve the
   list set by the user (a default empty list is supplied because
   GetMasterRTList is not allowed to fail); and finally, FreeMasterRTList is
   called internally by modeset to free any memory allocated by the
   implementation of the {Set,Get}MasterRTList routines. */
/*****************************************************************************/

void SetMasterRTList(void *lpRtList, int display_device)
{
    lpResTimeList[display_device] = (LPRESTIME)lpRtList;
}

LPRESTIME GetMasterRTList (LPDISPDATA lpDispData)
{
    int display_device = lpDispData->dwDeviceID;
    
    if (lpResTimeList[display_device])
        return (lpResTimeList[display_device]);
    
    // Here is returning a blank list.
    return (defaultRTList);
}

int FreeMasterRTList (LPRESTIME lpRTList)
{
    return  (TRUE);
}



/*****************************************************************************/
/* GetTimingStandardOverride () - This routine gets any timing standard
   override for the board specified. It should return one of the constants
   defined in restime.h like DMTV_ID. A timing standard override is a timing
   standard that applies to all modes. Just something that the user might want
   to enforce.

   This is currently not implemented on linux. */
/*****************************************************************************/

ULONG GetTimingStandardOverride (LPDISPDATA lpDispData)
{
    /* what should we do here? */
    
    return (NONE_ID);
}


/*****************************************************************************/
/* GetAllowAllModesFlag () - not needed on linux */
/*****************************************************************************/

ULONG GetAllowAllModesFlag (LPREGDATA lpRegData)
{
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\modeset.mhd\mac\mathrtns.c ===
/*
    FILE:   mathrtns.c
    DATE:   12/22/99

    This file contains math routines which need to be handled in an OS
    specific manner.
*/

#include "math.h"

float calcFLOOR(float fInput);
float calcROUND(float fInput);
float calcSQRT(float fInput);

float calcFLOOR(float fInput)
{
    return (floor(fInput));
}

float calcROUND(float fInput)
{
    return (calcFLOOR(fInput+0.5f));
}

float calcSQRT(float fInput)
{
    return ((float)sqrt((double)fInput));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\modeset.mhd\mac\getit.c ===
/*
    FILE:   getit.c
    DATE:   4/8/99

    This file holds code to get the mode, and output device from
    the registry for the given board.
*/

#include "cmntypes.h"
#include "modeext.h"
#include "modeset.h"
#include "debug.h"
//#include "..\..\common\inc\nvreg.h"
#include "restime.h"
#include "osapi.h"
#include "utils.h"
#include "::code:edid.h"
#include "::code:gtfmath.h"

typedef struct  tagDEVNAMEANDTYPE
{
    LPCHAR  lpszName;
    LPCHAR  lpszForceModeName;
    LPCHAR  lpszLastDevMode;
    LPCHAR  lpszDefRefName;
    LPCHAR  lpszOptRefName;
    ULONG   dwDevType;
    ULONG   dwTvType;
} DEVNAMEANDTYPE;

ULONG CFUNC GetPitch(LPDISPDATA lpDispData, ULONG dwXRes, ULONG dwBpp);
ULONG CFUNC GetTimingStandardOverride(LPDISPDATA lpDispData);
int WINAPI GetDisplayDevice(LPDISPDATA lpDispData, LPULONG lpDevType, LPULONG lpTvFormat);
int WINAPI SetDisplayDevice(LPDISPDATA lpDispData, ULONG dwDevType, ULONG dwTvFormat);
int WINAPI SetLastDisplayDevice(LPDISPDATA lpDispData, ULONG dwDevType, ULONG dwTvFormat);
int WINAPI SetDisplayDeviceMode(LPDISPDATA lpDispData, LPMODEINFO lpModeInfo);
int WINAPI GetEdidRegistryKey(LPDISPDATA lpDispData);
int WINAPI GetDisplayOverrideKey(LPDISPDATA lpDispData);
int CFUNC GrabModeInfoString(LPDISPDATA lpDispData, LPCHAR lpModeString, LPMODEINFO lpMI);
int CFUNC GetMonitorInfRangeLimits(LPDISPDATA lpDispData, LPMONITORLIMITS lpML, ULONG *lpdwXRes, ULONG *lpdwYRes);
ULONG CFUNC GetDefaultRefreshRate(LPDISPDATA lpDispData, ULONG dwDevType);
ULONG CFUNC GetOptimalRefreshRate(LPDISPDATA lpDispData, LPMODEINFO lpModeInfo, LPCHAR lpEdidBuffer, ULONG dwEdidSize);
int CFUNC GrabRefreshRateFromKey(ULONG hKey, LPDISPDATA lpDispData, LPCHAR lpszPath, LPMODEINFO lpModeInfo, LPCHAR lpEdidBuffer, ULONG dwEdidSize);
int WINAPI GetForcedMode(LPDISPDATA lpDispData, LPMODEINFO lpSuggMode, LPCHAR lpEdidBuffer, ULONG dwEdidSize);
int WINAPI GetFirstBootMode(LPDISPDATA lpDispData, LPMODEINFO lpModeInfo, LPCHAR lpEdidBuffer, ULONG dwEdidSize);
int WINAPI GetDisplayDeviceMode(LPDISPDATA lpDispData, LPMODEINFO lpModeInfo, LPCHAR lpEdidBuffer, ULONG dwEdidSize, ULONG dwFirstBootLogic);
int CFUNC GetMonitorLimitMode(LPDISPDATA lpDispData, LPMODEINFO lpModeInfo);



/*
    Function:   GetPitch

    Purpose:    This routine returns the pitch for a given mode.

    Arguments:  lpDispData - identifies the specific board that we
                              want the active display port for.
                dwXRes      - The X res in pixels for the mode
                              should be returned.
                dwBpp       - the bits per pixel for the mode

    Returns:    The pitch in bytes
*/
typedef ULONG   (*LPFNGETMODESIZE) (ULONG, ULONG, ULONG, ULONG, ULONG, ULONG *, ULONG *);
ULONG CFUNC GetPitchAndSize
(
    LPDISPDATA  lpDispData,
    ULONG       dwXRes,
    ULONG       dwYRes,
    ULONG       dwBpp,
    ULONG      *pdwPitch,
    ULONG      *pdwSize
)
{
    LPFNGETMODESIZE lpfnGetModeSize;

    lpfnGetModeSize = (LPFNGETMODESIZE) lpDispData->lpfnGetModeSize;
    return  ((*lpfnGetModeSize) (lpDispData->dwContext1, lpDispData->dwContext2, dwXRes, dwYRes, dwBpp, pdwPitch, pdwSize));
}


/*
    GetTimingStandardOverride

    This routine gets any timing standard override for the board
    specified. It should return one of the constants defined in
    restime.h like DMTV_ID. A timing standard override is a
    timing standard that applies to all modes. Just something
    that the user might want to enforce.
*/
ULONG CFUNC GetTimingStandardOverride
(
    LPDISPDATA lpDispData
)
{

/*
 * CHASCHAS - How will we do this on Mac?
 */

    return  (NONE_ID);
}


/*
    Function:   GetDisplayDevice

    Purpose:    This routine gets the display device for the board
                specified. The particular display device is stored
                in the registry.

    Arguments:  lpDispData - identifies the specific board that we
                              want the active display port for.
                lpDevType   - ptr to where the basic display type
                              should be returned.
                lpTvFormart - ptr to where the specific flavor of
                              the tv type should be returned.

    Returns:    lpDevType should be filled in with one of the
                DEVTYPE_XXXX constants defined in modeext.h
                If lpDevType is set to DEVTYPE_NTSC or DEVTYPE_PAL,
                then lpTvFormat should be set to one of the
                TVTYPE_XXXX constants defined in modeext.h
*/
int WINAPI GetDisplayDevice
(
    LPDISPDATA lpDispData,
    LPULONG lpDevType,
    LPULONG lpTvFormat
)
{
/*
 * CHASCHAS - How will we do this on Mac?
 */


    *lpDevType  = DEVTYPE_CRT;
    *lpTvFormat = 0; // Always 0 for CRTC
    return  (TRUE);
}


/*
    Function:   SetDisplayDevice

    Purpose:    This routine sets the display device for the board
                specified. The particular display device is stored
                in the registry.

    Arguments:  lpDispData - identifies the specific board that we
                              want the active display port for.
                dwDevType   - the basic display type
                              should be one of the DEVTYPE_XXXX
                              sonstants definde in modeext.h
                dwTvFormart - the specific flavor of the tv type
                              should be one of the TVTYPE_XXXX
                              sonstants definde in modeext.h

    Returns:    Always returns TRUE
*/
int WINAPI SetDisplayDevice
(
    LPDISPDATA lpDispData,
    ULONG dwDevType,
    ULONG dwTvFormat
)
{

/*
 * CHASCHAS - How will we do this on Mac?
 */

    return  (TRUE);
}


/*
    Function:   SetLastDisplayDevice

    Purpose:    This routine sets the display device for the board
                specified. The particular display device is stored
                in the registry. This routine is subtley different
                than SetDisplayDevice.  It is a different key in
                the registry and is used by the caller to track
                mode changes, etc.

    Arguments:  lpDispData - identifies the specific board that we
                              want the active display port for.
                dwDevType   - the basic display type
                              should be one of the DEVTYPE_XXXX
                              sonstants definde in modeext.h
                dwTvFormart - the specific flavor of the tv type
                              should be one of the TVTYPE_XXXX
                              sonstants definde in modeext.h

    Returns:    Always returns TRUE
*/
int WINAPI SetLastDisplayDevice
(
    LPDISPDATA lpDispData,
    ULONG dwDevType,
    ULONG dwTvFormat
)
{
/*
 * CHASCHAS - How will we do this on Mac?
 */

    return  (TRUE);
}


/*
    Function:   SetDisplayDeviceMode

    Purpose:    This routine writes a string in the registry
                inidcating the xres,yres,bpp,refrate for a
                given display device (CRT,PAL,NTSC,DFP) on
                a specific board (given by the location of
                the string in the registry.)

    Arguments:  lpDispData - identifies the specific board that we
                              want the active display port for.
                lpModeInfo  - tells the mode and display device
                              to write.

    Returns:    Always returns TRUE
*/
int WINAPI SetDisplayDeviceMode
(
    LPDISPDATA lpDispData,
    LPMODEINFO lpModeInfo
)
{
/*
 * CHASCHAS - How will we do this on Mac?
 */

    return  (TRUE);
}


/*
    Function:   GetEdidRegistryKey

    Purpose:    This routine gets the registry key that tells
                whether or not we are supposed to read the EDID.

    Arguments:  lpDispData - identifies the specific board that we
                              want the active display port for.

    Returns:    0       registry key does not exist or says not to
                        read the EDID
                non-0   registry key exists and says to read the EDID
*/
int WINAPI GetEdidRegistryKey
(
    LPDISPDATA lpDispData
)
{
    int     nFlag;

/*
 * CHASCHAS - How will we do this on Mac?
 */
    nFlag = 0;
    return  (nFlag);
}


/*
    Function:   GetDisplayOverrideKey

    Purpose:    This routine reads the key that determines if we
                are supposed to force to a particular display
                device (like DFP over CRT, etc.)

    Arguments:  lpDispData - identifies the specific board that we
                              want the active display port for.

    Returns:
                DEVTYPE_CRT registry key exists and says to use CRT
                DEVTYPE_DFP registry key exists and says to use DFP
                else        registry key does not exist or does not
                            specify one of the possible display override
                            options.
*/
int WINAPI GetDisplayOverrideKey
(
    LPDISPDATA lpDispData
)
{
    int     nFlag;

/*
 * CHASCHAS - How will we do this on Mac?
 */

    nFlag = DEVTYPE_NONE;
    return  (nFlag);
}


/*
    Function:   GrabModeInfoString

    Purpose:    This routine reads and parses a string of the
                form "xres,yres,bpp,refrate" from the registry.

    Arguments:  lpDispData - identifies the specific board that we
                              want the active display port for.
                lpModeString - Name of entry in registry (relative
                              to XXXX\NVidia\Display) that tells the
                              specific mode string to read.
                lpMI        - MODEINFO ptr where parsed mode goes

    Returns:    TRUE  that a valid mode was parsed and stored in lpMI
                FALSE there was a problem with the parsing and lpMI
                does not contain valid data.

                NOTE: Even if this routine returns TRUE, it does not
                mean the mode is reasonable. 1,1,55,9876 would be parsed
                fine, but it is not a valid mode string. The caller
                must check for validity if it needs to ensure this.
*/
int CFUNC GrabModeInfoString
(
    LPDISPDATA lpDispData,
    LPCHAR lpModeString,
    LPMODEINFO lpMI
)
{
    int     bModeValid = FALSE;

/*
 * CHASCHAS - How will we do this on Mac?
 */

    return  (bModeValid);
}


/*
    Function:   GetMonitorInfRangeLimits

    Purpose:    This routine reads the "MaxResolution" key in the
                active monitor node in the registry to get the
                maximum resolution the monitor can do. It uses
                the maximum resolution itself (like "1600,1200")
                as another subkey under which is typically a
                monitor range limits string which looks like
                "30-95,60-120,-,+" where the first range is
                the horizontal limits inKHz and the second is
                the vertical range in hertz. The last two characters
                are horizontal and vertical sync polarities.
                This range limits string doesn't always exist.

    Arguments:
                lpDispData - identifies the specific board that we
                              want the active display port for.
                lpML        - ptr to a monitor limits structure
                              that will be filled in with range
                              limits obtained or computed from
                              values stuffed in the registry
                              by the moitor .inf file.
                lpdwXRes    - ptr to a variable that will be set
                              to the maximum X-resolution found
                              for this monitor.
                lpdwYRes    - ptr to a variable that will be set
                              to the maximum Y-resolution found
                              for this monitor.

    Returns:    TRUE    then lpML, lpdwXRes, and lpdwYRes have been
                        filled in correctly.
                FALSE   then there was an error getting some value.
*/
int CFUNC GetMonitorInfRangeLimits
(
    LPDISPDATA lpDispData,
    LPMONITORLIMITS lpML,
    ULONG *lpdwXRes,
    ULONG *lpdwYRes
)
{
    if (lpDispData->edidSize == 0)
	    /*
	     * When there's no EDID, just continue processing as normal.
	     */
	    return (FALSE);        
    /*
     * When there's an EDID and this routine is called, that means
     * the EDID didn't have any range limits, but there has been
     * a maximum pixel clock calculated.  Set up a dummy monitor
     * limits table and return true so that modes that use pixel
     * clocks higher than the max pixel clock calculated will get
     * rejected.  All other modes will be accepted.
     */
    /*
     * This just shows that we don't know what the maximum
     * horizontal and vertical values are.
     */
    lpML->dwMaxHorz = 0;
    lpML->dwMaxVert = 0;
    return (TRUE);
}


/*
    Function:   GetDefaultRefreshRate

    Purpose:    This routine reads a key in the registry to get
                a specific value for the default refresh rate.
                There is an optional OEM specific key that can
                specify what default should mean. If the key does
                not exist, then 60 is returned.

    Arguments:
                lpDispData - identifies the specific board that we
                              want the active display port for.
                dwDevType   - tells which display device port is being
                              used since there might be different
                              default refresh rates for DFPs and CRTs.

    Returns:    always returns a value that is the default refresh rate
*/
ULONG CFUNC GetDefaultRefreshRate
(
    LPDISPDATA lpDispData,
    ULONG dwDevType
)
{
/*
 * CHASCHAS - How will we do this on Mac?
 */

    return  (60);
}


/*
    Function:   GetOptimalRefreshRate

    Purpose:    This routine reads a key in the registry to get
                a specific value for the default refresh rate.
                There is an optional OEM specific key that can
                specify what default should mean. If the key does
                not exist, then 60 is returned.

    Arguments:
                lpDispData - identifies the specific board that we
                              want the active display port for.
                lpModeInfo  - Current mode and device identifier.
                lpEdidBuffer - points to a buffer with EDID data in
                              it if dwEdidSize is not 0. If dwEdidSize
                              is 0, this argument is ignored.
                dwEdidSize    tells the size of the lpEdidBuffer
                              in bytes. If this variables is 0,
                              then lpEdidBuffer ptr may be invalid.

    Returns:    always returns a value that is the optimal refresh rate
*/
ULONG CFUNC GetOptimalRefreshRate
(
    LPDISPDATA lpDispData,
    LPMODEINFO lpModeInfo,
    LPCHAR lpEdidBuffer,
    ULONG dwEdidSize
)
{

/*
 * CHASCHAS - How will we do this on Mac?
 */

    return  (60);
}



/*
    Function:   GrabRefreshRateFromKey

    Purpose:    This routine reads the "RefreshRate" string value
                from the key and path provided and does a little
                preprocessing on what it finds. i.e. it handles
                optimal (-1) and default (0) cases.

    Arguments:  hKey        base Key in registry from which to read
                lpDispData - identifies the specific board that we
                              want the active display port for.
                lpszPath    path in registry to access which may
                            contain a "RefreshRate" string.
                lpModeInfo  - Current mode and device identifier.
                lpEdidBuffer - points to a buffer with EDID data in
                              it if dwEdidSize is not 0. If dwEdidSize
                              is 0, this argument is ignored.
                dwEdidSize    tells the size of the lpEdidBuffer
                              in bytes. If this variables is 0,
                              then lpEdidBuffer ptr may be invalid.

    Returns:    TRUE  then lpModeInfo->dwRefreshRate has a real
                      value stuffed in it. Also the field
                      lpModeInfo->dwOriginalRefreshRate has the
                      "Windows" value in it which might be the same
                      as ->dwRefreshRate if Windows was requesting
                      a specific refresh rate, or it can be 0 for
                      default or -1 for optimal.
                FALSE if nothing was found or there was an error.
*/
int CFUNC GrabRefreshRateFromKey
(
    ULONG hKey,
    LPDISPDATA lpDispData,
    LPCHAR lpszPath,
    LPMODEINFO lpModeInfo,
    LPCHAR lpEdidBuffer,
    ULONG dwEdidSize
)
{
/*
 * CHASCHAS - How will we do this on Mac?
 */

    return  (FALSE);
}


/*
    Function:   GetForcedMode

    Purpose:    This routine gte s a forced mode if one exists
                in the registry. It then erases the forced mode
                string and processes it appropriately.

    Arguments:  lpDispData - identifies the specific board that we
                              want the active display port for.
                lpModeInfo  - contains the display device on which
                              the mode will be set and the mode
                              suggested by the caller.
                lpEdidBuffer - points to a buffer with EDID data in
                              it if dwEdidSize is not 0. If dwEdidSize
                              is 0, this argument is ignored.
                dwEdidSize    tells the size of the lpEdidBuffer
                              in bytes. If this variables is 0,
                              then lpEdidBuffer ptr may be invalid.

    Returns:    This routine may override the mode provided in the
                lpModeInfo structure. Whether it does or not, it
                MUST do the following:
                If Windows wants a specific refresh rate value,
                then both the lpModeInfo->dwRefreshRate and the
                lpModeInfo->dwOriginalRefreshRate fields must be set
                to this specific value (liek 60, 75, 100, etc).
                If Windows wants the optimal rate, then the
                lpModeInfo->dwRefreshRate should be set to the
                specific value for the optimal refresh rate and
                lpModeInfo->dwOriginalRefreshRate should be set to -1.
                If Windows wants the default refresh rate, then the
                lpModeInfo->dwRefreshRate should be set to the
                specific value for the default refresh rate and
                lpModeInfo->dwOriginalRefreshRate should be set to 0.
*/
int WINAPI GetForcedMode
(
    LPDISPDATA lpDispData,
    LPMODEINFO lpSuggMode,
    LPCHAR lpEdidBuffer,
    ULONG dwEdidSize
)
{
/*
 * CHASCHAS - How will we do this on Mac?
 */
    return  (FALSE);
}



/*
    Function:   GetFirstBootMode

    Purpose:    This routine does some special logic for first
                boot after a restart.

    Arguments:  lpDispData - identifies the specific board that we
                              want the active display port for.
                lpModeInfo  - contains the display device on which
                              the mode will be set and the mode
                              suggested by the caller.
                lpEdidBuffer - points to a buffer with EDID data in
                              it if dwEdidSize is not 0. If dwEdidSize
                              is 0, this argument is ignored.
                dwEdidSize    tells the size of the lpEdidBuffer
                              in bytes. If this variables is 0,
                              then lpEdidBuffer ptr may be invalid.

    Returns:    This routine may override the mode provided in the
                lpModeInfo structure. Whether it does or not, it
                MUST do the following:
                If Windows wants a specific refresh rate value,
                then both the lpModeInfo->dwRefreshRate and the
                lpModeInfo->dwOriginalRefreshRate fields must be set
                to this specific value (liek 60, 75, 100, etc).
                If Windows wants the optimal rate, then the
                lpModeInfo->dwRefreshRate should be set to the
                specific value for the optimal refresh rate and
                lpModeInfo->dwOriginalRefreshRate should be set to -1.
                If Windows wants the default refresh rate, then the
                lpModeInfo->dwRefreshRate should be set to the
                specific value for the default refresh rate and
                lpModeInfo->dwOriginalRefreshRate should be set to 0.
*/
int WINAPI GetFirstBootMode
(
    LPDISPDATA lpDispData,
    LPMODEINFO lpModeInfo,
    LPCHAR lpEdidBuffer,
    ULONG dwEdidSize
)
{
/*
 * CHASCHAS - How will we do this on Mac?
 */
    return  (FALSE);
}


/*
    Function:   GetDisplayDeviceMode

    Purpose:    This routine gets the correct display mode for
                the device specified by lpDispData and the
                display device given by lpModeInfo->dwDevType.
                lpModeInfo->dwXRes, lpModeInfo->dwYRes, and
                lpModeInfo->dwBpp are valid, but the field
                lpModeInfo->dwRefreshRate is not.

    Arguments:  lpDispData - identifies the specific board that we
                              want the active display port for.
                lpModeInfo  - contains the display device on which
                              the mode will be set and the mode
                              suggested by the caller.
                lpEdidBuffer - points to a buffer with EDID data in
                              it if dwEdidSize is not 0. If dwEdidSize
                              is 0, this argument is ignored.
                dwEdidSize    tells the size of the lpEdidBuffer
                              in bytes. If this variables is 0,
                              then lpEdidBuffer ptr may be invalid.
                dwFirstBootLogic  If this variable is non-0, then
                              this is the first boot after a power
                              up.  This is just a flag so that this
                              routine can use different logic if it
                              wants to.

    Returns:    This routine may override the mode provided in the
                lpModeInfo structure. Whether it does or not, it
                MUST do the following:
                If Windows wants a specific refresh rate value,
                then both the lpModeInfo->dwRefreshRate and the
                lpModeInfo->dwOriginalRefreshRate fields must be set
                to this specific value (liek 60, 75, 100, etc).
                If Windows wants the optimal rate, then the
                lpModeInfo->dwRefreshRate should be set to the
                specific value for the optimal refresh rate and
                lpModeInfo->dwOriginalRefreshRate should be set to -1.
                If Windows wants the default refresh rate, then the
                lpModeInfo->dwRefreshRate should be set to the
                specific value for the default refresh rate and
                lpModeInfo->dwOriginalRefreshRate should be set to 0.

                It Always returns TRUE.
*/
int WINAPI GetDisplayDeviceMode
(
    LPDISPDATA lpDispData,
    LPMODEINFO lpModeInfo,
    LPCHAR lpEdidBuffer,
    ULONG dwEdidSize,
    ULONG dwFirstBootLogic
)
{

/*
 * CHASCHAS - How will we do this on Mac?
 */


    // Well, we just have to set up a default refresh rate then
    lpModeInfo->dwRefreshRate = 60;
    lpModeInfo->dwOriginalRefreshRate = lpModeInfo->dwRefreshRate;

    return  (TRUE);
}


/*
    Function:   GetMonitorLimitMode

    Purpose:    This routine gets the mode which should be an
                upper bound for a monitor which has no edid and
                no .inf.

    Arguments:  lpDispData - identifies the specific board that we
                              want the active display port for.
                lpModeInfo  - ptr to a place to store the limit mode

    Returns:    If this routine returns TRUE, then lpModeInfo was
                filled in with the limit mode. If this routine
                returns FALSE, then there is no limit mode.
*/
int CFUNC GetMonitorLimitMode
(
    LPDISPDATA lpDispData,
    LPMODEINFO lpModeInfo
)
{
    return  (GrabModeInfoString (lpDispData, NULL, lpModeInfo));
}

/*
    Function:   GetAllowAllModesFlag

    Purpose:    WIN9X specific function for testing only.

    Arguments:
                lpDispData - identifies the specific board that we
                              want the active display port for.
    Returns:    FALSE.
*/
ULONG WINAPI GetAllowAllModesFlag
(
    LPREGDATA lpRegData
)
{
    return (FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\modeset.mhd\mac\defines.h ===
#define MAC     1
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\modeset.mhd\linux\rtget.c ===
/*
    FILE:   rtget.c
    DATE:   4/8/99

    This file holds code to get the restrction and timing list.
    If there isn't one -- just return the blank list (not a NULL
    ptr.)
*/

#include "cmntypes.h"
#include "modeext.h"
#include "modeset.h"
#include "debug.h"
#include "restime.h"
#include "osapi.h"

// Just in case we can't GlobalAlloc a list, we have a single entry one
// we can use here.
RESTIME     sRTList;

/*
    GetMasterRTList

    This routine returns a ptr to a an array of RESTIME
    structures which describe the list of R&T strings for
    the board specified. This routine needs to ALWAYS return
    some RT list. If you have to just return a blank list.

    You can alloc memory for the mode list because you will be
    given a chance to free the ptr later.
*/
LPRESTIME CFUNC
GetMasterRTList (LPBOARDDATA lpBoardData)
{
    LPRESTIME   lpRTList;

    // Here is returning a blank list.
    lpRTList = &sRTList;
    lpRTList[0].dwXRes = 0;
    return  (lpRTList);
}


/*
    FreeMasterRTList

    This routine is called when the caller is done with the RTList.
*/
int CFUNC
FreeMasterRTList (LPRESTIME lpRTList)
{
    return  (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\modeset.mhd\mac\modelist.c ===
/*
    FILE:   modelist.c
    DATE:   4/8/99

    This file holds code to build a modelist from the registry
    and to walk the list looking for different things.
*/

#include "cmntypes.h"
#include "modeext.h"
#include "modeset.h"
#include "debug.h"
#include "utils.h"
//#include "..\..\common\inc\nvreg.h"
#include "restime.h"
#include "osapi.h"

MODEENTRY   SafeModeList[] =
{
    { 640,  480, 8,  60 },
    { 800,  600, 8,  60 },
    { 1024, 768, 8,  60 },
    { 640,  480, 16, 60 },
    { 800,  600, 16, 60 },
    { 1024, 768, 16, 60 },
    { 640,  480, 32, 60 },
    { 800,  600, 32, 60 },
    { 1024, 768, 32, 60 },
    { 0,    0,   0,  0  },
    { 1,    0,   0,  0  }
};

MODEENTRY   FullModeList[] =
{
    { 640,  480,  8,  60},
    { 640,  480,  8,  67},
    { 640,  480,  8,  75},
    { 640,  480,  8,  85},
    { 640,  480,  8,  153},
    { 800,  600,  8,  60},
    { 800,  600,  8,  72},
    { 800,  600,  8,  75},
    { 800,  600,  8,  85},
    { 800,  600,  8, 125},
    { 832,  624,  8,  75},
    { 832,  624,  8, 120},
    {1024,  768,  8,  60},
    {1024,  768,  8,  70},
    {1024,  768,  8,  75},
    {1024,  768,  8,  85},
    {1024,  768,  8,  99},
    {1056,  792,  8,  96},
    {1152,  870,  8,  75},
    {1280, 1024,  8,  60},
    {1280, 1024,  8,  75},
    {1280, 1024,  8,  85},
    {1600, 1024,  8,  60},
    {1600, 1200,  8,  60},
    {1600, 1200,  8,  65},
    {1600, 1200,  8,  75},
    {1600, 1200,  8,  85},
    {1920, 1440,  8,  60},
    {1920, 1440,  8,  75},
    { 640,  480, 15,  60},
    { 640,  480, 15,  67},
    { 640,  480, 15,  75},
    { 640,  480, 15,  85},
    { 640,  480, 15,  153},
    { 800,  600, 15,  60},
    { 800,  600, 15,  72},
    { 800,  600, 15,  75},
    { 800,  600, 15,  85},
    { 800,  600, 15, 125},
    { 832,  624, 15,  75},
    { 832,  624, 15, 120},
    {1024,  768, 15,  60},
    {1024,  768, 15,  70},
    {1024,  768, 15,  75},
    {1024,  768, 15,  85},
    {1024,  768, 15,  99},
    {1056,  792, 15,  96},
    {1152,  870, 15,  75},
    {1280, 1024, 15,  60},
    {1280, 1024, 15,  75},
    {1280, 1024, 15,  85},
    {1600, 1024, 15,  60},
    {1600, 1200, 15,  60},
    {1600, 1200, 15,  65},
    {1600, 1200, 15,  75},
    {1600, 1200, 15,  85},
    {1920, 1440, 15,  60},
    {1920, 1440, 15,  75},
    { 640,  480, 32,  60},
    { 640,  480, 32,  67},
    { 640,  480, 32,  75},
    { 640,  480, 32,  85},
    { 640,  480, 32,  153},
    { 800,  600, 32,  60},
    { 800,  600, 32,  72},
    { 800,  600, 32,  75},
    { 800,  600, 32,  85},
    { 800,  600, 32, 125},
    { 832,  624, 32,  75},
    { 832,  624, 32, 120},
    {1024,  768, 32,  60},
    {1024,  768, 32,  70},
    {1024,  768, 32,  75},
    {1024,  768, 32,  85},
    {1024,  768, 32,  99},
    {1056,  792, 32,  96},
    {1152,  870, 32,  75},
    {1280, 1024, 32,  60},
    {1280, 1024, 32,  75},
    {1280, 1024, 32,  85},
    {1600, 1024, 32,  60},
    {1600, 1200, 32,  60},
    {1600, 1200, 32,  65},
    {1600, 1200, 32,  75},
    {1600, 1200, 32,  85},
    {1920, 1440, 32,  60},
    {1920, 1440, 32,  75},
    { 0,    0,   0,  0  },
    { 1,    0,   0,  0  }
};

MODEENTRY   sLowModes[] =
{
    { 320,  200, 8,  60 },
    { 320,  200, 8,  70 },
    { 320,  200, 8,  72 },
    { 320,  200, 8,  75 },
    { 320,  200, 8,  85 },
    { 320,  200, 8,  100 },
    { 320,  200, 8,  120 },
    { 320,  240, 8,  60 },
    { 320,  240, 8,  70 },
    { 320,  240, 8,  72 },
    { 320,  240, 8,  75 },
    { 320,  240, 8,  85 },
    { 320,  240, 8,  100 },
    { 320,  240, 8,  120 },
    { 400,  300, 8,  60 },
    { 400,  300, 8,  70 },
    { 400,  300, 8,  72 },
    { 400,  300, 8,  75 },
    { 400,  300, 8,  85 },
    { 400,  300, 8,  100 },
    { 400,  300, 8,  120 },
    { 480,  360, 8,  60 },
    { 480,  360, 8,  70 },
    { 480,  360, 8,  72 },
    { 480,  360, 8,  75 },
    { 480,  360, 8,  85 },
    { 480,  360, 8,  100 },
    { 480,  360, 8,  120 },
    { 512,  384, 8,  60 },
    { 512,  384, 8,  70 },
    { 512,  384, 8,  72 },
    { 512,  384, 8,  75 },
    { 512,  384, 8,  85 },
    { 512,  384, 8,  100 },
    { 640,  400, 8,  60 },
    { 640,  400, 8,  70 },
    { 640,  400, 8,  72 },
    { 640,  400, 8,  75 },
    { 640,  400, 8,  85 },
    { 640,  400, 8,  100 },
    { 640,  400, 8,  120 },
    { 320,  200, 16, 60 },
    { 320,  200, 16, 70 },
    { 320,  200, 16, 72 },
    { 320,  200, 16, 75 },
    { 320,  200, 16, 85 },
    { 320,  200, 16, 100 },
    { 320,  200, 16, 120 },
    { 320,  240, 16, 60 },
    { 320,  240, 16, 70 },
    { 320,  240, 16, 72 },
    { 320,  240, 16, 75 },
    { 320,  240, 16, 85 },
    { 320,  240, 16, 100 },
    { 320,  240, 16, 120 },
    { 400,  300, 16, 60 },
    { 400,  300, 16, 70 },
    { 400,  300, 16, 72 },
    { 400,  300, 16, 75 },
    { 400,  300, 16, 85 },
    { 400,  300, 16, 100 },
    { 400,  300, 16, 120 },
    { 480,  360, 16, 60 },
    { 480,  360, 16, 70 },
    { 480,  360, 16, 72 },
    { 480,  360, 16, 75 },
    { 480,  360, 16, 85 },
    { 480,  360, 16, 100 },
    { 480,  360, 16, 120 },
    { 512,  384, 16, 60 },
    { 512,  384, 16, 70 },
    { 512,  384, 16, 72 },
    { 512,  384, 16, 75 },
    { 512,  384, 16, 85 },
    { 512,  384, 16, 100 },
    { 640,  400, 16, 60 },
    { 640,  400, 16, 70 },
    { 640,  400, 16, 72 },
    { 640,  400, 16, 75 },
    { 640,  400, 16, 85 },
    { 640,  400, 16, 100 },
    { 640,  400, 16, 120 },
    { 320,  200, 32, 60 },
    { 320,  200, 32, 70 },
    { 320,  200, 32, 72 },
    { 320,  200, 32, 75 },
    { 320,  200, 32, 85 },
    { 320,  200, 32, 100 },
    { 320,  200, 32, 120 },
    { 320,  240, 32, 60 },
    { 320,  240, 32, 70 },
    { 320,  240, 32, 72 },
    { 320,  240, 32, 75 },
    { 320,  240, 32, 85 },
    { 320,  240, 32, 100 },
    { 320,  240, 32, 120 },
    { 400,  300, 32, 60 },
    { 400,  300, 32, 70 },
    { 400,  300, 32, 72 },
    { 400,  300, 32, 75 },
    { 400,  300, 32, 85 },
    { 400,  300, 32, 100 },
    { 400,  300, 32, 120 },
    { 480,  360, 32, 60 },
    { 480,  360, 32, 70 },
    { 480,  360, 32, 72 },
    { 480,  360, 32, 75 },
    { 480,  360, 32, 85 },
    { 480,  360, 32, 100 },
    { 480,  360, 32, 120 },
    { 512,  384, 32, 60 },
    { 512,  384, 32, 70 },
    { 512,  384, 32, 72 },
    { 512,  384, 32, 75 },
    { 512,  384, 32, 85 },
    { 512,  384, 32, 100 },
    { 640,  400, 32, 60 },
    { 640,  400, 32, 70 },
    { 640,  400, 32, 72 },
    { 640,  400, 32, 75 },
    { 640,  400, 32, 85 },
    { 640,  400, 32, 100 },
    { 640,  400, 32, 120 },
    { 960,  720, 8,  60 },
    { 960,  720, 8,  70 },
    { 960,  720, 8,  72 },
    { 960,  720, 8,  75 },
    { 960,  720, 8,  85 },
    { 960,  720, 8,  100 },
    { 960,  720, 8,  120 },
    { 960,  720, 8,  140 },
    { 960,  720, 8,  144 },
    { 960,  720, 8,  150 },
    { 960,  720, 8,  170 },
    { 960,  720, 8,  200 },
    { 960,  720, 8,  240 },
    { 960,  720, 16, 60 },
    { 960,  720, 16, 70 },
    { 960,  720, 16, 72 },
    { 960,  720, 16, 75 },
    { 960,  720, 16, 85 },
    { 960,  720, 16, 100 },
    { 960,  720, 16, 120 },
    { 960,  720, 16, 140 },
    { 960,  720, 16, 144 },
    { 960,  720, 16, 150 },
    { 960,  720, 16, 170 },
    { 960,  720, 16, 200 },
    { 960,  720, 16, 240 },
    { 960,  720, 32, 60 },
    { 960,  720, 32, 70 },
    { 960,  720, 32, 72 },
    { 960,  720, 32, 75 },
    { 960,  720, 32, 85 },
    { 960,  720, 32, 100 },
    { 960,  720, 32, 120 },
    { 960,  720, 32, 140 },
    { 960,  720, 32, 144 },
    { 960,  720, 32, 150 },
    { 960,  720, 32, 170 },
    { 960,  720, 32, 200 },
    { 960,  720, 32, 240 },
    { 0,    0,   0,  0  },
};

LPMODEENTRY lpMasterModeList = SafeModeList;

#define USE_60HZ                        0x00
#define USE_REFRESH_RATES_FROM_LOWER    0x01
#define USE_REFRESH_RATES_FROM_STRING   0x02

extern int CFUNC GetSafeModeList (LPMODEENTRY lpModeList);

/*
 * SetMasterModeList
 *
 * The XServer needs to be able to pass in a list of available modes.
 */
void SetMasterModeList(void *lpModeList);
void SetMasterModeList(void *lpModeList)
{
    /*
     * Store the pointer to the master mode list.
     */
#if 1 /* CHASCHAS - Temporary */
    if (lpModeList)
        lpMasterModeList = FullModeList;
    else
        lpMasterModeList = SafeModeList;
#else
    if (lpModeList)
        lpMasterModeList = (LPMODEENTRY)lpModeList;
    else
        lpMasterModeList = SafeModeList;
#endif
}

/*
    GetMasterModeList

    This routine extracts the mode list for the board requested
    from the registry. This routine will always return some mode
    list.  If it can't find the board requested a safe mode list
    is returned.
*/
LPMODEENTRY CFUNC
GetMasterModeList (LPDISPDATA lpDispData)
{

/*
 * CHASCHAS - How will we do this on Mac?
 */

    return  (lpMasterModeList);
}


/*
    FreeMasterModeList

    This routine is called when the caller is done with the mode
    list it got earlier.
*/
int CFUNC
FreeMasterModeList (LPMODEENTRY lpModeList)
{
/*
 * CHASCHAS - How will we do this on Mac?
 */

    return  (TRUE);
}


/*
    GetSafeModeList

    This routine just returns a few safe modes in the mode list.
    It always returns TRUE.
*/
int CFUNC GetSafeModeList (LPMODEENTRY lpModeList)
{
    int     i;

    for (i = 0; SafeModeList[i].dwXRes != 1; i++)
        lpModeList[i] = SafeModeList[i];

    return  (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\modeset.mhd\win9x\getit.c ===
/*
    FILE:   getit.c
    DATE:   4/8/99

    This file holds code to get the mode, and output device from
    the registry for the given board.
*/

#include "cmntypes.h"
#include "modeext.h"
#include "modeset.h"
#include "mywin.h"
#include "regfuncs.h"
#include "debug.h"
#include "..\..\common\inc\nvreg.h"
#include "restime.h"
#include "osapi.h"
#include "utils.h"
#include "..\code\edid.h"
#include "..\code\gtfmath.h"
#include "..\code\dmt.h"

DEVICEANDTYPE   DeviceTypes[] =
{
    { "CRT", DEVTYPE_CRT },
    { "TV",  DEVTYPE_TV },
    { "DFP", DEVTYPE_DFP },
    { NULL,  0 }
};

typedef struct  tagTVFORMATANDTYPE
{
    LPCHAR  lpszName;
    char    cFormat;
}   TVFORMATANDTYPE;

TVFORMATANDTYPE TVFormat[] =
{
    { "NTSCM", TVTYPE_NTSCM },
    { "NTSCJ", TVTYPE_NTSCJ },
    { "PALM",  TVTYPE_PALM },
    { "PALA",  TVTYPE_PALA },
    { "PALN",  TVTYPE_PALN },
    { "PALNC", TVTYPE_PALNC },
    { NULL,    0 }
};

char sz640_480[] = "640,480";
char szSettings[] = "Display\\Settings";
char szControl[] = "System\\CurrentControlSet\\Control";
char szDefUser[] = "Config\\0001\\Display\\Settings";
char szDeviceType[MAX_KEY_LEN];
char szLastDevice[MAX_KEY_LEN];
char szPath[MAX_KEY_LEN];
char szFullPath[MAX_KEY_LEN];
char szExtraKey[MAX_KEY_LEN];

extern int CFUNC GrabRefreshRateFromKey (ULONG hKey, LPDISPDATA lpDispData,
                                        LPCHAR lpszPath, LPMODEINFO lpModeInfo,
                                        LPCHAR lpEdidBuffer, ULONG dwEdidSize,
                                        char *RefreshRateName);
extern LPMODEENTRY CFUNC GetModeListFromRegistry (LPDISPDATA lpDispData);
extern int WINAPI ParseDeviceTypeAndNumber (LPCHAR lpszString, LPDEVDATA lpDevData);

/*
    GetBootDevice

    Purpose:    This routine gets the Initial Boot display device for
                the board given. lpDevtype should be filled in with one
                of the basic types like DEVTYPE_CRT, DEVTYPE_NTSC, etc
                defined in modeext.h or filled with 0xffffffff if subkey
                is not found or invlalid Device type is found.
                If the basic type is either NTSC or PAL, then the
                lpTvFormat should be filled in with the specific NTSC
                or PAL formats like: TVTYPE_NTSC_M, TYTYPE_NTSC_J etc
                which are given in modeext.h

    Arguments:  lpRegData   - identifies the specific board
                lpDevData   - where to place the device found

    Returns:    TRUE    if lpDevType is filled in correctly.
                FALSE   otherwise
*/
int WINAPI
GetBootDevice (LPREGDATA lpRegData, LPDEVDATA lpDevData)
{
    char    szDev[MAX_KEY_LEN];

    DBG_PRINT0 (DL_0, "\r\nEntering GetBootDevice");

    szDeviceType[0] = 0;
    GetLocalNvidiaDisplayRegString (lpRegData,
                            NV4_REG_DRV_BOOT_DEVICE_TYPE, szDev);

    // Parse the device type
    if  (!ParseDeviceTypeAndNumber (szDev, lpDevData))
        return  (FALSE);

    lpDevData->cFormat = 0;

    // If this was a TV, then get the last format
    if  (lpDevData->cType == DEVTYPE_TV)
    {
        // JKTODO -- for now
        lpDevData->cFormat = TVTYPE_NTSCM;
    }

    DBG_PRINT0 (DL_1, "\r\nExiting GetBootDevice");
    return  (TRUE);
}


/*
    GetBootDeviceSelection
    Purpose:    This routine gets the Initial Boot device selection
                for desktop to use HW selected device. (Mobile Behaviour)


    Arguments:  lpRegData   - identifies the specific board

    Returns:    TRUE    If HW selected device will be used as boot device
                FALSE   otherwise
*/
int WINAPI
GetBootDeviceSelection (LPREGDATA lpRegData)
{
    int nRet;

    DBG_PRINT0 (DL_0, "\r\nEntering GetBootDeviceSelection");

    nRet = GetLocalNvidiaDisplayRegValue (lpRegData,
                NV4_REG_DRV_USE_HW_SELECTED_DEVICE, 0);

    DBG_PRINT0 (DL_1, "\r\nExiting GetBootDeviceSelection");
    return  (nRet);
}

/*
    Function:   GetLastDisplayFormat

    Purpose:    This routine gets called to get the last display
                format used on a particular display device. This
                really only applies in the case of a TV. It will
                set the format field of lpDevData to 0 if the device
                type is not DEVTYPE_TV.

    Arguments:  lpRegData   - identifies the specific board that we
                              want the active display port for.
                lpDevData   - ptr to the DEVDATA structure to be filled in

    Returns:    lpDevData filled in correctly
*/
int WINAPI
GetLastDisplayFormat (LPREGDATA lpRegData, LPDEVDATA lpDevData)
{
    int     i;
    char    szTvFormat[16];

    DBG_PRINT0 (DL_0, "\r\nEntering GetLastDisplayFormat.");

    // Assume the format is 0
    lpDevData->cFormat = 0;

    // If this was a TV, then get the last format
    if  (lpDevData->cType == DEVTYPE_TV)
    {
        szTvFormat[0] = 0;
        GetLocalNvidiaDisplayDevRegString (lpRegData, lpDevData,
                                NV4_REG_DRV_LAST_TV_FORMAT, szTvFormat);
        if(szTvFormat[0] == 0)
                                return(FALSE);

        // Parse the device type and reduce it a bit
        for (i = 0; TVFormat[i].lpszName != NULL; i++)
            if  (!lstrcmpi (TVFormat[i].lpszName, szTvFormat))
                break;

        lpDevData->cFormat = TVFormat[i].cFormat;
    }

    DBG_PRINT0 (DL_1, "\r\nExiting GetDisplayDevice.");
    return  (TRUE);
}


/*
    Function:   GetDisplayDevice

    Purpose:    This routine gets the display device for the board
                specified. The particular display device is stored
                in the registry.

    Arguments:  lpRegData   - identifies the specific board that we
                              want the active display port for.
                dwLogDevice - 0 based logical device number
                dwPhysDevice- 0 based physical device number
                lpDevData   - ptr to the DEVDATA structure to be filled in

    Returns:    lpDevData filled in correctly
*/
int WINAPI
GetDisplayDevice (LPREGDATA lpRegData, ULONG dwLogDevice, ULONG dwPhysDevice,
                    LPDEVDATA lpDevData)
{
    char    szDev[32];
    char    szTemp[32];

    DBG_PRINT0 (DL_0, "\r\nEntering GetDisplayDevice.");

    wsprintf (szTemp, "%s%c", NV4_REG_DRV_PHYSICAL_DEVICE,
                                (char) (dwPhysDevice + '0'));
    GetLocalNvidiaDisplayLogRegString (lpRegData, dwLogDevice, szTemp, szDev);

    if  (!ParseDeviceTypeAndNumber (szDev, lpDevData))
        return  (FALSE);

    GetLastDisplayFormat (lpRegData, lpDevData);

    DBG_PRINT0 (DL_1, "\r\nExiting GetDisplayDevice.");
    return  (TRUE);
}


/*
    Function:   SetDisplayDevice

    Purpose:    This routine sets the display device for the board
                specified. The particular display device is stored
                in the registry.

    Arguments:  lpRegData   - identifies the specific board
                dwLogDevice - 0 based logical device number
                dwPhysDevice - 0 based physical device number
                lpDevData   - the basic display type
                              should be one of the DEVTYPE_XXXX
                              sonstants definde in modeext.h

    Returns:    Always returns TRUE
*/
int WINAPI
SetDisplayDevice (LPREGDATA lpRegData, ULONG dwLogDevice, ULONG dwPhysDevice,
                    LPDEVDATA lpDevData)
{
    char    szTemp[MAX_KEY_LEN];
    char    szDev[16];

    DBG_PRINT0 (DL_0, "\r\nEntering SetDisplayDevice.");

    if  (lpDevData->cType > MAX_DEVTYPES)
        lpDevData->cType = 0;

    if  (lpDevData->cNumber > 9)
        lpDevData->cNumber = 0;

    wsprintf (szDev, "%s%c", DeviceTypes[lpDevData->cType].lpszName,
                            lpDevData->cNumber + '0');

    wsprintf (szTemp, "%s%d", NV4_REG_DRV_PHYSICAL_DEVICE, dwPhysDevice);
    SetLocalNvidiaDisplayLogRegString (lpRegData, dwLogDevice, szTemp,
                                        szDev, lstrlen(szDev));

    // If this was a TV device, then write out the format
    if  (lpDevData->cType == DEVTYPE_TV)
    {
        SetLocalNvidiaDisplayDevRegString (lpRegData,
                                lpDevData, NV4_REG_DRV_LAST_TV_FORMAT,
                                TVFormat[lpDevData->cFormat].lpszName,
                                lstrlen(TVFormat[lpDevData->cFormat].lpszName));
    }

    DBG_PRINT0 (DL_1, "\r\nExiting SetDisplayDevice.");
    return  (TRUE);
}


/*
    Function:   GetForcedDesktopMode

    Purpose:    This routine gets a forced desktop mode if one exists
                in the registry. Then it deletes the key.

    Arguments:  lpRegData    - identifies the specific board
                lpSuggMode   - This has a suggested mode on the way in
                               If a forced mode is found it is saved
                               here on the way out.

    Returns:    lpSuggMode is updated to the forced mode if one is
                found and the routine returns TRUE. Otherwise,
                lpSuggMode is left alone and the routine returns FALSE.

                Note that at the time of this call, the only fields
                in lpSuggMode that are valid are: dwXRes, dwYRes, dwBpp.

                The values in the other fields should be ignored by
                this routine. The caller will overwrite the other
                fields after this routine returns, so changing the
                other fields in this routine will make no difference.

                FALSE   no forced desktop mode was found
                TRUE    a forced desktop mode was found.
*/
int WINAPI
GetForcedDesktopMode (LPREGDATA lpRegData, LPMODEINFO lpSuggMode)
{
    MODEINFO    sMI;

    DBG_PRINT0 (DL_0, "\r\nEntering GetForcedMode");

    // If the force mode string exists in the registry, then it specifies
    // the mode that should be set period, regardless of anything else.
    if  (!GrabModeInfoString (lpRegData, 0x0FFFFFFFF, &lpSuggMode->MIDevData,
                                NV4_REG_DRV_FORCED_DESKTOP_MODE, &sMI, 1))
    {
        DBG_PRINT0 (DL_0, "\r\nExiting GetForcedMode with Failure.");
        return  (FALSE);
    }

    // Now erase the force mode string
    DeleteLocalNvidiaDisplayDevRegEntry (lpRegData, &lpSuggMode->MIDevData,
                                        NV4_REG_DRV_FORCED_DESKTOP_MODE);
    // Return the mode.
    sMI.MIDevData = lpSuggMode->MIDevData;
    *lpSuggMode = sMI;

    DBG_PRINT0 (DL_1, "\r\nExiting GetForcedMode with Success.");
    return  (TRUE);
}


/*
    Function:   GetLargestEdidMode

    Purpose:    This routine gets the largest edid mode found.

    Arguments:
                lpEdidBuffer - points to a buffer with EDID data in
                               it if dwEdidSize is not 0. If dwEdidSize
                               is 0, this argument is ignored.
                dwEdidSize     tells the size of the lpEdidBuffer
                               in bytes. If this variables is 0,
                               then lpEdidBuffer ptr may be invalid.
                lpModeFound    MODEINFO ptr where the largest EDID mode
                               found should be stored.

    Returns:    TRUE    then lpModeFound was updated with the largest
                        EDID mode
                FALSE   lpModeFound was not updated. This could be because
                        there was no EDID or there was an error parsing
                        the EDID. It doesn't matter.
*/
int WINAPI
GetLargestEdidMode (LPCHAR lpEdidBuffer, ULONG dwEdidSize,
                    LPMODEINFO lpModeFound)
{
    if  (!dwEdidSize)
    {
        // Ignore the force mode if it asks us to look through an
        // EDID which is not there.
        DBG_PRINT0 (DL_0, "\r\nExiting GetLargestEdidMode with Failure.");
        return  (FALSE);
    }

    EdidFindLargestEdidMode (lpEdidBuffer, dwEdidSize, lpModeFound);
    return  (TRUE);
}



/*
    Function:   GetDeviceDesktopMode

    Purpose:    This routine gets the desktop mode for the board
                specified.

    Arguments:  lpRegData   - identifies the specific board that we
                              want the active display port for.
                lpModeInfo  - MODEINFO ptr that holds the desktop mode
                              ion return. Note that only the x,y,bpp
                              are relevent here. Refresh rates are
                              CRTC specific

    Returns:    lpModeInfo -> dwXRes, dwYRes, and dwBpp are filled in
*/
int WINAPI
GetDeviceDesktopMode (LPREGDATA lpRegData, LPMODEINFO lpModeInfo)
{
    int     nRet;

    DBG_PRINT0 (DL_0, "\r\nEntering GetDeviceDesktopMode.");

    nRet = GrabModeInfoString (lpRegData, 0x0FFFFFFFF, &lpModeInfo->MIDevData,
                            NV4_REG_DRV_LAST_DESKTOP_MODE, lpModeInfo, 1);

    DBG_PRINT0 (DL_1, "\r\nExiting GetDeviceDesktopMode.");
    return  (nRet);
}


/*
    Function:   SetDeviceDesktopMode

    Purpose:    This routine writes the desktop mode given into the
                registry for the particular deivce and board specified.

    Arguments:  lpRegData   - identifies the specific board
                lpModeInfo    MODEINFO ptr specifying desktop mode

    Returns:    Always returns TRUE
*/
int WINAPI
SetDeviceDesktopMode (LPREGDATA lpRegData, LPMODEINFO lpModeInfo)
{
    char    szTemp[32];

    DBG_PRINT0 (DL_0, "\r\nEntering SetDeviceDesktopMode.");

    // Set it into the registry
    wsprintf (szTemp, "%ld,%ld,%ld", lpModeInfo->dwXRes,
                lpModeInfo->dwYRes, lpModeInfo->dwBpp);
    SetLocalNvidiaDisplayDevRegString (lpRegData, &lpModeInfo->MIDevData,
                NV4_REG_DRV_LAST_DESKTOP_MODE, szTemp, lstrlen(szTemp));

    DBG_PRINT0 (DL_1, "\r\nExiting SetDeviceDesktopMode.");
    return  (TRUE);
}


/*
    Function:   GetForcedDisplayMode

    Purpose:    This routine gets the forced display mode for the board
                and device specified.

    Arguments:  lpRegData   - identifies the specific board that we
                              want the active display port for.
                lpModeInfo  - MODEINFO ptr that holds the desktop mode
                              ion return.

    Returns:    TRUE    lpModeInfo is filled in with a forced mode
                FALSE   there was no forced mode
*/
int WINAPI
GetForcedDisplayMode (LPREGDATA lpRegData, LPMODEINFO lpModeInfo)
{
    int     nRet;

    DBG_PRINT0 (DL_0, "\r\nEntering GetForcedDisplayMode.");

    nRet = GrabModeInfoString (lpRegData, 0x0FFFFFFFF, &lpModeInfo->MIDevData,
                            NV4_REG_DRV_FORCED_MODE, lpModeInfo, 0);

    // Now erase the force mode string
    DeleteLocalNvidiaDisplayDevRegEntry (lpRegData, &lpModeInfo->MIDevData,
                                        NV4_REG_DRV_FORCED_MODE);

    DBG_PRINT0 (DL_1, "\r\nExiting GetForcedDisplayMode.");
    return  (nRet);
}


/*
    Function:   GetDeviceDisplayMode

    Purpose:    This routine gets the display mode for the board
                and device specified.

    Arguments:  lpRegData   - identifies the specific board that we
                              want the active display port for.
                lpModeInfo  - MODEINFO ptr that holds the desktop mode
                              ion return.

    Returns:    lpModeInfo is filled in
*/
int WINAPI
GetDeviceDisplayMode (LPREGDATA lpRegData, LPMODEINFO lpModeInfo)
{
    int     nRet;

    DBG_PRINT0 (DL_0, "\r\nEntering GetDeviceDisplayMode.");

    nRet = GrabModeInfoString (lpRegData, 0x0FFFFFFFF, &lpModeInfo->MIDevData,
                            NV4_REG_DRV_LAST_MODE, lpModeInfo, 0);

    DBG_PRINT0 (DL_1, "\r\nExiting GetDeviceDisplayMode.");
    return  (nRet);
}


/*
    Function:   SetDeviceDisplayMode

    Purpose:    This routine writes the display mode given into the
                registry for the particular device and board specified.

    Arguments:  lpRegData   - identifies the specific board
                lpModeInfo    MODEINFO ptr specifying desktop mode

    Returns:    Always returns TRUE
*/
int WINAPI
SetDeviceDisplayMode (LPREGDATA lpRegData, LPMODEINFO lpModeInfo)
{
    char    szTemp[32];

    DBG_PRINT0 (DL_0, "\r\nEntering SetDeviceDisplayMode.");

    // Set it into the registry
    wsprintf (szTemp, "%ld,%ld,%ld,%ld", lpModeInfo->dwXRes,
                lpModeInfo->dwYRes, lpModeInfo->dwBpp,
                lpModeInfo->dwRefreshRate);
    SetLocalNvidiaDisplayDevRegString (lpRegData, &lpModeInfo->MIDevData,
                    NV4_REG_DRV_LAST_MODE, szTemp, lstrlen(szTemp));

    DBG_PRINT0 (DL_1, "\r\nExiting SetDeviceDisplayMode.");
    return  (TRUE);
}


/*
    Function:   GetPanningFlag

    Purpose:    This routine gets the panning flag especially for the clone mode
                 for the board and device specified.

    Arguments:  lpRegData   - identifies the specific board that we
                              want the active display port for.
                lpModeInfo  - MODEINFO ptr that holds the desktop mode
                              ion return.

    Returns:    0 - the clone device has the maximum possible resolution
                1 - resolution limited (custom panning enabled).
*/
int WINAPI
GetClonePanningFlag (LPREGDATA lpRegData, LPMODEINFO lpModeInfo)
{
    ULONG nRet = 0;

    DBG_PRINT0 (DL_0, "\r\nEntering GetPanningFlag.");

    GetLocalNvidiaDisplayDevRegString (lpRegData, &lpModeInfo->MIDevData,
                                NV4_REG_DRV_PANNING_FLAG, (char*)&nRet);

    DBG_PRINT0 (DL_1, "\r\nExiting GetPanningFlag.");
    return  (int)(nRet & 1);
}


/*
    Function:   SetPanningFlag

    Purpose:    This routine writes the panning flag especially for the clone mode
                 for the board and device specified.

    Arguments:  lpRegData   - identifies the specific board
                lpModeInfo    MODEINFO ptr specifying desktop mode

    Returns:    Always returns TRUE
*/
int WINAPI
SetClonePanningFlag (LPREGDATA lpRegData, LPMODEINFO lpModeInfo, ULONG dwFlag)
{
    char    szTemp[32];

    DBG_PRINT0 (DL_0, "\r\nEntering SetPanningFlag.");

    // Set it into the registry
    wsprintf (szTemp, "%ld", dwFlag);
    SetLocalNvidiaDisplayDevRegString (lpRegData, &lpModeInfo->MIDevData,
                    NV4_REG_DRV_PANNING_FLAG, szTemp, lstrlen(szTemp));

    DBG_PRINT0 (DL_1, "\r\nExiting SetPanningFlag.");
    return  (TRUE);
}

/*
    Function:   GetRefreshRateForDesktop

    Purpose:    This routine gets the correct refresh rate for
                the desktop as Windows has it buried in the registry.
                display device given by lpModeInfo->dwDevData.
                lpModeInfo->dwXRes, lpModeInfo->dwYRes, and
                lpModeInfo->dwBpp are valid, but the field
                lpModeInfo->dwRefreshRate is not.

    Arguments:  lpDispData  - identifies the specific board that we
                              want the active display port for.
                lpModeInfo  - contains the display device on which
                              the mode will be set and the mode
                              suggested by the caller.
                lpEdidBuffer- points to a buffer with EDID data in
                              it if dwEdidSize is not 0. If dwEdidSize
                              is 0, this argument is ignored.
                dwEdidSize    tells the size of the lpEdidBuffer
                              in bytes. If this variables is 0,
                              then lpEdidBuffer ptr may be invalid.

    Returns:    This routine should not override the Xres,Yres, and Bpp
                in lpModeInfo. Only the dwRefreshRate field should be
                adjusted. The rest of the mode is provided just in case
                it is needed to determine the correct refresh rate.

                If Windows wants a specific refresh rate value,
                then both the lpModeInfo->dwRefreshRate and the
                lpModeInfo->dwOriginalRefreshRate fields must be set
                to this specific value (liek 60, 75, 100, etc).

                If Windows wants the optimal rate, then the
                lpModeInfo->dwRefreshRate should be set to the
                specific value for the optimal refresh rate and
                lpModeInfo->dwOriginalRefreshRate should be set to -1.

                If Windows wants the default refresh rate, then the
                lpModeInfo->dwRefreshRate should be set to the
                specific value for the default refresh rate and
                lpModeInfo->dwOriginalRefreshRate should be set to 0.

                It Always returns TRUE.
*/
int WINAPI
GetRefreshRateForDesktop (LPDISPDATA lpDispData, LPMODEINFO lpModeInfo,
                            LPCHAR lpEdidBuffer, ULONG dwEdidSize)
{
    ULONG       dwSize, hControl;
    long        lRet;
#ifdef  STEREO_SUPPORT
    char        StereoKey[256];
    ULONG       StereoEnabled;
    ULONG       dwType = REG_DWORD;
#endif  //STEREO_SUPPORT

    DBG_PRINT0 (DL_0, "\r\nEntering GetRefreshRateForDesktop.");

#ifdef  STEREO_SUPPORT
    // If stereo is enabled the StereoRefreshRate associated with the mode always overrides
    // what windows wants.
    lstrcpy(StereoKey, NV4_REG_GLOBAL_BASE_PATH);
    lstrcat(StereoKey, "\\");
    lstrcat(StereoKey, NV4_REG_STEREO_SUBKEY);

    if  (RegOpenKey (NV4_REG_GLOBAL_BASE_KEY, StereoKey, &hControl) == ERROR_SUCCESS)
    {
        // Read the current user name
        dwSize = sizeof (long);
        lRet = RegQueryValueEx (hControl, NV_REG_STEREO_ENABLED, NULL, &dwType, 
                        (UCHAR *)&StereoEnabled, (ULONG FAR *) &dwSize);
        RegCloseKey (hControl);
        if  (lRet == ERROR_SUCCESS && StereoEnabled)
        {
            // We know stereo is on. Now let's see if there is a StereoRefreshRate setting
            // in the folder like
            // HKLM\System\CurrentControlSet\Services\Class\Display\000X\MODES\16\1024,768
            GetLocalPath (lpDispData->lpBoardRegistryData, szPath);
            wsprintf(szFullPath, "%s\\MODES\\%ld\\%ld,%ld", szPath,
                                lpModeInfo->dwBpp,
                                lpModeInfo->dwXRes, lpModeInfo->dwYRes);
            // Try to read the user refresh rate from there
            if  (GrabRefreshRateFromKey (HKEY_LOCAL_MACHINE, lpDispData, szFullPath,
                                            lpModeInfo, lpEdidBuffer, dwEdidSize, "StereoRefreshRate"))
                 return  (TRUE);
        }   
    }
#endif  //STEREO_SUPPORT

    // First, is there a current user?
    lRet = RegOpenKey (HKEY_LOCAL_MACHINE, szControl, &hControl);
    if  (lRet == ERROR_SUCCESS)
    {
        // Read the current user name
        szPath[0] = 0;
        dwSize = MAX_KEY_LEN;
        RegQueryValueEx (hControl, "Current User", NULL, NULL,
                         szPath, (ULONG FAR *) &dwSize);

        RegCloseKey (hControl);

        // Try to open HKU\szPath as a key
        lRet = RegOpenKey (HKEY_USERS, szPath, &hControl);
        if  (lRet == ERROR_SUCCESS)
        {
            // Try to read HKU\szPath\Display\Settings
            RegCloseKey (hControl);

            lstrcat (szPath, "\\Display\\Settings");

            // Try to read the user refresh rate
            if  (GrabRefreshRateFromKey (HKEY_USERS, lpDispData, szPath,
                                    lpModeInfo, lpEdidBuffer, dwEdidSize, "RefreshRate"))
                 return  (TRUE);
        }
    }


    // OK, we didn't find it there, so go onto the next stage.
    // This is a path something like
    // HKLM\System\CurrentControlSet\Services\Class\Display\000X\MODES\16\1024,768
    GetLocalPath (lpDispData->lpBoardRegistryData, szPath);
    wsprintf(szFullPath, "%s\\MODES\\%ld\\%ld,%ld", szPath,
                        lpModeInfo->dwBpp,
                        lpModeInfo->dwXRes, lpModeInfo->dwYRes);

    // Try to read the user refresh rate from there
    if  (GrabRefreshRateFromKey (HKEY_LOCAL_MACHINE, lpDispData, szFullPath,
                                    lpModeInfo, lpEdidBuffer, dwEdidSize, "RefreshRate"))
         return  (TRUE);


    // Well, that didn't work either, so last chance is:
    // HKLM\System\CurrentControlSet\Services\Class\Display\000X\Default
    GetLocalPath (lpDispData->lpBoardRegistryData, szPath);
    lstrcat (szPath, "\\Default");
    // Try to read the user refresh rate from there
    if  (GrabRefreshRateFromKey (HKEY_LOCAL_MACHINE, lpDispData, szPath,
                                    lpModeInfo, lpEdidBuffer, dwEdidSize, "RefreshRate"))
         return  (TRUE);

    // Well, we just have to set up a default refresh rate then
    lpModeInfo->dwRefreshRate = 60;
    lpModeInfo->dwOriginalRefreshRate = lpModeInfo->dwRefreshRate;

    return  (TRUE);
}


/*
    Function:   GrabModeInfoString

    Purpose:    This routine reads and parses a string of the
                form "xres,yres,bpp,refrate" from the registry.

    Arguments:  lpRegData    - identifies the specific board
                dwLogDevice  - 0 based logical device number
                               if 0x0FFFFFFFF, then not used.
                lpDevData    - 0 based physical device number
                               if 0x0FFFFFFFF, then not used.
                lpModeString - Name of entry in registry (relative
                               to XXXX\NVidia\Display) that tells the
                               specific mode string to read.
                lpMI         - MODEINFO ptr where parsed mode goes
                nType        - 0 then this is a CRTC info string of the
                               form "xres,yres,bpp,refrate"
                             - 1 then this is a Desktop info string of the
                               form "xres,yres,bpp"

    Returns:    TRUE  that a valid mode was parsed and stored in lpMI
                FALSE there was a problem with the parsing and lpMI
                does not contain valid data.

                NOTE: Even if this routine returns TRUE, it does not
                mean the mode is reasonable. 1,1,55,9876 would be parsed
                fine, but it is not a valid mode string. The caller
                must check for validity if it needs to ensure this.
*/
int CFUNC
GrabModeInfoString (LPREGDATA lpRegData, ULONG dwLogDevice, LPDEVDATA lpDevData,
                    LPCHAR lpModeString, LPMODEINFO lpMI, int nType)
{
    char    szModeInfo[MAX_KEY_LEN];
    ULONG   dwIndex;
    int     bModeValid = FALSE;

    DBG_PRINT0 (DL_0, "\r\nEntering GrabModeInfoString.");

    szModeInfo[0] = 0;

    // If dwLogDevice is 0x0FFFFFFFF, then we get the string from ...
    if  ((dwLogDevice == 0x0FFFFFFFF) && (lpDevData == NULL))
    {
        // ... Nvidia\Display
        GetLocalNvidiaDisplayRegString (lpRegData, lpModeString, szModeInfo);
    }
    else
    {
        // If lpDevData is 0x0FFFFFFFF, then we get the string from ...
        if  (lpDevData == NULL)
        {
            // ... Nvidia\Display\LogDevice%dwLogDevice%.
            GetLocalNvidiaDisplayLogRegString (lpRegData, dwLogDevice,
                                            lpModeString, szModeInfo);
        }
        else
        {
            // ... otherwise we get the string from
            // Nvidia\Display\LogDevice%dwLogDevice%\PhysDevice%dwPhysDevice%
            GetLocalNvidiaDisplayDevRegString (lpRegData, lpDevData,
                                                lpModeString, szModeInfo);
        }
    }

    // if we got something back from reading the key, then use it
    if  (szModeInfo[0] != 0)
    {
        // Try to parse the mode
        dwIndex = 0;
        bModeValid = TRUE;

        if  (!ParseDecimalNumberComma (szModeInfo, &dwIndex, &lpMI->dwXRes))
            bModeValid = FALSE;
        DBG_PRINT1(DL_2, "\r\nXRes found to be %ld", lpMI->dwXRes);

        if  (!ParseDecimalNumberComma (szModeInfo, &dwIndex, &lpMI->dwYRes))
            bModeValid = FALSE;
        DBG_PRINT1(DL_2, "\r\nYRes found to be %ld", lpMI->dwYRes);

        if  (!ParseDecimalNumberComma (szModeInfo, &dwIndex, &lpMI->dwBpp))
            bModeValid = FALSE;
        DBG_PRINT1(DL_2, "\r\nBpp found to be %ld", lpMI->dwBpp);

        // The XRes and YRes can be whatever, but let's validate the
        // Bpp here.
        if  ((lpMI->dwBpp != 8) && (lpMI->dwBpp != 16) && (lpMI->dwBpp != 32))
        {
            DBG_PRINT0(DL_2, "\r\nBpp invalid. Changed to 8.");
            lpMI->dwBpp = 8;
        }

        if  (nType == 0)
        {
            if  (!ParseDecimalSeparator (szModeInfo, &dwIndex, &lpMI->dwRefreshRate, ',', 0))
                bModeValid = FALSE;
            DBG_PRINT1(DL_2, "\r\nRefresh Rate found to be %ld", lpMI->dwRefreshRate);
        }
    }

    DBG_PRINT0 (DL_1, "\r\nExiting GrabModeInfoString.");
    return  (bModeValid);
}


/*
    Function:   GetDefaultRefreshRate

    Purpose:    This routine reads a key in the registry to get
                a specific value for the default refresh rate.
                There is an optional OEM specific key that can
                specify what default should mean. If the key does
                not exist, then 60 is returned.

    Arguments:
                lpDispData  - identifies the specific board
                lpModeInfo  - tells which display device port is being
                              used since there might be different
                              default refresh rates for DFPs and CRTs.

    Returns:    always returns a value that is the default refresh rate
*/
ULONG CFUNC
GetDefaultRefreshRate (LPDISPDATA lpDispData, LPMODEINFO lpModeInfo)
{
    int     nRet;
    ULONG   dwRefreshRate, dwIndex;
    char    szDev[32];

    // Filter out TVs here -- always say 60Hz.
    if  (lpModeInfo->MIDevData.cType == DEVTYPE_TV)
        return  (60);

    if  (lpModeInfo->MIDevData.cType == DEVTYPE_CRT)
        lstrcpy (szDev, NV4_REG_DRV_DEFAULT_CRT_VERT_REFRESH_RATE);
    else
        lstrcpy (szDev, NV4_REG_DRV_DEFAULT_DFP_VERT_REFRESH_RATE);

    nRet = GetLocalNvidiaDisplayRegString (lpDispData->lpBoardRegistryData,
                                            szDev, szPath);
    if  (nRet)
    {
        dwIndex = 0;
        if  (ParseDecimalSeparator (szPath, &dwIndex, &dwRefreshRate, 0, 0))
        {
            return  (dwRefreshRate);
        }
    }

    return  (60);
}


/*
    Function:   GetOptimalRefreshRate

    Purpose:    This routine reads a key in the registry to get
                a specific value for the default refresh rate.
                There is an optional OEM specific key that can
                specify what default should mean. If the key does
                not exist, then 60 is returned.

    Arguments:
                lpDispData   - identifies the specific board
                lpModeInfo   - Current mode and device identifier.
                lpEdidBuffer - points to a buffer with EDID data in
                               it if dwEdidSize is not 0. If dwEdidSize
                               is 0, this argument is ignored.
                dwEdidSize     tells the size of the lpEdidBuffer
                               in bytes. If this variables is 0,
                               then lpEdidBuffer ptr may be invalid.

    Returns:    always returns a value that is the optimal refresh rate
*/
ULONG CFUNC
GetOptimalRefreshRate (LPDISPDATA lpDispData, LPMODEINFO lpModeInfo,
                        LPCHAR lpEdidBuffer, ULONG dwEdidSize)
{
    ULONG           dwRefreshRate, dwRegRefreshRate, dwIndex;
    ULONG           dwMaxXRes;
    ULONG           dwMaxYRes;
    MONITORLIMITS   ML;
    char            szDev[32];

    if ((dwEdidSize == 0) && (lpDispData->dwMonitorInfType == UNKNOWN_DEVICE))
    {
        // If monitor is unknown and no EDID, then only 60Hz allowed.
        return  (60);
    }

    // Filter out TVs here -- always say 60Hz.
    if  (lpModeInfo->MIDevData.cType == DEVTYPE_TV)
        return  (60);

    // Check if RestrictOptimal key exists and is equal to ASCII "1".
    // If so, check detailed, established, and standard timings for
    // an exact match of the XRes and YRes and use that RefreshRate
    // if it exists.
    if (GetLocalNvidiaDisplayRegString (lpDispData->lpBoardRegistryData,
            NV4_REG_DRV_USE_REFRESH_RATE_OF_XYRES_EDID_MODE_MATCH, szPath))
    {
        if  (!lstrcmpi (szPath, NV4_REG_DRV_TRUE))
        {
            if (dwEdidSize)
            {
                dwRefreshRate = (ULONG) EdidFindExactModeWithHighestRR
                                             (lpEdidBuffer, dwEdidSize,
                                              lpModeInfo);
                if  (dwRefreshRate)
                    return  (dwRefreshRate);
            }
        }
    }

    // Now let's deal with an EDID if it exists
    if  (dwEdidSize != 0)
    {
        // Use the mode in the EDID with the largest refresh rate
        // whose resolution is at least as big as the one passed in.
        dwRefreshRate = (ULONG) EdidFindSameModeOrLargerWithHighestRR (
                                lpEdidBuffer, dwEdidSize, lpModeInfo);
    }
    else
    {
        if  (!GetMonitorInfRangeLimits (lpDispData, &ML, &dwMaxXRes, &dwMaxYRes))
        {
            // Something went wrong getting monitor range limits.
            // Limit ourselves to 60Hz
            return (60);
        }

        if  ((!dwMaxXRes) || (!dwMaxYRes))
        {
            return  (60);
        }

        // Use the maximum xres and yres at the max vertical refresh rate
        // to compute what the monitor limits will be at the desired target
        // resolution.
        dwRefreshRate = GetMaximumRefreshRate (dwMaxXRes, dwMaxYRes,
                        ML.dwMaxVert, &ML, lpModeInfo->dwXRes,
                        lpModeInfo->dwYRes);
    }

    // See if the registry has an upper limit on the optimal
    // refresh rate value.
    dwRegRefreshRate = 0;
    if  (lpModeInfo->MIDevData.cType == DEVTYPE_CRT)
        lstrcpy (szDev, NV4_REG_DRV_OPTIMAL_CRT_VERT_REFRESH_RATE);
    else
        lstrcpy (szDev, NV4_REG_DRV_OPTIMAL_DFP_VERT_REFRESH_RATE);

    if (GetLocalNvidiaDisplayRegString (lpDispData->lpBoardRegistryData,
                                    szDev, szPath))
    {
        dwIndex = 0;
        if  (!ParseDecimalSeparator (szPath, &dwIndex, &dwRegRefreshRate, 0, 0))
        {
            // Parsing the refresh rate found in the registry failed,
            // so set the refresh rate back to 0.
            dwRegRefreshRate = 0;
        }
    }

    // If we found an upper bound in the registry, use it
    if  (dwRegRefreshRate)
    {
        if  (dwRefreshRate > dwRegRefreshRate)
            dwRefreshRate = dwRegRefreshRate;
    }

    // Now return the refresh rate or 60Hz.
    if  (dwRefreshRate != 0)
        return  (dwRefreshRate);

    return  (60);
}



/*
    Function:   GrabRefreshRateFromKey

    Purpose:    This routine reads the RefreshRateName string value
                from the key and path provided and does a little
                preprocessing on what it finds. i.e. it handles
                optimal (-1) and default (0) cases.

    Arguments:  hKey          base Key in registry from which to read
                lpDispData  - identifies the specific board that we
                              want the active display port for.
                lpszPath      path in registry to access which may
                              contain a RefreshRateName string.
                lpModeInfo  - Current mode and device identifier.
                lpEdidBuffer- points to a buffer with EDID data in
                              it if dwEdidSize is not 0. If dwEdidSize
                              is 0, this argument is ignored.
                dwEdidSize    tells the size of the lpEdidBuffer
                              in bytes. If this variables is 0,
                              then lpEdidBuffer ptr may be invalid.

    Returns:    TRUE  then lpModeInfo->dwRefreshRate has a real
                      value stuffed in it. Also the field
                      lpModeInfo->dwOriginalRefreshRate has the
                      "Windows" value in it which might be the same
                      as ->dwRefreshRate if Windows was requesting
                      a specific refresh rate, or it can be 0 for
                      default or -1 for optimal.
                FALSE if nothing was found or there was an error.
*/
int CFUNC
GrabRefreshRateFromKey (ULONG hKey, LPDISPDATA lpDispData, LPCHAR lpszPath,
                LPMODEINFO lpModeInfo, LPCHAR lpEdidBuffer, ULONG dwEdidSize, char *RefreshRateName)
{
    ULONG   hControl;
    char    szRefreshRate[8];
    int     bFoundRefRate;
    ULONG   dwIndex, dwSize;
    long    lRet;

    lRet = RegOpenKey (hKey, lpszPath, &hControl);
    if  (lRet != ERROR_SUCCESS)
    {
        return  (FALSE);
    }

    // OK, now hUser is a key to someplace in the registry that
    // may have a RefreshRateName value string in it. Find out.
    szRefreshRate[0] = 0;
    dwSize = 8;
    RegQueryValueEx (hControl, RefreshRateName, NULL, NULL,
                         szRefreshRate, (ULONG FAR *) &dwSize);

    bFoundRefRate = FALSE;
    if  (szRefreshRate[0] != 0)
    {
        // OK -- if the value is a specific refresh rate then
        // that is what we use.
        dwIndex = 0;
        if  (ParseDecimalSeparator (szRefreshRate, &dwIndex, &lpModeInfo->dwOriginalRefreshRate, 0, 0))
        {
            if  (lpModeInfo->dwOriginalRefreshRate == 0)
            {
                // If we actually parsed a '0' that means adapter default
                lpModeInfo->dwRefreshRate =
                GetDefaultRefreshRate (lpDispData, lpModeInfo);
            }
            else
            {
                // dwOriginalRefreshRate has specific refresh rate. Save
                // in dwRefreshRate.
                lpModeInfo->dwRefreshRate = lpModeInfo->dwOriginalRefreshRate;
            }

            bFoundRefRate = TRUE;
        }

        // Is the refresh rate set to "-1"?  'Cause that is optimal.
        if  (!lstrcmpi(szRefreshRate, "-1"))
        {
            lpModeInfo->dwOriginalRefreshRate = 0x0FFFFFFFF;
            lpModeInfo->dwRefreshRate = GetOptimalRefreshRate (lpDispData,
                                                    lpModeInfo, lpEdidBuffer,
                                                    dwEdidSize);
            bFoundRefRate = TRUE;
        }

        // OK, we either found a value and parsed it or the value was
        // set to "-1". If either one of those things happened, then
        // we "found" a refresh rate. If neither happened, we didn't.
    }

    // Done with the key
    RegCloseKey (hControl);

    if  (bFoundRefRate)
    {
        // Just as a safety precausion, force refresh rates < 60 up to 60
        if  (lpModeInfo->dwRefreshRate < 60)
        {
            lpModeInfo->dwRefreshRate = 60;
            lpModeInfo->dwOriginalRefreshRate = lpModeInfo->dwRefreshRate;
        }

        return  (TRUE);
    }

    return  (FALSE);
}


char  *(szBppAppend[]) =
{
    "\\8", "\\16", "\\24", "\\32"
};

// I would put these locally on the stack in the following function,
// but we ran out of stack space!!
char            szResPath[MAX_KEY_LEN];
char            szRefreshRateList[MAX_KEY_LEN];
char            szNewRefreshRateList[MAX_KEY_LEN];
char            szPDPath[MAX_KEY_LEN];
char            szNPDPath[MAX_KEY_LEN];

/*
    Function:   ResetRefreshRates

    Purpose:    This routine walks through the refresh rate strings in
                all the leaf subkeys of ....\DISPLAY\000X\MODES and updates
                the Default string. The Default string has a refresh
                rate list of something like "60,70,72,75,85,100,120".
                This string is replaced with a new refresh rate string
                containing those refresh rates that are supported in
                the current configuration which is given by lpDispData.

                This routine assumes that all of the leaf subkeys of
                ....\DISPLAY\000X\MODES have in them a master refresh
                rate list string somethig like:
                "ModeRefreshRateList"   "60,70,72,75,85,etc.."

    Arguments:
                lpDevData    - LPDEVDATA
                lpDispData   - identifies the specific board and
                               configuration that we want the refresh
                               rate list to agree with.
                lpEdidBuffer - ptr to EDID
                dwEdidSize   - length of edid in bytes. 0 if no edid.

    Returns:    TRUE    if refresh rate list was updated
                FALSE   if it wasn't because of some error dealing with
                        the registry
*/
int WINAPI
ResetRefreshRates (LPDEVDATA lpDevData, LPDISPDATA lpDispData,
                    LPCHAR lpEdidBuffer, ULONG dwEdidSize)
{
    ULONG           dwSrcIndex;
    int             i, pd, npd, bDone;
    ULONG           dwSubKey, dwMajorKey;
    ULONG           hModeBppKey, hModeResKey, dwSize;
    ULONG           hModeNewBppKey, hModeNewResKey;
    ULONG           dwIndex, dwMaxDacSpeed, dwMaxRefreshRate, dwRefreshRate;
    ULONG           dwMaxXRes, dwMaxYRes;
    ULONG           dwXRes, dwYRes, dwTotalPixels;
    GTFIN           GTFIn;
    GTFOUT          GTFOut;
    LPCHAR          lpMasterRefreshRateList, lpNewRefreshRateList;
    long            lRet;
    char            szRes[32];
    char            szRegPath[MAX_KEY_LEN];
    char            szAddedRefreshRate[16];
    MONITORLIMITS   sML;

    // Start off with a "Last" value that will never match
#define MAX_CACHE_EDID_SIZE 512
    int             nMustReset, nSmallerSize;
    static          DEVDATA sLastDevData = { -1, 0, 0, 0 };
    static          ULONG   dwLastEdidSize = 0x0FFFFFFFF;
    static          unsigned char  szLastEdid[MAX_CACHE_EDID_SIZE];
    static          ULONG   dwLastMonitorInfType = 0x0FFFFFFFF;
    static          ULONG   dwLastMaxDacSpeed8bpp = 0x0FFFFFFFF;
    static          ULONG   dwLastMaxDacSpeed16bpp = 0x0FFFFFFFF;
    static          ULONG   dwLastMaxDacSpeed32bpp = 0x0FFFFFFFF;

    DBG_PRINT0(DL_0, "\r\nEntering ResetRefreshRates.");

    ///////////////////////////////////////////////////////////////
    // A little caching scheme to speed things up.
    // If the device type is DIFFERENT from the last one passed
    // into this routine then we definitely need to update the
    // refresh rate list. If it is the same type of device, then
    // we do some other checks.
    nMustReset = FALSE;
    if  (sLastDevData.cType != lpDevData->cType)
        nMustReset = TRUE;
    else
    {
        // Same device type. Do the current and last devices
        // both have EDIDS?
        if  (dwEdidSize != dwLastEdidSize)
            nMustReset = TRUE;
        else
        {
            // Edid Sizes are the same. If the edid size is not 0,
            // then compare the two EDIDs
            if  (dwEdidSize != 0)
            {
                if  (dwLastEdidSize < dwEdidSize)
                    nSmallerSize = (int) dwLastEdidSize;
                else
                    nSmallerSize = (int) dwEdidSize;

                for (i = 0; i < nSmallerSize; i++)
                {
                    if  (szLastEdid[i] != lpEdidBuffer[i])
                    {
                        nMustReset = TRUE;
                        break;
                    }
                }
            }

            // Make sure that both have the same type of .inf file
            if  (dwLastMonitorInfType != lpDispData->dwMonitorInfType)
                nMustReset = TRUE;

            // If we have different limits on the DAC speed ....
            if  ((dwLastMaxDacSpeed8bpp != lpDispData->dwMaxDacSpeedInHertz8bpp)
              || (dwLastMaxDacSpeed16bpp != lpDispData->dwMaxDacSpeedInHertz16bpp)
              || (dwLastMaxDacSpeed32bpp != lpDispData->dwMaxDacSpeedInHertz32bpp))
                nMustReset = TRUE;
        }
    }

    if  (!nMustReset)
    {
        // Last device and current device are the same.
        // Nothing to do.
        return  (TRUE);
    }
    else
    {
        // Save off all the stuff for cache comparison next time.
        sLastDevData = *lpDevData;
        dwLastEdidSize = dwEdidSize;
        dwLastMonitorInfType = lpDispData->dwMonitorInfType;
        if  (dwLastEdidSize)
        {
            // We simply can't cache EDIDs larger than 512 bytes
            if  (dwLastEdidSize > MAX_CACHE_EDID_SIZE)
                 dwLastEdidSize = 0;

            for (i = 0; i < (int) dwLastEdidSize; i++)
                szLastEdid[i] = lpEdidBuffer[i];
        }

        dwLastMaxDacSpeed8bpp = lpDispData->dwMaxDacSpeedInHertz8bpp;
        dwLastMaxDacSpeed16bpp = lpDispData->dwMaxDacSpeedInHertz16bpp;
        dwLastMaxDacSpeed32bpp = lpDispData->dwMaxDacSpeedInHertz32bpp;

        // Fall through and let's reset the refresh rate list correctly.
    }
    ///////////////////////////////////////////////////////////////


    // Try to get the path in the registry to where the mode list is.
    if  (GetLocalPath (lpDispData->lpBoardRegistryData, szRegPath) < 0)
    {
        DBG_PRINT0(DL_0, "\r\nExiting ResetRefreshRates because RegOpenKey (...MODES) failed.");
        return  (FALSE);
    }

    dwMajorKey = lpDispData->lpBoardRegistryData->dwMainKey;

    // Tack on "\\MODES" to the returned regpath
    lstrcat (szRegPath, "\\Modes");

    // Create a loop so we can extract the modes for each pixel depth
    for (pd = 0; pd < 4; pd++)
    {
        // Copy the path to ...DISPLAY\000X\MODES and then tack on
        // the correct pixel depth key
        lstrcpy (szPDPath, szRegPath);

        switch  (pd)
        {
            case 0:
                lstrcat (szPDPath, "\\8");
                dwMaxDacSpeed = lpDispData->dwMaxDacSpeedInHertz8bpp;
                break;
            case 1:
                lstrcat (szPDPath, "\\16");
                dwMaxDacSpeed = lpDispData->dwMaxDacSpeedInHertz16bpp;
                break;
            case 2:
                lstrcat (szPDPath, "\\24");
                // We don't support 24bpp so don't need to worry here.
                break;
            case 3:
                lstrcat (szPDPath, "\\32");
                dwMaxDacSpeed = lpDispData->dwMaxDacSpeedInHertz32bpp;
                break;
        }

        // We now have the key where the pixel depth specific modes are.
        // Go ahead and open the key.
        lRet = RegOpenKey (dwMajorKey, szPDPath, &hModeBppKey);

        if  (lRet != ERROR_SUCCESS)
        {
            // If we have trouble opening a Bpp key, that is OK, since
            // we might not support a particular pixel depth. Just go
            // on to the next one.
            continue;
        }

        // Enumerate the subkeys -- each key is a spatial resolution.
        // Within each key there is a "(default)" string which has a
        // list of refresh rates which looks like: "60,72,75,85"
        // If the key does not have a list of refresh rates, then
        // we just write 60Hz as the only available refresh rate for
        // that mode.

        for (dwSubKey = 0; TRUE; dwSubKey++)
        {
            lRet = RegEnumKey (hModeBppKey, dwSubKey, szRes, MAX_KEY_LEN);

            if  (lRet != ERROR_SUCCESS)
            {
                // If there was an error, it probably means that there are
                // no more subkeys -- i.e. resolutions for this pixel
                // depth. That's fine. Break out of the loop.
                break;
            }

            // Get the xres and yres from the key string.
            dwIndex = 0;
            ParseDecimalSeparator (szRes, &dwIndex, &dwXRes, ',', ',');
            ParseDecimalSeparator (szRes, &dwIndex, &dwYRes, 0, 0);

            // So, here's the thing. We have set dwMaxDacSpeed to the
            // maximum dac speed for the pixel depth we are currently
            // working with. dwMaxDacSpeed takes into account memory
            // speed limitations, graphics chip CRTC limitations, etc.
            // Given this MaxSpeed, we need to come up with a max
            // vertical refresh rate. We need Microsoft's algorithm
            // here so that we could match what they would show, but
            // we don't have it, so for now we do our best.
            // Use GTF to find a refresh rate.

            dwMaxRefreshRate = 0;
            if  ((dwEdidSize == 0) ||
                 (!EdidGetMonitorLimits (lpEdidBuffer, dwEdidSize, &sML)))
            {
                if  ((lpDispData->dwMonitorInfType != SPECIFIC_DEVICE) ||
                     (!GetMonitorInfRangeLimits (lpDispData, &sML, &dwMaxXRes, &dwMaxYRes)))
                {
                    // There are no monitor limits, from either an EDID
                    // or an .inf, so just say YES.
                    GTFIn.dwHPixels = dwXRes;
                    GTFIn.dwVLines  = dwYRes;
                    GTFIn.dwMarginsRqd = FALSE;
                    GTFIn.dwIntRqd = FALSE;
                    GTFIn.dwIPParmType = IPTYPE_PIXEL_CLOCK_RATE;
                    GTFIn.dwIPFreqRqd = Divide32By32 (dwMaxDacSpeed, 1000000);

                    // Get the timing parameters.
                    ComputeGTFParameters(&GTFIn, &GTFOut);
                    dwMaxRefreshRate = Multiply32By32 (GTFOut.dwPixelClockIn10KHertz, 10000);
                    dwTotalPixels = Multiply32By32 (GTFOut.dwVTotalScans, (GTFOut.dwHTotalChars << 3));
                    dwMaxRefreshRate = Divide32By32 (dwMaxRefreshRate, dwTotalPixels);
                }
            }

            if  (dwMaxRefreshRate == 0)
            {
                if (sML.dwMaxPixelClock > dwMaxDacSpeed)
                    sML.dwMaxPixelClock = dwMaxDacSpeed;
                dwMaxRefreshRate = GetMaximumRefreshRate (0, 0, 0, &sML,
                                        dwXRes, dwYRes);
            }

            DmtGetMaximumRefreshRate (dwXRes, dwYRes, sML.dwMaxPixelClock,
                                      &dwRefreshRate);

            if (dwRefreshRate > dwMaxRefreshRate)
                dwMaxRefreshRate = dwRefreshRate;

            // Build a full path to the resolution key so we can open it
            lstrcpy (szResPath, szPDPath);
            lstrcat (szResPath, "\\");
            lstrcat (szResPath, szRes);

            // OK, now open the spatial resolution key so that we can
            // get the list of refresh rates for this resolution.
            lRet = RegOpenKey (dwMajorKey, szResPath, &hModeResKey);

            if  (lRet == ERROR_SUCCESS)
            {
                // Read the "ModeRefreshRateList" key.
                dwSize = MAX_KEY_LEN;
                lRet = RegQueryValueEx (hModeResKey, "ModeRefreshRateList",
                                NULL, NULL, szRefreshRateList, &dwSize);

                if  (lRet != ERROR_SUCCESS)
                {
                    // If we didn't find a ModeRefreshRateList, there
                    // might be several reasons. Asuume, though, that
                    // we could find one if we looked at the same
                    // resolution key in a lower color depth.
                    for (npd = pd - 1; npd >= 0; npd--)
                    {
                        lstrcpy (szNPDPath, szRegPath);
                        lstrcat (szNPDPath, szBppAppend[npd]);
                        lRet = RegOpenKey (dwMajorKey, szNPDPath, &hModeNewBppKey);
                        if  (lRet == ERROR_SUCCESS)
                        {
                            lstrcat (szNPDPath, "\\");
                            lstrcat (szNPDPath, szRes);
                            lRet = RegOpenKey (dwMajorKey, szNPDPath, &hModeNewResKey);
                            if  (lRet == ERROR_SUCCESS)
                            {
                                // Read the "ModeRefreshRateList" key.
                                dwSize = MAX_KEY_LEN;
                                lRet = RegQueryValueEx (hModeNewResKey,
                                        "ModeRefreshRateList", NULL,
                                        NULL, szRefreshRateList, &dwSize);

                                RegCloseKey (hModeNewResKey);
                            }

                            RegCloseKey (hModeNewBppKey);
                        }

                        if  (lRet == ERROR_SUCCESS)
                            break;
                    }
                }


                if  (lRet == ERROR_SUCCESS)
                {
                    // Now build a refresh rate string consisting of
                    // those refresh rates that are supported according
                    // to the BoardData.

                    // Always specify 60Hz.
                    lpNewRefreshRateList = szNewRefreshRateList;
                    wsprintf (lpNewRefreshRateList, "%d", 60);

                    if  ((lpDevData->cType == DEVTYPE_CRT) ||
                         (lpDevData->cType == DEVTYPE_DFP))
                    {
                        dwSrcIndex = 0;
                        bDone = FALSE;
                        lpMasterRefreshRateList = szRefreshRateList;
                        for (i = 0; !bDone; i++)
                        {
                            // Get the next refresh rate in the naster list
                            bDone = !ParseDecimalSeparator (lpMasterRefreshRateList, &dwSrcIndex, &dwRefreshRate, ',', 0);

                            if  (!bDone)
                            {
                                // We found a decimal number refresh rate
                                // Is this one within bounds?
                                if  (dwRefreshRate <= dwMaxRefreshRate)
                                {
                                    // Add it to the new list if it is not 60Hz
                                    // since we already added that in above
                                    if  (dwRefreshRate != 60)
                                    {
                                        wsprintf (szAddedRefreshRate, ",%d", dwRefreshRate);
                                        lstrcat (lpNewRefreshRateList, szAddedRefreshRate);
                                    }
                                }
                            }
                        }
                    }

                    // Write back the updated refresh rate list as
                    // the defaukt field in this key. That is what
                    // windows expects.
                    RegSetValueEx (hModeResKey, "", NULL, REG_SZ, lpNewRefreshRateList, lstrlen(lpNewRefreshRateList));
                }
            }

            // Close this bpp key
            RegCloseKey (hModeResKey);
        }

        // Close this bpp key
        RegCloseKey (hModeBppKey);
    }

    DBG_PRINT0(DL_0, "\r\nExiting ResetRefreshRates.");

    return  (TRUE);
}

/*
    Function:   GetEdidRegistryKey

    Purpose:    This routine gets the registry key that tells
                whether or not we are supposed to read the EDID.

    Arguments:  lpRegData   - identifies the specific board

    Returns:    0       registry key does not exist or says not to
                        read the EDID
                non-0   registry key exists and says to read the EDID
*/
int WINAPI
GetEdidRegistryKey (LPREGDATA lpRegData)
{
    int     nFlag;

    DBG_PRINT0 (DL_0, "\r\nEntering GetEdidRegistryKey.");

    nFlag = GetLocalNvidiaDisplayRegValue (lpRegData,
                                        NV4_REG_DRV_FORCE_EDID_READ, 0);

    DBG_PRINT1(DL_1, "\r\nExiting GetEdidRegistryKey.", nFlag);
    return  (nFlag);
}


int WINAPI
SetResolutionAndColorDepth (ULONG Bpp, ULONG XRes, ULONG YRes)
{
    ULONG       hDisplay;
    long        lRet;
    char        szResolution[MAX_KEY_LEN];
    char        szBpp[MAX_KEY_LEN];

    wsprintf (szResolution, "%ld,%ld", XRes, YRes);
    wsprintf (szBpp, "%ld", Bpp);

    // Open display settings key
    lRet = RegOpenKey (HKEY_CURRENT_CONFIG, szSettings, &hDisplay);
    if  (lRet == ERROR_SUCCESS)
    {
        RegSetValueEx (hDisplay, "Resolution", NULL, REG_SZ, szResolution, strlen(szResolution));
        RegCloseKey (hDisplay);
        return  (TRUE);
    }
    return  (FALSE);
}


/*
    GetDesktopModeList

    This routine gets the desktop mode list and returns it.

    The modes are returned as either MODEENTRY, MODEENTRYNORR, or
    MODEENTRYANDPITCH structures depending upon the value of dwType.

    If dwType is MODETYPE_MODEENTRY, then MODEENTRY structures are
    returned. If dwType is MODETYPE_MODEENTRYNORR, then MODEENTRYNORR
    structures are returned. If dwType is MODETYPE_MODEENTRYANDPITCH,
    then MODEENTRYANDPITCH structures are returned.
*/
int WINAPI
GetDesktopModeList (LPDISPDATA lpDispData, LPCHAR lpModes, ULONG dwType)
{
    LPMODEENTRY lpME;
    int         j;

    lpME = GetModeListFromRegistry (lpDispData);

    j = FormatModeList (lpDispData, lpModes, dwType, lpME);

    FreeMasterModeList (lpME);
    return  (j);
}


/*
    Function:   GetAllowAllModesFlag

    Purpose:    WIN9X spacific function for testing only.
                This function get "AllowAllModes" registry key
                for specified DispData.

    Arguments:
                lpDispData - identifies the specific board that we
                             want the active display port for.
    Returns:    "AllowAllModes" key value or FALSE.
*/
ULONG WINAPI GetAllowAllModesFlag(LPREGDATA lpRegData)
{

    int     nDefault = 0;
    int     wAllowAllModes = 0;

    wAllowAllModes =
        GetLocalNvidiaDisplayRegValue (lpRegData,
                                    NV4_REG_DRV_ALLOW_ALL_MODES, nDefault);

    return ((ULONG) wAllowAllModes);
}


/*
    Function:   GetAllowMightyModesFlag

    Purpose:    WIN9X spacific function for testing only.
                This function gets "AllowMightyModes" registry key
                for specified DispData.

    Arguments:
                lpDispData - identifies the specific board that we
                             want the active display port for.
    Returns:    "AllowMightyModes" key value or FALSE.
*/
ULONG WINAPI GetAllowMightyModesFlag(LPREGDATA lpRegData)
{

    int     nDefault = 0;
    int     wAllowMightyModes = 0;

    wAllowMightyModes =
        GetLocalNvidiaDisplayRegValue (lpRegData,
                                    NV4_REG_DRV_ALLOW_MIGHTY_MODES, nDefault);

    return ((ULONG) wAllowMightyModes);
}

/*
    Function:   GetControlVisionFlag

    Purpose:    WIN9X spacific function for testing only.
        This function get "ControlVision" registry key
        for specified DispData.

    Arguments:
                lpDispData - identifies the specific board that we
                             want the active display port for.
    Returns:    "ControlVision" key value or FALSE.
*/


int WINAPI
GetControlVisionFlag(LPDISPDATA lpDispData)
{

    int     nDefault = 0;
    int     wControlVisionFlag = 0;

    wControlVisionFlag = GetLocalNvidiaDisplayRegValue (lpDispData->lpBoardRegistryData,
                                   "ControlVision", nDefault);

    return wControlVisionFlag;
}


/*
    Function:   GetCheckSXGAPanelFlag

    Purpose:    This function gets "CheckSXGAPanel" registry key
                for specified DispData.

    Arguments:
                lpDispData - identifies the specific board that we
                             want the active display port for.
    Returns:    "CheckSXGAPanel" key value or FALSE.
*/
ULONG WINAPI GetCheckSXGAPanelFlag(LPREGDATA lpRegData)
{

    int     nDefault = 0;
    int     wCheckSXGAPanel = 0;

    wCheckSXGAPanel =
        GetLocalNvidiaDisplayRegValue (lpRegData,
                                    NV4_REG_DRV_CHECK_SXGA_PANEL, nDefault);

    return ((ULONG) wCheckSXGAPanel);
}


/*
    ParseDeviceTypeAndNumber

    Purpose:    This routine parses a string of the form "CRT4"
                or "TV2".  It gets the device type followed by
                the device number hich can be 0 - 9.

    Arguments:  lpszString  - string of the form described in Purpose:
                lpDevData   - ptr to a DEVTYPE structure.

    Returns:    TRUE    if lpDevData is filled in correctly.
                        Note: Only the DEVTYPE.cType and DEVTYPE.cNumber
                        are filled in. The DEVTYPE.cFormat is untouched.
                FALSE   otherwise
*/
int WINAPI
ParseDeviceTypeAndNumber (LPCHAR lpszString, LPDEVDATA lpDevData)
{
    int     i, nIndex, nEnd, nRet;
    char    cOld;

    nIndex = 0;
    for (i = 0; DeviceTypes[i].lpszName != NULL; i++)
    {
        // lstrncmpi does not exist, so I do it this way ...
        nEnd = (int) lstrlen (DeviceTypes[i].lpszName);
        cOld = lpszString[nEnd];

        lpszString[nEnd] = 0;
        nRet = (int) lstrcmpi (DeviceTypes[i].lpszName, lpszString);
        lpszString[nEnd] = cOld;

        if  (!nRet)
        {
            lpDevData->cType = DeviceTypes[i].cType;
            nIndex = nEnd;
            break;
        }
    }

    if  (nIndex != 0)
    {
        // We must have found a device type
        lpDevData->cNumber = lpszString[nIndex] - '0';
        if  ((lpDevData->cNumber < 0) || (lpDevData->cNumber > 9))
            lpDevData->cNumber = 0;

        return  (TRUE);
    }

    return  (FALSE);
}


/*
    IsDriverAttachedToDesktop

    Purpose:    This routine reads a Widnows OS maintained string
                in part of the registry that says whether or not
                the device specified is part of the virtual desktop
                in a multi-mon sceanrio. This way we can tell whether
                the device is enabled or not.

    Arguments:  lpszPciSpecifier
                This is a string that looks something like:
                PCI\VEN_10DE&DEV_0110&SUBSYS_00000000&REV_A1\000800

                We will need to convert this to
                PCI_VEN_10DE&DEV_0110&SUBSYS_00000000&REV_A1_000800_0001

                NOTE that the '\' got changed to an underscore and
                the _0001 got tacked on the end. Look for this key
                under HKEY_CURRENT_CONFIG\Display\Settings. Then go
                into it and look for something called "AttachToDesktop"
                It is a string value and if is present and has value "1"
                then return TRUE. Else we return FALSE.

    Returns:    TRUE    Driver is attached to desktop (device is enabled)
                FALSE   otherwise
*/
int WINAPI
IsDriverAttachedToDesktop (LPCHAR lpszPciSpecifier,ULONG ulDeviceNum)
{
    char    szRegPath[128], szRet[MAX_KEY_LEN];
    int     i, nLen, nRet, nUseCurrentConfig;
    ULONG   lRet, hKey;

    // First read registry to see if a user is logged in. The
    // AttachToDesktop key is valid in different locations in the
    // registry depending on whether or not a user is logged in.
    lstrcpy (szRegPath, "System\\CurrentControlSet\\Control\\");
    nLen = (int) lstrlen (szRegPath);

    lRet = RegOpenKey (HKEY_LOCAL_MACHINE, szRegPath, &hKey);

    // If we don't know, then play it safe and return TRUE
    if  (lRet != ERROR_SUCCESS)
        return  (TRUE);

    // Now read the AttachToDesktop value name
    nRet = GetRegString (hKey, "Current User", szRet);

    // If Current User exists, can only use HKEY_CURRENT_USER if
    // the user in "Current User" has a registry subdirectory in
    // HKEY_USERS.
    nUseCurrentConfig = TRUE;
    if (nRet)
    {
        lRet = RegOpenKey (HKEY_USERS, szRet, &hKey);
        if (lRet == ERROR_SUCCESS)
        {
            nUseCurrentConfig = FALSE;
            RegCloseKey (hKey);
        }
    }

    lstrcpy (szRegPath, "Display\\Settings\\");
    nLen = (int) lstrlen (szRegPath);

    // Copy lpszPciSpecifier replacing any '\' with an underscore
    for (i = 0; lpszPciSpecifier[i] != 0; i++)
    {
        szRegPath[nLen + i] = lpszPciSpecifier[i];
        if  (szRegPath[nLen + i] == '\\')
            szRegPath[nLen + i] = '_';
    }

    // Null terminate it
    szRegPath[nLen + i] = 0;

    // Tack a _0001 on the end for the second device on this board
	if(ulDeviceNum != 0)
	{
		wsprintf (szRegPath + nLen + i, "_000%1d", ulDeviceNum);
	}

    // Open the key. If "Current User" exists, use HKEY_CURRENT_USER;
    // otherwise, use HKEY_CURRENT_CONFIG.
    if (nUseCurrentConfig)
        lRet = RegOpenKey (HKEY_CURRENT_CONFIG, szRegPath, &hKey);
    else
        lRet = RegOpenKey (HKEY_CURRENT_USER, szRegPath, &hKey);

    // If we don't know, then play it safe and return TRUE
    if  (lRet != ERROR_SUCCESS)
        return  (TRUE);

    szRet[0] = 0;

    // Now read the AttachToDesktop value name
    nRet = GetRegString (hKey, "AttachToDesktop", szRet);

    if (nRet == TRUE)
    {
        // AttachToDesktop can be '0'. Make sure the key not only exists
        // but is equal to '1'.
        if (szRet[0] == '1')
            return  (TRUE);
    }

    return  (FALSE);
}


/*
    lpfnResetDisabledDeviceResolutions

    Purpose:    This routine runs through all the devices that have
                ever been secondaries and reset their resolutions
                to 640x480

    Arguments:  None

    Returns:    TRUE
*/
int WINAPI
lpfnResetDisabledDeviceResolutions ()
{
    char    szRegPath[128], szYes[4];
    ULONG   dwSubKey, lRet, dwSize;
    ULONG   hKey, hFullKey;

    lstrcpy (szRegPath, szSettings);

    // Open the key
    lRet = RegOpenKey (HKEY_CURRENT_CONFIG, szRegPath, &hKey);

    // Just return if it failed.
    if  (lRet != ERROR_SUCCESS)
        return  (TRUE);

    for (dwSubKey = 0; TRUE; dwSubKey++)
    {
        lRet = RegEnumKey (hKey, dwSubKey, szExtraKey, MAX_KEY_LEN);
        if  (lRet != ERROR_SUCCESS)
        {
            // If there was an error, it probably means that there are
            // no more subkeys -- i.e. no more secondaries to look at.
            break;
        }

        // Tack the base key onto this and open
        lstrcpy (szFullPath, szRegPath);
        lstrcat (szFullPath, "\\");
        lstrcat (szFullPath, szExtraKey);

        lRet = RegOpenKey (HKEY_CURRENT_CONFIG, szFullPath, &hFullKey);
        if  (lRet == ERROR_SUCCESS)
        {
            // Is this device enabled?
            // Read the AttachToDesktop key
            szYes[0] = 0;
            dwSize = 4;
            lRet = RegQueryValueEx (hFullKey, "AttachToDesktop", NULL,
                                NULL, (LPCHAR) &szYes, &dwSize);

            if  ((szYes[0] == 0) || (szYes[0] == '0'))
            {
                // If the AttachToDesktop key doesn't exist OR
                // it exists AND it is explicitly set to "0", then
                // the device is disabled.

                RegSetValueEx (hFullKey, "Resolution", NULL,
                                    REG_SZ, sz640_480, lstrlen(sz640_480));
            }

            RegCloseKey (hFullKey);
        }
    }

    RegCloseKey (hKey);
    return  (TRUE);
}

int WINAPI
DisplayDriverControl()
{
    //Just set breakpoint here and you will control any driver Loading-Unloading.
    //ax should be the value for SYMLOC
    return  (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\modeset.mhd\mac\rtget.c ===
/*
    FILE:   rtget.c
    DATE:   4/8/99

    This file holds code to get the restrction and timing list.
    If there isn't one -- just return the blank list (not a NULL
    ptr.)
*/

#include "cmntypes.h"
#include "modeext.h"
#include "modeset.h"
#include "utils.h"
#include "restime.h"
#include "debug.h"

// Just in cae we can't GlobalAlloc a list, we have a single entry one
// we can use here.
RESTIME     rtList;
LPRESTIME   lpResTimeList = NULL;

LPRESTIME CFUNC GetMasterRTList(LPDISPDATA lpDispData);
int CFUNC FreeMasterRTList(LPRESTIME lpRTList);
/*
 * SetResTimeList
 */
void SetResTimeList(void *lpRtList)
{
    lpResTimeList = (LPRESTIME)lpRtList;
    return;
}
/*
    GetMasterRTList

    This routine extracts the Restriction and Timing list for the
    device requested from the registry. nRTListLen is the length
    in RESTIME structures of the array pointed to by lpRTList.
*/
LPRESTIME CFUNC GetMasterRTList
(
    LPDISPDATA lpDispData
)
{
    LPRESTIME   lpRTList;

    if (lpResTimeList)
        lpRTList = lpResTimeList;
    else
    {
        // Here is returning a blank list.
        lpRTList = &rtList;
        lpRTList[0].dwXRes = 0;
    }
    return  (lpRTList);
}
/*
    FreeMasterRTList

    This routine is called when the caller is done with the RTList.
*/
int CFUNC FreeMasterRTList
(
    LPRESTIME lpRTList
)
{
/*
 * CHASCHAS - How will we do this on Mac?
 */

    return  (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\modeset.mhd\win9x\MODELIST.C ===
/*
    FILE:   modelist.c
    DATE:   4/8/99

    This file holds code to build a modelist from the registry
    and to walk the list looking for different things.
*/

#include "cmntypes.h"
#include "modeext.h"
#include "modeset.h"
#include "mywin.h"
#include "regfuncs.h"
#include "debug.h"
#include "utils.h"
#include "..\..\common\inc\nvreg.h"
#include "restime.h"
#include "osapi.h"

MODEENTRY   SafeModeList[] =
{
    { 640,  480, 8,  60 },
    { 800,  600, 8,  60 },
    { 1024, 768, 8,  60 },
    { 640,  480, 16, 60 },
    { 800,  600, 16, 60 },
    { 1024, 768, 16, 60 },
    { 640,  480, 32, 60 },
    { 800,  600, 32, 60 },
    { 1024, 768, 32, 60 },
    { 0,    0,   0,  0  },
    { 1,    0,   0,  0  }
};

MODEENTRY   sLowModes[] =
{
    { 320,  200, 8,  60 },
    { 320,  200, 8,  70 },
    { 320,  200, 8,  72 },
    { 320,  200, 8,  75 },
    { 320,  200, 8,  85 },
    { 320,  200, 8,  100 },
    { 320,  200, 8,  120 },
    { 320,  240, 8,  60 },
    { 320,  240, 8,  70 },
    { 320,  240, 8,  72 },
    { 320,  240, 8,  75 },
    { 320,  240, 8,  85 },
    { 320,  240, 8,  100 },
    { 320,  240, 8,  120 },
    { 400,  300, 8,  60 },
    { 400,  300, 8,  70 },
    { 400,  300, 8,  72 },
    { 400,  300, 8,  75 },
    { 400,  300, 8,  85 },
    { 400,  300, 8,  100 },
    { 400,  300, 8,  120 },
    { 480,  360, 8,  60 },
    { 480,  360, 8,  70 },
    { 480,  360, 8,  72 },
    { 480,  360, 8,  75 },
    { 480,  360, 8,  85 },
    { 480,  360, 8,  100 },
    { 480,  360, 8,  120 },
    { 512,  384, 8,  60 },
    { 512,  384, 8,  70 },
    { 512,  384, 8,  72 },
    { 512,  384, 8,  75 },
    { 512,  384, 8,  85 },
    { 512,  384, 8,  100 },
    { 640,  400, 8,  60 },
    { 640,  400, 8,  70 },
    { 640,  400, 8,  72 },
    { 640,  400, 8,  75 },
    { 640,  400, 8,  85 },
    { 640,  400, 8,  100 },
    { 640,  400, 8,  120 },
    { 320,  200, 16, 60 },
    { 320,  200, 16, 70 },
    { 320,  200, 16, 72 },
    { 320,  200, 16, 75 },
    { 320,  200, 16, 85 },
    { 320,  200, 16, 100 },
    { 320,  200, 16, 120 },
    { 320,  240, 16, 60 },
    { 320,  240, 16, 70 },
    { 320,  240, 16, 72 },
    { 320,  240, 16, 75 },
    { 320,  240, 16, 85 },
    { 320,  240, 16, 100 },
    { 320,  240, 16, 120 },
    { 400,  300, 16, 60 },
    { 400,  300, 16, 70 },
    { 400,  300, 16, 72 },
    { 400,  300, 16, 75 },
    { 400,  300, 16, 85 },
    { 400,  300, 16, 100 },
    { 400,  300, 16, 120 },
    { 480,  360, 16, 60 },
    { 480,  360, 16, 70 },
    { 480,  360, 16, 72 },
    { 480,  360, 16, 75 },
    { 480,  360, 16, 85 },
    { 480,  360, 16, 100 },
    { 480,  360, 16, 120 },
    { 512,  384, 16, 60 },
    { 512,  384, 16, 70 },
    { 512,  384, 16, 72 },
    { 512,  384, 16, 75 },
    { 512,  384, 16, 85 },
    { 512,  384, 16, 100 },
    { 640,  400, 16, 60 },
    { 640,  400, 16, 70 },
    { 640,  400, 16, 72 },
    { 640,  400, 16, 75 },
    { 640,  400, 16, 85 },
    { 640,  400, 16, 100 },
    { 640,  400, 16, 120 },
    { 320,  200, 32, 60 },
    { 320,  200, 32, 70 },
    { 320,  200, 32, 72 },
    { 320,  200, 32, 75 },
    { 320,  200, 32, 85 },
    { 320,  200, 32, 100 },
    { 320,  200, 32, 120 },
    { 320,  240, 32, 60 },
    { 320,  240, 32, 70 },
    { 320,  240, 32, 72 },
    { 320,  240, 32, 75 },
    { 320,  240, 32, 85 },
    { 320,  240, 32, 100 },
    { 320,  240, 32, 120 },
    { 400,  300, 32, 60 },
    { 400,  300, 32, 70 },
    { 400,  300, 32, 72 },
    { 400,  300, 32, 75 },
    { 400,  300, 32, 85 },
    { 400,  300, 32, 100 },
    { 400,  300, 32, 120 },
    { 480,  360, 32, 60 },
    { 480,  360, 32, 70 },
    { 480,  360, 32, 72 },
    { 480,  360, 32, 75 },
    { 480,  360, 32, 85 },
    { 480,  360, 32, 100 },
    { 480,  360, 32, 120 },
    { 512,  384, 32, 60 },
    { 512,  384, 32, 70 },
    { 512,  384, 32, 72 },
    { 512,  384, 32, 75 },
    { 512,  384, 32, 85 },
    { 512,  384, 32, 100 },
    { 640,  400, 32, 60 },
    { 640,  400, 32, 70 },
    { 640,  400, 32, 72 },
    { 640,  400, 32, 75 },
    { 640,  400, 32, 85 },
    { 640,  400, 32, 100 },
    { 640,  400, 32, 120 },
    { 960,  720, 8,  60 },
    { 960,  720, 8,  70 },
    { 960,  720, 8,  72 },
    { 960,  720, 8,  75 },
    { 960,  720, 8,  85 },
    { 960,  720, 8,  100 },
    { 960,  720, 8,  120 },
    { 960,  720, 8,  140 },
    { 960,  720, 8,  144 },
    { 960,  720, 8,  150 },
    { 960,  720, 8,  170 },
    { 960,  720, 8,  200 },
    { 960,  720, 8,  240 },
    { 960,  720, 16, 60 },
    { 960,  720, 16, 70 },
    { 960,  720, 16, 72 },
    { 960,  720, 16, 75 },
    { 960,  720, 16, 85 },
    { 960,  720, 16, 100 },
    { 960,  720, 16, 120 },
    { 960,  720, 16, 140 },
    { 960,  720, 16, 144 },
    { 960,  720, 16, 150 },
    { 960,  720, 16, 170 },
    { 960,  720, 16, 200 },
    { 960,  720, 16, 240 },
    { 960,  720, 32, 60 },
    { 960,  720, 32, 70 },
    { 960,  720, 32, 72 },
    { 960,  720, 32, 75 },
    { 960,  720, 32, 85 },
    { 960,  720, 32, 100 },
    { 960,  720, 32, 120 },
    { 960,  720, 32, 140 },
    { 960,  720, 32, 144 },
    { 960,  720, 32, 150 },
    { 960,  720, 32, 170 },
    { 960,  720, 32, 200 },
    { 960,  720, 32, 240 },
    { 0,    0,   0,  0  },
};

#define USE_60HZ                        0x00
#define USE_REFRESH_RATES_FROM_LOWER    0x01
#define USE_REFRESH_RATES_FROM_STRING   0x02

extern int CFUNC GetSafeModeList (LPMODEENTRY lpModeList);


/*
    GetMasterModeList

    This routine extracts the mode list for the board requested
    from the registry. This routine will always return some mode
    list.  If it can't find the board requested a safe mode list
    is returned.
*/
LPMODEENTRY CFUNC
GetMasterModeList (LPDISPDATA lpDispData)
{
    ULONG       i, j, pd, dwIndex, dwXRes, dwYRes;
    ULONG       hModeBppKey, hModeResKey, dwSize, dwMatchIndex;
    ULONG       dwSubKey, dwValue;
    ULONG       dwMajorKey;
    ULONG       dwValueNameSize;
    LPCHAR      lpC;
    int         nMode, nFlagRR;
    char        szValueName[MAX_KEY_LEN];
    char        szRegPath[MAX_KEY_LEN];
    char        szPDPath[MAX_KEY_LEN];
    char        szRes[MAX_KEY_LEN];
    char        szResPath[MAX_KEY_LEN];
    char        szRefreshRate[MAX_KEY_LEN];
    long        lRet;
    LPMODEENTRY lpML;

    DBG_PRINT0(DL_0, "\r\nEntering GetMasterModeList.");

    // Next, grab the mode list from the registry
    if  (!(lpML = (LPMODEENTRY) MemoryAlloc ((MAX_MODEENTRYS + 1) * sizeof(MODEENTRY))))
    {
        DBG_PRINT0(DL_0, "\r\nAllocation of Registry Mode List Failed.");
        DBG_PRINT0(DL_0, "\r\nSetting up a default safe mode list.");
        lpML = SafeModeList;
    }

    // Zero out the memory
    lpC = (LPCHAR) lpML;
    for (i = 0; i < ((MAX_MODEENTRYS + 1) * sizeof(MODEENTRY)); i++)
        lpC[i] = 0;

    // Use the safe mode list settings initially
    GetSafeModeList(lpML);

    // Try to get the path in the registry to where the mode list is.
    if  (GetLocalPath (lpDispData, szRegPath) < 0)
    {
        GetSafeModeList(lpML);
        DBG_PRINT0(DL_0, "\r\nGetLocalRegistryPath failed. Returning safe mode list.");
        return  (lpML);
    }

    // Tack on "\\MODES" to the returned regpath
    dwMajorKey = * ((ULONG *) szRegPath);
    lstrcat (szRegPath + 4, "\\Modes");

    // Start off with the first mode
    nMode = 0;

    // Create a loop so we can extract the modes for each pixel depth
    for (pd = 0; pd < 4; pd++)
    {
        // Copy the path to ...DISPLAY\000X\MODES and then tack on
        // the correct pixel depth key
        lstrcpy (szPDPath, szRegPath + 4);

        switch  (pd)
        {
            case 0:
                lstrcat (szPDPath, "\\8");
                break;
            case 1:
                lstrcat (szPDPath, "\\16");
                break;
            case 2:
                lstrcat (szPDPath, "\\24");
                break;
            case 3:
                lstrcat (szPDPath, "\\32");
                break;
        }

        // We now have the key where the pixel depth specific modes are.
        // Go ahead and open the key.
        lRet = RegOpenKey (dwMajorKey, szPDPath, &hModeBppKey);

        if  (lRet != ERROR_SUCCESS)
        {
            // If we have trouble opening a Bpp key, that is OK, since
            // we might not support a particular pixel depth. Just go
            // on to the next one.
            continue;
        }

        // Enumerate the subkeys -- each key is a spatial resolution.
        // Within each key there is a "(default)" string which has a
        // list of refresh rates which looks like: "60,72,75,85"
        // If the key does not have a list of refresh rates, then
        // look at the same resolution in the next lower pixel depth
        // and use that its refresh rates. Finally, if there is no
        // lower color depth, then assume just a 60Hz refresh rate.
        for (dwSubKey = 0; TRUE; dwSubKey++)
        {
            lRet = RegEnumKey (hModeBppKey, dwSubKey, szRes, MAX_KEY_LEN);

            if  (lRet != ERROR_SUCCESS)
            {
                // If there was an error, it probably means that there are
                // no more subkeys -- i.e. resolutions for this pixel
                // depth. That's fine. Break out of the loop.
                break;
            }

            // Get the xres and yres from the key string.
            dwIndex = 0;
            ParseDecimalSeparator (szRes, &dwIndex, &dwXRes, ',', ',');
            ParseDecimalSeparator (szRes, &dwIndex, &dwYRes, 0, 0);

            // Build a full path to the resolution key so we can open it
            lstrcpy (szResPath, szPDPath);
            lstrcat (szResPath, "\\");
            lstrcat (szResPath, szRes);

            // OK, now open the spatial resolution key so that we can
            // get the list of refresh rates for this resolution.
            lRet = RegOpenKey (dwMajorKey, szResPath, &hModeResKey);

            if  (lRet == ERROR_SUCCESS)
            {
                // The refresh rate string which looks like "60,72,75"
                // or some such thing, does not have a tag name associated
                // with it, so I cannot just query a value -- there is no
                // name to query the value of!  Must enumerate the values.
                for (dwValue = 0; TRUE; dwValue++)
                {
                    dwValueNameSize = MAX_KEY_LEN;
                    dwSize = MAX_KEY_LEN;
                    lRet = RegEnumValue (hModeResKey, dwValue, szValueName,
                                        &dwValueNameSize, NULL, NULL,
                                        szRefreshRate, &dwSize);


                    if  (lRet == ERROR_SUCCESS)
                    {
                        // We got back a key. Technically we should
                        // check to see if this is a valid refresh rate
                        // string, but we won't. We do a quick check
                        // here to see if the value name is NULL --
                        // that is the way MSoft stores it for some
                        // reason. The actual refresh rate string
                        // values will get pseudo-validated later in
                        // this routine.
                        if  ((dwValueNameSize == 0) &&
                             (szRefreshRate[0] != 0))
                        {
                            // Close the resolution key
                            RegCloseKey (hModeResKey);

                            nFlagRR = USE_REFRESH_RATES_FROM_STRING;
                            break;
                        }
                    }
                    else
                    {
                        // If we got an error, it is porbbaly because
                        // there are no more values to enumerate in the
                        // key. Unfortunately we didn't find a refresh
                        // rate string, so just close the key. The logic
                        // in the next section handles the error.
                        RegCloseKey (hModeResKey);
                        break;
                    }
                }
            }

            if  (lRet != ERROR_SUCCESS)
            {
                // Here's the thing. If either opening the resolution key
                // to query the refresh rate string, OR if the query of
                // the refresh rate string failed, we still have to come
                // up with a list of refresh rates somehow,
                // so check if we are looking for 8bpp modes.
                if  (pd == 0)
                {
                    // In 8bpp, there is no lower pixel depth so we
                    // have to assume a single value of 60Hz
                    nFlagRR = USE_60HZ;
                }
                else
                {
                    // We can make a good guess as to the refresh
                    // rates by using the ones for the same
                    // resolution mode in a lower pixel depth,
                    // if a lower pixel depth has the same
                    // resolution mode. IF not, use 60Hz.
                    nFlagRR = USE_REFRESH_RATES_FROM_LOWER;
                }
            }

            if  (nFlagRR == USE_REFRESH_RATES_FROM_STRING)
            {
                dwIndex = 0;

                // Generate a new mode for each refresh rate in the string
                while   (ParseDecimalSeparator (szRefreshRate,
                            &dwIndex, &(lpML[nMode].dwRefreshRate),
                            ',', 0))
                {
                    lpML[nMode].dwXRes = dwXRes;
                    lpML[nMode].dwYRes = dwYRes;
                    lpML[nMode].dwBpp  = (pd + 1) * 8;
                    if  (nMode < MAX_MODEENTRYS)
                        nMode++;
                }
            }

            if  (nFlagRR == USE_REFRESH_RATES_FROM_LOWER)
            {
                dwMatchIndex = FALSE;

                // Start with the pixel depth immediately below, but
                // if no matching res is found at that one, keep going.
                for (j = pd - 1; (((long) j) >= 0) && (!dwMatchIndex); j--)
                {
                    // Search through all modes already added to the table
                    for (i = 0; i < (ULONG) nMode; i++)
                    {
                        // Matching xres, yres, and prior pixel depth
                        // is a hit!
                        if  ((dwXRes == lpML[i].dwXRes) &&
                             (dwYRes == lpML[i].dwYRes) &&
                             (((j + 1) * 8) == lpML[i].dwBpp))
                        {
                            // Grab the prior mode, and modify the bpp
                            lpML[nMode] = lpML[i];
                            lpML[nMode].dwBpp = (pd + 1) * 8;
                            if  (nMode < MAX_MODEENTRYS)
                                nMode++;
                            dwMatchIndex = TRUE;
                        }
                    }
                }

                if  (!dwMatchIndex)
                {
                    // If there wasn't a lower pixel depth with a
                    // matching resolution, then do a single 60Hz mode.
                    nFlagRR = USE_60HZ;
                }
            }

            if  (nFlagRR == USE_60HZ)
            {
                lpML[nMode].dwXRes = dwXRes;
                lpML[nMode].dwYRes = dwYRes;
                lpML[nMode].dwBpp  = (pd + 1) * 8;
                lpML[nMode].dwRefreshRate = 60;
                if  (nMode < MAX_MODEENTRYS)
                    nMode++;
            }
        }

        // Close this bpp key
        RegCloseKey (hModeBppKey);
    }

    // Only one thing. If we didn't find any modes, then use a safe list
    if  (nMode == 0)
    {
        GetSafeModeList(lpML);
        DBG_PRINT0(DL_0, "\r\nNo modes found. Returning safe mode list.");
        return  (lpML);
    }

    // Add all the non-desktop, low resolution modes.
    for (i = 0; sLowModes[i].dwXRes != 0; i++)
    {
        lpML[nMode] = sLowModes[i];
        if  (nMode < MAX_MODEENTRYS)
            nMode++;
    }

    return  (lpML);
}


/*
    FreeMasterModeList

    This routine is called when the caller is done with the mode
    list it got earlier.
*/
int CFUNC
FreeMasterModeList (LPMODEENTRY lpModeList)
{
    if  (lpModeList != SafeModeList)
    {
        DBG_PRINT0(DL_0, "\r\nCalling MemoryFree on lpModeList.");
        MemoryFree ((LPULONG) lpModeList);
    }

    return  (TRUE);
}


/*
    GetSafeModeList

    This routine just returns a few safe modes in the mode list.
    It always returns TRUE.
*/
int CFUNC GetSafeModeList (LPMODEENTRY lpModeList)
{
    int     i;

    for (i = 0; SafeModeList[i].dwXRes != 1; i++)
        lpModeList[i] = SafeModeList[i];

    return  (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\modeset.mhd\win9x\osapi.c ===
/*
    FILE:   osapi.c
    DATE:   4/8/99

    This file holds code for functions that are called back to by
    the generic modeset code.
*/

#include "cmntypes.h"
#include "modeext.h"
#include "modeset.h"
#include "mywin.h"
#include "regfuncs.h"
#include "debug.h"
#include "..\..\common\inc\nvreg.h"
#include "restime.h"
#include "osapi.h"
#include "utils.h"
#include "..\code\edid.h"
#include "..\code\gtfmath.h"
#include "..\code\dmt.h"

MODEENTRY   SafeModeList[] =
{
    { 640,  480, 8,  60 },
    { 800,  600, 8,  60 },
    { 1024, 768, 8,  60 },
    { 640,  480, 16, 60 },
    { 800,  600, 16, 60 },
    { 1024, 768, 16, 60 },
    { 640,  480, 32, 60 },
    { 800,  600, 32, 60 },
    { 1024, 768, 32, 60 },
    { 0,    0,   0,  0  },
    { 1,    0,   0,  0  }
};

MODEENTRY   sLowModes[] =
{
    { 320,  200, 8,  60 },
    { 320,  200, 8,  70 },
    { 320,  200, 8,  72 },
    { 320,  200, 8,  75 },
    { 320,  200, 8,  85 },
    { 320,  200, 8,  100 },
    { 320,  200, 8,  120 },
    { 320,  240, 8,  60 },
    { 320,  240, 8,  70 },
    { 320,  240, 8,  72 },
    { 320,  240, 8,  75 },
    { 320,  240, 8,  85 },
    { 320,  240, 8,  100 },
    { 320,  240, 8,  120 },
    { 400,  300, 8,  60 },
    { 400,  300, 8,  70 },
    { 400,  300, 8,  72 },
    { 400,  300, 8,  75 },
    { 400,  300, 8,  85 },
    { 400,  300, 8,  100 },
    { 400,  300, 8,  120 },
    { 480,  360, 8,  60 },
    { 480,  360, 8,  70 },
    { 480,  360, 8,  72 },
    { 480,  360, 8,  75 },
    { 480,  360, 8,  85 },
    { 480,  360, 8,  100 },
    { 480,  360, 8,  120 },
    { 512,  384, 8,  60 },
    { 512,  384, 8,  70 },
    { 512,  384, 8,  72 },
    { 512,  384, 8,  75 },
    { 512,  384, 8,  85 },
    { 512,  384, 8,  100 },
    { 640,  400, 8,  60 },
    { 640,  400, 8,  70 },
    { 640,  400, 8,  72 },
    { 640,  400, 8,  75 },
    { 640,  400, 8,  85 },
    { 640,  400, 8,  100 },
    { 640,  400, 8,  120 },
    { 320,  200, 16, 60 },
    { 320,  200, 16, 70 },
    { 320,  200, 16, 72 },
    { 320,  200, 16, 75 },
    { 320,  200, 16, 85 },
    { 320,  200, 16, 100 },
    { 320,  200, 16, 120 },
    { 320,  240, 16, 60 },
    { 320,  240, 16, 70 },
    { 320,  240, 16, 72 },
    { 320,  240, 16, 75 },
    { 320,  240, 16, 85 },
    { 320,  240, 16, 100 },
    { 320,  240, 16, 120 },
    { 400,  300, 16, 60 },
    { 400,  300, 16, 70 },
    { 400,  300, 16, 72 },
    { 400,  300, 16, 75 },
    { 400,  300, 16, 85 },
    { 400,  300, 16, 100 },
    { 400,  300, 16, 120 },
    { 480,  360, 16, 60 },
    { 480,  360, 16, 70 },
    { 480,  360, 16, 72 },
    { 480,  360, 16, 75 },
    { 480,  360, 16, 85 },
    { 480,  360, 16, 100 },
    { 480,  360, 16, 120 },
    { 512,  384, 16, 60 },
    { 512,  384, 16, 70 },
    { 512,  384, 16, 72 },
    { 512,  384, 16, 75 },
    { 512,  384, 16, 85 },
    { 512,  384, 16, 100 },
    { 640,  400, 16, 60 },
    { 640,  400, 16, 70 },
    { 640,  400, 16, 72 },
    { 640,  400, 16, 75 },
    { 640,  400, 16, 85 },
    { 640,  400, 16, 100 },
    { 640,  400, 16, 120 },
    { 320,  200, 32, 60 },
    { 320,  200, 32, 70 },
    { 320,  200, 32, 72 },
    { 320,  200, 32, 75 },
    { 320,  200, 32, 85 },
    { 320,  200, 32, 100 },
    { 320,  200, 32, 120 },
    { 320,  240, 32, 60 },
    { 320,  240, 32, 70 },
    { 320,  240, 32, 72 },
    { 320,  240, 32, 75 },
    { 320,  240, 32, 85 },
    { 320,  240, 32, 100 },
    { 320,  240, 32, 120 },
    { 400,  300, 32, 60 },
    { 400,  300, 32, 70 },
    { 400,  300, 32, 72 },
    { 400,  300, 32, 75 },
    { 400,  300, 32, 85 },
    { 400,  300, 32, 100 },
    { 400,  300, 32, 120 },
    { 480,  360, 32, 60 },
    { 480,  360, 32, 70 },
    { 480,  360, 32, 72 },
    { 480,  360, 32, 75 },
    { 480,  360, 32, 85 },
    { 480,  360, 32, 100 },
    { 480,  360, 32, 120 },
    { 512,  384, 32, 60 },
    { 512,  384, 32, 70 },
    { 512,  384, 32, 72 },
    { 512,  384, 32, 75 },
    { 512,  384, 32, 85 },
    { 512,  384, 32, 100 },
    { 640,  400, 32, 60 },
    { 640,  400, 32, 70 },
    { 640,  400, 32, 72 },
    { 640,  400, 32, 75 },
    { 640,  400, 32, 85 },
    { 640,  400, 32, 100 },
    { 640,  400, 32, 120 },
    { 720,  480, 16, 60 },
    { 720,  480, 16, 75 },
    { 720,  480, 16, 85 },
    { 720,  480, 32, 60 },
    { 720,  480, 32, 75 },
    { 720,  480, 32, 85 },
    { 720,  576, 16, 60 },
    { 720,  576, 16, 75 },
    { 720,  576, 16, 85 },
    { 720,  576, 32, 60 },
    { 720,  576, 32, 75 },
    { 720,  576, 32, 85 },
    { 960,  720, 8,  60 },
    { 960,  720, 8,  70 },
    { 960,  720, 8,  72 },
    { 960,  720, 8,  75 },
    { 960,  720, 8,  85 },
    { 960,  720, 8,  100 },
    { 960,  720, 8,  120 },
    { 960,  720, 8,  140 },
    { 960,  720, 8,  144 },
    { 960,  720, 8,  150 },
    { 960,  720, 8,  170 },
    { 960,  720, 8,  200 },
    { 960,  720, 8,  240 },
    { 960,  720, 16, 60 },
    { 960,  720, 16, 70 },
    { 960,  720, 16, 72 },
    { 960,  720, 16, 75 },
    { 960,  720, 16, 85 },
    { 960,  720, 16, 100 },
    { 960,  720, 16, 120 },
    { 960,  720, 16, 140 },
    { 960,  720, 16, 144 },
    { 960,  720, 16, 150 },
    { 960,  720, 16, 170 },
    { 960,  720, 16, 200 },
    { 960,  720, 16, 240 },
    { 960,  720, 32, 60 },
    { 960,  720, 32, 70 },
    { 960,  720, 32, 72 },
    { 960,  720, 32, 75 },
    { 960,  720, 32, 85 },
    { 960,  720, 32, 100 },
    { 960,  720, 32, 120 },
    { 960,  720, 32, 140 },
    { 960,  720, 32, 144 },
    { 960,  720, 32, 150 },
    { 960,  720, 32, 170 },
    { 960,  720, 32, 200 },
    { 960,  720, 32, 240 },
    { 0,    0,   0,  0  },
};

#define USE_60HZ                        0x00
#define USE_REFRESH_RATES_FROM_LOWER    0x01
#define USE_REFRESH_RATES_FROM_STRING   0x02

// Just in cae we can't GlobalAlloc a list, we have a single entry one
// we can use here.
RESTIME     sRTList;

extern int CFUNC GetSafeModeList (LPMODEENTRY lpModeList);


/*
    GetModeListFromRegistry

    This routine extracts the mode list for the board requested
    from the registry. This routine will always return some mode
    list.  If it can't find the board requested a safe mode list
    is returned.
*/
LPMODEENTRY CFUNC
GetModeListFromRegistry (LPDISPDATA lpDispData)
{
    ULONG       i, j, pd, dwIndex, dwXRes, dwYRes;
    ULONG       hModeBppKey, hModeResKey, dwSize, dwMatchIndex;
    ULONG       dwSubKey, dwValue;
    ULONG       dwMajorKey;
    ULONG       dwValueNameSize;
    LPCHAR      lpC;
    int         nMode, nFlagRR;
    char        szValueName[MAX_KEY_LEN];
    char        szRegPath[MAX_KEY_LEN];
    char        szPDPath[MAX_KEY_LEN];
    char        szRes[MAX_KEY_LEN];
    char        szResPath[MAX_KEY_LEN];
    char        szRefreshRate[MAX_KEY_LEN];
    long        lRet;
    LPMODEENTRY lpML;

    DBG_PRINT0(DL_0, "\r\nEntering GetModeListFromRegistry.");

    // Next, grab the mode list from the registry
    if  (!(lpML = (LPMODEENTRY) MemoryAlloc ((MAX_MODEENTRYS + 1) * sizeof(MODEENTRY))))
    {
        DBG_PRINT0(DL_0, "\r\nAllocation of Registry Mode List Failed.");
        DBG_PRINT0(DL_0, "\r\nSetting up a default safe mode list.");
        lpML = SafeModeList;
        return  (lpML);
    }

    // Zero out the memory
    lpC = (LPCHAR) lpML;
    for (i = 0; i < ((MAX_MODEENTRYS + 1) * sizeof(MODEENTRY)); i++)
        lpC[i] = 0;

    // Use the safe mode list settings initially
    GetSafeModeList(lpML);

    // Try to get the path in the registry to where the mode list is.
    if  (GetLocalPath (lpDispData->lpBoardRegistryData, szRegPath) < 0)
    {
        GetSafeModeList(lpML);
        DBG_PRINT0(DL_0, "\r\nGetLocalRegistryPath failed. Returning safe mode list.");
        return  (lpML);
    }

    // Tack on "\\MODES" to the returned regpath
    dwMajorKey = lpDispData->lpBoardRegistryData->dwMainKey;
    lstrcat (szRegPath, "\\Modes");

    // Start off with the first mode
    nMode = 0;

    // Create a loop so we can extract the modes for each pixel depth
    for (pd = 0; pd < 4; pd++)
    {
        // Copy the path to ...DISPLAY\000X\MODES and then tack on
        // the correct pixel depth key
        lstrcpy (szPDPath, szRegPath);

        switch  (pd)
        {
            case 0:
                lstrcat (szPDPath, "\\8");
                break;
            case 1:
                lstrcat (szPDPath, "\\16");
                break;
            case 2:
                lstrcat (szPDPath, "\\24");
                break;
            case 3:
                lstrcat (szPDPath, "\\32");
                break;
        }

        // We now have the key where the pixel depth specific modes are.
        // Go ahead and open the key.
        lRet = RegOpenKey (dwMajorKey, szPDPath, &hModeBppKey);

        if  (lRet != ERROR_SUCCESS)
        {
            // If we have trouble opening a Bpp key, that is OK, since
            // we might not support a particular pixel depth. Just go
            // on to the next one.
            continue;
        }

        // Enumerate the subkeys -- each key is a spatial resolution.
        // Within each key there is a "(default)" string which has a
        // list of refresh rates which looks like: "60,72,75,85"
        // If the key does not have a list of refresh rates, then
        // look at the same resolution in the next lower pixel depth
        // and use that its refresh rates. Finally, if there is no
        // lower color depth, then assume just a 60Hz refresh rate.
        for (dwSubKey = 0; TRUE; dwSubKey++)
        {
            lRet = RegEnumKey (hModeBppKey, dwSubKey, szRes, MAX_KEY_LEN);

            if  (lRet != ERROR_SUCCESS)
            {
                // If there was an error, it probably means that there are
                // no more subkeys -- i.e. resolutions for this pixel
                // depth. That's fine. Break out of the loop.
                break;
            }

            // Get the xres and yres from the key string.
            dwIndex = 0;
            ParseDecimalSeparator (szRes, &dwIndex, &dwXRes, ',', ',');
            ParseDecimalSeparator (szRes, &dwIndex, &dwYRes, 0, 0);

            // Build a full path to the resolution key so we can open it
            lstrcpy (szResPath, szPDPath);
            lstrcat (szResPath, "\\");
            lstrcat (szResPath, szRes);

            // OK, now open the spatial resolution key so that we can
            // get the list of refresh rates for this resolution.
            lRet = RegOpenKey (dwMajorKey, szResPath, &hModeResKey);

            if  (lRet == ERROR_SUCCESS)
            {
                // The refresh rate string which looks like "60,72,75"
                // or some such thing, does not have a tag name associated
                // with it, so I cannot just query a value -- there is no
                // name to query the value of!  Must enumerate the values.
                for (dwValue = 0; TRUE; dwValue++)
                {
                    dwValueNameSize = MAX_KEY_LEN;
                    dwSize = MAX_KEY_LEN;
                    lRet = RegEnumValue (hModeResKey, dwValue, szValueName,
                                        &dwValueNameSize, NULL, NULL,
                                        szRefreshRate, &dwSize);


                    if  (lRet == ERROR_SUCCESS)
                    {
                        // We got back a key. Technically we should
                        // check to see if this is a valid refresh rate
                        // string, but we won't. We do a quick check
                        // here to see if the value name is NULL --
                        // that is the way MSoft stores it for some
                        // reason. The actual refresh rate string
                        // values will get pseudo-validated later in
                        // this routine.
                        if  ((dwValueNameSize == 0) &&
                             (szRefreshRate[0] != 0))
                        {
                            // Close the resolution key
                            RegCloseKey (hModeResKey);

                            nFlagRR = USE_REFRESH_RATES_FROM_STRING;
                            break;
                        }
                    }
                    else
                    {
                        // If we got an error, it is porbbaly because
                        // there are no more values to enumerate in the
                        // key. Unfortunately we didn't find a refresh
                        // rate string, so just close the key. The logic
                        // in the next section handles the error.
                        RegCloseKey (hModeResKey);
                        break;
                    }
                }
            }

            if  (lRet != ERROR_SUCCESS)
            {
                // Here's the thing. If either opening the resolution key
                // to query the refresh rate string, OR if the query of
                // the refresh rate string failed, we still have to come
                // up with a list of refresh rates somehow,
                // so check if we are looking for 8bpp modes.
                if  (pd == 0)
                {
                    // In 8bpp, there is no lower pixel depth so we
                    // have to assume a single value of 60Hz
                    nFlagRR = USE_60HZ;
                }
                else
                {
                    // We can make a good guess as to the refresh
                    // rates by using the ones for the same
                    // resolution mode in a lower pixel depth,
                    // if a lower pixel depth has the same
                    // resolution mode. IF not, use 60Hz.
                    nFlagRR = USE_REFRESH_RATES_FROM_LOWER;
                }
            }

            if  (nFlagRR == USE_REFRESH_RATES_FROM_STRING)
            {
                dwIndex = 0;

                // Generate a new mode for each refresh rate in the string
                while   (ParseDecimalSeparator (szRefreshRate,
                            &dwIndex, &(lpML[nMode].dwRefreshRate),
                            ',', 0))
                {
                    lpML[nMode].dwXRes = dwXRes;
                    lpML[nMode].dwYRes = dwYRes;
                    lpML[nMode].dwBpp  = (pd + 1) * 8;
                    if  (nMode < MAX_MODEENTRYS)
                        nMode++;
                }
            }

            if  (nFlagRR == USE_REFRESH_RATES_FROM_LOWER)
            {
                dwMatchIndex = FALSE;

                // Start with the pixel depth immediately below, but
                // if no matching res is found at that one, keep going.
                for (j = pd - 1; (((long) j) >= 0) && (!dwMatchIndex); j--)
                {
                    // Search through all modes already added to the table
                    for (i = 0; i < (ULONG) nMode; i++)
                    {
                        // Matching xres, yres, and prior pixel depth
                        // is a hit!
                        if  ((dwXRes == lpML[i].dwXRes) &&
                             (dwYRes == lpML[i].dwYRes) &&
                             (((j + 1) * 8) == lpML[i].dwBpp))
                        {
                            // Grab the prior mode, and modify the bpp
                            lpML[nMode] = lpML[i];
                            lpML[nMode].dwBpp = (pd + 1) * 8;
                            if  (nMode < MAX_MODEENTRYS)
                                nMode++;
                            dwMatchIndex = TRUE;
                        }
                    }
                }

                if  (!dwMatchIndex)
                {
                    // If there wasn't a lower pixel depth with a
                    // matching resolution, then do a single 60Hz mode.
                    nFlagRR = USE_60HZ;
                }
            }

            if  (nFlagRR == USE_60HZ)
            {
                lpML[nMode].dwXRes = dwXRes;
                lpML[nMode].dwYRes = dwYRes;
                lpML[nMode].dwBpp  = (pd + 1) * 8;
                lpML[nMode].dwRefreshRate = 60;
                if  (nMode < MAX_MODEENTRYS)
                    nMode++;
            }
        }

        // Close this bpp key
        RegCloseKey (hModeBppKey);
    }

    // Only one thing. If we didn't find any modes, then use a safe list
    if  (nMode == 0)
    {
        GetSafeModeList(lpML);
        DBG_PRINT0(DL_0, "\r\nNo modes found. Returning safe mode list.");
        return  (lpML);
    }

    return  (lpML);
}


/*
    GetMasterModeList

    This routine extracts the mode list for the board requested
    from the registry. This routine will always return some mode
    list.  If it can't find the board requested a safe mode list
    is returned.
*/
LPMODEENTRY CFUNC
GetMasterModeList (LPDISPDATA lpDispData)
{
    int         i, nLen;
    LPMODEENTRY lpML;

    DBG_PRINT0(DL_0, "\r\nEntering GetMasterModeList.");

    if(lpDispData->lpModeList != NULL)
        return  lpDispData->lpModeList;

    lpDispData->lpModeList = lpML = GetModeListFromRegistry (lpDispData);

    // Count the number of items in the list
    for (nLen = 0; nLen < MAX_MODEENTRYS; nLen++)
        if  (lpML[nLen].dwXRes == 0)
            break;

    // Add all the non-desktop, low resolution modes.
    for (i = 0; sLowModes[i].dwXRes != 0; i++)
    {
        lpML[nLen] = sLowModes[i];
        if  (nLen < MAX_MODEENTRYS)
            nLen++;
    }

    DBG_PRINT0(DL_0, "\r\nExiting GetMasterModeList.");
    return  (lpML);
}


/*
    FreeMasterModeList

    This routine is called when the caller is done with the mode
    list it got earlier.
*/
int CFUNC
FreeMasterModeListW9X (LPMODEENTRY lpModeList)
{
    if  (lpModeList != SafeModeList)
    {
        DBG_PRINT0(DL_0, "\r\nCalling MemoryFree on lpModeList.");
        MemoryFree ((LPULONG) lpModeList);
    }

    return  (TRUE);
}


/*
    GetSafeModeList

    This routine just returns a few safe modes in the mode list.
    It always returns TRUE.
*/
int CFUNC GetSafeModeList (LPMODEENTRY lpModeList)
{
    int     i;

    for (i = 0; SafeModeList[i].dwXRes != 1; i++)
        lpModeList[i] = SafeModeList[i];

    return  (TRUE);
}


/*
    GetMasterRTList

    This routine extracts the Restriction and Timing list for the
    device requested from the registry. nRTListLen is the length
    in RESTIME structures of the array pointed to by lpRTList.
*/
LPRESTIME CFUNC
GetMasterRTList (LPDISPDATA lpDispData)
{
    int         i;
    long        lRet;
    ULONG       dwSubKey;
    ULONG       dwSize, dwValueNameSize;
    ULONG       hRTKey;
    char        szItem[MAX_KEY_LEN];
    char        szRTString[MAX_KEY_LEN];
    LPRESTIME   lpRTList;

    DBG_PRINT0(DL_0, "\r\nEntering GetMasterRTList.");

    if(lpDispData->lpRTList != NULL)
        return  lpDispData->lpRTList;

    if  (!(lpRTList = (LPRESTIME) MemoryAlloc (MAX_RESTIMES * sizeof(RESTIME))))
    {
        DBG_PRINT0 (DL_0, "\r\nAllocation of Restriction And Timing List Failed.");
        DBG_PRINT0 (DL_0, "\r\nSetting up a default list with no restrictions.");
        lpRTList = &sRTList;

        // Use the dwXRes field in the first array element as a count
        // of the number of restriction list entries.
        lpRTList[0].dwXRes = 0;
        return  (lpRTList);
    }
    else
        lpDispData->lpRTList = lpRTList;

    // Use the dwXRes field in the first array element as a count
    // of the number of restriction list entries.
    lpRTList[0].dwXRes = 0;

    // First, find the path to the restriction and timing strings.
    if  (!(hRTKey = GetLocalNvidiaDisplaySubKey (lpDispData->lpBoardRegistryData)))
    {
        DBG_PRINT0(DL_0, "\r\nGetLocalDisplaySubKey failed. Returning empty RTList.");
        return  (lpRTList);
    }

    // Start enumerating and parsing the R&T strings.
    for (dwSubKey = 0; TRUE; dwSubKey++)
    {
        // Zero out the strings
        for (i = 0; i < MAX_KEY_LEN; i++)
        {
            szItem[i] = 0;
            szRTString[i] = 0;
        }

        dwValueNameSize = MAX_KEY_LEN;
        dwSize = MAX_KEY_LEN;
        lRet = RegEnumValue (hRTKey, dwSubKey, szItem,
                            &dwValueNameSize, NULL, NULL,
                            szRTString, &dwSize);

        // If there was an error, it probably means that there are
        // no more values to enumerate. That's fine. We are done.
        if  (lRet != ERROR_SUCCESS)
            break;

        // Is this subkey an R&T string? It is if it begins "R&T"
        if  ((szItem[0] == 'R') && (szItem[1] == '&') && (szItem[2] == 'T'))
        {
            // If the R&T string parses legitimately, include it in the list.
            if  (lpRTList[0].dwXRes < (MAX_RESTIMES - 1))
            {
                if  (ParseRTString (lpRTList + lpRTList[0].dwXRes + 1, szRTString))
                {
                    DBG_PRINT1(DL_0, "\r\nR&T string %s parsed fine.", (ULONG) szRTString);
                    lpRTList[0].dwXRes++;
                }
            }
        }
    }

    // Close the key
    RegCloseKey (hRTKey);

    return  (lpRTList);
}


/*
    FreeMasterRTList

    This routine is called when the caller is done with the RTList.
*/
int CFUNC
FreeMasterRTListW9X (LPRESTIME lpRTList)
{
    // The dwYRes field in the first array element is used as a flag
    // to indicate that the array was GlobalAlloced.
    if  (lpRTList != &sRTList)
    {
        DBG_PRINT0(DL_0, "\r\nCalling MemoryFree on RTList.");
        MemoryFree ((LPULONG) lpRTList);
    }

    return  (TRUE);
}

/*
    FreeMasterLists

    This routine is called from Display driver when the CRTC context is destroying.
*/
int WINAPI
FreeMasterLists ( LPDISPDATA lpDispData )
{
    if(lpDispData->lpRTList)
    {
        FreeMasterRTListW9X (lpDispData->lpRTList);
        lpDispData->lpRTList = NULL;
    }

    if(lpDispData->lpModeList)
    {
        FreeMasterModeListW9X (lpDispData->lpModeList);
        lpDispData->lpModeList = NULL;
    }
    return  (TRUE);
}


/*
    FreeMasterModeList

    This routine is called when the caller is done with the ModeList.
*/
int CFUNC
FreeMasterModeList (LPMODEENTRY lpModeList)
{
    return  (TRUE);
}


/*
    FreeMasterRTList

    This routine is called when the caller is done with the RTList.
*/
int CFUNC
FreeMasterRTList (LPRESTIME lpRTList)
{
    return  (TRUE);
}

/*
    GetTimingStandardOverride

    This routine gets any timing standard override for the board,
    logical device, and output device specified.
    It should return one of the constants defined in
    restime.h like DMTV_ID. A timing standard override is a
    timing standard that applies to all modes. Just something
    that the user might want to enforce.
*/
ULONG CFUNC
GetTimingStandardOverride (LPDISPDATA lpDispData)
{
    char    szVal[32];

    if (GetLocalNvidiaDisplayDevRegString (lpDispData->lpBoardRegistryData,
        (LPDEVDATA) lpDispData->lpDevData, NV4_REG_DRV_MONITOR_TIMING, szVal))
    {
        if  (!lstrcmpi(szVal, NV4_REG_DRV_MONITOR_TIMING_DMT))
            return  (DMTV_ID);

        if  (!lstrcmpi(szVal, NV4_REG_DRV_MONITOR_TIMING_GTF))
            return  (GTFV_ID);
    }

    return  (NONE_ID);
}


/*
    Function:   GetPitchAndSize

    Purpose:    This routine returns the pitch for a given mode.

    Arguments:  lpDispData  - identifies the specific board that we
                              want the active display port for.
                dwXRes      - The X res in pixels for the mode
                              should be returned.
                dwBpp       - the bits per pixel for the mode

    Returns:    The pitch in bytes
*/
typedef ULONG   (__far __pascal *LPFNGETMODESIZE) (PVOID, PVOID, ULONG, ULONG, ULONG, ULONG *, ULONG *);

ULONG CFUNC
GetPitchAndSize (LPDISPDATA lpDispData, ULONG dwXRes, ULONG dwYRes, ULONG dwBpp, ULONG *pdwPitch, ULONG *pdwSize)
{
    LPFNGETMODESIZE lpfnGetModeSize;

    lpfnGetModeSize = (LPFNGETMODESIZE) lpDispData->lpfnGetModeSize;
    return  ((*lpfnGetModeSize) (lpDispData->dwContext1, lpDispData->dwContext2, dwXRes, dwYRes, dwBpp, pdwPitch, pdwSize));
}


/*
    Function:   GetMonitorInfRangeLimits

    Purpose:    This routine reads the "MaxResolution" key in the
                active monitor node in the registry to get the
                maximum resolution the monitor can do. It uses
                the maximum resolution itself (like "1600,1200")
                as another subkey under which is typically a
                monitor range limits string which looks like
                "30-95,60-120,-,+" where the first range is
                the horizontal limits inKHz and the second is
                the vertical range in hertz. The last two characters
                are horizontal and vertical sync polarities.
                This range limits string doesn't always exist.

    Arguments:
                lpDispData  - identifies the specific board that we
                              want the active display port for.
                lpML        - ptr to a monitor limits structure
                              that will be filled in with range
                              limits obtained or computed from
                              values stuffed in the registry
                              by the moitor .inf file.
                lpdwXRes    - ptr to a variable that will be set
                              to the maximum X-resolution found
                              for this monitor.
                lpdwYRes    - ptr to a variable that will be set
                              to the maximum Y-resolution found
                              for this monitor.

    Returns:    TRUE    then lpML, lpdwXRes, and lpdwYRes have been
                        filled in correctly.
                FALSE   then there was an error getting some value.
*/
int CFUNC
GetMonitorInfRangeLimits (
    LPDISPDATA      lpDispData,
    LPMONITORLIMITS lpML,
    ULONG           *lpdwXRes,
    ULONG           *lpdwYRes)
{
    ULONG   i;
    char    szMaxResolution[10];
    ULONG   hMonitor, lRet;
    ULONG   dwSize;
    ULONG   dwHorizMin;
    ULONG   dwHorizMax;
    ULONG   dwVertMin;
    ULONG   dwVertMax;
    char    szBuffer[MAX_KEY_LEN];
    GTFIN   GTFIn;
    GTFOUT  GTFOut;

    // First zero out monitor limits structure.
    lpML->dwMinHorz = 0;
    lpML->dwMaxHorz = 0;
    lpML->dwMinVert = 0;
    lpML->dwMaxVert = 0;
    lpML->dwMaxPixelClock = 0;

    szMaxResolution[0] = 0;
    if  (!GetMonitorLocalRegString (lpDispData->lpMonitorRegistryData,
                                "MaxResolution", szMaxResolution))
        return  (FALSE);

    // If no string was returned from RegQueryEx, just return 60Hz.
    if (!szMaxResolution[0])
        return (FALSE);

    // Now convert the strings to numbers.
    i = 0;
    *lpdwXRes = 0;
    *lpdwYRes = 0;
    ParseDecimalSeparator (szMaxResolution, &i, lpdwXRes, ',', ',');
    ParseDecimalSeparator (szMaxResolution, &i, lpdwYRes, 0, 0);

    // Create path for MODES subkey.
    lstrcpy (szBuffer, lpDispData->lpMonitorRegistryData->szRegPath);
    lstrcat (szBuffer, "\\MODES");
    lstrcat (szBuffer, "\\");
    lstrcat (szBuffer, szMaxResolution);
    lRet = RegOpenKey (lpDispData->lpMonitorRegistryData->dwMainKey, szBuffer, &hMonitor);
    if  (lRet != ERROR_SUCCESS)
        return  (FALSE);

    szBuffer[0] = 0;
    dwSize = MAX_KEY_LEN;
    RegQueryValueEx (hMonitor, "Mode1", NULL, NULL,
                         szBuffer, (ULONG FAR *) &dwSize);

    RegCloseKey (hMonitor);

    // If no string was returned from RegQueryEx, just return 60Hz.
    if (!szBuffer[0])
        return (FALSE);

    // Now convert the strings to numbers. Be careful here because some
    // INF range limits are in the form xx.x-yy.y (a range) while others
    // are of the form xx.x (fixed frequency). For fixed frequency, set
    // max horizontal and max vertical to the same value as the minimums.
    i = 0;
    ParseDecimalNumberAndFractionAndSeparator (szBuffer, &i, &dwHorizMin, '-', ',');
    if (i > 0)
    {
        if (szBuffer[i - 1] == ',')
            dwHorizMax = dwHorizMin;
        else
            ParseDecimalNumberAndFractionAndSeparator (szBuffer, &i, &dwHorizMax, ',', ',');
    }
    ParseDecimalNumberAndFractionAndSeparator (szBuffer, &i, &dwVertMin, '-', ',');
    if (i > 0)
    {
        if (szBuffer[i - 1] == ',')
            dwVertMax = dwVertMin;
        else
            ParseDecimalNumberAndFractionAndSeparator (szBuffer, &i, &dwVertMax, ',', ',');
    }

    // Change horizontals from KHz to Hz.
    dwHorizMin = Multiply32By32(dwHorizMin, 1000);
    dwHorizMax = Multiply32By32(dwHorizMax, 1000);

    lpML->dwMinHorz = dwHorizMin;
    lpML->dwMaxHorz = dwHorizMax;
    lpML->dwMinVert = dwVertMin;
    lpML->dwMaxVert = dwVertMax;

    // Find a pixel clock limit.
    GTFIn.dwHPixels      = *lpdwXRes;
    GTFIn.dwVLines       = *lpdwYRes;
    GTFIn.dwMarginsRqd   = FALSE;
    GTFIn.dwIntRqd       = FALSE;
    GTFIn.dwIPParmType   = IPTYPE_VERTICAL_REFRESH_RATE;
    GTFIn.dwIPFreqRqd    = lpML->dwMaxVert;

    // Get the timing parameters.
    ComputeGTFParameters(&GTFIn, &GTFOut);
    lpML->dwMaxPixelClock = Multiply32By32(GTFOut.dwPixelClockIn10KHertz, 10000);

    // Make sure there's at least some kind of pixel clock. The fallback
    // pixel clock being used is the pixel clock for DMT 640x480@60Hz.
    if (lpML->dwMaxPixelClock == 0)
        lpML->dwMaxPixelClock = 25180000;

    return  (TRUE);
}


/*
    Function:   GetMonitorLimitMode

    Purpose:    This routine gets the mode which should be an
                upper bound for a monitor which has no edid and
                no .inf.

    Arguments:  lpDispData  - identifies the specific board that we
                              want the active display port for.
                lpModeInfo  - ptr to a place to store the limit mode

    Returns:    If this routine returns TRUE, then lpModeInfo was
                filled in with the limit mode. If this routine
                returns FALSE, then there is no limit mode.
*/
int CFUNC
GetMonitorLimitMode (LPDISPDATA lpDispData, LPMODEINFO lpModeInfo)
{
    return  (GrabModeInfoString (lpDispData->lpBoardRegistryData,
                0x0FFFFFFFF, NULL,
                NV4_REG_DRV_MONITOR_LIMIT_MODE, lpModeInfo, 0));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\modeset.mhd\win9x\MYWIN.H ===
/*
    FILE:   mywin.h
    DATE:   4/8/99

    This file has some things in it that are in windows.h, but I
    don't want to include windows.h because it just makes a mess.
*/

// A few constants
#define TRUE    1
#define FALSE   0
#define NULL    0

// These are constants for the registry functions
#define MAX_KEY_LEN             0x200
#define HKEY_CLASSES_ROOT       0x80000000
#define HKEY_CURRENT_USER       0x80000001
#define HKEY_LOCAL_MACHINE      0x80000002
#define HKEY_USERS              0x80000003
#define HKEY_PERFORMANCE_DATA   0x80000004
#define HKEY_CURRENT_CONFIG     0x80000005
#define HKEY_DYN_DATA           0x80000006
#define ERROR_SUCCESS           0x00

// This is for memory allocation
#define GMEM_SHARED 0x2000

// A few more constants
#define DLL_PROCESS_DETACH 0
#define DLL_PROCESS_ATTACH 1
#define DLL_THREAD_ATTACH  2
#define DLL_THREAD_DETACH  3

// Handle the WIN16, WIN32 difference as seemlessly as possible.
#ifdef  _WIN32
#define FAR
#define CFUNC   __cdecl
#define WINAPI  _stdcall
#else
#define FAR     __far
#define CFUNC   __cdecl  _loadds
#define WINAPI  _far _pascal  _loadds
#endif

// A few basic types
typedef unsigned char   UCHAR;
typedef unsigned short  USHORT;
typedef unsigned long   ULONG;
typedef UCHAR  FAR *    LPCHAR;
typedef USHORT FAR *    LPUSHORT;
typedef ULONG  FAR *    LPULONG;

// A few Windows functions that we need.
#ifdef _WIN32
#define RegOpenKey      RegOpenKeyA
#define RegEnumKey      RegEnumKeyA
#define RegEnumValue    RegEnumValueA
#define RegDeleteValue  RegDeleteValueA
#define RegQueryValueEx RegQueryValueExA
#define RegSetValueEx   RegSetValueExA
#define RegCreateKey    RegCreateKeyA
#define wsprintf  wsprintfA
#define OutputDebugString OutputDebugStringA
extern int    CFUNC  wsprintf(LPSTR, LPCSTR, ...);
#else
extern int    CFUNC  wsprintf();
#endif

#define REG_NONE        0x000000000
#define REG_SZ          0x000000001
#define REG_EXPAND_SZ   0x000000002
#define REG_BINARY      0x000000003
#define REG_DWORD       0x000000004

extern int    WINAPI GlobalAlloc (int nflags, ULONG dwSize);
extern void   WINAPI GlobalUnlock (int hMem);
extern void   WINAPI GlobalFree (int hMem);
extern int    WINAPI GlobalHandle (USHORT wSelector);
extern LPCHAR WINAPI GlobalLock (int hMem);
extern void   WINAPI OutputDebugString(LPCHAR lpStr);
extern long   WINAPI RegOpenKey   (ULONG hKey, LPCHAR lpName, LPULONG lphKey);
extern long   WINAPI RegCreateKey (ULONG hKey, LPCHAR lpName, LPULONG lphKey);
extern long   WINAPI RegCloseKey (ULONG hEnumCMEnumKey);
extern long   WINAPI RegEnumKey (ULONG hEnumCMEnumKey, ULONG dwSubKey,
                                LPCHAR szItem, ULONG dwLen);
extern long   WINAPI RegEnumValue (ULONG hEnumCMEnumKey, ULONG dwValueIndex,
                                LPCHAR lpValueName, LPULONG dwValueNameSize,
                                LPULONG lpReserved, LPULONG lpType,
                                LPCHAR lpData, LPULONG lpDataSize);
extern long   WINAPI RegQueryValueEx (ULONG hKey, LPCHAR lpValue,
                                LPULONG lpRes, LPULONG lpType,
                                LPCHAR lpBuf,  LPULONG lpSize);
extern long   WINAPI RegSetValueEx (ULONG hKey, LPCHAR lpValue,
                                LPULONG lpRes, ULONG dwType,
                                LPCHAR lpBuf,  ULONG dwSize);
extern long   WINAPI RegDeleteValue (ULONG hKey, LPCHAR lpValue);
extern LPCHAR WINAPI lstrcat (LPCHAR lpDst, LPCHAR lpSrc);
extern LPCHAR WINAPI lstrcpy (LPCHAR lpDst, LPCHAR lpSrc);
extern ULONG  WINAPI lstrlen (LPCHAR lpDst);
extern ULONG  WINAPI lstrcmpi (LPCHAR lpDst, LPCHAR lpSrc);

// A little bit of debugging support.
#ifdef DEBUG
extern  char szTemp[512];
#define DBG_PRINTF(x)       OutputDebugString((LPCHAR) (x))
#define DBG_PRINT_1DEC(x,y) {   wsprintf (szTemp, (x), (y));   \
                                OutputDebugString (szTemp);    \
                            }
#else
#define DBG_PRINTF(x)
#define DBG_PRINT_1DEC(x,y)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\modeset.mhd\win9x\OSMODE.C ===
/*
    FILE:   osmode.c
    DATE:   4/8/99

    This file has os-specific entry points for the modeset DLLs.
*/

#include "cmntypes.h"
#include "mywin.h"
#include "debug.h"

// 16bit Windows DLLs screw up if there is not at least one piece of
// data in the data segment. This is just to make sure there is one.
int     dummy;


/*
    DllEntryPoint

    Purpose:    This function is called by the OS when the 16bit Dll
                loads. We don't need to do anything in this routine
                right now. It is just a stub function.

    Arguments:  OS defined arguments.
                dwReason    -
                hInstance   - The module handle
                wDS         - Data segment for this module
                wHeapSize   - Size specified in the .def file for the heap
                dwReserved1 - not used
                wReserved2  - not used

    Returns:    Always return TRUE
*/
int WINAPI __export DllEntryPoint
(
    ULONG   dwReason,
    USHORT  hInstance,
    USHORT  wDS,
    USHORT  wHeapSize,
    ULONG   dwReserved1,
    USHORT  wReserved2
)
{
    DBG_PRINT0(DL_0, "\r\nDllEntryPoint for 16bit ModeSet DLL called -- Dll Loaded.");
    return  (TRUE);
}


/*
    WEP

    Purpose:    This function is called by the OS when the 16bit Dll
                unloads. We don't need to do anything in this routine
                right now. It is just a stub function.

    Arguments:  OS defined arguments.
                nExitType   - why the Dll is unloading

    Returns:    Always return TRUE
*/
int WINAPI WEP(int nExitType)
{
    DBG_PRINT0(DL_0, "\r\nWEP for 16bit ModeSet DLL called -- Dll Unloaded.");
	return	(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\modeset.mhd\win9x\panel.c ===
/*
    FILE:   panel.c
    DATE:   5/3/00

    This file holds code to support the control panel by writing
    the registry for the given board.
*/

#include "cmntypes.h"
#include "modeext.h"
#include "modeset.h"
#include "mywin.h"
#include "regfuncs.h"
#include "debug.h"
#include "..\..\common\inc\nvreg.h"
#include "..\..\common\win9x\inc\escape.h"
#include "restime.h"
#include "osapi.h"
#include "utils.h"
#include "..\code\edid.h"
#include "..\code\gtfmath.h"
#include "..\code\dmt.h"

typedef struct  _DESKTOP_STATE_DATA
{
    char    szName[8];
    int     nID;
}   DESKTOP_STATE_DATA;

DESKTOP_STATE_DATA  DesktopStateData[] =
{
    { NV4_REG_DRV_DESKTOP_STATE_NORMAL,     NVTWINVIEW_STATE_NORMAL },
    { NV4_REG_DRV_DESKTOP_STATE_MULTI_MON,  NVTWINVIEW_STATE_MULTIMON },
    { NV4_REG_DRV_DESKTOP_STATE_CLONE,      NVTWINVIEW_STATE_CLONE },
    { "\0",                                 NVTWINVIEW_STATE_NORMAL }
};


/*
    Function:   SetVirtualDesktop

    Purpose:    This routine writes the registry key VirtualDesktop
                with a "1" if dwState is non-zero or deletes the key
                if dwState = 0.

    Arguments:  lpRegData   - identifies the specific board
                dwLogDevice - 0 based logical device number
                dwState     - If 1 -> enable the key
                              if 0 -> delete it

    Returns:    Always returns TRUE
*/
int WINAPI
SetVirtualDesktop (LPREGDATA lpRegData, ULONG dwLogDevice, ULONG dwState)
{
    DBG_PRINT0 (DL_0, "\r\nEntering SetVirtualDesktop.");

    if  (dwState)
        SetLocalNvidiaDisplayLogRegString (lpRegData, dwLogDevice,
                    NV4_REG_DRV_VIRTUALDESKTOP, NV4_REG_DRV_TRUE, 1);
    else
        DeleteLocalNvidiaDisplayLogRegEntry (lpRegData, dwLogDevice,
                    NV4_REG_DRV_VIRTUALDESKTOP);

    DBG_PRINT0 (DL_1, "\r\nExiting SetVirtualDesktop.");
    return  (TRUE);
}


/*
    Function:   GetVirtualDesktop

    Purpose:    This routine reads the registry key VirtualDesktop

    Arguments:  lpRegData   - identifies the specific board
                dwLogDevice - 0 based logical device number
                lpState     - pointer to variable for return value

    Returns:    Always returns TRUE
*/
int WINAPI
GetVirtualDesktop (LPREGDATA lpRegData, ULONG dwLogDevice, ULONG *lpState)
{
    DBG_PRINT0 (DL_0, "\r\nEntering GetVirtualDesktop.");

    lpState[0] = 0;
    GetLocalNvidiaDisplayLogRegString (lpRegData, dwLogDevice,
                        NV4_REG_DRV_VIRTUALDESKTOP, (LPCHAR) lpState);
    if  (lpState[0] == '1')
        *lpState = 1;
    else
        *lpState = 0;

    DBG_PRINT0 (DL_1, "\r\nExiting GetVirtualDesktop.");
    return  (TRUE);
}


/*
    Function:   SetDesktopState

    Purpose:    This routine writes the registry key DesktopState with
                the desired desktop state.

    Arguments:  lpRegData   - identifies the specific board
                dwState     -  0 -> NVTWINVIEW_STATE_NORMAL
                               1 -> NVTWINVIEW_STATE_MULTIMON
                               2 -> NVTWINVIEW_STATE_CLONE

    Returns:    Always returns TRUE
*/
int WINAPI
SetDesktopState (LPREGDATA lpRegData, ULONG dwState)
{
    DBG_PRINT0 (DL_0, "\r\nEntering SetDesktopState.");

    if  (dwState > NVTWINVIEW_STATE_CLONE)
        dwState = NVTWINVIEW_STATE_NORMAL;

    SetLocalNvidiaRegValue (lpRegData, NV4_REG_DRV_DESKTOPSTATE, (int) dwState);

    DBG_PRINT0 (DL_1, "\r\nExiting SetDesktopState.");
    return  (TRUE);
}


/*
    Function:   GetDesktopState

    Purpose:    This routine reads the registry key DesktopState

    Arguments:  lpRegData   - identifies the specific board that we
                              want the active display port for.
                lpState     - pointer to variable for return value

    Returns:    Always returns TRUE
*/
int WINAPI
GetDesktopState (LPREGDATA lpRegData, ULONG *lpState)
{

    DBG_PRINT0 (DL_0, "\r\nEntering GetDesktopState.");

    *lpState = GetLocalNvidiaRegValue (lpRegData, NV4_REG_DRV_DESKTOPSTATE, 0);

    DBG_PRINT0 (DL_1, "\r\nExiting GetDesktopState.");
    return  (TRUE);
}


/*
    Function:   SetAutoPanMode

    Purpose:    This routine writes the registry key AutoPanMode
                with the coordinates of the Top Left corner of the display
                if dwState = 1 (disable auto-panning: freeze origin)
                or deletes the key if dwState = 0 (enable auto-panning:
                unfreeze origin).

    Arguments:  lpRegData   - identifies the specific board
                dwState     - If 1 -> write the key
                              if 0 -> delete the key
                lpDevData   - LPDEVDATA
                dwLeft      - if dwState is TRUE, then the auto pan
                dwTop       - is locked at this rectangle.
                dwRight
                dwBottom

    Returns:    Always returns TRUE
*/
int WINAPI
SetAutoPanMode (LPREGDATA lpRegData, LPDEVDATA lpDevData, ULONG dwLeft,
                ULONG dwTop, ULONG dwRight, ULONG dwBottom, ULONG dwState)
{
    char    szTemp[256];

    DBG_PRINT0 (DL_0, "\r\nEntering SetAutoPanMode.");

    if  (dwState)
    {
        wsprintf (szTemp, "%ld,%ld,%ld,%ld", dwLeft, dwTop, dwRight, dwBottom);
        SetLocalNvidiaDisplayDevRegString (lpRegData, lpDevData,
                                    NV4_REG_DRV_AUTOPANMODE, szTemp, 1);
    }
    else
        DeleteLocalNvidiaDisplayDevRegEntry (lpRegData, lpDevData,
                                            NV4_REG_DRV_AUTOPANMODE);

    DBG_PRINT0 (DL_1, "\r\nExiting SetAutoPanMode.");
    return  (TRUE);
}


/*
    Function:   GetAutoPanMode

    Purpose:    This routine reads the registry key AutoPanMode

    Arguments:  lpRegData   - identifies the specific board that we
                lpDevData   - LPDEVDATA
                lpState     - pointer to variable for return value
                lpLeft      - if the autopan key exists dwState is TRUE, then the auto pan
                lpTop       - is locked at this rectangle.
                lpRight
                lpBottom

    Returns:    Always returns TRUE
*/
int WINAPI
GetAutoPanMode (LPREGDATA lpRegData, LPDEVDATA lpDevData, ULONG *lpLeft,
                ULONG *lpTop, ULONG *lpRight, ULONG *lpBottom)
{
    char    szTemp[256];
    ULONG   dwIndex;

    DBG_PRINT0 (DL_0, "\r\nEntering GetAutoPanMode.");

    szTemp[0] = 0;
    GetLocalNvidiaDisplayDevRegString (lpRegData, lpDevData,
                                        NV4_REG_DRV_AUTOPANMODE, szTemp);

    if (szTemp[0] != 0)
    {
        dwIndex = 0;
        ParseDecimalSeparator (szTemp, &dwIndex, lpLeft, ',', ',');
        ParseDecimalSeparator (szTemp, &dwIndex, lpTop, ',', ',');
        ParseDecimalSeparator (szTemp, &dwIndex, lpRight, ',', ',');
        ParseDecimalSeparator (szTemp, &dwIndex, lpBottom, 0, 0);
    }
    else
        return (FALSE);

    DBG_PRINT0 (DL_1, "\r\nExiting GetAutoPanMode.");
    return  (TRUE);
}


/*
    Function:   SetTimingOverride

    Purpose:    This routine writes the registry key MonitorTiming
                or deletes the key if dwState = 0 (AUTO).

    Arguments:  lpRegData   - identifies the specific board
                lpDevData   - LPDEVDATA
                dwState     - If 0 -> Delete the key (AUTO)
                dwState     - If 1 -> DMT
                              if 2 -> GTF

    Returns:    Always returns TRUE
*/
int WINAPI
SetTimingOverride (LPREGDATA lpRegData, LPDEVDATA lpDevData, ULONG dwState)
{
    char    szTemp[256];

    DBG_PRINT0 (DL_0, "\r\nEntering SetTimingOverride.");

    if (dwState == 1)
    {
        wsprintf (szTemp, "DMT");
        SetLocalNvidiaDisplayDevRegString (lpRegData, lpDevData,
                                NV4_REG_DRV_MONITOR_TIMING, szTemp, 1);
    }
    else if (dwState == 2)
    {
        wsprintf (szTemp, "GTF");
        SetLocalNvidiaDisplayDevRegString (lpRegData, lpDevData,
                                NV4_REG_DRV_MONITOR_TIMING, szTemp, 1);
    }
    else
        DeleteLocalNvidiaDisplayDevRegEntry (lpRegData, lpDevData,
                                NV4_REG_DRV_MONITOR_TIMING);

    DBG_PRINT0 (DL_1, "\r\nExiting SetTimingOverride.");
    return  (TRUE);
}


/*
    Function:   GetTimingOverride

    Purpose:    This routine reads the registry key MonitorTiming

    Arguments:  lpRegData   - identifies the specific board that we
                              want the active display port for.
                lpDevData   - LPDEVDATA
                lpState     - pointer to variable for return value

    Returns:    Always returns TRUE
*/
int WINAPI
GetTimingOverride (LPREGDATA lpRegData, LPDEVDATA lpDevData, ULONG *lpState)
{
    char    szTemp[256];

    DBG_PRINT0 (DL_0, "\r\nEntering GetTimingOverride.");

    szTemp[0] = 0;
    GetLocalNvidiaDisplayDevRegString (lpRegData, lpDevData,
                            NV4_REG_DRV_MONITOR_TIMING, szTemp);

    if (szTemp[0] != 0)
    {
        if  (!lstrcmpi(szTemp, NV4_REG_DRV_MONITOR_TIMING_DMT))
            *lpState = 1;
        else if  (!lstrcmpi(szTemp, NV4_REG_DRV_MONITOR_TIMING_GTF))
            *lpState = 2;
        else
            *lpState = 0;
    }
    else
        return (FALSE);

    DBG_PRINT0 (DL_1, "\r\nExiting GetTimingOverride.");
    return  (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\modeset.mhd\win9x\REGFUNCS.C ===
 /*
    FILE:   regfuncs.c
    DATE:   4/8/99

    This file holds code to get certain things from the registry.
*/

#include "cmntypes.h"
#include "mywin.h"
#include "modeext.h"
#include "modeset.h"
#include "regfuncs.h"
#include "..\..\common\inc\nvreg.h"
#include "utils.h"
#include "debug.h"

extern  DEVICEANDTYPE   DeviceTypes[8];

/*
    GetLocalPath

    Purpose:    This routine extracts the local registry path
                from the lpRegData structure.

    Arguments:  lpRegData   LPREGDATA
                lpBuffer    Ptr to place to store registry path

    Returns:    The buffer is filled in with the
                registry path to ....\Display\000X

                Always returns TRUE.
*/
int CFUNC
GetLocalPath (LPREGDATA lpRegData, LPCHAR lpBuffer)
{
    lstrcpy (lpBuffer, lpRegData->szRegPath);
    return  (TRUE);
}


/*
    GetLocalNvidiaPath

    Purpose:    This routine extracts the local registry path
                from the RegData structure and tacks on the
                Nvidia substring.

    Arguments:  lpRegData   LPREGDATA
                lpBuffer    Ptr to place to store registry path

    Returns:    The buffer is filled in with the
                registry path to ....\Display\000X\Nvidia

                Always returns TRUE.
*/

int CFUNC
GetLocalNvidiaPath (LPREGDATA lpRegData, LPCHAR lpBuffer)
{
    // Get the local path
    GetLocalPath (lpRegData, lpBuffer);

    // Tack on Nvidia.
    lstrcat (lpBuffer, "\\NVidia");
    return  (TRUE);
}


/*
    GetLocalNvidiaDisplayPath

    Purpose:    This routine extracts the local registry path
                from the RegData structure and tacks on the
                Nvidia\Display string.

    Arguments:  lpRegData   LPREGDATA
                lpBuffer    Ptr to place to store registry path

    Returns:    The buffer is filled in with the
                registry path to ....\Display\000X\Nvidia\Display

                Always returns TRUE.
*/

int CFUNC
GetLocalNvidiaDisplayPath (LPREGDATA lpRegData, LPCHAR lpBuffer)
{
    // Get the local path
    GetLocalNvidiaPath (lpRegData, lpBuffer);

    // Tack on "Display"
    lstrcat (lpBuffer, "\\");
    lstrcat (lpBuffer, NV4_REG_DISPLAY_DRIVER_SUBKEY);
    return  (TRUE);
}


/*
    GetLocalNvidiaDisplayLogPath

    Purpose:    This routine extracts the local registry path
                from the RegData structure and tacks on the
                Nvidia\Display\LogDevice? string.

    Arguments:  lpRegData   LPREGDATA
                dwLogDevice 0 based logical device number
                lpBuffer    Ptr to place to store registry path

    Returns:    The buffer is filled in with the
                registry path to
                ....\Display\000X\Nvidia\Display\LogicalDevice?

                Always returns TRUE.
*/

int CFUNC
GetLocalNvidiaDisplayLogPath (LPREGDATA lpRegData, ULONG dwLogDevice,
                                LPCHAR lpBuffer)
{
    char    szTemp[32];

    // Get the local path
    GetLocalNvidiaDisplayPath (lpRegData, lpBuffer);

    // Tack on LogicalDevice? where ? is the logical device number
    wsprintf (szTemp, "\\LogicalDevice%ld", dwLogDevice);
    lstrcat (lpBuffer, szTemp);
    return  (TRUE);
}


/*
    GetLocalNvidiaDisplayDevPath

    Purpose:    This routine extracts the local registry path
                from the RegData structure and tacks on the
                Nvidia\Display\%DEV#% string.

    Arguments:  lpRegData    LPREGDATA
                dwLogDevice  0 based logical device number
                lpDevData    LPDEVDATA
                lpBuffer     Ptr to place to store registry path

    Returns:    The buffer is filled in with the
                registry path to
                ..\Display\000X\Nvidia\Display\%DEV#%

                Always returns TRUE.
*/

int CFUNC
GetLocalNvidiaDisplayDevPath (LPREGDATA lpRegData, LPDEVDATA lpDevData,
                                    LPCHAR lpBuffer)
{
    char    szTemp[12];

    // Get the local path
    GetLocalNvidiaDisplayPath (lpRegData, lpBuffer);

    // Tack on PhysicalDevice? where ? is the physical device number
    wsprintf (szTemp, "\\%s%d", DeviceTypes[lpDevData->cType].lpszName,
                                lpDevData->cNumber);
    lstrcat (lpBuffer, szTemp);
    return  (TRUE);
}


/*
    GetLocalSubKey

    Purpose:    This routine gets the local subkey which is
                ....Display\000X

    Arguments:  lpRegData   LPREGDATA

    Returns:    The registry key to ....\Display\000X
                NULL if there was an error.
*/
ULONG CFUNC
GetLocalSubKey (LPREGDATA lpRegData)
{
    char    szBuffer[MAX_KEY_LEN];
    ULONG   hDisplay, lRet;

    // Get local path and concatenate NVidia to form the local base path
    GetLocalPath (lpRegData, szBuffer);

    // Open this key
    lRet = RegCreateKey (lpRegData->dwMainKey, szBuffer, &hDisplay);
    if  (lRet != ERROR_SUCCESS)
        return  (FALSE);

    return  (hDisplay);
}


/*
    GetLocalNvidiaSubKey

    Purpose:    This routine gets the local subkey which is
                ....Display\000X\Nvidia.

    Arguments:  lpRegData   LPREGDATA

    Returns:    The registry key to ....\Display\000X\Nvidia.
                NULL if there was an error.
*/
ULONG CFUNC
GetLocalNvidiaSubKey (LPREGDATA lpRegData)
{
    char    szBuffer[MAX_KEY_LEN];
    ULONG   hDisplay, lRet;

    // Get local path and concatenate NVidia to form the local base path
    GetLocalNvidiaPath (lpRegData, szBuffer);

    // Open this key
    lRet = RegCreateKey (lpRegData->dwMainKey, szBuffer, &hDisplay);
    if  (lRet != ERROR_SUCCESS)
        return  (FALSE);

    return  (hDisplay);
}


/*
    GetLocalNvidiaDisplaySubKey

    Purpose:    This routine gets the local subkey which is
                ....Display\000X\Nvidia\Display.

    Arguments:  lpRegData   LPREGDATA

    Returns:    The registry key to ....\Display\000X\Nvidia\Display
                NULL if there was an error.
*/
ULONG CFUNC
GetLocalNvidiaDisplaySubKey (LPREGDATA lpRegData)
{
    char    szBuffer[MAX_KEY_LEN];
    ULONG   hDisplay, lRet;

    // Get local path and concatenate NVidia/Display
    GetLocalNvidiaDisplayPath (lpRegData, szBuffer);

    // Open this key
    lRet = RegCreateKey (lpRegData->dwMainKey, szBuffer, &hDisplay);
    if  (lRet != ERROR_SUCCESS)
        return  (FALSE);

    return  (hDisplay);
}


/*
    GetLocalNvidiaDisplayLogSubKey

    Purpose:    This routine gets the local subkey which is
                ....Display\000X\Nvidia\Display\LogicalDevice?

    Arguments:  lpRegData   LPREGDATA
                dwLogDevice 0 based logical device number

    Returns:    The registry key to
                ..\Display\000X\Nvidia\Display\LogicalDevice?
                NULL if there was an error.
*/
ULONG CFUNC
GetLocalNvidiaDisplayLogSubKey (LPREGDATA lpRegData, ULONG dwLogDevice)
{
    char    szBuffer[MAX_KEY_LEN];
    ULONG   hDisplay, lRet;

    // Get local path and concatenate NVidia to form the local base path
    GetLocalNvidiaDisplayLogPath (lpRegData, dwLogDevice, szBuffer);

    // Open this key
    lRet = RegCreateKey (lpRegData->dwMainKey, szBuffer, &hDisplay);
    if  (lRet != ERROR_SUCCESS)
        return  (FALSE);

    return  (hDisplay);
}


/*
    GetLocalNvidiaDisplayDevSubKey

    Purpose:    This routine gets the local subkey which is
                ..Display\000X\Nvidia\Display\LogicalDevice?\PhysicalDevice?

    Arguments:  lpRegData    LPREGDATA
                lpDevData    LPDEVDATA

    Returns:    The registry key to
                ..\Display\000X\Nvidia\Display\LogicalDevice?
                NULL if there was an error.
*/
ULONG CFUNC
GetLocalNvidiaDisplayDevSubKey (LPREGDATA lpRegData, LPDEVDATA lpDevData)
{
    char    szBuffer[MAX_KEY_LEN];
    ULONG   hDisplay, lRet;

    // Get local path and concatenate NVidia to form the local base path
    GetLocalNvidiaDisplayDevPath (lpRegData, lpDevData, szBuffer);

    // Open this key
    lRet = RegCreateKey (lpRegData->dwMainKey, szBuffer, &hDisplay);
    if  (lRet != ERROR_SUCCESS)
        return  (FALSE);

    return  (hDisplay);
}


/*
    GetRegValue

    Purpose:    This routine reads a decimal value from the key passed in

    Arguments:  hKey        key which holds value to read
                lpStr       string pointing to value name
                nDefault    value to return if lpStr didn't exist

    Returns:    The registry key and entry are read.
                nDefault is returned if there is an error or lpStr
                doesn't exist
*/
int CFUNC
GetRegValue (ULONG hKey, LPCHAR lpStr, int nDefault)
{
    ULONG   dwNum, dwSize;
    long    lRet;

    // Query the value from the lpStr entry
    dwNum = 0;
    dwSize = 4;
    lRet = RegQueryValueEx (hKey, lpStr, NULL, NULL, (LPCHAR) &dwNum, &dwSize);

    // CLose the key
    RegCloseKey (hKey);

    // If there was an error or no such key, then use the default value
    if  ((lRet != ERROR_SUCCESS) || (dwSize == 0))
        dwNum = (ULONG) nDefault;

    return  ((int) dwNum);
}


/*
    GetLocalRegValue

    Purpose:    This routine reads a decimal value from the local subkey
                which is ....Display\000X

    Arguments:  lpRegData   LPREGDATA
                lpStr       string pointing to value name
                nDefault    value to return if lpStr didn't exist

    Returns:    The value of the lpStr entry in the
                ...\Display\000X key.
                nDefault is returned if there is an error or lpStr
                doesn't exist
*/
int CFUNC
GetLocalRegValue (LPREGDATA lpRegData, LPCHAR lpStr, int nDefault)
{
    ULONG   hDisplay;

    if  (!(hDisplay = GetLocalSubKey (lpRegData)))
        return  (nDefault);

    return  (GetRegValue (hDisplay, lpStr, nDefault));
}


/*
    GetLocalNvidiaRegValue

    Purpose:    This routine reads a decimal value from the local subkey
                which is ....Display\000X\Nvidia

    Arguments:  lpRegData   LPREGDATA
                lpStr       string pointing to value name
                nDefault    value to return if lpStr didn't exist

    Returns:    The value of the lpStr entry in the
                ...\Display\000X\Nvidia key.
                nDefault is returned if there is an error or lpStr
                doesn't exist
*/

int CFUNC
GetLocalNvidiaRegValue (LPREGDATA lpRegData, LPCHAR lpStr, int nDefault)
{
    ULONG   hDisplay;

    if  (!(hDisplay = GetLocalNvidiaSubKey (lpRegData)))
        return  (nDefault);

    return  (GetRegValue (hDisplay, lpStr, nDefault));
}


/*
    GetLocalNvidiaDisplayRegValue

    Purpose:    This routine reads a decimal value from the local subkey
                which is ....Display\000X\Nvidia\Display

    Arguments:  lpRegData   LPREGDATA
                lpStr       string pointing to value name
                nDefault    value to return if lpStr didn't exist

    Returns:    The value of the lpStr entry in the
                ...\Display\000X\Nvidia\Display key.
                nDefault is returned if there is an error or lpStr
                doesn't exist
*/

int CFUNC
GetLocalNvidiaDisplayRegValue (LPREGDATA lpRegData, LPCHAR lpStr, int nDefault)
{
    ULONG   hDisplay;

    if  (!(hDisplay = GetLocalNvidiaDisplaySubKey (lpRegData)))
        return  (nDefault);

    return  (GetRegValue (hDisplay, lpStr, nDefault));
}


/*
    GetLocalNvidiaDisplayLogRegValue

    Purpose:    This routine reads a decimal value from the local subkey
                which is
                ..Display\000X\Nvidia\Display\LogicalDevice?

    Arguments:  lpRegData   LPREGDATA
                dwLogDevice 0 based logical device number
                lpStr       string pointing to value name
                nDefault    value to return if lpStr didn't exist

    Returns:    The value of the lpStr entry in the
                ...\Display\000X\Nvidia\Display\LogicalDevice? key.
                nDefault is returned if there is an error or lpStr
                doesn't exist
*/
int CFUNC
GetLocalNvidiaDisplayLogRegValue (LPREGDATA lpRegData, ULONG dwLogDevice,
                                    LPCHAR lpStr, int nDefault)
{
    ULONG   hDisplay;

    if  (!(hDisplay = GetLocalNvidiaDisplayLogSubKey (lpRegData, dwLogDevice)))
        return  (nDefault);

    return  (GetRegValue (hDisplay, lpStr, nDefault));
}


/*
    GetLocalNvidiaDisplayDevRegValue

    Purpose:    This routine reads a decimal value from the local subkey
                which is
                ..Display\000X\Nvidia\Display\LogicalDevice?\PhysDevice?

    Arguments:  lpRegData    LPREGDATA
                lpDevData    LPDEVDATA
                lpStr        string pointing to value name
                nDefault     value to return if lpStr didn't exist

    Returns:    The value of the lpStr entry in the
                ...\Display\000X\Nvidia\Display\%DEV#% key.
                nDefault is returned if there is an error or lpStr
                doesn't exist
*/
int CFUNC
GetLocalNvidiaDisplayDevRegValue (LPREGDATA lpRegData, LPDEVDATA lpDevData,
                                    LPCHAR lpStr, int nDefault)
{
    ULONG   hDisplay;

    if  (!(hDisplay = GetLocalNvidiaDisplayDevSubKey (lpRegData, lpDevData)))
        return  (nDefault);

    return  (GetRegValue (hDisplay, lpStr, nDefault));
}


/*
    GetRegString

    This routine reads a string value from the ...\DISPLAY\000X key.
    If the value specified by the lpStr string does not exist or there
    is any error in reading the registry, then FALSE is returned. Otherwise,
    TRUE is returned and lpRet gets set to the string read from the registry.
*/
int CFUNC
GetRegString (ULONG hKey, LPCHAR lpStr, LPCHAR lpRet)
{
    ULONG   dwSize, lRet;

    // Query the value from the lpStr entry
    dwSize = MAX_KEY_LEN;
    lRet = RegQueryValueEx (hKey, lpStr, NULL, NULL, lpRet, &dwSize);

    // Close the key
    RegCloseKey (hKey);

    if  (lRet != ERROR_SUCCESS)
        return  (FALSE);

    return  (TRUE);
}


/*
    GetLocalRegString

    Purpose:    This routine reads a string value from the local subkey
                which is ....Display\000X

    Arguments:  lpRegData   LPREGDATA
                lpStr   string pointing to entry name
                lpRet   place to return string

    Returns:    FALSE is returned if the string doesn't exist
                If TRUE is returned then lpRet is filled in with
                the string value of the entry given by lpStr
*/

int CFUNC
GetLocalRegString (LPREGDATA lpRegData, LPCHAR lpStr, LPCHAR lpRet)
{
    ULONG   hDisplay;

    if  (!(hDisplay = GetLocalSubKey (lpRegData)))
        return  (FALSE);

    return  (GetRegString (hDisplay, lpStr, lpRet));
}


/*
    GetLocalNvidiaRegString

    Purpose:    This routine reads a string value from the local subkey
                which is ....Display\000X\Nvidia

    Arguments:  lpRegData   LPREGDATA
                lpStr   string pointing to entry name
                lpRet   place to return string

    Returns:    FALSE is returned if the string doesn't exist
                If TRUE is returned then lpRet is filled in with
                the string value of the entry given by lpStr
*/
int CFUNC
GetLocalNvidiaRegString (LPREGDATA lpRegData, LPCHAR lpStr, LPCHAR lpRet)
{
    ULONG   hDisplay;

    if  (!(hDisplay = GetLocalNvidiaSubKey (lpRegData)))
        return  (FALSE);

    return  (GetRegString (hDisplay, lpStr, lpRet));
}


/*
    GetLocalNvidiaDisplayRegString

    Purpose:    This routine reads a string value from the local subkey
                which is ....Display\000X\Nvidia\Display

    Arguments:  lpRegData   LPREGDATA
                lpStr   string pointing to entry name
                lpRet   place to return string

    Returns:    FALSE is returned if the string doesn't exist
                If TRUE is returned then lpRet is filled in with
                the string value of the entry given by lpStr
*/
int CFUNC
GetLocalNvidiaDisplayRegString (LPREGDATA lpRegData, LPCHAR lpStr, LPCHAR lpRet)
{
    ULONG   hDisplay;

    if  (!(hDisplay = GetLocalNvidiaDisplaySubKey (lpRegData)))
        return  (FALSE);

    return  (GetRegString (hDisplay, lpStr, lpRet));
}


/*
    GetLocalNvidiaDisplayLogRegString

    Purpose:    This routine reads a string value from the local subkey
                which is
                ..Display\000X\Nvidia\Display\LogicalDevice?

    Arguments:  lpRegData   LPREGDATA
                dwLogDevice 0 based logical device number
                lpStr       string pointing to entry name
                lpRet       place to return string

    Returns:    FALSE is returned if the string doesn't exist
                If TRUE is returned then lpRet is filled in with
                the string value of the entry given by lpStr
*/
int CFUNC
GetLocalNvidiaDisplayLogRegString (LPREGDATA lpRegData, ULONG dwLogDevice,
                                    LPCHAR lpStr, LPCHAR lpRet)
{
    ULONG   hDisplay;

    if  (!(hDisplay = GetLocalNvidiaDisplayLogSubKey (lpRegData, dwLogDevice)))
        return  (FALSE);

    return  (GetRegString (hDisplay, lpStr, lpRet));
}


/*
    GetLocalNvidiaDisplayDevRegString

    Purpose:    This routine reads a string value from the local subkey
                which is
                ..Display\000X\Nvidia\Display\%DEV#%

    Arguments:  lpRegData   LPREGDATA
                lpDevData   LPDEVDATA
                lpStr       string pointing to entry name
                lpRet       place to return string

    Returns:    FALSE is returned if the string doesn't exist
                If TRUE is returned then lpRet is filled in with
                the string value of the entry given by lpStr
*/
int CFUNC
GetLocalNvidiaDisplayDevRegString (LPREGDATA lpRegData, LPDEVDATA lpDevData,
                                    LPCHAR lpStr, LPCHAR lpRet)
{
    ULONG   hDisplay;

    if  (!(hDisplay = GetLocalNvidiaDisplayDevSubKey (lpRegData, lpDevData)))
        return  (FALSE);

    return  (GetRegString (hDisplay, lpStr, lpRet));
}


/*
    DeleteRegEntry

    Purpose:    This routine deletes an entry from a registry key.

    Arguments:  hKey    Key containgin element to delete
                lpStr   string pointing to entry name to delete

    Returns:    Always returns TRUE
*/
int WINAPI
DeleteRegEntry (ULONG hKey, LPCHAR lpStr)
{
    // Delete the value
    RegDeleteValue (hKey, lpStr);

    // CLose the key
    RegCloseKey (hKey);

    return  (TRUE);
}


/*
    DeleteLocalRegEntry

    Purpose:    This routine deletes an entry from the registry
                path ....\Display\000X

    Arguments:  lpRegData   LPREGDATA
                lpStr   string pointing to entry name to delete

    Returns:    Always returns TRUE
*/
int WINAPI
DeleteLocalRegEntry (LPREGDATA lpRegData, LPCHAR lpStr)
{
    ULONG   hDisplay;

    if  (!(hDisplay = GetLocalSubKey (lpRegData)))
        return  (FALSE);

    return  (DeleteRegEntry (hDisplay, lpStr));
}


/*
    DeleteLocalNvidiaRegEntry

    Purpose:    This routine deletes an entry from the registry
                path ....\Display\000X\Nvidia

    Arguments:  lpRegData   LPREGDATA
                lpStr   string pointing to entry name to delete

    Returns:    Always returns TRUE
*/
int WINAPI
DeleteLocalNvidiaRegEntry (LPREGDATA lpRegData, LPCHAR lpStr)
{
    ULONG   hDisplay;

    if  (!(hDisplay = GetLocalNvidiaSubKey (lpRegData)))
        return  (FALSE);

    return  (DeleteRegEntry (hDisplay, lpStr));
}



/*
    DeleteLocalNvidiaDisplayRegEntry

    Purpose:    This routine deletes an entry from the registry
                path ....\Display\000X\Nvidia\Display

    Arguments:  lpRegData   LPREGDATA
                lpStr   string pointing to entry name to delete

    Returns:    Always returns TRUE
*/
int WINAPI
DeleteLocalNvidiaDisplayRegEntry (LPREGDATA lpRegData, LPCHAR lpStr)
{
    ULONG   hDisplay;

    if  (!(hDisplay = GetLocalNvidiaDisplaySubKey (lpRegData)))
        return  (FALSE);

    return  (DeleteRegEntry (hDisplay, lpStr));
}


/*
    DeleteLocalNvidiaDisplayLogRegEntry

    Purpose:    This routine deletes an entry from the registry
                path ....\Display\000X\Nvidia\Display\LogicalDevice?

    Arguments:  lpRegData   LPREGDATA
                dwLogDevice 0 based Logical device number
                lpStr       string pointing to entry name to delete

    Returns:    Always returns TRUE
*/
int WINAPI
DeleteLocalNvidiaDisplayLogRegEntry (LPREGDATA lpRegData, ULONG dwLogDevice,
                                        LPCHAR lpStr)
{
    ULONG   hDisplay;

    if  (!(hDisplay = GetLocalNvidiaDisplayLogSubKey (lpRegData, dwLogDevice)))
        return  (FALSE);

    return  (DeleteRegEntry (hDisplay, lpStr));
}


/*
    DeleteLocalNvidiaDisplayDevRegEntry

    Purpose:    This routine deletes an entry from the registry
                path
                ..Display\000X\Nvidia\Display\LogicalDevice?\PhysicalDevice?

    Arguments:  lpRegData   LPREGDATA
                lpDevData   LPDEVDATA
                lpStr       string pointing to entry name to delete

    Returns:    Always returns TRUE
*/
int WINAPI
DeleteLocalNvidiaDisplayDevRegEntry (LPREGDATA lpRegData, LPDEVDATA lpDevData,
                                        LPCHAR lpStr)
{
    ULONG   hDisplay;

    if  (!(hDisplay = GetLocalNvidiaDisplayDevSubKey (lpRegData, lpDevData)))
        return  (FALSE);

    return  (DeleteRegEntry (hDisplay, lpStr));
}


/*
    SetRegString

    Purpose:    This routine writes an entry into the registry
                path passed in.

    Arguments:  hKey    key to write to
                lpStr   string pointing to entry name to set
                lpData  "string value" of entry
                dwDataLen  length of lpData in bytes to write to registry

    Returns:    TRUE    value was written
                FALSE   there was an error
*/
int CFUNC
SetRegString (ULONG hKey, LPCHAR lpStr, LPCHAR lpData, ULONG dwDataLen)
{
    long    lRet;

    // Write the value from the lpStr entry
    lRet = RegSetValueEx (hKey, lpStr, NULL, REG_SZ, lpData, dwDataLen);

    // Close the key
    RegCloseKey (hKey);

    if  (lRet != ERROR_SUCCESS)
        return  (FALSE);

    return  (TRUE);
}


/*
    SetRegValue

    Purpose:    This routine writes an entry into the registry
                path passed in.

    Arguments:  hKey    key to write to
                lpStr   string pointing to entry name to set
                lpData  "string value" of entry
                dwDataLen  length of lpData in bytes to write to registry

    Returns:    TRUE    value was written
                FALSE   there was an error
*/
int CFUNC
SetRegValue (ULONG hKey, LPCHAR lpStr, int nVal)
{
    long    lRet;
    ULONG   ulVal;

    ulVal = (ULONG) nVal;
    // Write the value from the lpStr entry
    lRet = RegSetValueEx (hKey, lpStr, NULL, REG_DWORD, (LPCHAR) &ulVal, sizeof (ulVal));

    // Close the key
    RegCloseKey (hKey);

    if  (lRet != ERROR_SUCCESS)
        return  (FALSE);

    return  (TRUE);
}


/*
    SetLocalRegString

    Purpose:    This routine writes an entry into the registry
                path ....\Display\000X

    Arguments:  lpRegData   LPREGDATA
                lpStr   string pointing to entry name to set
                lpData  "string value" of entry
                dwDataLen  length of lpData in bytes to write to registry

    Returns:    TRUE    value was written
                FALSE   there was an error
*/
int CFUNC
SetLocalRegString (LPREGDATA lpRegData, LPCHAR lpStr, LPCHAR lpData, ULONG dwDataLen)
{
    ULONG   hDisplay;

    if  (!(hDisplay = GetLocalSubKey (lpRegData)))
        return  (FALSE);

    return  (SetRegString (hDisplay, lpStr, lpData, dwDataLen));
}


/*
    SetLocalNvidiaRegString

    Purpose:    This routine writes an entry into the registry
                path ....\Display\000X\Nvidia

    Arguments:  lpRegData   LPREGDATA
                lpStr       string pointing to entry name to set
                lpData      "string value" of entry
                dwDataLen   length of lpData in bytes to write to registry

    Returns:    TRUE    value was written
                FALSE   there was an error
*/
int CFUNC
SetLocalNvidiaRegString (LPREGDATA lpRegData, LPCHAR lpStr, LPCHAR lpData, ULONG dwDataLen)
{
    ULONG   hDisplay;

    if  (!(hDisplay = GetLocalNvidiaSubKey (lpRegData)))
        return  (FALSE);

    return  (SetRegString (hDisplay, lpStr, lpData, dwDataLen));
}


/*
    SetLocalNvidiaRegValue

    Purpose:    This routine writes an entry into the registry
                path ....\Display\000X\Nvidia

    Arguments:  lpRegData   LPREGDATA
                lpStr       string pointing to entry name to set
                lpData      "string value" of entry
                dwDataLen   length of lpData in bytes to write to registry

    Returns:    TRUE    value was written
                FALSE   there was an error
*/
int CFUNC
SetLocalNvidiaRegValue (LPREGDATA lpRegData, LPCHAR lpStr, int nVal)
{
    ULONG   hDisplay;

    if  (!(hDisplay = GetLocalNvidiaSubKey (lpRegData)))
        return  (FALSE);

    return  (SetRegValue (hDisplay, lpStr, nVal));
}


/*
    SetLocalNvidiaDisplayRegString

    Purpose:    This routine writes an entry into the registry
                path ....\Display\000X\Nvidia\Display

    Arguments:  lpRegData   LPREGDATA
                lpStr       string pointing to entry name to set
                lpData      "string value" of entry
                dwDataLen   length of lpData in bytes to write to registry

    Returns:    TRUE    value was written
                FALSE   there was an error
*/
int CFUNC
SetLocalNvidiaDisplayRegString (LPREGDATA lpRegData, LPCHAR lpStr, LPCHAR lpData, ULONG dwDataLen)
{
    ULONG   hDisplay;

    if  (!(hDisplay = GetLocalNvidiaDisplaySubKey (lpRegData)))
        return  (FALSE);

    return  (SetRegString (hDisplay, lpStr, lpData, dwDataLen));
}


/*
    SetLocalNvidiaDisplayLogRegString

    Purpose:    This routine writes an entry into the registry
                path
                ..\Display\000X\Nvidia\Display\LogicalDevice?

    Arguments:  lpRegData    LPREGDATA
                dwLogDevice  0 based logical device number
                lpStr        string pointing to entry name to set
                lpData       "string value" of entry
                dwDataLen    length of lpData in bytes to write to registry

    Returns:    TRUE    value was written
                FALSE   there was an error
*/
int CFUNC
SetLocalNvidiaDisplayLogRegString (LPREGDATA lpRegData, ULONG dwLogDevice,
                            LPCHAR lpStr, LPCHAR lpData, ULONG dwDataLen)
{
    ULONG   hDisplay;

    if  (!(hDisplay = GetLocalNvidiaDisplayLogSubKey (lpRegData, dwLogDevice)))
        return  (FALSE);

    return  (SetRegString (hDisplay, lpStr, lpData, dwDataLen));
}


/*
    SetLocalNvidiaDisplayDevRegString

    Purpose:    This routine writes an entry into the registry
                path
                ..\Display\000X\Nvidia\Display\LogicalDevice?\PhyscialDevice?

    Arguments:  lpRegData   LPREGDATA
                lpDevData   LPDEVDATA
                lpStr       string pointing to entry name to set
                lpData      "string value" of entry
                dwDataLen   length of lpData in bytes to write to registry

    Returns:    TRUE    value was written
                FALSE   there was an error
*/
int CFUNC
SetLocalNvidiaDisplayDevRegString (LPREGDATA lpRegData, LPDEVDATA lpDevData,
                            LPCHAR lpStr, LPCHAR lpData, ULONG dwDataLen)
{
    ULONG   hDisplay;

    if  (!(hDisplay = GetLocalNvidiaDisplayDevSubKey (lpRegData, lpDevData)))
        return  (FALSE);

    return  (SetRegString (hDisplay, lpStr, lpData, dwDataLen));
}


/*
    GetMonitorLocalSubKey

    Purpose:    This routine gets the key for the local monitor
                path which looks like ....\Monitor\000X

    Arguments:  lpRegData   LPREGDATA

    Returns:    The key to the ....\Monitor\000X registry path
                0 is returned if there is an error
*/
ULONG CFUNC
GetMonitorLocalSubKey (LPREGDATA lpRegData)
{
    ULONG   hMonitor, lRet;

    // Open this key
    lRet = RegCreateKey (lpRegData->dwMainKey, lpRegData->szRegPath, &hMonitor);
    if  (lRet != ERROR_SUCCESS)
        return  (FALSE);

    return  (hMonitor);
}


/*
    GetMonitorLocalRegString

    Purpose:    This routine reads a string value from the local subkey
                which is ....Monitor\000X

    Arguments:  lpRegData   LPREGDATA
                lpStr   string pointing to entry name
                lpRet   place to return string

    Returns:    FALSE is returned if the string doesn't exist
                If TRUE is returned then lpRet is filled in with
                the string value of the entry given by lpStr
*/
ULONG CFUNC
GetMonitorLocalRegString (LPREGDATA lpRegData, LPCHAR lpStr, LPCHAR lpData)
{
    ULONG   hMonitor;

    if  (!(hMonitor = GetMonitorLocalSubKey (lpRegData)))
        return  (FALSE);

    return  (GetRegString (hMonitor, lpStr, lpData));
}


/*
    PrintString0

    This routine prints a debug string.
*/
int CFUNC
PrintString0 (LPCHAR lpStr)
{
    OutputDebugString (lpStr);
    return  (TRUE);
}

/*
    PrintString1

    This routine prints a debug string with 1 argument.
*/
int CFUNC
PrintString1 (LPCHAR lpStr, ULONG dwValue)
{
    wsprintf (szDebug, lpStr, dwValue);
    OutputDebugString (szDebug);
    return  (TRUE);
}


/*
    MemoryAlloc

    This routine allocates the amount of memory requested and
    returns a ptr to the memory block.
*/
LPCHAR CFUNC
MemoryAlloc (ULONG dwSize)
{
    int     hMem;
    LPCHAR  lpMem;

    hMem = (int) GlobalAlloc (GMEM_SHARED, dwSize);

    if  (hMem)
    {
        lpMem = GlobalLock (hMem);

        if  (lpMem)
            return  (lpMem);
    }

    return  (FALSE);
}


/*
    MemoryFree

    This routine frees the memory block.
*/
int CFUNC
MemoryFree (LPULONG lpMem)
{
    int hMem;

    if  (lpMem)
    {
        hMem = (int) GlobalHandle ((USHORT) (((ULONG) lpMem) >> 16));

        if  (hMem)
        {
            GlobalUnlock (hMem);
            GlobalFree (hMem);
        }
    }

    return  (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\modeset.mhd\win9x\rtget.c ===
/*
    FILE:   rtget.c
    DATE:   4/8/99

    This file holds code to get the restrction and timing list.
    If there isn't one -- just return the blank list (not a NULL
    ptr.)
*/

#include "cmntypes.h"
#include "modeext.h"
#include "modeset.h"
#include "mywin.h"
#include "utils.h"
#include "restime.h"
#include "regfuncs.h"
#include "debug.h"

// Just in cae we can't GlobalAlloc a list, we have a single entry one
// we can use here.
RESTIME     sRTList;

/*
    GetMasterRTList

    This routine extracts the Restriction and Timing list for the
    device requested from the registry. nRTListLen is the length
    in RESTIME structures of the array pointed to by lpRTList.
*/
LPRESTIME CFUNC
GetMasterRTList (LPDISPDATA lpDispData)
{
    int         i;
    long        lRet;
    ULONG       dwSubKey;
    ULONG       dwSize, dwValueNameSize;
    ULONG       hRTKey;
    char        szItem[MAX_KEY_LEN];
    char        szRTString[MAX_KEY_LEN];
    LPRESTIME   lpRTList;

    DBG_PRINT0(DL_0, "\r\nEntering GetMasterRTList.");

    if  (!(lpRTList = (LPRESTIME) MemoryAlloc (MAX_RESTIMES * sizeof(RESTIME))))
    {
        DBG_PRINT0 (DL_0, "\r\nAllocation of Restriction And Timing List Failed.");
        DBG_PRINT0 (DL_0, "\r\nSetting up a default list with no restrictions.");
        lpRTList = &sRTList;

        // Use the dwXRes field in the first array element as a count
        // of the number of restriction list entries.
        lpRTList[0].dwXRes = 0;
        return  (lpRTList);
    }

    // Use the dwXRes field in the first array element as a count
    // of the number of restriction list entries.
    lpRTList[0].dwXRes = 0;

    // First, find the path to the restriction and timing strings.
    if  (!(hRTKey = GetLocalNvidiaDisplaySubKey (lpDispData->lpBoardRegistryData)))
    {
        DBG_PRINT0(DL_0, "\r\nGetLocalDisplaySubKey failed. Returning empty RTList.");  
        return  (lpRTList);
    }

    // Start enumerating and parsing the R&T strings.
    for (dwSubKey = 0; TRUE; dwSubKey++)
    {
        // Zero out the strings
        for (i = 0; i < MAX_KEY_LEN; i++)
        {
            szItem[i] = 0;
            szRTString[i] = 0;
        }

        dwValueNameSize = MAX_KEY_LEN;
        dwSize = MAX_KEY_LEN;
        lRet = RegEnumValue (hRTKey, dwSubKey, szItem,
                            &dwValueNameSize, NULL, NULL,
                            szRTString, &dwSize);

        // If there was an error, it probably means that there are
        // no more values to enumerate. That's fine. We are done.
        if  (lRet != ERROR_SUCCESS)
            break;

        // Is this subkey an R&T string? It is if it begins "R&T"
        if  ((szItem[0] == 'R') && (szItem[1] == '&') && (szItem[2] == 'T'))
        {
            // If the R&T string parses legitimately, include it in the list.
            if  (lpRTList[0].dwXRes < (MAX_RESTIMES - 1))
            {
                if  (ParseRTString (lpRTList + lpRTList[0].dwXRes + 1, szRTString))
                {
                    DBG_PRINT1(DL_0, "\r\nR&T string %s parsed fine.", szRTString);
                    lpRTList[0].dwXRes++;
                }
            }
        }
    }

    // Close the key
    RegCloseKey (hRTKey);

    return  (lpRTList);
}


/*
    FreeMasterRTList

    This routine is called when the caller is done with the RTList.
*/
int CFUNC
FreeMasterRTList (LPRESTIME lpRTList)
{
    // The dwYRes field in the first array element is used as a flag
    // to indicate that the array was GlobalAlloced.
    if  (lpRTList != &sRTList)
    {
        DBG_PRINT0(DL_0, "\r\nCalling MemoryFree on RTList.");
        MemoryFree ((LPULONG) lpRTList);
    }

    return  (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\modeset.mhd\winnt\rtget.c ===
/*
    FILE:   rtget.c
    DATE:   4/8/99

    This file holds code to get the restrction and timing list.
    If there isn't one -- just return the blank list (not a NULL
    ptr.)
*/
#include "cmntypes.h"
#include "modeext.h"
#include "modeset.h"
#include "utils.h"
#include "restime.h"
#include "debug.h"

// Just in case we can't GlobalAlloc a list, we have a single entry one
// we can use here.
RESTIME     sRTList;

/*
    GetMasterRTList

    This routine returns a ptr to a an array of RESTIME
    structures which describe the list of R&T strings for
    the board specified. This routine needs to ALWAYS return
    some RT list. If you have to just return a blank list.

    You can alloc memory for the mode list because you will be
    given a chance to free the ptr later.
*/
LPRESTIME CFUNC
GetMasterRTList (LPDISPDATA lpBoardData)
{
    LPRESTIME   lpRTList;

    // Here is returning a blank list.
    lpRTList = &sRTList;
    lpRTList[0].dwXRes = 0;
    return  (lpRTList);
}


/*
    FreeMasterRTList

    This routine is called when the caller is done with the RTList.
*/
int CFUNC
FreeMasterRTList (LPRESTIME lpRTList)
{
    return  (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\common\inc\aos.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  NVIDIA, Corp. of Sunnyvale,  California owns     *|
|*     copyrights, patents, and has design patents pending on the design     *|
|*     and  interface  of the NV chips.   Users and  possessors  of this     *|
|*     source code are hereby granted a nonexclusive, royalty-free copy-     *|
|*     right  and design patent license  to use this code  in individual     *|
|*     and commercial software.                                              *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright  1993-1998  NVIDIA,  Corporation.   NVIDIA  has  design     *|
|*     patents and patents pending in the U.S. and foreign countries.        *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF THIS SOURCE CODE FOR ANY PURPOSE. IT IS PROVIDED "AS IS" WITH-     *|
|*     OUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPORATION     *|
|*     DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOURCE CODE, INCLUD-     *|
|*     ING ALL IMPLIED WARRANTIES  OF MERCHANTABILITY  AND FITNESS FOR A     *|
|*     PARTICULAR  PURPOSE.  IN NO EVENT  SHALL NVIDIA,  CORPORATION  BE     *|
|*     LIABLE FOR ANY SPECIAL,  INDIRECT,  INCIDENTAL,  OR CONSEQUENTIAL     *|
|*     DAMAGES, OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,     *|
|*     DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR     *|
|*     OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION  WITH THE     *|
|*     USE OR PERFORMANCE OF THIS SOURCE CODE.                               *|
|*                                                                           *|
|*     RESTRICTED RIGHTS LEGEND:  Use, duplication, or disclosure by the     *|
|*     Government is subject  to restrictions  as set forth  in subpara-     *|
|*     graph (c) (1) (ii) of the Rights  in Technical Data  and Computer     *|
|*     Software  clause  at DFARS  52.227-7013 and in similar clauses in     *|
|*     the FAR and NASA FAR Supplement.                                      *|
|*                                                                           *|
\***************************************************************************/

/*
* aos.h
*
* OS-independent functions implemented by the RM
*
*/


#if !defined _AUDIOOS_H_
#define _AUDIOOS_H_

#if defined __cplusplus
extern "C" {
#endif

// init calls
RM_STATUS   RmInitAudioDevice(VOID *pResList, VOID *pDevObj, PHWINFO_COMMON_FIELDS pDev);
VOID        RmShutdownAudioDevice(PHWINFO_COMMON_FIELDS pDev);


/* specifies the dont care bits from bit 12 onwards */
#define ALIGN_4K					0x00000000
#define ALIGN_8K					0x00000001		
#define ALIGN_16K					0x00000003
#define ALIGN_32K					0x00000007
#define ALIGN_64K					0x0000000F
#define ALIGN_128K					0x0000001F
#define ALIGN_DONT_CARE				0xFFFFFFFF

// exported services
RM_STATUS	aosAllocateMem(U032 uSize, U032 uAlignMask, VOID **ppLinAddr, VOID **ppPhysAddr);
VOID		aosFreeMem(VOID *pLinAddr);

RM_STATUS	aosMapLinearAddress(VOID *pPhys, U032 uSize, VOID **ppLinear);
VOID		aosUnmapLinearAddress(VOID *pLinear, U032 uSize);

RM_STATUS   aosGetPhysicalAddress(VOID *pLinAddr, U032 uSize, VOID **pPhysAddr);

VOID        aosZeroMemory(VOID *pLinAddr, U032 uSize);
VOID        aosMemCopy(VOID *pDestination, VOID *pSource, U032 uSize);

// debug print stuff
VOID        aosDbgPrintString(int iDbgLevel, char *pStr);
VOID        aosDbgBreakPoint();

// OS-independent functions for doing file i/o - used for debugging drivers without real HW
VOID *      aosCreateDiskFile();
VOID        aosWriteDiskFile(VOID *pHandle, VOID *pBuffer, U032 uSize);
VOID        aosCloseDiskFile(VOID *pHandle);


#define PAGEOFF(p)			        (((U032)(p)) & 0xFFF)
#define MAX_SIMUL_ALLOCATIONS       2048     /* maximum number of simultaneous memory allocations */

#if !defined PAGE_SIZE
#define PAGE_SIZE                   4096
#endif

#if !defined PAGE_SHIFT
#define PAGE_SHIFT			        12L
#endif

#if !defined PAGENUM
#define PAGENUM(p)			        (((U032)(p)) >> PAGE_SHIFT)
#endif

// this is all defined in os.h for Win9x, but not for NT (??)
#if !defined DEBUGLEVEL_TRACEINFO
#define DEBUGLEVEL_TRACEINFO	    0       // For informational debug trace info
#define DEBUGLEVEL_SETUPINFO	    1       // For informational debug setup info
#define DEBUGLEVEL_USERERRORS	    2       // For debug info on app level errors
#define DEBUGLEVEL_WARNINGS	        3       // For RM debug warning info
#define DEBUGLEVEL_ERRORS	        4       // For RM debug error info
#endif

#define MIN(a,b)                    (((a)<(b))?(a):(b))
#define MAX(a,b)                    (((a)>(b))?(a):(b))

#if defined __cplusplus
};
#endif

#if defined __cplusplus
// only include the class definition for c++
class CFpState
{
public:
    CFpState();
    ~CFpState();

private:
#if defined WDM
    KFLOATING_SAVE m_State;
#else
    U032 m_dwFpuSave[32];
    U032 m_dwCr0;
#endif
};

#endif      // C++

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\modeset.mhd\win9x\REGFUNCS.H ===
/*
    FILE:   regfuncs.h
    DATE:   4/8/99

    This file holds code to get certain things from the registry.
*/

typedef struct  tagDEVICEANDTYPE
{
    LPCHAR  lpszName;
    char    cType;
}   DEVICEANDTYPE;

typedef DEVICEANDTYPE FAR *LPDEVICEANDTYPE;


// This routine is in getit.c
extern int CFUNC GrabModeInfoString (LPREGDATA lpRegData, ULONG dwLogDevice, LPDEVDATA lpDevData, LPCHAR lpModeString, LPMODEINFO lpMI, int nType);

// All these are in regfuncs.c
extern int CFUNC GetLocalPath (LPREGDATA lpRegData, LPCHAR lpBuffer);
extern int CFUNC GetLocalNvidiaPath (LPREGDATA lpRegData, LPCHAR lpBuffer);
extern int CFUNC GetLocalNvidiaDisplayPath (LPREGDATA lpRegData, LPCHAR lpBuffer);
extern int CFUNC GetLocalNvidiaDisplayLogPath (LPREGDATA lpRegData, ULONG dwLogDevice, LPCHAR lpBuffer);
extern int CFUNC GetLocalNvidiaDisplayDevPath (LPREGDATA lpRegData, LPDEVDATA lpDevData, LPCHAR lpBuffer);
extern ULONG CFUNC GetLocalSubKey (LPREGDATA lpRegData);
extern ULONG CFUNC GetLocalNvidiaSubKey (LPREGDATA lpRegData);
extern ULONG CFUNC GetLocalNvidiaDisplaySubKey (LPREGDATA lpRegData);
extern ULONG CFUNC GetLocalNvidiaDisplayLogSubKey (LPREGDATA lpRegData, ULONG dwLogDevice);
extern ULONG CFUNC GetLocalNvidiaDisplayDevSubKey (LPREGDATA lpRegData, LPDEVDATA lpDevData);
extern int CFUNC GetRegValue (ULONG hKey, LPCHAR lpStr, int nDefault);
extern int CFUNC GetLocalRegValue (LPREGDATA lpRegData, LPCHAR lpStr, int nDefault);
extern int CFUNC GetLocalNvidiaRegValue (LPREGDATA lpRegData, LPCHAR lpStr, int nDefault);
extern int CFUNC GetLocalNvidiaDisplayRegValue (LPREGDATA lpRegData, LPCHAR lpStr, int nDefault);
extern int CFUNC GetLocalNvidiaDisplayLogRegValue (LPREGDATA lpRegData, ULONG dwLogDevice, LPCHAR lpStr, int nDefault);
extern int CFUNC GetLocalNvidiaDisplayDevRegValue (LPREGDATA lpRegData, LPDEVDATA lpDevData, LPCHAR lpStr, int nDefault);
extern int CFUNC GetRegString (ULONG hKey, LPCHAR lpStr, LPCHAR lpRet);
extern int CFUNC GetLocalRegString (LPREGDATA lpRegData, LPCHAR lpStr, LPCHAR lpRet);
extern int CFUNC GetLocalNvidiaRegString (LPREGDATA lpRegData, LPCHAR lpStr, LPCHAR lpRet);
extern int CFUNC GetLocalNvidiaDisplayRegString (LPREGDATA lpRegData, LPCHAR lpStr, LPCHAR lpRet);
extern int CFUNC GetLocalNvidiaDisplayLogRegString (LPREGDATA lpRegData, ULONG dwLogDevice, LPCHAR lpStr, LPCHAR lpRet);
extern int CFUNC GetLocalNvidiaDisplayDevRegString (LPREGDATA lpRegData, LPDEVDATA lpDevData, LPCHAR lpStr, LPCHAR lpRet);
extern int CFUNC SetRegString (ULONG hKey, LPCHAR lpStr, LPCHAR lpData, ULONG dwDataLen);
extern int CFUNC SetRegValue (ULONG hKey, LPCHAR lpStr, int nVal);
extern int CFUNC SetLocalRegString (LPREGDATA lpRegData, LPCHAR lpStr, LPCHAR lpData, ULONG dwDataLen);
extern int CFUNC SetLocalNvidiaRegString (LPREGDATA lpRegData, LPCHAR lpStr, LPCHAR lpData, ULONG dwDataLen);
extern int CFUNC SetLocalNvidiaRegValue (LPREGDATA lpRegData, LPCHAR lpStr, int nVal);
extern int CFUNC SetLocalNvidiaDisplayRegString (LPREGDATA lpRegData, LPCHAR lpStr, LPCHAR lpData, ULONG dwDataLen);
extern int CFUNC SetLocalNvidiaDisplayLogRegString (LPREGDATA lpRegData, ULONG dwLogDevice, LPCHAR lpStr, LPCHAR lpData, ULONG dwDataLen);
extern int CFUNC SetLocalNvidiaDisplayDevRegString (LPREGDATA lpRegData, LPDEVDATA lpDevData, LPCHAR lpStr, LPCHAR lpData, ULONG dwDataLen);
extern int WINAPI DeleteRegEntry (ULONG hKey, LPCHAR lpStr);
extern int WINAPI DeleteLocalRegEntry (LPREGDATA lpRegData, LPCHAR lpStr);
extern int WINAPI DeleteLocalNvidiaRegEntry (LPREGDATA lpRegData, LPCHAR lpStr);
extern int WINAPI DeleteLocalNvidiaDisplayRegEntry (LPREGDATA lpRegData, LPCHAR lpStr);
extern int WINAPI DeleteLocalNvidiaDisplayLogRegEntry (LPREGDATA lpRegData, ULONG dwLogDevice, LPCHAR lpStr);
extern int WINAPI DeleteLocalNvidiaDisplayDevRegEntry (LPREGDATA lpRegData, LPDEVDATA lpDevData, LPCHAR lpStr);
extern ULONG CFUNC GetMonitorLocalSubKey (LPREGDATA lpRegData);
extern ULONG CFUNC GetMonitorLocalRegString (LPREGDATA lpRegData, LPCHAR lpStr, LPCHAR lpData);
extern int CFUNC PrintString0 (LPCHAR lpStr);
extern int CFUNC PrintString1 (LPCHAR lpStr, ULONG dwValue);
extern LPCHAR CFUNC MemoryAlloc (ULONG dwSize);
extern int CFUNC MemoryFree (LPULONG lpMem);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\common\inc\client.h ===
#ifndef _CLIENT_H_
#define _CLIENT_H_
/******************************************************************************
*
*   File:  client.h
*
*   Description:
*       This file contains the data structures needed to describe all
*   client information.
*
*
*   THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
*   NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
*   IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
*
******************************************************************************/

#define NUM_CLIENTS 160
#define NUM_DEVICES 8

typedef struct _def_client_memory_info
{
    PHWINFO             pDev;
    U032                Handle;
    U032                Parent;
    U032                Class;
    VOID*               Address;
    U032                Length;
    U032                Type;
    U032                Physicality;
    U032                Coherency;
    U032                Instance;
    U032                version;   // used to keep track of how an instance of class NV01_MEMORY_LOCAL_USER was allocated - C.Moidel
    U032                HeapOwner; /* if version > 0 then HeapOwner is the handle to a valid instance of NV04_HEAP_OWNER
                                                     This means that both the memory and HeapOwner were allocated with RmAlloc()
                                      if version = 0 then HeapOwner is a non-unique user created ID and there 
                                                     is NOT a HeapOwner object behind that ID.  Do not register and unregister with the HeapOwner!
                                                     This means that the memory was allocated with either RmAllocMemory() or RmArchHeap()  - C.Moidel*/  
    VOID*               MemData;   // private per-alloc data
    struct _def_client_memory_info* Next;
    struct _def_client_memory_info* Prev;

} CLI_MEMORY_INFO, *PCLI_MEMORY_INFO;

// FIFO channel info
typedef struct _def_client_fifo_info
{
    U032                Handle;
    U032                Device;
    U032                Class;
    U032                ErrorDmaContext;
    U032                DataDmaContext;
    VOID*               FifoPtr;
    U032                DevID;
    U032                InUse;
    U032                ChID;
    U032                AppID;
    void               *AppHandle;
    U032                Selector;
    VOID*               Flat;
    U032                heventWait;
    V032                hwndNotify;
    V032                hwndError;
    U032                msgNotify;
    U032                msgError;
    VOID*               lpSysCallback;
    U032                eventNotify;
    VOID*               pDmaObject;

} CLI_FIFO_INFO, *PCLI_FIFO_INFO;

// device information
typedef struct _def_client_device_info
{
    U032                Handle;
    U032                Client;
    U032                Class;
    U032                InUse;
    U032                AppID;
    U032                DevID;
    void               *AppHandle;
    PCLI_FIFO_INFO      DevFifoList;
    PCLI_MEMORY_INFO    DevMemoryList;

} CLI_DEVICE_INFO, *PCLI_DEVICE_INFO;

typedef struct _def_client_event_user
{
    U032                Handle;
    U032                Channel;
    struct _def_client_event_user* Next;
    struct _def_client_event_user* Prev;

} CLI_EVENT_USER, *PCLI_EVENT_USER;

typedef struct _def_client_event_info
{
    U032                Handle;
    U032                Class;
    PCLI_EVENT_USER     UserList;
    struct _def_client_event_info* Next;
    struct _def_client_event_info* Prev;

} CLI_EVENT_INFO, *PCLI_EVENT_INFO;


//Heap Owner info structure - added by Chuck Moidel
/* TODO: Create a heap_owner data structure that stores device & handle information about allocations
   that it "ownes" rather than doing a search throughout the data structres. */

typedef struct _def_client_heap_owner_info
{
    U032                Handle;
    U032                Client;
    U032                Class;
    U032                BlockReferenceCount;
//  PCLI_MEMORY_INFO    HeapOwnerMemoryList; 
//  PCLI_DEVICE_INFO    CliDeviceList;
    struct _def_client_heap_owner_info* Next;
    struct _def_client_heap_owner_info* Prev;

} CLI_HEAP_OWNER_INFO, *PCLI_HEAP_OWNER_INFO;

// client information
typedef struct _def_client_info
{
    U032                 Handle;
    U032                 Class;
    U032                 InUse;
    U032                 AppID;
    U032                 ProcID;
    void                *AppHandle;
    U032                 ProcContext;
    U032                 FifoCount;
    PCLI_DMA_INFO        CliDmaList;
    PCLI_DEVICE_INFO     CliDeviceList;
    PCLI_MEMORY_INFO     CliMemoryList;
    PCLI_EVENT_INFO      CliEventList;
    PCLI_HEAP_OWNER_INFO CliHeapOwnerList;   // modified by Chuck Moidel

} CLIENTINFO, *PCLIENTINFO;

//
// FIFO channel info.
//

typedef struct _def_channel_info
{
    U032  InUse;
    U032  ChID;
    U032  AppID;
    VOID *AppHandle;
    U032  Selector;
    VOID* Flat;
    U032  heventWait;
    V032  hwndNotify;
    V032  hwndError;
    U032  msgNotify;
    U032  msgError;
    VOID* lpSysCallback;
} CHANNELINFO, *PCHANNELINFO;


RM_STATUS           CliAddClient            (U032*, U032);
BOOL                CliDelClient            ();
BOOL                CliGetClientHandle      (U032*);
BOOL                CliGetClientIndex       (U032, U032*);
BOOL                CliGetClientAppHandle   (U032, void**);
BOOL                CliSetClientContext     (U032);
BOOL                CliSetClientAppHandle   (U032, void*);
BOOL                CliSetClientInstance    (U032);
RM_STATUS           CliGetClientHandleFromChID(PHWINFO, U032, U032*);
RM_STATUS           CliAddDevice            (U032, U032, U032);
BOOL                CliDelDevice            (U032);
BOOL                CliMakeDeviceList       (U032, U032, PCLI_DEVICE_INFO*);
BOOL                CliGetDeviceInfo        (U032, PCLI_DEVICE_INFO*);
PCLI_DEVICE_INFO    CliGetDeviceList        ();
BOOL                CliGetDeviceHandle      (U032, U032*);
BOOL                CliGetDeviceAppHandle   (U032, void**);
BOOL                CliSetDeviceContext     (U032, PHWINFO*);
BOOL                CliSetDeviceAppHandle   (U032, void*);
BOOL                CliGetDeviceClassString (U032, char*);
RM_STATUS           CliAddDeviceFifo        (PHWINFO, U032, U032, U032, U032, U032, U032, U032, U032, VOID*);
BOOL                CliDelDeviceFifo        (U032, U032);
BOOL                CliMakeDeviceFifoList   (U032, U032, U032, PCLI_FIFO_INFO*);
BOOL                CliGetDeviceFifoInfo    (U032, U032, PCLI_FIFO_INFO*);
BOOL                CliGetDeviceFifoList    (U032, PCLI_FIFO_INFO*);
RM_STATUS           CliAddDeviceMemory      (U032, U032, U032, VOID*, U032, U032, U032, U032);
BOOL                CliDelDeviceMemory      (U032, U032);
BOOL                CliDelDeviceHeapOwner   (U032, U032);
BOOL                CliGetDeviceMemoryInfo  (U032, U032, PCLI_MEMORY_INFO*);
PCLI_MEMORY_INFO    CliGetDeviceMemoryList  (U032);
RM_STATUS           CliAddDma               (U032, U032, U032, U032, U032, VOID*, U032, PCLI_DMA_INFO*);
BOOL                CliDelDma               (U032);
BOOL                CliGetDmaInfo           (U032, PCLI_DMA_INFO*);
PCLI_DMA_INFO       CliGetDmaList           ();
RM_STATUS           CliAddMemory            (PHWINFO, U032, U032, U032, U032, VOID*, U032, VOID*);
BOOL                CliDelMemory            (U032);
BOOL                CliGetMemoryInfo        (U032, PCLI_MEMORY_INFO*);
BOOL                CliGetMemoryInfoForLinAddr(VOID *, PCLI_MEMORY_INFO *);
PCLI_MEMORY_INFO    CliGetMemoryList        ();
RM_STATUS           CliAddEvent             (U032, U032, U032, U032, PCLI_EVENT_INFO*);
BOOL                CliDelEvent             (U032);
BOOL                CliDelEventUser         (U032, U032);
U032                CliGetEventUserHandle   (PCLI_EVENT_USER, U032);
BOOL                CliGetEventInfo         (U032, PCLI_EVENT_INFO*);
PCLI_EVENT_INFO     CliGetEventList         ();
BOOL                CliFindObject           (U032, POBJECT*, U032*);
BOOL                CliGetClass             (U032, U032, U032*);
BOOL                CliIsUniqueHandle       (U032, BOOL);
BOOL                CliGetPhysicalDevice    (U032, U032*);

#endif // _CLIENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\common\inc\nvagp.h ===
#ifndef NVAGP_H
#define NVAGP_H

#include <nvrm.h>

#include <os.h>
#ifdef LINUX
#include <os-interface.h>
#endif

// AGP memory allocation tracking
typedef struct _AGP_MEM_INFO
{
    VOID *SysAddr;              // original pages
    U032 PageCount;
    U032 Offset;                // index into AGP Bitmap
    VOID *pMdl;                  // MDL for user mapping
} AGP_MEM_INFO, *PAGP_MEM_INFO;

/* export AGP functionality to rest of resman */
BOOL RmInitAGP (PHWINFO);
BOOL RmTeardownAGP (PHWINFO);
RM_STATUS NvInitChipset(PHWINFO, VOID **handle, U032 *chipset);
RM_STATUS NvSetAGPRate(PHWINFO, VOID *handle, U032 *agprate);
VOID NvUpdateAGPConfig(PHWINFO);
RM_STATUS NvGetAGPBaseLimit(PHWINFO, U032 *base, U032 *limit);
VOID NvEnableAGP(PHWINFO);
VOID NvDisableAGP(PHWINFO);
VOID NvSaveRestoreAGPChipset(PHWINFO pDev, U032 state);
VOID NvSetupAGPConfig(PHWINFO);
RM_STATUS NvAllocAGPPages ( PHWINFO, VOID **, U032, U032, VOID **);
RM_STATUS NvMapAGPPages ( PHWINFO, VOID **, U032, VOID *);
RM_STATUS NvFreeAGPPages ( PHWINFO, VOID **, VOID  *);
BOOL NvSetBusDeviceFunc(PHWINFO);
RM_STATUS NvSetCapIDOffset(PHWINFO, VOID *, U032 *);

/* OS-specific functionality imported from resman */
/* probably need to split this into a different file */
#ifdef LINUX
#include <linux/types.h>		/* for size_t */
#endif

#define AgpInfo(pdev)      (((PRMINFO)(pdev)->pRmInfo)->AGP)

#define PCI_VENDOR_ID		0x00
#define PCI_DEVICE_ID		0x02
#define PCI_COMMAND  		0x04
#define PCI_BASE_ADDRESS_0	0x10   /* Aperture Base */
#define PCI_BASE_ADDRESS_1	0x14   /* Aperture Base */
#define PCI_CAPABILITY_LIST     0x34
#define PCI_DEVICE_SPECIFIC     0x40

#define PCI_MAX_SLOTS            255

#define PCI_MAX_DEVICES                     32
#define PCI_MAX_FUNCTION                    8
#define PCI_INVALID_VENDORID                0xFFFF

#define PCI_CLASS_DISPLAY_DEV               0x03
#define PCI_CLASS_BRIDGE_DEV                0x06
#define PCI_SUBCLASS_BR_HOST                0x00
#define PCI_MULTIFUNCTION                   0x80

#define AGP_NB_ADDR_VALID       0x80000000

#define AGP_CAP_ID              0x02
#define AGP_CAP_STATUS          0x04
#define AGP_CAP_COMMAND         0x08

#define PCI_VENDOR_ID_INTEL       0x8086
#define PCI_VENDOR_ID_AMD         0x1022
#define PCI_VENDOR_ID_VIA         0x1106
#define PCI_VENDOR_ID_RCC         0x1166
#define PCI_VENDOR_ID_MICRON_1    0x1042
#define PCI_VENDOR_ID_MICRON_2    0x1344

#define AGP_STATUS            AgpInfo(pDev).AGPCapPtr+4
#define AGP_COMMAND           AgpInfo(pDev).AGPCapPtr+8

#define INTEL_CHIPSET_CONFIG    0x50
#define INTEL_ERRSTS            0x92
#define INTEL_GART_CONTROL      0xB0
#define INTEL_APER_SIZE         0xB4
#define INTEL_GART_BASE         0xB8
#define INTEL_MULTI_TRANS_TIMER         0xBC
#define INTEL_LOW_PRI_TRANS_TIMER       0xBD

#define VIA_GART_CONTROL        0x80
#define VIA_APER_SIZE           0x84
#define VIA_GART_BASE           0x88
#define VIA_AGP_CONTROL         0xAC

#define AMD_APER_SIZE           0xAC

/* Memory space registers - hex offsets */
#define AMD_GART_STATUS         0x02
#define AMD_GART_BASE           0x04
#define AMD_GART_CONTROL        0x10

#define RCC_APER_SIZE           0x60

#define osPciOrByte(handle, offset, value)			\
    {								\
        volatile unsigned char tmp = osPciReadByte(handle, offset);	\
        tmp |= (U008) value;						\
		osPciWriteByte(handle, offset, tmp);			\
    }

#define osPciOrWord(handle, offset, value)			\
    {								\
        volatile unsigned short tmp = osPciReadWord(handle, offset); \
        tmp |= (U016) value;						\
		osPciWriteWord(handle, offset, tmp);			\
    }

#define osPciOrDword(handle, offset, value)			\
    {								\
        volatile unsigned int tmp = osPciReadDword(handle, offset);	\
        tmp |= (U032) value;						\
		osPciWriteDword(handle, offset, tmp);		\
    }

#define osPciAndByte(handle, offset, value)			\
    {								\
        volatile unsigned char tmp = osPciReadByte(handle, offset);	\
        tmp &= (U008) value;						\
		osPciWriteByte(handle, offset, tmp);			\
    }

#define osPciAndWord(handle, offset, value)			\
    {								\
        volatile unsigned short tmp = osPciReadWord(handle, offset);	\
        tmp &= (U016) value;						\
		osPciWriteWord(handle, offset, tmp);			\
    }

#define osPciAndDword(handle, offset, value)			\
    {								\
        volatile unsigned int tmp = osPciReadDword(handle, offset);	\
        tmp &= (U032) value;						\
		osPciWriteDword(handle, offset, tmp);		\
    }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\modeset.mhd\winnt\MODELIST.C ===
/*
    FILE:   modelist.c
    DATE:   4/8/99

    This file holds code to get the master mode list.
*/

#include "cmntypes.h"
#include "modeext.h"
#include "modeset.h"
#include "debug.h"
#include "utils.h"
//#include "..\..\common\inc\nvreg.h"
#include "restime.h"
#include "osapi.h"

/*
    GetMasterModeList

    This routine returns a ptr to a an array of MODEENTRY
    structures which describe the list of available modes for
    the board specified. This routine needs to ALWAYS return
    some mode list. If you have to just return a list of safe
    modes like 640,480,8,60Hz.

    You can alloc memory for the mode list because you will be
    given a chance to free the ptr later.
*/
LPMODEENTRY CFUNC
GetMasterModeList (LPDISPDATA lpBoardData)
{
    // You can't return NULL -- this is just a template.
    return  (NULL);
}


/*
    FreeMasterModeList

    This routine is called when the caller is done with the mode
    list it got earlier.
*/
int CFUNC
FreeMasterModeList (LPMODEENTRY lpModeList)
{
    return  (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\common\inc\dload.h ===
/*****************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2001 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2001  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
|*****************************************************************************|
|*                                                                           *|
|* Module: dload.c                                                           *|
|*    These are the OS-specific bits of implementing dynamic loading of      *|
|* driver code.  Be that from file, ROM/BIOS, etc.                           *|
|*                                                                           *|
|*****************************************************************************|
|*                                                                           *|
|* History:                                                                  *|
|*       Ken Adams (kadams)     02/2001 - wrote it based upon investigatory  *|
|*                                        code from Todd Poynter.            *|
|*                                                                           *|
\*****************************************************************************/
#ifndef _DLOAD_H
#define _DLOAD_H


RM_STATUS initDload     ( PHWINFO);
RM_STATUS DldLoadModule ( PHWINFO, U008 *rawImage );


NV_UINTPTR_T DldFindMemOffset       (PDLD_MODULE, char *); 
NV_UINTPTR_T DldGetImageOffset      (PDLD_MODULE, unsigned);
NvU16        DldGetSymbolSection    (PDLD_MODULE, unsigned symIndex);
NV_UINTPTR_T DldGetSectionMemOffset (PDLD_MODULE, unsigned secNumber);
NV_UINTPTR_T DldGetMemOffset        (PDLD_MODULE, unsigned symIndex);
void         DldPrintImgInfo        (PDLD_MODULE);
void         DldPrintSectionInfo    (PDLD_MODULE);
void         DldPrintRelocationInfo (PDLD_MODULE);
void         DldPrintSymbolTableInfo(PDLD_MODULE);

RM_STATUS    DldInflate             (NvU8 *in, NvU8* out);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\common\inc\nvarch.h ===
#ifndef _NVARCH_H
#define _NVARCH_H
/**************************************************************************************************************
*
*    File:  nvarch.h
*
*    Description:
*        Defines the functions that implement the nvalloc architecture
*
**************************************************************************************************************/


// macros for IOCTL argument passing and return values
#define ARGS_PTR(t) t *pArgs = (t*)parameters    // declare and define a pointer to the arg struct (arg struct type)
#define ARG(a) (pArgs->a)                         // reference to a member of the arg struct (element name)
#define ARG_P064(a) NvP64_VALUE(pArgs->a)         // extraction of a pointer from a NvP64 in the arg struct (element name)
#define ARG_SELECTOR(a) NvP64_SELECTOR(pArgs->a) // extraction of a selector from a NvP64 in the arg struct (element name)
#define ARG_U064(a) NvU64_VALUE(pArgs->a)        // extraction of a value from a NvU64 in the arg struct (element name)

// macros for error checking
#define RM_SUCCESS(s) ((s) == RM_OK)

// TO DO: clean this up by retrieving values from the registry
// display info constants and structure taken from win95's vdd.h
#define REGISTRY_BPP_NOT_VALID          0x0008
#define MONITOR_INFO_NOT_VALID          0x0080
#define MONITOR_INFO_DISABLED_BY_USER   0x0100

//---------------------------------------------------------------------------
//
//  External variable definitions.
//
//---------------------------------------------------------------------------

extern PCLIENTINFO clientInfo;

extern U032         rmInService;
extern U032         osInService;
extern U032         rmInSafeService;
extern U032         rmInCallback;
extern U032       * rmStackBase;
extern U032       * rmStack;
extern U032         vmmStack;

//---------------------------------------------------------------------------
//
// Function prototypes.
//
//---------------------------------------------------------------------------

// discardable initialization routines
RM_STATUS   initSemaphore           (VOID);
RM_STATUS   initCallbackFreeList    (VOID);
RM_STATUS   initClientInfo          (VOID);
RM_STATUS   destroyClientInfo       (VOID);
RM_STATUS   initMemoryAllocTable    (VOID);

// exported API functions
VOID        Nv01AllocRoot           (NVOS01_PARAMETERS*);
VOID        Nv01AllocDevice         (NVOS06_PARAMETERS*);
VOID        Nv01AllocContextDma     (NVOS03_PARAMETERS*);
VOID        Nv01AllocChannelPio     (NVOS04_PARAMETERS*);
VOID        Nv03AllocChannelDma     (NVOS07_PARAMETERS*);
VOID        Nv01AllocMemory         (NVOS02_PARAMETERS*);
VOID        Nv01AllocObject         (NVOS05_PARAMETERS*);
VOID        Nv04Alloc               (NVOS21_PARAMETERS*);
VOID        Nv01Free                (NVOS00_PARAMETERS*);
VOID        Nv03DmaFlowControl      (NVOS08_PARAMETERS*);
VOID        Nv01Interrupt           (NVOS09_PARAMETERS*);
VOID        Nv01AllocEvent          (NVOS10_PARAMETERS*);
VOID        Nv03ArchHeap            (NVOS11_PARAMETERS*);
VOID        Nv01ConfigVersion       (NVOS12_PARAMETERS*);
VOID        Nv01ConfigGet           (NVOS13_PARAMETERS*);
VOID        Nv01ConfigSet           (NVOS14_PARAMETERS*);
VOID        Nv01ConfigUpdate        (NVOS15_PARAMETERS*);
VOID        Nv01DebugControl        (NVOS20_PARAMETERS*);
VOID        NvRing0Callback         (NVRM_RING0CALLBACK_PARAMS*);
VOID        Nv04ConfigGetEx         (NVOS_CONFIG_GET_EX_PARAMS*);
VOID        Nv04ConfigSetEx         (NVOS_CONFIG_SET_EX_PARAMS*);
VOID        Nv04I2CAccess           (NVOS_I2C_ACCESS_PARAMS*);

// RM support functions
NvV32       RmAllocClient           (U032*, U032);
NvV32       RmAllocDevice           (U032, U032, U032, char*);
NvV32       RmAllocContextDma       (U032, U032, U032, U032, U032, VOID*, U032);
NvV32       RmAllocChannelPio       (U032, U032, U032, U032, U032, VOID**, U032);
NvV32       RmAllocChannelDma       (U032, U032, U032, U032, U032, U032, U032, VOID**);
RM_STATUS   RmAllocChannel          (U032, U032, U032, U032, U032, U032, U032, VOID**, U032);
NvV32       RmAllocMemory           (U032, U032, U032, U032, U032, VOID**, U032*);
RM_STATUS   RmAllocSystemMemory     (PHWINFO, U032, VOID**, U032*, VOID**, U032);
RM_STATUS   RmAllocInstanceMemory   (PHWINFO, U032, VOID**, U032*, U032*, U032*);
RM_STATUS   RmAllocFrameBufferMapping(PHWINFO, U032, VOID**, U032*);
NvV32       RmAllocObject           (U032, U032, U032, U032);
NvV32       RmAllocEvent            (U032, U032, U032, U032, U032, U064);
NvV32       RmAlloc                 (U032, U032, U032, U032, VOID*);
RM_STATUS   RmAllocObjectEx         (U032, U032, U032, VOID*);
NvV32       RmFree                  (U032, U032, U032);
RM_STATUS   RmFreeClient            (U032);
RM_STATUS   RmFreeDevice            (U032, U032);
RM_STATUS   RmFreeContextDma        (U032, U032);
RM_STATUS   RmFreeChannel           (U032, U032, U032);
RM_STATUS   RmFreeMemory            (U032, U032, U032, U032);
RM_STATUS   RmFreeSystemMemory      (PHWINFO, U032);
RM_STATUS   RmFreeSystemMemoryWithArgs(PHWINFO, VOID**, U032, VOID*, U032);
RM_STATUS   RmFreeInstanceMemory    (PHWINFO, U032, U032, U032);
RM_STATUS   RmFreeFrameBuffer       (PHWINFO, U032, U032, U032);
RM_STATUS   RmFreeObject            (U032, U032);
RM_STATUS   RmFreeEvent             (U032, U032);
NvV32       RmDmaChannelWritePut    (U032, U032);
NvV32       RmDmaChannelWritePutWithGet(U032, U032, U032);
NvV32       RmDmaChannelReadGet     (U032, U032*);
NvV32       RmDmaChannelSetJump     (U032, U032);
NvV32       RmInterrupt             (U032, U032);
NvV32       RmArchHeap              (U032, U032, U032, U032, U032, U032, U032, U032, S032*, U032*, U032*, VOID**, U032*, U032*, U032*);
NvV32       RmConfigVersion         (U032, U032, U032*);
NvV32       RmConfigGet             (U032, U032, U032, U032*);
NvV32       RmConfigSet             (U032, U032, U032, U032*, U032);
NvV32       RmConfigUpdate          (U032, U032, U032);
NvV32       RmConfigGetEx           (U032, U032, U032, VOID*, U032);
NvV32       RmConfigSetEx           (U032, U032, U032, VOID*, U032);
RM_STATUS   RmAllocDeviceInstance   (U032*);
NvV32       RmArchStatus            (RM_STATUS, U032);
VOID        RmInitCpuInfo           (PHWINFO);
VOID        RmInitBusInfo           (PHWINFO);
NvV32       RmI2CAccess             (U032, U032, VOID*);
NvV32       RmDirectMethodCall      (U032, U032, U032, U032, U032);
RM_STATUS   RmDebugEx               (U032, U032, U032, VOID*);
RM_STATUS   RmSwapInit              (PHWINFO);
RM_STATUS   RmSwapExt               (PHWINFO, U032, U032, U032, U032, U032, U032);
RM_STATUS   RmSwapClient            (PHWINFO, U032, U032);
RM_STATUS   RmSwapClientGone        (U032);

#endif // _NVARCH_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\common\inc\nvrmint.h ===
/*
 * nvrmint.h
 *
 * NVidia resource manager API header file for internal builds.
 *
 * Copyright (c) 1997, Nvidia Corporation.  All rights reserved.
 * Portions Copyright (c) 1996, 1997, Silicon Graphics Inc.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */

/*
 * _DWTYPE is returned from GetVersionEx(&osVer) and it is stored in dwWinType
 * in the __GLNVstate structure.
 */
#define NV_WIN_IS_9X(_DWTYPE) (_DWTYPE == VER_PLATFORM_WIN32_WINDOWS)
#define NV_WIN_IS_NT(_DWTYPE) (_DWTYPE == VER_PLATFORM_WIN32_NT)

typedef HANDLE NVDESCRIPTOR;
#define NV_DEVICE_NAME_LENGTH_MAX 127
#define NVARCH_INVALID_NVDESCRIPTOR 0
#define NVARCH_INVALID_CLIENT_HANDLE 0


/*
 * Control codes
 */
#define NVRM_IOCTL_BASE                 0x10
#define NVRM_IOCTL_NV_ARCH              (NVRM_IOCTL_BASE + 5)

#define NVRM_ARCH_NV01FREE              0
#define NVRM_ARCH_NV01ALLOCROOT         1
#define NVRM_ARCH_NV01ALLOCMEMORY       2
#define NVRM_ARCH_NV01ALLOCCONTEXTDMA   3
#define NVRM_ARCH_NV01ALLOCCHANNELPIO   4
#define NVRM_ARCH_NV01ALLOCOBJECT       5
#define NVRM_ARCH_NV01ALLOCDEVICE       6
#define NVRM_ARCH_NV03ALLOCCHANNELDMA   7
#define NVRM_ARCH_NV03DMAFLOWCONTROL    8
#define NVRM_ARCH_NV01INTERRUPT         9
#define NVRM_ARCH_NV01ALLOCEVENT        10
#define NVRM_ARCH_NV01HEAP              11
#define NVRM_ARCH_NV01CONFIGVERSION     12
#define NVRM_ARCH_NV01CONFIGGET         13
#define NVRM_ARCH_NV01CONFIGSET         14
#define NVRM_ARCH_NV01CONFIGUPDATE      15
#define NVRM_ARCH_RING0CALLBACK         16
#define NVRM_ARCH_NV04CONFIGGETEX       17
#define NVRM_ARCH_NV04CONFIGSETEX       18
#define NVRM_ARCH_NV04I2CACCESS         19
#define NVRM_ARCH_NV01DEBUGCONTROL      20
#define NVRM_ARCH_NV04ALLOC             21
// audio stuff
#define NVRM_ARCH_UNIFIEDFREE           30

/*
 * Win 9x data structure.
 */
typedef struct
{
    ULONG function;
    ULONG pParameters;
} NvIoctlArch, *PNvIoctlArch;

typedef struct
{
    ULONG p0;
    ULONG p1;
    ULONG p2;
    ULONG p3;
    ULONG p4;
    ULONG p5;
    ULONG p6;
} NVWATCHAPI_PARAMETERS;

ULONG   NvAlloc             (HANDLE, ULONG, ULONG, ULONG, ULONG, PVOID);
ULONG   NvAllocRoot         (HANDLE, ULONG*);
ULONG   NvAllocDevice       (HANDLE, ULONG, ULONG, ULONG, PUCHAR);
ULONG   NvAllocContextDma   (HANDLE, ULONG, ULONG, ULONG, ULONG, PVOID, ULONG);
ULONG   NvAllocChannelPio   (HANDLE, ULONG, ULONG, ULONG, ULONG, ULONG, PVOID*, ULONG);
ULONG   NvAllocChannelDma   (HANDLE, ULONG, ULONG, ULONG, ULONG, ULONG, ULONG, ULONG, PVOID*);
ULONG   NvAllocMemory       (HANDLE, ULONG, ULONG, ULONG, ULONG, ULONG, PVOID*, ULONG*);
ULONG   NvAllocObject       (HANDLE, ULONG, ULONG, ULONG, ULONG);
ULONG   NvFree              (HANDLE, ULONG, ULONG, ULONG);
ULONG   NvDmaFlowControl    (HANDLE, ULONG, ULONG, ULONG, ULONG);
ULONG   NvAllocEvent        (HANDLE, ULONG, ULONG, ULONG, ULONG, ULONG, ULONG);
ULONG   NvWatchApiFrontEnd  (ULONG, ULONG, ULONG, ULONG, ULONG, ULONG, ULONG);
//ULONG     NvDmaPushMutexState (HANDLE, DWORD);

/*
 * Internal, platform dependent implementation of API routines
 */

HANDLE NvRmOpenWin9x(VOID);
HANDLE NvRmOpenWinNt(VOID);

VOID NvRmCloseWin9x(HANDLE);
VOID NvRmCloseWinNt(VOID);

ULONG NvRmAllocWin9x(ULONG hClient, ULONG hParent, ULONG hObject, ULONG hClass, PVOID pAllocParms);
ULONG NvRmAllocWinNt(ULONG hClient, ULONG hParent, ULONG hObject, ULONG hClass, PVOID pAllocParms);

ULONG NvRmAllocRootWin9x(ULONG *phClient);
ULONG NvRmAllocRootWinNt(ULONG *phClient);

ULONG NvRmAllocDeviceWin9x(ULONG hClient, ULONG hDevice, ULONG hClass, PUCHAR szName);
ULONG NvRmAllocDeviceWinNt(ULONG hClient, ULONG hDevice, ULONG hClass, PUCHAR szName);

ULONG NvRmAllocContextDmaWin9x(ULONG hClient, ULONG hDma, ULONG hClass, ULONG flags, PVOID base, ULONG limit);
ULONG NvRmAllocContextDmaWinNt(ULONG hClient, ULONG hDma, ULONG hClass, ULONG flags, PVOID base, ULONG limit);

ULONG NvRmAllocChannelPioWin9x(ULONG hClient, ULONG hDevice, ULONG hChannel, ULONG hClass, ULONG hErrorCtx, PVOID *ppChannel, ULONG flags);
ULONG NvRmAllocChannelPioWinNt(ULONG hClient, ULONG hDevice, ULONG hChannel, ULONG hClass, ULONG hErrorCtx, PVOID *ppChannel, ULONG flags);

ULONG NvRmAllocChannelDmaWin9x(ULONG hClient, ULONG hDevice, ULONG hChannel, ULONG hClass, ULONG hErrorCtx, ULONG hDataCtx, ULONG offset, PVOID *ppChannel);
ULONG NvRmAllocChannelDmaWinNt(ULONG hClient, ULONG hDevice, ULONG hChannel, ULONG hClass, ULONG hErrorCtx, ULONG hDataCtx, ULONG offset, PVOID *ppChannel);

ULONG NvRmAllocMemoryWin9x(ULONG hClient, ULONG hParent, ULONG hMemory, ULONG hClass, ULONG flags, PVOID *ppAddress, ULONG *pLimit);
ULONG NvRmAllocMemoryWinNt(ULONG hClient, ULONG hParent, ULONG hMemory, ULONG hClass, ULONG flags, PVOID *ppAddress, ULONG *pLimit);

ULONG NvRmAllocObjectWin9x(ULONG hClient, ULONG hChannel, ULONG hObject, ULONG hClass);
ULONG NvRmAllocObjectWinNt(ULONG hClient, ULONG hChannel, ULONG hObject, ULONG hClass);

ULONG NvRmFreeWin9x(ULONG hClient, ULONG hParent, ULONG hObject);
ULONG NvRmFreeWinNt(ULONG hClient, ULONG hParent, ULONG hObject);

ULONG Nv3RmGetDmaPushInfoWin9x(ULONG hClient, ULONG hDevice, ULONG hChannel, ULONG hDmaContext, ULONG get);
ULONG Nv3RmGetDmaPushInfoWinNt(ULONG hClient, ULONG hDevice, ULONG hChannel, ULONG hDmaContext, ULONG get);

ULONG NvRmAllocEventWin9x(ULONG hClient, ULONG hObjectParent, ULONG hObjectNew, ULONG hClass, ULONG index, ULONG data);
ULONG NvRmAllocEventWinNt(ULONG hClient, ULONG hObjectParent, ULONG hObjectNew, ULONG hClass, ULONG index, ULONG data);

ULONG NvRmArchHeapWin9x(ULONG hClient, ULONG hParent, ULONG function, ULONG owner, ULONG type,
                               ULONG height, ULONG size, ULONG *pitch, ULONG *offset, ULONG *address, ULONG *limit, ULONG *free, ULONG *total);
ULONG NvRmArchHeapWinNt(ULONG hClient, ULONG hParent, ULONG function, ULONG owner, ULONG type,
                               ULONG height, ULONG size, ULONG *pitch, ULONG *offset, ULONG *address, ULONG *limit, ULONG *free, ULONG *total);
ULONG NvRmConfigGetWin9x(ULONG hClient, ULONG hDevice, ULONG index, ULONG *pValue);
ULONG NvRmConfigGetWinNt(ULONG hClient, ULONG hDevice, ULONG index, ULONG *pValue);
ULONG NvRmConfigSetWin9x(ULONG hClient, ULONG hDevice, ULONG index, ULONG newValue, ULONG *pOldValue);
ULONG NvRmConfigSetWinNt(ULONG hClient, ULONG hDevice, ULONG index, ULONG newValue, ULONG *pOldValue);

ULONG NvRmConfigGetExWin9x(ULONG hClient, ULONG hDevice, ULONG index, VOID *paramStructPtr, ULONG paramSize);
ULONG NvRmConfigGetExWinNt(ULONG hClient, ULONG hDevice, ULONG index, VOID *paramStructPtr, ULONG paramSize);
ULONG NvRmConfigSetExWin9x(ULONG hClient, ULONG hDevice, ULONG index, VOID *paramStructPtr, ULONG paramSize);
ULONG NvRmConfigSetExWinNt(ULONG hClient, ULONG hDevice, ULONG index, VOID *paramStructPtr, ULONG paramSize);

ULONG NvRmInterruptExWin9x(ULONG hClient, ULONG device);
ULONG NvRmInterruptExWinNt(ULONG hClient, ULONG device);

// Unpublished hook for driver to call a ring0 function.
ULONG NvRmRing0CallbackWin9x(ULONG hClient, ULONG device, ULONG procAddr, ULONG param1, ULONG param2);
ULONG NvRmRing0CallbackWinNt(ULONG hClient, ULONG device, ULONG procAddr, ULONG param1, ULONG param2);

ULONG NvRmInterruptWin9x(ULONG, ULONG);
ULONG NvRmInterruptWinNt(ULONG, ULONG);

// Unpublished I2C access routine
ULONG NvRmI2CAccessWin9x(ULONG hClient, ULONG device, VOID *paramStructPtr );
ULONG NvRmI2CAccessWinNt(ULONG hClient, ULONG device, VOID *paramStructPtr );

// Unpublished debug control
ULONG NvRmDebugControlWin9x( ULONG hRoot, ULONG command, VOID *pArgs);
ULONG NvRmDebugControlWinNt( ULONG hRoot, ULONG command, VOID *pArgs);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\common\inc\nvrm_obscure.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 2000 NVIDIA, Corp.  All rights reserved.             *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/*
 * Obscure resman symbols in the build by defining them away.
 *
 * Periodically should look at symbols in output to make sure no
 * new ones have snuck in.
 *
 * This should be os-independent.  Symbols that don't exist for one release
 *   or another are harmless
 *
 * TODO:
 *    need a perl script to undo this in arbitrary text (cut'n'paste
 *    debugger output for example)
 */

#define BT_Init                                      _nv_rmsym_00001
#define Bt_NC                                        _nv_rmsym_00002
#define Bt_NC400                                     _nv_rmsym_00003
#define Bt_NC480                                     _nv_rmsym_00004
#define Bt_NC600                                     _nv_rmsym_00005
#define Bt_NJ                                        _nv_rmsym_00006
#define Bt_NJ400                                     _nv_rmsym_00007
#define Bt_NJ480                                     _nv_rmsym_00008
#define Bt_NJ600                                     _nv_rmsym_00009
#define Bt_NM                                        _nv_rmsym_00010
#define Bt_NM400                                     _nv_rmsym_00011
#define Bt_NM480                                     _nv_rmsym_00012
#define Bt_NM600                                     _nv_rmsym_00013
#define Bt_PA                                        _nv_rmsym_00014
#define Bt_PA400                                     _nv_rmsym_00015
#define Bt_PA480                                     _nv_rmsym_00016
#define Bt_PA600                                     _nv_rmsym_00017
#define Bt_PM                                        _nv_rmsym_00018
#define Bt_PM400                                     _nv_rmsym_00019
#define Bt_PM480                                     _nv_rmsym_00020
#define Bt_PM600                                     _nv_rmsym_00021
#define Bt_PN                                        _nv_rmsym_00022
#define Bt_PN400                                     _nv_rmsym_00023
#define Bt_PN480                                     _nv_rmsym_00024
#define Bt_PN600                                     _nv_rmsym_00025
#define Btc_NC                                       _nv_rmsym_00026
#define Btc_NJ                                       _nv_rmsym_00027
#define Btc_NM                                       _nv_rmsym_00028
#define Btc_NM200                                    _nv_rmsym_00029
#define Btc_NM240                                    _nv_rmsym_00030
#define Btc_NM300                                    _nv_rmsym_00031
#define Btc_NM360                                    _nv_rmsym_00032
#define Btc_NM384                                    _nv_rmsym_00033
#define Btc_NM3x4                                    _nv_rmsym_00034
#define Btc_NM400                                    _nv_rmsym_00035
#define Btc_NM480                                    _nv_rmsym_00036
#define Btc_NM600                                    _nv_rmsym_00037
#define Btc_PA                                       _nv_rmsym_00038
#define Btc_PA200                                    _nv_rmsym_00039
#define Btc_PA240                                    _nv_rmsym_00040
#define Btc_PA300                                    _nv_rmsym_00041
#define Btc_PA360                                    _nv_rmsym_00042
#define Btc_PA384                                    _nv_rmsym_00043
#define Btc_PA3x4                                    _nv_rmsym_00044
#define Btc_PA400                                    _nv_rmsym_00045
#define Btc_PA480                                    _nv_rmsym_00046
#define Btc_PA600                                    _nv_rmsym_00047
#define Btc_PM                                       _nv_rmsym_00048
#define Btc_PN                                       _nv_rmsym_00049
#define CHRONTEL_NTSC                                _nv_rmsym_00050
#define CHRONTEL_PAL                                 _nv_rmsym_00051
#define CH_Disable                                   _nv_rmsym_00052
#define CH_FBC                                       _nv_rmsym_00053
#define CH_Init                                      _nv_rmsym_00054
#define CH_NTSC320X200                               _nv_rmsym_00055
#define CH_NTSC320X240                               _nv_rmsym_00056
#define CH_NTSC400X300                               _nv_rmsym_00057
#define CH_NTSC480X360                               _nv_rmsym_00058
#define CH_NTSC512X384                               _nv_rmsym_00059
#define CH_NTSC640X400                               _nv_rmsym_00060
#define CH_NTSC640X480                               _nv_rmsym_00061
#define CH_NTSC800X600                               _nv_rmsym_00062
#define CH_NULL_STRING                               _nv_rmsym_00063
#define CH_PAL320X200                                _nv_rmsym_00064
#define CH_PAL320X240                                _nv_rmsym_00065
#define CH_PAL400X300                                _nv_rmsym_00066
#define CH_PAL480X360                                _nv_rmsym_00067
#define CH_PAL512X384                                _nv_rmsym_00068
#define CH_PAL640X400                                _nv_rmsym_00069
#define CH_PAL640X480                                _nv_rmsym_00070
#define CH_PAL800X600                                _nv_rmsym_00071
#define CliAddClient                                 _nv_rmsym_00072
#define CliAddDevice                                 _nv_rmsym_00073
#define CliAddDeviceFifo                             _nv_rmsym_00074
#define CliAddDeviceMemory                           _nv_rmsym_00075
#define CliAddDma                                    _nv_rmsym_00076
#define CliAddEvent                                  _nv_rmsym_00077
#define CliAddMemory                                 _nv_rmsym_00078
#define CliDelClient                                 _nv_rmsym_00079
#define CliDelDevice                                 _nv_rmsym_00080
#define CliDelDeviceFifo                             _nv_rmsym_00081
#define CliDelDeviceHeapOwner                        _nv_rmsym_00082
#define CliDelDeviceMemory                           _nv_rmsym_00083
#define CliDelDma                                    _nv_rmsym_00084
#define CliDelEvent                                  _nv_rmsym_00085
#define CliDelEventUser                              _nv_rmsym_00086
#define CliDelMemory                                 _nv_rmsym_00087
#define CliFindObject                                _nv_rmsym_00088
#define CliGetClass                                  _nv_rmsym_00089
#define CliGetClientHandle                           _nv_rmsym_00090
#define CliGetClientHandleFromChID                   _nv_rmsym_00091
#define CliGetClientIndex                            _nv_rmsym_00092
#define CliGetDeviceClassString                      _nv_rmsym_00093
#define CliGetDeviceFifoInfo                         _nv_rmsym_00094
#define CliGetDeviceFifoList                         _nv_rmsym_00095
#define CliGetDeviceHandle                           _nv_rmsym_00096
#define CliGetDeviceInfo                             _nv_rmsym_00097
#define CliGetDeviceList                             _nv_rmsym_00098
#define CliGetDeviceMemoryInfo                       _nv_rmsym_00099
#define CliGetDeviceMemoryList                       _nv_rmsym_00100
#define CliGetDmaInfo                                _nv_rmsym_00101
#define CliGetDmaList                                _nv_rmsym_00102
#define CliGetEventInfo                              _nv_rmsym_00103
#define CliGetEventList                              _nv_rmsym_00104
#define CliGetEventUserHandle                        _nv_rmsym_00105
#define CliGetMemoryInfo                             _nv_rmsym_00106
#define CliGetMemoryList                             _nv_rmsym_00107
#define CliGetPhysicalDevice                         _nv_rmsym_00108
#define CliIsUniqueHandle                            _nv_rmsym_00109
#define CliSetClientContext                          _nv_rmsym_00110
#define CliSetClientInstance                         _nv_rmsym_00111
#define CliSetDeviceContext                          _nv_rmsym_00112
#define ClientInstance                               _nv_rmsym_00113
#define Common_ClassDescriptors                      _nv_rmsym_00114
#define Commonclass04DGetImageOffsetNotify           _nv_rmsym_00115
#define Commonclass04DGetVbiOffsetNotify             _nv_rmsym_00116
#define Commonclass04DNotify                         _nv_rmsym_00117
#define Commonclass04DSetContextDmaImage             _nv_rmsym_00118
#define Commonclass04DSetContextDmaNotifies          _nv_rmsym_00119
#define Commonclass04DSetContextDmaVbi               _nv_rmsym_00120
#define Commonclass04DSetImage                       _nv_rmsym_00121
#define Commonclass04DSetImageConfig                 _nv_rmsym_00122
#define Commonclass04DSetImageStartLine              _nv_rmsym_00123
#define Commonclass04DSetVbi                         _nv_rmsym_00124
#define Commonclass04DStopTransferImage              _nv_rmsym_00125
#define Commonclass04DStopTransferVbi                _nv_rmsym_00126
#define Commonclass04ENotify                         _nv_rmsym_00127
#define Commonclass04EReadData                       _nv_rmsym_00128
#define Commonclass04ESetContextDmaData              _nv_rmsym_00129
#define Commonclass04ESetContextDmaImage             _nv_rmsym_00130
#define Commonclass04ESetContextDmaNotifies          _nv_rmsym_00131
#define Commonclass04EStopTransfer                   _nv_rmsym_00132
#define Commonclass04EWriteImage                     _nv_rmsym_00133
#define Commonclass04FNotify                         _nv_rmsym_00134
#define Commonclass04FRead                           _nv_rmsym_00135
#define Commonclass04FSetContextDmaNotifies          _nv_rmsym_00136
#define Commonclass04FSetInterruptNotify             _nv_rmsym_00137
#define Commonclass04FStopTransfer                   _nv_rmsym_00138
#define Commonclass04FWrite                          _nv_rmsym_00139
#define Commonclass63GetOffsetNotify                 _nv_rmsym_00140
#define Commonclass63ImageScan                       _nv_rmsym_00141
#define Commonclass63SetImageCtxDma                  _nv_rmsym_00142
#define Commonclass63SetNotify                       _nv_rmsym_00143
#define Commonclass63SetNotifyCtxDma                 _nv_rmsym_00144
#define Commonclass63SetVideoOutput                  _nv_rmsym_00145
#define Commonclass63StopTransfer                    _nv_rmsym_00146
#define Commonclass64SetDeltaDuDx                    _nv_rmsym_00147
#define Commonclass64SetDeltaDvDy                    _nv_rmsym_00148
#define Commonclass64SetNotify                       _nv_rmsym_00149
#define Commonclass64SetNotifyCtxDma                 _nv_rmsym_00150
#define Commonclass64SetPoint                        _nv_rmsym_00151
#define Commonclass64SetVideoInput                   _nv_rmsym_00152
#define Commonclass64SetVideoOutput                  _nv_rmsym_00153
#define Commonclass65SetColorFormat                  _nv_rmsym_00154
#define Commonclass65SetColorKey                     _nv_rmsym_00155
#define Commonclass65SetNotify                       _nv_rmsym_00156
#define Commonclass65SetNotifyCtxDma                 _nv_rmsym_00157
#define Commonclass65SetPoint                        _nv_rmsym_00158
#define Commonclass65SetSize                         _nv_rmsym_00159
#define Commonclass65SetVideoInput                   _nv_rmsym_00160
#define Commonclass65SetVideoOutput                  _nv_rmsym_00161
#define CompatColors                                 _nv_rmsym_00162
#define DevinitCrtcToPriv                            _nv_rmsym_00163
#define DevinitExtractDataFromBios                   _nv_rmsym_00164
#define DevinitFetchByte                             _nv_rmsym_00165
#define DevinitFetchDword                            _nv_rmsym_00166
#define DevinitFetchWord                             _nv_rmsym_00167
#define DevinitGetInitTableInfo                      _nv_rmsym_00168
#define DevinitInitDataToCode                        _nv_rmsym_00169
#define DevinitInitializeDevice                      _nv_rmsym_00170
#define EDIDCopy                                     _nv_rmsym_00171
#define EDIDGetMaxRefreshRate                        _nv_rmsym_00172
#define EDIDIsMonitorGTF                             _nv_rmsym_00173
#define EDIDIsValid                                  _nv_rmsym_00174
#define EDIDRead                                     _nv_rmsym_00175
#define EDIDV1Copy                                   _nv_rmsym_00176
#define EDIDV1GetMaxRefreshRate                      _nv_rmsym_00177
#define EDIDV1IsMonitorGTF                           _nv_rmsym_00178
#define EDIDV2Copy                                   _nv_rmsym_00179
#define EDIDV2GetMaxRefreshRate                      _nv_rmsym_00180
#define EDIDV2IsMonitorGTF                           _nv_rmsym_00181
#define EngineInfos                                  _nv_rmsym_00182
#define FindRegistryKeyDisplayPosition               _nv_rmsym_00183
#define FixupColors                                  _nv_rmsym_00184
#define FlushWB                                      _nv_rmsym_00185
#define Fog_EyeDist_Passthr_Mode                     _nv_rmsym_00186
#define Fog_Passthr_Mode                             _nv_rmsym_00187
#define GetTimingFromCode                            _nv_rmsym_00188
#define GrayColors                                   _nv_rmsym_00189
#define HalRmFuncs_000                               _nv_rmsym_00190
#define ImageNotify                                  _nv_rmsym_00191

#define InitNV                                       _nv_rmsym_00193
#define IntenseTable                                 _nv_rmsym_00194
#define IsMonitorDDC                                 _nv_rmsym_00195
#define IsNV0A_NV04                                  _nv_rmsym_00196
#define IsNV10MaskRevA02orBetter_NV10                _nv_rmsym_00197
#define IsNV10MaskRevA03orBetter_NV10                _nv_rmsym_00198
#define IsNV10_NV10                                  _nv_rmsym_00199
#define IsNV15_NV10                                  _nv_rmsym_00200
#define IsNV15orBetter_NV10                          _nv_rmsym_00201
#define IsNV4_NV04                                   _nv_rmsym_00202
#define IsNV5_NV04                                   _nv_rmsym_00203
#define IsNV5orBetter_NV04                           _nv_rmsym_00204
#define IsNVXX                                       _nv_rmsym_00205
#define MTRR_Types                                   _nv_rmsym_00206
#define NTSCstr640                                   _nv_rmsym_00207
#define NTSCstr800                                   _nv_rmsym_00208
#define NV04_ClassDescriptors                        _nv_rmsym_00209
#define NV04_EngineDescriptors                       _nv_rmsym_00210
#define NV04_HalFuncs_000                            _nv_rmsym_00211
#define NV04_MultiChipFuncs                          _nv_rmsym_00212
#define NV04_NumClassDescs                           _nv_rmsym_00213
#define NV04_NumEngineDescs                          _nv_rmsym_00214
#define NV04_NvChipGetRasterPosition                 _nv_rmsym_00216
#define NV04_RmUpdateArbitrationSettings             _nv_rmsym_00217
#define NV04_class04DCreate                          _nv_rmsym_00218
#define NV04_class04DDestroy                         _nv_rmsym_00219
#define NV04_class04DGetImageOffsetNotify            _nv_rmsym_00220
#define NV04_class04DGetVbiOffsetNotify              _nv_rmsym_00221
#define NV04_class04DNotify                          _nv_rmsym_00222
#define NV04_class04DService                         _nv_rmsym_00223
#define NV04_class04DSetContextDmaImage              _nv_rmsym_00224
#define NV04_class04DSetContextDmaNotifies           _nv_rmsym_00225
#define NV04_class04DSetContextDmaVbi                _nv_rmsym_00226
#define NV04_class04DSetImage                        _nv_rmsym_00227
#define NV04_class04DSetImageConfig                  _nv_rmsym_00228
#define NV04_class04DSetImageStartLine               _nv_rmsym_00229
#define NV04_class04DSetVbi                          _nv_rmsym_00230
#define NV04_class04DStopTransferImage               _nv_rmsym_00231
#define NV04_class04DStopTransferVbi                 _nv_rmsym_00232
#define NV04_class04EAudioNotify                     _nv_rmsym_00233
#define NV04_class04ECreate                          _nv_rmsym_00234
#define NV04_class04EDestroy                         _nv_rmsym_00235
#define NV04_class04EImageNotify                     _nv_rmsym_00236
#define NV04_class04ENotify                          _nv_rmsym_00237
#define NV04_class04EReadData                        _nv_rmsym_00238
#define NV04_class04ESetContextDmaData               _nv_rmsym_00239
#define NV04_class04ESetContextDmaImage              _nv_rmsym_00240
#define NV04_class04ESetContextDmaNotifies           _nv_rmsym_00241
#define NV04_class04EStopTransfer                    _nv_rmsym_00242
#define NV04_class04EVideoNotify                     _nv_rmsym_00243
#define NV04_class04EWriteImage                      _nv_rmsym_00244
#define NV04_class04FCreate                          _nv_rmsym_00245
#define NV04_class04FDestroy                         _nv_rmsym_00246
#define NV04_class04FNotify                          _nv_rmsym_00247
#define NV04_class04FRead                            _nv_rmsym_00248
#define NV04_class04FSetContextDmaNotifies           _nv_rmsym_00249
#define NV04_class04FSetInterruptNotify              _nv_rmsym_00250
#define NV04_class04FStopTransfer                    _nv_rmsym_00251
#define NV04_class04FWrite                           _nv_rmsym_00252
#define NV04_class04F_VMI                            _nv_rmsym_00253
#define NV04_dacAGPClockTable                        _nv_rmsym_00254
#define NV04_dacProgramCursorImage                   _nv_rmsym_00255
#define NV04_dacProgramMClk                          _nv_rmsym_00256
#define NV04_dacProgramNVClk                         _nv_rmsym_00257
#define NV04_dacValidateArbitrationSettings          _nv_rmsym_00258
#define NV04_initMp                                  _nv_rmsym_00259
#define NV04_mpPriorityService                       _nv_rmsym_00260
#define NV04_mpService                               _nv_rmsym_00261
#define NV10_ClassDescriptors                        _nv_rmsym_00262
#define NV10_EngineDescriptors                       _nv_rmsym_00263
#define NV10_HalFuncs_000                            _nv_rmsym_00264
#define NV10_MultiChipFuncs                          _nv_rmsym_00265
#define NV10_NumClassDescs                           _nv_rmsym_00266
#define NV10_NumEngineDescs                          _nv_rmsym_00267
#define NV10_NvChipGetRasterPosition                 _nv_rmsym_00269
#define NV10_RmUpdateArbitrationSettings             _nv_rmsym_00270
#define NV10_class04DCreate                          _nv_rmsym_00271
#define NV10_class04DDestroy                         _nv_rmsym_00272
#define NV10_class04DGetImageOffsetNotify            _nv_rmsym_00273
#define NV10_class04DGetVbiOffsetNotify              _nv_rmsym_00274
#define NV10_class04DNotify                          _nv_rmsym_00275
#define NV10_class04DService                         _nv_rmsym_00276
#define NV10_class04DSetContextDmaImage              _nv_rmsym_00277
#define NV10_class04DSetContextDmaNotifies           _nv_rmsym_00278
#define NV10_class04DSetContextDmaVbi                _nv_rmsym_00279
#define NV10_class04DSetImage                        _nv_rmsym_00280
#define NV10_class04DSetImageConfig                  _nv_rmsym_00281
#define NV10_class04DSetImageStartLine               _nv_rmsym_00282
#define NV10_class04DSetVbi                          _nv_rmsym_00283
#define NV10_class04DStopTransferImage               _nv_rmsym_00284
#define NV10_class04DStopTransferVbi                 _nv_rmsym_00285
#define NV10_class04ECreate                          _nv_rmsym_00286
#define NV10_class04EDestroy                         _nv_rmsym_00287
#define NV10_class04EImageNotify                     _nv_rmsym_00288
#define NV10_class04ENotify                          _nv_rmsym_00289
#define NV10_class04EReadData                        _nv_rmsym_00290
#define NV10_class04ESetContextDmaData               _nv_rmsym_00291
#define NV10_class04ESetContextDmaImage              _nv_rmsym_00292
#define NV10_class04ESetContextDmaNotifies           _nv_rmsym_00293
#define NV10_class04EStopTransfer                    _nv_rmsym_00294
#define NV10_class04EVideoNotify                     _nv_rmsym_00295
#define NV10_class04EWriteImage                      _nv_rmsym_00296
#define NV10_class04FCreate                          _nv_rmsym_00297
#define NV10_class04FDestroy                         _nv_rmsym_00298
#define NV10_class04FNotify                          _nv_rmsym_00299
#define NV10_class04FRead                            _nv_rmsym_00300
#define NV10_class04FSetContextDmaNotifies           _nv_rmsym_00301
#define NV10_class04FSetInterruptNotify              _nv_rmsym_00302
#define NV10_class04FStopTransfer                    _nv_rmsym_00303
#define NV10_class04FWrite                           _nv_rmsym_00304
#define NV10_class04F_VMI                            _nv_rmsym_00305
#define NV10_dacAGPClockTable                        _nv_rmsym_00306
#define NV10_dacCalculateArbitration                 _nv_rmsym_00307
#define NV10_dacCalculateVideoCaps                   _nv_rmsym_00308
#define NV10_dacProgramCursorImage                   _nv_rmsym_00309
#define NV10_dacProgramMClk                          _nv_rmsym_00310
#define NV10_dacProgramNVClk                         _nv_rmsym_00311
#define NV10_dacValidateArbitrationSettings          _nv_rmsym_00312
#define NV10_initMp                                  _nv_rmsym_00313
#define NV10_mpPriorityService                       _nv_rmsym_00314
#define NV10_mpService                               _nv_rmsym_00315
#define NVExtractBiosImage                           _nv_rmsym_00316
#define NotifyImageBuffer                            _nv_rmsym_00317

#define NotifyVbiBuffer                              _nv_rmsym_00319

#define Nv01AllocChannelPio                          _nv_rmsym_00321
#define Nv01AllocContextDma                          _nv_rmsym_00322
#define Nv01AllocDevice                              _nv_rmsym_00323
#define Nv01AllocEvent                               _nv_rmsym_00324
#define Nv01AllocMemory                              _nv_rmsym_00325
#define Nv01AllocObject                              _nv_rmsym_00326
#define Nv01AllocRoot                                _nv_rmsym_00327
#define Nv01ConfigGet                                _nv_rmsym_00328
#define Nv01ConfigSet                                _nv_rmsym_00329
#define Nv01ConfigUpdate                             _nv_rmsym_00330
#define Nv01ConfigVersion                            _nv_rmsym_00331
#define Nv01DebugControl                             _nv_rmsym_00332
#define Nv01Free                                     _nv_rmsym_00333
#define Nv01Interrupt                                _nv_rmsym_00334
#define Nv03AllocChannelDma                          _nv_rmsym_00335
#define Nv03ArchHeap                                 _nv_rmsym_00336
#define Nv03DmaFlowControl                           _nv_rmsym_00337
#define Nv04ConfigGetEx                              _nv_rmsym_00338
#define Nv04ConfigSetEx                              _nv_rmsym_00339
#define Nv04I2CAccess                                _nv_rmsym_00340
#define Nv04MemLatchMemConfig                        _nv_rmsym_00341
#define Nv04MemResizeMemory                          _nv_rmsym_00342
#define Nv04MemResizeSdram                           _nv_rmsym_00343
#define Nv04MemResizeSgram                           _nv_rmsym_00344
#define Nv04VideoLUTCursorDACMethods                 _nv_rmsym_00345
#define Nv04VideoOverlayMethods                      _nv_rmsym_00346
#define Nv04_bmp_GenInitTbl                          _nv_rmsym_00347
#define Nv05MemLatchMemConfig                        _nv_rmsym_00348
#define Nv05MemResizeMemory                          _nv_rmsym_00349
#define Nv05VideoLUTCursorDACMethods                 _nv_rmsym_00350
#define Nv05_bmp_GenInitTbl                          _nv_rmsym_00351
#define Nv05_bmp_MemInitTbl                          _nv_rmsym_00352
#define Nv05_bmp_ScrambleTbl                         _nv_rmsym_00353
#define Nv10CelsiusPrimitiveHalMethods               _nv_rmsym_00354
#define Nv10CelsiusPrimitiveMethods                  _nv_rmsym_00355
#define Nv10ContextSurfaces2DMethods                 _nv_rmsym_00356
#define Nv10ContextSurfaces3DMethods                 _nv_rmsym_00357
#define Nv10DX5TexturedTriangleMethods               _nv_rmsym_00358
#define Nv10DX6MultiTextureTriangleMethods           _nv_rmsym_00359
#define Nv10DvdSubpictureMethods                     _nv_rmsym_00360
#define Nv10ImageFromCpuMethods                      _nv_rmsym_00361
#define Nv10MemChipPreInit                           _nv_rmsym_00362
#define Nv10MemComputeMemory                         _nv_rmsym_00363
#define Nv10MemConfigureClocks                       _nv_rmsym_00364
#define Nv10MemConfigureMemory                       _nv_rmsym_00365
#define Nv10ScaledImageFromMemoryMethods             _nv_rmsym_00366
#define Nv10TextureFromCpuMethods                    _nv_rmsym_00367
#define Nv10VideoLUTCursorDACMethods                 _nv_rmsym_00368
#define Nv10VideoOverlayMethods                      _nv_rmsym_00369
#define Nv10_DDR_Sequence_Table                      _nv_rmsym_00370
#define Nv10_SDR_Sequence_Table                      _nv_rmsym_00371
#define Nv10_bmp_GenInitTbl                          _nv_rmsym_00372
#define Nv10_bmp_MemInitTbl                          _nv_rmsym_00373
#define Nv15CelsiusPrimitiveHalMethods               _nv_rmsym_00374
#define Nv15CelsiusPrimitiveMethods                  _nv_rmsym_00375
#define Nv15ImageBlitMethods                         _nv_rmsym_00376
#define Nv15VideoLUTCursorDACMethods                 _nv_rmsym_00377
#define Nv1BetaSolidMethods                          _nv_rmsym_00378
#define Nv1ExternalParallelBusMethods                _nv_rmsym_00379
#define Nv1ImageBlitMethods                          _nv_rmsym_00380
#define Nv1ImageFromCpuMethods                       _nv_rmsym_00381
#define Nv1ImagePatternMethods                       _nv_rmsym_00382
#define Nv1ImageRectangleBlackMethods                _nv_rmsym_00383
#define Nv1ImageSolidMethods                         _nv_rmsym_00384
#define Nv1RenderSolidLinMethods                     _nv_rmsym_00385
#define Nv1RenderSolidRectangleMethods               _nv_rmsym_00386
#define Nv1RenderSolidTriangleMethods                _nv_rmsym_00387
#define Nv1TimerMethods                              _nv_rmsym_00388
#define Nv3ContextRopMethods                         _nv_rmsym_00389
#define Nv3ContextSurface0Methods                    _nv_rmsym_00390
#define Nv3ContextSurface1Methods                    _nv_rmsym_00391
#define Nv3ContextSurface2Methods                    _nv_rmsym_00392
#define Nv3ContextSurface3Methods                    _nv_rmsym_00393
#define Nv3DX3TexturedTriangleMethods                _nv_rmsym_00394
#define Nv3ExternalMonitorBusMethods                 _nv_rmsym_00395
#define Nv3ExternalVideoDecoderMethods               _nv_rmsym_00396
#define Nv3ExternalVideoDecompressorMethods          _nv_rmsym_00397
#define Nv3GDIRectangleTextMethods                   _nv_rmsym_00398
#define Nv3MemoryToMemoryFormatMethods               _nv_rmsym_00399
#define Nv3ScaledImageFromMemoryMethods              _nv_rmsym_00400
#define Nv3StretchedImageFromCPUMethods              _nv_rmsym_00401
#define Nv4ContextBetaMethods                        _nv_rmsym_00402
#define Nv4ContextColorKeyMethods                    _nv_rmsym_00403
#define Nv4ContextPatternMethods                     _nv_rmsym_00404
#define Nv4ContextSurfaceSwizzledMethods             _nv_rmsym_00405
#define Nv4ContextSurfaces2DMethods                  _nv_rmsym_00406
#define Nv4ContextSurfacesArgbZsHalMethods           _nv_rmsym_00407
#define Nv4ContextSurfacesArgbZsMethods              _nv_rmsym_00408
#define Nv4DX5TexturedTriangleMethods                _nv_rmsym_00409
#define Nv4DX6MultiTextureTriangleMethods            _nv_rmsym_00410
#define Nv4DvdSubpictureMethods                      _nv_rmsym_00411
#define Nv4ExternalSerialBusMethods                  _nv_rmsym_00412
#define Nv4GDIRectangleTextMethods                   _nv_rmsym_00413
#define Nv4ImageBlitMethods                          _nv_rmsym_00414
#define Nv4ImageFromCpuMethods                       _nv_rmsym_00415
#define Nv4IndexedImageFromCpuHalMethods             _nv_rmsym_00416
#define Nv4IndexedImageFromCpuMethods                _nv_rmsym_00417
#define Nv4RenderSolidLinMethods                     _nv_rmsym_00418
#define Nv4RenderSolidRectangleMethods               _nv_rmsym_00419
#define Nv4RenderSolidTriangleMethods                _nv_rmsym_00420
#define Nv4ScaledImageFromMemoryMethods              _nv_rmsym_00421
#define Nv4StretchedImageFromCpuMethods              _nv_rmsym_00422
#define Nv5ImageFromCpuMethods                       _nv_rmsym_00423
#define Nv5IndexedImageFromCpuMethods                _nv_rmsym_00424
#define Nv5ScaledImageFromMemoryMethods              _nv_rmsym_00425
#define Nv5StretchedImageFromCpuMethods              _nv_rmsym_00426
#define NvChipTetrisTileTable                        _nv_rmsym_00427
#define NvClassMethods                               _nv_rmsym_00428
#define NvControlClass                               _nv_rmsym_00429
#define NvControlMethods                             _nv_rmsym_00430
#define NvDBPtr_Table                                _nv_rmsym_00431
#define NvDmaFromMemoryMethods                       _nv_rmsym_00432
#define NvDmaInMemoryMethods                         _nv_rmsym_00433
#define NvDmaToMemoryMethods                         _nv_rmsym_00434
#define NvPatchcordMethods                           _nv_rmsym_00435
#define NvRing0Callback                              _nv_rmsym_00436
#define NvVideoColorKeyMethods                       _nv_rmsym_00437
#define NvVideoColormapMethods                       _nv_rmsym_00438
#define NvVideoFromMemoryMethods                     _nv_rmsym_00439
#define NvVideoScalerMethods                         _nv_rmsym_00440
#define NvVideoSinkMethods                           _nv_rmsym_00441
#define NvWatchInstanceMemFuncs                      _nv_rmsym_00442
#define NvWatch_DumpBtreeContents                    _nv_rmsym_00443
#define NvWatch_DumpCRTCRegs                         _nv_rmsym_00444
#define NvWatch_Dump_ClientInfo                      _nv_rmsym_00445
#define NvWatch_Dump_HT_Object_From_Channel          _nv_rmsym_00446
#define NvWatch_Dump_HT_Object_From_Class            _nv_rmsym_00447
#define NvWatch_Dump_HT_Object_From_Engine           _nv_rmsym_00448
#define NvWatch_Dump_HT_Object_From_Handle           _nv_rmsym_00449
#define NvWatch_Dump_HT_Object_From_Instance         _nv_rmsym_00450
#define NvWatch_Dump_HT_Objects                      _nv_rmsym_00451
#define NvWatch_Dump_InstanceFifoContext             _nv_rmsym_00452
#define NvWatch_Dump_NvInfo                          _nv_rmsym_00453
#define NvWatch_EditCRTCReg                          _nv_rmsym_00454
#define NvWatch_FrontEnd                             _nv_rmsym_00455
#define NvWatch_GetObjectFromInst                    _nv_rmsym_00456
#define NvWatch_NV04_DumpFifoContents                _nv_rmsym_00457
#define NvWatch_NV04_DumpUserDmaBuffersAtGet         _nv_rmsym_00458
#define NvWatch_NV04_Dump_Fifo                       _nv_rmsym_00459
#define NvWatch_NV04_Dump_Graphics                   _nv_rmsym_00460
#define NvWatch_NV04_Dump_Master                     _nv_rmsym_00461
#define NvWatch_NV04_Dump_SubChannelContext          _nv_rmsym_00462
#define NvWatch_NV04_Dump_Video                      _nv_rmsym_00463
#define NvWatch_NV04_FillDiagStruct                  _nv_rmsym_00464
#define NvWatch_NV04_GetHashSize                     _nv_rmsym_00465
#define NvWatch_NV10_DumpFifoContents                _nv_rmsym_00466
#define NvWatch_NV10_DumpUserDmaBuffersAtGet         _nv_rmsym_00467
#define NvWatch_NV10_Dump_Fifo                       _nv_rmsym_00468
#define NvWatch_NV10_Dump_Graphics                   _nv_rmsym_00469
#define NvWatch_NV10_Dump_Master                     _nv_rmsym_00470
#define NvWatch_NV10_Dump_Video                      _nv_rmsym_00471
#define NvWatch_NV10_FillDiagStruct                  _nv_rmsym_00472
#define NvWatch_NV10_GetHashSize                     _nv_rmsym_00473
#define NvWatch_ObjectStrings                        _nv_rmsym_00474
#define NvWatch_Process_Hash_Entry                   _nv_rmsym_00475
#define NvWatch_QuickDiag                            _nv_rmsym_00476
#define NvWatch_QuickDiag_fifo                       _nv_rmsym_00477
#define NvWatch_QuickDiag_master                     _nv_rmsym_00478
#define NvWatch_ascii2hex                            _nv_rmsym_00479
#define NvWatch_btreeDumpBranch                      _nv_rmsym_00480
#define NvWatch_dumpraw                              _nv_rmsym_00481
#define NvWatch_engine_dump                          _nv_rmsym_00482
#define NvWatch_num_objects                          _nv_rmsym_00483
#define NvWatch_nvedit                               _nv_rmsym_00484
#define NvWatch_nvread                               _nv_rmsym_00485
#define NvWatch_spaceit                              _nv_rmsym_00486
#define PALMstr640                                   _nv_rmsym_00487
#define PALMstr800                                   _nv_rmsym_00488
#define PALstr640                                    _nv_rmsym_00489
#define PALstr800                                    _nv_rmsym_00490
#define ParseEDID11                                  _nv_rmsym_00491
#define ParseEDID12                                  _nv_rmsym_00492
#define ParseEDID13                                  _nv_rmsym_00493
#define ParseEDID2                                   _nv_rmsym_00494

#define ReadCRTCLock                                 _nv_rmsym_00496
#define ReadSCL                                      _nv_rmsym_00497
#define ReadSDA                                      _nv_rmsym_00498
#define ReadVDIF                                     _nv_rmsym_00499
#define ResetSCLLine                                 _nv_rmsym_00500
#define ResetSDALine                                 _nv_rmsym_00501
#define RmAllocChannel                               _nv_rmsym_00502
#define RmAllocChannelDma                            _nv_rmsym_00503
#define RmAllocChannelPio                            _nv_rmsym_00504
#define RmAllocClient                                _nv_rmsym_00505
#define RmAllocContextDma                            _nv_rmsym_00506
#define RmAllocDevice                                _nv_rmsym_00507
#define RmAllocDeviceInstance                        _nv_rmsym_00508
#define RmAllocEvent                                 _nv_rmsym_00509
#define RmAllocFrameBufferMapping                    _nv_rmsym_00510
#define RmAllocInstanceMemory                        _nv_rmsym_00511
#define RmAllocMemory                                _nv_rmsym_00512
#define RmAllocObject                                _nv_rmsym_00513
#define RmAllocSystemMemory                          _nv_rmsym_00514
#define RmArchHeap                                   _nv_rmsym_00515
#define RmArchStatus                                 _nv_rmsym_00516
#define RmConfigGet                                  _nv_rmsym_00517
#define RmConfigGetEx                                _nv_rmsym_00518
#define RmConfigGetExKernel                          _nv_rmsym_00519
#define RmConfigGetKernel                            _nv_rmsym_00520
#define RmConfigSet                                  _nv_rmsym_00521
#define RmConfigSetEx                                _nv_rmsym_00522
#define RmConfigUpdate                               _nv_rmsym_00523
#define RmConfigVersion                              _nv_rmsym_00524
#define RmDisableInterrupts                          _nv_rmsym_00525
#define RmEnableInterrupts                           _nv_rmsym_00526
#define RmFailureTriggered                           _nv_rmsym_00527
#define RmFailuresDisable                            _nv_rmsym_00528
#define RmFailuresEnable                             _nv_rmsym_00529
#define RmFree                                       _nv_rmsym_00530
#define RmFreeChannel                                _nv_rmsym_00531
#define RmFreeClient                                 _nv_rmsym_00532
#define RmFreeContextDma                             _nv_rmsym_00533
#define RmFreeDevice                                 _nv_rmsym_00534
#define RmFreeEvent                                  _nv_rmsym_00535
#define RmFreeFrameBuffer                            _nv_rmsym_00536
#define RmFreeInstanceMemory                         _nv_rmsym_00537
#define RmFreeMemory                                 _nv_rmsym_00538
#define RmFreeObject                                 _nv_rmsym_00539
#define RmFreeSystemMemory                           _nv_rmsym_00540
#define RmI2CAccess                                  _nv_rmsym_00541

#define RmInitCpuInfo                                _nv_rmsym_00543
#define RmInitNvDevice                               _nv_rmsym_00544
#define RmInitNvMapping                              _nv_rmsym_00545
#define RmInterrupt                                  _nv_rmsym_00546
#define RmInterruptPending                           _nv_rmsym_00547
#define RmLoadState                                  _nv_rmsym_00548
#define RmPostNvDevice                               _nv_rmsym_00549
#define RmSetMode                                    _nv_rmsym_00550

#define RmUnloadState                                _nv_rmsym_00552
#define SavedBiosImageArray                          _nv_rmsym_00553
#define ScaleOffset_Passthr_Mode                     _nv_rmsym_00554
#define SetRetraceH                                  _nv_rmsym_00555
#define SetRetraceV                                  _nv_rmsym_00556
#define SetSCLLine                                   _nv_rmsym_00557
#define SetSDALine                                   _nv_rmsym_00558
#define StopDDC1                                     _nv_rmsym_00559
#define VBlank                                       _nv_rmsym_00560
#define VBlankAddCallback                            _nv_rmsym_00561
#define VBlankDeleteCallback                         _nv_rmsym_00562
#define VGATable                                     _nv_rmsym_00563
#define VPFilterCos                                  _nv_rmsym_00564
#define VT_BT_NTSC                                   _nv_rmsym_00565
#define VT_BT_PAL                                    _nv_rmsym_00566
#define VbiNotify                                    _nv_rmsym_00567


#define Vertex_Passthr_Mode                          _nv_rmsym_00570
#define WaitHighSCLLine                              _nv_rmsym_00571
#define WaitHighSDALine                              _nv_rmsym_00572
#define _nvHalClass053SetClipHorizontal              _nv_rmsym_00573
#define _nvHalClass053SetClipVertical                _nv_rmsym_00574
#define _nvHalClass056GetState                       _nv_rmsym_00575
#define _nvHalClass056SetMaterialEmission            _nv_rmsym_00576
#define _nvHalClass060SetColorConversion             _nv_rmsym_00577
#define _nvHalClass096GetState                       _nv_rmsym_00578
#define _nvHalGrClassSoftwareMethod_NV04             _nv_rmsym_00579
#define _nvHalGrClassSoftwareMethod_NV10             _nv_rmsym_00580
#define _nvHalGrInitCelsius_NV10                     _nv_rmsym_00581
#define _nvHalGrInitDx5_NV10                         _nv_rmsym_00582
#define _nvHalGrInitInstance_NV04                    _nv_rmsym_00583
#define _nvHalGrInitObjectContext_NV10               _nv_rmsym_00584
#define _nvHalGrSetContextColorKeyWar_NV04           _nv_rmsym_00585
#define allocHalEnginePvts                           _nv_rmsym_00586

#define blockFree                                    _nv_rmsym_00588
#define btreeBalance                                 _nv_rmsym_00589
#define btreeBalanceBranch                           _nv_rmsym_00590
#define btreeBranchValidate                          _nv_rmsym_00591
#define btreeDelete                                  _nv_rmsym_00592
#define btreeDumpBranch                              _nv_rmsym_00593
#define btreeDumpTree                                _nv_rmsym_00594
#define btreeEnumNext                                _nv_rmsym_00595
#define btreeEnumStart                               _nv_rmsym_00596
#define btreeInsert                                  _nv_rmsym_00597
#define btreeInsertBranch                            _nv_rmsym_00598
#define btreeNodeValidate                            _nv_rmsym_00599
#define btreeSearch                                  _nv_rmsym_00600
#define btreeTreeValidate                            _nv_rmsym_00601
#define class01CSetContextBeta1                      _nv_rmsym_00602
#define class01CSetContextClip                       _nv_rmsym_00603
#define class01CSetContextPattern                    _nv_rmsym_00604
#define class01CSetContextRop                        _nv_rmsym_00605
#define class01CSetContextSurface                    _nv_rmsym_00606
#define class01CSetOperation                         _nv_rmsym_00607
#define class01CValidate                             _nv_rmsym_00608
#define class01DSetContextBeta1                      _nv_rmsym_00609
#define class01DSetContextClip                       _nv_rmsym_00610
#define class01DSetContextPattern                    _nv_rmsym_00611
#define class01DSetContextRop                        _nv_rmsym_00612
#define class01DSetContextSurface                    _nv_rmsym_00613
#define class01DSetOperation                         _nv_rmsym_00614
#define class01DValidate                             _nv_rmsym_00615
#define class01ESetContextBeta1                      _nv_rmsym_00616
#define class01ESetContextClip                       _nv_rmsym_00617
#define class01ESetContextPattern                    _nv_rmsym_00618
#define class01ESetContextRop                        _nv_rmsym_00619
#define class01ESetContextSurface                    _nv_rmsym_00620
#define class01ESetOperation                         _nv_rmsym_00621
#define class01EValidate                             _nv_rmsym_00622
#define class01FSetContextBeta1                      _nv_rmsym_00623
#define class01FSetContextClip                       _nv_rmsym_00624
#define class01FSetContextColorKey                   _nv_rmsym_00625
#define class01FSetContextPattern                    _nv_rmsym_00626
#define class01FSetContextRop                        _nv_rmsym_00627
#define class01FSetContextSurface                    _nv_rmsym_00628
#define class01FSetContextSurfaceSource              _nv_rmsym_00629
#define class01FSetOperation                         _nv_rmsym_00630
#define class01FValidate                             _nv_rmsym_00631
#define class021SetContextBeta1                      _nv_rmsym_00632
#define class021SetContextClip                       _nv_rmsym_00633
#define class021SetContextColorKey                   _nv_rmsym_00634
#define class021SetContextPattern                    _nv_rmsym_00635
#define class021SetContextRop                        _nv_rmsym_00636
#define class021SetContextSurface                    _nv_rmsym_00637
#define class021SetOperation                         _nv_rmsym_00638
#define class021Validate                             _nv_rmsym_00639
#define class036SetContextBeta1                      _nv_rmsym_00640
#define class036SetContextColorKey                   _nv_rmsym_00641
#define class036SetContextPattern                    _nv_rmsym_00642
#define class036SetContextRop                        _nv_rmsym_00643
#define class036SetContextSurface                    _nv_rmsym_00644
#define class036SetOperation                         _nv_rmsym_00645
#define class036Validate                             _nv_rmsym_00646
#define class037SetContextBeta1                      _nv_rmsym_00647
#define class037SetContextPattern                    _nv_rmsym_00648
#define class037SetContextRop                        _nv_rmsym_00649
#define class037SetContextSurface                    _nv_rmsym_00650
#define class037SetOperation                         _nv_rmsym_00651
#define class037Validate                             _nv_rmsym_00652
#define class046CursorImageNotify                    _nv_rmsym_00653
#define class046GetOffset                            _nv_rmsym_00654
#define class046ImageNotify                          _nv_rmsym_00655
#define class046ProgramLUT                           _nv_rmsym_00656
#define class046SetCursorCtxDma                      _nv_rmsym_00657
#define class046SetCursorImageValues                 _nv_rmsym_00658
#define class046SetCursorPoint                       _nv_rmsym_00659
#define class046SetDACValues                         _nv_rmsym_00660
#define class046SetImageCtxDma                       _nv_rmsym_00661
#define class046SetImageValues                       _nv_rmsym_00662
#define class046SetLUTCtxDma                         _nv_rmsym_00663
#define class046SetLUTValues                         _nv_rmsym_00664
#define class046SetNotify                            _nv_rmsym_00665
#define class046SetNotifyCtxDma                      _nv_rmsym_00666
#define class046StopCursorImage                      _nv_rmsym_00667
#define class046StopDAC                              _nv_rmsym_00668
#define class046StopImage                            _nv_rmsym_00669
#define class046StopLUT                              _nv_rmsym_00670
#define class047GetExceptionData_NV04                _nv_rmsym_00671
#define class047GetOffset                            _nv_rmsym_00672
#define class047InitXfer_NV04                        _nv_rmsym_00673
#define class047KickoffBuffer_NV04                   _nv_rmsym_00674
#define class047Method_NV04                          _nv_rmsym_00675
#define class047Method_NV10                          _nv_rmsym_00676
#define class047Service_NV04                         _nv_rmsym_00677
#define class047SetNotify                            _nv_rmsym_00678
#define class047SetNotifyCtxDma                      _nv_rmsym_00679
#define class047SetOverlayCtxDma                     _nv_rmsym_00680
#define class047SetOverlayPointOutNow                _nv_rmsym_00681
#define class047SetOverlayValues                     _nv_rmsym_00682
#define class047StartXfer_NV04                       _nv_rmsym_00683
#define class047StopOverlay                          _nv_rmsym_00684
#define class047StopOverlayNow                       _nv_rmsym_00685
#define class048SetContextClip                       _nv_rmsym_00686
#define class048SetContextSurfaceColor               _nv_rmsym_00687
#define class048SetContextSurfaceZeta                _nv_rmsym_00688
#define class048Validate                             _nv_rmsym_00689
#define class049CursorImageNotify                    _nv_rmsym_00690
#define class049GetOffset                            _nv_rmsym_00691
#define class049ImageNotify                          _nv_rmsym_00692
#define class049ProgramLUT                           _nv_rmsym_00693
#define class049SetCursorCtxDma                      _nv_rmsym_00694
#define class049SetCursorImageValues                 _nv_rmsym_00695
#define class049SetCursorPoint                       _nv_rmsym_00696
#define class049SetDACValues                         _nv_rmsym_00697
#define class049SetImageCtxDma                       _nv_rmsym_00698
#define class049SetImageValues                       _nv_rmsym_00699
#define class049SetLUTCtxDma                         _nv_rmsym_00700
#define class049SetLUTValues                         _nv_rmsym_00701
#define class049SetNotify                            _nv_rmsym_00702
#define class049SetNotifyCtxDma                      _nv_rmsym_00703
#define class049StopCursorImage                      _nv_rmsym_00704
#define class049StopDAC                              _nv_rmsym_00705
#define class049StopImage                            _nv_rmsym_00706
#define class049StopLUT                              _nv_rmsym_00707
#define class04ASetContextBeta1                      _nv_rmsym_00708
#define class04ASetContextBeta4                      _nv_rmsym_00709
#define class04ASetContextPattern                    _nv_rmsym_00710
#define class04ASetContextRop                        _nv_rmsym_00711
#define class04ASetContextSurface                    _nv_rmsym_00712
#define class04ASetOperation                         _nv_rmsym_00713
#define class04AValidate                             _nv_rmsym_00714
#define class04BSetContextBeta1                      _nv_rmsym_00715
#define class04BSetContextPattern                    _nv_rmsym_00716
#define class04BSetContextRop                        _nv_rmsym_00717
#define class04BSetContextSurface                    _nv_rmsym_00718
#define class04BSetOperation                         _nv_rmsym_00719
#define class04BValidate                             _nv_rmsym_00720
#define class04DCalculateScaleIncrement              _nv_rmsym_00721
#define class04DFindNearestScaleFactor               _nv_rmsym_00722
#define class04DProgramWeights                       _nv_rmsym_00723
#define class04DStartImage                           _nv_rmsym_00724

#define class04DStartVbi                             _nv_rmsym_00726

#define class04EStartAudRead                         _nv_rmsym_00728
#define class04EStartRead                            _nv_rmsym_00729
#define class04EStartVidRead                         _nv_rmsym_00730
#define class04EStartWrite                           _nv_rmsym_00731
#define class050Create                               _nv_rmsym_00732
#define class050Destroy                              _nv_rmsym_00733
#define class050Notify                               _nv_rmsym_00734
#define class050Read                                 _nv_rmsym_00735
#define class050SetContextDmaNotifies                _nv_rmsym_00736
#define class050SetInterruptNotify                   _nv_rmsym_00737
#define class050StopTransfer                         _nv_rmsym_00738
#define class050Write                                _nv_rmsym_00739
#define class051Create                               _nv_rmsym_00740
#define class051Destroy                              _nv_rmsym_00741
#define class051Notify                               _nv_rmsym_00742
#define class051Read                                 _nv_rmsym_00743
#define class051SetContextDmaNotifies                _nv_rmsym_00744
#define class051SetInterruptNotify                   _nv_rmsym_00745
#define class051StopTransfer                         _nv_rmsym_00746
#define class051Write                                _nv_rmsym_00747
#define class053SetClipHorizontal                    _nv_rmsym_00748
#define class053SetClipVertical                      _nv_rmsym_00749
#define class05CSetContextBeta1                      _nv_rmsym_00750
#define class05CSetContextBeta4                      _nv_rmsym_00751
#define class05CSetContextClip                       _nv_rmsym_00752
#define class05CSetContextPattern                    _nv_rmsym_00753
#define class05CSetContextRop                        _nv_rmsym_00754
#define class05CSetContextSurface                    _nv_rmsym_00755
#define class05CSetOperation                         _nv_rmsym_00756
#define class05CValidate                             _nv_rmsym_00757
#define class05DSetContextBeta1                      _nv_rmsym_00758
#define class05DSetContextBeta4                      _nv_rmsym_00759
#define class05DSetContextClip                       _nv_rmsym_00760
#define class05DSetContextPattern                    _nv_rmsym_00761
#define class05DSetContextRop                        _nv_rmsym_00762
#define class05DSetContextSurface                    _nv_rmsym_00763
#define class05DSetOperation                         _nv_rmsym_00764
#define class05DValidate                             _nv_rmsym_00765
#define class05ESetContextBeta1                      _nv_rmsym_00766
#define class05ESetContextBeta4                      _nv_rmsym_00767
#define class05ESetContextClip                       _nv_rmsym_00768
#define class05ESetContextPattern                    _nv_rmsym_00769
#define class05ESetContextRop                        _nv_rmsym_00770
#define class05ESetContextSurface                    _nv_rmsym_00771
#define class05ESetOperation                         _nv_rmsym_00772
#define class05EValidate                             _nv_rmsym_00773
#define class05FSetContextBeta1                      _nv_rmsym_00774
#define class05FSetContextBeta4                      _nv_rmsym_00775
#define class05FSetContextClip                       _nv_rmsym_00776
#define class05FSetContextColorKey                   _nv_rmsym_00777
#define class05FSetContextPattern                    _nv_rmsym_00778
#define class05FSetContextRop                        _nv_rmsym_00779
#define class05FSetContextSurfaces2d                 _nv_rmsym_00780
#define class05FSetOperation                         _nv_rmsym_00781
#define class05FValidate                             _nv_rmsym_00782
#define class060SetColorConversion                   _nv_rmsym_00783
#define class060SetContextBeta1                      _nv_rmsym_00784
#define class060SetContextBeta4                      _nv_rmsym_00785
#define class060SetContextClip                       _nv_rmsym_00786
#define class060SetContextColorKey                   _nv_rmsym_00787
#define class060SetContextPattern                    _nv_rmsym_00788
#define class060SetContextRop                        _nv_rmsym_00789
#define class060SetContextSurface                    _nv_rmsym_00790
#define class060SetOperation                         _nv_rmsym_00791
#define class060Validate                             _nv_rmsym_00792
#define class061SetContextBeta1                      _nv_rmsym_00793
#define class061SetContextBeta4                      _nv_rmsym_00794
#define class061SetContextClip                       _nv_rmsym_00795
#define class061SetContextColorKey                   _nv_rmsym_00796
#define class061SetContextPattern                    _nv_rmsym_00797
#define class061SetContextRop                        _nv_rmsym_00798
#define class061SetContextSurface                    _nv_rmsym_00799
#define class061SetOperation                         _nv_rmsym_00800
#define class061Validate                             _nv_rmsym_00801
#define class063SetColorConversion                   _nv_rmsym_00802
#define class063SetContextBeta1                      _nv_rmsym_00803
#define class063SetContextBeta4                      _nv_rmsym_00804
#define class063SetContextColorKey                   _nv_rmsym_00805
#define class063SetContextPattern                    _nv_rmsym_00806
#define class063SetContextRop                        _nv_rmsym_00807
#define class063SetContextSurface                    _nv_rmsym_00808
#define class063SetOperation                         _nv_rmsym_00809
#define class063Validate                             _nv_rmsym_00810
#define class064SetColorConversion                   _nv_rmsym_00811
#define class064SetContextBeta1                      _nv_rmsym_00812
#define class064SetContextBeta4                      _nv_rmsym_00813
#define class064SetContextClip                       _nv_rmsym_00814
#define class064SetContextColorKey                   _nv_rmsym_00815
#define class064SetContextPattern                    _nv_rmsym_00816
#define class064SetContextRop                        _nv_rmsym_00817
#define class064SetContextSurface                    _nv_rmsym_00818
#define class064SetOperation                         _nv_rmsym_00819
#define class064Validate                             _nv_rmsym_00820
#define class065SetColorConversion                   _nv_rmsym_00821
#define class065SetContextBeta1                      _nv_rmsym_00822
#define class065SetContextBeta4                      _nv_rmsym_00823
#define class065SetContextClip                       _nv_rmsym_00824
#define class065SetContextColorKey                   _nv_rmsym_00825
#define class065SetContextPattern                    _nv_rmsym_00826
#define class065SetContextRop                        _nv_rmsym_00827
#define class065SetContextSurface                    _nv_rmsym_00828
#define class065SetOperation                         _nv_rmsym_00829
#define class065Validate                             _nv_rmsym_00830
#define class066SetColorConversion                   _nv_rmsym_00831
#define class066SetContextBeta1                      _nv_rmsym_00832
#define class066SetContextBeta4                      _nv_rmsym_00833
#define class066SetContextColorKey                   _nv_rmsym_00834
#define class066SetContextPattern                    _nv_rmsym_00835
#define class066SetContextRop                        _nv_rmsym_00836
#define class066SetContextSurface                    _nv_rmsym_00837
#define class066SetOperation                         _nv_rmsym_00838
#define class066Validate                             _nv_rmsym_00839
#define class067CursorImageNotify                    _nv_rmsym_00840
#define class067GetOffset                            _nv_rmsym_00841
#define class067ImageNotify                          _nv_rmsym_00842
#define class067ProgramLUT                           _nv_rmsym_00843
#define class067SetCursorCtxDma                      _nv_rmsym_00844
#define class067SetCursorImageValues                 _nv_rmsym_00845
#define class067SetCursorPoint                       _nv_rmsym_00846
#define class067SetDACValues                         _nv_rmsym_00847
#define class067SetImageCtxDma                       _nv_rmsym_00848
#define class067SetImageValues                       _nv_rmsym_00849
#define class067SetLUTCtxDma                         _nv_rmsym_00850
#define class067SetLUTValues                         _nv_rmsym_00851
#define class067SetNotify                            _nv_rmsym_00852
#define class067SetNotifyCtxDma                      _nv_rmsym_00853
#define class067StopCursorImage                      _nv_rmsym_00854
#define class067StopDAC                              _nv_rmsym_00855
#define class067StopImage                            _nv_rmsym_00856
#define class067StopLUT                              _nv_rmsym_00857
#define class076SetContextBeta1                      _nv_rmsym_00858
#define class076SetContextBeta4                      _nv_rmsym_00859
#define class076SetContextColorKey                   _nv_rmsym_00860
#define class076SetContextPattern                    _nv_rmsym_00861
#define class076SetContextRop                        _nv_rmsym_00862
#define class076SetContextSurface                    _nv_rmsym_00863
#define class076SetOperation                         _nv_rmsym_00864
#define class076Validate                             _nv_rmsym_00865
#define class077SetContextBeta1                      _nv_rmsym_00866
#define class077SetContextBeta4                      _nv_rmsym_00867
#define class077SetContextColorKey                   _nv_rmsym_00868
#define class077SetContextPattern                    _nv_rmsym_00869
#define class077SetContextRop                        _nv_rmsym_00870
#define class077SetContextSurface                    _nv_rmsym_00871
#define class077SetOperation                         _nv_rmsym_00872
#define class077Validate                             _nv_rmsym_00873
#define class07AGetOffset                            _nv_rmsym_00874
#define class07ASetNotify                            _nv_rmsym_00875
#define class07ASetNotifyCtxDma                      _nv_rmsym_00876
#define class07ASetOverlayChrominanceNow             _nv_rmsym_00877
#define class07ASetOverlayCtxDma                     _nv_rmsym_00878
#define class07ASetOverlayLuminanceNow               _nv_rmsym_00879
#define class07ASetOverlayPointOutNow                _nv_rmsym_00880
#define class07ASetOverlayValues                     _nv_rmsym_00881
#define class07AStopOverlay                          _nv_rmsym_00882
#define class07CCursorImageNotify                    _nv_rmsym_00883
#define class07CGetOffset                            _nv_rmsym_00884
#define class07CImageNotify                          _nv_rmsym_00885
#define class07CProgramLUT                           _nv_rmsym_00886
#define class07CSetCursorCtxDma                      _nv_rmsym_00887
#define class07CSetCursorImageValues                 _nv_rmsym_00888
#define class07CSetCursorPoint                       _nv_rmsym_00889
#define class07CSetDACValues                         _nv_rmsym_00890
#define class07CSetImageCtxDma                       _nv_rmsym_00891
#define class07CSetImageValues                       _nv_rmsym_00892
#define class07CSetLUTCtxDma                         _nv_rmsym_00893
#define class07CSetLUTValues                         _nv_rmsym_00894
#define class07CSetNotify                            _nv_rmsym_00895
#define class07CSetNotifyCtxDma                      _nv_rmsym_00896
#define class07CSetOffsetRange                       _nv_rmsym_00897
#define class07CStopCursorImage                      _nv_rmsym_00898
#define class07CStopDAC                              _nv_rmsym_00899
#define class07CStopImage                            _nv_rmsym_00900
#define class07CStopLUT                              _nv_rmsym_00901
#define class07aMethod_NV10                          _nv_rmsym_00902
#define class63ColorKey_NV04                         _nv_rmsym_00903
#define class63ColorKey_NV10                         _nv_rmsym_00904
#define class63DualSurfaceDesktop_NV04               _nv_rmsym_00905
#define class63DualSurfaceDesktop_NV10               _nv_rmsym_00906
#define class63DualSurface_NV04                      _nv_rmsym_00907
#define class63DualSurface_NV10                      _nv_rmsym_00908
#define class63GetExceptionData_NV04                 _nv_rmsym_00909
#define class63GetOffsetNotify                       _nv_rmsym_00910
#define class63ImageScan                             _nv_rmsym_00911
#define class63InitXfer_NV04                         _nv_rmsym_00912
#define class63InitXfer_NV10                         _nv_rmsym_00913
#define class63KickoffBuffer_NV04                    _nv_rmsym_00914
#define class63Method_NV04                           _nv_rmsym_00915
#define class63Method_NV10                           _nv_rmsym_00916
#define class63Service_NV04                          _nv_rmsym_00917
#define class63SetImageCtxDma                        _nv_rmsym_00918
#define class63SetNotify                             _nv_rmsym_00919
#define class63SetNotifyCtxDma                       _nv_rmsym_00920
#define class63SetVideoOutput                        _nv_rmsym_00921
#define class63StartXfer_NV04                        _nv_rmsym_00922
#define class63StartXfer_NV10                        _nv_rmsym_00923
#define class63StopTransfer                          _nv_rmsym_00924
#define class63VBlank                                _nv_rmsym_00925
#define class63WaitVBlank                            _nv_rmsym_00926
#define class63XferComplete                          _nv_rmsym_00927
#define class64Method_NV04                           _nv_rmsym_00928
#define class64Method_NV10                           _nv_rmsym_00929
#define class64SetDeltaDuDx                          _nv_rmsym_00930
#define class64SetDeltaDvDy                          _nv_rmsym_00931
#define class64SetNotify                             _nv_rmsym_00932
#define class64SetNotifyCtxDma                       _nv_rmsym_00933
#define class64SetPoint                              _nv_rmsym_00934
#define class64SetVideoInput                         _nv_rmsym_00935
#define class64SetVideoOutput                        _nv_rmsym_00936
#define class65Method_NV04                           _nv_rmsym_00937
#define class65Method_NV10                           _nv_rmsym_00938
#define class65SetColorFormat                        _nv_rmsym_00939
#define class65SetColorKey                           _nv_rmsym_00940
#define class65SetNotify                             _nv_rmsym_00941
#define class65SetNotifyCtxDma                       _nv_rmsym_00942
#define class65SetPoint                              _nv_rmsym_00943
#define class65SetSize                               _nv_rmsym_00944
#define class65SetVideoInput                         _nv_rmsym_00945
#define class65SetVideoOutput                        _nv_rmsym_00946
#define classAddZombie                               _nv_rmsym_00947
#define classBuildDB                                 _nv_rmsym_00948
#define classCreate                                  _nv_rmsym_00949
#define classCreateWellKnownObjects                  _nv_rmsym_00950
#define classDeleteWellKnownObjects                  _nv_rmsym_00951
#define classDestroy                                 _nv_rmsym_00952
#define classDestroyDB                               _nv_rmsym_00953
#define classGetClass                                _nv_rmsym_00954
#define classGetInfo                                 _nv_rmsym_00955
#define classInitCommonObject                        _nv_rmsym_00956
#define classMethodsTable                            _nv_rmsym_00957
#define classSoftwareMethod                          _nv_rmsym_00958
#define clientHandle                                 _nv_rmsym_00959
#define clientInfo                                   _nv_rmsym_00960
#define clientInfoSelector                           _nv_rmsym_00961
#define clientSize                                   _nv_rmsym_00962
#define dac128Name                                   _nv_rmsym_00963
#define dac16Name                                    _nv_rmsym_00964
#define dac32Name                                    _nv_rmsym_00965
#define dac64Name                                    _nv_rmsym_00966
#define dacAdjustCRTCForFlatPanel                    _nv_rmsym_00967
#define dacAdjustCRTCForTV                           _nv_rmsym_00968
#define dacCalcMNP                                   _nv_rmsym_00969
#define dacCalcPLL                                   _nv_rmsym_00970
#define dacCalculateArbitration                      _nv_rmsym_00971
#define dacCreateObj                                 _nv_rmsym_00972
#define dacDestroyObj                                _nv_rmsym_00973
#define dacDetectTrigger                             _nv_rmsym_00974
#define dacDisableCursor                             _nv_rmsym_00975
#define dacEnableCursor                              _nv_rmsym_00976
#define dacFlatPanelConnectStatus                    _nv_rmsym_00977
#define dacGetDefaultTVPosition                      _nv_rmsym_00978
#define dacGetDisplayType                            _nv_rmsym_00979
#define dacGetFlatPanelConfig                        _nv_rmsym_00980
#define dacGetFlatPanelInfo                          _nv_rmsym_00981
#define dacGetI2CModeString                          _nv_rmsym_00982
#define dacGetMonitorDefaultPosition                 _nv_rmsym_00983
#define dacGetMonitorInfo                            _nv_rmsym_00984
#define dacGetTVAdjustTableArray                     _nv_rmsym_00985
#define dacGetTVAdjustTableEntry                     _nv_rmsym_00986
#define dacGetTVmode                                 _nv_rmsym_00987
#define dacLoadColor256DAC                           _nv_rmsym_00988
#define dacLoadColorDACTable                         _nv_rmsym_00989
#define dacLoadIdentityDAC                           _nv_rmsym_00990
#define dacLoadIndexRange                            _nv_rmsym_00991
#define dacLoadPalette                               _nv_rmsym_00992
#define dacLoadWidthDepth                            _nv_rmsym_00993
#define dacMonitorConnectStatus                      _nv_rmsym_00994
#define dacProgramBrooktree                          _nv_rmsym_00995
#define dacProgramCRTC                               _nv_rmsym_00996
#define dacProgramChrontel                           _nv_rmsym_00997
#define dacProgramCursorPosition                     _nv_rmsym_00998
#define dacProgramCustomCRTC                         _nv_rmsym_00999
#define dacProgramDefaultCRTC                        _nv_rmsym_01000
#define dacProgramLUT                                _nv_rmsym_01001
#define dacProgramScanRegion                         _nv_rmsym_01002
#define dacProgramVideoStart                         _nv_rmsym_01003
#define dacReadBIOSI2CSettings                       _nv_rmsym_01004
#define dacReadDesktopPositionFromRegistry           _nv_rmsym_01005
#define dacReadDisplayTypeFromRegistry               _nv_rmsym_01006
#define dacReadTVDesktopPositionFromRegistry         _nv_rmsym_01007
#define dacReadTVOutFromRegistry                     _nv_rmsym_01008
#define dacReadTVTypeFromRegistry                    _nv_rmsym_01009
#define dacSaveMonitorDefaultPosition                _nv_rmsym_01010
#define dacSetCursorBlink                            _nv_rmsym_01011
#define dacSetDpmLevel                               _nv_rmsym_01012
#define dacSetFan                                    _nv_rmsym_01013
#define dacSetFlatPanelMode                          _nv_rmsym_01014
#define dacSetMonitorPosition                        _nv_rmsym_01015
#define dacSetTVPosition                             _nv_rmsym_01016
#define dacSetupTVEncoder                            _nv_rmsym_01017
#define dacTVConnectStatus                           _nv_rmsym_01018
#define dacTransferFromBIOSCopy                      _nv_rmsym_01019
#define dacVBlank                                    _nv_rmsym_01020
#define dacWriteColor                                _nv_rmsym_01021
#define dacWriteColor2                               _nv_rmsym_01022
#define dacWriteDesktopPositionToRegistry            _nv_rmsym_01023
#define dacWriteDisplayTypeToRegistry                _nv_rmsym_01024
#define dacWriteTVOutToRegistry                      _nv_rmsym_01025
#define dacWriteTVTypeToRegistry                     _nv_rmsym_01026
#define dbgDumpHeap                                  _nv_rmsym_01027
#define dbgDumpMTRRs                                 _nv_rmsym_01028
#define destroyHal                                   _nv_rmsym_01029
#define disableCursor                                _nv_rmsym_01030
#define dmaAllocInstance                             _nv_rmsym_01031
#define dmaAllocate                                  _nv_rmsym_01032
#define dmaBindToChannel                             _nv_rmsym_01033
#define dmaContextInstanceToObject                   _nv_rmsym_01034
#define dmaCreate                                    _nv_rmsym_01035
#define dmaDeallocate                                _nv_rmsym_01036
#define dmaDelete                                    _nv_rmsym_01037
#define dmaFindContext                               _nv_rmsym_01038
#define dmaFreeInstance                              _nv_rmsym_01039
#define dmaGetMappedAddress                          _nv_rmsym_01040
#define dmaHalInstanceToHalInfo_NV04                 _nv_rmsym_01041
#define dmaHalInstanceToHalInfo_NV10                 _nv_rmsym_01042
#define dmaListElementPool                           _nv_rmsym_01043
#define dmaRegisterToDevice                          _nv_rmsym_01044
#define dmaSetBufferCtxDma                           _nv_rmsym_01045
#define dmaSetBufferLength                           _nv_rmsym_01046
#define dmaSetBufferPitch                            _nv_rmsym_01047
#define dmaSetBufferStart                            _nv_rmsym_01048
#define dmaUnbindFromChannel                         _nv_rmsym_01049
#define dmaUnregisterFromDevice                      _nv_rmsym_01050
#define dmaValidateObjectName                        _nv_rmsym_01051
#define dmaValidateXlate                             _nv_rmsym_01052
#define edidGetVersion                               _nv_rmsym_01053
#define edidIsAnalogDisplay                          _nv_rmsym_01054
#define edidParseDetailed1                           _nv_rmsym_01055
#define edidParseDetailed2                           _nv_rmsym_01056
#define edidParseDetailedTimingBlock                 _nv_rmsym_01057
#define enableCursor                                 _nv_rmsym_01058
#define engineGetBufferSize                          _nv_rmsym_01059
#define engineGetInfo                                _nv_rmsym_01060
#define engineGetInstMemSize                         _nv_rmsym_01061
#define eventRemoveObjectEventNotify                 _nv_rmsym_01062
#define eventSetEventNotify                          _nv_rmsym_01063
#define eventSetObjectEventNotify                    _nv_rmsym_01064
#define fbAllocInstMem                               _nv_rmsym_01065
#define fbAllocInstMemAlign                          _nv_rmsym_01066
#define fbCalcScreenMemSize                          _nv_rmsym_01067
#define fbFreeInstMem                                _nv_rmsym_01068
#define fbInitializeInstMemBitMap                    _nv_rmsym_01069
#define fbService                                    _nv_rmsym_01070
#define fifoAddHashEntry                             _nv_rmsym_01071
#define fifoAddObject                                _nv_rmsym_01072
#define fifoAlloc                                    _nv_rmsym_01073
#define fifoAllocDma                                 _nv_rmsym_01074
#define fifoDelHashEntry                             _nv_rmsym_01075
#define fifoDelObject                                _nv_rmsym_01076
#define fifoDeleteObjectInstance                     _nv_rmsym_01077
#define fifoEnumObjects                              _nv_rmsym_01078
#define fifoFree                                     _nv_rmsym_01079
#define fifoResend                                   _nv_rmsym_01080
#define fifoResetChannelState                        _nv_rmsym_01081
#define fifoSearchObject                             _nv_rmsym_01082
#define fifoService                                  _nv_rmsym_01083
#define fifoSoftwareMethod                           _nv_rmsym_01084
#define fifoUpdateObjectInstance                     _nv_rmsym_01085
#define fifolog                                      _nv_rmsym_01086
#define findex                                       _nv_rmsym_01087
#define fpParseEDID                                  _nv_rmsym_01088
#define getI2CPort                                   _nv_rmsym_01089
#define get_winice_input                             _nv_rmsym_01090
#define grCancelVBlank                               _nv_rmsym_01091
#define grContextInstanceToObject                    _nv_rmsym_01092
#define grCreateObj                                  _nv_rmsym_01093
#define grCreateOrdinal                              _nv_rmsym_01094
#define grCreateVideoColormap                        _nv_rmsym_01095
#define grCreateVideoPatchcord                       _nv_rmsym_01096
#define grCreateVideoSink                            _nv_rmsym_01097
#define grDefaultMethods                             _nv_rmsym_01098
#define grDeleteObjectInstance                       _nv_rmsym_01099
#define grDeleteOrdinal                              _nv_rmsym_01100
#define grDeleteVideoColormap                        _nv_rmsym_01101
#define grDeleteVideoPatchcord                       _nv_rmsym_01102
#define grDeleteVideoSink                            _nv_rmsym_01103
#define grDestroyObj                                 _nv_rmsym_01104
#define grGetLastIllegalMthdObject                   _nv_rmsym_01105
#define grHWMethod                                   _nv_rmsym_01106
#define grInitCommon                                 _nv_rmsym_01107
#define grInitPipeContextAddr                        _nv_rmsym_01108
#define grInitRenderCommon                           _nv_rmsym_01109
#define grInvalidateVideoPatchcord                   _nv_rmsym_01110
#define grIsRenderObject                             _nv_rmsym_01111
#define grLoadPipeContext                            _nv_rmsym_01112
#define grResubmitVertexContextDma                   _nv_rmsym_01113
#define grService                                    _nv_rmsym_01114
#define grSetLastIllegalMthdObject                   _nv_rmsym_01115
#define grUnloadPipeContext                          _nv_rmsym_01116
#define grVBlank                                     _nv_rmsym_01117
#define grValidateVideoPatchcord                     _nv_rmsym_01118
#define grVideoSwitchComplete                        _nv_rmsym_01119
#define grWaitVBlank                                 _nv_rmsym_01120
#define heapAlloc                                    _nv_rmsym_01121
#define heapCompact                                  _nv_rmsym_01122
#define heapCreate                                   _nv_rmsym_01123
#define heapDestroy                                  _nv_rmsym_01124
#define heapDump                                     _nv_rmsym_01125
#define heapFree                                     _nv_rmsym_01126
#define heapGetBase                                  _nv_rmsym_01127
#define heapGetFree                                  _nv_rmsym_01128
#define heapGetMaxFree                               _nv_rmsym_01129
#define heapGetSize                                  _nv_rmsym_01130
#define heapInfo                                     _nv_rmsym_01131
#define heapPurge                                    _nv_rmsym_01132
#define heapValidate                                 _nv_rmsym_01133
#define i2cAccess                                    _nv_rmsym_01134
#define i2cAck                                       _nv_rmsym_01135
#define i2cHardwareInit                              _nv_rmsym_01136
#define i2cInit                                      _nv_rmsym_01137
#define i2cRead                                      _nv_rmsym_01138
#define i2cReadCRTCStatusIndex                       _nv_rmsym_01139
#define i2cReadCRTCWrIndex                           _nv_rmsym_01140
#define i2cReadCtrl                                  _nv_rmsym_01141
#define i2cRead_ALT                                  _nv_rmsym_01142
#define i2cRead_ALT2                                 _nv_rmsym_01143
#define i2cReceiveByte                               _nv_rmsym_01144
#define i2cSend                                      _nv_rmsym_01145
#define i2cSendByte                                  _nv_rmsym_01146
#define i2cStart                                     _nv_rmsym_01147
#define i2cStop                                      _nv_rmsym_01148
#define i2cWrite                                     _nv_rmsym_01149
#define i2cWriteCRTCWrIndex                          _nv_rmsym_01150
#define i2cWriteCtrl                                 _nv_rmsym_01151
#define i2cWrite_ALT                                 _nv_rmsym_01152
#define initClientInfo                               _nv_rmsym_01153
#define initDac                                      _nv_rmsym_01154
#define initDacEx                                    _nv_rmsym_01155
#define initDisplayInfo                              _nv_rmsym_01156
#define initDmaListElementPool                       _nv_rmsym_01157
#define initFb                                       _nv_rmsym_01158
#define initFbEx                                     _nv_rmsym_01159
#define initFifo                                     _nv_rmsym_01160
#define initFifoEx                                   _nv_rmsym_01161
#define initGrEx                                     _nv_rmsym_01162
#define initHal                                      _nv_rmsym_01163
#define initMapping                                  _nv_rmsym_01164
#define initMc                                       _nv_rmsym_01165
#define initRModeEx                                  _nv_rmsym_01166
#define initTmr                                      _nv_rmsym_01167
#define init_COMPUTE_Memory                          _nv_rmsym_01168
#define init_CONFIGURE_Clocks                        _nv_rmsym_01169
#define init_CONFIGURE_Memory                        _nv_rmsym_01170
#define init_CONFIGURE_PreInit                       _nv_rmsym_01171
#define init_INDEX_IO_Write                          _nv_rmsym_01172
#define init_MEM_RESTRICT_SCRIPT                     _nv_rmsym_01173
#define init_NV                                      _nv_rmsym_01174
#define init_PLL_Values                              _nv_rmsym_01175
#define init_Reset_Chip                              _nv_rmsym_01176
#define init_STRAP_RESTRICT_SCRIPT                   _nv_rmsym_01177
#define init_TIME_Delay                              _nv_rmsym_01178
#define init_ZM                                      _nv_rmsym_01179
#define init_ZMW                                     _nv_rmsym_01180
#define mcService                                    _nv_rmsym_01181
#define mcSetBiosRevision                            _nv_rmsym_01182
#define memTypeFlags                                 _nv_rmsym_01183
#define mpCreateObj                                  _nv_rmsym_01184
#define mpDestroyObj                                 _nv_rmsym_01185
#define mthdColormapDirtyLength                      _nv_rmsym_01186
#define mthdColormapDirtyNotify                      _nv_rmsym_01187
#define mthdColormapDirtyStart                       _nv_rmsym_01188
#define mthdCreate                                   _nv_rmsym_01189
#define mthdDestroy                                  _nv_rmsym_01190
#define mthdNoOperation                              _nv_rmsym_01191
#define mthdSetAlarmNotify                           _nv_rmsym_01192
#define mthdSetAlarmNotifyCtxDma                     _nv_rmsym_01193
#define mthdSetAlarmTime                             _nv_rmsym_01194
#define mthdSetBufferCtxDma                          _nv_rmsym_01195
#define mthdSetBufferLength                          _nv_rmsym_01196
#define mthdSetBufferNotify                          _nv_rmsym_01197
#define mthdSetBufferNotifyCount                     _nv_rmsym_01198
#define mthdSetBufferNotifyCtxDma                    _nv_rmsym_01199
#define mthdSetBufferPitch                           _nv_rmsym_01200
#define mthdSetBufferPosNotify                       _nv_rmsym_01201
#define mthdSetBufferPosNotifyCtxDma                 _nv_rmsym_01202
#define mthdSetBufferStart                           _nv_rmsym_01203
#define mthdSetColormapCtxDma                        _nv_rmsym_01204
#define mthdSetColormapFormat                        _nv_rmsym_01205
#define mthdSetColormapLength                        _nv_rmsym_01206
#define mthdSetColormapStart                         _nv_rmsym_01207
#define mthdSetDmaSpecifier                          _nv_rmsym_01208
#define mthdSetNotify                                _nv_rmsym_01209
#define mthdSetNotifyCtxDma                          _nv_rmsym_01210
#define mthdSetNumberChannels                        _nv_rmsym_01211
#define mthdSetObject                                _nv_rmsym_01212
#define mthdSetSampleRate                            _nv_rmsym_01213
#define mthdSetSampleRateAdjust                      _nv_rmsym_01214
#define mthdSetTime                                  _nv_rmsym_01215
#define mthdSetVideoInput                            _nv_rmsym_01216
#define mthdSetVideoOutput                           _nv_rmsym_01217

#define nopCreate                                    _nv_rmsym_01219
#define nopDelete                                    _nv_rmsym_01220
#define notifyBufferComplete                         _nv_rmsym_01221
#define notifyBufferHWComplete                       _nv_rmsym_01222
#define notifyDefaultError                           _nv_rmsym_01223
#define notifyFillNotifier                           _nv_rmsym_01224
#define notifyFillNotifierArray                      _nv_rmsym_01225
#define notifyMethodComplete                         _nv_rmsym_01226
#define notifySetBufferNotify                        _nv_rmsym_01227
#define notifySetBufferNotifyCtxDma                  _nv_rmsym_01228
#define nvClassEngineDescriptor                      _nv_rmsym_01229

#define nvHalDacAlloc                                _nv_rmsym_01231
#define nvHalDacAlloc_NV04                           _nv_rmsym_01232
#define nvHalDacAlloc_NV10                           _nv_rmsym_01233
#define nvHalDacControl                              _nv_rmsym_01234
#define nvHalDacControl_NV04                         _nv_rmsym_01235
#define nvHalDacControl_NV10                         _nv_rmsym_01236
#define nvHalDacFree                                 _nv_rmsym_01237
#define nvHalDacFree_NV04                            _nv_rmsym_01238
#define nvHalDacFree_NV10                            _nv_rmsym_01239
#define nvHalDacSetStartAddr                         _nv_rmsym_01240
#define nvHalDacSetStartAddr_NV04                    _nv_rmsym_01241
#define nvHalDacSetStartAddr_NV10                    _nv_rmsym_01242
#define nvHalDmaAlloc                                _nv_rmsym_01243
#define nvHalDmaAlloc_NV04                           _nv_rmsym_01244
#define nvHalDmaAlloc_NV10                           _nv_rmsym_01245
#define nvHalDmaControl                              _nv_rmsym_01246
#define nvHalDmaControl_NV04                         _nv_rmsym_01247
#define nvHalDmaControl_NV10                         _nv_rmsym_01248
#define nvHalDmaFree                                 _nv_rmsym_01249
#define nvHalDmaFree_NV04                            _nv_rmsym_01250
#define nvHalDmaFree_NV10                            _nv_rmsym_01251
#define nvHalDmaGetInstSize                          _nv_rmsym_01252
#define nvHalDmaGetInstSize_NV04                     _nv_rmsym_01253
#define nvHalDmaGetInstSize_NV10                     _nv_rmsym_01254
#define nvHalFbAlloc                                 _nv_rmsym_01255
#define nvHalFbAlloc_NV04                            _nv_rmsym_01256
#define nvHalFbAlloc_NV10                            _nv_rmsym_01257
#define nvHalFbControl                               _nv_rmsym_01258
#define nvHalFbControl_NV04                          _nv_rmsym_01259
#define nvHalFbControl_NV10                          _nv_rmsym_01260
#define nvHalFbFree                                  _nv_rmsym_01261
#define nvHalFbFree_NV04                             _nv_rmsym_01262
#define nvHalFbFree_NV10                             _nv_rmsym_01263
#define nvHalFbGetSurfacePitch                       _nv_rmsym_01264
#define nvHalFbGetSurfacePitch_NV04                  _nv_rmsym_01265
#define nvHalFbGetSurfacePitch_NV10                  _nv_rmsym_01266
#define nvHalFbRoundToTiledPitch_NV10                _nv_rmsym_01267
#define nvHalFbSetAllocParameters                    _nv_rmsym_01268
#define nvHalFbSetAllocParameters_NV04               _nv_rmsym_01269
#define nvHalFbSetAllocParameters_NV10               _nv_rmsym_01270
#define nvHalFifoAccess                              _nv_rmsym_01271
#define nvHalFifoAccess_NV04                         _nv_rmsym_01272
#define nvHalFifoAccess_NV10                         _nv_rmsym_01273
#define nvHalFifoAllocDma                            _nv_rmsym_01274
#define nvHalFifoAllocDma_NV04                       _nv_rmsym_01275
#define nvHalFifoAllocDma_NV10                       _nv_rmsym_01276
#define nvHalFifoAllocPio                            _nv_rmsym_01277
#define nvHalFifoAllocPio_NV04                       _nv_rmsym_01278
#define nvHalFifoAllocPio_NV10                       _nv_rmsym_01279
#define nvHalFifoContextSwitch_NV04                  _nv_rmsym_01280
#define nvHalFifoContextSwitch_NV10                  _nv_rmsym_01281
#define nvHalFifoControl                             _nv_rmsym_01282
#define nvHalFifoControl_NV04                        _nv_rmsym_01283
#define nvHalFifoControl_NV10                        _nv_rmsym_01284
#define nvHalFifoFree                                _nv_rmsym_01285
#define nvHalFifoFree_NV04                           _nv_rmsym_01286
#define nvHalFifoFree_NV10                           _nv_rmsym_01287
#define nvHalFifoGetExceptionData                    _nv_rmsym_01288
#define nvHalFifoGetExceptionData_NV04               _nv_rmsym_01289
#define nvHalFifoGetExceptionData_NV10               _nv_rmsym_01290
#define nvHalFifoHashAdd                             _nv_rmsym_01291
#define nvHalFifoHashAdd_NV04                        _nv_rmsym_01292
#define nvHalFifoHashAdd_NV10                        _nv_rmsym_01293
#define nvHalFifoHashDelete                          _nv_rmsym_01294
#define nvHalFifoHashDelete_NV04                     _nv_rmsym_01295
#define nvHalFifoHashDelete_NV10                     _nv_rmsym_01296
#define nvHalFifoHashFunc                            _nv_rmsym_01297
#define nvHalFifoHashFunc_NV04                       _nv_rmsym_01298
#define nvHalFifoHashFunc_NV10                       _nv_rmsym_01299
#define nvHalFifoService                             _nv_rmsym_01300
#define nvHalFifoService_NV04                        _nv_rmsym_01301
#define nvHalFifoService_NV10                        _nv_rmsym_01302
#define nvHalGrAlloc                                 _nv_rmsym_01303
#define nvHalGrAlloc_NV04                            _nv_rmsym_01304
#define nvHalGrAlloc_NV10                            _nv_rmsym_01305
#define nvHalGrControl                               _nv_rmsym_01306
#define nvHalGrControl_NV04                          _nv_rmsym_01307
#define nvHalGrControl_NV10                          _nv_rmsym_01308
#define nvHalGrFree                                  _nv_rmsym_01309
#define nvHalGrFree_NV04                             _nv_rmsym_01310
#define nvHalGrFree_NV10                             _nv_rmsym_01311
#define nvHalGrGetExceptionData                      _nv_rmsym_01312
#define nvHalGrGetExceptionData_NV04                 _nv_rmsym_01313
#define nvHalGrGetExceptionData_NV10                 _nv_rmsym_01314
#define nvHalGrGetNotifyData                         _nv_rmsym_01315
#define nvHalGrGetNotifyData_NV04                    _nv_rmsym_01316
#define nvHalGrGetNotifyData_NV10                    _nv_rmsym_01317
#define nvHalGrGetState_NV10                         _nv_rmsym_01318
#define nvHalGrLoadChannelContext_NV04               _nv_rmsym_01319
#define nvHalGrLoadChannelContext_NV10               _nv_rmsym_01320
#define nvHalGrMethods_NV04                          _nv_rmsym_01321
#define nvHalGrMethods_NV10                          _nv_rmsym_01322
#define nvHalGrPutState_NV10                         _nv_rmsym_01323
#define nvHalGrService                               _nv_rmsym_01324
#define nvHalGrService_NV04                          _nv_rmsym_01325
#define nvHalGrService_NV10                          _nv_rmsym_01326
#define nvHalGrSetMaterialEmission_NV10              _nv_rmsym_01327
#define nvHalGrSetObjectContext                      _nv_rmsym_01328
#define nvHalGrSetObjectContext_NV04                 _nv_rmsym_01329
#define nvHalGrSetObjectContext_NV10                 _nv_rmsym_01330
#define nvHalGrUnloadChannelContext_NV04             _nv_rmsym_01331
#define nvHalGrUnloadChannelContext_NV10             _nv_rmsym_01332
#define nvHalMcChipId                                _nv_rmsym_01333
#define nvHalMcChipId_NV04                           _nv_rmsym_01334
#define nvHalMcChipId_NV10                           _nv_rmsym_01335
#define nvHalMcControl                               _nv_rmsym_01336
#define nvHalMcControl_NV04                          _nv_rmsym_01337
#define nvHalMcControl_NV10                          _nv_rmsym_01338
#define nvHalMcPower                                 _nv_rmsym_01339
#define nvHalMcPower_NV04                            _nv_rmsym_01340
#define nvHalMcPower_NV10                            _nv_rmsym_01341
#define nvHalMpAlloc                                 _nv_rmsym_01342
#define nvHalMpAlloc_NV04                            _nv_rmsym_01343
#define nvHalMpAlloc_NV10                            _nv_rmsym_01344
#define nvHalMpControl                               _nv_rmsym_01345
#define nvHalMpControl_NV04                          _nv_rmsym_01346
#define nvHalMpControl_NV10                          _nv_rmsym_01347
#define nvHalMpFree                                  _nv_rmsym_01348
#define nvHalMpFree_NV04                             _nv_rmsym_01349
#define nvHalMpFree_NV10                             _nv_rmsym_01350
#define nvHalRmServiceIntr                           _nv_rmsym_01351
#define nvHalTetrisTileWrite_NV04                    _nv_rmsym_01352
#define nvHalTetrisTile_NV04                         _nv_rmsym_01353
#define nvHalVideoAlloc                              _nv_rmsym_01354
#define nvHalVideoAlloc_NV04                         _nv_rmsym_01355
#define nvHalVideoAlloc_NV10                         _nv_rmsym_01356
#define nvHalVideoControl                            _nv_rmsym_01357
#define nvHalVideoControl_NV04                       _nv_rmsym_01358
#define nvHalVideoControl_NV10                       _nv_rmsym_01359
#define nvHalVideoFree                               _nv_rmsym_01360
#define nvHalVideoFree_NV04                          _nv_rmsym_01361
#define nvHalVideoFree_NV10                          _nv_rmsym_01362
#define nvHalVideoGetExceptionData                   _nv_rmsym_01363
#define nvHalVideoGetExceptionData_NV04              _nv_rmsym_01364
#define nvHalVideoGetExceptionData_NV10              _nv_rmsym_01365
#define nvHalVideoMethod                             _nv_rmsym_01366
#define nvHalVideoMethod_NV04                        _nv_rmsym_01367
#define nvHalVideoMethod_NV10                        _nv_rmsym_01368
#define nvHalVideoService                            _nv_rmsym_01369
#define nvHalVideoService_NV04                       _nv_rmsym_01370
#define nvHalVideoService_NV10                       _nv_rmsym_01371
#define nvInfoSelector                               _nv_rmsym_01372
#define nvNoEngineDescriptor                         _nv_rmsym_01373


#define osAllocDmaListElement                        _nv_rmsym_01381
#define osAllocPages                                 _nv_rmsym_01382
#define osDeviceNameToDeviceClass                    _nv_rmsym_01383
#define osDisplayInfo                                _nv_rmsym_01384
#define osError                                      _nv_rmsym_01385
#define osFreeDmaListElement                         _nv_rmsym_01386
#define osFreePages                                  _nv_rmsym_01387
#define osInService                                  _nv_rmsym_01388
#define osIsr                                        _nv_rmsym_01389
#define osLockUserMem                                _nv_rmsym_01390
#define osMapFifo                                    _nv_rmsym_01391
#define osMapFrameBuffer                             _nv_rmsym_01392
#define osMapInstanceMemory                          _nv_rmsym_01393
#define osMapPciMemoryUser                           _nv_rmsym_01394
#define osNotifyAction                               _nv_rmsym_01395
#define osNotifyEvent                                _nv_rmsym_01396
#ifndef LINUX
#define osReadRegistryBinary                         _nv_rmsym_01397
#define osReadRegistryDword                          _nv_rmsym_01398
#endif
#define osSetVideoMode                               _nv_rmsym_01399
#define osStateFbEx                                  _nv_rmsym_01400
#define osUnlockUserMem                              _nv_rmsym_01401
#define osUnmapMemory                                _nv_rmsym_01402
#define osUnmapPciMemoryUser                         _nv_rmsym_01403
#define osVirtualToPhysicalAddr                      _nv_rmsym_01404
#ifndef LINUX
#define osWriteRegistryBinary                        _nv_rmsym_01405
#define osWriteRegistryDword                         _nv_rmsym_01406
#endif
#define pClient                                      _nv_rmsym_01407
#define rmInCallback                                 _nv_rmsym_01408
#define rmInSafeService                              _nv_rmsym_01409
#define rmInService                                  _nv_rmsym_01410
#define stateConfigGet                               _nv_rmsym_01411
#define stateConfigGetEx                             _nv_rmsym_01412
#define stateConfigSet                               _nv_rmsym_01413
#define stateConfigSetEx                             _nv_rmsym_01414
#define stateDac                                     _nv_rmsym_01415
#define stateDma                                     _nv_rmsym_01416
#define stateFb                                      _nv_rmsym_01417
#define stateFifo                                    _nv_rmsym_01418
#define stateGr                                      _nv_rmsym_01419
#define stateMc                                      _nv_rmsym_01420
#define stateMp                                      _nv_rmsym_01421
#define stateNv                                      _nv_rmsym_01422
#define stateSetMode                                 _nv_rmsym_01423
#define stateSetMode_DacClassStyle                   _nv_rmsym_01424
#define stateTmr                                     _nv_rmsym_01425
#define stateVideo                                   _nv_rmsym_01426
#define str1024                                      _nv_rmsym_01427
#define str1152                                      _nv_rmsym_01428
#define str1280                                      _nv_rmsym_01429
#define str1280x960                                  _nv_rmsym_01430
#define str1600                                      _nv_rmsym_01431
#define str1600x900                                  _nv_rmsym_01432
#define str1800                                      _nv_rmsym_01433
#define str1920x1080                                 _nv_rmsym_01434
#define str1920x1200                                 _nv_rmsym_01435
#define str1920x1440                                 _nv_rmsym_01436
#define str2048x1536                                 _nv_rmsym_01437
#define str640                                       _nv_rmsym_01438
#define str800                                       _nv_rmsym_01439
#define strDevNodeDisplayNumber                      _nv_rmsym_01440
#define strDevNodeRM                                 _nv_rmsym_01441
#define strDisableMPC                                _nv_rmsym_01442
#define strDisplayType                               _nv_rmsym_01443
#define strEnable256Burst                            _nv_rmsym_01444
#define strExternalSerialOnPrimary                   _nv_rmsym_01445
#define strFpMode                                    _nv_rmsym_01446
#define strMemoryOverride                            _nv_rmsym_01447
#define strPBUSOverride                              _nv_rmsym_01448
#define strRTLOverride                               _nv_rmsym_01449
#define strTVOutOnPrimary                            _nv_rmsym_01450
#define strTVOutType                                 _nv_rmsym_01451
#define strTVtype                                    _nv_rmsym_01452
#define strTilingOverride                            _nv_rmsym_01453
#define strUnderscanXOverride                        _nv_rmsym_01454
#define strUnderscanYOverride                        _nv_rmsym_01455
#define tetris_tile_table_signature                  _nv_rmsym_01456
#define tmrAlarmNotify                               _nv_rmsym_01457
#define tmrCancelCallback                            _nv_rmsym_01458
#define tmrCreateTimer                               _nv_rmsym_01459
#define tmrDefaultMethods                            _nv_rmsym_01460
#define tmrDelay                                     _nv_rmsym_01461
#define tmrDeleteContextTime                         _nv_rmsym_01462
#define tmrDeleteTimer                               _nv_rmsym_01463
#define tmrGetCurrentTime                            _nv_rmsym_01464
#define tmrMonthDays                                 _nv_rmsym_01465
#define tmrScheduleCallbackAbs                       _nv_rmsym_01466
#define tmrScheduleCallbackRel                       _nv_rmsym_01467
#define tmrService                                   _nv_rmsym_01468
#define tmrStopTransfer                              _nv_rmsym_01469
#define vblankProcessCallbacks                       _nv_rmsym_01470
#define videoAdjustScalarForTV_NV10                  _nv_rmsym_01471
#define videoConvertScaleFactor_NV04                 _nv_rmsym_01472
#define videoConvertScaleFactor_NV10                 _nv_rmsym_01473
#define videoCreateColorKeyObj                       _nv_rmsym_01474
#define videoCreateFromMemoryObj                     _nv_rmsym_01475
#define videoCreateObj                               _nv_rmsym_01476
#define videoCreateOverlayObj                        _nv_rmsym_01477
#define videoCreateScalerObj                         _nv_rmsym_01478
#define videoDestroyColorKeyObj                      _nv_rmsym_01479
#define videoDestroyFromMemoryObj                    _nv_rmsym_01480
#define videoDestroyObj                              _nv_rmsym_01481
#define videoDestroyOverlayObj                       _nv_rmsym_01482
#define videoDestroyScalerObj                        _nv_rmsym_01483
#define videoFromMemService                          _nv_rmsym_01484
#define videoGetExceptionData_NV10                   _nv_rmsym_01485
#define videoHwOwnsBuffer_NV10                       _nv_rmsym_01486
#define videoInit_NV04                               _nv_rmsym_01487
#define videoInit_NV10                               _nv_rmsym_01488
#define videoKickOffOverlay_NV10                     _nv_rmsym_01489
#define videoOverlayService                          _nv_rmsym_01490
#define videoService                                 _nv_rmsym_01491
#define videoService_NV10                            _nv_rmsym_01492
#define videoStopOverlay_NV10                        _nv_rmsym_01493
#define wGpo                                         _nv_rmsym_01494
#define wMaxWaitStates                               _nv_rmsym_01495
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\common\inc\nvutypes.h ===
#ifndef NVUTYPES_INCLUDED
#define NVUTYPES_INCLUDED
/*
 * nvutypes.h
 *
 * Copyright (C) 1995,1996 NVIDIA Corporation.
 *
 * This file contains unpacked types corresponding to the packed 32-bit 
 * types in <nv32.h>.  For example, the byte/bit alignment of Nvu1Pt16
 * is the same as required by renderSolidRectangle.Rectangle[0].y_x.
 *
 * If you want to manipulate elements smaller than 32 bits in your code, 
 * use these structures or define similar structures.  But when
 * you make assignments to hardware offsets in the NV Architecture,
 * you must use at least 32-bit wide quantities -- you must perform 
 * 32-bit writes.  You can cast these structures to 32 bits or combine
 * them in a union with pure 32-bit elements.
 *
 * An alternative to using these structures is to store values in your
 * own chosen format, and use the macros in <nvmacros.h> to assemble 
 * them into 32-bit values before writing to the chip.  But such macros 
 * take CPU cycles (except for constant values).
 */

/* Note that in the type names, "u" means unpacked, not "U" for unsigned". */

#ifndef NV32_INCLUDED
#include <nv32.h>                       /* for V008, U032, etc. typedefs */
#endif

typedef short	S016;

typedef struct {
	V008                c0;                               /*0000-0000*/
	V008                reserved01[0x003];                /*0001-0003*/
} Nvu1Color08;
typedef struct {
	V008                c0;                               /*0000-0000*/
	V008                c1;                               /*0001-0001*/
	V008                c2;                               /*0002-0002*/
	V008                c3;                               /*0003-0003*/
} Nvu4Color08;
typedef struct {
	V016                c0;                               /*0000-0001*/
	V016                reserved01[0x001];                /*0002-0003*/
} Nvu1Color16;
typedef struct {
	V016                c0;                               /*0000-0001*/
	V016                c1;                               /*0002-0003*/
} Nvu2Color16;
typedef struct {
	V032                c0;                               /*0000-0003*/
} Nvu1Color32;
typedef union {
	Nvu1Color08         v008;                             /*0000-0003*/
	Nvu1Color16         v016;                             /*0000-0003*/
	Nvu1Color32         v032;                             /*0000-0003*/
	V032                p;                                /*0000-0003*/
} Nvu1Color;

typedef union {
	Nvu4Color08         v_4_008;                          /*0000-0003*/
	Nvu2Color16         v_2_016;                          /*0000-0003*/
	Nvu1Color32         v_1_032;                          /*0000-0003*/
	Nvu1Color16         v_1_016;                          /*0000-0003*/
	Nvu1Color08         v_1_008;                          /*0000-0003*/
	V032                p;                                /*0000-0003*/
} NvuColor;

typedef struct {
	U016                fractHertz;                       /*0000-0001*/
	U016                intHertz;                         /*0002-0003*/
} NvuHertz;

typedef struct {
	U016                fractPart;                        /*0000-0001*/
	U016                intPart;                          /*0002-0003*/
} NvuFract;

typedef struct {
	S016                x;                                /*0000-0001*/
	S016                y;                                /*0002-0003*/
	U016                w;                                /*0004-0005*/
	U016                h;                                /*0006-0007*/
} NvuRect16;

typedef struct {
	S016                x;                                /*0000-0001*/
	S016                y;                                /*0002-0003*/
} Nvu1Pt16;

typedef struct {
	U016                w;                                /*0000-0001*/
	U016                h;                                /*0002-0003*/
} NvuDim16;

typedef struct {
	S016                x0;                               /*0000-0001*/
	S016                y0;                               /*0002-0003*/
	S016                x1;                               /*0004-0005*/
	S016                y1;                               /*0006-0007*/
} Nvu2Pt16;

typedef struct {
	S016                x0;                               /*0000-0001*/
	S016                y0;                               /*0002-0003*/
	S016                x1;                               /*0004-0005*/
	S016                y1;                               /*0006-0007*/
	S016                x2;                               /*0008-0009*/
	S016                y2;                               /*000a-000b*/
} Nvu3Pt16;

typedef struct {
	S016                x0;                               /*0000-0001*/
	S016                y0;                               /*0002-0003*/
	S016                x1;                               /*0004-0005*/
	S016                y1;                               /*0006-0007*/
	S016                x2;                               /*0008-0009*/
	S016                y2;                               /*000a-000b*/
	S016                x3;                               /*000c-000d*/
	S016                y3;                               /*000e-000f*/
} Nvu4Pt16;

typedef struct {
	S016                x0;                               /*0000-0001*/
	S016                y0;                               /*0002-0003*/
	S016                x1;                               /*0004-0005*/
	S016                y1;                               /*0006-0007*/
	S016                x2;                               /*0008-0009*/
	S016                y2;                               /*000a-000b*/
	S016                x3;                               /*000c-000d*/
	S016                y3;                               /*000e-000f*/
	S016                x4;                               /*0010-0011*/
	S016                y4;                               /*0012-0013*/
	S016                x5;                               /*0014-0015*/
	S016                y5;                               /*0016-0017*/
	S016                x6;                               /*0018-0019*/
	S016                y6;                               /*001a-001b*/
	S016                x7;                               /*001c-001d*/
	S016                y7;                               /*001e-001f*/
	S016                x8;                               /*0020-0021*/
	S016                y8;                               /*0022-0023*/
} Nvu9Pt16;


#endif /* NVUTYPES_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\common\inc\nvmath.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  NVIDIA, Corp. of Sunnyvale,  California owns     *|
|*     copyrights, patents, and has design patents pending on the design     *|
|*     and  interface  of the NV chips.   Users and  possessors  of this     *|
|*     source code are hereby granted a nonexclusive, royalty-free copy-     *|
|*     right  and design patent license  to use this code  in individual     *|
|*     and commercial software.                                              *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright  1993-1998  NVIDIA,  Corporation.   NVIDIA  has  design     *|
|*     patents and patents pending in the U.S. and foreign countries.        *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF THIS SOURCE CODE FOR ANY PURPOSE. IT IS PROVIDED "AS IS" WITH-     *|
|*     OUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPORATION     *|
|*     DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOURCE CODE, INCLUD-     *|
|*     ING ALL IMPLIED WARRANTIES  OF MERCHANTABILITY  AND FITNESS FOR A     *|
|*     PARTICULAR  PURPOSE.  IN NO EVENT  SHALL NVIDIA,  CORPORATION  BE     *|
|*     LIABLE FOR ANY SPECIAL,  INDIRECT,  INCIDENTAL,  OR CONSEQUENTIAL     *|
|*     DAMAGES, OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,     *|
|*     DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR     *|
|*     OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION  WITH THE     *|
|*     USE OR PERFORMANCE OF THIS SOURCE CODE.                               *|
|*                                                                           *|
|*     RESTRICTED RIGHTS LEGEND:  Use, duplication, or disclosure by the     *|
|*     Government is subject  to restrictions  as set forth  in subpara-     *|
|*     graph (c) (1) (ii) of the Rights  in Technical Data  and Computer     *|
|*     Software  clause  at DFARS  52.227-7013 and in similar clauses in     *|
|*     the FAR and NASA FAR Supplement.                                      *|
|*                                                                           *|
\***************************************************************************/

/*
* nvmath.h
*
* OS-independent math utility functions implemented
*
*/

#if !defined _NVMATH_H_
#define _NVMATH_H_

#include <math.h>


// most functions (sqrt, sin.. etc) can be used by turning
// intrinsic functions on (option /Oi)
// see... http://msdn.microsoft.com/library/devprods/vs6/visualc/vccore/_core_.2f.oi.htm
// not-true intrinsic functions are implemented here...

// /Og messes up the .NMS
#pragma optimize ("g", on)
// not required if i use /Oi
// #pragma intrinsic (exp, log)

__inline double r0_pow (double a, double u)
{
    if (a == 0.0)
        return 0.0;
    else if (u == 0.0)
        return 1.0;
    else
        return (exp(u*log(a)));
}

__inline double r0_sinh(double a)
{
    return (0.5*(exp(a)-exp(-a)));
}

static __inline long FTOL(float ftmp1)
{
    long lTemp1;

    __asm
    {
        fld ftmp1
        fistp lTemp1
    }
    return lTemp1;
}

static __inline long DTOL(double ftmp1)
{
    long lTemp1;

    __asm
    {
        fld ftmp1
        fistp lTemp1
    }
    return lTemp1;
}


#pragma optimize ("g", off)

#define pow(x,y)    r0_pow ((x),(y))
#define sinh(x)     r0_sinh((x))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\common\inc\nvcmrsvd.h ===
#ifndef _NVCMRSVD_H_
#define _NVCMRSVD_H_
 /***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif

#ifndef NVTYPES_INCLUDED
#include "nvtypes.h"
#endif

//------------------------------------------------------------------------------
// Configuration manager reserved properties.
//
// #define NV_CFGEX_RESERVED 150
//------------------------------------------------------------------------------

typedef struct
{
    U032   Property;
    U032 * In;
    U032 * Out;
} NV_CFGEX_RESERVED_PROPERTY;

enum
{
    // Register read and write.
     PROPERTY_REG_RD08              // In:[Offset]       Out:[Data]
    ,PROPERTY_REG_RD16              // In:[Offset]       Out:[Data]
    ,PROPERTY_REG_RD32              // In:[Offset]       Out:[Data]
    ,PROPERTY_REG_WR08              // In:[Offset, Data] Out:[]
    ,PROPERTY_REG_WR16              // In:[Offset, Data] Out:[]
    ,PROPERTY_REG_WR32              // In:[Offset, Data] Out:[]

    // Frame buffer read and write.
    ,PROPERTY_FB_RD08               // In:[Offset]       Out:[Data]
    ,PROPERTY_FB_RD16               // In:[Offset]       Out:[Data]
    ,PROPERTY_FB_RD32               // In:[Offset]       Out:[Data]
    ,PROPERTY_FB_WR08               // In:[Offset, Data] Out:[]
    ,PROPERTY_FB_WR16               // In:[Offset, Data] Out:[]
    ,PROPERTY_FB_WR32               // In:[Offset, Data] Out:[]

    // PCI read and write.
    ,PROPERTY_PCI_RD08              // In:[Bus, Device, Function, Offset]       Out:[Data]
    ,PROPERTY_PCI_RD16              // In:[Bus, Device, Function, Offset]       Out:[Data]
    ,PROPERTY_PCI_RD32              // In:[Bus, Device, Function, Offset]       Out:[Data]
    ,PROPERTY_PC