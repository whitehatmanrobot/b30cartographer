LETE );
		}

		/// <summary>
		/// VerifyOwnership:  determines if a packet belongs to the test case.
		/// </summary>
		/// <param name="id">byte array of id to check</param>
		/// <returns>true if the id belongs to this test case.</returns>
		public override bool VerifyOwnership( byte[] id )
		{
			return true;
		}



		/// <summary>
		/// Result:  The final result of the test case...  set to false if not complete.
		///     0 -- failed.
		///     1 -- passed.
		/// </summary>
		public override int Result
		{
			get
			{
				if ( _state == TEST_STATE.COMPLETE )
				{
					return _result;
				}
				else
				{
					return 0;
				}
			}
		}

		public int SiteId
		{
			get
			{
				return _siteId;
			}
			set
			{
				_siteId = value;
			}            
		}

		// ----------------------------------
		//  Members
		// ----------------------------------
		protected TEST_STATE        _state;
		protected string            _url;
		protected int               _siteId;

	}


	/// <summary>
	/// TestGetSitePUIDs:  Tests the lookup puid call to the live proxy.
	/// </summary>
	public class TestGetSitePUIDs: TestCase
	{
		// ----------------------------------
		//  Constant
		// ----------------------------------

		// ----------------------------------
		//  Methods
		// ----------------------------------
		public TestGetSitePUIDs( string httpserver )
		{
			_url = "http://" + httpserver + "/LiveProxy/getsitepuids.aspx";

			_result = 0;
			_resultstring = "";
		}

		/// <summary>
		/// Run:  start, execute the test case.
		/// </summary>
		public override void Run()
		{

			byte[] data = new byte[0];

			byte[] resp = _wc.UploadData( _url, data );

			MemoryStream ms = new MemoryStream( resp );
			BinaryReader br = new BinaryReader( ms );

			ulong machinepuid = br.ReadUInt64();
			ulong userpuid = br.ReadUInt64();

			_resultstring = "Response received: \n";
                
			// print out the results.
			foreach ( string s in _wc.ResponseHeaders )
			{
				_resultstring += s + " = " + (_wc.ResponseHeaders.GetValues( s ))[0] + " \n";
			}

			_resultstring += "MachinePUID: 0x" + machinepuid.ToString("X") + ", UserPUID: 0x" + userpuid.ToString("X");
			_state = TEST_STATE.COMPLETE;
			br.Close();

		}

		/// <summary>
		/// Process:  Takes a given packet returning true if it belongs to this case.
		/// </summary>
		public override bool Process( Object data )
		{
			bool result = true;

			// if it does...  determine our state.
			switch( _state )
			{
				case TEST_STATE.COMPLETE:
				{
				}
					break;
				case TEST_STATE.NONE:
				case TEST_STATE.WAITING_RESPONSE:
				default:
				{
					throw new Exception( "Invalid state." );
				}
			}

			return result;
		}

		/// <summary>
		/// IsComplete:  True if test case complete.
		/// </summary>
		/// <returns>Whether operation is complete or not.</returns>
		public override bool IsComplete()
		{
			return ( _state == TEST_STATE.COMPLETE );
		}

		/// <summary>
		/// VerifyOwnership:  determines if a packet belongs to the test case.
		/// </summary>
		/// <param name="id">byte array of id to check</param>
		/// <returns>true if the id belongs to this test case.</returns>
		public override bool VerifyOwnership( byte[] id )
		{
			return true;
		}



		/// <summary>
		/// Result:  The final result of the test case...  set to false if not complete.
		///     0 -- failed.
		///     1 -- passed.
		/// </summary>
		public override int Result
		{
			get
			{
				if ( _state == TEST_STATE.COMPLETE )
				{
					return _result;
				}
				else
				{
					return 0;
				}
			}
		}


		// ----------------------------------
		//  Members
		// ----------------------------------
		protected TEST_STATE        _state;
		protected string            _url;

	}


	/// <summary>
	/// TestLookupPUID:  Tests the lookup puid call to the live proxy.
	/// </summary>
	public class TestLookupPUID: TestCase
	{
		// ----------------------------------
		//  Constant
		// ----------------------------------

		// ----------------------------------
		//  Methods
		// ----------------------------------
		public TestLookupPUID( string httpserver)
		{
			_url = "http://" + httpserver + "/LiveProxy/lookuppuid.aspx";

			_result = 0;
			_resultstring = "";
		}
		
		public TestLookupPUID( string httpserver, uint numPUIDs )
		{
			_url = "http://" + httpserver + "/LiveProxy/lookuppuid.aspx";

			_result = 0;
			_resultstring = "";
			_puidInfo = new PUIDInfo(numPUIDs);
		}

		/// <summary>
		/// Run:  start, execute the test case.
		/// </summary>
		public override void Run()
		{		
			byte[] data = _puidInfo.GetBinary();
			
			byte[] resp = _wc.UploadData( _url,"POST", data );

			GamerTagInfo gti = new GamerTagInfo();
			gti.ReadBinary( resp );

			_resultstring = "Response received: \n";
                
			// print out the results.
			foreach ( string s in _wc.ResponseHeaders )
			{
				_resultstring += s + " = " + (_wc.ResponseHeaders.GetValues( s ))[0] + " \n";
			}

			_resultstring += gti.ToString();
			_state = TEST_STATE.COMPLETE;

		}

		/// <summary>
		/// Run:  start, execute the test case.
		/// </summary>
		public void RunNull()
		{
			byte[] data = new byte[0];
			
			byte[] resp = _wc.UploadData( _url,"POST", data );

			GamerTagInfo gti = new GamerTagInfo();
			gti.ReadBinary( resp );

			_resultstring = "Response received: \n";
                
			// print out the results.
			foreach ( string s in _wc.ResponseHeaders )
			{
				_resultstring += s + " = " + (_wc.ResponseHeaders.GetValues( s ))[0] + " \n";
			}

			_resultstring += gti.ToString();
			_state = TEST_STATE.COMPLETE;

		}

		/// <summary>
		/// Process:  Takes a given packet returning true if it belongs to this case.
		/// </summary>
		public override bool Process( Object data )
		{
			bool result = true;

			// if it does...  determine our state.
			switch( _state )
			{
				case TEST_STATE.COMPLETE:
				{
				}
					break;
				case TEST_STATE.NONE:
				case TEST_STATE.WAITING_RESPONSE:
				default:
				{
					throw new Exception( "Invalid state." );
				}
			}

			return result;
		}

		/// <summary>
		/// IsComplete:  True if test case complete.
		/// </summary>
		/// <returns>Whether operation is complete or not.</returns>
		public override bool IsComplete()
		{
			return ( _state == TEST_STATE.COMPLETE );
		}

		/// <summary>
		/// VerifyOwnership:  determines if a packet belongs to the test case.
		/// </summary>
		/// <param name="id">byte array of id to check</param>
		/// <returns>true if the id belongs to this test case.</returns>
		public override bool VerifyOwnership( byte[] id )
		{
			return true;
		}



		/// <summary>
		/// Result:  The final result of the test case...  set to false if not complete.
		///     0 -- failed.
		///     1 -- passed.
		/// </summary>
		public override int Result
		{
			get
			{
				if ( _state == TEST_STATE.COMPLETE )
				{
					return _result;
				}
				else
				{
					return 0;
				}
			}
		}

		public void AddPUID( ulong puid )
		{
			_puidInfo.AddPUID( puid );
		}

		public int NumberOfPUIDs
		{
			get
			{
				return (int)_puidInfo.Count;
			}
			set
			{
				_puidInfo = new PUIDInfo( (uint)value );
			}            
		}

		// ----------------------------------
		//  Members
		// ----------------------------------
		protected TEST_STATE        _state;
		protected string            _url;
		protected PUIDInfo          _puidInfo;

	}


	/// <summary>
	/// TestLookupGamerTag:  Tests the lookup gamertag call to the live proxy.
	/// </summary>
	public class TestLookupGamerTag: TestCase
	{
		// ----------------------------------
		//  Constant
		// ----------------------------------

		// ----------------------------------
		//  Methods
		// ----------------------------------
		public TestLookupGamerTag( string httpserver )
		{
			_url = "http://" + httpserver + "/LiveProxy/lookupgamertag.aspx";

			_result = 0;
			_resultstring = "";
			
		}

		public TestLookupGamerTag( string httpserver, uint numGamerTags )
		{
			_url = "http://" + httpserver + "/LiveProxy/lookupgamertag.aspx";

			_result = 0;
			_resultstring = "";
			_gtInfo = new GamerTagInfo(numGamerTags);	
		}
		

		/// <summary>
		/// Run:  start, execute the test case.
		/// </summary>
		public override void Run()
		{
			byte[] data = _gtInfo.GetBinary();

			byte[] resp = _wc.UploadData( _url, "POST", data );

			PUIDInfo pi = new PUIDInfo();
			pi.ReadBinary( resp );

			_resultstring = "Response received: \n";
                
			// print out the results.
			foreach ( string s in _wc.ResponseHeaders )
			{
				_resultstring += s + " = " + (_wc.ResponseHeaders.GetValues( s ))[0] + " \n";
			}

			_resultstring += pi.ToString();
			_state = TEST_STATE.COMPLETE;
		}

		/// <summary>
		/// Process:  Takes a given packet returning true if it belongs to this case.
		/// </summary>
		public override bool Process( Object data )
		{
			bool result = true;

			// if it does...  determine our state.
			switch( _state )
			{
				case TEST_STATE.COMPLETE:
				{
				}
					break;
				case TEST_STATE.NONE:
				case TEST_STATE.WAITING_RESPONSE:
				default:
				{
					throw new Exception( "Invalid state." );
				}
			}

			return result;
		}

		/// <summary>
		/// IsComplete:  True if test case complete.
		/// </summary>
		/// <returns>Whether operation is complete or not.</returns>
		public override bool IsComplete()
		{
			return ( _state == TEST_STATE.COMPLETE );
		}

		/// <summary>
		/// VerifyOwnership:  determines if a packet belongs to the test case.
		/// </summary>
		/// <param name="id">byte array of id to check</param>
		/// <returns>true if the id belongs to this test case.</returns>
		public override bool VerifyOwnership( byte[] id )
		{
			return true;
		}



		/// <summary>
		/// Result:  The final result of the test case...  set to false if not complete.
		///     0 -- failed.
		///     1 -- passed.
		/// </summary>
		public override int Result
		{
			get
			{
				if ( _state == TEST_STATE.COMPLETE )
				{
					return _result;
				}
				else
				{
					return 0;
				}
			}
		}

		public void AddGamerTag( string gamertag )
		{
			_gtInfo.AddGamerTag( gamertag );
		}

		public int NumberOfGamerTags
		{
			get
			{
				return (int)_gtInfo.Count;
			}
			set
			{
				_gtInfo = new GamerTagInfo( (uint)value );
			}            
		}

		// ----------------------------------
		//  Members
		// ----------------------------------
		protected TEST_STATE        _state;
		protected string            _url;
		protected GamerTagInfo      _gtInfo;

	}


	public class LSPTestSuite
	{
		public void LoadConfig( string xmlCfgFileName )
		{
			XmlDocument cfg = new XmlDocument();
			int nCount = 0;

			//Load the the document with the last book node.
			XmlTextReader reader = new XmlTextReader( xmlCfgFileName );
			reader.WhitespaceHandling = WhitespaceHandling.None;
			reader.MoveToContent();
			cfg.Load(reader);
			XmlElement docElement = cfg.DocumentElement;

			// this is the node which hold the http server we want to connect to.
			XmlNodeList nl = docElement.SelectNodes( "//LivePxyTest/server" );

			// Get the http server we want to talk to.
			_httpserver = (nl[0].Attributes.GetNamedItem("value")).Value;

			nl = docElement.SelectNodes( "//LivePxyTest/test/case" );
            
			// create the number of test cases we'll be using...
			_tests = new TestCase[nl.Count];
			foreach( XmlNode xn in nl )
			{
				TestCase newcase = null;
				switch( xn.Attributes.GetNamedItem("type").Value )
				{
					case "1":
					{
						TestForwardRequest tfr = new TestForwardRequest( _httpserver );
                            
						tfr.XRL = xn.Attributes.GetNamedItem("xrl").Value;
						tfr.Body = xn.Attributes.GetNamedItem("body").Value;

						newcase = (TestCase)tfr;
					}
						break;
					case "2":
					{
						TestGetSiteInfo tgsi = new TestGetSiteInfo( _httpserver );
                            
						tgsi.SiteId = Int32.Parse( xn.Attributes.GetNamedItem("siteid").Value );

						newcase = (TestCase)tgsi;
					}
						break;
					case "3":
					{
						TestLookupPUID tlp = new TestLookupPUID( _httpserver );

						tlp.NumberOfPUIDs = Int32.Parse( xn.Attributes.GetNamedItem("numberofpuids").Value );

						// look at all the child nodes.
						foreach ( XmlNode xchild in xn.ChildNodes )
						{
							tlp.AddPUID( UInt64.Parse(xchild.Attributes.GetNamedItem("value").Value) );
						}

						newcase = (TestCase)tlp;
					}
						break;
					case "4":
					{
						TestLookupGamerTag tlgt = new TestLookupGamerTag( _httpserver );

						tlgt.NumberOfGamerTags = Int32.Parse( xn.Attributes.GetNamedItem("numberofgamertags").Value );

						// look at all the child nodes.
						foreach ( XmlNode xchild in xn.ChildNodes )
						{
							tlgt.AddGamerTag( xchild.Attributes.GetNamedItem("value").Value );
						}

						newcase = (TestCase)tlgt;
					}
						break;
					default:
					{
						throw new Exception("LivePxyTest:  XML file contains invalid test case type.");
					}
				}

				_tests[nCount] = newcase;

				nCount++;
			}
        
		}

		public TestCase[] _tests;
		protected string     _httpserver;

		private const string http_request_header = "POST /liveproxy/forwardrequest.aspx HTTP/1.0\r\nAccept: */*\r\nUser-Agent: httppost\r\nHost: UdpSender\r\nxrl: value\r\n\r\n";
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\LiveProxy\test\dvt\TestCase.cs ===
using System;
using System.Text;
using System.Collections;
using System.Net;
using System.Net.Sockets;
using System.IO;


namespace xonline.server.webcache.liveproxy.test.dvt 
{
    /// <summary>
    /// UdpsTestCase:  The base class for the test cases used by xdtool.
    /// </summary>
    public class TestCase : Object
    {
        // ----------------------------------
        //  Constants
        // ----------------------------------

        // ----------------------------------
        //  Type
        // ----------------------------------
        protected enum TEST_STATE
        {
            NONE                = 0,
            COMPLETE            = 1,
            WAITING_RESPONSE    = 2,
        };

        // ----------------------------------
        //  Methods
        // ----------------------------------
        public TestCase()
        {
            _resultstring = "Invalid";
        }

        /// <summary>
        /// Run:  executes the test case.  Should be overridden.
        /// </summary>
        public virtual void Run()
        {
            // override this method executing
            throw new Exception( "Method not supported." );
        }

        /// <summary>
        /// Process:  Takes a given packet returning true if it belongs to this case.
        /// </summary>
        public virtual bool Process( Object packet )
        {
            // override this method executing
            throw new Exception( "Method not supported." );
        }

        /// <summary>
        /// VerifyOwnership:  determines if a packet belongs to the test case.
        /// </summary>
        /// <param name="id">byte array of id to check</param>
        /// <returns>true if the id belongs to this test case.</returns>
        public virtual bool VerifyOwnership( byte[] id )
        {
            // override this method executing
            throw new Exception( "Method not supported." );
        }

        /// <summary>
        /// IsComplete:  (Should be overridden) True if test case complete.
        /// </summary>
        /// <returns>Whether operation is complete or not.</returns>
        public virtual bool IsComplete()
        {
            throw new Exception("Please implement this function.");
        }

        /// <summary>
        /// Result:  The final result of the test case...  set to false if not complete.
        /// </summary>
        public virtual int Result
        {
            get
            {
                return _result;
            }
        }


        /// <summary>
        /// ToString:  returns the result string for this entry.
        /// </summary>
        public override string ToString()
        {
            return _resultstring;
        }



        // ----------------------------------
        //  Members
        // ----------------------------------
        protected int       _result;
        protected string    _resultstring;
    }

    /// <summary>
    /// TestForwardRequest:  .
    /// </summary>
    public class TestForwardRequest: TestCase
    {
        // ----------------------------------
        //  Constant
        // ----------------------------------

        // ----------------------------------
        //  Methods
        // ----------------------------------
        public TestForwardRequest( string httpserver )
        {
            _url = "http://" + httpserver + "/LiveProxy/forwardrequest.aspx";

            _body = "";
            _xrl = "";
            _result = 0;
            _resultstring = "";
        }

        /// <summary>
        /// Run:  start, execute the test case.
        /// </summary>
        public override void Run()
        {
            byte[] data = System.Text.ASCIIEncoding.ASCII.GetBytes(_body);
            WebClient wc = new WebClient();

            // add the necessary headers.
            wc.Headers.Add( "xrl", _xrl );
            wc.Headers.Add("Content-Type", "xon/6");
            wc.Headers.Add("User-Agent", "6/1.00.65535");

            byte[] resp = wc.UploadData( _url, data );

            _resultstring = "Response received: \n";
                
            // print out the results.
            foreach ( string s in wc.ResponseHeaders )
            {
                _resultstring += s + " = " + (wc.ResponseHeaders.GetValues( s ))[0] + " \n";
            }
            _resultstring = System.Text.ASCIIEncoding.ASCII.GetString( resp );
            _state = TEST_STATE.COMPLETE;

        }

        /// <summary>
        /// Process:  Takes a given packet returning true if it belongs to this case.
        /// </summary>
        public override bool Process( Object data )
        {
            bool result = true;

            // if it does...  determine our state.
            switch( _state )
            {
                case TEST_STATE.COMPLETE:
                {
                }
                    break;
                case TEST_STATE.NONE:
                case TEST_STATE.WAITING_RESPONSE:
                default:
                {
                    throw new Exception( "Invalid state." );
                }
            }

                return result;
        }

        /// <summary>
        /// IsComplete:  True if test case complete.
        /// </summary>
        /// <returns>Whether operation is complete or not.</returns>
        public override bool IsComplete()
        {
            return ( _state == TEST_STATE.COMPLETE );
        }

        /// <summary>
        /// VerifyOwnership:  determines if a packet belongs to the test case.
        /// </summary>
        /// <param name="id">byte array of id to check</param>
        /// <returns>true if the id belongs to this test case.</returns>
        public override bool VerifyOwnership( byte[] id )
        {
            return true;
        }



        /// <summary>
        /// Result:  The final result of the test case...  set to false if not complete.
        ///     0 -- failed.
        ///     1 -- passed.
        /// </summary>
        public override int Result
        {
            get
            {
                if ( _state == TEST_STATE.COMPLETE )
                {
                    return _result;
                }
                else
                {
                    return 0;
                }
            }
        }

        public string XRL
        {
            get
            {
                return _xrl;
            }
            set
            {
                _xrl = value;
            }            
        }

        public string Body
        {
            get
            {
                return _body;
            }
            set
            {
                _body = value;
            }            
        }

        // ----------------------------------
        //  Members
        // ----------------------------------
        protected TEST_STATE        _state;
        protected string            _url;
        protected string            _body;
        protected string            _xrl;

    }

    /// <summary>
    /// TestGetSiteInfo:  Tests the site info call to the live proxy.
    /// </summary>
    public class TestGetSiteInfo: TestCase
    {
        // ----------------------------------
        //  Constant
        // ----------------------------------

        // ----------------------------------
        //  Methods
        // ----------------------------------
        public TestGetSiteInfo( string httpserver )
        {
            _url = "http://" + httpserver + "/LiveProxy/getsiteinfo.aspx";

            _siteId = 0;
            _result = 0;
            _resultstring = "";
        }

        /// <summary>
        /// Run:  start, execute the test case.
        /// </summary>
        public override void Run()
        {
            byte[] data = System.BitConverter.GetBytes( _siteId );
            WebClient wc = new WebClient();

            wc.Headers.Add("Content-Type", "xon/0");
            wc.Headers.Add("User-Agent", "0/1.00.65535");

            byte[] resp = wc.UploadData( _url, data );

            SiteInfoReply sir = new SiteInfoReply();
            sir.ReadBinary( resp );

            _resultstring = "Response received: \n";
                
            // print out the results.
            foreach ( string s in wc.ResponseHeaders )
            {
                _resultstring += s + " = " + (wc.ResponseHeaders.GetValues( s ))[0] + " \n";
            }

            _resultstring += sir.ToString();
            _state = TEST_STATE.COMPLETE;

        }

        /// <summary>
        /// Process:  Takes a given packet returning true if it belongs to this case.
        /// </summary>
        public override bool Process( Object data )
        {
            bool result = true;

            // if it does...  determine our state.
            switch( _state )
            {
                case TEST_STATE.COMPLETE:
                {
                }
                    break;
                case TEST_STATE.NONE:
                case TEST_STATE.WAITING_RESPONSE:
                default:
                {
                    throw new Exception( "Invalid state." );
                }
            }

                return result;
        }

        /// <summary>
        /// IsComplete:  True if test case complete.
        /// </summary>
        /// <returns>Whether operation is complete or not.</returns>
        public override bool IsComplete()
        {
            return ( _state == TEST_STATE.COMPLETE );
        }

        /// <summary>
        /// VerifyOwnership:  determines if a packet belongs to the test case.
        /// </summary>
        /// <param name="id">byte array of id to check</param>
        /// <returns>true if the id belongs to this test case.</returns>
        public override bool VerifyOwnership( byte[] id )
        {
            return true;
        }



        /// <summary>
        /// Result:  The final result of the test case...  set to false if not complete.
        ///     0 -- failed.
        ///     1 -- passed.
        /// </summary>
        public override int Result
        {
            get
            {
                if ( _state == TEST_STATE.COMPLETE )
                {
                    return _result;
                }
                else
                {
                    return 0;
                }
            }
        }

        public int SiteId
        {
            get
            {
                return _siteId;
            }
            set
            {
                _siteId = value;
            }            
        }

        // ----------------------------------
        //  Members
        // ----------------------------------
        protected TEST_STATE        _state;
        protected string            _url;
        protected int               _siteId;

    }

    /// <summary>
    /// TestLookupPUID:  Tests the lookup puid call to the live proxy.
    /// </summary>
    public class TestLookupPUID: TestCase
    {
        // ----------------------------------
        //  Constant
        // ----------------------------------

        // ----------------------------------
        //  Methods
        // ----------------------------------
        public TestLookupPUID( string httpserver )
        {
            _url = "http://" + httpserver + "/LiveProxy/lookuppuid.aspx";

            _result = 0;
            _resultstring = "";
        }

        /// <summary>
        /// Run:  start, execute the test case.
        /// </summary>
        public override void Run()
        {
            byte[] data = _puidInfo.GetBinary();
            WebClient wc = new WebClient();

            wc.Headers.Add("Content-Type", "xon/0");
            wc.Headers.Add("User-Agent", "0/1.00.65535");

            byte[] resp = wc.UploadData( _url, data );

            GamerTagInfo gti = new GamerTagInfo();
            gti.ReadBinary( resp );

            _resultstring = "Response received: \n";
                
            // print out the results.
            foreach ( string s in wc.ResponseHeaders )
            {
                _resultstring += s + " = " + (wc.ResponseHeaders.GetValues( s ))[0] + " \n";
            }

            _resultstring += gti.ToString();
            _state = TEST_STATE.COMPLETE;

        }

        /// <summary>
        /// Process:  Takes a given packet returning true if it belongs to this case.
        /// </summary>
        public override bool Process( Object data )
        {
            bool result = true;

            // if it does...  determine our state.
            switch( _state )
            {
                case TEST_STATE.COMPLETE:
                {
                }
                    break;
                case TEST_STATE.NONE:
                case TEST_STATE.WAITING_RESPONSE:
                default:
                {
                    throw new Exception( "Invalid state." );
                }
            }

                return result;
        }

        /// <summary>
        /// IsComplete:  True if test case complete.
        /// </summary>
        /// <returns>Whether operation is complete or not.</returns>
        public override bool IsComplete()
        {
            return ( _state == TEST_STATE.COMPLETE );
        }

        /// <summary>
        /// VerifyOwnership:  determines if a packet belongs to the test case.
        /// </summary>
        /// <param name="id">byte array of id to check</param>
        /// <returns>true if the id belongs to this test case.</returns>
        public override bool VerifyOwnership( byte[] id )
        {
            return true;
        }



        /// <summary>
        /// Result:  The final result of the test case...  set to false if not complete.
        ///     0 -- failed.
        ///     1 -- passed.
        /// </summary>
        public override int Result
        {
            get
            {
                if ( _state == TEST_STATE.COMPLETE )
                {
                    return _result;
                }
                else
                {
                    return 0;
                }
            }
        }

        public void AddPUID( ulong puid )
        {
            _puidInfo.AddPUID( puid );
        }

        public int NumberOfPUIDs
        {
            get
            {
                return (int)_puidInfo.Count;
            }
            set
            {
                _puidInfo = new PUIDInfo( (uint)value );
            }            
        }

        // ----------------------------------
        //  Members
        // ----------------------------------
        protected TEST_STATE        _state;
        protected string            _url;
        protected PUIDInfo          _puidInfo;

    }

    /// <summary>
    /// TestLookupGamerTag:  Tests the lookup gamertag call to the live proxy.
    /// </summary>
    public class TestLookupGamerTag: TestCase
    {
        // ----------------------------------
        //  Constant
        // ----------------------------------

        // ----------------------------------
        //  Methods
        // ----------------------------------
        public TestLookupGamerTag( string httpserver )
        {
            _url = "http://" + httpserver + "/LiveProxy/lookupgamertag.aspx";

            _result = 0;
            _resultstring = "";
        }

        /// <summary>
        /// Run:  start, execute the test case.
        /// </summary>
        public override void Run()
        {
            byte[] data = _gtInfo.GetBinary();
            WebClient wc = new WebClient();

            wc.Headers.Add("Content-Type", "xon/0");
            wc.Headers.Add("User-Agent", "0/1.00.65535");

            byte[] resp = wc.UploadData( _url, data );

            PUIDInfo pi = new PUIDInfo();
            pi.ReadBinary( resp );

            _resultstring = "Response received: \n";
                
            // print out the results.
            foreach ( string s in wc.ResponseHeaders )
            {
                _resultstring += s + " = " + (wc.ResponseHeaders.GetValues( s ))[0] + " \n";
            }

            _resultstring += pi.ToString();
            _state = TEST_STATE.COMPLETE;

        }

        /// <summary>
        /// Process:  Takes a given packet returning true if it belongs to this case.
        /// </summary>
        public override bool Process( Object data )
        {
            bool result = true;

            // if it does...  determine our state.
            switch( _state )
            {
                case TEST_STATE.COMPLETE:
                {
                }
                    break;
                case TEST_STATE.NONE:
                case TEST_STATE.WAITING_RESPONSE:
                default:
                {
                    throw new Exception( "Invalid state." );
                }
            }

                return result;
        }

        /// <summary>
        /// IsComplete:  True if test case complete.
        /// </summary>
        /// <returns>Whether operation is complete or not.</returns>
        public override bool IsComplete()
        {
            return ( _state == TEST_STATE.COMPLETE );
        }

        /// <summary>
        /// VerifyOwnership:  determines if a packet belongs to the test case.
        /// </summary>
        /// <param name="id">byte array of id to check</param>
        /// <returns>true if the id belongs to this test case.</returns>
        public override bool VerifyOwnership( byte[] id )
        {
            return true;
        }



        /// <summary>
        /// Result:  The final result of the test case...  set to false if not complete.
        ///     0 -- failed.
        ///     1 -- passed.
        /// </summary>
        public override int Result
        {
            get
            {
                if ( _state == TEST_STATE.COMPLETE )
                {
                    return _result;
                }
                else
                {
                    return 0;
                }
            }
        }

        public void AddGamerTag( string gamertag )
        {
            _gtInfo.AddGamerTag( gamertag );
        }

        public int NumberOfGamerTags
        {
            get
            {
                return (int)_gtInfo.Count;
            }
            set
            {
                _gtInfo = new GamerTagInfo( (uint)value );
            }            
        }

        // ----------------------------------
        //  Members
        // ----------------------------------
        protected TEST_STATE        _state;
        protected string            _url;
        protected GamerTagInfo      _gtInfo;

    }
    
    /// <summary>
    /// TestGetSitePUIDs:  Tests the lookup puid call to the live proxy.
    /// </summary>
    public class TestGetSitePUIDs: TestCase
    {
        // ----------------------------------
        //  Constant
        // ----------------------------------

        // ----------------------------------
        //  Methods
        // ----------------------------------
        public TestGetSitePUIDs( string httpserver )
        {
            _url = "http://" + httpserver + "/LiveProxy/getsitepuids.aspx";

            _result = 0;
            _resultstring = "";
        }

        /// <summary>
        /// Run:  start, execute the test case.
        /// </summary>
        public override void Run()
        {
            WebClient wc = new WebClient();
            byte[] data = new byte[0];

            wc.Headers.Add("Content-Type", "xon/0");
            wc.Headers.Add("User-Agent", "0/1.00.65535");
            wc.Headers.Add("Subject-Name", _subjectName );

            byte[] resp = wc.UploadData( _url, data );

            MemoryStream ms = new MemoryStream( resp );
            BinaryReader br = new BinaryReader( ms );

            ulong machinepuid = br.ReadUInt64();
            ulong userpuid = br.ReadUInt64();

            _resultstring = "Response received: \n";
                
            // print out the results.
            foreach ( string s in wc.ResponseHeaders )
            {
                _resultstring += s + " = " + (wc.ResponseHeaders.GetValues( s ))[0] + " \n";
            }

            _resultstring += "MachinePUID: 0x" + machinepuid.ToString("X") + ", UserPUID: 0x" + userpuid.ToString("X");
            _state = TEST_STATE.COMPLETE;
            br.Close();

        }

        /// <summary>
        /// Process:  Takes a given packet returning true if it belongs to this case.
        /// </summary>
        public override bool Process( Object data )
        {
            bool result = true;

            // if it does...  determine our state.
            switch( _state )
            {
                case TEST_STATE.COMPLETE:
                {
                }
                    break;
                case TEST_STATE.NONE:
                case TEST_STATE.WAITING_RESPONSE:
                default:
                {
                    throw new Exception( "Invalid state." );
                }
            }

                return result;
        }

        /// <summary>
        /// IsComplete:  True if test case complete.
        /// </summary>
        /// <returns>Whether operation is complete or not.</returns>
        public override bool IsComplete()
        {
            return ( _state == TEST_STATE.COMPLETE );
        }

        /// <summary>
        /// VerifyOwnership:  determines if a packet belongs to the test case.
        /// </summary>
        /// <param name="id">byte array of id to check</param>
        /// <returns>true if the id belongs to this test case.</returns>
        public override bool VerifyOwnership( byte[] id )
        {
            return true;
        }



        /// <summary>
        /// Result:  The final result of the test case...  set to false if not complete.
        ///     0 -- failed.
        ///     1 -- passed.
        /// </summary>
        public override int Result
        {
            get
            {
                if ( _state == TEST_STATE.COMPLETE )
                {
                    return _result;
                }
                else
                {
                    return 0;
                }
            }
        }

        /// <summary>
        /// SubjectName:  subjecty name to use.
        /// </summary>
        public string SubjectName
        {
            get
            {
                return _subjectName;
            }
            set
            {
                _subjectName = value;
            }
        }


        // ----------------------------------
        //  Members
        // ----------------------------------
        protected TEST_STATE        _state;
        protected string            _url;
        protected string            _subjectName;

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\LiveProxy\test\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_lspwidget_none_12.4.56.0_none_5c53f0f7e717803c
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_lspwidget_no-public-key_12.4.56.0_x-ww_4a1a05d0
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=lspwidget
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_lspwidget_no-public-key_12.4.56.0_x-ww_4a1a05d0
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_lspwidget_no-public-key_12.4.56.0_x-ww_4a1a05d0.manifest
XP_MANIFEST_PATH=manifests\msil_lspwidget_no-public-key_12.4.56.0_x-ww_4a1a05d0.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_lspwidget_no-public-key_12.4.56.0_x-ww_4a1a05d0.cat
XP_CATALOG_PATH=manifests\msil_lspwidget_no-public-key_12.4.56.0_x-ww_4a1a05d0.cat
XP_PAYLOAD_PATH=msil_lspwidget_no-public-key_12.4.56.0_x-ww_4a1a05d0
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=lspwidget,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\LiveProxy\test\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_lspwidget_none_12.4.56.0_none_5c53f0f7e717803c
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_lspwidget_no-public-key_12.4.56.0_x-ww_4a1a05d0
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=lspwidget
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_lspwidget_no-public-key_12.4.56.0_x-ww_4a1a05d0
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_lspwidget_no-public-key_12.4.56.0_x-ww_4a1a05d0.manifest
XP_MANIFEST_PATH=manifests\msil_lspwidget_no-public-key_12.4.56.0_x-ww_4a1a05d0.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_lspwidget_no-public-key_12.4.56.0_x-ww_4a1a05d0.cat
XP_CATALOG_PATH=manifests\msil_lspwidget_no-public-key_12.4.56.0_x-ww_4a1a05d0.cat
XP_PAYLOAD_PATH=msil_lspwidget_no-public-key_12.4.56.0_x-ww_4a1a05d0
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=lspwidget,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Messaging\Dll\perfcounters.cs ===
using System;
using System.Threading;
using System.Diagnostics;
using xonline.common.mgmt;
using xonline.common.service;

namespace xonline.server.webcache.messaging.dll 
{

    [XomPerformanceCounterCategoryAttr( "WebCache: Messaging", "Xbox Live: Web Cache server performance counters (Messaging)" )]

    public class WebCacheMessagingCounter : XomPerformanceCounterCategory
    {
        // Perf counters for each entry point
        [XomPerformanceCounterAttr(
             "EnumMessages requests per second", 
             "Number of EnumMessages requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter EnumMessagesRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "EnumMessages requests total", 
             "Total EnumMessages requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter EnumMessagesRequestsTotal;


        [XomPerformanceCounterAttr(
             "GetMessageDetails requests per second", 
             "Number of GetMessageDetails requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter GetMessageDetailsRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "GetMessageDetails requests total", 
             "GetMessageDetails requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter GetMessageDetailsRequestsTotal;


        [XomPerformanceCounterAttr(
             "DeleteMessage requests per second", 
             "Number of DeleteMessage requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter DeleteMessageRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "DeleteMessage requests total", 
             "Total DeleteMessage requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter DeleteMessageRequestsTotal;


        [XomPerformanceCounterAttr(
             "SendMessage requests per second", 
             "Number of SendMessage requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter SendMessageRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "SendMessage requests total", 
             "Total SendMessage requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter SendMessageRequestsTotal;

        
        [XomPerformanceCounterAttr(
             "RevokeMessage requests per second", 
             "Number of RevokeMessage requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RevokeMessageRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "RevokeMessage requests total", 
             "Total RevokeMessage requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RevokeMessageRequestsTotal;



        [XomPerformanceCounterAttr(
             "DeleteUserTitle requests per second", 
             "Number of DeleteUserTitle requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter DeleteUserTitleRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "DeleteUserTitle requests total", 
             "Total DeleteUserTitle requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter DeleteUserTitleRequestsTotal;

        [XomPerformanceCounterAttr(
             "EnumUserTitles requests per second", 
             "Number of EnumUserTitles requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter EnumUserTitlesRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "EnumUserTitles requests total", 
             "Total EnumUserTitles requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter EnumUserTitlesRequestsTotal;

        [XomPerformanceCounterAttr(
             "SetMessageFlags requests per second", 
             "Number of SetMessageFlags requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter SetMessageFlagsRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "SetMessageFlags requests total", 
             "Total SetMessageFlags requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter SetMessageFlagsRequestsTotal;

        [XomPerformanceCounterAttr(
             "EnumTitleWideMessages requests per second", 
             "Number of EnumTitleWideMessages requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter EnumTitleWideMessagesRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "EnumTitleWideMessages requests total", 
             "Total EnumTitleWideMessages requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter EnumTitleWideMessagesRequestsTotal;

        [XomPerformanceCounterAttr(
             "GetTitleWideMessageDetails requests per second", 
             "Number of GetTitleWideMessageDetails requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter GetTitleWideMessageDetailsRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "GetTitleWideMessageDetails requests total", 
             "Total GetTitleWideMessageDetails requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter GetTitleWideMessageDetailsRequestsTotal;

        [XomPerformanceCounterAttr(
             "DeleteTitleWideMessage requests per second", 
             "Number of DeleteTitleWideMessage requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter DeleteTitleWideMessageRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "DeleteTitleWideMessage requests total", 
             "Total DeleteTitleWideMessage requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter DeleteTitleWideMessageRequestsTotal;

        [XomPerformanceCounterAttr(
             "SendTitleWideMessage requests per second", 
             "Number of SendTitleWideMessage requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter SendTitleWideMessageRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "SendTitleWideMessage requests total", 
             "Total SendTitleWideMessage requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter SendTitleWideMessageRequestsTotal;

        [XomPerformanceCounterAttr(
             "SendTitleUserMessage requests per second", 
             "Number of SendTitleUserMessage requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter SendTitleUserMessageRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "SendTitleUserMessage requests total", 
             "Total SendTitleUserMessage requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter SendTitleUserMessageRequestsTotal;

        [XomPerformanceCounterAttr(
             "RevokeTitleUserMessage requests per second", 
             "Number of RevokeTitleUserMessage requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RevokeTitleUserMessageRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "RevokeTitleUserMessage requests total", 
             "Total RevokeTitleUserMessage requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RevokeTitleUserMessageRequestsTotal;

        [XomPerformanceCounterAttr(
             "GetMessageString requests per second", 
             "Number of GetMessageString requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter GetMessageStringRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "GetMessageString requests total", 
             "Total GetMessageString requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter GetMessageStringRequestsTotal;


        // Perf counters related to dependencies (Storage Service, String Service)
        [XomPerformanceCounterAttr(
             "StoreAttachment requests per second", 
             "Number of StoreAttachment requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter StoreAttachmentRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "StoreAttachment requests total", 
             "Total StoreAttachment requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter StoreAttachmentRequestsTotal;

        [XomPerformanceCounterAttr(
             "AddString requests per second", 
             "Number of AddString requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter AddStringRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "AddString requests total", 
             "Total AddString requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter AddStringRequestsTotal;


        public virtual WebCacheMessagingCounter this[string partnerName]
        {
            get
            {
                return (WebCacheMessagingCounter) GetInstance(partnerName);
            }
        }

        static public WebCacheMessagingCounter Counters = new WebCacheMessagingCounter();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Messaging\Test\FuncDeleteMessage.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using System.IO;
using System.Xml;
using System.Web.Services.Protocols;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.Messaging;
using ServerTestFramework.Web.UserAccount;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;

namespace MessagingWidget
{
	[TestGroup]
	public class FuncDeleteMessage : TestNode
	{
		[TestCase, Description("ValidDeleteMessage")]
		class ValidDeleteMessage : TestBase
		{
			protected override void Execute()
			{
				// 1.  verify msg exists
				// 2.  delete msg
				// 3.  verify deletion

				WCMessaging service = new WCMessaging();

				WCMessageSummary summary = null;
				WCMessageDetails details = null;

				uint delmsgID = (uint) MWGlobal.MessageList["DeleteMsg"];

				//First make sure it exists
				UInt32 hr = service.GetMessageDetails(
					MWGlobal.Users[4].WebId,
					MWGlobal.Users[4].GamerTag,
					delmsgID,
					0,
					0,
					out summary,
					out details
					);

				if ( summary == null )   // failed to get our  message
				{
					Console.WriteLine("DeleteMsg does not exist.");
					return;
				}

				hr = service.DeleteMessage(
					MWGlobal.Users[4].WebId,
					MWGlobal.Users[4].GamerTag,		// user info
					delmsgID,						// MessageID   
					0								// DeleteFlags
					);

				if( HResult.Succeeded( hr ) )
				{
					// verify delete
					/***		TODO: add check when fixed.  Currently throws a server exception
					 
					hr = service.GetMessageDetails(
						user,
						delmsgID,
						0,
						0,
						out summary,
						out details
						);

					if ( summary == null )   // failed to get our  message
					{
						Console.WriteLine("DeleteMsg does not exist.");
						return;
					}
					**/

				}
				else
				{
					Console.WriteLine("Delete call failed, hr: " + hr.ToString("X") );
					return;
				}


				ResultCode = TEST_RESULTS.PASSED;
			}
		}
	
		[TestCase, Description("NegDeleteUnknownMessage")]
		class NegDeleteUnknownMessage : TestBase
		{
			protected override void Execute()
			{

				WCMessaging service = new WCMessaging();

				UInt32 hr = service.DeleteMessage(
					MWGlobal.Users[6].WebId,			// User 6 should never have messages
					MWGlobal.Users[6].GamerTag,
					9999,
					0
					);

				if( hr != HResult.XONLINE_E_MESSAGE_INVALID_MESSAGE_ID )
				{
					Console.WriteLine("Unexpected pass or bad error code: " + hr.ToString("X") );
					return;
				}

				// try a block sender with no sender
				hr = service.DeleteMessage(
					MWGlobal.Users[6].WebId,
					MWGlobal.Users[6].GamerTag,
					9999,
					WCDeleteMsgFlags.BlockSender			
					);
				
				if( hr != HResult.XONLINE_E_MESSAGE_INVALID_MESSAGE_ID)
				{
					Console.WriteLine("Unexpected pass or bad error code: " + hr.ToString("X") );
					return;
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("NegDeleteNullID")]
		class NegDeleteNullID : TestBase
		{
			protected override void Execute()
			{

				WCMessaging service = new WCMessaging();

				try 
				{
					UInt32 hr = service.DeleteMessage(
						MWGlobal.Users[1].WebId, 
						null,			// use valid WebID
						0, 
						0);

					if( HResult.Succeeded( hr ) )
					{
						return;
					}
				}
				catch(SoapException e)
				{
					// This should return a meaningful error when fixed
					Console.WriteLine(e.Message);
				}

				try
				{
					// try empty gamertag string
					
					UInt32 hr = service.DeleteMessage(
						MWGlobal.Users[1].WebId,						
						"",
						9999,
						WCDeleteMsgFlags.BlockSender);
		
					if( HResult.Succeeded( hr ) )
					{
						return;
					}
				}
				catch(SoapException e)
				{
					// should return a meaningful error when fixed
					Console.WriteLine(e.Message);

				}

				// Null WebID
				try 
				{
					UInt32 hr = service.DeleteMessage(
						null, 
						MWGlobal.Users[1].GamerTag,
						0, 
						0);

					if( HResult.Succeeded( hr ) )
					{
						return;
					}
				}
				catch(SoapException e)
				{
					// This should return a meaningful error when fixed
					Console.WriteLine(e.Message);
				}


				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("NegUnknownUser")]
		class NegUnknownUser : TestBase
		{
			protected override void Execute()
			{

				WCMessaging service = new WCMessaging();

				try 
				{
					UInt32 hr = service.DeleteMessage(
						MWGlobal.Users[1].WebId,				// use valid Web ID
						RandomEx.GlobalRandGen.GenerateRandomString(15), 
						0, 
						0);

					if( HResult.Succeeded( hr ) )
					{
						return;
					}
				}
				catch(SoapException e)
				{
					// This should return a meaningful error when fixed
					Console.WriteLine(e.Message);
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}
				
		[TestCase, Description("NegDelMismatchedUser")]
		class NegDelMismatchedUser : TestBase
		{
			protected override void Execute()
			{

				WCMessaging service = new WCMessaging();

				try 
				{
					UInt32 hr = service.DeleteMessage(
						MWGlobal.Users[0].WebId, 
						MWGlobal.Users[1].GamerTag,
						0, 
						0);

					if( HResult.Succeeded( hr ) )
					{
						return;
					}
				}
				catch(SoapException e)
				{
					// This should return a meaningful error when fixed
					Console.WriteLine(e.Message);
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}			
	
		[TestCase, Description("NegDelBadTag")]
		class NegDelBadTag : TestBase
		{
			protected override void Execute()
			{

				WCMessaging service = new WCMessaging();

				try 
				{
					UInt32 hr = service.DeleteMessage(
						MWGlobal.Users[1].WebId,  // use valid Web ID
						"0123456789xxxxxx",		// 16-char tag
						0, 
						0);

					if( HResult.Succeeded( hr ) )
					{
						return;
					}
				}
				catch(SoapException e)
				{
					// This should return a meaningful error when fixed
					Console.WriteLine(e.Message);
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}	
	
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Messaging\Test\FuncDeleteTitleWideMessage.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using System.IO;
using System.Xml;
using System.Web.Services.Protocols;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.Messaging;
using ServerTestFramework.Web.UserAccount;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;

namespace MessagingWidget
{
	[TestGroup]
	public class FuncDeleteTitleMessage : TestNode
	{
		[TestCase, Description("BasicDeleteSystemMessage")]
		class BasicDeleteSystemMessage : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();

				// pull this from Send test
				uint MessageID  = (uint) MWGlobal.MessageList["SysMsgBasic"];

				UInt32 hr = service.DeleteTitleWideMessage(
					400001,			// TitleID
					MessageID,		// MessageID
					0				// WCDeleteSysMsgFlags
					//WCDeleteSysMsgFlags.RevokeAll
					);

				if( HResult.Succeeded( hr ) )
				{
					// Hurray!

					// TODO: Verify msg deletion
				}
				else
				{
					return;
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("Delete Unknown SystemMessage")]
		class NegDelUnknownSysMsg : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();


				UInt32 hr = service.DeleteTitleWideMessage(
					400001,			// TitleID
					9999,			// MessageID unknown  -- should not exist
					0				// WCDeleteSysMsgFlags
					//WCDeleteSysMsgFlags.RevokeAll
					);

				if( HResult.Succeeded( hr ) )
				{
					Global.RO.Info("Unexpected pass.");
					return;
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}
	

		[TestCase, Description("Delete Unknown SystemMessage TitleID")]
		class NegDelUnknownTitleID : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();

				// pull this from Send test
				uint MessageID  = (uint) MWGlobal.MessageList["SysMsgBasic"];

				try 
				{
					UInt32 hr = service.DeleteTitleWideMessage(
						1111,			// TitleID -- unknown
						MessageID,		// valid MessageID from previous send
						0				// WCDeleteSysMsgFlags
						//WCDeleteSysMsgFlags.RevokeAll
						);

					if( HResult.Succeeded( hr ) )
					{
						Global.RO.Info("Unexpected pass.");
						return;
					}

				}
				catch(SoapException e)
				{
					// DebugPartner error message expected
                    string expMsgStart = "Server was unable to process request. ---> Partner:DebugPartner";
                    if (!e.Message.StartsWith(expMsgStart)) 
					{
                        Global.RO.Info("Unexpected soap exception message: " + e.Message + " ... had expected: " + expMsgStart);
						return;
					}
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

//		[TestCase, Description("TEMPDeleteAllSystemMessages")]
		class TEMPDeleteAllSystemMessages : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
				WCTitleWideMessageSummary[] summary = null;

				UInt32 hr = service.EnumTitleWideMessages(
					400001,
					out summary
					);

				if( HResult.Succeeded( hr ) )
				{
					if ( summary.Length > 0 )
					{
						for( int iMessage = 0; iMessage < summary.Length; iMessage++ )
						{
							hr = service.DeleteTitleWideMessage(
								400001,							// TitleID
								summary[iMessage].MessageID,	// MessageID
								0								// WCDeleteSysMsgFlags
								//WCDeleteSysMsgFlags.RevokeAll
								);
						}
					}

				}


				ResultCode = TEST_RESULTS.PASSED;
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Messaging\Dll\messaging.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Security.Cryptography; // SHA1CryptoServiceProvider
using System.Text;
using System.Web;
using System.Web.Services;
using System.Web.Services.Protocols;
using System.Web.Caching;

using xonline.common.protocol;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.server.webcache.common;
using xonline.server.mgmt.soap;
using xonline.common.config;
using xonline.common.installer;

[assembly: XomIisInstallerAttribute( Interface.wcmessaging )]
[assembly: ConfigAttribute(xonline.common.config.Component.wcmessaging)]

[assembly: XomAreaDefinition(XomAreaName.wcMessagingLog)]
[assembly: XomAreaDefinition(XomAreaName.wcMessagingTrace)]

namespace xonline.server.webcache.messaging.dll 
{
    [System.Web.Services.WebServiceBindingAttribute(Name="MessagingSoap", Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class MessagingImpl : Messaging
    {   
        public MessagingImpl()
        {
            try
            {
                CheckFlagConsistency();

                //CODEGEN: This call is required by the ASP.NET Web Services Designer
                InitializeComponent();
            }
            catch (XboxWebException)
            {
                throw;
            }
            catch (Exception e)
            {
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_19, e);
            }
        }

        #region Component Designer generated code
        
        //Required by the Web Services Designer 
        private IContainer components = null;
                
        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
        }

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        protected override void Dispose( bool disposing )
        {
            if(disposing && components != null)
            {
                components.Dispose();
            }
            base.Dispose(disposing);        
        }
        
        #endregion

        // 
        // Internal helper functions
        //

        // 
        // Convert from locales to languages supported by the String server
        //
        private ushort LocaleToLanguage( string locale )
        {
            locale = locale.ToLower();
            switch( locale )
            {
            case "de-at":
            case "de-ch":
            case "de-de":
                return XOn.XC_LANGUAGE_GERMAN;
            case "en-au":
            case "en-ca":
            case "en-gb":
            case "en-ie":
            case "en-nz":
            case "en-sg":
            case "en-us":
                return XOn.XC_LANGUAGE_ENGLISH;
            case "es-es":
            case "es-mx":
                return XOn.XC_LANGUAGE_SPANISH;
            case "fr-be":
            case "fr-fr":
                return XOn.XC_LANGUAGE_FRENCH;
            case "it-it":
                return XOn.XC_LANGUAGE_ITALIAN;
            case "ja-jp":
                return XOn.XC_LANGUAGE_JAPANESE;
            case "ko-kr":
                return XOn.XC_LANGUAGE_KOREAN;
            case "pt-br":
                return XOn.XC_LANGUAGE_PORTUGUESE;
            case "zh-hk":
            case "zh-tw":
                return XOn.XC_LANGUAGE_TCHINESE;
            case "da-dk":
            case "fi-fi":
            case "nl-nl":
            case "no-no":
            case "sv-se":
            default:
                return XOn.XC_LANGUAGE_UNKNOWN;
            }
        }

        //
        // A simple helper for printing out web IDs
        //
        private string StringFromWebID( byte[] webID )
        {
            if( null == webID || 8 != webID.Length )
            {
                return "0";
            }

            string s = "";
            for( int iByte = 0; iByte < 8; iByte++ )
            {
                // Don't print leading zeroes
                if( 0 != webID[ iByte ] )
                {
                    s += webID[ iByte ].ToString("X");
                }
            }
            if( "" == s )
            {
                s = "0";
            }

            return s;
        }

        //
        // Wrapping this here allows me to not have XCache installed on my Dev machine when unit testing.
        //
        private ulong LookupPUID( string strGamerTag )
        {
            try
            {
#if DEBUG
                // Do a sort of local look-up on the names used by the unittest
                if( "DebugPartner" == Utilities.GetSubjectName() )
                {
                    if( "xmsgtest1" == strGamerTag )
                    {
                        return 1;
                    }
                    else if( "xmsgtest2" == strGamerTag )
                    {
                        return 2;
                    }
                }
#endif
                return Utilities.Instance.LookupXuidByGamertag(strGamerTag);
            }
            catch (ArgumentException ae)
            {
                throw new XboxWebExceptionNoEvent("XCache Exception: ", ae);
            }            
        }

        //
        // Wrapping this here allows me to not have XCache installed on my Dev machine when unit testing.
        //
        private PUIDAndOwner LookupWebID( byte[] webID, string strGamerTag )
        {
            try
            {
#if DEBUG
                // Do a sort of local look-up on the names used by the unittest
                if( "DebugPartner" == Utilities.GetSubjectName() )
                {
                    if( "xmsgtest1" == strGamerTag )
                    {
                        return new PUIDAndOwner( 1, true );
                    }
                    else if( "xmsgtest2" == strGamerTag )
                    {
                        return new PUIDAndOwner( 2, true );
                    }
                }
#endif
                return Utilities.Instance.LookupWebID( webID, strGamerTag );
            }
            catch (ArgumentException ae)
            {
                // For back compat, we must throw the same message we used to. 
                throw new XboxWebExceptionNoEvent("(webID,GamerTag) pair ("+ByteConvert.ToReverseString(webID) +","+strGamerTag+") is not linked in our system", ae);
            }            
        }

        //
        // Wrapping this here allows me to not have XCache installed on my Dev machine when unit testing.
        //
        private string LookupGamerTag( ulong PUID )
        {
            try
            {
#if DEBUG
                // Do a sort of local look-up on the names used by the unittest
                if( "DebugPartner" == Utilities.GetSubjectName() )
                {
                    if( 1 == PUID )
                    {
                        return "xmsgtest1";
                    }
                    else if( 2 == PUID )
                    {
                        return "xmsgtest2";
                    }
                }
#endif
                return Utilities.Instance.LookupGamerTag( PUID );
            }
            catch (ArgumentException ae)
            {
                throw new XboxWebExceptionNoEvent("XCache Exception: ", ae);
            }            
        }

        //
        // Wrapping this here allows me to not have XCache installed on my Dev machine when unit testing.
        //
        private ulong[] LookupPUIDs( string[] rgstrGamerTags )
        {
            try
            {
#if DEBUG
                // Do a sort of local look-up on the names used by the unittest
                if( "DebugPartner" == Utilities.GetSubjectName() )
                {
                    bool fUnknownTags = false;
                    ulong[] rgPUIDs = new ulong[ rgstrGamerTags.Length ];
                    for( int iGamerTag = 0; iGamerTag < rgstrGamerTags.Length; iGamerTag++ )
                    {
                        if( "xmsgtest1" == rgstrGamerTags[ iGamerTag ] )
                        {
                            rgPUIDs[ iGamerTag ] = 1;
                        }
                        else if( "xmsgtest2" == rgstrGamerTags[ iGamerTag ] )
                        {
                            rgPUIDs[ iGamerTag ] = 2;
                        }
                        else
                        {
                            fUnknownTags = true;
                            break;
                        }
                    }
                    if( !fUnknownTags )
                    {
                        return rgPUIDs;
                    }
                    // If there are any unknown tags fall through to the regular call
                }
#endif
                return Utilities.Instance.LookupXuidsByGamertags(rgstrGamerTags);
            }
            catch (ArgumentException ae)
            {
                throw new XboxWebExceptionNoEvent("XCache Exception: ", ae);
            }                       
        }

        //
        // Wrapping this here allows me to not have XCache installed on my Dev machine when unit testing.
        //
        private string[] LookupGamerTags( ulong[] rgPUIDs )
        {
            try
            {
#if DEBUG
                // Do a sort of local look-up on the names used by the unittest
                if( "DebugPartner" == Utilities.GetSubjectName() )
                {
                    bool fUnknownPUIDs = false;
                    string[] rgGamerTags = new string[ rgPUIDs.Length ];
                    for( int iPUID = 0; iPUID < rgPUIDs.Length; iPUID++ )
                    {
                        if( 1 == rgPUIDs[ iPUID ] )
                        {
                            rgGamerTags[ iPUID ] = "xmsgtest1";
                        }
                        else if( 2 == rgPUIDs[ iPUID ] )
                        {
                            rgGamerTags[ iPUID ] = "xmsgtest2";
                        }
                        else
                        {
                            fUnknownPUIDs = true;
                            break;
                        }
                    }
                    if( !fUnknownPUIDs )
                    {
                        return rgGamerTags;
                    }
                    // If there are any unknown PUIDs fall through to the regular call
                }
#endif
                return Utilities.Instance.LookupGamerTags( rgPUIDs );
            }
            catch (ArgumentException ae)
            {
                throw new XboxWebExceptionNoEvent("XCache Exception: ", ae);
            }            
        }

        // 
        // Code to make sure webcache-based Messaging flags stay consistent with protocol definitions
        //
        private void CheckFlagConsistency()
        {
            WCMessageFlags TitleFlags = 
                WCMessageFlags.TitleReserved0 | 
                WCMessageFlags.TitleReserved1 | 
                WCMessageFlags.TitleReserved2 | 
                WCMessageFlags.TitleReserved3 | 
                WCMessageFlags.TitleReserved4 | 
                WCMessageFlags.TitleReserved5 | 
                WCMessageFlags.TitleReserved6; // Bug in wsdl.exe | WCMessageFlags.TitleReserved7;

            WCMessageFlags ReservedFlags = 
                WCMessageFlags.MSReserved0  | 
                WCMessageFlags.MSReserved1  | 
                WCMessageFlags.MSReserved2  | 
                WCMessageFlags.MSReserved3  | 
                WCMessageFlags.MSReserved4  | 
                WCMessageFlags.MSReserved5  | 
                WCMessageFlags.MSReserved6  | 
                WCMessageFlags.MSReserved7  | 
                WCMessageFlags.MSReserved8  | 
                WCMessageFlags.MSReserved9  | 
                WCMessageFlags.MSReserved10 | 
                WCMessageFlags.MSReserved11 | 
                WCMessageFlags.MSReserved12 | 
                WCMessageFlags.MSReserved13;

            uint[] uiFlags =
            {
                // Attachment flags
                (uint) WCAttachFlags.NonExportable,   MsgDefs.XONLINE_MSG_ATTACHMENT_FLAG_NON_EXPORTABLE,
                (uint) WCAttachFlags.Directory,       MsgDefs.XONLINE_MSG_ATTACHMENT_FLAG_DIRECTORY,

                // Message Flags
                (uint) WCMessageFlags.Required,       MsgDefs.XONLINE_MSG_FLAG_REQUIRED,
                (uint) WCMessageFlags.Recommended,    MsgDefs.XONLINE_MSG_FLAG_RECOMMENDED,
                (uint) WCMessageFlags.HasVoice,       MsgDefs.XONLINE_MSG_FLAG_HAS_VOICE,
                (uint) WCMessageFlags.HasText,        MsgDefs.XONLINE_MSG_FLAG_HAS_TEXT,
                (uint) WCMessageFlags.Read,           MsgDefs.XONLINE_MSG_FLAG_READ,
                (uint) WCMessageFlags.NonExportable,  MsgDefs.XONLINE_MSG_FLAG_NON_EXPORTABLE,
                (uint) WCMessageFlags.TeamContext,    MsgDefs.XONLINE_MSG_FLAG_TEAM_CONTEXT,
                (uint) WCMessageFlags.CompContext,    MsgDefs.XONLINE_MSG_FLAG_COMP_CONTEXT,
                (uint) WCMessageFlags.AlternateTitle, MsgDefs.XONLINE_MSG_FLAG_ALTERNATE_TITLE,
                (uint) WCMessageFlags.Marketing,      MsgDefs.XONLINE_MSG_FLAG_MARKETING,
                (uint) ReservedFlags,                 MsgDefs.XONLINE_MSG_FLAGS_RESERVED | 
                                                      MsgDefs.XONLINE_MSG_FLAG_SENDER_IS_FRIEND |
                                                      MsgDefs.XONLINE_MSG_FLAG_RECV_DETAILS_NEEDED |
                                                      MsgDefs.XONLINE_MSG_FLAG_MS_MARKETING |
                                                      MsgDefs.XONLINE_MSG_FLAG_HAS_PHOTO,
                (uint) TitleFlags | 0x80000000,       MsgDefs.XONLINE_MSG_FLAGS_TITLE_RESERVED,

                // Message Types
                (uint) WCMessageType.TitleCustom,     MsgDefs.XONLINE_MSG_TYPE_TITLE_CUSTOM,
                (uint) WCMessageType.FriendRequest,   MsgDefs.XONLINE_MSG_TYPE_FRIEND_REQUEST,
                (uint) WCMessageType.GameInvite,      MsgDefs.XONLINE_MSG_TYPE_GAME_INVITE,
                (uint) WCMessageType.TeamRecruit,     MsgDefs.XONLINE_MSG_TYPE_TEAM_RECRUIT,
                (uint) WCMessageType.CompReminder,    MsgDefs.XONLINE_MSG_TYPE_COMP_REMINDER,
                (uint) WCMessageType.CompRequest,     MsgDefs.XONLINE_MSG_TYPE_COMP_REQUEST,
                (uint) WCMessageType.LiveMessage,     MsgDefs.XONLINE_MSG_TYPE_LIVE_MESSAGE,
                (uint) WCMessageType.PersonalMessage,     MsgDefs.XONLINE_MSG_TYPE_PERSONAL_MESSAGE,
                (uint) WCMessageType.VideoMessage,     MsgDefs.XONLINE_MSG_TYPE_VIDEO_MESSAGE,
                (uint) WCMessageType.QuickChatInvite,     MsgDefs.XONLINE_MSG_TYPE_QUICK_CHAT_INVITE,
                (uint) WCMessageType.VideoChatInvite,     MsgDefs.XONLINE_MSG_TYPE_VIDEO_CHAT_INVITE,
                (uint) WCMessageType.PartyChatInvite,     MsgDefs.XONLINE_MSG_TYPE_PARTY_CHAT_INVITE,

                // DeleteMessage Flags
                (uint) WCDeleteMsgFlags.BlockSender,  MsgDefs.XMSG_DELETE_MESSAGE_FLAG_BLOCK_SENDER,

                // DeleteTitleWideMessage Flags
                (uint) WCDeleteSysMsgFlags.RevokeAll, MsgDefs.XMSG_DELETE_SYSTEM_MESSAGE_FLAG_REVOKE_ALL,

                // UserTitle Flags
                (uint) WCUserTitleFlags.AcceptMarketing, MsgDefs.XMSG_USER_TITLE_FLAG_ACCEPT_MARKETING,
            };

            for( uint iFlag = 0; iFlag < uiFlags.Length; iFlag += 2 )
            {
                if( uiFlags[ iFlag ] != uiFlags[ iFlag + 1 ] ) 
                {
                    throw new XboxWebInternalException( XEvent.Id.WEBCACHE_UNKNOWN_ERROR_20, "Flags don't match (uiFlags[" + iFlag.ToString() + "]) - (" + uiFlags[ iFlag ].ToString("X") + " != " + uiFlags[ iFlag + 1 ].ToString("X") + ")!" );
                }
            }
        }

        // 
        // Code to sign an attachment for a particular title
        //
        private HResult SignAttachment( ref byte[] rgbDigest, uint dwTitleID, ulong qwSenderID, out byte[] rgbSignature )
        {
            // Initialize output variables
            rgbSignature = null;

            // Get a signature from the Signature service

            // Specify which title we will be signing on behalf of
            XSigAuthData authData = new XSigAuthData();
            authData._titleID = dwTitleID;
            authData._titleVersion = 0;
            authData._userID1 = qwSenderID;
            authData._userID2 = 0;
            authData._userID3 = 0;
            authData._userID4 = 0;
            authData._XboxID = Utilities.GetRequestorMachinePUID();
            
            XSigSignOnBehalfRequest signRequest = new XSigSignOnBehalfRequest();
            signRequest._serviceId = (uint) XOService.MessagingService;
            signRequest._authData = authData;
            signRequest._digest = rgbDigest;

            XSigSignOnBehalfResponse signResponse = new XSigSignOnBehalfResponse();
            XRLObject2 xrlo = signResponse;

            Utilities.RequestInfo requestInfo = Utilities.GetRequestInfo();
            HTTPAuthData httpAuthData = new HTTPAuthData( requestInfo.ClientPort, requestInfo.ClientIP, requestInfo.qwRequestID, 0, dwTitleID, (uint) XOService.Signature_Server, 0 );

            HResult hr = XRLUtil.PostXrlRequest( XOService.Signature_Server, signRequest.GetXRL(), httpAuthData.GetBase64EncodedString(), signRequest, ref xrlo );
            if( HResult.Failed( hr ) )
            {
                return hr;
            }
            else if( HResult.Failed( signResponse._hresult ) )
            {
                 return signResponse._hresult;
            }

            rgbSignature = (byte[]) signResponse._signature;

            return HResult.S_OK;
        }        

        //
        // Code to sign CAB packages for a particular title
        //
        private HResult SignPackage(ref byte [] data, uint titleID, ulong userPuid, 
            out byte [] hash, out byte [] signature)
        {
            HResult hr = HResult.S_OK;

            // Initialize output variables
            signature = null;

            // set up a stream so we can jump around in the array
            using (MemoryStream cabStream = new MemoryStream(data))
            {
                // set up a binary reader on that stream to make it easier to read off data types
                using (BinaryReader cabReader = new BinaryReader(cabStream))
                {
                    // set up a binary writer to aid writing the hashes and signatures back into the array
                    using (BinaryWriter cabWriter = new BinaryWriter(cabStream))
                    {
                        /*

                        Packages need two separate Live signatures.  We will request these in two
                        seperate requests to xsig.  The first signature is validated
                        when the package is downloaded, and then it is thrown away.  Subsequent
                        uses of the file will validate the signature within the contentmeta.xbx
                        file.

                        Refer to cabinet.h, xcabinet.h, and xcontsig.h in the xbox client tree
                        to understand the following layout of the interesting parts of 
                        the "data" byte array:

                        CFHEADER
                        CFRESERVE
                        RC4_SHA_HEADER
                        RC4_SHA_HEADER

                        (everything preceding can also be understood as a single XONLINECONTENT_HEADER)

                        CFFOLDER structures (cFolders of them)
                        CFDATA structures (the first is contentmeta.xbx)
                        
                        */

                        const int XONLINECONTENT_FIXED_HEADER_SIZE_WITH_HMAC = 124;
                        const int CFHEADER_SIZE = 36; // 6 longs + 6 shorts
                        const int CFDATA_SIZE = 8; // 1 long + 2 shorts
                        const int CFFOLDER_HMAC_SIZE = 36; // 1 long + 2 shorts + checksum(20) + confounder(8)
                        
                        const int CFOLDERS_OFFSET_WITHIN_CFHEADER = 26; // 6 longs + 1 short
                        const int MAGIC_NUMBER_OFFSET_WITHIN_XCONTSIG_HEADER = 20; // 1 digest
                        const int TITLE_ID_OFFSET_WITHIN_XCONTSIG_HEADER = 36; // 1 digest + 4 longs
                        const int CBDATA_OFFSET_WITHIN_CFDATA = 4; // 1 long
                        const int HMAC_CHECKSUM_OFFSET_WITHIN_CFFOLDER = 8; // 1 long + 2 shorts
                        const int DIGESTFOLDERS_CHECKSUM_OFFSET_WITHIN_XONLINECONTENT_HEADER = 
                            CFHEADER_SIZE + 4; // CFHEADER_SIZE + 1 short + 2 bytes
                        
                        char [] XCONTSIG_MAGIC = { 'X', 'C', 'S', 'F' };

                        // first we need to find out how many folders are in the cab
                        cabStream.Seek(CFOLDERS_OFFSET_WITHIN_CFHEADER, SeekOrigin.Begin);
                        ushort cFolders = cabReader.ReadUInt16();

                        // now start over, moving past the whole CFHEADER, and read off CFRESERVE.cbCFHeader
                        // note that we don't check CFHEADER.flags, since we know CFRESERVE will also be present
                        // this value tells us how many bytes are in CFHEADER.abReserve
                        cabStream.Seek(CFHEADER_SIZE, SeekOrigin.Begin);
                        ushort cbCFHeader = cabReader.ReadUInt16();

                        // skip past the remaing 2 CFRESERVE bytes, plus the entire CFHEADER.abReserve section
                        cabStream.Seek(2 + cbCFHeader, SeekOrigin.Current);

                        // now we're at the first of the CFFOLDER structures
                        long coffFolders = cabStream.Position;

                        // read coffCabStart and cCFData from the first CFFOLDER structure
                        long coffCabStart = cabReader.ReadUInt32();
                        uint cCFData = cabReader.ReadUInt32();

                        // now that we have coffCabStart, we now know the location of contentmeta.xbx
                        // so, let's sanity check by observing the magic number
                        // we need to just skip over the CFDATA structure and the jump to the proper offset
                        cabStream.Seek(coffCabStart + CFDATA_SIZE + MAGIC_NUMBER_OFFSET_WITHIN_XCONTSIG_HEADER,
                            SeekOrigin.Begin);
                        byte [] magicNumber = cabReader.ReadBytes(4);
                        for (int i = 0; i < 4; i++)
                        {
                            if (magicNumber[i] != XCONTSIG_MAGIC[i])
                                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_INTERNAL_NONFATAL_ERROR,
                                    "Error parsing cab file in preparation for dual-signing during WriteFile");
                        }

                        // now let's jump to the titleID and make sure it checks out
                        cabStream.Seek(coffCabStart + CFDATA_SIZE + TITLE_ID_OFFSET_WITHIN_XCONTSIG_HEADER, 
                            SeekOrigin.Begin);
                        uint packageTitleID = cabReader.ReadUInt32();
                        if (packageTitleID != titleID)
                            throw new PartnerBadRequestException(string.Format(
                                "TitleID in package ({0}) does not match title ID passed into API ({1})",
                                packageTitleID, titleID));

                        // we need sign a 112 byte region starting at offset 36 within contentmeta.xbx
                        cabStream.Seek(coffCabStart + CFDATA_SIZE + 36, SeekOrigin.Begin);
                        byte [] regionOfContentMetaXbx = cabReader.ReadBytes(112);
                        byte [] hashOfContentMetaXbx = _sha1.ComputeHash(regionOfContentMetaXbx);
                        hash = hashOfContentMetaXbx;
                        byte [] signatureOfContentMetaXbx;

                        hr = SignAttachment( ref hashOfContentMetaXbx, titleID, userPuid, out signatureOfContentMetaXbx );
                        if( HResult.Failed( hr ) )
                        {
                            return hr;
                        }
                        
                        signature = signatureOfContentMetaXbx;

                        // the signature should be written to XCONTSIG_LIVE_SIGNATURE.Signature
                        cabWriter.Write(signatureOfContentMetaXbx, 0, 100);
                        cabWriter.Flush();

                        // now that we have modified xcontentmeta.xbx, we need to zero out
                        // the csum over the CFDATA for contentmeta.xbx
                        UInt32 crc = 0;

                        // write the crc back into CFDATA.csum
                        cabStream.Seek(coffCabStart, SeekOrigin.Begin);
                        cabWriter.Write(crc);
                        cabWriter.Flush();

                        // now we are ready to fix the hash which verified all CFDATA file content

                        // starting with the first CFDATA, we will iteratively hash the contents
                        // of each CFDATA (including the.ab region into a single hash value
                        cabStream.Seek(coffCabStart, SeekOrigin.Begin);
                        _sha1.Initialize();

                        // update the sha1 with each data block except for the last one
                        for (int i = 0; i < cCFData - 1; i++)
                        {
                            cabStream.Seek(CBDATA_OFFSET_WITHIN_CFDATA, SeekOrigin.Current);
                            int cbData = (int) cabReader.ReadUInt16();
                            int cbTotalCFDataSize = cbData + CFDATA_SIZE;

                            // the entire CFDATA (including ab) must be included in the hash
                            int dataArrayOffset = (int) cabStream.Position - 6;

                            // this API is generic, so the last two parameters for TransformBlock, below,
                            // actually not used for anything in the function, we are just calculating a hash
                            
                            // point the sha1 at the proper place in the byte array
                            _sha1.TransformBlock(data, dataArrayOffset, cbTotalCFDataSize, 
                                data, dataArrayOffset);

                            // now update the stream pointer to point to the next CFDATA structure
                            cabStream.Seek(2 + cbData, SeekOrigin.Current);
                        }

                        // now we do the same thing for the last block, but call TransformFinalBlock
                        cabStream.Seek(CBDATA_OFFSET_WITHIN_CFDATA, SeekOrigin.Current);
                        int lastCbData = (int) cabReader.ReadUInt16();
                        int lastCbTotalCFDataSize = lastCbData + CFDATA_SIZE;
                        
                        // the entire CFDATA (including ab) must be included in the hash
                        int lastDataArrayOffset = (int) cabStream.Position - 6;

                        _sha1.TransformFinalBlock(data, lastDataArrayOffset, lastCbTotalCFDataSize);

                        // now we've calculated the hash that verifies all file content, now including
                        // our modification to contentmeta.xbx
                        byte [] hashOfCFDatas = _sha1.Hash;

                        // seek to the RC4_SHA_HEADER.Checksum of the first CFFOLDER entry
                        cabStream.Seek(coffFolders + HMAC_CHECKSUM_OFFSET_WITHIN_CFFOLDER, SeekOrigin.Begin);

                        // write out the checksum
                        cabWriter.Write(hashOfCFDatas);
                        cabWriter.Flush();

                        // now we have changed the first folder entry, and so we must update the
                        // hash that verifies all the folder information

                        // read all the CFFOLDER structures into a single byte array
                        _sha1.Initialize();
                        
                        cabStream.Seek(coffFolders, SeekOrigin.Begin);
                        byte [] regionCFFolders = cabReader.ReadBytes(cFolders * CFFOLDER_HMAC_SIZE);
                        byte [] hashCFFolders = _sha1.ComputeHash(regionCFFolders);

                        // seek to XONLINECONTENT_HEADER.digestFolders.Checksum
                        cabStream.Seek(DIGESTFOLDERS_CHECKSUM_OFFSET_WITHIN_XONLINECONTENT_HEADER,
                            SeekOrigin.Begin);

                        // write out the checksum
                        cabWriter.Write(hashCFFolders);
                        cabWriter.Flush();

                        // now we are finally ready to sign XONLINECONTENT_HEADER
                        cabStream.Seek(0, SeekOrigin.Begin);
                        byte [] regionHeaderData = cabReader.ReadBytes(XONLINECONTENT_FIXED_HEADER_SIZE_WITH_HMAC); 
                        byte [] hashHeaderData = _sha1.ComputeHash(regionHeaderData);
                        byte [] signatureHeaderData;

                        hr = SignAttachment( ref hashHeaderData, titleID, userPuid, out signatureHeaderData );
                        if( HResult.Failed( hr ) )
                        {
                            return hr;
                        }
                        
                        // Signing the attachment moved the stream past XONLINECONTENT_HEADER and the HMAC,
                        // now move past the DWORD checkpoint
                        cabStream.Seek(4, SeekOrigin.Current);

                        cabWriter.Write(signatureHeaderData);
                        cabWriter.Flush();
                    }
                }
            }

            return hr;
        }
        
        //
        // Code to make a write call to storage and return a URL
        //
        private HResult StorageWrite( byte[] rgbData, uint dwTitleID, ulong qwSenderID, bool fIsPackage, string strPath, DateTime dtExpiration )
        {
            HResult hr;

            // Update perf counters
            WebCacheMessagingCounter.Counters.StoreAttachmentRequestsPerSecond.Increment();
            WebCacheMessagingCounter.Counters.StoreAttachmentRequestsTotal.Increment();

            string partnerName = Utilities.GetSubjectName();
            if( null != partnerName )
            {
                WebCacheMessagingCounter.Counters[ partnerName ].StoreAttachmentRequestsPerSecond.Increment();
                WebCacheMessagingCounter.Counters[ partnerName ].StoreAttachmentRequestsTotal.Increment();
            }

            ReqHdrWriteFile req = new ReqHdrWriteFile();
            ulong xboxID = Utilities.GetRequestorMachinePUID();

            // Set up the base access token
            req._accessToken = new WriteFileToken();
            req._accessToken._operation = (ushort) Operation.FileWrite;
            req._accessToken._serviceId = (uint) XOService.Storage;
            req._accessToken._flags = 0;
            req._accessToken._userPuid = qwSenderID;
            req._accessToken._xboxPuid = xboxID;
            req._accessToken._pathName = strPath; // _pathNameSize is set automatically based on this
            req._accessToken._signature = null; // _signatureSize is set automatically based on this

            // Set up the write access token
            req._accessToken._tokenExpirationDate = 0;
            req._accessToken._fileExpirationDate = dtExpiration.ToFileTimeUtc();
            req._accessToken._maxFileSize = ProtocolConstants.maxFileSize;

            // Set up the request body
            req._titleId = dwTitleID;
            req._titleVersion = 0;
            req._userCountryId = 0;
            req._compressionType = (byte) CompressionType.Uncompressed;

            // Attachments that are a package of files have their digest computed differently than attachments
            // that are blobs to be downloaded to memory.
            if( fIsPackage )
            {
                // First we must sign the data
                hr = SignPackage( ref rgbData, dwTitleID, qwSenderID, out req._blobHash, out req._blobSignature );
                if( HResult.Failed( hr ) )
                {
                    return hr;
                }

                // Set the content type appropriately
                req._contentType = (uint) ContentType.ContentPackage;
            }
            else
            {
                // Compute a digest of the attachment data
                req._blobHash = _sha1.ComputeHash( rgbData );

                // NOTE: Make the signature the correct size, but leave it all zeroes.
                req._blobSignature = new byte[ ProtocolConstants.sizeSignature ];

                // Set the content type appropriately
                req._contentType = (uint) ContentType.ContentBlob;
            }

            req._blobSizeUncompressed = (uint) rgbData.Length;
            req._blobSize = (uint) rgbData.Length;
            req._attributes = null; // _attributesSize is set automatically based on this

            // Write the full request into a binary stream
            MemoryStream stream = new MemoryStream();
            BinaryWriter writer = new BinaryWriter( stream );

            // Write out the request header
            req.WriteTo( writer );

            // Write out the attachment data
            writer.Write( rgbData );

            // Make sure the BinaryWriter is finished writing
            writer.Flush();

            // Make the request to Storage
            Utilities.RequestInfo requestInfo = Utilities.GetRequestInfo();
            HTTPAuthData httpAuthData = new HTTPAuthData( requestInfo.ClientPort, requestInfo.ClientIP, requestInfo.qwRequestID, xboxID, qwSenderID, dwTitleID, (uint) XOService.Storage, 0 );

            byte[] response;
            hr = XRLUtil.PostXrlRequest( VirtualInterface.stfd_storage_int, req.GetXRL(), httpAuthData.GetBase64EncodedString(), stream.ToArray(), null, out response );
            if( HResult.Failed( hr ) )
            {
                return hr;
            }

            // Log this request
            string szLog = "ATT|"
                + Utilities.GetSubjectName()       + "|"
                + Utilities.GetRequestID()         + "|"
                + Utilities.GetClientIPPort()      + "|"
                + dwTitleID.ToString("X")          + "|"
                + rgbData.Length.ToString("X")     + "|"
                + fIsPackage.ToString();

            Xom.Log(XomAreaName.wcMessagingLog, szLog );
            Xom.Log(XomAreaName.Reporting_v2, szLog );

            return HResult.S_OK;
        }

        //
        // Common code shared by GetMessageDetails and GetTitleWideMessageDetails
        //
        private void PopulateDetails( out WCMessageDetails destDetails, ref MessageDetails srcDetails )
        {
            if( null == srcDetails || 0 == srcDetails.wPropCount )
            {
                // Nothing to do
                destDetails = null;
                return;
            }

            destDetails = new WCMessageDetails();

            // First, we need to know how many of each property type there are
            // NOTE: I would love to have a better way to do this...
            uint cNullProps = 0;
            uint cByteProps = 0;
            uint cWordProps = 0;
            uint cDwordProps = 0;
            uint cQwordProps = 0;
            uint cStringProps = 0;
            uint cTimeProps = 0;
            uint cBinaryProps = 0;
            uint cAttachProps = 0;
            uint cBoolProps = 0;
            uint cStringIdProps = 0;

            for( uint iProp = 0; iProp < srcDetails.wPropCount; iProp++ )
            {
                byte bPropType = MsgDefs.XOnlineMessageGetPropType( srcDetails.rgProperties[ iProp ].wPropTag );

                switch( bPropType )
                {
                case MsgDefs.XONLINE_MSG_PROP_TYPE_NULL:         cNullProps++;         break;
                case MsgDefs.XONLINE_MSG_PROP_TYPE_I1:           cByteProps++;         break;
                case MsgDefs.XONLINE_MSG_PROP_TYPE_I2:           cWordProps++;         break;
                case MsgDefs.XONLINE_MSG_PROP_TYPE_I4:           cDwordProps++;        break;
                case MsgDefs.XONLINE_MSG_PROP_TYPE_I8:           cQwordProps++;        break;
                case MsgDefs.XONLINE_MSG_PROP_TYPE_STRING:       cStringProps++;       break;
                case MsgDefs.XONLINE_MSG_PROP_TYPE_FILETIME:     cTimeProps++;         break;
                case MsgDefs.XONLINE_MSG_PROP_TYPE_BINARY:       cBinaryProps++;       break;
                case MsgDefs.XONLINE_MSG_PROP_TYPE_ATTACHMENT:   cAttachProps++;       break;
                case MsgDefs.XONLINE_MSG_PROP_TYPE_BOOL:         cBoolProps++;         break;
                case MsgDefs.XONLINE_MSG_PROP_TYPE_STRING_ID:    cStringIdProps++;     break;

                default: throw new XboxWebInternalException( XEvent.Id.WEBCACHE_UNKNOWN_ERROR_21, "Unknown property type encountered in PopulateDetails" );
                }
            }

            // Allocate the details structures
            if( 0 != cNullProps )       destDetails.NullProp       = new WCNullProp[ cNullProps ];
            if( 0 != cByteProps )       destDetails.ByteProp       = new WCByteProp[ cByteProps ];
            if( 0 != cWordProps )       destDetails.WordProp       = new WCWordProp[ cWordProps ];
            if( 0 != cDwordProps )      destDetails.DwordProp      = new WCDwordProp[ cDwordProps ];
            if( 0 != cQwordProps )      destDetails.QwordProp      = new WCQwordProp[ cQwordProps ];
            if( 0 != cStringProps )     destDetails.StringProp     = new WCStringProp[ cStringProps ];
            if( 0 != cTimeProps )       destDetails.TimeProp       = new WCTimeProp[ cTimeProps ];
            if( 0 != cBinaryProps )     destDetails.BinaryProp     = new WCBinaryProp[ cBinaryProps ];
            if( 0 != cAttachProps )     destDetails.AttachmentProp = new WCAttachmentProp[ cAttachProps ];
            if( 0 != cBoolProps )       destDetails.BoolProp       = new WCBoolProp[ cBoolProps ];
            if( 0 != cStringIdProps )   destDetails.StringIdProp   = new WCStringIdProp[ cStringIdProps ];

            BinaryReader reader = new BinaryReader( new MemoryStream( srcDetails.rgbData ) );

            // Fill in the details structures
            for( uint iProp = 0; iProp < srcDetails.wPropCount; iProp++ )
            {
                byte bPropType = MsgDefs.XOnlineMessageGetPropType( srcDetails.rgProperties[ iProp ].wPropTag );

                switch( bPropType )
                {
                case MsgDefs.XONLINE_MSG_PROP_TYPE_NULL:
                    destDetails.NullProp[ cNullProps - 1 ] = new WCNullProp();
                    destDetails.NullProp[ cNullProps - 1 ].PropID = MsgDefs.XOnlineMessageGetPropId( srcDetails.rgProperties[ iProp ].wPropTag );
                    cNullProps--;
                    break;
                case MsgDefs.XONLINE_MSG_PROP_TYPE_I1:
                    destDetails.ByteProp[ cByteProps - 1 ] = new WCByteProp();
                    destDetails.ByteProp[ cByteProps - 1 ].PropID = MsgDefs.XOnlineMessageGetPropId( srcDetails.rgProperties[ iProp ].wPropTag );
                    destDetails.ByteProp[ cByteProps - 1 ].Value = (byte) srcDetails.rgProperties[ iProp ].wPropOffset;
                    cByteProps--;
                    break;
                case MsgDefs.XONLINE_MSG_PROP_TYPE_I2:
                    destDetails.WordProp[ cWordProps - 1 ] = new WCWordProp();
                    destDetails.WordProp[ cWordProps - 1 ].PropID = MsgDefs.XOnlineMessageGetPropId( srcDetails.rgProperties[ iProp ].wPropTag );
                    destDetails.WordProp[ cWordProps - 1 ].Value = srcDetails.rgProperties[ iProp ].wPropOffset;
                    cWordProps--;
                    break;
                case MsgDefs.XONLINE_MSG_PROP_TYPE_I4:
                    destDetails.DwordProp[ cDwordProps - 1 ] = new WCDwordProp();
                    destDetails.DwordProp[ cDwordProps - 1 ].PropID = MsgDefs.XOnlineMessageGetPropId( srcDetails.rgProperties[ iProp ].wPropTag );
                    reader.BaseStream.Seek( srcDetails.rgProperties[ iProp ].wPropOffset, SeekOrigin.Begin );
                    destDetails.DwordProp[ cDwordProps - 1 ].Value = reader.ReadUInt32();
                    cDwordProps--;
                    break;
                case MsgDefs.XONLINE_MSG_PROP_TYPE_I8:
                    destDetails.QwordProp[ cQwordProps - 1 ] = new WCQwordProp();
                    destDetails.QwordProp[ cQwordProps - 1 ].PropID = MsgDefs.XOnlineMessageGetPropId( srcDetails.rgProperties[ iProp ].wPropTag );
                    reader.BaseStream.Seek( srcDetails.rgProperties[ iProp ].wPropOffset, SeekOrigin.Begin );
                    destDetails.QwordProp[ cQwordProps - 1 ].Value = reader.ReadUInt64();
                    cQwordProps--;
                    break;
                case MsgDefs.XONLINE_MSG_PROP_TYPE_STRING:
                    destDetails.StringProp[ cStringProps - 1 ] = new WCStringProp();
                    destDetails.StringProp[ cStringProps - 1 ].PropID = MsgDefs.XOnlineMessageGetPropId( srcDetails.rgProperties[ iProp ].wPropTag );

                    reader.BaseStream.Seek( srcDetails.rgProperties[ iProp ].wPropOffset, SeekOrigin.Begin );
                    MessageStringProperty strprop = new MessageStringProperty();
                    strprop.ReadStream( reader );

                    destDetails.StringProp[ cStringProps - 1 ].Value = strprop.szString;

                    cStringProps--;
                    break;
                case MsgDefs.XONLINE_MSG_PROP_TYPE_FILETIME:
                    destDetails.TimeProp[ cTimeProps - 1 ] = new WCTimeProp();
                    destDetails.TimeProp[ cTimeProps - 1 ].PropID = MsgDefs.XOnlineMessageGetPropId( srcDetails.rgProperties[ iProp ].wPropTag );
                    reader.BaseStream.Seek( srcDetails.rgProperties[ iProp ].wPropOffset, SeekOrigin.Begin );
                    destDetails.TimeProp[ cTimeProps - 1 ].Value = new DateTime( reader.ReadInt64() );
                    cTimeProps--;
                    break;
                case MsgDefs.XONLINE_MSG_PROP_TYPE_BINARY:
                    destDetails.BinaryProp[ cBinaryProps - 1 ] = new WCBinaryProp();
                    destDetails.BinaryProp[ cBinaryProps - 1 ].PropID = MsgDefs.XOnlineMessageGetPropId( srcDetails.rgProperties[ iProp ].wPropTag );

                    reader.BaseStream.Seek( srcDetails.rgProperties[ iProp ].wPropOffset, SeekOrigin.Begin );
                    MessageBinaryProperty binprop = new MessageBinaryProperty();
                    binprop.ReadStream( reader );

                    destDetails.BinaryProp[ cBinaryProps - 1 ].Value = binprop.rgbData;

                    cBinaryProps--;
                    break;
                case MsgDefs.XONLINE_MSG_PROP_TYPE_ATTACHMENT:
                    destDetails.AttachmentProp[ cAttachProps - 1 ] = new WCAttachmentProp();
                    destDetails.AttachmentProp[ cAttachProps - 1 ].PropID = MsgDefs.XOnlineMessageGetPropId( srcDetails.rgProperties[ iProp ].wPropTag );

                    reader.BaseStream.Seek( srcDetails.rgProperties[ iProp ].wPropOffset, SeekOrigin.Begin );
                    MessageAttachmentProperty attachprop = new MessageAttachmentProperty();
                    attachprop.ReadStream( reader );

                    destDetails.AttachmentProp[ cAttachProps - 1 ].AttachSize = attachprop.cbAttach;
                    destDetails.AttachmentProp[ cAttachProps - 1 ].AttachFlags = (WCAttachFlags) attachprop.dwAttachFlags;
                    destDetails.AttachmentProp[ cAttachProps - 1 ].AttachUrl = attachprop.szAttachUrl;

                    cAttachProps--;
                    break;
                case MsgDefs.XONLINE_MSG_PROP_TYPE_BOOL:
                    destDetails.BoolProp[ cBoolProps - 1 ] = new WCBoolProp();
                    destDetails.BoolProp[ cBoolProps - 1 ].PropID = MsgDefs.XOnlineMessageGetPropId( srcDetails.rgProperties[ iProp ].wPropTag );
                    destDetails.BoolProp[ cBoolProps - 1 ].Value = srcDetails.rgProperties[ iProp ].wPropOffset > 0 ? true : false;
                    cBoolProps--;
                    break;
                case MsgDefs.XONLINE_MSG_PROP_TYPE_STRING_ID:
                    destDetails.StringIdProp[ cStringIdProps - 1 ] = new WCStringIdProp();
                    destDetails.StringIdProp[ cStringIdProps - 1 ].PropID = MsgDefs.XOnlineMessageGetPropId( srcDetails.rgProperties[ iProp ].wPropTag );
                    reader.BaseStream.Seek( srcDetails.rgProperties[ iProp ].wPropOffset, SeekOrigin.Begin );
                    destDetails.StringIdProp[ cStringIdProps - 1 ].Value = reader.ReadUInt32();
                    cStringIdProps--;
                    break;

                default: throw new XboxWebInternalException( XEvent.Id.WEBCACHE_UNKNOWN_ERROR_22, "Unknown property type encountered in PopulateDetails" );
                }
            }

        } // PopulateDetails

        //
        // Common code shared by SendToUserCommon and SendTitleWideMessage
        //
        private HResult SendCommon( uint TitleID, ulong SenderPuid, DateTime MsgExpireTime, ref CMessage message, ref WCMessageDetails Details, ref WCMessageAttachment[] Attachment )
        {
            HResult hr = HResult.S_OK;

            // We want to make sure any attachments expire after the message, so we add 5 hours to their expiration.  The client
            // also does this.
            MsgExpireTime = MsgExpireTime.AddHours( 5 );

            // First store any attachments with the Storage Service
            if( null != Attachment )
            {
                // Build the path used for attachments
                //     "//msg.<country-id>/u:<puid>/<message-GUID>_<attachment-ID>"
                //
                string strAttachBase = "//msg.0/u:" + SenderPuid.ToString("x") + "/" + Guid.NewGuid().ToString() + "_";

                for( uint iAttach = 0; iAttach < Attachment.Length; iAttach++ )
                {
                    if( null == Attachment[ iAttach ].Data || 
                        0 == Attachment[ iAttach ].Data.Length )
                    {
                        // Nothing to attach
                        continue;
                    }

                    ushort wPropTag = MsgDefs.XONLINE_MSG_PROP_TAG( MsgDefs.XONLINE_MSG_PROP_TYPE_ATTACHMENT, Attachment[ iAttach ].PropID );

                    string strAttachPath = strAttachBase + wPropTag.ToString( "x" );

                    // Call Storage to store the attachment, then add its path to the message
                    hr = StorageWrite( Attachment[ iAttach ].Data, 
                                       TitleID, 
                                       SenderPuid,
                                       0 != ( (uint) Attachment[ iAttach ].Flags & MsgDefs.XONLINE_MSG_ATTACHMENT_FLAG_DIRECTORY ), 
                                       strAttachPath, 
                                       MsgExpireTime );
                    if( HResult.Failed( hr ) )
                    {
                        return hr;
                    }

                    // Add the storage path to the message
                    message.AddAttachment( wPropTag, strAttachPath, (uint) Attachment[ iAttach ].Data.Length, (uint) Attachment[ iAttach ].Flags );
                }
            }

            // Next add on any passed-in message details
            if( null != Details )
            {
                try
                {
                    if( null != Details.NullProp )
                    {
                        for( uint iProp = 0; iProp < Details.NullProp.Length; iProp++ )
                        {
                            if( null != Details.NullProp[ iProp ] )
                            {
                                ushort wPropTag = MsgDefs.XONLINE_MSG_PROP_TAG( MsgDefs.XONLINE_MSG_PROP_TYPE_NULL, Details.NullProp[ iProp ].PropID );
                                message.AddProperty( wPropTag );
                            }
                        }
                    }
                    if( null != Details.ByteProp )
                    {
                        for( uint iProp = 0; iProp < Details.ByteProp.Length; iProp++ )
                        {
                            if( null != Details.ByteProp[ iProp ] )
                            {
                                ushort wPropTag = MsgDefs.XONLINE_MSG_PROP_TAG( MsgDefs.XONLINE_MSG_PROP_TYPE_I1, Details.ByteProp[ iProp ].PropID );
                                message.AddProperty( wPropTag, Details.ByteProp[ iProp ].Value );
                            }
                        }
                    }
                    if( null != Details.WordProp )
                    {
                        for( uint iProp = 0; iProp < Details.WordProp.Length; iProp++ )
                        {
                            if( null != Details.WordProp[ iProp ] )
                            {
                                ushort wPropTag = MsgDefs.XONLINE_MSG_PROP_TAG( MsgDefs.XONLINE_MSG_PROP_TYPE_I2, Details.WordProp[ iProp ].PropID );
                                message.AddProperty( wPropTag, Details.WordProp[ iProp ].Value );
                            }
                        }
                    }
                    if( null != Details.DwordProp )
                    {
                        for( uint iProp = 0; iProp < Details.DwordProp.Length; iProp++ )
                        {
                            if( null != Details.DwordProp[ iProp ] )
                            {
                                ushort wPropTag = MsgDefs.XONLINE_MSG_PROP_TAG( MsgDefs.XONLINE_MSG_PROP_TYPE_I4, Details.DwordProp[ iProp ].PropID );
                                message.AddProperty( wPropTag, Details.DwordProp[ iProp ].Value );
                            }
                        }
                    }
                    if( null != Details.QwordProp )
                    {
                        for( uint iProp = 0; iProp < Details.QwordProp.Length; iProp++ )
                        {
                            if( null != Details.QwordProp[ iProp ] )
                            {
                                ushort wPropTag = MsgDefs.XONLINE_MSG_PROP_TAG( MsgDefs.XONLINE_MSG_PROP_TYPE_I8, Details.QwordProp[ iProp ].PropID );
                                message.AddProperty( wPropTag, Details.QwordProp[ iProp ].Value );
                            }
                        }
                    }
                    if( null != Details.StringProp )
                    {
                        for( uint iProp = 0; iProp < Details.StringProp.Length; iProp++ )
                        {
                            if( null != Details.StringProp[ iProp ] )
                            {
                                ushort wPropTag = MsgDefs.XONLINE_MSG_PROP_TAG( MsgDefs.XONLINE_MSG_PROP_TYPE_STRING, Details.StringProp[ iProp ].PropID );
                                message.AddProperty( wPropTag, Details.StringProp[ iProp ].Value );
                            }
                        }
                    }
                    if( null != Details.TimeProp )
                    {
                        for( uint iProp = 0; iProp < Details.TimeProp.Length; iProp++ )
                        {
                            if( null != Details.TimeProp[ iProp ] )
                            {
                                ushort wPropTag = MsgDefs.XONLINE_MSG_PROP_TAG( MsgDefs.XONLINE_MSG_PROP_TYPE_FILETIME, Details.TimeProp[ iProp ].PropID );
                                message.AddProperty( wPropTag, Details.TimeProp[ iProp ].Value );
                            }
                        }
                    }
                    if( null != Details.BinaryProp )
                    {
                        for( uint iProp = 0; iProp < Details.BinaryProp.Length; iProp++ )
                        {
                            if( null != Details.BinaryProp[ iProp ] )
                            {
                                ushort wPropTag = MsgDefs.XONLINE_MSG_PROP_TAG( MsgDefs.XONLINE_MSG_PROP_TYPE_BINARY, Details.BinaryProp[ iProp ].PropID );
                                message.AddProperty( wPropTag, Details.BinaryProp[ iProp ].Value );
                            }
                        }
                    }
                    if( null != Details.AttachmentProp )
                    {
                        for( uint iProp = 0; iProp < Details.AttachmentProp.Length; iProp++ )
                        {
                            if( null != Details.AttachmentProp[ iProp ] )
                            {
                                ushort wPropTag = MsgDefs.XONLINE_MSG_PROP_TAG( MsgDefs.XONLINE_MSG_PROP_TYPE_ATTACHMENT, Details.AttachmentProp[ iProp ].PropID );
                                message.AddAttachment( wPropTag, 
                                                    Details.AttachmentProp[ iProp ].AttachUrl,
                                                    Details.AttachmentProp[ iProp ].AttachSize,
                                                    (uint) Details.AttachmentProp[ iProp ].AttachFlags );
                            }
                        }
                    }
                    if( null != Details.BoolProp )
                    {
                        for( uint iProp = 0; iProp < Details.BoolProp.Length; iProp++ )
                        {
                            if( null != Details.BoolProp[ iProp ] )
                            {
                                ushort wPropTag = MsgDefs.XONLINE_MSG_PROP_TAG( MsgDefs.XONLINE_MSG_PROP_TYPE_BOOL, Details.BoolProp[ iProp ].PropID );
                                message.AddProperty( wPropTag, Details.BoolProp[ iProp ].Value );
                            }
                        }
                    }
                    if( null != Details.StringIdProp )
                    {
                        for( uint iProp = 0; iProp < Details.StringIdProp.Length; iProp++ )
                        {
                            if( null != Details.StringIdProp[ iProp ] )
                            {
                                ushort wPropTag = MsgDefs.XONLINE_MSG_PROP_TAG( MsgDefs.XONLINE_MSG_PROP_TYPE_STRING_ID, Details.StringIdProp[ iProp ].PropID );
                                message.AddProperty( wPropTag, Details.StringIdProp[ iProp ].Value );
                            }
                        }
                    }
                }
                catch( ApplicationException e )
                {
                    throw new XboxWebExceptionNoEvent( e.Message );
                }
            }

            return hr;

        } // SendCommon

        //
        // Common code for sending to a list of recipients
        //
        private HResult SendToUserCommon( ref CUserMessage message, ref string[] Recipient, ref WCMessageDetails Details, ref WCMessageAttachment[] Attachment, out WCRecipientResult[] RecipResult )
        {
            HResult hr;
            RecipResult = null;

            // Validate the message type
            switch( (WCMessageType) message.GetMessageType() )
            {
            case WCMessageType.FriendRequest:
            case WCMessageType.GameInvite:
            case WCMessageType.TeamRecruit:
            case WCMessageType.LiveMessage:
            case WCMessageType.VideoMessage:
            case WCMessageType.VideoChatInvite:
            case WCMessageType.QuickChatInvite:
            case WCMessageType.PartyChatInvite:
            default:
                // These types must be sent from feature specific widgets
                Xom.Trace(XomAreaName.wcMessagingTrace, LogLevel.L_ERROR, "SendToUserCommon: Attempt to send disallowed message type: " + message.GetMessageType().ToString() );
                return HResult.E_INVALIDARG;

            case WCMessageType.TitleCustom:
            case WCMessageType.CompReminder:
            case WCMessageType.CompRequest:
            case WCMessageType.PersonalMessage:
                // These types can be sent from here
                break;
            }

            // Make sure we have some recipients
            if( null == Recipient || 0 == Recipient.Length )
            {
                // Nothing to do
                Xom.Trace(XomAreaName.wcMessagingTrace, LogLevel.L_WARNING, "SendToUserCommon: Called with no recipients, nothing to do." );
                return HResult.S_OK;
            }

            // Calculate the message expiration so that it can be used for any dependent objects like strings or attachments
            DateTime MsgExpireTime = DateTime.UtcNow.AddMinutes( message.GetExpireMinutes() );
                
            // First add all of the passed in recipients
            ulong[] rgRecipientIDs = LookupPUIDs( Recipient );
            if( null == rgRecipientIDs || 0 == rgRecipientIDs.Length )
            {
                Xom.Trace(XomAreaName.wcMessagingTrace, LogLevel.L_ERROR, "SendToUserCommon: Failed to find PUID for all recipients" );
                return 0x80070525; // HRESULT_FROM_WIN32( ERROR_NO_SUCH_USER )
            }

            ArrayList alUnknownRecips = new ArrayList();
            for( int iRecip = 0; iRecip < rgRecipientIDs.Length; iRecip++ )
            {
                // Track any gamertag that wasn't found so we can report it in the response
                if( 0 == rgRecipientIDs[ iRecip ] )
                {
                    Xom.Trace(XomAreaName.wcMessagingTrace, LogLevel.L_ERROR, "SendToUserCommon: Failed to find PUID for recipient " + Recipient[ iRecip ] );
                    alUnknownRecips.Add( Recipient[ iRecip ] );
                }
                else
                {
                    message.AddRecipient( rgRecipientIDs[ iRecip ] );
                }
            }

            // Next store any attachments with the Storage Service and add on any passed-in message details
            CMessage basemsg = message;
            hr = SendCommon( message.GetSenderTitleId(), message.GetSenderId(), MsgExpireTime, ref basemsg, ref Details, ref Attachment );
            if( HResult.Failed( hr ) )
            {
                Xom.Trace(XomAreaName.wcMessagingTrace, LogLevel.L_ERROR, "SendToUserCommon: SendCommon failed, hr = " + hr );
                return hr;
            }

            // Let the FD know who is calling
            Utilities.RequestInfo requestInfo = Utilities.GetRequestInfo();
            HTTPAuthData httpAuthData = new HTTPAuthData( requestInfo.ClientPort, requestInfo.ClientIP, requestInfo.qwRequestID, message.GetSenderId(), message.GetSenderTitleId(), (uint) XOService.MessagingService, 0 );
            message.SetAuthData( httpAuthData.GetBase64EncodedString() );

            if (message.GetSenderId() != 0)
            {
                // call webalive to ensure that presence knows about this user.
                hr = WebAliveUser(message.GetSenderId(), httpAuthData);
                if( HResult.Failed( hr ) )
                {
                    Xom.Trace(XomAreaName.wcMessagingTrace, LogLevel.L_ERROR, "SendToUserCommon: WebAliveUser failed, hr = " + hr );
                    return hr;
                }
            }
            
            // Finally, send the message to the Messaging Service
            hr = message.Send();
            if( HResult.Failed( hr ) )
            {
                Xom.Trace(XomAreaName.wcMessagingTrace, LogLevel.L_ERROR, "SendToUserCommon: CUserMessage::Send failed, hr = " + hr );
                return hr;
            }

            // NOTE: If Send() succeeds, hr is the value from the response, so it will contain any success code at this point
            if( 0 != alUnknownRecips.Count )
            {
                // We are going to fail at least one recipient, so we need to return S_FALSE, even if the response had S_OK
                hr = HResult.S_FALSE;
            }

            // Go through the returned results and copy them over to the equivalent widget structures
            SendMessageReply response = message.GetResponse();
            if( 0 != response.cRecipients || 0 != alUnknownRecips.Count )
            {
                RecipResult = new WCRecipientResult[ response.cRecipients + alUnknownRecips.Count ];

                if( 0 != response.cRecipients )
                {
                    // Batch the call to xcache
                    ulong[] rgRetRecips = new ulong[ response.cRecipients ];
                    for( int iRecip = 0; iRecip < response.cRecipients; iRecip++ )
                    {
                        rgRetRecips[ iRecip ] = response.recipients[ iRecip ].qwUserID;
                    }           
  
                    // Look-up gamertag from the cache (presumably this shouldn't be able to fail since the reverse look-up succeeded prior to the send)
                    string[] rgRetGamerTags = LookupGamerTags( rgRetRecips );
                    if( null == rgRetGamerTags )
                    {
                        Xom.Trace(XomAreaName.wcMessagingTrace, LogLevel.L_ERROR, "SendToUserCommon: Failed to find GamerTag for all PUIDs in response" );
                        return 0x80070525; // HRESULT_FROM_WIN32( ERROR_NO_SUCH_USER )
                    }

                    for( int iRecip = 0; iRecip < response.cRecipients; iRecip++ )
                    {
                        if( Utilities.IsInvalidGamertag( rgRetGamerTags[ iRecip ] ) )
                        {
                            Xom.Trace(XomAreaName.wcMessagingTrace, LogLevel.L_ERROR, "SendToUserCommon: Failed to find GamerTag for PUID in response " + response.recipients[ iRecip ].qwUserID );
                            return 0x80070525; // HRESULT_FROM_WIN32( ERROR_NO_SUCH_USER )
                        }

                        RecipResult[ iRecip ] = new WCRecipientResult();
                        RecipResult[ iRecip ].User = rgRetGamerTags[ iRecip ];
                        RecipResult[ iRecip ].MessageID = response.recipients[ iRecip ].dwMessageID;
                    }
                }
                for( int iRecip = 0; iRecip < alUnknownRecips.Count; iRecip++ )
                {
                    RecipResult[ iRecip ] = new WCRecipientResult();
                    RecipResult[ iRecip ].User = (string) alUnknownRecips[ iRecip ];
                    RecipResult[ iRecip ].MessageID = 0x80070525; // HRESULT_FROM_WIN32( ERROR_NO_SUCH_USER )
                }
            }

            Xom.Trace(XomAreaName.wcMessagingTrace, LogLevel.L_NORMAL, "SendToUserCommon: Returning hr = " + hr );
            return hr;

        } // SendToUserCommon

        //
        // Common code for revoking from a list of recipients
        //
        private HResult RevokeMessageCommon( ulong puid, ref WCRecipientResult[] RecipResult )
        {
            HResult hr;

            // Make sure we have some recipients
            if( null == RecipResult || 0 == RecipResult.Length )
            {
                // Nothing to do
                Xom.Trace(XomAreaName.wcMessagingTrace, LogLevel.L_WARNING, "RevokeMessageCommon: Called with no recipients, nothing to do." );
                return HResult.S_OK;
            }

            RevokeMessageMsg request = new RevokeMessageMsg();
            RevokeMessageReply response = new RevokeMessageReply();

            // Build the request
            request.qwSenderID = puid;
            request.qwSenderContext = 0;
            request.bMessageType = 0;
            request.cRecipients = (ushort) RecipResult.Length;
              
            // Batch the call to xcache
            string[] rgGamerTags = new string[ RecipResult.Length ];
            for( int iRecip = 0; iRecip < RecipResult.Length; iRecip++ )
            {
                rgGamerTags[ iRecip ] = RecipResult[ iRecip ].User;
            }           
  
            // Look-up PUID from cache
            ulong[] rgqwUserIDs = LookupPUIDs( rgGamerTags );
            if( null == rgqwUserIDs )
            {
                Xom.Trace(XomAreaName.wcMessagingTrace, LogLevel.L_ERROR, "RevokeMessageCommon: Failed to find PUID for all recipients" );
                return 0x80070525; // HRESULT_FROM_WIN32( ERROR_NO_SUCH_USER )
            }
   
            request.rgRecipients = new RecipientResult[ RecipResult.Length ];
            for( int iRecip = 0; iRecip < RecipResult.Length; iRecip++ )
            {
                if( 0 == rgqwUserIDs[ iRecip ] )
                {
                    Xom.Trace(XomAreaName.wcMessagingTrace, LogLevel.L_ERROR, "RevokeMessageCommon: Failed to find PUID for recipient " + RecipResult[ iRecip ].User );
                    return 0x80070525; // HRESULT_FROM_WIN32( ERROR_NO_SUCH_USER )
                }
                request.rgRecipients[ iRecip ] = new RecipientResult();
                request.rgRecipients[ iRecip ].qwUserID = rgqwUserIDs[ iRecip ];
                request.rgRecipients[ iRecip ].dwMessageID = RecipResult[ iRecip ].MessageID;
            }

            // For some reason PostXrlRequest won't accept a type that inherits from XRLObject2 for the response
            XRLObject2 xrlo = response;

            // Let the FD know who is calling
            Utilities.RequestInfo requestInfo = Utilities.GetRequestInfo();
            HTTPAuthData httpAuthData = new HTTPAuthData( requestInfo.ClientPort, requestInfo.ClientIP, requestInfo.qwRequestID, puid, 0, (uint) XOService.MessagingService, 0 );

            if (puid != 0)
            {
                // call webalive to ensure that presence knows about this user.
                hr = WebAliveUser(puid, httpAuthData);
                if( HResult.Failed( hr ) )
                {
                    Xom.Trace(XomAreaName.wcMessagingTrace, LogLevel.L_ERROR, "RevokeMessageCommon: WebAliveUser failed, hr = " + hr );
                    return hr;
                }
            }

            // Call the Messaging front door to hand the request
            hr = XRLUtil.PostXrlRequest( VirtualInterface.xpnfd_messaging_int, "/xpnfront/xmessaging.srf", httpAuthData.GetBase64EncodedString(), request, ref xrlo );
            if( HResult.Failed( hr ) )
            {
                Xom.Trace(XomAreaName.wcMessagingTrace, LogLevel.L_ERROR, "RevokeMessageCommon: PostXrlRequest failed, hr = " + hr );
                return hr;
            }

            hr = response.hr;
            if( HResult.Failed( hr ) )
            {
                Xom.Trace(XomAreaName.wcMessagingTrace, LogLevel.L_ERROR, "RevokeMessageCommon: PostXrlRequest got back failed response, hr = " + hr );
                return hr;
            }

            Xom.Trace(XomAreaName.wcMessagingTrace, LogLevel.L_NORMAL, "RevokeMessageCommon: Returning hr = " + hr );
            return hr;

        } // RevokeMessageCommon

        private HResult WebAliveUser(ulong puid, HTTPAuthData httpAuthData)
        {
            WebAliveRequest webAlive = new WebAliveRequest();
            webAlive.puid = puid;

            WebAliveResponse waResponse = new WebAliveResponse();
            XRLObject2 xrlo = waResponse;

            HResult hr = XRLUtil.PostXrlRequest( VirtualInterface.xpnfd_presence_int, webAlive.GetXRL(), httpAuthData.GetBase64EncodedString(), webAlive, ref xrlo );
            if( HResult.Failed( hr ) )
            {
                Xom.Trace(XomAreaName.wcMessagingTrace, LogLevel.L_ERROR, "WebAliveUser: PostXrlRequest failed, hr = " + hr );
                return hr;
            }

            hr = waResponse.hr;
            if(waResponse.hr != HResult.S_OK)
            {
                Xom.Trace(XomAreaName.wcMessagingTrace, LogLevel.L_ERROR, "WebAliveUser: failed response, hr = " + hr );
                return hr;
            }

            if (waResponse.puid != puid)
            {
                Xom.Trace(XomAreaName.wcMessagingTrace, LogLevel.L_ERROR, "WebAliveUser: puid mismatch on response: " + waResponse.puid.ToString("X") + " != " + puid.ToString("X"));
                return HResult.XONLINE_E_NOTIFICATION_INVALID_PUID;
            }

            return HResult.S_OK;
        }


        //
        // Begin WebService method implementation
        //
 
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/EnumMessages", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public override System.UInt32 EnumMessages([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] UserWebID, string UserGamerTag, [System.Xml.Serialization.XmlElementAttribute("Summary")] out WCMessageSummary[] Summary)
        {
            ushort cMessages = 0;
            HResult hr = HResult.S_OK;
            Summary = null;

            try
            {
                Utilities.Instance.CheckAPI( "Messaging.EnumMessages" );

                // Update perf counters
                WebCacheMessagingCounter.Counters.EnumMessagesRequestsPerSecond.Increment();
                WebCacheMessagingCounter.Counters.EnumMessagesRequestsTotal.Increment();
                       
                string partnerName = Utilities.GetSubjectName();
                if( null != partnerName )
                {
                    WebCacheMessagingCounter.Counters[ partnerName ].EnumMessagesRequestsPerSecond.Increment();
                    WebCacheMessagingCounter.Counters[ partnerName ].EnumMessagesRequestsTotal.Increment();
                }

                // Validate parameters
                if( null == User )
                {
                    throw new XboxWebExceptionNoEvent( "Messaging: User cannot be null!" );
                }

                // Look-up PUID from cache (throws if not found)
                PUIDAndOwner puidAndOwner = LookupWebID( UserWebID, UserGamerTag );

                EnumerateMessagesMsg request = new EnumerateMessagesMsg();
                EnumerateMessagesReply response = new EnumerateMessagesReply();

                // Build the request
                request.qwUserID = puidAndOwner.PUID;

                // For some reason PostXrlRequest won't accept a type that inherits from XRLObject2 for the response
                XRLObject2 xrlo = response;

                // Let the FD know who is calling
                Utilities.RequestInfo requestInfo = Utilities.GetRequestInfo();
                HTTPAuthData httpAuthData = new HTTPAuthData( requestInfo.ClientPort, requestInfo.ClientIP, requestInfo.qwRequestID, puidAndOwner.PUID, 0, (uint) XOService.MessagingService, 0 );

                // call webalive to ensure that presence knows about this user.
                hr = WebAliveUser(puidAndOwner.PUID, httpAuthData);
                if( HResult.Failed( hr ) )
                {
                    Xom.Trace(XomAreaName.wcMessagingTrace, LogLevel.L_ERROR, "EnumMessages: WebAliveUser failed, hr = " + hr );
                    return hr;
                }

                // Call the Messaging front door to hand the request
                hr = XRLUtil.PostXrlRequest( VirtualInterface.xpnfd_messaging_int, "/xpnfront/xmessaging.srf", httpAuthData.GetBase64EncodedString(), request, ref xrlo );
                if( HResult.Failed( hr ) )
                {
                    Xom.Trace(XomAreaName.wcMessagingTrace, LogLevel.L_ERROR, "EnumMessages: PostXrlRequest failed, hr = " + hr );
                    return hr;
                }

                hr = response.hr;
                if( HResult.Failed( hr ) )
                {
                    Xom.Trace(XomAreaName.wcMessagingTrace, LogLevel.L_ERROR, "EnumMessages: PostXrlRequest got back failed response, hr = " + hr );
                    return hr;
                }

                // Loop through the returned messages and convert them from Messaging structures to the widget equivalents
                if( 0 != response.cMessages )
                {
                    cMessages = response.cMessages;

                    Summary = new WCMessageSummary[ response.cMessages ];

                    for( uint iMsg = 0; iMsg < response.cMessages; iMsg++ )
                    {
                        Summary[ iMsg ] = new WCMessageSummary();

                        Summary[ iMsg ].Sender           = response.rgMessages[ iMsg ].szSenderName;
                        Summary[ iMsg ].SenderContext    = response.rgMessages[ iMsg ].qwSenderContext;
                        Summary[ iMsg ].SentTime         = MsgDefs.MsgTimeToDateTime( response.rgMessages[ iMsg ].mtSentTime );
                        Summary[ iMsg ].MessageID        = response.rgMessages[ iMsg ].dwMessageID;
                        Summary[ iMsg ].MessageFlags     = (WCMessageFlags) response.rgMessages[ iMsg ].dwMessageFlags;
                        Summary[ iMsg ].SenderTitleID    = response.rgMessages[ iMsg ].dwSenderTitleID;
                        Summary[ iMsg ].ExpireMinutes    = response.rgMessages[ iMsg ].wExpireMinutes;
                        Summary[ iMsg ].DetailsSize      = response.rgMessages[ iMsg ].cbDetails;
                        Summary[ iMsg ].MessageType      = (WCMessageType) response.rgMessages[ iMsg ].bMessageType;
                    }
                }
                
                Xom.Trace(XomAreaName.wcMessagingTrace, LogLevel.L_NORMAL, "EnumMessages: Returning " + response.cMessages.ToString() + " messages, hr = " + hr );
                return hr;
            }
            catch (XboxWebException)
            {
                hr = HResult.E_FAIL;
                throw;
            }
            catch (Exception e)
            {
                hr = HResult.E_FAIL;
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_23, e);
            }
            finally
            {
                string szLog = "ENM|"
                    + Utilities.GetSubjectName()                          + "|"
                    + Utilities.GetRequestID()                            + "|"
                    + Utilities.GetClientIPPort()                         + "|"
                    + UserGamerTag                                        + "|"
                    + StringFromWebID( UserWebID )                        + "|"
                    + cMessages.ToString("X")                             + "|"
                    + hr;

                Xom.Log(XomAreaName.wcMessagingLog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );
            }
        }
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/GetMessageDetails", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public override System.UInt32 GetMessageDetails([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] UserWebID, string UserGamerTag, System.UInt32 MessageID, WCMessageFlags SetFlags, WCMessageFlags UnsetFlags, out WCMessageSummary Summary, out WCMessageDetails Details)
        {
            HResult hr = HResult.S_OK;
            byte MessageType = 0;
            Summary = null;
            Details = null;

            try
            {
                Utilities.Instance.CheckAPI( "Messaging.GetMessageDetails" );

                // Update perf counters
                WebCacheMessagingCounter.Counters.GetMessageDetailsRequestsPerSecond.Increment();
                WebCacheMessagingCounter.Counters.GetMessageDetailsRequestsTotal.Increment();
                       
                string partnerName = Utilities.GetSubjectName();
                if( null != partnerName )
                {
                    WebCacheMessagingCounter.Counters[ partnerName ].GetMessageDetailsRequestsPerSecond.Increment();
                    WebCacheMessagingCounter.Counters[ partnerName ].GetMessageDetailsRequestsTotal.Increment();
                }

                // Validate parameters
                if( null == User )
                {
                    throw new XboxWebExceptionNoEvent( "Messaging: User cannot be null!" );
                }

                // Look-up PUID from cache (throws if not found)
                PUIDAndOwner puidAndOwner = LookupWebID( UserWebID, UserGamerTag );

                MessageDetailsMsg request = new MessageDetailsMsg();
                MessageDetailsReply response = new MessageDetailsReply();

                // Build the request
                request.qwUserID = puidAndOwner.PUID;
                request.dwMessageID = MessageID;
                request.dwSetFlags = (uint) SetFlags;
                request.dwUnsetFlags = (uint) UnsetFlags;

                // For some reason PostXrlRequest won't accept a type that inherits from XRLObject2 for the response
                XRLObject2 xrlo = response;

                // Let the FD know who is calling
                Utilities.RequestInfo requestInfo = Utilities.GetRequestInfo();
                HTTPAuthData httpAuthData = new HTTPAuthData( requestInfo.ClientPort, requestInfo.ClientIP, requestInfo.qwRequestID, puidAndOwner.PUID, 0, (uint) XOService.MessagingService, 0 );

                // call webalive to ensure that presence knows about this user.
                hr = WebAliveUser(puidAndOwner.PUID, httpAuthData);
                if( HResult.Failed( hr ) )
                {
                    Xom.Trace(XomAreaName.wcMessagingTrace, LogLevel.L_ERROR, "GetMessageDetails: WebAliveUser failed, hr = " + hr );
                    return hr;
                }

                // Call the Messaging front door to hand the request
                hr = XRLUtil.PostXrlRequest( VirtualInterface.xpnfd_messaging_int, "/xpnfront/xmessaging.srf", httpAuthData.GetBase64EncodedString(), request, ref xrlo );
                if( HResult.Failed( hr ) )
                {
                    Xom.Trace(XomAreaName.wcMessagingTrace, LogLevel.L_ERROR, "GetMessageDetails: PostXrlRequest failed, hr = " + hr );
                    return hr;
                }

                hr = response.hr;
                if( HResult.Failed( hr ) )
                {
                    Xom.Trace(XomAreaName.wcMessagingTrace, LogLevel.L_ERROR, "GetMessageDetails: PostXrlRequest got back failed response, hr = " + hr );
                    return hr;
                }

                MessageType = response.summary.bMessageType;

                // Fill out the message summary ///////////////////////////////////

                Summary = new WCMessageSummary();

                Summary.Sender           = response.summary.szSenderName;
                Summary.SenderContext    = response.summary.qwSenderContext;
                Summary.SentTime         = MsgDefs.MsgTimeToDateTime( response.summary.mtSentTime );
                Summary.MessageID        = response.summary.dwMessageID;
                Summary.MessageFlags     = (WCMessageFlags) response.summary.dwMessageFlags;
                Summary.SenderTitleID    = response.summary.dwSenderTitleID;
                Summary.ExpireMinutes    = response.summary.wExpireMinutes;
                Summary.DetailsSize      = response.summary.cbDetails;
                Summary.MessageType      = (WCMessageType) response.summary.bMessageType;

                // Fill out the message details ///////////////////////////////////

                if( 0 != response.summary.cbDetails )
                {
                    PopulateDetails( out Details, ref response.details );
                }

                // All done ///////////////////////////////////////////////////////

                Xom.Trace(XomAreaName.wcMessagingTrace, LogLevel.L_NORMAL, "GetMessageDetails: Returning hr = " + hr );
                return hr;
            }
            catch (XboxWebException)
            {
                hr = HResult.E_FAIL;
                throw;
            }
            catch (Exception e)
            {
                hr = HResult.E_FAIL;
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_24, e);
            }
            finally
            {
                string szLog = "DET|"
                    + Utilities.GetSubjectName()                          + "|"
                    + Utilities.GetRequestID()                            + "|"
                    + Utilities.GetClientIPPort()                         + "|"
                    + UserGamerTag                                        + "|"
                    + StringFromWebID( UserWebID )                        + "|"
                    + MessageID.ToString("X")                             + "|"
                    + SetFlags.ToString("X")                              + "|"
                    + UnsetFlags.ToString("X")                            + "|"
                    + MessageType.ToString("X")                           + "|"
                    + hr;

                Xom.Log(XomAreaName.wcMessagingLog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );
            }
        }

        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/DeleteMessage", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public override System.UInt32 DeleteMessage([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] UserWebID, string UserGamerTag, System.UInt32 MessageID, WCDeleteMsgFlags Flags)
        {
            HResult hr = HResult.S_OK;

            try
            {
                Utilities.Instance.CheckAPI( "Messaging.DeleteMessage" );

                // Update perf counters
                WebCacheMessagingCounter.Counters.DeleteMessageRequestsPerSecond.Increment();
                WebCacheMessagingCounter.Counters.DeleteMessageRequestsTotal.Increment();
                       
                string partnerName = Utilities.GetSubjectName();
                if( null != partnerName )
                {
                    WebCacheMessagingCounter.Counters[ partnerName ].DeleteMessageRequestsPerSecond.Increment();
                    WebCacheMessagingCounter.Counters[ partnerName ].DeleteMessageRequestsTotal.Increment();
                }

                // Validate parameters
                if( null == User )
                {
                    throw new XboxWebExceptionNoEvent( "Messaging: User cannot be null!" );
                }

                // Look-up PUID from cache (throws if not found)
                PUIDAndOwner puidAndOwner = LookupWebID( UserWebID, UserGamerTag );

                DeleteMessageMsg request = new DeleteMessageMsg();
                DeleteMessageReply response = new DeleteMessageReply();

                // Build the request
                request.qwUserID = puidAndOwner.PUID;
                request.dwMessageID = MessageID;
                request.dwFlags = (uint) Flags;

                // For some reason PostXrlRequest won't accept a type that inherits from XRLObject2 for the response
                XRLObject2 xrlo = response;

                // Let the FD know who is calling
                Utilities.RequestInfo requestInfo = Utilities.GetRequestInfo();
                HTTPAuthData httpAuthData = new HTTPAuthData( requestInfo.ClientPort, requestInfo.ClientIP, requestInfo.qwRequestID, puidAndOwner.PUID, 0, (uint) XOService.MessagingService, 0 );

                // call webalive to ensure that presence knows about this user.
                hr = WebAliveUser(puidAndOwner.PUID, httpAuthData);
                if( HResult.Failed( hr ) )
                {
                    Xom.Trace(XomAreaName.wcMessagingTrace, LogLevel.L_ERROR, "DeleteMessage: WebAliveUser failed, hr = " + hr );
                    return hr;
                }

                // Call the Messaging front door to hand the request
                hr = XRLUtil.PostXrlRequest( VirtualInterface.xpnfd_messaging_int, "/xpnfront/xmessaging.srf", httpAuthData.GetBase64EncodedString(), request, ref xrlo );
                if( HResult.Failed( hr ) )
                {
                    Xom.Trace(XomAreaName.wcMessagingTrace, LogLevel.L_ERROR, "DeleteMessage: PostXrlRequest failed, hr = " + hr );
                    return hr;
                }

                hr = response.hr;
                if( HResult.Failed( hr ) )
                {
                    Xom.Trace(XomAreaName.wcMessagingTrace, LogLevel.L_ERROR, "DeleteMessage: PostXrlRequest got back failed response, hr = " + hr );
                    return hr;
                }

                Xom.Trace(XomAreaName.wcMessagingTrace, LogLevel.L_NORMAL, "DeleteMessage: Returning hr = " + hr );
                return hr;
            }
            catch (XboxWebException)
            {
                hr = HResult.E_FAIL;
                throw;
            }
            catch (Exception e)
            {
                hr = HResult.E_FAIL;
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_25, e);
            }
            finally
            {
                string szLog = "DEL|"
                    + Utilities.GetSubjectName()                          + "|"
                    + Utilities.GetRequestID()                            + "|"
                    + Utilities.GetClientIPPort()                         + "|"
                    + UserGamerTag                                        + "|"
                    + StringFromWebID( UserWebID )                        + "|"
                    + MessageID.ToString("X")                             + "|"
                    + Flags.ToString("X")                                 + "|"
                    + hr;
            
                Xom.Log(XomAreaName.wcMessagingLog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );
            }
        }

        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/SendMessage", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public override System.UInt32 SendMessage([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] SenderWebID, string SenderGamerTag, System.UInt64 SenderContext, WCMessageFlags MessageFlags, System.UInt32 SenderTitleID, System.UInt16 ExpireMinutes, WCMessageType MessageType, [System.Xml.Serialization.XmlElementAttribute("Recipient")] string[] Recipient, WCMessageDetails Details, [System.Xml.Serialization.XmlElementAttribute("Attachment")] WCMessageAttachment[] Attachment, [System.Xml.Serialization.XmlElementAttribute("RecipResult")] out WCRecipientResult[] RecipResult)
        {
            HResult hr = HResult.S_OK;
            RecipResult = null;

            try
            {
                Utilities.Instance.CheckAPIAndTitle( "Messaging.SendMessage", SenderTitleID, TitlePrivilege.ReadWrite );

                // Update perf counters
                WebCacheMessagingCounter.Counters.SendMessageRequestsPerSecond.Increment();
                WebCacheMessagingCounter.Counters.SendMessageRequestsTotal.Increment();
                       
                string partnerName = Utilities.GetSubjectName();
                if( null != partnerName )
                {
                    WebCacheMessagingCounter.Counters[ partnerName ].SendMessageRequestsPerSecond.Increment();
                    WebCacheMessagingCounter.Counters[ partnerName ].SendMessageRequestsTotal.Increment();
                }

                // Look-up PUID from cache (throws if not found)
                PUIDAndOwner puidAndOwner = LookupWebID( SenderWebID, SenderGamerTag );

                CUserMessage message = new CUserMessage( 
                    puidAndOwner.PUID, 
                    SenderContext, 
                    (uint) MessageFlags, 
                    SenderTitleID, 
                    ExpireMinutes, 
                    (byte) MessageType, 
                    SenderGamerTag );

                // Do the send
                hr = SendToUserCommon( ref message, ref Recipient, ref Details, ref Attachment, out RecipResult );

                return hr;
            }
            catch (XboxWebException)
            {
                hr = HResult.E_FAIL;
                throw;
            }
            catch (Exception e)
            {
                hr = HResult.E_FAIL;
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_26, e);
            }
            finally
            {
                string szLog = "SND|"
                    + Utilities.GetSubjectName()                              + "|"
                    + Utilities.GetRequestID()                                + "|"
                    + Utilities.GetClientIPPort()                             + "|"
                    + SenderGamerTag                                          + "|"
                    + StringFromWebID( SenderWebID )                          + "|"
                    + SenderContext.ToString("X")                             + "|"
                    + SenderTitleID.ToString("X")                             + "|"
                    + MessageFlags.ToString("X")                              + "|"
                    + ExpireMinutes.ToString("X")                             + "|"
                    + MessageType.ToString("X")                               + "|"
                    + hr;
            
                Xom.Log(XomAreaName.wcMessagingLog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );
            }
        }

        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/RevokeMessage", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public override System.UInt32 RevokeMessage([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] SenderWebID, string SenderGamerTag, [System.Xml.Serialization.XmlElementAttribute("RecipResult")] WCRecipientResult[] RecipResult)
        {
            HResult hr = HResult.S_OK;

            try
            {
                Utilities.Instance.CheckAPI( "Messaging.RevokeMessage" );

                // Update perf counters
                WebCacheMessagingCounter.Counters.RevokeMessageRequestsPerSecond.Increment();
                WebCacheMessagingCounter.Counters.RevokeMessageRequestsTotal.Increment();
                       
                string partnerName = Utilities.GetSubjectName();
                if( null != partnerName )
                {
                    WebCacheMessagingCounter.Counters[ partnerName ].RevokeMessageRequestsPerSecond.Increment();
                    WebCacheMessagingCounter.Counters[ partnerName ].RevokeMessageRequestsTotal.Increment();
                }

                // Look-up PUID from cache (throws if not found)
                PUIDAndOwner puidAndOwner = LookupWebID( SenderWebID, SenderGamerTag );

                // Do the revoke
                hr = RevokeMessageCommon( puidAndOwner.PUID, ref RecipResult );

                return hr;
            }
            catch (XboxWebException)
            {
                hr = HResult.E_FAIL;
                throw;
            }
            catch (Exception e)
            {
                hr = HResult.E_FAIL;
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_27, e);
            }
            finally
            {
                string szLog = "RVK|"
                    + Utilities.GetSubjectName()                                       + "|"
                    + Utilities.GetRequestID()                                         + "|"
                    + Utilities.GetClientIPPort()                                      + "|"
                    + SenderGamerTag                                                   + "|"
                    + StringFromWebID( SenderWebID )                                   + "|"
                    + ( null == RecipResult ? "0" : RecipResult.Length.ToString("X") ) + "|"
                    + hr;
            
                Xom.Log(XomAreaName.wcMessagingLog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );
            }
        }

        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/DeleteUserTitle", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public override System.UInt32 DeleteUserTitle([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] UserWebID, string UserGamerTag, System.UInt32 TitleID)
        {
            HResult hr = HResult.S_OK;

            try
            {
                Utilities.Instance.CheckAPI( "Messaging.DeleteUserTitle" );

                // Update perf counters
                WebCacheMessagingCounter.Counters.DeleteUserTitleRequestsPerSecond.Increment();
                WebCacheMessagingCounter.Counters.DeleteUserTitleRequestsTotal.Increment();
                       
                string partnerName = Utilities.GetSubjectName();
                if( null != partnerName )
                {
                    WebCacheMessagingCounter.Counters[ partnerName ].DeleteUserTitleRequestsPerSecond.Increment();
                    WebCacheMessagingCounter.Counters[ partnerName ].DeleteUserTitleRequestsTotal.Increment();
                }

                // Validate parameters
                if( null == User )
                {
                    throw new XboxWebExceptionNoEvent( "Messaging: User cannot be null!" );
                }

                // Look-up PUID from cache (throws if not found)
                PUIDAndOwner puidAndOwner = LookupWebID( UserWebID, UserGamerTag );

                DeleteTitleMsg request = new DeleteTitleMsg();
                DeleteTitleReply response = new DeleteTitleReply();

                // Build the request
                request.qwUserID = puidAndOwner.PUID;
                request.dwTitleID = TitleID;

                // For some reason PostXrlRequest won't accept a type that inherits from XRLObject2 for the response
                XRLObject2 xrlo = response;

                // Let the FD know who is calling
                Utilities.RequestInfo requestInfo = Utilities.GetRequestInfo();
                HTTPAuthData httpAuthData = new HTTPAuthData( requestInfo.ClientPort, requestInfo.ClientIP, requestInfo.qwRequestID, puidAndOwner.PUID, 0, (uint) XOService.MessagingService, 0 );

                // call webalive to ensure that presence knows about this user.
                hr = WebAliveUser(puidAndOwner.PUID, httpAuthData);
                if( HResult.Failed( hr ) )
                {
                    Xom.Trace(XomAreaName.wcMessagingTrace, LogLevel.L_ERROR, "DeleteUserTitle: WebAliveUser failed, hr = " + hr );
                    return hr;
                }
               
                // Call the Messaging front door to hand the request
                hr = XRLUtil.PostXrlRequest( VirtualInterface.xpnfd_messaging_int, "/xpnfront/xmessaging.srf", httpAuthData.GetBase64EncodedString(), request, ref xrlo );
                if( HResult.Failed( hr ) )
                {
                    Xom.Trace(XomAreaName.wcMessagingTrace, LogLevel.L_ERROR, "DeleteUserTitle: PostXrlRequest failed, hr = " + hr );
                    return hr;
                }

                hr = response.hr;
                if( HResult.Failed( hr ) )
                {
                    Xom.Trace(XomAreaName.wcMessagingTrace, LogLevel.L_ERROR, "DeleteUserTitle: PostXrlRequest got back failed response, hr = " + hr );
                    return hr;
                }

                Xom.Trace(XomAreaName.wcMessagingTrace, LogLevel.L_NORMAL, "DeleteUserTitle: Returning hr = " + hr );
                return hr;
            }
            catch (XboxWebException)
            {
                hr = HResult.E_FAIL;
                throw;
            }
            catch (Exception e)
            {
                hr = HResult.E_FAIL;
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_28, e);
            }
            finally
            {
                string szLog = "DTL|"
                    + Utilities.GetSubjectName()                          + "|"
                    + Utilities.GetRequestID()                            + "|"
                    + Utilities.GetClientIPPort()                         + "|"
                    + UserGamerTag                                        + "|"
                    + StringFromWebID( UserWebID )                        + "|"
                    + TitleID.ToString("X")                               + "|"
                    + hr;
            
                Xom.Log(XomAreaName.wcMessagingLog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );
            }
        }

        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/EnumUserTitles", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public override System.UInt32 EnumUserTitles([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] UserWebID, string UserGamerTag, [System.Xml.Serialization.XmlElementAttribute("Title")] out WCUserTitle[] Title)
        {
            HResult hr = HResult.S_OK;
            ushort cTitles = 0;
            Title = null;

            try
            {
                Utilities.Instance.CheckAPI( "Messaging.EnumUserTitles" );

                // Update perf counters
                WebCacheMessagingCounter.Counters.EnumUserTitlesRequestsPerSecond.Increment();
                WebCacheMessagingCounter.Counters.EnumUserTitlesRequestsTotal.Increment();
                       
                string partnerName = Utilities.GetSubjectName();
                if( null != partnerName )
                {
                    WebCacheMessagingCounter.Counters[ partnerName ].EnumUserTitlesRequestsPerSecond.Increment();
                    WebCacheMessagingCounter.Counters[ partnerName ].EnumUserTitlesRequestsTotal.Increment();
                }

                // Validate parameters
                if( null == User )
                {
                    throw new XboxWebExceptionNoEvent( "Messaging: User cannot be null!" );
                }

                // Look-up PUID from cache (throws if not found)
                PUIDAndOwner puidAndOwner = LookupWebID( UserWebID, UserGamerTag );

                EnumerateTitlesMsg request = new EnumerateTitlesMsg();
                EnumerateTitlesReply response = new EnumerateTitlesReply();

                // Build the request
                request.qwUserID = puidAndOwner.PUID;

                // For some reason PostXrlRequest won't accept a type that inherits from XRLObject2 for the response
                XRLObject2 xrlo = response;

                // Let the FD know who is calling
                Utilities.RequestInfo requestInfo = Utilities.GetRequestInfo();
                HTTPAuthData httpAuthData = new HTTPAuthData( requestInfo.ClientPort, requestInfo.ClientIP, requestInfo.qwRequestID, puidAndOwner.PUID, 0, (uint) XOService.MessagingService, 0 );

                // call webalive to ensure that presence knows about this user.
                hr = WebAliveUser(puidAndOwner.PUID, httpAuthData);
                if( HResult.Failed( hr ) )
                {
                    Xom.Trace(XomAreaName.wcMessagingTrace, LogLevel.L_ERROR, "EnumUserTitles: WebAliveUser failed, hr = " + hr );
                    return hr;
                }

                // Call the Messaging front door to hand the request
                hr = XRLUtil.PostXrlRequest( VirtualInterface.xpnfd_messaging_int, "/xpnfront/xmessaging.srf", httpAuthData.GetBase64EncodedString(), request, ref xrlo );
                if( HResult.Failed( hr ) )
                {
                    Xom.Trace(XomAreaName.wcMessagingTrace, LogLevel.L_ERROR, "EnumUserTitles: PostXrlRequest failed, hr = " + hr );
                    return hr;
                }

                hr = response.hr;
                if( HResult.Failed( hr ) )
                {
                    Xom.Trace(XomAreaName.wcMessagingTrace, LogLevel.L_ERROR, "EnumUserTitles: PostXrlRequest got back failed response, hr = " + hr );
                    return hr;
                }

                // Loop through the returned messages and convert them from Messaging structures to the widget equivalents
                if( 0 != response.cTitles )
                {
                    cTitles = response.cTitles;

                    Title = new WCUserTitle[ response.cTitles ];

                    for( uint iTitle = 0; iTitle < response.cTitles; iTitle++ )
                    {
                        Title[ iTitle ] = new WCUserTitle();

                        Title[ iTitle ].TitleID          = response.rgTitles[ iTitle ].dwTitleID;
                        Title[ iTitle ].LastLogonTime    = response.rgTitles[ iTitle ].dtLastLogon;
                        Title[ iTitle ].Flags            = (WCUserTitleFlags) response.rgTitles[ iTitle ].dwFlags;
                    }
                }
                
                Xom.Trace(XomAreaName.wcMessagingTrace, LogLevel.L_NORMAL, "EnumUserTitles: Returning " + response.cTitles.ToString() + " titles, hr = " + hr );
                return hr;
            }
            catch (XboxWebException)
            {
                hr = HResult.E_FAIL;
                throw;
            }
            catch (Exception e)
            {
                hr = HResult.E_FAIL;
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_29, e);
            }
            finally
            {
                string szLog = "ETL|"
                    + Utilities.GetSubjectName()                          + "|"
                    + Utilities.GetRequestID()                            + "|"
                    + Utilities.GetClientIPPort()                         + "|"
                    + UserGamerTag                                        + "|"
                    + StringFromWebID( UserWebID )                        + "|"
                    + cTitles.ToString("X")                               + "|"
                    + hr;
            
                Xom.Log(XomAreaName.wcMessagingLog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );
            }
        }

        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/SetMessageFlags", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public override System.UInt32 SetMessageFlags([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] UserWebID, string UserGamerTag, System.UInt32 MessageID, WCMessageFlags SetFlags, WCMessageFlags UnsetFlags)
        {
            HResult hr = HResult.S_OK;

            try
            {
                Utilities.Instance.CheckAPI( "Messaging.SetMessageFlags" );

                // Update perf counters
                WebCacheMessagingCounter.Counters.SetMessageFlagsRequestsPerSecond.Increment();
                WebCacheMessagingCounter.Counters.SetMessageFlagsRequestsTotal.Increment();
                       
                string partnerName = Utilities.GetSubjectName();
                if( null != partnerName )
                {
                    WebCacheMessagingCounter.Counters[ partnerName ].SetMessageFlagsRequestsPerSecond.Increment();
                    WebCacheMessagingCounter.Counters[ partnerName ].SetMessageFlagsRequestsTotal.Increment();
                }

                // Validate parameters
                if( null == User )
                {
                    throw new XboxWebExceptionNoEvent( "Messaging: User cannot be null!" );
                }

                // Look-up PUID from cache (throws if not found)
                PUIDAndOwner puidAndOwner = LookupWebID( UserWebID, UserGamerTag );

                MessageFlagsMsg request = new MessageFlagsMsg();
                MessageFlagsReply response = new MessageFlagsReply();

                // Build the request
                request.qwUserID = puidAndOwner.PUID;
                request.dwMessageID = MessageID;
                request.dwSetFlags = (uint) SetFlags;
                request.dwUnsetFlags = (uint) UnsetFlags;

                // For some reason PostXrlRequest won't accept a type that inherits from XRLObject2 for the response
                XRLObject2 xrlo = response;

                // Let the FD know who is calling
                Utilities.RequestInfo requestInfo = Utilities.GetRequestInfo();
                HTTPAuthData httpAuthData = new HTTPAuthData( requestInfo.ClientPort, requestInfo.ClientIP, requestInfo.qwRequestID, puidAndOwner.PUID, 0, (uint) XOService.MessagingService, 0 );

                // call webalive to ensure that presence knows about this user.
                hr = WebAliveUser(puidAndOwner.PUID, httpAuthData);
                if( HResult.Failed( hr ) )
                {
                    Xom.Trace(XomAreaName.wcMessagingTrace, LogLevel.L_ERROR, "SetMessageFlags: WebAliveUser failed, hr = " + hr );
                    return hr;
                }

                // Call the Messaging front door to hand the request
                hr = XRLUtil.PostXrlRequest( VirtualInterface.xpnfd_messaging_int, "/xpnfront/xmessaging.srf", httpAuthData.GetBase64EncodedString(), request, ref xrlo );
                if( HResult.Failed( hr ) )
                {
                    Xom.Trace(XomAreaName.wcMessagingTrace, LogLevel.L_ERROR, "SetMessageFlags: PostXrlRequest failed, hr = " + hr );
                    return hr;
                }

                hr = response.hr;
                if( HResult.Failed( hr ) )
                {
                    Xom.Trace(XomAreaName.wcMessagingTrace, LogLevel.L_ERROR, "SetMessageFlags: PostXrlRequest got back failed response, hr = " + hr );
                    return hr;
                }

                Xom.Trace(XomAreaName.wcMessagingTrace, LogLevel.L_NORMAL, "SetMessageFlags: Returning hr = " + hr );
                return hr;
            }
            catch (XboxWebException)
            {
                hr = HResult.E_FAIL;
                throw;
            }
            catch (Exception e)
            {
                hr = HResult.E_FAIL;
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_30, e);
            }
            finally
            {
                string szLog = "FLG|"
                    + Utilities.GetSubjectName()                          + "|"
                    + Utilities.GetRequestID()                            + "|"
                    + Utilities.GetClientIPPort()                         + "|"
                    + UserGamerTag                                        + "|"
                    + StringFromWebID( UserWebID )                        + "|"
                    + MessageID.ToString("X")                             + "|"
                    + SetFlags.ToString("X")                              + "|"
                    + UnsetFlags.ToString("X")                            + "|"
                    + hr;
            
                Xom.Log(XomAreaName.wcMessagingLog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );
            }
        }

        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/EnumTitleWideMessages", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public override System.UInt32 EnumTitleWideMessages(System.UInt32 TitleID, [System.Xml.Serialization.XmlElementAttribute("Summary")] out WCTitleWideMessageSummary[] Summary)
        {
            HResult hr = HResult.S_OK;
            ushort cMessages = 0;
            Summary = null;

            try
            {
                Utilities.Instance.CheckAPIAndTitle( "Messaging.EnumTitleWideMessages", TitleID, TitlePrivilege.ReadOnly );

                // Update perf counters
                WebCacheMessagingCounter.Counters.EnumTitleWideMessagesRequestsPerSecond.Increment();
                WebCacheMessagingCounter.Counters.EnumTitleWideMessagesRequestsTotal.Increment();
                       
                string partnerName = Utilities.GetSubjectName();
                if( null != partnerName )
                {
                    WebCacheMessagingCounter.Counters[ partnerName ].EnumTitleWideMessagesRequestsPerSecond.Increment();
                    WebCacheMessagingCounter.Counters[ partnerName ].EnumTitleWideMessagesRequestsTotal.Increment();
                }

                EnumerateSystemMessagesMsg request = new EnumerateSystemMessagesMsg();
                EnumerateSystemMessagesReply response = new EnumerateSystemMessagesReply();

                // Build the request
                request.dwTitleID = TitleID;

                // For some reason PostXrlRequest won't accept a type that inherits from XRLObject2 for the response
                XRLObject2 xrlo = response;

                // Let the FD know who is calling
                Utilities.RequestInfo requestInfo = Utilities.GetRequestInfo();
                HTTPAuthData httpAuthData = new HTTPAuthData( requestInfo.ClientPort, requestInfo.ClientIP, requestInfo.qwRequestID, 0, TitleID, (uint) XOService.MessagingService, 0 );

                // Call the Messaging front door to hand the request
                hr = XRLUtil.PostXrlRequest( VirtualInterface.xpnfd_messaging_int, "/xpnfront/xmessaging.srf", httpAuthData.GetBase64EncodedString(), request, ref xrlo );
                if( HResult.Failed( hr ) )
                {
                    Xom.Trace(XomAreaName.wcMessagingTrace, LogLevel.L_ERROR, "EnumTitleWideMessages: PostXrlRequest failed, hr = " + hr );
                    return hr;
                }

                hr = response.hr;
                if( HResult.Failed( hr ) )
                {
                    Xom.Trace(XomAreaName.wcMessagingTrace, LogLevel.L_ERROR, "EnumTitleWideMessages: PostXrlRequest got back failed response, hr = " + hr );
                    return hr;
                }

                // Loop through the returned messages and convert them from Messaging structures to the widget equivalents
                if( 0 != response.cMessages )
                {
                    cMessages = response.cMessages;

                    Summary = new WCTitleWideMessageSummary[ response.cMessages ];

                    for( uint iMsg = 0; iMsg < response.cMessages; iMsg++ )
                    {
                        Summary[ iMsg ] = new WCTitleWideMessageSummary();

                        Summary[ iMsg ].TitleID          = response.rgMessages[ iMsg ].dwTitleID;
                        Summary[ iMsg ].SenderContext    = response.rgMessages[ iMsg ].qwSenderContext;
                        Summary[ iMsg ].SentTime         = response.rgMessages[ iMsg ].dtSentTime;
                        Summary[ iMsg ].Region           = response.rgMessages[ iMsg ].dwRegion;
                        Summary[ iMsg ].MessageID        = response.rgMessages[ iMsg ].dwMessageID;
                        Summary[ iMsg ].MessageFlags     = (WCMessageFlags) response.rgMessages[ iMsg ].dwMessageFlags;
                        Summary[ iMsg ].ExpireMinutes    = response.rgMessages[ iMsg ].wExpireMinutes;
                        Summary[ iMsg ].DetailsSize      = response.rgMessages[ iMsg ].cbDetails;
                        Summary[ iMsg ].MessageType      = (WCMessageType) response.rgMessages[ iMsg ].bMessageType;
                        Summary[ iMsg ].SenderName       = response.rgMessages[ iMsg ].szSenderName;
                        Summary[ iMsg ].Description      = response.rgMessages[ iMsg ].szDescription;
                    }
                }
                
                Xom.Trace(XomAreaName.wcMessagingTrace, LogLevel.L_NORMAL, "EnumTitleWideMessages: Returning " + response.cMessages.ToString() + " messages, hr = " + hr );
                return hr;
            }
            catch (XboxWebException)
            {
                hr = HResult.E_FAIL;
                throw;
            }
            catch (Exception e)
            {
                hr = HResult.E_FAIL;
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_31, e);
            }
            finally
            {
                string szLog = "ENS|"
                    + Utilities.GetSubjectName()       + "|"
                    + Utilities.GetRequestID()         + "|"
                    + Utilities.GetClientIPPort()      + "|"
                    + TitleID.ToString("X")            + "|"
                    + cMessages.ToString("X")          + "|"
                    + hr;
            
                Xom.Log(XomAreaName.wcMessagingLog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );
            }
        }

        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/GetTitleWideMessageDetails", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public override System.UInt32 GetTitleWideMessageDetails(System.UInt32 TitleID, System.UInt32 MessageID, out WCTitleWideMessageSummary Summary, out WCMessageDetails Details)
        {
            HResult hr = HResult.S_OK;
            byte bMessageType = 0;
            Summary = null;
            Details = null;

            try
            {
                Utilities.Instance.CheckAPIAndTitle( "Messaging.GetTitleWideMessageDetails", TitleID, TitlePrivilege.ReadOnly );

                // Update perf counters
                WebCacheMessagingCounter.Counters.GetTitleWideMessageDetailsRequestsPerSecond.Increment();
                WebCacheMessagingCounter.Counters.GetTitleWideMessageDetailsRequestsTotal.Increment();
                       
                string partnerName = Utilities.GetSubjectName();
                if( null != partnerName )
                {
                    WebCacheMessagingCounter.Counters[ partnerName ].GetTitleWideMessageDetailsRequestsPerSecond.Increment();
                    WebCacheMessagingCounter.Counters[ partnerName ].GetTitleWideMessageDetailsRequestsTotal.Increment();
                }

                SystemMessageDetailsMsg request = new SystemMessageDetailsMsg();
                SystemMessageDetailsReply response = new SystemMessageDetailsReply();

                // Build the request
                request.dwTitleID = TitleID;
                request.dwMessageID = MessageID;

                // For some reason PostXrlRequest won't accept a type that inherits from XRLObject2 for the response
                XRLObject2 xrlo = response;

                // Let the FD know who is calling
                Utilities.RequestInfo requestInfo = Utilities.GetRequestInfo();
                HTTPAuthData httpAuthData = new HTTPAuthData( requestInfo.ClientPort, requestInfo.ClientIP, requestInfo.qwRequestID, 0, TitleID, (uint) XOService.MessagingService, 0 );

                // Call the Messaging front door to hand the request
                hr = XRLUtil.PostXrlRequest( VirtualInterface.xpnfd_messaging_int, "/xpnfront/xmessaging.srf", httpAuthData.GetBase64EncodedString(), request, ref xrlo );
                if( HResult.Failed( hr ) )
                {
                    Xom.Trace(XomAreaName.wcMessagingTrace, LogLevel.L_ERROR, "GetTitleWideMessageDetails: PostXrlRequest failed, hr = " + hr );
                    return hr;
                }

                hr = response.hr;
                if( HResult.Failed( hr ) )
                {
                    Xom.Trace(XomAreaName.wcMessagingTrace, LogLevel.L_ERROR, "GetTitleWideMessageDetails: PostXrlRequest got back failed response, hr = " + hr );
                    return hr;
                }

                bMessageType = response.summary.bMessageType;

                // Fill out the message summary ///////////////////////////////////

                Summary = new WCTitleWideMessageSummary();

                Summary.TitleID          = response.summary.dwTitleID;
                Summary.SenderContext    = response.summary.qwSenderContext;
                Summary.SentTime         = response.summary.dtSentTime;
                Summary.Region           = response.summary.dwRegion;
                Summary.MessageID        = response.summary.dwMessageID;
                Summary.MessageFlags     = (WCMessageFlags) response.summary.dwMessageFlags;
                Summary.ExpireMinutes    = response.summary.wExpireMinutes;
                Summary.DetailsSize      = response.summary.cbDetails;
                Summary.MessageType      = (WCMessageType) response.summary.bMessageType;
                Summary.SenderName       = response.summary.szSenderName;
                Summary.Description      = response.summary.szDescription;

                // Fill out the message details ///////////////////////////////////

                if( 0 != response.summary.cbDetails )
                {
                    PopulateDetails( out Details, ref response.details );
                }

                // All done ///////////////////////////////////////////////////////

                Xom.Trace(XomAreaName.wcMessagingTrace, LogLevel.L_NORMAL, "GetTitleWideMessageDetails: Returning hr = " + hr );
                return hr;
            }
            catch (XboxWebException)
            {
                hr = HResult.E_FAIL;
                throw;
            }
            catch (Exception e)
            {
                hr = HResult.E_FAIL;
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_32, e);
            }
            finally
            {
                string szLog = "DTS|"
                    + Utilities.GetSubjectName()       + "|"
                    + Utilities.GetRequestID()         + "|"
                    + Utilities.GetClientIPPort()      + "|"
                    + TitleID.ToString("X")            + "|"
                    + MessageID.ToString("X")          + "|"
                    + bMessageType.ToString("X")       + "|"
                    + hr;
            
                Xom.Log(XomAreaName.wcMessagingLog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );
            }
        }

        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/DeleteTitleWideMessage", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public override System.UInt32 DeleteTitleWideMessage(System.UInt32 TitleID, System.UInt32 MessageID, WCDeleteSysMsgFlags Flags)
        {
            HResult hr = HResult.S_OK;

            try
            {
                Utilities.Instance.CheckAPIAndTitle( "Messaging.DeleteTitleWideMessage", TitleID, TitlePrivilege.ReadWrite );

                // Update perf counters
                WebCacheMessagingCounter.Counters.DeleteTitleWideMessageRequestsPerSecond.Increment();
                WebCacheMessagingCounter.Counters.DeleteTitleWideMessageRequestsTotal.Increment();
                       
                string partnerName = Utilities.GetSubjectName();
                if( null != partnerName )
                {
                    WebCacheMessagingCounter.Counters[ partnerName ].DeleteTitleWideMessageRequestsPerSecond.Increment();
                    WebCacheMessagingCounter.Counters[ partnerName ].DeleteTitleWideMessageRequestsTotal.Increment();
                }

                DeleteSystemMessageMsg request = new DeleteSystemMessageMsg();
                DeleteSystemMessageReply response = new DeleteSystemMessageReply();

                // Build the request
                request.dwTitleID = TitleID;
                request.dwMessageID = MessageID;
                request.dwFlags = (uint) Flags;

                // For some reason PostXrlRequest won't accept a type that inherits from XRLObject2 for the response
                XRLObject2 xrlo = response;

                // Let the FD know who is calling
                Utilities.RequestInfo requestInfo = Utilities.GetRequestInfo();
                HTTPAuthData httpAuthData = new HTTPAuthData( requestInfo.ClientPort, requestInfo.ClientIP, requestInfo.qwRequestID, 0, TitleID, (uint) XOService.MessagingService, 0 );

                // Call the Messaging front door to hand the request
                hr = XRLUtil.PostXrlRequest( VirtualInterface.xpnfd_messaging_int, "/xpnfront/xmessaging.srf", httpAuthData.GetBase64EncodedString(), request, ref xrlo );
                if( HResult.Failed( hr ) )
                {
                    Xom.Trace(XomAreaName.wcMessagingTrace, LogLevel.L_ERROR, "DeleteTitleWideMessage: PostXrlRequest failed, hr = " + hr );
                    return hr;
                }

                hr = response.hr;
                if( HResult.Failed( hr ) )
                {
                    Xom.Trace(XomAreaName.wcMessagingTrace, LogLevel.L_ERROR, "DeleteTitleWideMessage: PostXrlRequest got back failed response, hr = " + hr );
                    return hr;
                }

                Xom.Trace(XomAreaName.wcMessagingTrace, LogLevel.L_NORMAL, "DeleteTitleWideMessage: Returning hr = " + hr );
                return hr;
            }
            catch (XboxWebException)
            {
                hr = HResult.E_FAIL;
                throw;
            }
            catch (Exception e)
            {
                hr = HResult.E_FAIL;
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_33, e);
            }
            finally
            {
                string szLog = "DES|"
                    + Utilities.GetSubjectName()       + "|"
                    + Utilities.GetRequestID()         + "|"
                    + Utilities.GetClientIPPort()      + "|"
                    + TitleID.ToString("X")            + "|"
                    + MessageID.ToString("X")          + "|"
                    + Flags.ToString("X")              + "|"
                    + hr;
            
                Xom.Log(XomAreaName.wcMessagingLog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );
            }
        }

        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/SendTitleWideMessage", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public override System.UInt32 SendTitleWideMessage(string Sender, System.UInt64 SenderContext, System.DateTime SentTime, System.UInt32 Region, WCMessageFlags MessageFlags, System.UInt32 SenderTitleID, System.UInt16 ExpireMinutes, WCMessageType MessageType, string Description, WCMessageDetails Details, [System.Xml.Serialization.XmlElementAttribute("LocalizedString")] WCLocalizedString[] LocalizedString, [System.Xml.Serialization.XmlElementAttribute("Attachment")] WCMessageAttachment[] Attachment, out System.UInt16 Delay, out System.UInt32 MessageID)
        {
            HResult hr = HResult.S_OK;
            MessageID = 0;
            Delay = 0;

            try
            {
                Utilities.Instance.CheckAPIAndTitle( "Messaging.SendTitleWideMessage", SenderTitleID, TitlePrivilege.ReadWrite );

                // Update perf counters
                WebCacheMessagingCounter.Counters.SendTitleWideMessageRequestsPerSecond.Increment();
                WebCacheMessagingCounter.Counters.SendTitleWideMessageRequestsTotal.Increment();
                       
                string partnerName = Utilities.GetSubjectName();
                if( null != partnerName )
                {
                    WebCacheMessagingCounter.Counters[ partnerName ].SendTitleWideMessageRequestsPerSecond.Increment();
                    WebCacheMessagingCounter.Counters[ partnerName ].SendTitleWideMessageRequestsTotal.Increment();
                }

                // Validate the message type
                switch( MessageType )
                {
                case WCMessageType.FriendRequest:
                case WCMessageType.GameInvite:
                case WCMessageType.TeamRecruit:
                case WCMessageType.LiveMessage:
                default:
                    // These types must be sent from feature specific widgets
                    Xom.Trace(XomAreaName.wcMessagingTrace, LogLevel.L_ERROR, "SendMessage: Attempt to send disallowed message type: " + MessageType.ToString() );
                    return 0x80070005; // E_ACCESSDENIED

                case WCMessageType.TitleCustom:
                case WCMessageType.CompReminder:
                case WCMessageType.CompRequest:
                    // These types can be sent from here
                    break;
                }

                // If the sent time is within the next 10 minutes, set it to 10 minutes from now so that we know any strings get
                // loaded before the message is available to users.
                if( null != LocalizedString &&
                    0 != LocalizedString.Length &&
                    DateTime.UtcNow.AddMinutes( 10 ) > SentTime )
                {
                    SentTime = DateTime.UtcNow.AddMinutes( 10 );
                    Delay = 10;
                }

                CSystemMessage message = new CSystemMessage( 
                    SenderTitleID, 
                    SenderContext, 
                    Region, 
                    (uint) MessageFlags, 
                    ExpireMinutes, 
                    (byte) MessageType, 
                    Sender, 
                    SentTime,
                    Description );

                // Calculate the message expiration so that it can be used for any dependent objects like strings or attachments
                DateTime MsgExpireTime = SentTime.AddMinutes( ExpireMinutes );

                // First store any attachments with the Storage Service and add on any passed-in message details
                CMessage basemsg = message;
                hr = SendCommon( SenderTitleID, 0, MsgExpireTime, ref basemsg, ref Details, ref Attachment );
                if( HResult.Failed( hr ) )
                {
                    Xom.Trace(XomAreaName.wcMessagingTrace, LogLevel.L_ERROR, "SendTitleWideMessage: SendCommon failed, hr = " + hr );
                    return hr;
                }

                // Setup auth data so the FD knows who is calling
                Utilities.RequestInfo requestInfo = Utilities.GetRequestInfo();
                HTTPAuthData httpAuthData = new HTTPAuthData( requestInfo.ClientPort, requestInfo.ClientIP, requestInfo.qwRequestID, 0, SenderTitleID, (uint) XOService.StringService, 0 );

                // Next store any strings with the String Service
                if( null != LocalizedString )
                {
                    StringAdd2Request strrequest = new StringAdd2Request();
                    StringAddResponse strresponse = new StringAddResponse();

                    // Set request properties common to each call
                    strrequest.dwTitleID = SenderTitleID;
                    strrequest.dwStringID = 0xFFFFFFFF; // Let the String Service pick an ID
                    strrequest.fVetText = false; // We don't vet strings from publishers, only users
                    strrequest.dtExpire = MsgExpireTime.AddHours( 5 );

                    for( uint iString = 0; iString < LocalizedString.Length; iString++ )
                    {
                        if( null == LocalizedString[ iString ].LangString )
                        {
                            continue;
                        }

                        // Update perf counters
                        WebCacheMessagingCounter.Counters.AddStringRequestsPerSecond.Increment();
                        WebCacheMessagingCounter.Counters.AddStringRequestsTotal.Increment();

                        if( null != partnerName )
                        {
                            WebCacheMessagingCounter.Counters[ partnerName ].AddStringRequestsPerSecond.Increment();
                            WebCacheMessagingCounter.Counters[ partnerName ].AddStringRequestsTotal.Increment();
                        }

                        // Set request properties unique to each call
                        strrequest.szDefaultLocale = LocalizedString[ iString ].DefaultLocale;
                        strrequest.cLocaleStrings = (byte) LocalizedString[ iString ].LangString.Length;

                        // Copy over the per-language strings
                        strrequest.rgLocaleStrings = new LocaleString[ LocalizedString[ iString ].LangString.Length ];

                        for( uint iLangString = 0; iLangString < LocalizedString[ iString ].LangString.Length; iLangString++ )
                        {
                            strrequest.rgLocaleStrings[ iLangString ] = new LocaleString();
 
                            strrequest.rgLocaleStrings[ iLangString ].szLocale = LocalizedString[ iString ].LangString[ iLangString ].Locale;
                            strrequest.rgLocaleStrings[ iLangString ].szString = LocalizedString[ iString ].LangString[ iLangString ].String;

                            // UTF8 encoding, no byte order mark, throw on bad encoding
                            UTF8Encoding utf8 = new UTF8Encoding( false, true );

                            strrequest.rgLocaleStrings[ iLangString ].wStringSize = (ushort) utf8.GetByteCount( LocalizedString[ iString ].LangString[ iLangString ].String ); 
                        }

                        // For some reason PostXrlRequest won't accept a type that inherits from XRLObject2 for the response
                        XRLObject2 xrlo = strresponse;

                        // Call the String front door to handle the request
                        hr = XRLUtil.PostXrlRequest( XOService.StringService, strrequest.GetXRL(), httpAuthData.GetBase64EncodedString(), strrequest, ref xrlo );
                        if( HResult.Failed( hr ) )
                        {
                            return hr;
                        }

                        // Log this request
                        string szLog = "STR|"
                            + Utilities.GetSubjectName()       + "|"
                            + Utilities.GetRequestID()         + "|"
                            + Utilities.GetClientIPPort()      + "|"
                            + SenderTitleID.ToString("X");

                        Xom.Log(XomAreaName.wcMessagingLog, szLog );
                        Xom.Log(XomAreaName.Reporting_v2, szLog );

                        // Add the stringID to the message
                        ushort wPropTag = MsgDefs.XONLINE_MSG_PROP_TAG( MsgDefs.XONLINE_MSG_PROP_TYPE_STRING_ID, LocalizedString[ iString ].PropID );
                        message.AddProperty( wPropTag, strresponse.dwStringID );
                    }
                }

                message.SetAuthData( httpAuthData.GetBase64EncodedString() );

                // Finally, send the message to the Messaging Service
                hr = message.Send();
                if( HResult.Failed( hr ) )
                {
                    Xom.Trace(XomAreaName.wcMessagingTrace, LogLevel.L_ERROR, "SendTitleWideMessage: CSystemMessage::Send failed, hr = " + hr );
                    return hr;
                }

                // NOTE: If Send() succeeds, hr is the value from the response, so it will contain any success code at this point

                // Return the message ID in the response
                SendSystemMessageReply response = message.GetResponse();

                // Set the output parameter
                MessageID = response.dwMessageID;

                Xom.Trace(XomAreaName.wcMessagingTrace, LogLevel.L_NORMAL, "SendTitleWideMessage: Returning Message=" + response.dwMessageID.ToString("X") + " hr = " + hr );
                return hr;
            }
            catch (XboxWebException)
            {
                hr = HResult.E_FAIL;
                throw;
            }
            catch (Exception e)
            {
                hr = HResult.E_FAIL;
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_34, e);
            }
            finally
            {
                string szLog = "STW|"
                    + Utilities.GetSubjectName()       + "|"
                    + Utilities.GetRequestID()         + "|"
                    + Utilities.GetClientIPPort()      + "|"
                    + Sender                           + "|"
                    + SenderContext.ToString("X")      + "|"
                    + SenderTitleID.ToString("X")      + "|"
                    + Region.ToString("X")             + "|"
                    + SentTime.ToString()              + "|"
                    + MessageFlags.ToString("X")       + "|"
                    + ExpireMinutes.ToString("X")      + "|"
                    + MessageType.ToString("X")        + "|"
                    + MessageID.ToString("X")          + "|"
                    + hr;
            
                Xom.Log(XomAreaName.wcMessagingLog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );
            }
        }

        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/SendTitleUserMessage", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public override System.UInt32 SendTitleUserMessage(string Sender, System.UInt64 SenderContext, WCMessageFlags MessageFlags, System.UInt32 SenderTitleID, System.UInt16 ExpireMinutes, WCMessageType MessageType, [System.Xml.Serialization.XmlElementAttribute("Recipient")] string[] Recipient, WCMessageDetails Details, [System.Xml.Serialization.XmlElementAttribute("Attachment")] WCMessageAttachment[] Attachment, [System.Xml.Serialization.XmlElementAttribute("RecipResult")] out WCRecipientResult[] RecipResult)
        {
            HResult hr = HResult.S_OK;
            RecipResult = null;

            try
            {
                Utilities.Instance.CheckAPIAndTitle( "Messaging.SendTitleUserMessage", SenderTitleID, TitlePrivilege.ReadWrite );

                // Update perf counters
                WebCacheMessagingCounter.Counters.SendTitleUserMessageRequestsPerSecond.Increment();
                WebCacheMessagingCounter.Counters.SendTitleUserMessageRequestsTotal.Increment();
                       
                string partnerName = Utilities.GetSubjectName();
                if( null != partnerName )
                {
                    WebCacheMessagingCounter.Counters[ partnerName ].SendTitleUserMessageRequestsPerSecond.Increment();
                    WebCacheMessagingCounter.Counters[ partnerName ].SendTitleUserMessageRequestsTotal.Increment();
                }

                CUserMessage message = new CUserMessage( 
                    0, 
                    SenderContext, 
                    (uint) MessageFlags, 
                    SenderTitleID, 
                    ExpireMinutes, 
                    (byte) MessageType, 
                    Sender );

                // Do the send
                hr = SendToUserCommon( ref message, ref Recipient, ref Details, ref Attachment, out RecipResult );

                return hr;
            }
            catch (XboxWebException)
            {
                hr = HResult.E_FAIL;
                throw;
            }
            catch (Exception e)
            {
                hr = HResult.E_FAIL;
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_35, e);
            }
            finally
            {
                string szLog = "STU|"
                    + Utilities.GetSubjectName()       + "|"
                    + Utilities.GetRequestID()         + "|"
                    + Utilities.GetClientIPPort()      + "|"
                    + Sender                           + "|"
                    + SenderContext.ToString("X")      + "|"
                    + SenderTitleID.ToString("X")      + "|"
                    + MessageFlags.ToString("X")       + "|"
                    + ExpireMinutes.ToString("X")      + "|"
                    + MessageType.ToString("X")        + "|"
                    + hr;
            
                Xom.Log(XomAreaName.wcMessagingLog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );
            }
        }
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/RevokeTitleUserMessage", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public override System.UInt32 RevokeTitleUserMessage([System.Xml.Serialization.XmlElementAttribute("RecipResult")] WCRecipientResult[] RecipResult)
        {
            HResult hr = HResult.S_OK;

            try
            {
                Utilities.Instance.CheckAPI( "Messaging.RevokeTitleUserMessage" );

                // Update perf counters
                WebCacheMessagingCounter.Counters.RevokeTitleUserMessageRequestsPerSecond.Increment();
                WebCacheMessagingCounter.Counters.RevokeTitleUserMessageRequestsTotal.Increment();
                       
                string partnerName = Utilities.GetSubjectName();
                if( null != partnerName )
                {
                    WebCacheMessagingCounter.Counters[ partnerName ].RevokeTitleUserMessageRequestsPerSecond.Increment();
                    WebCacheMessagingCounter.Counters[ partnerName ].RevokeTitleUserMessageRequestsTotal.Increment();
                }

                // Do the revoke
                hr = RevokeMessageCommon( 0, ref RecipResult );

                return hr;
            }
            catch (XboxWebException)
            {
                hr = HResult.E_FAIL;
                throw;
            }
            catch (Exception e)
            {
                hr = HResult.E_FAIL;
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_36, e);
            }
            finally
            {
                string szLog = "RTU|"
                    + Utilities.GetSubjectName()       + "|"
                    + Utilities.GetRequestID()         + "|"
                    + Utilities.GetClientIPPort()      + "|"
                    + ( null == RecipResult ? "0" : RecipResult.Length.ToString("X") ) + "|"
                    + hr;
            
                Xom.Log(XomAreaName.wcMessagingLog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );
            }
        }

        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/GetMessageString", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("StringData")]
        public override string GetMessageString(System.UInt32 TitleID, System.UInt32 StringID, string Locale)
        {
            HResult hr = HResult.S_OK;

            try
            {
                Utilities.Instance.CheckAPI( "Messaging.GetMessageString" );

                // Update perf counters
                WebCacheMessagingCounter.Counters.GetMessageStringRequestsPerSecond.Increment();
                WebCacheMessagingCounter.Counters.GetMessageStringRequestsTotal.Increment();

                string partnerName = Utilities.GetSubjectName();
                if( null != partnerName )
                {
                    WebCacheMessagingCounter.Counters[ partnerName ].GetMessageStringRequestsPerSecond.Increment();
                    WebCacheMessagingCounter.Counters[ partnerName ].GetMessageStringRequestsTotal.Increment();
                }

                StringLookup2Request strrequest = new StringLookup2Request();
                StringLookupResponse strresponse = new StringLookupResponse();

                // Build the request
                strrequest.dwTitleID = TitleID;
                strrequest.szLocale = Locale; 
                strrequest.wNumStrings = 1;
                strrequest.rgdwStringIDs = new uint[ 1 ];
                strrequest.rgdwStringIDs[ 0 ] = StringID;

                // For some reason PostXrlRequest won't accept a type that inherits from XRLObject2 for the response
                XRLObject2 xrlo = strresponse;

                // Setup auth data so the FD knows who is calling
                Utilities.RequestInfo requestInfo = Utilities.GetRequestInfo();
                HTTPAuthData httpAuthData = new HTTPAuthData( requestInfo.ClientPort, requestInfo.ClientIP, requestInfo.qwRequestID, 0, TitleID, (uint) XOService.StringService, 0 );

                // Call the String front door to handle the request
                hr = XRLUtil.PostXrlRequest( XOService.StringService, strrequest.GetXRL(), httpAuthData.GetBase64EncodedString(), strrequest, ref xrlo );
                if( HResult.Failed( hr ) )
                {
                    Xom.Trace(XomAreaName.wcMessagingTrace, LogLevel.L_ERROR, "GetMessageString: PostXrlRequest failed, hr = " + hr );
                    return "";
                }

                Xom.Trace(XomAreaName.wcMessagingTrace, LogLevel.L_NORMAL, "GetMessageString: success." );
                return strresponse.rgStringData[ 0 ].szString;
            }
            catch (XboxWebException)
            {
                hr = HResult.E_FAIL;
                throw;
            }
            catch (Exception e)
            {
                hr = HResult.E_FAIL;
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_37, e);
            }
            finally
            {
                string szLog = "GST|"
                    + Utilities.GetSubjectName()       + "|"
                    + Utilities.GetRequestID()         + "|"
                    + Utilities.GetClientIPPort()      + "|"
                    + TitleID.ToString("X")            + "|"
                    + StringID.ToString("X")           + "|"
                    + Locale                           + "|"
                    + hr;
            
                Xom.Log(XomAreaName.wcMessagingLog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );
            }
        }

        private static SHA1 _sha1 = new SHA1CryptoServiceProvider();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Messaging\Test\FuncEnumMessages.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using System.IO;
using System.Xml;
using System.Web.Services.Protocols;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.Messaging;
using ServerTestFramework.Web.UserAccount;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;
using xonline.common.config;

namespace MessagingWidget
{
	[TestGroup]
	public class FuncEnumMessages : TestNode
	{
		[TestCase, Description("ValidEnumMessages")]
		class ValidEnumMessages : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
				WCMessageSummary[] summary = null;

				//WCWebUser user = new WCWebUser();
				//user.GamerTag = MWGlobal.Users[1].GamerTag;
				//user.WebID = MWGlobal.Users[1].WebId;

				Global.RO.Info("EnumMessages User: " +MWGlobal.Users[1].GamerTag);

				UInt32 hr = service.EnumMessages( 
						MWGlobal.Users[1].WebId,       // User
						MWGlobal.Users[1].GamerTag,
						out summary );

				Global.RO.Info( "EnumMessages returned {0}", hr );

				if( HResult.Succeeded( hr ) )
				{
					if ( summary.Length == 0 )   // we should have SEVERAL messages  (test for exact count?)
					{
						Global.RO.Info( "Got no messages!" );
						return;
					}

					// spew
					for( int iMessage = 0; iMessage < summary.Length; iMessage++ )
					{
						Global.RO.Info( "    Message {0}", iMessage );
						Global.RO.Info( "        szSenderName - {0}", summary[ iMessage ].Sender );
						Global.RO.Info( "        qwSenderContext - {0}", summary[ iMessage ].SenderContext );
						Global.RO.Info( "        mtSentTime - {0}", summary[ iMessage ].SentTime );
						Global.RO.Info( "        dwMessageID - {0}", summary[ iMessage ].MessageID );
						Global.RO.Info( "        dwMessageFlags - {0}", summary[ iMessage ].MessageFlags );
						Global.RO.Info( "        dwSenderTitleID - {0}", summary[ iMessage ].SenderTitleID );
						Global.RO.Info( "        bMessageType - {0}", summary[ iMessage ].MessageType );
						Global.RO.Info( "        wExpireMinutes - {0}", summary[ iMessage ].ExpireMinutes );
						Global.RO.Info( "        cbDetails - {0}", summary[ iMessage ].DetailsSize );
					}
				}
				else
				{
					//failed, TODO: log some useful stuff here
                    Global.RO.Info("EnumMessages call failed");

					return;
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		//Temporary utility function
		[TestCase, Description("CreateUser utility function")]
		class CreateUser: TestBase
		{
			protected override void Execute()
			{
                UacsCommon ua = new UacsCommon();

				//Owner o = new Owner("RMB_user1000012");
				Owner o = ua.GenerateOwner();
				ulong puid = ua.CreateUser(o);

				WCUserAccount wua = new WCUserAccount(Global.XEnv.GetVirtualInterface(VirtualInterface.wcusers));
				byte []webPuid = ua.GenerateWebId(puid);
				
				bool f = wua.LinkUser(webPuid, true, o);
				if (!f)
				{
					Global.RO.Info("Could not link gamertag???");
				}

				ConsoleX.WriteLine("Created user: " + o.gamertag + " PUID: " + puid);

				ResultCode = TEST_RESULTS.PASSED;
			}
		}


		//TODO: requires pre-populated data in xprof tables
		[TestCase, Description("EnumMAXMessages")]
		class EnumMAXMessages : TestBase
		{
			protected override void Execute()
			{
				//Messaging service = new Messaging();
				WCMessaging service = new WCMessaging();
				WCMessageSummary[] summary = null;

				//WCWebUser user = new WCWebUser();
				//user.GamerTag = MWGlobal.Users[3].GamerTag;
				//user.WebID = MWGlobal.Users[3].WebId;
				
				UInt32 hr = service.EnumMessages( 
					MWGlobal.Users[3].WebId,       // User
					MWGlobal.Users[3].GamerTag,
					out summary );

				Global.RO.Info( "EnumMessages returned {0}", hr );
				
				if( HResult.Succeeded( hr ) )
				{
					if ( summary.Length != 100 ) //MAXMESSAGES)
					{
						return;  // TEST CASE FAIL
					}
				}
				else
					return;

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("EnumZeroMessages")]
		class EnumZeroMessages : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
				WCMessageSummary[] summary = null;

				//WCWebUser user = new WCWebUser();
				//user.GamerTag = MWGlobal.Users[0].GamerTag;			// User 0 should have 0 messages
				//user.WebID = MWGlobal.Users[0].WebId;

				Global.RO.Info("EnumMessages User: " + MWGlobal.Users[0].GamerTag);

				UInt32 hr = service.EnumMessages( 
					MWGlobal.Users[0].WebId,			// User 0 should have 0 messages
					MWGlobal.Users[0].GamerTag,
					out summary );

				Global.RO.Info( "EnumMessages returned {0}", hr );

				if( HResult.Succeeded( hr ) )
				{
					if ( summary.Length != 0 )
					{
						Global.RO.Info( "Unexpected messages: " + summary.Length );
						return;
					}
				}
				else
				{
					Global.RO.Info("Failed enum, hr: " + hr.ToString("X") );

					return;
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("NegMismatchedUser")]
		class NegMismatchedUser : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
				WCMessageSummary[] summary = null;

				//WCWebUser user = new WCWebUser();
				//user.GamerTag = MWGlobal.Users[0].GamerTag;		// user 0, webid 1
				//user.WebID = MWGlobal.Users[1].WebId;

				try 
				{
					UInt32 hr = service.EnumMessages( 
						MWGlobal.Users[0].WebId,       // User
						MWGlobal.Users[1].GamerTag,
						out summary );

					Global.RO.Info( "EnumMessages returned {0}", hr );

					if( HResult.Succeeded( hr ) )
					{
						Global.RO.Info("Unexpected success");
						return;
					}
				}
				catch (SoapException e)
				{
					if (! e.Message.EndsWith("not linked in our system") )
					{
						Global.RO.Info(e.Message);
						return;
					}
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("NegEnumNullUser")]
			class NegEnumNullID : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
				WCMessageSummary[] summary = null;

				//WCWebUser user = new WCWebUser();
				//user.GamerTag = null;
				//user.WebID = MWGlobal.Users[1].WebId;

				try 
				{
					UInt32 hr = service.EnumMessages( 
						MWGlobal.Users[1].WebId,       // User
						null,
						out summary );

					Global.RO.Info( "EnumMessages returned {0}", hr );

					if( HResult.Succeeded( hr ) )
					{
						Global.RO.Info("Unexpected success");
						return;
					}
				}
				catch (SoapException e)
				{
					// normal (for now)
					// TODO: Check code when this is fixed by Mason
					Global.RO.Info(e.Message);

				}

				// Null WebID
				try 
				{
					UInt32 hr = service.EnumMessages( 
						null,       // User
						MWGlobal.Users[1].GamerTag,
						out summary );

					Global.RO.Info( "EnumMessages returned {0}", hr );

					if( HResult.Succeeded( hr ) )
					{
						Global.RO.Info("Unexpected success");
						return;
					}
				}
				catch (SoapException e)
				{
					// normal (for now)
					// TODO: Check code when this is fixed by Mason
					Global.RO.Info(e.Message);
				}


				// now try empty string
				try 
				{

					UInt32 hr = service.EnumMessages( 
						MWGlobal.Users[1].WebId,       // User
						"",
						out summary );

					Global.RO.Info( "EnumMessages returned {0}", hr );

					if( HResult.Succeeded( hr ) )
					{
						Global.RO.Info("Unexpected success");
						return;
					}
				}
				catch (SoapException e)
				{
					// normal (for now)
					// TODO: Check code when this is fixed by Mason
					Global.RO.Info(e.Message);
				}


				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("NegUnknownUser")]
		class NegUnknownUser : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
				WCMessageSummary[] summary = null;

				//WCWebUser user = new WCWebUser();
				//user.GamerTag = RandomEx.GlobalRandGen.GenerateRandomString(15);
				//user.WebID = MWGlobal.Users[1].WebId;

				try 
				{
					UInt32 hr = service.EnumMessages( 
						MWGlobal.Users[1].WebId,
						RandomEx.GlobalRandGen.GenerateRandomString(15),       // User
						out summary );

					Global.RO.Info( "EnumMessages returned {0}", hr );

					if( HResult.Succeeded( hr ) )
					{
						Global.RO.Info("Unexpected success");
						return;
					}
				}
				catch (SoapException e)
				{
					if (! e.Message.EndsWith("not linked in our system") )
					{
						Global.RO.Info(e.Message);
						return;
					}
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}
	
		[TestCase, Description("NegBadID")]
		class NegBadID : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
				WCMessageSummary[] summary = null;

				//WCWebUser user = new WCWebUser();
				//user.GamerTag = "1234567890xxxxxx";		// ID is 16 chars long
				//user.WebID = MWGlobal.Users[1].WebId;

				try 
				{
					UInt32 hr = service.EnumMessages( 
						MWGlobal.Users[1].WebId,
						"1234567890xxxxxx",       // User
						out summary );

					Global.RO.Info( "EnumMessages returned {0}", hr );

					if( HResult.Succeeded( hr ) )
					{
						Global.RO.Info("Unexpected success");
						return;
					}
				}
				catch (SoapException e)
				{
					if (! e.Message.EndsWith("not linked in our system") )
					{
						Global.RO.Info(e.Message);
						return;
					}
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Messaging\Dll\wsdl.cs ===
//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.1.4322.573
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=1.1.4322.573.
// 
namespace xonline.server.webcache.messaging.dll  {    using System.Diagnostics;
    using System.Xml.Serialization;
    using System;
    using System.Web.Services.Protocols;
    using System.ComponentModel;
    using System.Web.Services;
    
    
    /// <remarks/>
    [System.Web.Services.WebServiceBindingAttribute(Name="MessagingSoap", Namespace="http://websvc.xboxlive.com/Messaging/")]
    public abstract class Messaging : System.Web.Services.WebService {
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/EnumMessages", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public abstract System.UInt32 EnumMessages([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] UserWebID, string UserGamerTag, [System.Xml.Serialization.XmlElementAttribute("Summary")] out WCMessageSummary[] Summary);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/GetMessageDetails", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public abstract System.UInt32 GetMessageDetails([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] UserWebID, string UserGamerTag, System.UInt32 MessageID, WCMessageFlags SetFlags, WCMessageFlags UnsetFlags, out WCMessageSummary Summary, out WCMessageDetails Details);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/DeleteMessage", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public abstract System.UInt32 DeleteMessage([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] UserWebID, string UserGamerTag, System.UInt32 MessageID, WCDeleteMsgFlags Flags);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/SendMessage", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public abstract System.UInt32 SendMessage([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] SenderWebID, string SenderGamerTag, System.UInt64 SenderContext, WCMessageFlags MessageFlags, System.UInt32 SenderTitleID, System.UInt16 ExpireMinutes, WCMessageType MessageType, [System.Xml.Serialization.XmlElementAttribute("Recipient")] string[] Recipient, WCMessageDetails Details, [System.Xml.Serialization.XmlElementAttribute("Attachment")] WCMessageAttachment[] Attachment, [System.Xml.Serialization.XmlElementAttribute("RecipResult")] out WCRecipientResult[] RecipResult);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/RevokeMessage", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public abstract System.UInt32 RevokeMessage([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] SenderWebID, string SenderGamerTag, [System.Xml.Serialization.XmlElementAttribute("RecipResult")] WCRecipientResult[] RecipResult);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/DeleteUserTitle", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public abstract System.UInt32 DeleteUserTitle([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] UserWebID, string UserGamerTag, System.UInt32 TitleID);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/EnumUserTitles", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public abstract System.UInt32 EnumUserTitles([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] UserWebID, string UserGamerTag, [System.Xml.Serialization.XmlElementAttribute("Title")] out WCUserTitle[] Title);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/SetMessageFlags", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public abstract System.UInt32 SetMessageFlags([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] UserWebID, string UserGamerTag, System.UInt32 MessageID, WCMessageFlags SetFlags, WCMessageFlags UnsetFlags);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/EnumTitleWideMessages", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public abstract System.UInt32 EnumTitleWideMessages(System.UInt32 TitleID, [System.Xml.Serialization.XmlElementAttribute("Summary")] out WCTitleWideMessageSummary[] Summary);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/GetTitleWideMessageDetails", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public abstract System.UInt32 GetTitleWideMessageDetails(System.UInt32 TitleID, System.UInt32 MessageID, out WCTitleWideMessageSummary Summary, out WCMessageDetails Details);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/DeleteTitleWideMessage", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public abstract System.UInt32 DeleteTitleWideMessage(System.UInt32 TitleID, System.UInt32 MessageID, WCDeleteSysMsgFlags Flags);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/SendTitleWideMessage", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public abstract System.UInt32 SendTitleWideMessage(string Sender, System.UInt64 SenderContext, System.DateTime SentTime, System.UInt32 Region, WCMessageFlags MessageFlags, System.UInt32 SenderTitleID, System.UInt16 ExpireMinutes, WCMessageType MessageType, string Description, WCMessageDetails Details, [System.Xml.Serialization.XmlElementAttribute("LocalizedString")] WCLocalizedString[] LocalizedString, [System.Xml.Serialization.XmlElementAttribute("Attachment")] WCMessageAttachment[] Attachment, out System.UInt16 Delay, out System.UInt32 MessageID);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/SendTitleUserMessage", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public abstract System.UInt32 SendTitleUserMessage(string Sender, System.UInt64 SenderContext, WCMessageFlags MessageFlags, System.UInt32 SenderTitleID, System.UInt16 ExpireMinutes, WCMessageType MessageType, [System.Xml.Serialization.XmlElementAttribute("Recipient")] string[] Recipient, WCMessageDetails Details, [System.Xml.Serialization.XmlElementAttribute("Attachment")] WCMessageAttachment[] Attachment, [System.Xml.Serialization.XmlElementAttribute("RecipResult")] out WCRecipientResult[] RecipResult);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/RevokeTitleUserMessage", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public abstract System.UInt32 RevokeTitleUserMessage([System.Xml.Serialization.XmlElementAttribute("RecipResult")] WCRecipientResult[] RecipResult);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/GetMessageString", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("StringData")]
        public abstract string GetMessageString(System.UInt32 TitleID, System.UInt32 StringID, string Locale);
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class WCMessageSummary {
        
        /// <remarks/>
        public string Sender;
        
        /// <remarks/>
        public System.UInt64 SenderContext;
        
        /// <remarks/>
        public System.DateTime SentTime;
        
        /// <remarks/>
        public System.UInt32 MessageID;
        
        /// <remarks/>
        public WCMessageFlags MessageFlags;
        
        /// <remarks/>
        public System.UInt32 SenderTitleID;
        
        /// <remarks/>
        public System.UInt16 ExpireMinutes;
        
        /// <remarks/>
        public System.UInt16 DetailsSize;
        
        /// <remarks/>
        public WCMessageType MessageType;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    [System.FlagsAttribute()]
    public enum WCMessageFlags {
        
        /// <remarks/>
        Required = 1,
        
        /// <remarks/>
        Recommended = 2,
        
        /// <remarks/>
        HasVoice = 4,
        
        /// <remarks/>
        HasText = 8,
        
        /// <remarks/>
        Read = 16,
        
        /// <remarks/>
        NonExportable = 32,
        
        /// <remarks/>
        TeamContext = 64,
        
        /// <remarks/>
        CompContext = 128,
        
        /// <remarks/>
        AlternateTitle = 256,
        
        /// <remarks/>
        Marketing = 512,

        // Note: This flag corresponds to XONLINE_MSG_FLAG_MS_MARKETING, which was added
        // for the Xbox 360 release (in changelist 150008) to identify marketing messages
        // from Microsoft (as opposed to from partners, which the previous flag identifies).
        // We're not updating the name of this flag here so we don't have to worry about what
        // partner sites will do with a different name, and since this flag is for Microsoft
        // use only, calling it MSReserved0 is still reasonably accurate. This comment was added
        // to resolve bug 34037.
        /// <remarks/>
        MSReserved0 = 1024, 
        /// <remarks/>
        MSReserved1 = 2048,
        
        /// <remarks/>
        MSReserved2 = 4096,
        
        /// <remarks/>
        MSReserved3 = 8192,
        
        /// <remarks/>
        MSReserved4 = 16384,
        
        /// <remarks/>
        MSReserved5 = 32768,
        
        /// <remarks/>
        MSReserved6 = 65536,
        
        /// <remarks/>
        MSReserved7 = 131072,
        
        /// <remarks/>
        MSReserved8 = 262144,
        
        /// <remarks/>
        MSReserved9 = 524288,
        
        /// <remarks/>
        MSReserved10 = 1048576,
        
        /// <remarks/>
        MSReserved11 = 2097152,
        
        /// <remarks/>
        MSReserved12 = 4194304,
        
        /// <remarks/>
        MSReserved13 = 8388608,
        
        /// <remarks/>
        TitleReserved0 = 16777216,
        
        /// <remarks/>
        TitleReserved1 = 33554432,
        
        /// <remarks/>
        TitleReserved2 = 67108864,
        
        /// <remarks/>
        TitleReserved3 = 134217728,
        
        /// <remarks/>
        TitleReserved4 = 268435456,
        
        /// <remarks/>
        TitleReserved5 = 536870912,
        
        /// <remarks/>
        TitleReserved6 = 1073741824,
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public enum WCMessageType {
        
        /// <remarks/>
        Invalid,
        
        /// <remarks/>
        TitleCustom,
        
        /// <remarks/>
        FriendRequest,
        
        /// <remarks/>
        GameInvite,
        
        /// <remarks/>
        TeamRecruit,
        
        /// <remarks/>
        CompReminder,
        
        /// <remarks/>
        CompRequest,
        
        /// <remarks/>
        LiveMessage,
        
        /// <remarks/>
        PersonalMessage,

        /// <remarks/>
        VideoMessage,
        
        /// <remarks/>
        QuickChatInvite,
        
        /// <remarks/>
        VideoChatInvite,
        
        /// <remarks/>
        PartyChatInvite,
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class WCLanguageString {
        
        /// <remarks/>
        public string Locale;
        
        /// <remarks/>
        public string String;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class WCLocalizedString {
        
        /// <remarks/>
        public System.Byte PropID;
        
        /// <remarks/>
        public string DefaultLocale;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("LangString")]
        public WCLanguageString[] LangString;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class WCTitleWideMessageSummary {
        
        /// <remarks/>
        public System.UInt32 TitleID;
        
        /// <remarks/>
        public System.UInt64 SenderContext;
        
        /// <remarks/>
        public System.DateTime SentTime;
        
        /// <remarks/>
        public System.UInt32 Region;
        
        /// <remarks/>
        public System.UInt32 MessageID;
        
        /// <remarks/>
        public WCMessageFlags MessageFlags;
        
        /// <remarks/>
        public System.UInt16 ExpireMinutes;
        
        /// <remarks/>
        public System.UInt16 DetailsSize;
        
        /// <remarks/>
        public WCMessageType MessageType;
        
        /// <remarks/>
        public string SenderName;
        
        /// <remarks/>
        public string Description;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class WCUserTitle {
        
        /// <remarks/>
        public System.UInt32 TitleID;
        
        /// <remarks/>
        public System.DateTime LastLogonTime;
        
        /// <remarks/>
        public WCUserTitleFlags Flags;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    [System.FlagsAttribute()]
    public enum WCUserTitleFlags {
        
        /// <remarks/>
        AcceptMarketing = 1,
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class WCRecipientResult {
        
        /// <remarks/>
        public string User;
        
        /// <remarks/>
        public System.UInt32 MessageID;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class WCMessageAttachment {
        
        /// <remarks/>
        public System.Byte PropID;
        
        /// <remarks/>
        public WCAttachFlags Flags;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
        public System.Byte[] Data;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    [System.FlagsAttribute()]
    public enum WCAttachFlags {
        
        /// <remarks/>
        NonExportable = 1,
        
        /// <remarks/>
        Directory = 2,
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class WCStringIdProp {
        
        /// <remarks/>
        public System.Byte PropID;
        
        /// <remarks/>
        public System.UInt32 Value;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class WCBoolProp {
        
        /// <remarks/>
        public System.Byte PropID;
        
        /// <remarks/>
        public bool Value;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class WCAttachmentProp {
        
        /// <remarks/>
        public System.Byte PropID;
        
        /// <remarks/>
        public System.UInt32 AttachSize;
        
        /// <remarks/>
        public WCAttachFlags AttachFlags;
        
        /// <remarks/>
        public string AttachUrl;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class WCBinaryProp {
        
        /// <remarks/>
        public System.Byte PropID;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
        public System.Byte[] Value;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class WCTimeProp {
        
        /// <remarks/>
        public System.Byte PropID;
        
        /// <remarks/>
        public System.DateTime Value;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class WCStringProp {
        
        /// <remarks/>
        public System.Byte PropID;
        
        /// <remarks/>
        public string Value;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class WCQwordProp {
        
        /// <remarks/>
        public System.Byte PropID;
        
        /// <remarks/>
        public System.UInt64 Value;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class WCDwordProp {
        
        /// <remarks/>
        public System.Byte PropID;
        
        /// <remarks/>
        public System.UInt32 Value;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class WCWordProp {
        
        /// <remarks/>
        public System.Byte PropID;
        
        /// <remarks/>
        public System.UInt16 Value;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class WCByteProp {
        
        /// <remarks/>
        public System.Byte PropID;
        
        /// <remarks/>
        public System.Byte Value;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class WCNullProp {
        
        /// <remarks/>
        public System.Byte PropID;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class WCMessageDetails {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("NullProp")]
        public WCNullProp[] NullProp;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("ByteProp")]
        public WCByteProp[] ByteProp;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("WordProp")]
        public WCWordProp[] WordProp;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("DwordProp")]
        public WCDwordProp[] DwordProp;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("QwordProp")]
        public WCQwordProp[] QwordProp;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("StringProp")]
        public WCStringProp[] StringProp;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("TimeProp")]
        public WCTimeProp[] TimeProp;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("BinaryProp")]
        public WCBinaryProp[] BinaryProp;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("AttachmentProp")]
        public WCAttachmentProp[] AttachmentProp;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("BoolProp")]
        public WCBoolProp[] BoolProp;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("StringIdProp")]
        public WCStringIdProp[] StringIdProp;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    [System.FlagsAttribute()]
    public enum WCDeleteMsgFlags {
        
        /// <remarks/>
        BlockSender = 1,
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    [System.FlagsAttribute()]
    public enum WCDeleteSysMsgFlags {
        
        /// <remarks/>
        RevokeAll = 1,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Messaging\MOTDTool\MOTDTool.cs ===
using System;
using System.IO;
using System.Net;
using xonline.common.tools.console;
using xonline.server.webcache.messaging.motdtool;


namespace xonline.server.webcache.messaging.motdtool 
{
    // Change the URL and add the HTTP headers that make the widget validation code happy:).
    public class MessagingWidget : Messaging
    {
        public MessagingWidget( string strUrl )
        {
            Url = strUrl;
        }

        override protected WebRequest GetWebRequest( Uri url )
        {
            WebRequest wr = base.GetWebRequest( url );
            if( null != wr )
            {
                wr.Headers.Add( "Subject-Name", "DebugPartner" );
                wr.Headers.Add( "Client-IP-Port", "1.1.1.1:1000" );
                wr.Headers.Add( "RequestId", "CAFEBABEDEADBEEF" );
            }

            return wr;
        }
    }

    class CMOTDToolApp  
    {
        static void Usage()
        {
            Console.WriteLine( "MOTDTOOL:" );
            Console.WriteLine( "Tool to add a sample message of the day to the Xbox Live Messaging Service" );
            Console.WriteLine( "" );
            Console.WriteLine( "Usage:" );
            Console.WriteLine( "MOTDTOOL /title:<titleid> /ip:<ip>" );
            Console.WriteLine( "" );
            Console.WriteLine( "Definitions:" );
            Console.WriteLine( "    <titleid>    - Unique Xbox Live identifier for the desired title (in" );
            Console.WriteLine( "                   unsigned decimal)" );
            Console.WriteLine( "    <ip>         - The IP address or DNS name of the Messaging widget" );
            Console.WriteLine( "" );
            Console.WriteLine( "Messages sent with this tool will go to all users of the title and will expire" );
            Console.WriteLine( "after 1 day." );
            Console.WriteLine( "" );
        }
        
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static int Main( string[] args )
        {
            string [] rgstrCmdLineTags = 
            {
                "?", 
                "title",            // title ID
                "ip",               // IP or DNS name of the Messaging widget box
            };
            
            NamedArgParser ArgParser = new NamedArgParser( rgstrCmdLineTags );

            // Parse any command line arguments
            if ( !ArgParser.Parse( args ) )
            {
                Usage();
                return -1;
            }

            // Did the user request usage information?            
            if ( 0 == ArgParser.Count ||
                null != ArgParser[ "?" ] )
            {
                Usage();
                return 0;
            }

            if( null == ArgParser[ "title" ] )
            {
                // user didn't supply a title ID
                Console.WriteLine( "" );
                Console.WriteLine( "Error: Title ID must be specified." );
                return -1;
            }

            uint dwTitleID = System.Convert.ToUInt32( ArgParser[ "title" ] );

            // Build the URL
            string strUrl = "http://";
            string strUrlParam = ArgParser[ "ip" ];
            if( null == strUrlParam )
            {
                strUrlParam = "localhost";
            }
            strUrl = strUrl + strUrlParam + "/Messaging/Messaging.asmx";

            Console.WriteLine( "Sending message of the day to title 0x{0}, url {1}...", dwTitleID.ToString("X"), strUrl );

            // Build up the message ///////////////////////////////////////////
            MemoryStream stream = null;
            BinaryWriter writer = null;

            // Add some details ///////////////////////////////////////////////
            WCMessageDetails details = new WCMessageDetails();

            details.NullProp = new WCNullProp[ 1 ];
            details.NullProp[ 0 ] = new WCNullProp();
            details.NullProp[ 0 ].PropID = 0x01;

            details.ByteProp = new WCByteProp[ 1 ];
            details.ByteProp[ 0 ] = new WCByteProp();
            details.ByteProp[ 0 ].PropID = 0x02;
            details.ByteProp[ 0 ].Value = 22;

            details.WordProp = new WCWordProp[ 1 ];
            details.WordProp[ 0 ] = new WCWordProp();
            details.WordProp[ 0 ].PropID = 0x03;
            details.WordProp[ 0 ].Value = 23;

            details.DwordProp = new WCDwordProp[ 1 ];
            details.DwordProp[ 0 ] = new WCDwordProp();
            details.DwordProp[ 0 ].PropID = 0x04;
            details.DwordProp[ 0 ].Value = 24;

            details.QwordProp = new WCQwordProp[ 1 ];
            details.QwordProp[ 0 ] = new WCQwordProp();
            details.QwordProp[ 0 ].PropID = 0x05;
            details.QwordProp[ 0 ].Value = 25;

            details.StringProp = new WCStringProp[ 1 ];
            details.StringProp[ 0 ] = new WCStringProp();
            details.StringProp[ 0 ].PropID = 0x06;
            details.StringProp[ 0 ].Value = "This is a string prop for my message of the day";

            details.TimeProp = new WCTimeProp[ 1 ];
            details.TimeProp[ 0 ] = new WCTimeProp();
            details.TimeProp[ 0 ].PropID = 0x07;
            details.TimeProp[ 0 ].Value = new DateTime( 2001, 11, 15, 0, 0, 0, 0 );

            details.BinaryProp = new WCBinaryProp[ 1 ];
            details.BinaryProp[ 0 ] = new WCBinaryProp();
            details.BinaryProp[ 0 ].PropID = 0x08;
            details.BinaryProp[ 0 ].Value = new byte[ 10 ];
            details.BinaryProp[ 0 ].Value[ 0 ] = 0;
            details.BinaryProp[ 0 ].Value[ 1 ] = 1;
            details.BinaryProp[ 0 ].Value[ 2 ] = 2;
            details.BinaryProp[ 0 ].Value[ 3 ] = 3;
            details.BinaryProp[ 0 ].Value[ 4 ] = 4;
            details.BinaryProp[ 0 ].Value[ 5 ] = 5;
            details.BinaryProp[ 0 ].Value[ 6 ] = 6;
            details.BinaryProp[ 0 ].Value[ 7 ] = 7;
            details.BinaryProp[ 0 ].Value[ 8 ] = 8;
            details.BinaryProp[ 0 ].Value[ 9 ] = 9;

            details.BoolProp = new WCBoolProp[ 1 ];
            details.BoolProp[ 0 ] = new WCBoolProp();
            details.BoolProp[ 0 ].PropID = 0x0A;
            details.BoolProp[ 0 ].Value = true;

            // Create a localized string in two languages /////////////////////
            WCLocalizedString[] strings = new WCLocalizedString[ 1 ];
            strings[ 0 ] = new WCLocalizedString();
            strings[ 0 ].DefaultLocale = "en-us";
            strings[ 0 ].PropID = 0x10;
            strings[ 0 ].LangString = new WCLanguageString[ 2 ];
            strings[ 0 ].LangString[ 0 ] = new WCLanguageString();
            strings[ 0 ].LangString[ 0 ].Locale = "en-us";
            strings[ 0 ].LangString[ 0 ].String = "This is an English string that should push to the string server.";
            strings[ 0 ].LangString[ 1 ] = new WCLanguageString();
            strings[ 0 ].LangString[ 1 ].Locale = "fr-fr";
            strings[ 0 ].LangString[ 1 ].String = "Ici les mots francais.  Vraiment, je suis tout ce qui est homme.";

            // Add two attachments ////////////////////////////////////////////
            WCMessageAttachment[] attachments = new WCMessageAttachment[ 2 ];

            // Add a binary attachment
            attachments[ 0 ] = new WCMessageAttachment();
            attachments[ 0 ].PropID = 0x20;
            attachments[ 0 ].Flags = 0;
            attachments[ 0 ].Data = new byte[ 100 ];
            stream = new MemoryStream( attachments[ 0 ].Data );
            writer = new BinaryWriter( stream );
            writer.Write( "This is the first test attachment." );
            writer.Flush();
            stream = null;
            writer = null;

            // Add a package attachment
            attachments[ 1 ] = new WCMessageAttachment();
            attachments[ 1 ].PropID = 0x21;
            attachments[ 1 ].Flags = WCAttachFlags.Directory;

            // Attempt to open the file
            FileStream fstream = new FileStream( "new.xcp", FileMode.Open );
            attachments[ 1 ].Data = new byte[ fstream.Length ];
            fstream.Read( attachments[ 1 ].Data, 0, (int) fstream.Length );

            // Send the message ///////////////////////////////////////////////
            MessagingWidget widget = new MessagingWidget( strUrl );

            uint uiSentMessageID = 0;
            ushort usDelay = 0;
            UInt32 hr = widget.SendTitleWideMessage( "MOTDTool",                    // SenderName
                                                     0x0123456789ABCDEF,            // SenderContext
                                                     DateTime.UtcNow,               // SentTime
                                                     0,                             // Region
                                                     WCMessageFlags.TitleReserved0, // MessageFlags
                                                     dwTitleID,                     // TitleID
                                                     1440,                          // ExpireMinutes (1 day)
                                                     WCMessageType.TitleCustom,     // MessageType
                                                     "MOTDTool sample message",     // Description
                                                     details,                       // Details
                                                     strings,                       // Strings
                                                     attachments,                   // Attachments
                                                     out usDelay,                   // Submission delay added
                                                     out uiSentMessageID );         // MessageID
            if( 0 != ( hr & 0x80000000 ) )
            {
                Console.WriteLine( "Error: Send failed, hr=" + hr.ToString( "X" ) );
                return -1;
            }

            if( 0 == usDelay )
            {
                Console.WriteLine( "Message sent successfully, ID=" + uiSentMessageID.ToString( "X" ) + "." );
            }
            else
            {
                Console.WriteLine( "Message sent successfully, ID=" + uiSentMessageID.ToString( "X" ) + ", message is delayed " + usDelay.ToString() + " minutes to wait for the String service to reload strings." );
            }

            return 0;

        } // Main

    } // CMOTDToolApp

} // namespace Xbox.Tools.MOTDTool
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Messaging\Test\FuncGetMessageString.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using System.IO;
using System.Xml;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.Messaging;
using ServerTestFramework.Web.UserAccount;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;

namespace MessagingWidget
{
	// TODO: Run tests and more cases when API is available

	[TestGroup]
	public class FuncGetMsgString : TestNode
	{
		[TestCase, Description("BasicGetMsgString")]
			class BasicGetMsgString : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();

				string resultString = service.GetMessageString(
					400001,
					2147483653,
					//WCLanguage.English
					"en-US"
					);
             
				if ( resultString == null )
				{
					return;
				}
				else
					ConsoleX.WriteLine("\nGot string: " + resultString);

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("Test default string")]
		class GetDefaultString : TestBase
		{
			protected override void Execute()
			{

				ResultCode = TEST_RESULTS.PASSED;
			}
		}
	
		//TODO:  Add new cases for locale string tests

		//TODO: requires pre-populated data in xprof tables
		[TestCase, Description("NegInvalid")]
			class NegInvalid : TestBase
		{
			protected override void Execute()
			{

				// User Invalid GamerTag, string, data, etc.

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

	
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Messaging\Test\FuncEnumTitleMessages.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using System.IO;
using System.Xml;
using System.Web.Services.Protocols;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.Messaging;
using ServerTestFramework.Web.UserAccount;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;

namespace MessagingWidget
{
	[TestGroup]
	public class FuncEnumTitleWideMessages : TestNode
	{
		[TestCase, Description("BasicEnumSysMsgs")]
		class BasicEnumSysMsgs : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
				WCTitleWideMessageSummary[] summary = null;

				UInt32 hr = service.EnumTitleWideMessages(
					400001,
					out summary
					);

				if( HResult.Succeeded( hr ) )
				{
					for( int iMessage = 0; iMessage < summary.Length; iMessage++ )
					{
						Global.RO.Info( "    Message {0}", iMessage );
						Global.RO.Info( "        TitleID - {0}", summary[ iMessage ].TitleID);
						Global.RO.Info( "        SenderName - {0}", summary[ iMessage ].SenderName);
						Global.RO.Info( "        qwSenderContext - {0}", summary[ iMessage ].SenderContext );
						Global.RO.Info( "        Region - {0}", summary[ iMessage ].Region );
						Global.RO.Info( "        mtSentTime - {0}", summary[ iMessage ].SentTime );
						Global.RO.Info( "        dwMessageID - {0}", summary[ iMessage ].MessageID );
						Global.RO.Info( "        dwMessageFlags - {0}", summary[ iMessage ].MessageFlags );
						Global.RO.Info( "        dwDescription - {0}", summary[ iMessage ].Description);
						Global.RO.Info( "        bMessageType - {0}", summary[ iMessage ].MessageType );
						Global.RO.Info( "        wExpireMinutes - {0}", summary[ iMessage ].ExpireMinutes );
						Global.RO.Info( "        cbDetails - {0}", summary[ iMessage ].DetailsSize );
					}
				}
				else
				{
					Global.RO.Info("Enum failed: " + hr.ToString("X") );
					return;
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}
	
		[TestCase, Description("Enum System-Wide Message")]
		class EnumSysWideMsgs : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
				WCTitleWideMessageSummary[] summary = null;

				UInt32 hr = service.EnumTitleWideMessages(
					0,					//  0 == system wide message
					out summary
					);

				if( HResult.Succeeded( hr ) )
				{
					for( int iMessage = 0; iMessage < summary.Length; iMessage++ )
					{
						Global.RO.Info( "    Message {0}", iMessage );
						Global.RO.Info( "        TitleID - {0}", summary[ iMessage ].TitleID);
						Global.RO.Info( "        qwSenderContext - {0}", summary[ iMessage ].SenderContext );
						Global.RO.Info( "        Region - {0}", summary[ iMessage ].Region );
						Global.RO.Info( "        mtSentTime - {0}", summary[ iMessage ].SentTime );
						Global.RO.Info( "        dwMessageID - {0}", summary[ iMessage ].MessageID );
						Global.RO.Info( "        dwMessageFlags - {0}", summary[ iMessage ].MessageFlags );
						Global.RO.Info( "        SenderName - {0}", summary[ iMessage ].SenderName );
						Global.RO.Info( "        dwDescription - {0}", summary[ iMessage ].Description);
						Global.RO.Info( "        bMessageType - {0}", summary[ iMessage ].MessageType );
						Global.RO.Info( "        wExpireMinutes - {0}", summary[ iMessage ].ExpireMinutes );
						Global.RO.Info( "        cbDetails - {0}", summary[ iMessage ].DetailsSize );
					}
				}
				else
				{
					Global.RO.Info("Enum failed: " + hr.ToString("X") );
					return;
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}
	
		[TestCase, Description("Neg Enum Bad ID")]
		class NegEnumBadID : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
				WCTitleWideMessageSummary[] summary = null;

				try 
				{
					UInt32 hr = service.EnumTitleWideMessages(
						1111,									// TitleID should not exist
						out summary
						);

					if( HResult.Succeeded( hr ) )
					{
						Global.RO.Info("Unexpected pass.");
						return;
					}
				}
				catch(SoapException e)
				{
					// DebugPartner error message expected
                    string expMsgStart = "Server was unable to process request. ---> Partner:DebugPartner";
                    if (!e.Message.StartsWith(expMsgStart)) 
					{
                        Global.RO.Info("Unexpected soap exception message: " + e.Message + " ... had expected: " + expMsgStart);
						return;
					}
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}


	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Messaging\Test\FuncRevokeMessage.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using System.IO;
using System.Xml;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.Messaging;
using ServerTestFramework.Web.UserAccount;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;
using System.Web.Services.Protocols;

namespace MessagingWidget
{
	[TestGroup]
	public class FuncRevokeMessage : TestNode
	{
		[TestCase, Description("ValidRevokeMessage")]
		class ValidRevokeMessage : TestBase
		{
			// 1. verify msg exists
			// 2. revoke msg
			// 3. verify revoke

			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();

				//WCWebUser user = new WCWebUser();
				//user.GamerTag = MWGlobal.Users[5].GamerTag;
				//user.WebID = MWGlobal.Users[5].WebId;

				WCMessageSummary[] summary = null;
				
				UInt32 hr = service.EnumMessages( 
					MWGlobal.Users[5].WebId,       // User
					MWGlobal.Users[5].GamerTag,
					out summary );

				if ( HResult.Failed(hr) )
				{
					Console.WriteLine("Enum failed, hr: " + hr.ToString("X"));
					return;
				}

				// find message ID for revoke
				bool msgFound = false;
				uint revokemsgID;

				if ( MWGlobal.MessageList.Contains("RevokeMsg") )
					revokemsgID = (uint) MWGlobal.MessageList["RevokeMsg"];
				else
				{
					Console.WriteLine("Message to revoke not sent.");
					return;
				}

				foreach (WCMessageSummary sum in summary)
				{
					if ( sum.MessageID == revokemsgID)
						msgFound = true;
				}

				if (!msgFound)
				{
					Console.WriteLine("Message to revoke not found in user queue.");
					return;
				}

				// Now revoke the message

				WCRecipientResult[] revokelist = new WCRecipientResult[1];
				revokelist[0] = new WCRecipientResult();
				revokelist[0].User = MWGlobal.Users[5].GamerTag;
				revokelist[0].MessageID = revokemsgID;

				//user.GamerTag = MWGlobal.Users[0].GamerTag;
				//user.WebID = MWGlobal.Users[0].WebId;

				hr = service.RevokeMessage(
					MWGlobal.Users[0].WebId,
					MWGlobal.Users[0].GamerTag,
					revokelist
					);

				if( HResult.Failed( hr ) )
				{
					Console.WriteLine("Failed to revoke msg, hr: " + hr.ToString("X") );
					return;
				}

				// now verify revoke
				//user.GamerTag = MWGlobal.Users[5].GamerTag;
				//user.WebID = MWGlobal.Users[5].WebId;

				summary = null;
				
				hr = service.EnumMessages( 
					MWGlobal.Users[5].WebId,       // User
					MWGlobal.Users[5].GamerTag,
					out summary );

				if ( HResult.Failed(hr) )
				{
					Console.WriteLine("Enum2 failed, hr: " + hr.ToString("X"));
					return;
				}

				msgFound = false;
				foreach (WCMessageSummary sum in summary)
				{
					if ( sum.MessageID == revokemsgID)
						msgFound = true;
				}

				if ( msgFound )   // uh-oh, the revoke did not work!?
				{
					Console.WriteLine("Msg stille exists in queue.");
					return;
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}
	
		[TestCase, Description("RevokeUnknownMessage")]
		class RevokeUnknownMessage : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();

				//WCWebUser user = new WCWebUser();
				//user.GamerTag = MWGlobal.Users[1].GamerTag;
				//user.WebID = MWGlobal.Users[1].WebId;

				WCRecipientResult[] revokelist = new WCRecipientResult[1];
				revokelist[0] = new WCRecipientResult();
				revokelist[0].User = MWGlobal.Users[0].GamerTag;
				revokelist[0].MessageID = 9999;						
					// this message should not exist
					// TODO: But there's a better way...

				UInt32 hr = service.RevokeMessage(
					MWGlobal.Users[1].WebId,
					MWGlobal.Users[1].GamerTag,
					revokelist
					);

				if( HResult.Succeeded( hr ) )
				{
					// Should return OK whether the message exists or was revoked or not

				}
				else
				{
					Console.WriteLine("Failed, hr: " + hr.ToString("X") );
					return;
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("NegRevokeUnknownGamer")]
		class NegRevokeUnknownGamer : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();

				//WCWebUser user = new WCWebUser();
				//user.GamerTag = RandomEx.GlobalRandGen.GenerateRandomString(15);
				//user.WebID = MWGlobal.Users[0].WebId;				//valid WebID, bad GamerTag

				WCRecipientResult[] revokelist = new WCRecipientResult[1];
				revokelist[0] = new WCRecipientResult();
				revokelist[0].User = MWGlobal.Users[0].GamerTag;
				revokelist[0].MessageID = UInt32.MaxValue;						
				// this message should not exist
				// TODO: But there's a better way...

				try 
				{

					UInt32 hr = service.RevokeMessage(
						MWGlobal.Users[0].WebId,
						RandomEx.GlobalRandGen.GenerateRandomString(15),
						revokelist
						);

					if( HResult.Succeeded( hr ) )
					{
						// FAILED
						Console.WriteLine("Unexpected success.");
						return;
					}
				}
				catch (SoapException e)		// this is normal
				{
					if (! e.Message.EndsWith("not linked in our system") )
					{
						Console.WriteLine(e.Message);
						return;
					}
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("NegRevokeMismatchedUser")]
		class NegRevokeMismatchedUser : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();

				//WCWebUser user = new WCWebUser();
				//user.GamerTag = MWGlobal.Users[0].GamerTag;			//  User 0 name, User 1 WebID
				//user.WebID = MWGlobal.Users[1].WebId;

				WCRecipientResult[] revokelist = new WCRecipientResult[1];
				revokelist[0] = new WCRecipientResult();
				revokelist[0].User = MWGlobal.Users[0].GamerTag;
				revokelist[0].MessageID = UInt32.MaxValue;						
				// this message should not exist
				// TODO: But there's a better way...

				try 
				{

					UInt32 hr = service.RevokeMessage(
						MWGlobal.Users[0].WebId,
						MWGlobal.Users[1].GamerTag,
						revokelist
						);

					if( HResult.Succeeded( hr ) )
					{
						// FAILED
						Console.WriteLine("Unexpected success.");
						return;
					}
				}
				catch (SoapException e)		// this is normal
				{
					if (! e.Message.EndsWith("not linked in our system") )
					{
						Console.WriteLine(e.Message);
						return;
					}
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("NegRevokeNullUser")]
		class NegRevokeNullUser : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();

				//WCWebUser user = new WCWebUser();
				//user.GamerTag = null;
				//user.WebID = MWGlobal.Users[1].WebId;

				WCRecipientResult[] revokelist = new WCRecipientResult[1];
				revokelist[0] = new WCRecipientResult();
				revokelist[0].User = MWGlobal.Users[0].GamerTag;
				revokelist[0].MessageID = UInt32.MaxValue;						

				try 
				{
					UInt32 hr = service.RevokeMessage(
						null,
						MWGlobal.Users[1].GamerTag,
						revokelist
						);

					if( HResult.Succeeded( hr ) )
					{
						// FAILED
						Console.WriteLine("Unexpected success.");

					}
				}
				catch(SoapException e)
				{
					// this is OK, should get error return from SOAP call
					Console.WriteLine(e.Message);
				}
				
				// Check empty string too
				//user.GamerTag = "";
				try
				{	
					uint hr = service.RevokeMessage(
						MWGlobal.Users[1].WebId,
						"",
						revokelist
						);

					if( HResult.Succeeded( hr ) )
					{
						// FAILED
						Console.WriteLine("Unexpected success.");
						return;
					}
				}
				catch (SoapException e)		// this is normal
				{
					// success! ?
					Console.WriteLine(e.Message);
				}


				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("NegRevokeTooLongUser")]
		class NegRevokeTooLongUser : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();

				//WCWebUser user = new WCWebUser();
				//user.GamerTag = "1234567890123456";		// 16 characters long
				//user.WebID = MWGlobal.Users[1].WebId;

				WCRecipientResult[] revokelist = new WCRecipientResult[1];
				revokelist[0] = new WCRecipientResult();
				revokelist[0].User = MWGlobal.Users[0].GamerTag;
				revokelist[0].MessageID = UInt32.MaxValue;						

				try 
				{
					UInt32 hr = service.RevokeMessage(
						MWGlobal.Users[1].WebId,
						"1234567890123456",
						revokelist
						);

					if( HResult.Succeeded( hr ) )
					{
						// FAILED
						Console.WriteLine("Unexpected success.");
						return;
					}
				}
				catch (SoapException e)		// this is normal
				{
					if (! e.Message.EndsWith("not linked in our system") )
					{
						Console.WriteLine(e.Message);
						return;
					}
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Messaging\Test\FuncGetMessageDetails.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using System.IO;
using System.Xml;
using System.Web.Services.Protocols;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.Messaging;
using ServerTestFramework.Web.UserAccount;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;

namespace MessagingWidget
{
	[TestGroup]
	public class FuncGetMessageDetails : TestNode
	{
        //TODO: test dependency on SendMessage
		[TestCase, Description("ValidGetDetails")]
		class ValidGetDetails : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
				WCMessageSummary summary = null;
				WCMessageDetails details = null;

				// pull this from Send test?
				//uint uiSentMessageID = 0x0000ABCD;

				//WCWebUser user = new WCWebUser();
				//user.GamerTag = MWGlobal.Users[1].GamerTag;
				//user.WebID = MWGlobal.Users[1].WebId;

				uint msgid = 0;

				if ( MWGlobal.MessageList.Contains("BasicMessage") )
					msgid = (uint) MWGlobal.MessageList["BasicMessage"];
				else
					return;

				uint hr = service.GetMessageDetails( 
					MWGlobal.Users[1].WebId,               // User
					MWGlobal.Users[1].GamerTag,
					msgid,				// MessageID   
					//WCMessageFlags.Read, // SetFlags
					//WCMessageFlags.TitleReserved0, // UnsetFlags
					0,
					0,
					out summary,
					out details );

				if( HResult.Failed( hr ) )
				{
					Global.RO.Info("GetMessageDetails failed, HResult: " + hr );
					return;
				}

				if ( summary != null )
				{

					Global.RO.Info( "    Summary:" );
					Global.RO.Info( "        szSenderName - {0}",    summary.Sender );
					Global.RO.Info( "        qwSenderContext - {0}", summary.SenderContext );
					Global.RO.Info( "        mtSentTime - {0}",      summary.SentTime );
					Global.RO.Info( "        dwMessageID - {0}",     summary.MessageID );
					Global.RO.Info( "        dwMessageFlags - {0}",  summary.MessageFlags );
					Global.RO.Info( "        dwSenderTitleID - {0}", summary.SenderTitleID );
					Global.RO.Info( "        bMessageType - {0}",    summary.MessageType );
					Global.RO.Info( "        wExpireMinutes - {0}",  summary.ExpireMinutes );
					Global.RO.Info( "        cbDetails - {0}",       summary.DetailsSize );
				}

				if ( details != null )
				{
					if ( details.NullProp != null )
					{
						Global.RO.Info("Nullprop count: " + details.NullProp.Length);
					}

					foreach ( WCByteProp byteprop in details.ByteProp )
					{
						Global.RO.Info("ByteProp: " + byteprop.Value );
					}

					foreach ( WCWordProp wordprop in details.WordProp )
					{
						Global.RO.Info("WordProp: " + wordprop.Value );
					}

					foreach ( WCDwordProp dwordprop in details.DwordProp )
					{
						Global.RO.Info("DWordProp: " + dwordprop.Value );
					}

					foreach ( WCQwordProp qwordprop in details.QwordProp )
					{
						Global.RO.Info("QWordProp: " + qwordprop.Value );
					}

					foreach ( WCStringProp stringprop in details.StringProp )
					{
						Global.RO.Info("StringProp: " + stringprop.Value );
					}

					foreach ( WCTimeProp timeprop in details.TimeProp )
					{
						Global.RO.Info("TimeProp: " + timeprop.Value );
					}

					foreach ( WCBinaryProp binprop in details.BinaryProp )
					{
						Global.RO.Info("BinaryProp size: " + binprop.Value.Length);
					}
					
					foreach ( WCAttachmentProp attachprop in details.AttachmentProp )
					{
						Global.RO.Info("AttachmentProp: " + attachprop.AttachUrl );
					}

					foreach ( WCBoolProp boolprop in details.BoolProp )
					{
						Global.RO.Info("BoolProp: " + boolprop.Value );
					}

					foreach ( WCStringIdProp stringidprop in details.StringIdProp )
					{
						Global.RO.Info("StringIDProp: " + stringidprop.Value );
					}

				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}
	
		// GetMessageDetails helper base class
		class GetDetailsTest : TestBase
		{
			protected override void Execute()
			{
				return;
			}

			public void GetDetails(uint msgID)
			{

				WCMessaging service = new WCMessaging();
				WCMessageSummary summary = null;
				WCMessageDetails details = null;

				// pull this from Send test?
				//uint uiSentMessageID = 0x0000ABCD;

				//WCWebUser user = new WCWebUser();
				//user.GamerTag = MWGlobal.Users[2].GamerTag;		// user    User 2 for Details Helper
				//user.WebID = MWGlobal.Users[2].WebId;

				try 
				{
					uint hr = service.GetMessageDetails( 
						MWGlobal.Users[2].WebId,               // User
						MWGlobal.Users[2].GamerTag,
						msgID,				// MessageID   
						0,
						0,
						out summary,
						out details );

					if( HResult.Failed( hr ) )
					{
						Global.RO.Info("GetMessageDetails failed, HResult: " + hr );
						return;
					}

					if ( summary != null )
					{

						Global.RO.Info( "    Summary:" );
						Global.RO.Info( "        szSenderName - {0}",    summary.Sender );
						Global.RO.Info( "        qwSenderContext - {0}", summary.SenderContext );
						Global.RO.Info( "        mtSentTime - {0}",      summary.SentTime );
						Global.RO.Info( "        dwMessageID - {0}",     summary.MessageID );
						Global.RO.Info( "        dwMessageFlags - {0}",  summary.MessageFlags );
						Global.RO.Info( "        dwSenderTitleID - {0}", summary.SenderTitleID );
						Global.RO.Info( "        bMessageType - {0}",    summary.MessageType );
						Global.RO.Info( "        wExpireMinutes - {0}",  summary.ExpireMinutes );
						Global.RO.Info( "        cbDetails - {0}",       summary.DetailsSize );
					}

				
					if ( details != null )
					{
						#region DumpDetails
						if (details.NullProp != null)
							Global.RO.Info("Nullprop count: " + details.NullProp.Length);

						if (details.ByteProp != null)
							foreach ( WCByteProp byteprop in details.ByteProp )
							{
								Global.RO.Info("ByteProp: " + byteprop.Value );
							}

                        if (details.WordProp != null)
							foreach ( WCWordProp wordprop in details.WordProp )
							{
								Global.RO.Info("WordProp: " + wordprop.Value );
							}

						if (details.DwordProp != null)
							foreach ( WCDwordProp dwordprop in details.DwordProp )
							{
								Global.RO.Info("DWordProp: " + dwordprop.Value );
							}

						if (details.QwordProp != null)
							foreach ( WCQwordProp qwordprop in details.QwordProp )
							{
								Global.RO.Info("QWordProp: " + qwordprop.Value );
							}

						if (details.StringProp != null)
							foreach ( WCStringProp stringprop in details.StringProp )
							{
								Global.RO.Info("StringProp: " + stringprop.Value );
							}

						if (details.TimeProp != null)
							foreach ( WCTimeProp timeprop in details.TimeProp )
							{
								Global.RO.Info("TimeProp: " + timeprop.Value );
							}

						if (details.BinaryProp != null)
							foreach ( WCBinaryProp binprop in details.BinaryProp )
							{
								Global.RO.Info("BinaryProp size: " + binprop.Value.Length);
							}

						if (details.AttachmentProp != null)	
							foreach ( WCAttachmentProp attachprop in details.AttachmentProp )
							{
								Global.RO.Info("AttachmentProp: " + attachprop.AttachUrl );
							}

						if (details.BoolProp != null)
							foreach ( WCBoolProp boolprop in details.BoolProp )
							{
								Global.RO.Info("BoolProp: " + boolprop.Value );
							}

						if (details.StringIdProp != null)
							foreach ( WCStringIdProp stringidprop in details.StringIdProp )
							{
								Global.RO.Info("StringIDProp: " + stringidprop.Value );
							}
						#endregion DumpDetails
					}

				}
				catch(Exception e)
				{
					Global.RO.Info("EXCEPTION: " + e.Message);
					return;   // test failed
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("GetDetailsBasic")]
		class GetDetailsBasic : GetDetailsTest
		{
			protected override void Execute()
			{
				this.GetDetails( (uint) MWGlobal.MessageList["BasicMessage"] );
			}
		}

		[TestCase, Description("GetDetailsCompReq")]
		class GetDetailsCompReq : GetDetailsTest
		{
			protected override void Execute()
			{
				this.GetDetails( (uint) MWGlobal.MessageList["CompRequest"] );
			}
		}

		[TestCase, Description("GetDetailsCompRemind")]
			class GetDetailsCompRemind : GetDetailsTest
		{
			protected override void Execute()
			{
				this.GetDetails( (uint) MWGlobal.MessageList["CompRemind"] );
			}
		}

		// Deprecated test -- user messages can no longer send strings
		//[TestCase, Description("GetDetailsMsgString")]
			class GetDetailsMsgString : GetDetailsTest
		{
			protected override void Execute()
			{
				this.GetDetails( (uint) MWGlobal.MessageList["MessageString"] );
			}
		}

		[TestCase, Description("GetDetailsMsgAttach")]
			class GetDetailsMsgAttach : GetDetailsTest
		{
			protected override void Execute()
			{
				this.GetDetails( (uint) MWGlobal.MessageList["MessageAttachment"] );
			}
		}

		[TestCase, Description("GetDetailsStringID")]
			class GetDetailsStringID : GetDetailsTest
		{
			protected override void Execute()
			{
				this.GetDetails( (uint) MWGlobal.MessageList["DetailsStringID"] );
			}
		}

		[TestCase, Description("GetDetailsBool")]
			class GetDetailsBool: GetDetailsTest
		{
			protected override void Execute()
			{
				this.GetDetails( (uint) MWGlobal.MessageList["DetailsBool"] );
			}
		}

		[TestCase, Description("GetDetailsAttachment")]
			class GetDetailsAttachment : GetDetailsTest
		{
			protected override void Execute()
			{
				this.GetDetails( (uint) MWGlobal.MessageList["DetailsAttachment"] );
			}
		}

		[TestCase, Description("GetDetailsString")]
			class GetDetailsString : GetDetailsTest
		{
			protected override void Execute()
			{
				this.GetDetails( (uint) MWGlobal.MessageList["DetailsString"] );
			}
		}

        [TestCase, Description("GetDetailsPersonalMessage")]
        class GetDetailsPersonalMessage : GetDetailsTest
        {
            protected override void Execute()
            {
                this.GetDetails((uint)MWGlobal.MessageList["PersonalMessage"]);
            }
        }

		[TestCase, Description("GetDetailsBinary")]
			class GetDetailsBinary : GetDetailsTest
		{
			protected override void Execute()
			{
				this.GetDetails( (uint) MWGlobal.MessageList["DetailsBinary"] );
			}
		}

		[TestCase, Description("GetDetailsByte")]
			class GetDetailsByte : GetDetailsTest
		{
			protected override void Execute()
			{
				this.GetDetails( (uint) MWGlobal.MessageList["DetailsByte"] );
			}
		}

		[TestCase, Description("GetDetailsWord")]
			class GetDetailsWord : GetDetailsTest
		{
			protected override void Execute()
			{
				this.GetDetails( (uint) MWGlobal.MessageList["DetailsWord"] );
			}
		}

		[TestCase, Description("GetDetailsDword")]
			class GetDetailsDword : GetDetailsTest
		{
			protected override void Execute()
			{
				this.GetDetails( (uint) MWGlobal.MessageList["DetailsDword"] );
			}
		}
		
		[TestCase, Description("GetDetailsQword")]
			class GetDetailsQword : GetDetailsTest
		{
			protected override void Execute()
			{
				this.GetDetails( (uint) MWGlobal.MessageList["DetailsQword"] );
			}
		}

		[TestCase, Description("NegGetNonExistMessageDetails")]
		class NegGetNonExistMsg : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
				WCMessageSummary summary = null;
				WCMessageDetails details = null;


				//WCWebUser user = new WCWebUser();
				//user.GamerTag = MWGlobal.Users[6].GamerTag;		// user 6 should have no messages
				//user.WebID = MWGlobal.Users[6].WebId;


				uint hr = service.GetMessageDetails( 
					MWGlobal.Users[6].WebId,               // User
					MWGlobal.Users[6].GamerTag,
					99999,				// MessageID   
					0,
					0,
					out summary,
					out details );

				if( HResult.Succeeded( hr ) )
				{
					Global.RO.Info("Unexpected pass." + hr );
					return;
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("NegUnknownUser")]
		class NegUnknownUser : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
				WCMessageSummary summary = null;
				WCMessageDetails details = null;


				//WCWebUser user = new WCWebUser();
				//user.GamerTag = RandomEx.GlobalRandGen.GenerateRandomString(15);
				//user.WebID = MWGlobal.Users[1].WebId;

				try 
				{
					uint hr = service.GetMessageDetails( 
						MWGlobal.Users[1].WebId,
						RandomEx.GlobalRandGen.GenerateRandomString(15),               // User
						0,					// MessageID   
						0,
						0,
						out summary,
						out details );

					if( HResult.Succeeded( hr ) )
					{
						Global.RO.Info("Unexpected pass." + hr );
						return;
					}
				}
				catch(SoapException e)
				{
					// this is OK, should get error return from SOAP call
                    string expMsgStart = "Server was unable to process request. ---> (webID,GamerTag)";
					if (! e.Message.StartsWith(expMsgStart) )
					{
						Global.RO.Info("Unexpected soap exception message: " + e.Message + " ... had expected: " + expMsgStart);
                        return;
					}
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("NegUnknownUser")]
		class NegNullUser : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
				WCMessageSummary summary = null;
				WCMessageDetails details = null;


				//WCWebUser user = new WCWebUser();
				//user.GamerTag = null;
				//user.WebID = MWGlobal.Users[1].WebId;

				try
				{
					uint hr = service.GetMessageDetails( 
						null,               // User
						MWGlobal.Users[1].GamerTag,
						0,					// MessageID   
						0,
						0,
						out summary,
						out details );

					Global.RO.Info("HR: " + hr.ToString("X"));
					if( HResult.Succeeded( hr ) )
					{
						Global.RO.Info("Unexpected pass from Null UserID.");
						return;
					}
				}
				catch(SoapException e)
				{
					Global.RO.Info(e.Message);
				}

				// Now try empty string
				//user.GamerTag = "";

				try
				{
					uint hr = service.GetMessageDetails( 
						MWGlobal.Users[1].WebId,
						"",                // User
						0,					// MessageID   
						0,
						0,
						out summary,
						out details );

					Global.RO.Info("HR: " + hr.ToString("X"));
					if( HResult.Succeeded( hr ) )
					{
						Global.RO.Info("Unexpected pass from empty string.");
						return;
					}
				}
				catch(SoapException e)
				{
					// this is OK, should get error return from SOAP call
					Global.RO.Info(e.Message);
				}

				// Try null Web ID
				//user.GamerTag = MWGlobal.Users[1].GamerTag;
				//user.WebID = null;

				try
				{
					uint hr = service.GetMessageDetails( 
						MWGlobal.Users[1].WebId,               // User
						null,
						0,					// MessageID   
						0,
						0,
						out summary,
						out details );

					Global.RO.Info("HR: " + hr.ToString("X"));
					if( HResult.Succeeded( hr ) )
					{
						Global.RO.Info("Unexpected pass from empty string.");
						return;
					}
				}
				catch(SoapException e)
				{
					// this is OK, should get error return from SOAP call
					Global.RO.Info(e.Message);
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("NegMismatchedUser")]
		class NegMismatchedUser : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
				WCMessageSummary summary = null;
				WCMessageDetails details = null;


				//WCWebUser user = new WCWebUser();
				//user.GamerTag = MWGlobal.Users[1].GamerTag;		// user 1 tag, User 0 web ID
				//user.WebID = MWGlobal.Users[0].WebId;
	
				try 
				{
					uint hr = service.GetMessageDetails( 
						MWGlobal.Users[1].WebId,               // User
						MWGlobal.Users[0].GamerTag,
						0,					// MessageID   
						0,
						0,
						out summary,
						out details );

					Global.RO.Info("HR: " + hr.ToString("X"));
					if( HResult.Succeeded( hr ) )
					{
						Global.RO.Info("Unexpected pass." + hr );
						return;
					}
				}
				catch(SoapException e)
				{
					// this is OK, should get error return from SOAP call
                    string expMsgStart = "Server was unable to process request. ---> (webID,GamerTag)";
                    if (!e.Message.StartsWith(expMsgStart))
					{
                        Global.RO.Info("Unexpected soap exception message: " + e.Message + " ... had expected: " + expMsgStart);
                        return;
					}
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}



		[TestCase, Description("SetMessageFlags")]
		class SetMessageFlags : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
				WCMessageSummary summary = null;
				WCMessageDetails details = null;

				//WCWebUser user = new WCWebUser();
				//user.GamerTag = MWGlobal.Users[1].GamerTag;		// user 1 should have BasicMessage
				//user.WebID = MWGlobal.Users[1].WebId;

				uint msgid = 0;
				if ( MWGlobal.MessageList.Contains("BasicMessage") )
					msgid = (uint) MWGlobal.MessageList["BasicMessage"];
				else
					return;

				uint hr = service.GetMessageDetails( 
					MWGlobal.Users[1].WebId,               // User
					MWGlobal.Users[1].GamerTag,
					msgid,					// MessageID   
					WCMessageFlags.Read,		// set
					0,							// unset
					out summary,
					out details );

				if( HResult.Failed( hr ) )
				{
					Global.RO.Info("Failed SetFlags: " + hr.ToString("X") );
					return;
				}

				//verify flag set

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("UnsetMessageFlags")]
		class UnsetMessageFlags : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
				WCMessageSummary summary = null;
				WCMessageDetails details = null;

				//WCWebUser user = new WCWebUser();
				//user.GamerTag = MWGlobal.Users[1].GamerTag;		// user 1 should have BasicMessage
				//user.WebID = MWGlobal.Users[1].WebId;

				uint msgid = 0;
				if ( MWGlobal.MessageList.Contains("BasicMessage") )
					msgid = (uint) MWGlobal.MessageList["BasicMessage"];
				else
					return;

				uint hr = service.GetMessageDetails( 
					MWGlobal.Users[1].WebId,							// User
					MWGlobal.Users[1].GamerTag,
					msgid,							// MessageID   
					0,								// SetFlags
					WCMessageFlags.TitleReserved0, // UnsetFlags
					out summary,
					out details );

				if( HResult.Failed( hr ) )
				{
					Global.RO.Info("Failed UnsetFlags: " + hr.ToString("X") );
					return;
				}

				//Verify flag unset

				ResultCode = TEST_RESULTS.PASSED;
			}
		}
		
		[TestCase, Description("SetAndUnsetMessageFlags")]
		class SetUnsetFlags : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
				WCMessageSummary summary = null;
				WCMessageDetails details = null;

				//WCWebUser user = new WCWebUser();
				//user.GamerTag = MWGlobal.Users[1].GamerTag;
				//user.WebID = MWGlobal.Users[1].WebId;
				
				uint msgid = 0;
				if ( MWGlobal.MessageList.Contains("BasicMessage") )
					msgid = (uint) MWGlobal.MessageList["BasicMessage"];
				else
					return;

				uint hr = service.GetMessageDetails( 
					MWGlobal.Users[1].WebId,							// User
					MWGlobal.Users[1].GamerTag,
					msgid,							// MessageID   
					WCMessageFlags.Read,			// SetFlags
					WCMessageFlags.TitleReserved0,	// UnsetFlags
					out summary,
					out details );

				if( HResult.Failed( hr ) )
				{
					Global.RO.Info("Failed UnsetFlags: " + hr.ToString("X") );
					return;
				}

				// verify flags

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Messaging\Test\FuncGetTitleWideDetails.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using System.IO;
using System.Xml;
using System.Web.Services.Protocols;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.Messaging;
using ServerTestFramework.Web.UserAccount;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;

namespace MessagingWidget
{
	[TestGroup]
	public class FuncGetTitleMessageDetails : TestNode
	{
		//TODO: test dependency on SendMessage
		[TestCase, Description("BasicGetDetails")]
		class BasicGetDetails : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
				WCTitleWideMessageSummary summary = null;
				WCMessageDetails details = null;

				// pull this from Send test
				uint MessageID  = (uint) MWGlobal.MessageList["SysMsgBasic"];

				UInt32 hr = service.GetTitleWideMessageDetails(
					400001,				
					MessageID,
					out summary,
					out details
					);

				if( HResult.Failed( hr ) )
				{
					Global.RO.Info("GetMessageDetails failed, HResult: " + hr );
					return;
				}
				
				if ( summary != null )
				{

					Global.RO.Info( "    Summary:" );
					Global.RO.Info( "        szSenderName - {0}",    summary.SenderName );
					Global.RO.Info( "	    Description - {0}",		summary.Description );
					Global.RO.Info( "        dwTitleID - {0}",		summary.TitleID );
					Global.RO.Info( "        qwSenderContext - {0}", summary.SenderContext );
					Global.RO.Info( "        mtSentTime - {0}",      summary.SentTime );
					Global.RO.Info( "        dwMessageID - {0}",     summary.MessageID );
					Global.RO.Info( "        dwMessageFlags - {0}",  summary.MessageFlags );
					Global.RO.Info( "        bMessageType - {0}",    summary.MessageType );
					Global.RO.Info( "        wExpireMinutes - {0}",  summary.ExpireMinutes );
					Global.RO.Info( "        cbDetails - {0}",       summary.DetailsSize );
				}

				if ( details != null )
				{
					if (details.NullProp != null)
					{
						Global.RO.Info("Nullprop count: " + details.NullProp.Length);
					}

					if (details.ByteProp != null)
						foreach ( WCByteProp byteprop in details.ByteProp )
						{
							Global.RO.Info("ByteProp: " + byteprop.Value );
						}

					if (details.WordProp != null)
						foreach ( WCWordProp wordprop in details.WordProp )
						{
							Global.RO.Info("WordProp: " + wordprop.Value );
						}

					if (details.DwordProp != null)
						foreach ( WCDwordProp dwordprop in details.DwordProp )
						{
							Global.RO.Info("DWordProp: " + dwordprop.Value );
						}

					if (details.QwordProp != null)
						foreach ( WCQwordProp qwordprop in details.QwordProp )
						{
							Global.RO.Info("QWordProp: " + qwordprop.Value );
						}

					if (details.StringProp != null)
						foreach ( WCStringProp stringprop in details.StringProp )
						{
							Global.RO.Info("StringProp: " + stringprop.Value );
						}

					if (details.TimeProp != null)
						foreach ( WCTimeProp timeprop in details.TimeProp )
						{
							Global.RO.Info("TimeProp: " + timeprop.Value );
						}

					if (details.BinaryProp != null)
						foreach ( WCBinaryProp binprop in details.BinaryProp )
						{
							Global.RO.Info("BinaryProp size: " + binprop.Value.Length);
						}

					if (details.AttachmentProp != null)	
						foreach ( WCAttachmentProp attachprop in details.AttachmentProp )
						{
							Global.RO.Info("AttachmentProp: " + attachprop.AttachUrl );
						}

					if (details.BoolProp != null)
						foreach ( WCBoolProp boolprop in details.BoolProp )
						{
							Global.RO.Info("BoolProp: " + boolprop.Value );
						}

					if (details.StringProp != null)
						foreach ( WCStringIdProp stringidprop in details.StringIdProp )
						{
							Global.RO.Info("StringIDProp: " + stringidprop.Value );
						}

				}

		
				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("NegGetUnknownMessage")]
		class NegGetUnknownMessage : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
				WCTitleWideMessageSummary summary = null;
				WCMessageDetails details = null;


				UInt32 hr = service.GetTitleWideMessageDetails(
					400001,				
					9999,				// MessageID   TODO: This should not exist, make sure
					out summary,
					out details
					);

				if( HResult.Succeeded( hr ) )
				{
					Global.RO.Info("Unexpected pass.");
					return;
				}
				
		
				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("NegGetBadTitleID")]
		class NegGetBadTitleID : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
				WCTitleWideMessageSummary summary = null;
				WCMessageDetails details = null;

				try 
				{
					UInt32 hr = service.GetTitleWideMessageDetails(
						1111,										//TitleID does not exist
						9999,				
						out summary,
						out details
						);

					if( HResult.Succeeded( hr ) )
					{
						Global.RO.Info("Unexpected pass.");
						return;
					}
				}
				catch(SoapException e)
				{
					// DebugPartner error message expected
                    string expMsgStart = "Server was unable to process request. ---> Partner:DebugPartner";
                    if (!e.Message.StartsWith(expMsgStart)) 
					{
                        Global.RO.Info("Unexpected soap exception message: " + e.Message + " ... had expected: " + expMsgStart);
						return;
					}
				}
		
				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("Get All Detail Messages")]
		class GetDetailsMsgs : TestBase
		{
			// Enumerate all messages for TitleID we're using for test
			// Then get each message using GetSystemMessageDetails

			protected override void Execute()
			{

				// Default to pass for this test so we don't have to return early to fail
				ResultCode = TEST_RESULTS.PASSED;

				WCMessaging service = new WCMessaging();
				WCTitleWideMessageSummary[] summary = null;

				UInt32 hr = service.EnumTitleWideMessages(
					400001,
					out summary
					);

				if( HResult.Succeeded( hr ) )
				{
					Global.RO.Info("\nEnum returned {0} messages.", summary.Length);

					WCTitleWideMessageSummary newsummary = null;
					WCMessageDetails details = null;

					int failcount = 0;

					foreach(WCTitleWideMessageSummary sum in summary)
					{
						try 
						{
							// Now retrieve the message details and dump them
							hr = service.GetTitleWideMessageDetails(
								400001,
								sum.MessageID,
								out newsummary,
								out details
								);
						}
						catch(SoapException e)
						{
							Global.RO.Info("Failed: " + e.Message);
							failcount++;
						}

						if ( HResult.Failed(hr) )
						{
							ResultCode = TEST_RESULTS.FAILED;
							Global.RO.Info("Failed GetSystemMessageDetails: " + hr.ToString("X"));
							continue;
						}

						if ( details != null )
						{
							#region DumpDetails
							if (details.NullProp != null)
							{
								Global.RO.Info("Nullprop count: " + details.NullProp.Length);
							}

							if (details.ByteProp != null)
								foreach ( WCByteProp byteprop in details.ByteProp )
								{
									Global.RO.Info("ByteProp: " + byteprop.Value );
								}

							if (details.WordProp != null)
								foreach ( WCWordProp wordprop in details.WordProp )
								{
									Global.RO.Info("WordProp: " + wordprop.Value );
								}

							if (details.DwordProp != null)
								foreach ( WCDwordProp dwordprop in details.DwordProp )
								{
									Global.RO.Info("DWordProp: " + dwordprop.Value );
								}

							if (details.QwordProp != null)
								foreach ( WCQwordProp qwordprop in details.QwordProp )
								{
									Global.RO.Info("QWordProp: " + qwordprop.Value );
								}

							if (details.StringProp != null)
								foreach ( WCStringProp stringprop in details.StringProp )
								{
									Global.RO.Info("StringProp: " + stringprop.Value );
								}

							if (details.TimeProp != null)
								foreach ( WCTimeProp timeprop in details.TimeProp )
								{
									Global.RO.Info("TimeProp: " + timeprop.Value );
								}

							if (details.BinaryProp != null)
								foreach ( WCBinaryProp binprop in details.BinaryProp )
								{
									Global.RO.Info("BinaryProp size: " + binprop.Value.Length);
								}

							if (details.AttachmentProp != null)	
								foreach ( WCAttachmentProp attachprop in details.AttachmentProp )
								{
									Global.RO.Info("AttachmentProp: " + attachprop.AttachUrl );
								}

							if (details.BoolProp != null)
								foreach ( WCBoolProp boolprop in details.BoolProp )
								{
									Global.RO.Info("BoolProp: " + boolprop.Value );
								}

							if (details.StringIdProp != null)
								foreach ( WCStringIdProp stringidprop in details.StringIdProp )
								{
									Global.RO.Info("StringIDProp: " + stringidprop.Value );
								}

							#endregion DumpDetails
						}


					}

					if (failcount > 0)
						this.ResultCode = TEST_RESULTS.FAILED;
				}
				else
				{
					Global.RO.Info("Enum failed: " + hr.ToString("X") );
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Messaging\Test\FuncRevokeTitleMessage.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using System.IO;
using System.Xml;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.Messaging;
using ServerTestFramework.Web.UserAccount;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;
using System.Web.Services.Protocols;

namespace MessagingWidget
{
	[TestGroup]
	public class FuncRevokeTitleMessage : TestNode
	{
		[TestCase, Description("ValidRevokeMessage")]
		class ValidRevokeMessage : TestBase
		{
			// 1. verify msg exists
			// 2. revoke msg
			// 3. verify revoke

			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();

				//WCWebUser user = new WCWebUser();
				//user.GamerTag = MWGlobal.Users[5].GamerTag;
				//user.WebID = MWGlobal.Users[5].WebId;

				WCMessageSummary[] summary = null;
				
				UInt32 hr = service.EnumMessages( 
					MWGlobal.Users[5].WebId,       // User
					MWGlobal.Users[5].GamerTag,
					out summary );

				if ( HResult.Failed(hr) )
				{
					Console.WriteLine("Enum failed, hr: " + hr.ToString("X"));
					return;
				}

				// find message ID for revoke
				bool msgFound = false;
				uint revokemsgID;

				if ( MWGlobal.MessageList.Contains("RevokeTitleMsg") )
					revokemsgID = (uint) MWGlobal.MessageList["RevokeTitleMsg"];
				else
				{
					Console.WriteLine("TitleMessage ID to revoke not sent.");
					return;
				}

				foreach (WCMessageSummary sum in summary)
				{
					if ( sum.MessageID == revokemsgID)
						msgFound = true;
				}

				if (!msgFound)
				{
					Console.WriteLine("Message to revoke not found in user queue.");
					return;
				}

				// Now revoke the message

				WCRecipientResult[] revokelist = new WCRecipientResult[1];
				revokelist[0] = new WCRecipientResult();
				revokelist[0].User = MWGlobal.Users[5].GamerTag;
				revokelist[0].MessageID = revokemsgID;

				hr = service.RevokeTitleUserMessage(
					revokelist
					);

				if( HResult.Failed( hr ) )
				{
					Console.WriteLine("Failed to revoke msg, hr: " + hr.ToString("X") );
					return;
				}

				// now verify revoke
				//user.GamerTag = MWGlobal.Users[5].GamerTag;
				//user.WebID = MWGlobal.Users[5].WebId;

				summary = null;
				
				hr = service.EnumMessages( 
					MWGlobal.Users[5].WebId,       // User
					MWGlobal.Users[5].GamerTag,
					out summary );

				if ( HResult.Failed(hr) )
				{
					Console.WriteLine("Enum2 failed, hr: " + hr.ToString("X"));
					return;
				}

				msgFound = false;
				foreach (WCMessageSummary sum in summary)
				{
					if ( sum.MessageID == revokemsgID)
						msgFound = true;
				}

				if ( msgFound )   // uh-oh, the revoke did not work!?
				{
					Console.WriteLine("Msg stille exists in queue.");
					return;
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}
	
		/***
		[TestCase, Description("RevokeUnknownMessage")]
		class RevokeUnknownMessage : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();

				WCWebUser user = new WCWebUser();
				user.GamerTag = MWGlobal.Users[1].GamerTag;
				user.WebID = MWGlobal.Users[1].WebId;

				WCRecipientResult[] revokelist = new WCRecipientResult[1];
				revokelist[0] = new WCRecipientResult();
				revokelist[0].User = MWGlobal.Users[0].GamerTag;
				revokelist[0].MessageID = 9999;						
					// this message should not exist
					// TODO: But there's a better way...

				UInt32 hr = service.RevokeMessage(
					user,
					revokelist
					);

				if( HResult.Succeeded( hr ) )
				{
					// Should return OK whether the message exists or was revoked or not

				}
				else
				{
					Console.WriteLine("Failed, hr: " + hr.ToString("X") );
					return;
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("NegRevokeUnknownGamer")]
		class NegRevokeUnknownGamer : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();

				WCWebUser user = new WCWebUser();
				user.GamerTag = RandomEx.GlobalRandGen.GenerateRandomString(15);
				user.WebID = MWGlobal.Users[0].WebId;				//valid WebID, bad GamerTag

				WCRecipientResult[] revokelist = new WCRecipientResult[1];
				revokelist[0] = new WCRecipientResult();
				revokelist[0].User = MWGlobal.Users[0].GamerTag;
				revokelist[0].MessageID = UInt32.MaxValue;						
				// this message should not exist
				// TODO: But there's a better way...

				try 
				{

					UInt32 hr = service.RevokeMessage(
						user,
						revokelist
						);

					if( HResult.Succeeded( hr ) )
					{
						// FAILED
						Console.WriteLine("Unexpected success.");
						return;
					}
				}
				catch (SoapException e)		// this is normal
				{
					if (! e.Message.EndsWith("not linked in our system") )
					{
						Console.WriteLine(e.Message);
						return;
					}
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("NegRevokeMismatchedUser")]
		class NegRevokeMismatchedUser : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();

				WCWebUser user = new WCWebUser();
				user.GamerTag = MWGlobal.Users[0].GamerTag;			//  User 0 name, User 1 WebID
				user.WebID = MWGlobal.Users[1].WebId;

				WCRecipientResult[] revokelist = new WCRecipientResult[1];
				revokelist[0] = new WCRecipientResult();
				revokelist[0].User = MWGlobal.Users[0].GamerTag;
				revokelist[0].MessageID = UInt32.MaxValue;						
				// this message should not exist
				// TODO: But there's a better way...

				try 
				{

					UInt32 hr = service.RevokeMessage(
						user,
						revokelist
						);

					if( HResult.Succeeded( hr ) )
					{
						// FAILED
						Console.WriteLine("Unexpected success.");
						return;
					}
				}
				catch (SoapException e)		// this is normal
				{
					if (! e.Message.EndsWith("not linked in our system") )
					{
						Console.WriteLine(e.Message);
						return;
					}
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("NegRevokeNullUser")]
		class NegRevokeNullUser : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();

				WCWebUser user = new WCWebUser();
				user.GamerTag = null;
				user.WebID = MWGlobal.Users[1].WebId;

				WCRecipientResult[] revokelist = new WCRecipientResult[1];
				revokelist[0] = new WCRecipientResult();
				revokelist[0].User = MWGlobal.Users[0].GamerTag;
				revokelist[0].MessageID = UInt32.MaxValue;						

				try 
				{
					UInt32 hr = service.RevokeMessage(
						user,
						revokelist
						);

					if( HResult.Succeeded( hr ) )
					{
						// FAILED
						Console.WriteLine("Unexpected success.");

					}
				}
				catch(SoapException e)
				{
					// this is OK, should get error return from SOAP call
					Console.WriteLine(e.Message);
				}
				
				// Check empty string too
				user.GamerTag = "";
				try
				{	
					uint hr = service.RevokeMessage(
						user,
						revokelist
						);

					if( HResult.Succeeded( hr ) )
					{
						// FAILED
						Console.WriteLine("Unexpected success.");
						return;
					}
				}
				catch (SoapException e)		// this is normal
				{
					// success! ?
					Console.WriteLine(e.Message);
				}


				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("NegRevokeTooLongUser")]
		class NegRevokeTooLongUser : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();

				WCWebUser user = new WCWebUser();
				user.GamerTag = "1234567890123456";		// 16 characters long
				user.WebID = MWGlobal.Users[1].WebId;

				WCRecipientResult[] revokelist = new WCRecipientResult[1];
				revokelist[0] = new WCRecipientResult();
				revokelist[0].User = MWGlobal.Users[0].GamerTag;
				revokelist[0].MessageID = UInt32.MaxValue;						

				try 
				{
					UInt32 hr = service.RevokeMessage(
						user,
						revokelist
						);

					if( HResult.Succeeded( hr ) )
					{
						// FAILED
						Console.WriteLine("Unexpected success.");
						return;
					}
				}
				catch (SoapException e)		// this is normal
				{
					if (! e.Message.EndsWith("not linked in our system") )
					{
						Console.WriteLine(e.Message);
						return;
					}
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		***/
		
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Messaging\MOTDTool\wsdl.cs ===
//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.1.4322.573
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=1.1.4322.573.
// 
namespace xonline.server.webcache.messaging.motdtool  
{
    using System.Diagnostics;
    using System.Xml.Serialization;
    using System;
    using System.Web.Services.Protocols;
    using System.ComponentModel;
    using System.Web.Services;
    
    
    /// <remarks/>
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="MessagingSoap", Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class Messaging : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        /// <remarks/>
        public Messaging() {
            this.Url = "https://websvc.xboxlive.com/messaging/messaging.asmx";
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/EnumMessages", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public System.UInt32 EnumMessages([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] UserWebID, string UserGamerTag, [System.Xml.Serialization.XmlElementAttribute("Summary")] out WCMessageSummary[] Summary) {
            object[] results = this.Invoke("EnumMessages", new object[] {
                        UserWebID,
                        UserGamerTag});
            Summary = ((WCMessageSummary[])(results[1]));
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginEnumMessages(System.Byte[] UserWebID, string UserGamerTag, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("EnumMessages", new object[] {
                        UserWebID,
                        UserGamerTag}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.UInt32 EndEnumMessages(System.IAsyncResult asyncResult, out WCMessageSummary[] Summary) {
            object[] results = this.EndInvoke(asyncResult);
            Summary = ((WCMessageSummary[])(results[1]));
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/GetMessageDetails", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public System.UInt32 GetMessageDetails([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] UserWebID, string UserGamerTag, System.UInt32 MessageID, WCMessageFlags SetFlags, WCMessageFlags UnsetFlags, out WCMessageSummary Summary, out WCMessageDetails Details) {
            object[] results = this.Invoke("GetMessageDetails", new object[] {
                        UserWebID,
                        UserGamerTag,
                        MessageID,
                        SetFlags,
                        UnsetFlags});
            Summary = ((WCMessageSummary)(results[1]));
            Details = ((WCMessageDetails)(results[2]));
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetMessageDetails(System.Byte[] UserWebID, string UserGamerTag, System.UInt32 MessageID, WCMessageFlags SetFlags, WCMessageFlags UnsetFlags, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetMessageDetails", new object[] {
                        UserWebID,
                        UserGamerTag,
                        MessageID,
                        SetFlags,
                        UnsetFlags}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.UInt32 EndGetMessageDetails(System.IAsyncResult asyncResult, out WCMessageSummary Summary, out WCMessageDetails Details) {
            object[] results = this.EndInvoke(asyncResult);
            Summary = ((WCMessageSummary)(results[1]));
            Details = ((WCMessageDetails)(results[2]));
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/DeleteMessage", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public System.UInt32 DeleteMessage([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] UserWebID, string UserGamerTag, System.UInt32 MessageID, WCDeleteMsgFlags Flags) {
            object[] results = this.Invoke("DeleteMessage", new object[] {
                        UserWebID,
                        UserGamerTag,
                        MessageID,
                        Flags});
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginDeleteMessage(System.Byte[] UserWebID, string UserGamerTag, System.UInt32 MessageID, WCDeleteMsgFlags Flags, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("DeleteMessage", new object[] {
                        UserWebID,
                        UserGamerTag,
                        MessageID,
                        Flags}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.UInt32 EndDeleteMessage(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/SendMessage", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public System.UInt32 SendMessage([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] SenderWebID, string SenderGamerTag, System.UInt64 SenderContext, WCMessageFlags MessageFlags, System.UInt32 SenderTitleID, System.UInt16 ExpireMinutes, WCMessageType MessageType, [System.Xml.Serialization.XmlElementAttribute("Recipient")] string[] Recipient, WCMessageDetails Details, [System.Xml.Serialization.XmlElementAttribute("Attachment")] WCMessageAttachment[] Attachment, [System.Xml.Serialization.XmlElementAttribute("RecipResult")] out WCRecipientResult[] RecipResult) {
            object[] results = this.Invoke("SendMessage", new object[] {
                        SenderWebID,
                        SenderGamerTag,
                        SenderContext,
                        MessageFlags,
                        SenderTitleID,
                        ExpireMinutes,
                        MessageType,
                        Recipient,
                        Details,
                        Attachment});
            RecipResult = ((WCRecipientResult[])(results[1]));
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSendMessage(System.Byte[] SenderWebID, string SenderGamerTag, System.UInt64 SenderContext, WCMessageFlags MessageFlags, System.UInt32 SenderTitleID, System.UInt16 ExpireMinutes, WCMessageType MessageType, string[] Recipient, WCMessageDetails Details, WCMessageAttachment[] Attachment, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SendMessage", new object[] {
                        SenderWebID,
                        SenderGamerTag,
                        SenderContext,
                        MessageFlags,
                        SenderTitleID,
                        ExpireMinutes,
                        MessageType,
                        Recipient,
                        Details,
                        Attachment}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.UInt32 EndSendMessage(System.IAsyncResult asyncResult, out WCRecipientResult[] RecipResult) {
            object[] results = this.EndInvoke(asyncResult);
            RecipResult = ((WCRecipientResult[])(results[1]));
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/RevokeMessage", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public System.UInt32 RevokeMessage([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] SenderWebID, string SenderGamerTag, [System.Xml.Serialization.XmlElementAttribute("RecipResult")] WCRecipientResult[] RecipResult) {
            object[] results = this.Invoke("RevokeMessage", new object[] {
                        SenderWebID,
                        SenderGamerTag,
                        RecipResult});
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginRevokeMessage(System.Byte[] SenderWebID, string SenderGamerTag, WCRecipientResult[] RecipResult, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("RevokeMessage", new object[] {
                        SenderWebID,
                        SenderGamerTag,
                        RecipResult}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.UInt32 EndRevokeMessage(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/DeleteUserTitle", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public System.UInt32 DeleteUserTitle([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] UserWebID, string UserGamerTag, System.UInt32 TitleID) {
            object[] results = this.Invoke("DeleteUserTitle", new object[] {
                        UserWebID,
                        UserGamerTag,
                        TitleID});
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginDeleteUserTitle(System.Byte[] UserWebID, string UserGamerTag, System.UInt32 TitleID, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("DeleteUserTitle", new object[] {
                        UserWebID,
                        UserGamerTag,
                        TitleID}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.UInt32 EndDeleteUserTitle(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/EnumUserTitles", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public System.UInt32 EnumUserTitles([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] UserWebID, string UserGamerTag, [System.Xml.Serialization.XmlElementAttribute("Title")] out WCUserTitle[] Title) {
            object[] results = this.Invoke("EnumUserTitles", new object[] {
                        UserWebID,
                        UserGamerTag});
            Title = ((WCUserTitle[])(results[1]));
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginEnumUserTitles(System.Byte[] UserWebID, string UserGamerTag, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("EnumUserTitles", new object[] {
                        UserWebID,
                        UserGamerTag}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.UInt32 EndEnumUserTitles(System.IAsyncResult asyncResult, out WCUserTitle[] Title) {
            object[] results = this.EndInvoke(asyncResult);
            Title = ((WCUserTitle[])(results[1]));
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/SetMessageFlags", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public System.UInt32 SetMessageFlags([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] UserWebID, string UserGamerTag, System.UInt32 MessageID, WCMessageFlags SetFlags, WCMessageFlags UnsetFlags) {
            object[] results = this.Invoke("SetMessageFlags", new object[] {
                        UserWebID,
                        UserGamerTag,
                        MessageID,
                        SetFlags,
                        UnsetFlags});
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSetMessageFlags(System.Byte[] UserWebID, string UserGamerTag, System.UInt32 MessageID, WCMessageFlags SetFlags, WCMessageFlags UnsetFlags, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SetMessageFlags", new object[] {
                        UserWebID,
                        UserGamerTag,
                        MessageID,
                        SetFlags,
                        UnsetFlags}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.UInt32 EndSetMessageFlags(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/EnumTitleWideMessages", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public System.UInt32 EnumTitleWideMessages(System.UInt32 TitleID, [System.Xml.Serialization.XmlElementAttribute("Summary")] out WCTitleWideMessageSummary[] Summary) {
            object[] results = this.Invoke("EnumTitleWideMessages", new object[] {
                        TitleID});
            Summary = ((WCTitleWideMessageSummary[])(results[1]));
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginEnumTitleWideMessages(System.UInt32 TitleID, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("EnumTitleWideMessages", new object[] {
                        TitleID}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.UInt32 EndEnumTitleWideMessages(System.IAsyncResult asyncResult, out WCTitleWideMessageSummary[] Summary) {
            object[] results = this.EndInvoke(asyncResult);
            Summary = ((WCTitleWideMessageSummary[])(results[1]));
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/GetTitleWideMessageDetails", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public System.UInt32 GetTitleWideMessageDetails(System.UInt32 TitleID, System.UInt32 MessageID, out WCTitleWideMessageSummary Summary, out WCMessageDetails Details) {
            object[] results = this.Invoke("GetTitleWideMessageDetails", new object[] {
                        TitleID,
                        MessageID});
            Summary = ((WCTitleWideMessageSummary)(results[1]));
            Details = ((WCMessageDetails)(results[2]));
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetTitleWideMessageDetails(System.UInt32 TitleID, System.UInt32 MessageID, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetTitleWideMessageDetails", new object[] {
                        TitleID,
                        MessageID}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.UInt32 EndGetTitleWideMessageDetails(System.IAsyncResult asyncResult, out WCTitleWideMessageSummary Summary, out WCMessageDetails Details) {
            object[] results = this.EndInvoke(asyncResult);
            Summary = ((WCTitleWideMessageSummary)(results[1]));
            Details = ((WCMessageDetails)(results[2]));
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/DeleteTitleWideMessage", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public System.UInt32 DeleteTitleWideMessage(System.UInt32 TitleID, System.UInt32 MessageID, WCDeleteSysMsgFlags Flags) {
            object[] results = this.Invoke("DeleteTitleWideMessage", new object[] {
                        TitleID,
                        MessageID,
                        Flags});
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginDeleteTitleWideMessage(System.UInt32 TitleID, System.UInt32 MessageID, WCDeleteSysMsgFlags Flags, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("DeleteTitleWideMessage", new object[] {
                        TitleID,
                        MessageID,
                        Flags}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.UInt32 EndDeleteTitleWideMessage(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/SendTitleWideMessage", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public System.UInt32 SendTitleWideMessage(string Sender, System.UInt64 SenderContext, System.DateTime SentTime, System.UInt32 Region, WCMessageFlags MessageFlags, System.UInt32 SenderTitleID, System.UInt16 ExpireMinutes, WCMessageType MessageType, string Description, WCMessageDetails Details, [System.Xml.Serialization.XmlElementAttribute("LocalizedString")] WCLocalizedString[] LocalizedString, [System.Xml.Serialization.XmlElementAttribute("Attachment")] WCMessageAttachment[] Attachment, out System.UInt16 Delay, out System.UInt32 MessageID) {
            object[] results = this.Invoke("SendTitleWideMessage", new object[] {
                        Sender,
                        SenderContext,
                        SentTime,
                        Region,
                        MessageFlags,
                        SenderTitleID,
                        ExpireMinutes,
                        MessageType,
                        Description,
                        Details,
                        LocalizedString,
                        Attachment});
            Delay = ((System.UInt16)(results[1]));
            MessageID = ((System.UInt32)(results[2]));
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSendTitleWideMessage(string Sender, System.UInt64 SenderContext, System.DateTime SentTime, System.UInt32 Region, WCMessageFlags MessageFlags, System.UInt32 SenderTitleID, System.UInt16 ExpireMinutes, WCMessageType MessageType, string Description, WCMessageDetails Details, WCLocalizedString[] LocalizedString, WCMessageAttachment[] Attachment, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SendTitleWideMessage", new object[] {
                        Sender,
                        SenderContext,
                        SentTime,
                        Region,
                        MessageFlags,
                        SenderTitleID,
                        ExpireMinutes,
                        MessageType,
                        Description,
                        Details,
                        LocalizedString,
                        Attachment}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.UInt32 EndSendTitleWideMessage(System.IAsyncResult asyncResult, out System.UInt16 Delay, out System.UInt32 MessageID) {
            object[] results = this.EndInvoke(asyncResult);
            Delay = ((System.UInt16)(results[1]));
            MessageID = ((System.UInt32)(results[2]));
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/SendTitleUserMessage", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public System.UInt32 SendTitleUserMessage(string Sender, System.UInt64 SenderContext, WCMessageFlags MessageFlags, System.UInt32 SenderTitleID, System.UInt16 ExpireMinutes, WCMessageType MessageType, [System.Xml.Serialization.XmlElementAttribute("Recipient")] string[] Recipient, WCMessageDetails Details, [System.Xml.Serialization.XmlElementAttribute("Attachment")] WCMessageAttachment[] Attachment, [System.Xml.Serialization.XmlElementAttribute("RecipResult")] out WCRecipientResult[] RecipResult) {
            object[] results = this.Invoke("SendTitleUserMessage", new object[] {
                        Sender,
                        SenderContext,
                        MessageFlags,
                        SenderTitleID,
                        ExpireMinutes,
                        MessageType,
                        Recipient,
                        Details,
                        Attachment});
            RecipResult = ((WCRecipientResult[])(results[1]));
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSendTitleUserMessage(string Sender, System.UInt64 SenderContext, WCMessageFlags MessageFlags, System.UInt32 SenderTitleID, System.UInt16 ExpireMinutes, WCMessageType MessageType, string[] Recipient, WCMessageDetails Details, WCMessageAttachment[] Attachment, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SendTitleUserMessage", new object[] {
                        Sender,
                        SenderContext,
                        MessageFlags,
                        SenderTitleID,
                        ExpireMinutes,
                        MessageType,
                        Recipient,
                        Details,
                        Attachment}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.UInt32 EndSendTitleUserMessage(System.IAsyncResult asyncResult, out WCRecipientResult[] RecipResult) {
            object[] results = this.EndInvoke(asyncResult);
            RecipResult = ((WCRecipientResult[])(results[1]));
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/RevokeTitleUserMessage", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public System.UInt32 RevokeTitleUserMessage([System.Xml.Serialization.XmlElementAttribute("RecipResult")] WCRecipientResult[] RecipResult) {
            object[] results = this.Invoke("RevokeTitleUserMessage", new object[] {
                        RecipResult});
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginRevokeTitleUserMessage(WCRecipientResult[] RecipResult, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("RevokeTitleUserMessage", new object[] {
                        RecipResult}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.UInt32 EndRevokeTitleUserMessage(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/GetMessageString", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("StringData")]
        public string GetMessageString(System.UInt32 TitleID, System.UInt32 StringID, string Locale) {
            object[] results = this.Invoke("GetMessageString", new object[] {
                        TitleID,
                        StringID,
                        Locale});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetMessageString(System.UInt32 TitleID, System.UInt32 StringID, string Locale, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetMessageString", new object[] {
                        TitleID,
                        StringID,
                        Locale}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndGetMessageString(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class WCMessageSummary {
        
        /// <remarks/>
        public string Sender;
        
        /// <remarks/>
        public System.UInt64 SenderContext;
        
        /// <remarks/>
        public System.DateTime SentTime;
        
        /// <remarks/>
        public System.UInt32 MessageID;
        
        /// <remarks/>
        public WCMessageFlags MessageFlags;
        
        /// <remarks/>
        public System.UInt32 SenderTitleID;
        
        /// <remarks/>
        public System.UInt16 ExpireMinutes;
        
        /// <remarks/>
        public System.UInt16 DetailsSize;
        
        /// <remarks/>
        public WCMessageType MessageType;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    [System.FlagsAttribute()]
    public enum WCMessageFlags {
        
        /// <remarks/>
        Required = 1,
        
        /// <remarks/>
        Recommended = 2,
        
        /// <remarks/>
        HasVoice = 4,
        
        /// <remarks/>
        HasText = 8,
        
        /// <remarks/>
        Read = 16,
        
        /// <remarks/>
        NonExportable = 32,
        
        /// <remarks/>
        TeamContext = 64,
        
        /// <remarks/>
        CompContext = 128,
        
        /// <remarks/>
        AlternateTitle = 256,
        
        /// <remarks/>
        Marketing = 512,
        
        /// <remarks/>
        MSReserved0 = 1024,
        
        /// <remarks/>
        MSReserved1 = 2048,
        
        /// <remarks/>
        MSReserved2 = 4096,
        
        /// <remarks/>
        MSReserved3 = 8192,
        
        /// <remarks/>
        MSReserved4 = 16384,
        
        /// <remarks/>
        MSReserved5 = 32768,
        
        /// <remarks/>
        MSReserved6 = 65536,
        
        /// <remarks/>
        MSReserved7 = 131072,
        
        /// <remarks/>
        MSReserved8 = 262144,
        
        /// <remarks/>
        MSReserved9 = 524288,
        
        /// <remarks/>
        MSReserved10 = 1048576,
        
        /// <remarks/>
        MSReserved11 = 2097152,
        
        /// <remarks/>
        MSReserved12 = 4194304,
        
        /// <remarks/>
        MSReserved13 = 8388608,
        
        /// <remarks/>
        TitleReserved0 = 16777216,
        
        /// <remarks/>
        TitleReserved1 = 33554432,
        
        /// <remarks/>
        TitleReserved2 = 67108864,
        
        /// <remarks/>
        TitleReserved3 = 134217728,
        
        /// <remarks/>
        TitleReserved4 = 268435456,
        
        /// <remarks/>
        TitleReserved5 = 536870912,
        
        /// <remarks/>
        TitleReserved6 = 1073741824,
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public enum WCMessageType {
        
        /// <remarks/>
        Invalid,
        
        /// <remarks/>
        TitleCustom,
        
        /// <remarks/>
        FriendRequest,
        
        /// <remarks/>
        GameInvite,
        
        /// <remarks/>
        TeamRecruit,
        
        /// <remarks/>
        CompReminder,
        
        /// <remarks/>
        CompRequest,
        
        /// <remarks/>
        LiveMessage,
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class WCLanguageString {
        
        /// <remarks/>
        public string Locale;
        
        /// <remarks/>
        public string String;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class WCLocalizedString {
        
        /// <remarks/>
        public System.Byte PropID;
        
        /// <remarks/>
        public string DefaultLocale;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("LangString")]
        public WCLanguageString[] LangString;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class WCTitleWideMessageSummary {
        
        /// <remarks/>
        public System.UInt32 TitleID;
        
        /// <remarks/>
        public System.UInt64 SenderContext;
        
        /// <remarks/>
        public System.DateTime SentTime;
        
        /// <remarks/>
        public System.UInt32 Region;
        
        /// <remarks/>
        public System.UInt32 MessageID;
        
        /// <remarks/>
        public WCMessageFlags MessageFlags;
        
        /// <remarks/>
        public System.UInt16 ExpireMinutes;
        
        /// <remarks/>
        public System.UInt16 DetailsSize;
        
        /// <remarks/>
        public WCMessageType MessageType;
        
        /// <remarks/>
        public string SenderName;
        
        /// <remarks/>
        public string Description;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class WCUserTitle {
        
        /// <remarks/>
        public System.UInt32 TitleID;
        
        /// <remarks/>
        public System.DateTime LastLogonTime;
        
        /// <remarks/>
        public WCUserTitleFlags Flags;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    [System.FlagsAttribute()]
    public enum WCUserTitleFlags {
        
        /// <remarks/>
        AcceptMarketing = 1,
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class WCRecipientResult {
        
        /// <remarks/>
        public string User;
        
        /// <remarks/>
        public System.UInt32 MessageID;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class WCMessageAttachment {
        
        /// <remarks/>
        public System.Byte PropID;
        
        /// <remarks/>
        public WCAttachFlags Flags;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
        public System.Byte[] Data;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    [System.FlagsAttribute()]
    public enum WCAttachFlags {
        
        /// <remarks/>
        NonExportable = 1,
        
        /// <remarks/>
        Directory = 2,
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class WCStringIdProp {
        
        /// <remarks/>
        public System.Byte PropID;
        
        /// <remarks/>
        public System.UInt32 Value;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class WCBoolProp {
        
        /// <remarks/>
        public System.Byte PropID;
        
        /// <remarks/>
        public bool Value;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class WCAttachmentProp {
        
        /// <remarks/>
        public System.Byte PropID;
        
        /// <remarks/>
        public System.UInt32 AttachSize;
        
        /// <remarks/>
        public WCAttachFlags AttachFlags;
        
        /// <remarks/>
        public string AttachUrl;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class WCBinaryProp {
        
        /// <remarks/>
        public System.Byte PropID;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
        public System.Byte[] Value;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class WCTimeProp {
        
        /// <remarks/>
        public System.Byte PropID;
        
        /// <remarks/>
        public System.DateTime Value;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class WCStringProp {
        
        /// <remarks/>
        public System.Byte PropID;
        
        /// <remarks/>
        public string Value;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class WCQwordProp {
        
        /// <remarks/>
        public System.Byte PropID;
        
        /// <remarks/>
        public System.UInt64 Value;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class WCDwordProp {
        
        /// <remarks/>
        public System.Byte PropID;
        
        /// <remarks/>
        public System.UInt32 Value;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class WCWordProp {
        
        /// <remarks/>
        public System.Byte PropID;
        
        /// <remarks/>
        public System.UInt16 Value;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class WCByteProp {
        
        /// <remarks/>
        public System.Byte PropID;
        
        /// <remarks/>
        public System.Byte Value;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class WCNullProp {
        
        /// <remarks/>
        public System.Byte PropID;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class WCMessageDetails {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("NullProp")]
        public WCNullProp[] NullProp;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("ByteProp")]
        public WCByteProp[] ByteProp;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("WordProp")]
        public WCWordProp[] WordProp;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("DwordProp")]
        public WCDwordProp[] DwordProp;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("QwordProp")]
        public WCQwordProp[] QwordProp;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("StringProp")]
        public WCStringProp[] StringProp;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("TimeProp")]
        public WCTimeProp[] TimeProp;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("BinaryProp")]
        public WCBinaryProp[] BinaryProp;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("AttachmentProp")]
        public WCAttachmentProp[] AttachmentProp;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("BoolProp")]
        public WCBoolProp[] BoolProp;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("StringIdProp")]
        public WCStringIdProp[] StringIdProp;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    [System.FlagsAttribute()]
    public enum WCDeleteMsgFlags {
        
        /// <remarks/>
        BlockSender = 1,
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    [System.FlagsAttribute()]
    public enum WCDeleteSysMsgFlags {
        
        /// <remarks/>
        RevokeAll = 1,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Messaging\Test\StressMessaging.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using System.IO;
using System.Xml;
using System.Web;
using System.Web.Services;
using System.Web.Services.Protocols;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.Messaging;
using ServerTestFramework.Web.UserAccount;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;

namespace MessagingWidget.Stress
{
    [StressInstantiate]
	public class SendMessage : TestBase
	{
		protected override void Execute()
		{
			WCMessaging service = new WCMessaging();
            
			// send to a random number of recipients -- 1 to 20
			int RecipCount = RandomEx.GlobalRandGen.Next(1, 20);
			string[] recipients = new string[ RecipCount ];
			for (int iRecip = 0; iRecip < RecipCount; iRecip++)
				recipients[ iRecip ] = MWGlobal.StressUsers.GetGamerTag();

			WCMessageDetails smDetails = new WCMessageDetails();
			// Add details for stress?

			WCMessageAttachment[] attachments = new WCMessageAttachment[ 1 ];
			attachments[ 0 ] = new WCMessageAttachment();

			//WCWebUser user = new WCWebUser();
			PuidName PuidUser = MWGlobal.StressUsers.GetPuidName();
			//user.GamerTag = PUIDuser.GamerTag;
			//user.WebID = PUIDuser.WebId;

			WCRecipientResult[] results = null;

			UInt32 hr = service.SendMessage( 
				PuidUser.WebId,						
				PuidUser.GamerTag,					 // User
				0,                             // SenderContext
				WCMessageFlags.TitleReserved0, // MessageFlags
				400001,                        // SenderTitleID
				60,								// Expire Minutes
				WCMessageType.TitleCustom,		// WCMessageType
				recipients,                    // Recipient IDs
				smDetails,                     // Details
				attachments,                   // Attachments
				out results );

			if( HResult.Failed( hr ) )
			{

				return;
			}

			if( recipients.Length != results.Length )
			{
				return;
			}

			ResultCode = TEST_RESULTS.PASSED;
		}
	}

    [StressInstantiate]
	public class GetMessage : TestBase
	{
		protected override void Execute()
		{

			WCMessaging service = new WCMessaging();
			WCMessageSummary[] summary = null;

			//WCWebUser user = new WCWebUser();
			PuidName PuidUser = MWGlobal.StressUsers.GetPuidName();
			//user.GamerTag = PuidUser.GamerTag;
			//user.WebID = PuidUser.WebId;

			UInt32 hr = service.EnumMessages( 
				PuidUser.WebId,
				PuidUser.GamerTag,       // User
				out summary );

			if( HResult.Failed( hr ) )
			{
				//unexpected failure
				return;
			}

			if ( summary.Length > 0 )
			{
				WCMessageSummary newsummary;
				WCMessageDetails details;

				// Pull each message using GetMessage()
				foreach( WCMessageSummary msgsum in summary)
				{

					hr = service.GetMessageDetails( 
						PuidUser.WebId,
						PuidUser.GamerTag,       // User
						msgsum.MessageID,		// MessageID
						WCMessageFlags.Read,	// SetFlags
						0,						// UnSetFlags
						out newsummary,
						out details 
						);

					if ( HResult.Failed(hr) )
					{
						return;
					}
				}

			}

			ResultCode = TEST_RESULTS.PASSED;
		}
	}

    [StressInstantiate]
	class DeleteMessages : TestBase
	{
		protected override void Execute()
		{
	
			WCMessaging service = new WCMessaging();
			WCMessageSummary[] summary = null;

			//WCWebUser user = new WCWebUser();
			PuidName PuidUser = MWGlobal.StressUsers.GetPuidName();
			//user.GamerTag = PuidUser.GamerTag;
			//user.WebID = PuidUser.WebId;

			// First, enumerate the messages we have
			// Then pick one(?) to delete

			UInt32 hr = service.EnumMessages( 
				PuidUser.WebId,
				PuidUser.GamerTag,       // User
				out summary );

			if( HResult.Failed( hr ) )
			{
				//unexpected failure
				return;
			}

			if ( (summary!= null) && (summary.Length > 0) )		// we have some messages, delete them
			{
				for( uint iMsg = 0; iMsg < summary.Length; iMsg++ )
				{
					try
					{

						hr = service.DeleteMessage(
							PuidUser.WebId,					// user info
							PuidUser.GamerTag,
							summary[iMsg].MessageID,		// MessageID
							0								// DeleteFlags    TODO: Add some block sender tests
							);

						if( HResult.Failed( hr ) )
						{
							return;
						}
					}
					catch(Exception e)
					{
						Console.WriteLine(e.Message);
						return;
					}
				}
			}

			ResultCode = TEST_RESULTS.PASSED;
		}
	}

    [StressInstantiate]
	class RevokeMessages : TestBase
	{
		protected override void Execute()
		{
	
			WCMessaging service = new WCMessaging();
			WCMessageSummary[] summary = null;

			//WCWebUser user = new WCWebUser();
			PuidName PuidUser = MWGlobal.StressUsers.GetPuidName();
			//user.GamerTag = PuidUser.GamerTag;
			//user.WebID = PuidUser.WebId;

			// First, enumerate the messages we have
			// Then pick one(?) to revoke

			UInt32 hr = service.EnumMessages( 
				PuidUser.WebId,
				PuidUser.GamerTag,       // User
				out summary );

			if( HResult.Failed( hr ) )
			{
				//unexpected failure
				return;
			}

			if ( summary.Length > 0 )		// we have some messages, revoke the first one
			{
				// First, find PUID for sender
				// = MWGlobal.StressUsers.GetPuidName();
				// TODO:   fix this... 

				WCRecipientResult[] revoke = new WCRecipientResult[1];
				revoke[0] = new WCRecipientResult();
				revoke[0].MessageID = summary[0].MessageID;
				revoke[0].User = summary[0].Sender;

				hr = service.RevokeMessage(
					PuidUser.WebId,
					PuidUser.GamerTag,       // User
					revoke );

				if( HResult.Failed( hr ) )
				{
					return;
				}

			}

			ResultCode = TEST_RESULTS.PASSED;
		}
	}

	[TestCase, Description("Stress SendSystemMessage")]
    [StressInstantiate]
	class SendTitleWideMessage : TestBase
	{
		protected override void Execute()
		{
			WCMessaging service = new WCMessaging();
             
			WCMessageDetails smDetails = new WCMessageDetails();
			// TODO: Add some details

			uint MessageID = 0;
			ushort delay = 0;

			// TODO: Add a stress case with lots of details

			UInt32 hr = service.SendTitleWideMessage(
				"StressTestCase",
				0,								
				System.DateTime.UtcNow,
				0,
				WCMessageFlags.TitleReserved1,	// MessageFlags
				400001,							// Sender TitleID
				60,
				WCMessageType.TitleCustom,
				"Some stress Message",
				smDetails,
				null,
				null,
				out delay,
				out MessageID
				);

			if( HResult.Failed( hr ) )
			{
				return;
			}

			ResultCode = TEST_RESULTS.PASSED;
		}
	}

	[TestCase, Description("Stress SendTitleUserMessage")]
    [StressInstantiate]
	class SendTitleUserMessage : TestBase
	{
		protected override void Execute()
		{
			WCMessaging service = new WCMessaging();
			WCMessageDetails smDetails = new WCMessageDetails();
			WCRecipientResult[] results = null;

			string[] recipients = new string[1];
			recipients[0] = MWGlobal.StressUsers.GetGamerTag();

			// TODO: Add a stress case with lots of details

			UInt32 hr = service.SendTitleUserMessage(
				"StressTestCase",
				0,
				WCMessageFlags.TitleReserved1,	// MessageFlags
				400001,							// Sender TitleID
				60,
				WCMessageType.TitleCustom,
				recipients,
				smDetails,
				null,
				out results
				);

			if( HResult.Failed( hr ) )
			{
				return;
			}

			MWGlobal.RevokeList.Enqueue( new MessageInfo(results[0].MessageID, results[0].User, null, null) );

			ResultCode = TEST_RESULTS.PASSED;
		}
	}

	[TestCase, Description("Stress RevokeTitleUserMessage")]
    [StressInstantiate]
	class RevokeTitleUserMessage : TestBase
	{
		protected override void Execute()
		{
	
			WCMessaging service = new WCMessaging();
			MessageInfo msg = null;

			WCRecipientResult[] revoke = new WCRecipientResult[1];
			revoke[0] = new WCRecipientResult();

			// Output revoke queue count so we can tweak the thread priorities
			Console.WriteLine("Revoke Queue: " + MWGlobal.RevokeList.Count);

			if (MWGlobal.RevokeList.Count > 0)  // if we have a message to revoke
			{
				msg = (MessageInfo) MWGlobal.RevokeList.Dequeue();
				revoke[0].MessageID = msg.MessageID;
				revoke[0].User = msg.ReceiverName;

				uint hr = service.RevokeTitleUserMessage( revoke );

				if( HResult.Failed( hr ) )
				{
					return;
				}
			}


			ResultCode = TEST_RESULTS.PASSED;
		}
	}


	// Enum system messages, then GetSystemMessageDetails for each one
    [StressInstantiate]
	class GetTitleWideMessage : TestBase
	{
		protected override void Execute()
		{
			WCMessaging service = new WCMessaging();
			WCTitleWideMessageSummary[] summary = null;

			UInt32 hr = service.EnumTitleWideMessages(
				400001,
				out summary
				);

			if( HResult.Succeeded( hr ) )
			{
				for( int iMessage = 0; iMessage < summary.Length; iMessage++ )
				{
					WCTitleWideMessageSummary newsummary = null;
					WCMessageDetails details = null;

					try 
					{
						hr = service.GetTitleWideMessageDetails(
							400001,								// TitleID
							summary[iMessage].MessageID,		// MessageID   
							out newsummary,
							out details
							);

						if( HResult.Failed( hr ) )
						{
							if (hr == HResult.XONLINE_E_MESSAGE_INVALID_MESSAGE_ID)		// this is OK
								continue;
							else
								return;
						}
					}
					catch(SoapException e)
					{
						if (! e.Message.EndsWith("end of the stream.") )
						{
							throw e;	// "Unable to read" message is OK, throw everything else back up
						}
					}
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}
	}

    [StressInstantiate]
	class DeleteTitleWideMessage : TestBase
	{
		protected override void Execute()
		{
			WCMessaging service = new WCMessaging();
			WCTitleWideMessageSummary[] summary = null;

			UInt32 hr = service.EnumTitleWideMessages(
				400001,
				out summary
				);

			if( HResult.Succeeded( hr ) )
			{
				if ( summary.Length > 0 )
				{
					for( int iMessage = 0; iMessage < summary.Length; iMessage++ )
					{
						hr = service.DeleteTitleWideMessage(
							400001,							// TitleID
							summary[iMessage].MessageID,	// MessageID
							0								// WCDeleteSysMsgFlags
							//WCDeleteSysMsgFlags.RevokeAll
							);

						if( HResult.Failed( hr ) )
						{
							if (hr == HResult.XONLINE_E_MESSAGE_INVALID_MESSAGE_ID)		// this is OK
								continue;
							else
								return;
						}
					}
				}

				ResultCode = TEST_RESULTS.PASSED;
			}

		}
	}

    [StressInstantiate]
	class SetMessageFlags : TestBase
	{
		protected override void Execute()
		{
	
			WCMessaging service = new WCMessaging();
			WCMessageSummary[] summary = null;

			//WCWebUser user = new WCWebUser();
			PuidName PuidUser = MWGlobal.StressUsers.GetPuidName();
			//user.GamerTag = PuidUser.GamerTag;
			//user.WebID = PuidUser.WebId;

			// First, enumerate the messages we have
			// Then pick one(?) to set / unset

			UInt32 hr = service.EnumMessages( 
				PuidUser.WebId,
				PuidUser.GamerTag,       // User
				out summary );

			if( HResult.Failed( hr ) )
			{
				//unexpected failure
				return;
			}

			if ( summary.Length > 0 )				// we have a message
			{
				WCMessageFlags setFlags = new WCMessageFlags();
				WCMessageFlags unsetFlags = new WCMessageFlags();

				if( (RandomEx.GlobalRandGen.Next() % 2) == 0 )		// TODO: fix this... check for flags or randomize setting/unsetting?
				{
					// set flags
					hr = service.SetMessageFlags(
						PuidUser.WebId,
						PuidUser.GamerTag,       // User
						summary[0].MessageID, 
						setFlags, 
						0 
						);
				}
				else
				{
					// unset flags
					hr = service.SetMessageFlags(
						PuidUser.WebId,
						PuidUser.GamerTag,       // User
						summary[0].MessageID, 
						0, 
						unsetFlags);
				}

				if( HResult.Failed( hr ) )
				{
					return;
				}

			}

			ResultCode = TEST_RESULTS.PASSED;
		}
	}

    [StressInstantiate]
	class EnumAndDeleteUserTitles : TestBase
	{
		protected override void Execute()
		{
	
			WCMessaging service = new WCMessaging();

			//WCWebUser user = new WCWebUser();
			PuidName PuidUser = MWGlobal.StressUsers.GetPuidName();
			//user.GamerTag = PuidUser.GamerTag;
			//user.WebID = PuidUser.WebId;

			WCUserTitle[] titles = null;

			UInt32 hr = service.EnumUserTitles(
				PuidUser.WebId,
				PuidUser.GamerTag,       // User
				out titles
				);

			if( HResult.Failed( hr ) )
			{
				//unexpected failure
				return;
			}

			// TODO:  Use FC.Logon (?) to add titles for each user or pre-populate
			if ( titles.Length > 0 )    // we have some titles, let's delete a few
			{
				hr = service.DeleteUserTitle(
					PuidUser.WebId,
					PuidUser.GamerTag,       // User
					titles[0].TitleID
					);
				
				if( HResult.Failed( hr ) )
				{
					//unexpected failure
					return;
				}
			}


			ResultCode = TEST_RESULTS.PASSED;
		}
	}

    [StressInstantiate]
	class GetMessageString : TestBase
	{
		protected override void Execute()
		{
			WCMessaging service = new WCMessaging();

			string ResponseStr = service.GetMessageString(
				400001,				// TitleID
				2147483653,			// StringID
				//WCLanguage.English	// LangID
				"en-US"
				);
			// TODO: Add new locale string tests

			if ( ResponseStr == null)
				return;
				//Console.WriteLine("Got string: " + ResponseStr);

			ResultCode = TEST_RESULTS.PASSED;
		}
	}


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Messaging\Test\FuncSendTitleWideMessage.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using System.IO;
using System.Xml;
using System.Web.Services.Protocols;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.Messaging;
using ServerTestFramework.Web.UserAccount;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;

namespace MessagingWidget
{
	[TestGroup]
	public class FuncSendTitleWideMessage : TestNode
	{
		[TestCase, Description("BasicSendSystemMessage")]
		class BasicSendTitleMessage : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				WCMessageDetails smDetails = new WCMessageDetails();
				// TODO: Add some details

				WCLocalizedString[] strings = new WCLocalizedString[ 1 ];
				strings[ 0 ] = new WCLocalizedString();
				// TODO: Add some strings

				WCMessageAttachment[] attachments = new WCMessageAttachment[ 1 ];
				attachments[ 0 ] = new WCMessageAttachment();
				// TODO: Add some attachments

				uint MessageID = 0;
				ushort delay = 0;

				UInt32 hr = service.SendTitleWideMessage(
					"TestCase",
					0,								
					System.DateTime.UtcNow,
					0,
					WCMessageFlags.TitleReserved1,	// MessageFlags
					400001,							// Sender TitleID
					60,
					WCMessageType.TitleCustom,
					"Some TEST Message",
					smDetails,
					null,
					null,
					out delay,
					out MessageID
					);

				if( HResult.Failed( hr ) )
				{
					Global.RO.Info("Failed SendSystemMessage, HResult: " + hr);
					return;
				}

				MWGlobal.MessageList.Add("SysMsgBasic", MessageID);

				ConsoleX.WriteLine("Created system messageID: " + MessageID);

				ResultCode = TEST_RESULTS.PASSED;
			}
		}


		[TestCase, Description("Send TitleWide With String")]
		class SendTitleString : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				WCMessageDetails smDetails = new WCMessageDetails();
				// TODO: Add some details

				WCLocalizedString[] strings = new WCLocalizedString[ 1 ];
				strings[0] = new WCLocalizedString();
				//strings[0].DefaultLanguage = WCLanguage.English;
				strings[0].DefaultLocale = "en-US";
				strings[0].PropID = 0x01;
				strings[0].LangString = new WCLanguageString[2];
				strings[0].LangString[0] = new WCLanguageString();
				//strings[0].LangString[0].Language = WCLanguage.English;
				strings[0].LangString[0].Locale = "en-US";
				strings[0].LangString[0].String = "This is an English string that should push to the string server.";
				strings[0].LangString[1] = new WCLanguageString();
				//strings[0].LangString[1].Language = WCLanguage.French;
				strings[0].LangString[1].Locale = "fr-FR";
				strings[0].LangString[1].String = "Ici les mots francais.  Vraiment, je suis tout ce qui est homme.";

				WCMessageAttachment[] attachments = new WCMessageAttachment[ 1 ];
				attachments[ 0 ] = new WCMessageAttachment();
				// TODO: Add some attachments

				uint MessageID = 0;
				ushort delay = 0;

				UInt32 hr = service.SendTitleWideMessage(
					"TestCase",
					0,								
					System.DateTime.UtcNow,
					0,
					WCMessageFlags.TitleReserved1,	// MessageFlags
					400001,							// Sender TitleID
					60,
					WCMessageType.TitleCustom,
					"Some TEST Message",
					smDetails,
					strings,
					attachments,
					out delay,
					out MessageID
					);

				if( HResult.Failed( hr ) )
				{
					Global.RO.Info("Failed SendSystemMessage, HResult: " + hr);
					return;
				}

				MWGlobal.MessageList.Add("SysMsgWithString", MessageID);

				ConsoleX.WriteLine("Created system messageID: " + MessageID);

				ResultCode = TEST_RESULTS.PASSED;
			}
		}


		//TODO : Add DebugPartner for access?
		[TestCase, Description("SendSystemWideMessage")]
		class SendSystemWideMessage : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				WCMessageDetails smDetails = new WCMessageDetails();
				// TODO: Add some details

				WCLocalizedString[] strings = new WCLocalizedString[ 1 ];
				strings[ 0 ] = new WCLocalizedString();
				// TODO: Add some strings

				WCMessageAttachment[] attachments = new WCMessageAttachment[ 1 ];
				attachments[ 0 ] = new WCMessageAttachment();
				// TODO: Add some attachments

				uint MessageID = 0;
				ushort delay = 0;

				UInt32 hr = service.SendTitleWideMessage(
					"TestCase",
					0,								
					System.DateTime.UtcNow,
					0,
					WCMessageFlags.TitleReserved1,	// MessageFlags
					0,								// Sender TitleID 0 == System-Wide message
					60,
					WCMessageType.TitleCustom,
					"TEST System-wide Message",
					smDetails,
					strings,
					attachments,
					out delay,
					out MessageID
					);

				if( HResult.Failed( hr ) )
				{
					Global.RO.Info("Failed SendSystemMessage, HResult: " + hr);
					return;
				}

                Global.RO.Info("Created system messageID: " + MessageID);

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("SendExpiredMessage")]
		class SendExpiredMessage : TestBase
		{
			protected override void Execute()
			{

				WCMessaging service = new WCMessaging();
             
				uint MessageID = 0;
				ushort delay = 0;

				UInt32 hr = service.SendTitleWideMessage(
					"TestExpire",					
					0,								
					System.DateTime.UtcNow.AddDays(-10),	// set time sent to past (verify this works)
					0,
					WCMessageFlags.TitleReserved1,	// MessageFlags
					400001,							// Sender TitleID
					60,								// message should expire already
					WCMessageType.TitleCustom,
					"Some TEST Message",
					null,
					null,
					null,
					out delay,
					out MessageID
					);

				if( HResult.Failed( hr ) )
				{
					Global.RO.Info("Failed SendSystemMessage, HResult: " + hr);
					return;
				}

				ConsoleX.WriteLine("Created system messageID: " + MessageID);

				ResultCode = TEST_RESULTS.PASSED;
			}
		}


		[TestCase, Description("Neg Send Unknown TitleID message")]
		class NegSendUnknownTitleID : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
         
				WCMessageDetails smDetails = new WCMessageDetails();
				// TODO: Add some details

				WCLocalizedString[] strings = new WCLocalizedString[ 1 ];
				strings[ 0 ] = new WCLocalizedString();
				// TODO: Add some strings

				WCMessageAttachment[] attachments = new WCMessageAttachment[ 1 ];
				attachments[ 0 ] = new WCMessageAttachment();
				// TODO: Add some attachments

				uint MessageID = 0;
				ushort delay = 0;

				try 
				{
					UInt32 hr = service.SendTitleWideMessage(
						"TestCase",
						0,								
						System.DateTime.UtcNow,
						0,
						WCMessageFlags.TitleReserved1,	// MessageFlags
						1111,							// Sender TitleID
						60,
						WCMessageType.TitleCustom,
						"Some Message",
						smDetails,
						strings,
						attachments,
						out delay,
						out MessageID
						);

					if( HResult.Succeeded( hr ) )
					{
						Global.RO.Info("Unexpected success.");
						return;
					}
				}
				catch(SoapException e)
				{
					// DebugPartner error message expected
                    string expMsgStart = "Server was unable to process request. ---> Partner:DebugPartner";
                    if (!e.Message.StartsWith(expMsgStart)) 
					{
                        Global.RO.Info("Unexpected soap exception message: " + e.Message + " ... had expected: " + expMsgStart);
						return;
					}
				}

				// Verify error code

				ResultCode = TEST_RESULTS.PASSED;
			}
		}
	

		//helper function
		static public bool SendDetails(WCMessageDetails details, string msgname)
		{
			WCMessaging service = new WCMessaging();

			uint result = 0;
			ushort delay = 0;

			UInt32 hr = service.SendTitleWideMessage( 
				"TestCase",                    // Sender name
				0,                             // SenderContext
				System.DateTime.UtcNow,			// Send Time
				1,								// Region
				WCMessageFlags.TitleReserved0, // MessageFlags
				400001,                       // TitleID
				60,                            // ExpireMinutes
				WCMessageType.TitleCustom,     // MessageType
				"Details test message",
				details,                     // Details
				null,                       // Strings
				null,                   // Attachments
				out delay,
				out result );

			if( HResult.Failed( hr ) )
			{
				Global.RO.Info("Failed SendMessage, HResult: " + hr.ToString("X"));
				return false;
			}

			// Add this MessageID to MessageList so we can pull it for other tests
			MWGlobal.MessageList.Add(msgname, result);
			ConsoleX.WriteLine("Created messageID: " + result);

			return true;
		}

		[TestCase, Description("Send Detail Null")]
		class SendDetailNull: TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				WCMessageDetails smDetails = new WCMessageDetails();

				smDetails.NullProp = new WCNullProp[1];
				smDetails.NullProp[0] = new WCNullProp();
				smDetails.NullProp[0].PropID = 0x01;
	
				if(! SendDetails(smDetails, "SysMsgNull") )
					return;

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("Send Detail Byte")]
			class SendDetailByte: TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				WCMessageDetails smDetails = new WCMessageDetails();

				smDetails.ByteProp = new WCByteProp[1];
				smDetails.ByteProp[0] = new WCByteProp();
				smDetails.ByteProp[0].PropID = 0x02;
				smDetails.ByteProp[0].Value = 0xFF;

				if(! SendDetails(smDetails, "SysMsgByte") )
					return;

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("Send Detail Word")]
		class SendDetailWord: TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				WCMessageDetails smDetails = new WCMessageDetails();

				smDetails.WordProp = new WCWordProp[1];
				smDetails.WordProp[0] = new WCWordProp();
				smDetails.WordProp[0].PropID = 0x03;
				smDetails.WordProp[0].Value = 0xFFFF;

				if(! SendDetails(smDetails, "SysMsgWord") )
					return;

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("Send Detail Dword")]
		class SendDetailDword: TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				WCMessageDetails smDetails = new WCMessageDetails();

				smDetails.DwordProp = new WCDwordProp[1];
				smDetails.DwordProp[0] = new WCDwordProp();
				smDetails.DwordProp[0].PropID = 0x04;
				smDetails.DwordProp[0].Value = 0xFFFFFFFF;

				if(! SendDetails(smDetails, "SysMsgDword") )
					return;

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("Send Detail Qword")]
			class SendDetailQword: TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				WCMessageDetails smDetails = new WCMessageDetails();

				smDetails.QwordProp = new WCQwordProp[1];
				smDetails.QwordProp[0] = new WCQwordProp();
				smDetails.QwordProp[0].PropID = 0x05;
				smDetails.QwordProp[0].Value = 0xFFFFFFFF;

				if(! SendDetails(smDetails, "SysMsgQword") )
					return;

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("Send Detail String")]
		class SendDetailString: TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				WCMessageDetails smDetails = new WCMessageDetails();

				smDetails.StringProp = new WCStringProp[1];
				smDetails.StringProp[0] = new WCStringProp();
				smDetails.StringProp[0].PropID = 0x06;
				smDetails.StringProp[0].Value = "THIS IS A TEST STRING!!!!";


				if(! SendDetails(smDetails, "SysMsgString") )
					return;

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("Send Detail FileTime")]
			class SendDetailFileTime: TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				WCMessageDetails smDetails = new WCMessageDetails();

				smDetails.TimeProp = new WCTimeProp[1];
				smDetails.TimeProp[0] = new WCTimeProp();
				smDetails.TimeProp[0].PropID = 0x07;
				smDetails.TimeProp[0].Value = System.DateTime.UtcNow.AddDays(100);

				if(! SendDetails(smDetails, "SysMsgTime") )
					return;

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("Send Detail Binary")]
			class SendDetailBinary: TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				WCMessageDetails smDetails = new WCMessageDetails();

				byte[] tempbin = { 0x01, 0x02 };

				smDetails.BinaryProp = new WCBinaryProp[1];
				smDetails.BinaryProp[0] = new WCBinaryProp();
				smDetails.BinaryProp[0].PropID = 0x08;
				smDetails.BinaryProp[0].Value = tempbin;

				if(! SendDetails(smDetails, "SysMsgBinary") )
					return;

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("Send Detail Attachment")]
		class SendDetailAttachment: TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				WCMessageDetails smDetails = new WCMessageDetails();

				smDetails.AttachmentProp = new WCAttachmentProp[1];
				smDetails.AttachmentProp[0] = new WCAttachmentProp();
				smDetails.AttachmentProp[0].PropID = 0x09;
				smDetails.AttachmentProp[0].AttachFlags = 0;
				smDetails.AttachmentProp[0].AttachSize = 0;
				smDetails.AttachmentProp[0].AttachUrl = "http://someurl.com/yah";

				if(! SendDetails(smDetails, "SysMsgAttachment") )
					return;

				ResultCode = TEST_RESULTS.PASSED;
			}
		}


		[TestCase, Description("Send Detail Bool")]
		class SendDetailBool: TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				WCMessageDetails smDetails = new WCMessageDetails();

				smDetails.BoolProp = new WCBoolProp[1];
				smDetails.BoolProp[0] = new WCBoolProp();
				smDetails.BoolProp[0].PropID = 0x0A;
				smDetails.BoolProp[0].Value = true;


				if(! SendDetails(smDetails, "SysMsgBool") )
					return;

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("Send Detail StringID")]
			class SendDetailStringID: TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				WCMessageDetails smDetails = new WCMessageDetails();

				smDetails.StringIdProp = new WCStringIdProp[1];
				smDetails.StringIdProp[0] = new WCStringIdProp();
				smDetails.StringIdProp[0].PropID = 0x0B;
				smDetails.StringIdProp[0].Value = 1111;


				if(! SendDetails(smDetails, "SysMsgStringId") )
					return;

				ResultCode = TEST_RESULTS.PASSED;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Messaging\Test\FuncSetMessageFlags.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using System.IO;
using System.Xml;
using System.Web.Services.Protocols;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.Messaging;
using ServerTestFramework.Web.UserAccount;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;

namespace MessagingWidget
{
	[TestGroup]
	public class FuncSetMessageFlags : TestNode
	{
		//TODO: requires pre-populated data in xprof tables
		[TestCase, Description("ValidSetFlags")]
		class ValidSetFlags : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();

				//WCWebUser user = new WCWebUser();
				//user.GamerTag = MWGlobal.Users[1].GamerTag;
				//user.WebID = MWGlobal.Users[1].WebId;
				
				uint msgid = 0;
				if ( MWGlobal.MessageList.Contains("BasicMessage") )		//TODO: Use seperate message/user?
					msgid = (uint) MWGlobal.MessageList["BasicMessage"];
				else
					return;
			
				UInt32 hr = service.SetMessageFlags(
					MWGlobal.Users[1].WebId,
					MWGlobal.Users[1].GamerTag,
					msgid,
					WCMessageFlags.Read | WCMessageFlags.TitleReserved0,
					0
					);

				if( HResult.Succeeded( hr ) )
				{
					WCMessageSummary summary = new WCMessageSummary();
					WCMessageDetails details = new WCMessageDetails();

					hr = service.GetMessageDetails(MWGlobal.Users[1].WebId, MWGlobal.Users[1].GamerTag, msgid, 0, 0, out summary, out details);
					if( HResult.Succeeded(hr))
					{
						Console.WriteLine("FLAGS: " + summary.MessageFlags );
					}
					else
					{
						Console.WriteLine("GetDetails failed: " + hr.ToString("X") );
					}
				}
				else
				{
					return;
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("ValidClearFlag")]
		class ValidClearFlags : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();

				//WCWebUser user = new WCWebUser();
				//user.GamerTag = MWGlobal.Users[1].GamerTag;
				//user.WebID = MWGlobal.Users[1].WebId;
				
				uint msgid = 0;
				if ( MWGlobal.MessageList.Contains("BasicMessage") )		//TODO: Use seperate message/user?
					msgid = (uint) MWGlobal.MessageList["BasicMessage"];
				else
					return;
			
				UInt32 hr = service.SetMessageFlags(
					MWGlobal.Users[1].WebId,
					MWGlobal.Users[1].GamerTag,
					msgid,
					0,
					WCMessageFlags.TitleReserved0			//  ONLY TitleReserved flags can be cleared
					);

				if( HResult.Succeeded( hr ) )
				{
					WCMessageSummary summary = new WCMessageSummary();
					WCMessageDetails details = new WCMessageDetails();

					hr = service.GetMessageDetails(
						MWGlobal.Users[1].WebId,
						MWGlobal.Users[1].GamerTag,
						msgid, 
						0, 
						0, 
						out summary, 
						out details
						);

					if( HResult.Succeeded(hr))
					{
						Console.WriteLine("FLAGS: " + summary.MessageFlags );
					}
					else
					{
						Console.WriteLine("GetDetails failed: " + hr.ToString("X") );
					}
				}
				else
				{
					return;
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}


		[TestCase, Description("NegUnsetFlag")]
		class NegUnsetFlag : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();

				//WCWebUser user = new WCWebUser();
				//user.GamerTag = MWGlobal.Users[1].GamerTag;
				//user.WebID = MWGlobal.Users[1].WebId;
				
				uint msgid = 0;
				if ( MWGlobal.MessageList.Contains("BasicMessage") )		//TODO: Use seperate message/user?
					msgid = (uint) MWGlobal.MessageList["BasicMessage"];
				else
					return;
			
				// we are not allowed to clear the Read flag, only set it

				UInt32 hr = service.SetMessageFlags(
					MWGlobal.Users[1].WebId,
					MWGlobal.Users[1].GamerTag,
					msgid,
					0,
					WCMessageFlags.Read									
					);

				if( HResult.Succeeded( hr ) )
				{
					Console.WriteLine("Unexpectd pass.");
					return;
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("NegSetInvalidFlag")]
		class NegSetInvalidFlag : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();

				//WCWebUser user = new WCWebUser();
				//user.GamerTag = MWGlobal.Users[1].GamerTag;
				//user.WebID = MWGlobal.Users[1].WebId;
				
				uint msgid = 0;
				if ( MWGlobal.MessageList.Contains("BasicMessage") )		//TODO: Use seperate message/user?
					msgid = (uint) MWGlobal.MessageList["BasicMessage"];
				else
					return;
			
				UInt32 hr = service.SetMessageFlags(
					MWGlobal.Users[1].WebId,
					MWGlobal.Users[1].GamerTag,
					msgid,
					WCMessageFlags.Recommended,			// illegal after message sent
					0
					);

				if( HResult.Succeeded( hr ) )
				{
					Console.WriteLine("Unexpected success!");
					return;
				}

				// now try MSReserved flag
				hr = service.SetMessageFlags(
					MWGlobal.Users[1].WebId,
					MWGlobal.Users[1].GamerTag,
					msgid,
					WCMessageFlags.MSReserved10,			// illegal any time
					0
					);

				if( HResult.Succeeded( hr ) )
				{
					Console.WriteLine("Unexpected success!");
					return;
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("NegNullGamer")]
		class NegNullGamer : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();

				//WCWebUser user = new WCWebUser();
				//user.GamerTag = null;
				//user.WebID = MWGlobal.Users[1].WebId;
				
				uint msgid = 0;
				if ( MWGlobal.MessageList.Contains("BasicMessage") )		//TODO: Use seperate message/user?
					msgid = (uint) MWGlobal.MessageList["BasicMessage"];
				else
					return;
			
				try 
				{
					UInt32 hr = service.SetMessageFlags(
						null,
						MWGlobal.Users[1].GamerTag,
						msgid,
						WCMessageFlags.Recommended,			// illegal after message sent
						0
						);

					if( HResult.Succeeded( hr ) )
					{
						Console.WriteLine("Unexpected success!");
						return;
					}
				}
				catch(SoapException e)
				{
					Console.WriteLine(e.Message);
				}


				// try null WebID
				//user.GamerTag = MWGlobal.Users[1].GamerTag;
				//user.WebID = null;
	
				try 
				{
					UInt32 hr = service.SetMessageFlags(
						MWGlobal.Users[1].WebId,
						null,
						msgid,
						WCMessageFlags.Recommended,			// illegal after message sent
						0
						);

					if( HResult.Succeeded( hr ) )
					{
						Console.WriteLine("Unexpected success!");
						return;
					}
				}
				catch(SoapException e)
				{
					Console.WriteLine(e.Message);
				}


				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("NegUnknownGamer")]
		class NegUnknownGamer : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();

				//WCWebUser user = new WCWebUser();
				//user.GamerTag = RandomEx.GlobalRandGen.GenerateRandomString(15);
				//user.WebID = MWGlobal.Users[1].WebId;
				
				uint msgid = 0;
				if ( MWGlobal.MessageList.Contains("BasicMessage") )		//TODO: Use seperate message/user?
					msgid = (uint) MWGlobal.MessageList["BasicMessage"];
				else
					return;
			
				try 
				{
					UInt32 hr = service.SetMessageFlags(
						MWGlobal.Users[1].WebId,
						RandomEx.GlobalRandGen.GenerateRandomString(15),
						msgid,
						WCMessageFlags.Recommended,			// illegal after message sent
						0
						);

					if( HResult.Succeeded( hr ) )
					{
						Console.WriteLine("Unexpected success!");
						return;
					}
				}
				catch(SoapException e)
				{
					Console.WriteLine(e.Message);
				}


				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("NegMismatchedGamer")]
		class NegMismatchedGamer : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();

				//WCWebUser user = new WCWebUser();
				//user.GamerTag = MWGlobal.Users[0].GamerTag;
				//user.WebID = MWGlobal.Users[1].WebId;
				
				uint msgid = 0;
				if ( MWGlobal.MessageList.Contains("BasicMessage") )		//TODO: Use seperate message/user?
					msgid = (uint) MWGlobal.MessageList["BasicMessage"];
				else
					return;
			
				try 
				{
					UInt32 hr = service.SetMessageFlags(
						MWGlobal.Users[0].WebId,
						MWGlobal.Users[1].GamerTag,
						msgid,
						WCMessageFlags.Recommended,			// illegal after message sent
						0
						);

					if( HResult.Succeeded( hr ) )
					{
						Console.WriteLine("Unexpected success!");
						return;
					}
				}
				catch(SoapException e)
				{
					Console.WriteLine(e.Message);
				}


				ResultCode = TEST_RESULTS.PASSED;
			}
		}


	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Messaging\Test\FuncSendTitleUserMessage.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using System.IO;
using System.Xml;
using System.Web.Services.Protocols;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.Messaging;
using ServerTestFramework.Web.UserAccount;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;

namespace MessagingWidget
{
	[TestGroup]
	public class FuncSendTitleUserMessage : TestNode
	{

		// This test case is responsible for populating the DB with any test data needed, but not sent by
		// other cases.  If this case does not run it may cause others to fail

		[TestCase, Description("Send Test Data Messages")]
		class SendTestData : TestBase
		{
			protected uint SendTestMessage(string reciptag, string msgidentifier)
			{
				WCMessaging service = new WCMessaging();
             
				string[] recipients = new string[ 1 ];
				recipients[ 0 ] = reciptag;

				WCRecipientResult[] results = null;

				UInt32 hr = service.SendTitleUserMessage(
					"TitleUser Msg",						  // Sender
					0,                             // SenderContext
					WCMessageFlags.TitleReserved0, // MessageFlags
					400001,                        // SenderTitleID
					60,								// Expire Minutes
					WCMessageType.TitleCustom,		// WCMessageType
					recipients,                    // Recipient IDs
					null,	                     // Details
					//null,							// Strings
					null,							// Attachments
					out results );

				if( HResult.Failed(hr) )
				{
					Global.RO.Info("Failed SendTitleUserMessage, HResult: " + hr.ToString("X"));
					ResultCode = TEST_RESULTS.FAILED;
					return hr;
				}

				if ( (results != null) && (results.Length > 0) )
				{
					if( HResult.Failed(results[0].MessageID ) )
					{
						Global.RO.Info("Failed SendTitleUserMessage, HResult: " + hr.ToString("X"));
						ResultCode = TEST_RESULTS.FAILED;
					}
					else
					{
						MWGlobal.MessageList.Add(msgidentifier, results[0].MessageID);
					}

					return results[0].MessageID;
				}
				else
				{
					ResultCode = TEST_RESULTS.FAILED;
					return 0x80000000;
				}

			}

			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				// Send 101 messages to User3 for max enum and queue check
				// TODO: this takes 20-30 secs...  something we can do here?

				for(int i = 0; i < 101; i++)
				{
					SendTestMessage(MWGlobal.Users[3].GamerTag, "titlemaxtest" + i.ToString());
				}

				// Send basic msg for user1
				SendTestMessage(MWGlobal.Users[9].GamerTag, "BasicTitleMessage");

				// Send msg for User5 for Revoke tests
				SendTestMessage(MWGlobal.Users[5].GamerTag, "RevokeTitleMsg");
				

				// Send msg for User4 for Delete tests
				SendTestMessage(MWGlobal.Users[4].GamerTag, "DeleteTitleMsg");

			}
		}


		[TestCase, Description("BasicSendTitleUserMessage")]
		class BasicSendTitleUserMessage : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				string[] recipients = new string[ 1 ];
				recipients[ 0 ] = MWGlobal.Users[9].GamerTag;			// User 9 for receiving TitleUser Messages

				WCMessageDetails smDetails = new WCMessageDetails();
				// TODO: Add some details in new case

				WCMessageAttachment[] attachments = new WCMessageAttachment[ 1 ];
				attachments[ 0 ] = new WCMessageAttachment();
				// TODO: Add some attachments in new case

				WCRecipientResult[] results = null;

				UInt32 hr = service.SendTitleUserMessage(
					"TitleUser Msg",    // Sender
					0,                             // SenderContext
					WCMessageFlags.TitleReserved0, // MessageFlags
					400001,                        // SenderTitleID
					60,								// Expire Minutes
					WCMessageType.TitleCustom,		// WCMessageType
					recipients,                    // Recipient IDs
					smDetails,                     // Details
					//null,                       // Strings
					attachments,                   // Attachments
					out results );

				if( HResult.Failed( hr ) )
				{
					Global.RO.Info("Failed SendTitleUserMessage, HResult: " + hr.ToString("X"));
					return;
				}

				if( recipients.Length != results.Length )
				{
					Global.RO.Info("Failed to send to all recipients(???).");
					return;
				}

				// Add this MessageID to MessageList so we can pull it for other tests
				MWGlobal.MessageList.Add("BasicTitleSend", results[0].MessageID);

				ConsoleX.WriteLine("Created messageID: " + results[0].MessageID);

				ResultCode = TEST_RESULTS.PASSED;
			}
		}
	

		// NOTE: This case fails if we don't go through the whole create users process
		[TestCase, Description("SendMAXRecipients")]
		class SendMaxRecipients : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				string[] recipients = new string[ 100 ];

                if (MWGlobal.Users.Length < 100) // not enough users to perform test?
                {
                    Global.RO.Info("Not set up for NegSendMaxPlusRecipients test... not 100 users available. (only " + MWGlobal.Users.Length + " are in array)");
                    return;
                }

				for(int iUser = 0; iUser < 100; iUser++)
				{
					recipients[iUser] = MWGlobal.Users[iUser].GamerTag;
				}

				WCMessageAttachment[] attachments = new WCMessageAttachment[ 1 ];
				attachments[ 0 ] = new WCMessageAttachment();
				// TODO: Add some attachments in new case

				WCRecipientResult[] results = null;

				UInt32 hr = service.SendTitleUserMessage( 
					"TitleUser Msg",						  // Sender
					0,                             // SenderContext
					WCMessageFlags.TitleReserved0, // MessageFlags
					400001,                        // SenderTitleID
					60,								// Expire Minutes
					WCMessageType.TitleCustom,    // WCMessageType
					recipients,                   // Recipient IDs
					null,				          // Details
					//null,			              // Strings
					null,		                  // Attachments
					out results );

				if( HResult.Failed( hr ) )
				{
					Global.RO.Info("Failed SendTitleUserMessage, HResult: " + hr.ToString("X"));
					return;
				}

				if( recipients.Length != results.Length )
				{
					Global.RO.Info("Failed to send to all recipients(???).");
					return;
				}

				for(int i = 0; i < results.Length; i++)
					Global.RO.Info(results[i].User + " : " + results[i].MessageID);


				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		// NOTE: This case fails if we don't go through the whole create users process
		[TestCase, Description("NegSendMaxPlusRecipients")]
		class NegSendMaxPlusRecipients : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				string[] recipients = new string[ 101 ];

                if (MWGlobal.Users.Length < 101) //not enough users to perform test?
                {
                    Global.RO.Info("Not set up for NegSendMaxPlusRecipients test... not 101 users available. (only " + MWGlobal.Users.Length + " are in array)");
                    return;
                }

				for(int iUser = 0; iUser < 101; iUser++)
				{
					recipients[iUser] = MWGlobal.Users[iUser].GamerTag;
				}

				WCMessageAttachment[] attachments = new WCMessageAttachment[ 1 ];
				attachments[ 0 ] = new WCMessageAttachment();
				// TODO: Add some attachments in new case

				WCRecipientResult[] results = null;

				UInt32 hr = service.SendTitleUserMessage( 
					"TitleUser Msg",						  // Sender
					0,                             // SenderContext
					WCMessageFlags.TitleReserved0, // MessageFlags
					400001,                        // SenderTitleID
					60,								// Expire Minutes
					WCMessageType.TitleCustom,    // WCMessageType
					recipients,                   // Recipient IDs
					null,				          // Details
					//null,			              // Strings
					null,		                  // Attachments
					out results );

				if( HResult.Succeeded( hr ) )
				{
					Global.RO.Info("Unexpected pass.");
					return;
				}

				if( hr != HResult.E_INVALIDARG )
				{
					Global.RO.Info("Incorrect HRESULT: " + hr.ToString("X") );
					return;
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}


		[TestCase, Description("SendMaxExpireTime")]
		//TODO: This varies by message type according to INI settings in ops -- test around this
		class SendMaxExpireTime : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				string[] recipients = new string[ 1 ];
				recipients[ 0 ] = MWGlobal.Users[9].GamerTag;

				WCMessageDetails smDetails = new WCMessageDetails();
				// TODO: Add some details in new case


				WCMessageAttachment[] attachments = new WCMessageAttachment[ 1 ];
				attachments[ 0 ] = new WCMessageAttachment();
				// TODO: Add some attachments


				WCRecipientResult[] results = null;

				UInt32 hr = service.SendTitleUserMessage( 
					"TitleUser Msg",						  // Sender
					0,                             // SenderContext
					WCMessageFlags.TitleReserved0, // MessageFlags
					400001,                        // SenderTitleID
					ushort.MaxValue,				// Expire Minutes   64800 == 45 days
					WCMessageType.TitleCustom,		// WCMessageType
					recipients,                    // Recipient IDs
					smDetails,                     // Details
					//null,	                       // Strings
					attachments,                   // Attachments
					out results );

				if( HResult.Failed( hr ) )
				{
					Global.RO.Info("Failed SendTitleUserMessage, HResult: " + hr.ToString("X"));
					return;
				}

				if( recipients.Length != results.Length )
				{
					Global.RO.Info("Failed to send to all recipients(???).");
					return;
				}

				//Add MessageID to list
				MWGlobal.MessageList.Add("TitleMaxExpire", results[0].MessageID);

				ConsoleX.WriteLine("Created messageID: " + results[0].MessageID);

				ResultCode = TEST_RESULTS.PASSED;
			}
		}


		[TestCase, Description("Send MSReserved Flag")]
		class NegSendReservedFlag : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				string[] recipients = new string[ 1 ];
				recipients[ 0 ] = MWGlobal.Users[9].GamerTag;

				WCMessageDetails smDetails = new WCMessageDetails();
				// TODO: Add some details in new case

				WCLocalizedString[] strings = new WCLocalizedString[ 1 ];
				strings[ 0 ] = new WCLocalizedString();

				WCMessageAttachment[] attachments = new WCMessageAttachment[ 1 ];
				attachments[ 0 ] = new WCMessageAttachment();
				// TODO: Add some attachments

				WCRecipientResult[] results = null;

                //test all reserved flags (note: MSReserved0 through 2 are now in use, so not "reserved" anymore)
                //Xenon bug 34037 made MSReserved0 flag allowed.  1 and 2... happened sometime...
                for (uint rflag = (uint)WCMessageFlags.MSReserved3; ; rflag <<= 1)
                {
                    UInt32 hr = service.SendTitleUserMessage(
                        "TitleUser Msg",						  // Sender
                        0,                             // SenderContext
                        (WCMessageFlags)rflag,        // MessageFlags
                        400001,                        // SenderTitleID
                        60,								// Expire Minutes
                        WCMessageType.TitleCustom,		// WCMessageType
                        recipients,                    // Recipient IDs
                        smDetails,                     // Details
                        //strings,                       // Strings
                        attachments,                   // Attachments
                        out results);

                    if (HResult.Succeeded(hr))
                    {
                        Global.RO.Info("Failed NEG SendReservedFlag");
                        return;
                    }

                    //TODO: Check specific code  0x80070005 ?

                    if (rflag == (uint)WCMessageFlags.MSReserved13) break; //13 is the last reserved flag value
                }

				ResultCode = TEST_RESULTS.PASSED;
			}
		}



	
		[TestCase, Description("Send Invalid Type Message")]
		class NegSendTypeInvalidMessage : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				string[] recipients = new string[ 1 ];
				recipients[ 0 ] = MWGlobal.Users[9].GamerTag;

				WCMessageDetails smDetails = new WCMessageDetails();
				// TODO: Add some details in new case

				WCLocalizedString[] strings = new WCLocalizedString[ 1 ];
				strings[ 0 ] = new WCLocalizedString();

				WCMessageAttachment[] attachments = new WCMessageAttachment[ 1 ];
				attachments[ 0 ] = new WCMessageAttachment();
				// TODO: Add some attachments


				WCRecipientResult[] results = null;

				UInt32 hr = service.SendTitleUserMessage( 
					"TitleUser Msg",						  // Sender
					0,                             // SenderContext
					WCMessageFlags.TitleReserved0, // MessageFlags
					400001,                        // SenderTitleID
					60,								// Expire Minutes
					WCMessageType.Invalid,			// WCMessageType
					recipients,                    // Recipient IDs
					smDetails,                     // Details
					//strings,                       // Strings
					attachments,                   // Attachments
					out results );

				if( HResult.Succeeded( hr ) )
				{
					Global.RO.Info("Failed NEG SendInvalidFlag");
					return;
				}

				//TODO: Check specific code  0x80070005 ?

				ResultCode = TEST_RESULTS.PASSED;
			}
		}


		[TestCase, Description("Send Message Attachment")]
		class SendAttachment : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				string[] recipients = new string[ 1 ];
				recipients[ 0 ] = MWGlobal.Users[9].GamerTag;

				byte[] attachdata = {			// 16 bytes of data
					0x00, 0xFF, 0x01, 0x02,
					0x00, 0xFF, 0x01, 0x02,
					0x00, 0xFF, 0x01, 0x02,
					0x00, 0xFF, 0x01, 0x02			
					};

				WCMessageAttachment[] attach = new WCMessageAttachment[1];
				attach[0] = new WCMessageAttachment();
				attach[0].PropID = 9;
				attach[0].Data = attachdata;
				//attach[0].Data = null
				attach[0].Flags = 0;

				WCRecipientResult[] results = null;
				UInt32 hr = service.SendTitleUserMessage( 
					"TitleUser Msg",                       // Sender
					0,                             // SenderContext
					WCMessageFlags.TitleReserved0, // MessageFlags
					400001,                        // SenderTitleID
					60,                            // ExpireMinutes
					WCMessageType.TitleCustom,     // MessageType
					recipients,                    // Recipient IDs
					null,	                       // Details
					//null,	                       // Strings
					attach,						   // Attachments
					out results );

				if( HResult.Failed( hr ) )
				{
					Global.RO.Info("Failed SendTitleUserMessage, HResult: " + hr.ToString("X"));
					return;
				}

				if( recipients.Length != results.Length )
				{
					Global.RO.Info("Failed to send to all recipients(???).");
					return;
				}

				// Add MessageID
				MWGlobal.MessageList.Add("TitleMessageAttachment", results[0].MessageID);

				ConsoleX.WriteLine("Created messageID: " + results[0].MessageID);

				ResultCode = TEST_RESULTS.PASSED;
			}
		}


		//TODO: Test case that sends random details

		[TestCase, Description("Send Details StringID")]
		class SendDetailsStringID : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				string[] recipients = new string[ 1 ];
				recipients[ 0 ] = MWGlobal.Users[9].GamerTag;

				WCMessageDetails smDetails = new WCMessageDetails();
				smDetails.StringIdProp = new WCStringIdProp[1];
				smDetails.StringIdProp[0] = new WCStringIdProp();
				smDetails.StringIdProp[0].Value = 1;
				smDetails.StringIdProp[0].PropID = 1;

				WCLocalizedString[] strings = new WCLocalizedString[ 1 ];
				strings[ 0 ] = new WCLocalizedString();

				WCMessageAttachment[] attachments = new WCMessageAttachment[ 1 ];
				attachments[ 0 ] = new WCMessageAttachment();
				// TODO: Add some attachments


				WCRecipientResult[] results = null;
				UInt32 hr = service.SendTitleUserMessage( 
					"TitleUser Msg",                       // Sender
					0,                             // SenderContext
					WCMessageFlags.TitleReserved0, // MessageFlags
					400001,                        // SenderTitleID
					60,                            // ExpireMinutes
					WCMessageType.TitleCustom,     // MessageType
					recipients,                    // Recipient IDs
					smDetails,                     // Details
					//strings,                       // Strings
					attachments,                   // Attachments
					out results );

				if( HResult.Failed( hr ) )
				{
					Global.RO.Info("Failed SendTitleUserMessage, HResult: " + hr.ToString("X"));
					return;
				}

				if( recipients.Length != results.Length )
				{
					Global.RO.Info("Failed to send to all recipients(???).");
					return;
				}

				// Add this MessageID to MessageList so we can pull it for other tests
				MWGlobal.MessageList.Add("TitleDetailsStringID", results[0].MessageID);

				ConsoleX.WriteLine("Created messageID: " + results[0].MessageID);

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("Send Details Bool")]
		class SendDetailsBool : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				string[] recipients = new string[ 1 ];
				recipients[ 0 ] = MWGlobal.Users[9].GamerTag;

				WCMessageDetails smDetails = new WCMessageDetails();
				smDetails.BoolProp = new WCBoolProp[1];
				smDetails.BoolProp[0] = new WCBoolProp();
				smDetails.BoolProp[0].PropID = 1;
				smDetails.BoolProp[0].Value = true;

				WCLocalizedString[] strings = new WCLocalizedString[ 1 ];
				strings[ 0 ] = new WCLocalizedString();

				WCMessageAttachment[] attachments = new WCMessageAttachment[ 1 ];
				attachments[ 0 ] = new WCMessageAttachment();
				// TODO: Add some attachments

				WCRecipientResult[] results = null;
				UInt32 hr = service.SendTitleUserMessage( 
					"TitleUser Msg",                       // Sender
					0,                             // SenderContext
					WCMessageFlags.TitleReserved0, // MessageFlags
					400001,                        // SenderTitleID
					60,                            // ExpireMinutes
					WCMessageType.TitleCustom,     // MessageType
					recipients,                    // Recipient IDs
					smDetails,                     // Details
					//strings,                       // Strings
					attachments,                   // Attachments
					out results );

				if( HResult.Failed( hr ) )
				{
					Global.RO.Info("Failed SendTitleUserMessage, HResult: " + hr.ToString("X"));
					return;
				}

				if( recipients.Length != results.Length )
				{
					Global.RO.Info("Failed to send to all recipients(???).");
					return;
				}

				// Add this MessageID to MessageList so we can pull it for other tests
				MWGlobal.MessageList.Add("TitleDetailsBool", results[0].MessageID);

				ConsoleX.WriteLine("Created messageID: " + results[0].MessageID);

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("Send Details Attach")]
		class SendDetailsAttach : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				string[] recipients = new string[ 1 ];
				recipients[ 0 ] = MWGlobal.Users[9].GamerTag;

				WCMessageDetails smDetails = new WCMessageDetails();
				smDetails.AttachmentProp = new WCAttachmentProp[1];
				smDetails.AttachmentProp[0] = new WCAttachmentProp();
				smDetails.AttachmentProp[0].PropID = 22;
				smDetails.AttachmentProp[0].AttachFlags = WCAttachFlags.NonExportable;
				smDetails.AttachmentProp[0].AttachSize = 0;
				smDetails.AttachmentProp[0].AttachUrl = "http://somefakeurl/testcase.html";

				WCLocalizedString[] strings = new WCLocalizedString[ 1 ];
				strings[ 0 ] = new WCLocalizedString();

				WCMessageAttachment[] attachments = new WCMessageAttachment[ 1 ];
				attachments[ 0 ] = new WCMessageAttachment();
				// TODO: Add some attachments

				WCRecipientResult[] results = null;
				UInt32 hr = service.SendTitleUserMessage( 
					"TitleUser Msg",                       // Sender
					0,                             // SenderContext
					WCMessageFlags.TitleReserved0, // MessageFlags
					400001,                        // SenderTitleID
					60,                            // ExpireMinutes
					WCMessageType.TitleCustom,     // MessageType
					recipients,                    // Recipient IDs
					smDetails,                     // Details
					//strings,                       // Strings
					attachments,                   // Attachments
					out results );

				if( HResult.Failed( hr ) )
				{
					Global.RO.Info("Failed SendTitleUserMessage, HResult: " + hr.ToString("X"));
					return;
				}

				if( recipients.Length != results.Length )
				{
					Global.RO.Info("Failed to send to all recipients(???).");
					return;
				}

				// Add this MessageID to MessageList so we can pull it for other tests
				MWGlobal.MessageList.Add("TitleDetailsAttachment", results[0].MessageID);

				ConsoleX.WriteLine("Created messageID: " + results[0].MessageID);

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("Send Details String")]
		class SendDetailsString : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				string[] recipients = new string[ 1 ];
				recipients[ 0 ] = MWGlobal.Users[9].GamerTag;

				WCMessageDetails smDetails = new WCMessageDetails();
				smDetails.StringProp = new WCStringProp[1];
				smDetails.StringProp[0] = new WCStringProp();
				smDetails.StringProp[0].PropID = 0xFF;
				smDetails.StringProp[0].Value = "Test case string.";

				WCMessageAttachment[] attachments = new WCMessageAttachment[ 1 ];
				attachments[ 0 ] = new WCMessageAttachment();
				// TODO: Add some attachments


				WCRecipientResult[] results = null;
				UInt32 hr = service.SendTitleUserMessage( 
					"TitleUser Msg",                       // Sender
					0,                             // SenderContext
					WCMessageFlags.TitleReserved0, // MessageFlags
					400001,                        // SenderTitleID
					60,                            // ExpireMinutes
					WCMessageType.TitleCustom,     // MessageType
					recipients,                    // Recipient IDs
					smDetails,                     // Details
					//strings,                       // Strings
					attachments,                   // Attachments
					out results );

				if( HResult.Failed( hr ) )
				{
					Global.RO.Info("Failed SendTitleUserMessage, HResult: " + hr.ToString("X"));
					return;
				}

				if( recipients.Length != results.Length )
				{
					Global.RO.Info("Failed to send to all recipients(???).");
					return;
				}

				// Add this MessageID to MessageList so we can pull it for other tests
				MWGlobal.MessageList.Add("TitleDetailsString", results[0].MessageID);

				ConsoleX.WriteLine("Created messageID: " + results[0].MessageID);

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("Send Details Binary")]
			class SendDetailsBinary : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				string[] recipients = new string[ 1 ];
				recipients[ 0 ] = MWGlobal.Users[9].GamerTag;

				byte[] testdata = { 0x00, 0xFF, 0x01, 0x02, 0x03 };

				WCMessageDetails smDetails = new WCMessageDetails();
				smDetails.BinaryProp = new WCBinaryProp[1];
				smDetails.BinaryProp[0] = new WCBinaryProp();
				smDetails.BinaryProp[0].PropID = 0xFF;
				smDetails.BinaryProp[0].Value = testdata;


				WCLocalizedString[] strings = new WCLocalizedString[ 1 ];
				strings[ 0 ] = new WCLocalizedString();

				WCMessageAttachment[] attachments = new WCMessageAttachment[ 1 ];
				attachments[ 0 ] = new WCMessageAttachment();
				// TODO: Add some attachments

				WCRecipientResult[] results = null;
				UInt32 hr = service.SendTitleUserMessage( 
					"TitleUser Msg",                       // Sender
					0,                             // SenderContext
					WCMessageFlags.TitleReserved0, // MessageFlags
					400001,                        // SenderTitleID
					60,                            // ExpireMinutes
					WCMessageType.TitleCustom,     // MessageType
					recipients,                    // Recipient IDs
					smDetails,                     // Details
					//strings,                       // Strings
					attachments,                   // Attachments
					out results );

				if( HResult.Failed( hr ) )
				{
					Global.RO.Info("Failed SendTitleUserMessage, HResult: " + hr.ToString("X"));
					return;
				}

				if( recipients.Length != results.Length )
				{
					Global.RO.Info("Failed to send to all recipients(???).");
					return;
				}

				// Add this MessageID to MessageList so we can pull it for other tests
				MWGlobal.MessageList.Add("TitleDetailsBinary", results[0].MessageID);

				ConsoleX.WriteLine("Created messageID: " + results[0].MessageID);

				ResultCode = TEST_RESULTS.PASSED;
			}
		}


		[TestCase, Description("Send Details Qword")]
		class SendDetailsQword : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				string[] recipients = new string[ 1 ];
				recipients[ 0 ] = MWGlobal.Users[9].GamerTag;

				WCMessageDetails smDetails = new WCMessageDetails();
				smDetails.QwordProp = new WCQwordProp[4];
				smDetails.QwordProp[0] = new WCQwordProp();
				smDetails.QwordProp[0].PropID = 0xFF;
				smDetails.QwordProp[0].Value = UInt64.MinValue;
				smDetails.QwordProp[1] = new WCQwordProp();
				smDetails.QwordProp[1].PropID = 0xFE;	
				smDetails.QwordProp[1].Value = UInt64.MaxValue;
				smDetails.QwordProp[2] = new WCQwordProp();
				smDetails.QwordProp[2].PropID = 0xFD;	
				smDetails.QwordProp[2].Value = 0;
				smDetails.QwordProp[3] = new WCQwordProp();
				smDetails.QwordProp[3].PropID = 0xFC;	
				smDetails.QwordProp[3].Value = 1111;

				WCLocalizedString[] strings = new WCLocalizedString[ 1 ];
				strings[ 0 ] = new WCLocalizedString();

				WCMessageAttachment[] attachments = new WCMessageAttachment[ 1 ];
				attachments[ 0 ] = new WCMessageAttachment();
				// TODO: Add some attachments

				WCRecipientResult[] results = null;
				UInt32 hr = service.SendTitleUserMessage( 
					"TitleUser Msg",                       // Sender
					0,                             // SenderContext
					WCMessageFlags.TitleReserved0, // MessageFlags
					400001,                        // SenderTitleID
					60,                            // ExpireMinutes
					WCMessageType.TitleCustom,     // MessageType
					recipients,                    // Recipient IDs
					smDetails,                     // Details
					//strings,                       // Strings
					attachments,                   // Attachments
					out results );

				if( HResult.Failed( hr ) )
				{
					Global.RO.Info("Failed SendTitleUserMessage, HResult: " + hr.ToString("X"));
					return;
				}

				if( recipients.Length != results.Length )
				{
					Global.RO.Info("Failed to send to all recipients(???).");
					return;
				}

				// Add this MessageID to MessageList so we can pull it for other tests
				MWGlobal.MessageList.Add("TitleDetailsQword", results[0].MessageID);

				ConsoleX.WriteLine("Created messageID: " + results[0].MessageID);

				ResultCode = TEST_RESULTS.PASSED;
			}
		}



		[TestCase, Description("Send Details DWord")]
		class SendDetailsDWord : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				string[] recipients = new string[ 1 ];
				recipients[ 0 ] = MWGlobal.Users[9].GamerTag;

				WCMessageDetails smDetails = new WCMessageDetails();
				smDetails.DwordProp = new WCDwordProp[4];
				smDetails.DwordProp[0] = new WCDwordProp();
				smDetails.DwordProp[0].PropID = 0xFF;	//0x04xx is dword type
				smDetails.DwordProp[0].Value = (UInt32) 1111;
				smDetails.DwordProp[1] = new WCDwordProp();
				smDetails.DwordProp[1].PropID = 0xFE;	
				smDetails.DwordProp[1].Value = (UInt32) 2222;
				smDetails.DwordProp[2] = new WCDwordProp();
				smDetails.DwordProp[2].PropID = 0xFD;	
				smDetails.DwordProp[2].Value = (UInt32) 3333;
				smDetails.DwordProp[3] = new WCDwordProp();
				smDetails.DwordProp[3].PropID = 0xFC;	
				smDetails.DwordProp[3].Value = (UInt32) 4444;

				WCLocalizedString[] strings = new WCLocalizedString[ 1 ];
				strings[ 0 ] = new WCLocalizedString();

				WCMessageAttachment[] attachments = new WCMessageAttachment[ 1 ];
				attachments[ 0 ] = new WCMessageAttachment();
				// TODO: Add some attachments

				WCRecipientResult[] results = null;
				UInt32 hr = service.SendTitleUserMessage( 
					"TitleUser Msg",                       // Sender
					0,                             // SenderContext
					WCMessageFlags.TitleReserved0, // MessageFlags
					400001,                        // SenderTitleID
					60,                            // ExpireMinutes
					WCMessageType.TitleCustom,     // MessageType
					recipients,                    // Recipient IDs
					smDetails,                     // Details
					//strings,                       // Strings
					attachments,                   // Attachments
					out results );

				if( HResult.Failed( hr ) )
				{
					Global.RO.Info("Failed SendTitleUserMessage, HResult: " + hr.ToString("X"));
					return;
				}

				if( recipients.Length != results.Length )
				{
					Global.RO.Info("Failed to send to all recipients(???).");
					return;
				}

				// Add this MessageID to MessageList so we can pull it for other tests
				MWGlobal.MessageList.Add("TitleDetailsDword", results[0].MessageID);

				ConsoleX.WriteLine("Created messageID: " + results[0].MessageID);

				ResultCode = TEST_RESULTS.PASSED;
			}
		}


		[TestCase, Description("Send Details Byte")]
		class SendDetailsByte : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				string[] recipients = new string[ 1 ];
				recipients[ 0 ] = MWGlobal.Users[9].GamerTag;

				WCMessageDetails smDetails = new WCMessageDetails();
				smDetails.ByteProp = new WCByteProp[1];
				smDetails.ByteProp[0] = new WCByteProp();
				smDetails.ByteProp[0].PropID = 0x01;
				smDetails.ByteProp[0].Value = 0xFF;

				WCLocalizedString[] strings = new WCLocalizedString[ 1 ];
				strings[ 0 ] = new WCLocalizedString();

				WCMessageAttachment[] attachments = new WCMessageAttachment[ 1 ];
				attachments[ 0 ] = new WCMessageAttachment();
				// TODO: Add some attachments


				WCRecipientResult[] results = null;
				UInt32 hr = service.SendTitleUserMessage( 
					"TitleUser Msg",                       // Sender
					0,                             // SenderContext
					WCMessageFlags.TitleReserved0, // MessageFlags
					400001,                        // SenderTitleID
					60,                            // ExpireMinutes
					WCMessageType.TitleCustom,     // MessageType
					recipients,                    // Recipient IDs
					smDetails,                     // Details
					//strings,                       // Strings
					attachments,                   // Attachments
					out results );

				if( HResult.Failed( hr ) )
				{
					Global.RO.Info("Failed SendTitleUserMessage, HResult: " + hr.ToString("X"));
					return;
				}

				if( recipients.Length != results.Length )
				{
					Global.RO.Info("Failed to send to all recipients(???).");
					return;
				}

				// Add this MessageID to MessageList so we can pull it for other tests
				MWGlobal.MessageList.Add("TitleDetailsByte", results[0].MessageID);

				ConsoleX.WriteLine("Created messageID: " + results[0].MessageID);

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("Send Details Word")]
		class SendDetailsWord : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				string[] recipients = new string[ 1 ];
				recipients[ 0 ] = MWGlobal.Users[9].GamerTag;

				WCMessageDetails smDetails = new WCMessageDetails();
				smDetails.WordProp = new WCWordProp[1];
				smDetails.WordProp[0] = new WCWordProp();
				smDetails.WordProp[0].PropID = 0xFF;
				smDetails.WordProp[0].Value = UInt16.MaxValue;

				WCLocalizedString[] strings = new WCLocalizedString[ 1 ];
				strings[ 0 ] = new WCLocalizedString();

				WCMessageAttachment[] attachments = new WCMessageAttachment[ 1 ];
				attachments[ 0 ] = new WCMessageAttachment();
				// TODO: Add some attachments


				WCRecipientResult[] results = null;
				UInt32 hr = service.SendTitleUserMessage( 
					"TitleUser Msg",                       // Sender
					0,                             // SenderContext
					WCMessageFlags.TitleReserved0, // MessageFlags
					400001,                        // SenderTitleID
					60,                            // ExpireMinutes
					WCMessageType.TitleCustom,     // MessageType
					recipients,                    // Recipient IDs
					smDetails,                     // Details
					//strings,                       // Strings
					attachments,                   // Attachments
					out results );

				if( HResult.Failed( hr ) )
				{
					Global.RO.Info("Failed SendTitleUserMessage, HResult: " + hr.ToString("X"));
					return;
				}

				if( recipients.Length != results.Length )
				{
					Global.RO.Info("Failed to send to all recipients(???).");
					return;
				}

				// Add this MessageID to MessageList so we can pull it for other tests
				MWGlobal.MessageList.Add("TitleDetailsWord", results[0].MessageID);

				ConsoleX.WriteLine("Created messageID: " + results[0].MessageID);

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("NegRepeatedPropID")]
		class NegRepeatedPropID : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				string[] recipients = new string[ 1 ];
				recipients[ 0 ] = MWGlobal.Users[9].GamerTag;

				WCMessageDetails smDetails = new WCMessageDetails();
				smDetails.DwordProp = new WCDwordProp[2];
				smDetails.DwordProp[0] = new WCDwordProp();
				smDetails.DwordProp[0].PropID = 0x01;	//0x04xx is dword type
				smDetails.DwordProp[0].Value = (UInt32) 1111;
				smDetails.DwordProp[1] = new WCDwordProp();
				smDetails.DwordProp[1].PropID = 0x01;	
				smDetails.DwordProp[1].Value = (UInt32) 2222;

				WCLocalizedString[] strings = new WCLocalizedString[ 1 ];
				strings[ 0 ] = new WCLocalizedString();

				WCMessageAttachment[] attachments = new WCMessageAttachment[ 1 ];
				attachments[ 0 ] = new WCMessageAttachment();
				// TODO: Add some attachments


				WCRecipientResult[] results = null;
				UInt32 hr = service.SendTitleUserMessage( 
					"TitleUser Msg",                       // Sender
					0,                             // SenderContext
					WCMessageFlags.TitleReserved0, // MessageFlags
					400001,                        // SenderTitleID
					60,                            // ExpireMinutes
					WCMessageType.TitleCustom,     // MessageType
					recipients,                    // Recipient IDs
					smDetails,                     // Details
					//strings,                       // Strings
					attachments,                   // Attachments
					out results );

				if( hr != HResult.E_INVALIDARG )
				{
					Global.RO.Info("Unexpected HResult: " + hr.ToString("X") );
					return;
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}


		[TestCase, Description("NegRepeatedPropID2")]
			class NegRepeatedPropID2 : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				string[] recipients = new string[ 1 ];
				recipients[ 0 ] = MWGlobal.Users[9].GamerTag;

				// Create two properties with the same ID as different types
				WCMessageDetails smDetails = new WCMessageDetails();
				smDetails.DwordProp = new WCDwordProp[1];
				smDetails.DwordProp[0] = new WCDwordProp();
				smDetails.DwordProp[0].PropID = 0x01;
				smDetails.DwordProp[0].Value = (UInt32) 1111;

				smDetails.ByteProp = new WCByteProp[1];
				smDetails.ByteProp[0] = new WCByteProp();
				smDetails.ByteProp[0].PropID = 0x01;
				smDetails.ByteProp[0].Value = 0x01;


				WCRecipientResult[] results = null;
				UInt32 hr = service.SendTitleUserMessage( 
					"TitleUser Msg",                       // Sender
					0,                             // SenderContext
					WCMessageFlags.TitleReserved0, // MessageFlags
					400001,                        // SenderTitleID
					60,                            // ExpireMinutes
					WCMessageType.TitleCustom,     // MessageType
					recipients,                    // Recipient IDs
					smDetails,                     // Details
					//null,                       // Strings
					null,                   // Attachments
					out results );

				if( hr != HResult.E_INVALIDARG )
				{
					Global.RO.Info("Unexpected HResult: " + hr.ToString("X") );
					return;
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("SendMaxDetails")]
			class SendMaxDetails : TestBase
		{
			protected override void Execute()
			{
				//TODO: Test case to finish

				//eturn;
				ResultCode = TEST_RESULTS.PASSED;
			}
		}


		[TestCase, Description("NegUnknownUser")]
		class NegUnknownTitleID : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				string[] recipients = new string[ 1 ];
				recipients[ 0 ] = MWGlobal.Users[9].GamerTag;


				WCRecipientResult[] results = null;

				try 
				{

					UInt32 hr = service.SendTitleUserMessage( 
						"TitleUser Msg",						  // Sender
						0,                             // SenderContext
						0,								// MessageFlags
						1111,                        // SenderTitleID
						60,								// Expire Minutes
						WCMessageType.TitleCustom,		// WCMessageType
						recipients,                    // Recipient IDs
						null,                     // Details
						//null,                       // Strings
						null,                   // Attachments
						out results );

					if( HResult.Succeeded( hr ) )
					{
						Global.RO.Info("Unexpected pass.");
						return;
					}
				}
				catch(SoapException e)
				{
					Global.RO.Info(e.Message);
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

	

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Messaging\Test\dvt\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\misc\FormatGen\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Messaging\Test\FuncUserTitles.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using System.IO;
using System.Xml;
using System.Web.Services.Protocols;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.Messaging;
using ServerTestFramework.Web.UserAccount;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;

namespace MessagingWidget
{
	[TestGroup]
	public class FuncUserTitles : TestNode
	{
		//TODO: requires pre-populated data in xprof tables
		[TestCase, Description("EnumUserTitles")]
		class EnumUserTitles : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
				WCUserTitle[] Titles = null;

				//WCWebUser user = new WCWebUser();
				//user.GamerTag = MWGlobal.Users[0].GamerTag;
				//user.WebID = MWGlobal.Users[0].WebId;

				UInt32 hr = service.EnumUserTitles(
					MWGlobal.Users[0].WebId,
					MWGlobal.Users[0].GamerTag,
					out Titles
					);

				Console.WriteLine( "EnumUserTitles returned {0}", hr );
				
				if( HResult.Succeeded( hr ) )
				{
					foreach (WCUserTitle uTitle in Titles)
					{
						Console.WriteLine( uTitle.TitleID );
					}
				}
				else
				{
					Console.WriteLine("Failed Enum call: " + hr.ToString("X"));
					return;
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}
	
		[TestCase, Description("EnumZeroTitles")]
		class EnumZeroTitles : TestBase
		{

			// Enumerate titles for a user we know has 0 titles
			// (technically, this is not really possible as the Dash should be represented)
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
				WCUserTitle[] Titles = null;

				//WCWebUser user = new WCWebUser();
				//user.GamerTag = MWGlobal.Users[5].GamerTag;			// User 5 should have NO titles
				//user.WebID = MWGlobal.Users[5].WebId;

				UInt32 hr = service.EnumUserTitles(
					MWGlobal.Users[5].WebId,
					MWGlobal.Users[5].GamerTag,
					out Titles
					);

				Console.WriteLine( "EnumUserTitles returned {0}", hr );
				
				if( HResult.Succeeded( hr ) )
				{
					if (Titles.Length > 0)
					{
						Console.WriteLine("Unexpected titleIDs found: " + Titles.Length );
						return;
					}
				}
				else
				{
					Console.WriteLine("Failed Enum call: " + hr.ToString("X"));
					return;
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}


		//TODO: requires pre-populated data in xprof tables
		[TestCase, Description("DeleteUserTitle")]
		class DeleteUserTitle : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
				
				//WCWebUser user = new WCWebUser();
				//user.GamerTag = MWGlobal.Users[1].GamerTag;
				//user.WebID = MWGlobal.Users[1].WebId;

				UInt32 hr = service.DeleteUserTitle(
					MWGlobal.Users[1].WebId,
					MWGlobal.Users[1].GamerTag,
					0xFFFF0000							//TODO: pre-populate
					);

				Console.WriteLine( "DeleteUserTitle returned {0}", hr.ToString("X") );
				
				if( HResult.Succeeded( hr ) )
				{
					// Verify title is deleted
					WCUserTitle[] Titles = null;

					hr = service.EnumUserTitles(
						MWGlobal.Users[1].WebId,
						MWGlobal.Users[1].GamerTag,
						out Titles
						);

					for(int iTitle = 0; iTitle < Titles.Length; iTitle++)
					{
						if( Titles[iTitle].TitleID == 0xFFFF0000 )
						{
							Console.WriteLine("Call succeeded, but title is still subscribed.");
							return;
						}
					}
				}
				else
				{
					Console.WriteLine("Failed call: " + hr.ToString("X"));
					return;
				}

				ResultCode = TEST_RESULTS.PASSED;

			}
		}

		
		[TestCase, Description("NegDeleteBadTitle")]
		class NegDeleteBadTitle : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
				
				//WCWebUser user = new WCWebUser();
				//user.GamerTag = MWGlobal.Users[2].GamerTag;
				//user.WebID = MWGlobal.Users[2].WebId;

				UInt32 hr = service.DeleteUserTitle(
					MWGlobal.Users[2].WebId,
					MWGlobal.Users[2].GamerTag,
					1111							// Title user does not have listed
					);
		
				if( HResult.Succeeded( hr ) )
				{
					Console.WriteLine("Unexpected pass.");
					return;
				}
				
				if( hr != HResult.XONLINE_E_MESSAGE_INVALID_TITLE_ID )
				{
					Console.WriteLine("Incorrect HResult: " + hr.ToString("X"));
					return;
				}

				ResultCode = TEST_RESULTS.PASSED;

			}
		}

		[TestCase, Description("NegNullUserID")]
		class NegNullUserID : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
				
				//WCWebUser user = new WCWebUser();
				//user.GamerTag = null;
				//user.WebID = MWGlobal.Users[2].WebId;

				try 
				{
					UInt32 hr = service.DeleteUserTitle(
						null,
						MWGlobal.Users[2].GamerTag,
						400001							
						);

					Console.WriteLine( "Null tag HR: ", hr.ToString("X") );
				
					if( HResult.Succeeded( hr ) )
					{
						return;
					}
				}
				catch(SoapException e)
				{
					// this is OK, should get error return from SOAP call
					Console.WriteLine(e.Message);
				}

				// try empty string
				//user.GamerTag = "";

				try 
				{
					uint hr = service.DeleteUserTitle(
						MWGlobal.Users[2].WebId,
						"",
						400001	
						);

					Console.WriteLine( "Empty tag HR: ", hr.ToString("X") );
				
					if( HResult.Succeeded( hr ) )
					{
						return;
					}
				}
				catch(SoapException e)
				{
					// this is OK, should get error return from SOAP call
					Console.WriteLine(e.Message);
				}

				// try null WebID
				//user.GamerTag = MWGlobal.Users[1].GamerTag;
				//user.WebID = null;

				try 
				{
					uint hr = service.DeleteUserTitle(
						MWGlobal.Users[2].WebId,
						null,
						400001	
						);

					Console.WriteLine( "Null WebID HR: ", hr.ToString("X") );
				
					if( HResult.Succeeded( hr ) )
					{
						return;
					}
				}
				catch(SoapException e)
				{
					// this is OK, should get error return from SOAP call
					Console.WriteLine(e.Message);
				}

				ResultCode = TEST_RESULTS.PASSED;

			}
		}

	
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Messaging\Test\MainClass.cs ===
using System;
using ServerTestFramework;
using MessagingWidget;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;
using ServerTestFramework.Utilities.AsyncUtils;
using ServerTestFramework.Database;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.Messaging;
using ServerTestFramework.Web.UserAccount;
using ServerTestFramework.LiveService.UserAccount;

[assembly: RootNode(typeof(MessagingWidget.MessagingWidget))]

namespace MessagingWidget
{
	/// <summary>
	/// Summary description for MessagingWidget
	/// </summary>
    [Owner("codyluit"), TestFrequency("Regression"), TestCasePriority(3)]
	public class MessagingWidget : TestNode
	{
		const int	MAXMESSAGES	= 125;   // defined in 

        public MessagingWidget()
        {
            //add functional tests (this will force them into a specific order).
            foreach (TestNode n in GetTests())
            {
                AddChild(n);
            }

            //add stress tests
            foreach (TestNode n in GetStressTests())
            {
                n.Name="MessagingWidget Stress "+n.Name;
                AddChild(n, false, true);
            }
        }

        public override void PreRun(RUN_TYPE runType)
        {
            if (runType == RUN_TYPE.FUNCTIONAL)
            {
                InitializeFunctional();
            }
            else if (runType == RUN_TYPE.STRESS)
            {
                InitializeStress();
            }
        }

        public void InitializeStress()
		{
			UacsCommon ua=new UacsCommon();

			MWGlobal.userSet = STFLiveGlobal.GetUserSet("xenon");
            MWGlobal.myCount = (int)MWGlobal.userSet.Count;
			MWGlobal.StressUsers = new CPUIDList( MWGlobal.myCount );
			UodbWS.PopulatePuidListFromNames( MWGlobal.userSet.Prefix, ref MWGlobal.StressUsers );

			for( int i = 0; i < MWGlobal.StressUsers.GetSize(); ++i )
			{
				MWGlobal.StressUsers[i].WebId = WCUserAccount.PuidToWebID( MWGlobal.StressUsers[i].Puid );
			}
		}

        private void DoMakeMWGlobalUser(uint ind, object obj)
        {
            //System.Threading.Thread.Sleep((int)(5+(6-ind)*10));
            //throw new Exception("Rar!");

            UacsCommon ua = new UacsCommon();

            //Owner o = ua.GenerateOwner();
            Owner o = new Owner("MW" + ua.Random.GenerateRandomNameString(10));
            ulong puid = ua.CreateUser(o);

            WCUserAccount wua = new WCUserAccount();

            byte[] webPuid = ua.GenerateWebId(puid);

            if (!(wua.LinkUser(webPuid, true, o)))
            {
                ConsoleX.WriteLine("Could not link gamertag???");
            }
            else
            {
                MWGlobal.Users[ind] = new PuidName(puid, o.gamertag, webPuid);
                //ConsoleX.WriteLine("Linked user " + MWGlobal.Users[i].ToString() );
                Global.RO.Info("MWGlobal.Users[{2}] = new PuidName({0},\"{1}\", ua.GenerateWebId({0}));", puid, o.gamertag, ind);
            }
        }

        public void InitializeFunctional()
		{
			MWGlobal.Users = new PuidName[MWGlobal.UserMax];

			MWGlobal.MessageList.Clear();

			// TODO: pull this from config file
			bool bCreateUsers = true;
			
			if ( !bCreateUsers )
			{
                UacsCommon ua = new UacsCommon();

				MWGlobal.Users[0] = new PuidName(2550699431811538,"MW711743e829", ua.GenerateWebId(2550699431811538));
				MWGlobal.Users[1] = new PuidName(2550699431811539,"MW28344i3903", ua.GenerateWebId(2550699431811539));
				MWGlobal.Users[2] = new PuidName(2550699431811540,"MWe3994515oa", ua.GenerateWebId(2550699431811540));
				MWGlobal.Users[3] = new PuidName(2550699431811541,"MW1ue6u6i004", ua.GenerateWebId(2550699431811541));
				MWGlobal.Users[4] = new PuidName(2550699431811542,"MW303aoo6eue", ua.GenerateWebId(2550699431811542));
				MWGlobal.Users[5] = new PuidName(2550699431811543,"MWo010e3762o", ua.GenerateWebId(2550699431811543));
				MWGlobal.Users[6] = new PuidName(2550699431811544,"MW169683ii4i", ua.GenerateWebId(2550699431811544));
				MWGlobal.Users[7] = new PuidName(2550699431811545,"MWu39e0e0oe5", ua.GenerateWebId(2550699431811545));
				MWGlobal.Users[8] = new PuidName(2550699431811546,"MWo552i0ia9a", ua.GenerateWebId(2550699431811546));
				MWGlobal.Users[9] = new PuidName(2550699431811547,"MWu5i12e5e19", ua.GenerateWebId(2550699431811547));
			}
			else
			{
                ParallelRunner.Run(DoMakeMWGlobalUser,(uint)MWGlobal.UserMax,6,0);

                //async test.. not for messaging stuff.. to test of ParallelRunner
                /*AsyncUtils.ParallelRunner.Status status=AsyncUtils.ParallelRunner.RunAsync(DoMakeMWGlobalUser,(uint)MWGlobal.UserMax,6,0);
                while (status.IsStillRunning)
                {
                    System.Threading.Thread.Sleep(500);
                    Global.RO.Debug("async status test: error="+status.WasError+"  finished="+status.NumberFinished);
                }*/

				new SleepInfo("Waiting for cache link", 30000);	
			}

		}

        public System.Collections.Generic.List<TestNode> GetTests()
        {
            System.Collections.Generic.List<TestNode> tests = new System.Collections.Generic.List<TestNode>();

            tests.Add(new FuncSendMessage() );      // Put this first -- tests after this rely on test data
                                                    // inserted here
            tests.Add(new FuncEnumMessages() );
            tests.Add(new FuncGetMessageDetails() );
            tests.Add(new FuncDeleteMessage() );
            tests.Add(new FuncRevokeMessage() );
            tests.Add(new FuncSetMessageFlags() );
            
            tests.Add(new FuncUserTitles() );

            tests.Add(new FuncSendTitleWideMessage() );     // must go first
            tests.Add(new FuncSendTitleUserMessage() );
            tests.Add(new FuncEnumTitleWideMessages() );
            tests.Add(new FuncGetTitleMessageDetails() );
            tests.Add(new FuncDeleteTitleMessage() );
            tests.Add(new FuncRevokeTitleMessage() );
            
            tests.Add(new FuncGetMsgString() );


            return tests;
        }

        public System.Collections.Generic.List<TestNode> GetStressTests()
        {
            System.Collections.Generic.List<TestNode> tests = new System.Collections.Generic.List<TestNode>();
            //tests.Add(new Stress.EnumMessages());     //enum handled by Get and Delete, likewise for System Msgs
            tests.Add(new Stress.SendMessage());
            tests.Add(new Stress.GetMessage());
            tests.Add(new Stress.DeleteMessages());
            tests.Add(new Stress.RevokeMessages());
            tests.Add(new Stress.SetMessageFlags());

            tests.Add(new Stress.SendTitleWideMessage());
            tests.Add(new Stress.GetTitleWideMessage());
            tests.Add(new Stress.DeleteTitleWideMessage());
            tests.Add(new Stress.SendTitleUserMessage());
            tests.Add(new Stress.RevokeTitleUserMessage());

            tests.Add(new Stress.GetMessageString());
            tests.Add(new Stress.EnumAndDeleteUserTitles());
            
            return tests;
        }


		/**
		 
		// Comparison utility function for user message summaries
		public bool IsSummaryEqual( ref WCMessageSummary s1, ref WCMessageSummary s2 )
		{
			if( s1.Sender == s2.Sender &&
				s1.SenderContext == s2.SenderContext &&
				s1.SentTime == s2.SentTime &&
				s1.MessageID == s2.MessageID &&
				s1.MessageFlags == s2.MessageFlags &&
				s1.SenderTitleID == s2.SenderTitleID &&
				s1.MessageType == s2.MessageType &&
				s1.ExpireMinutes == s2.ExpireMinutes &&
				s1.DetailsSize == s2.DetailsSize )
			{
				return true;
			}

			return false;
		}

		// Comparison utility function for system message summaries
		public bool IsSummaryEqual( ref WCSystemMessageSummary s1, ref WCSystemMessageSummary s2 )
		{
			if( s1.TitleID == s2.TitleID &&
				s1.Region == s2.Region &&
				s1.SenderName == s2.SenderName &&
				s1.Description == s2.Description &&
				s1.SenderContext == s2.SenderContext &&
				s1.SentTime == s2.SentTime &&
				s1.MessageID == s2.MessageID &&
				s1.MessageFlags == s2.MessageFlags &&
				s1.MessageType == s2.MessageType &&
				s1.ExpireMinutes == s2.ExpireMinutes &&
				s1.DetailsSize == s2.DetailsSize )
			{
				return true;
			}

			return false;
		}
		**/
	}

	public class MessageInfo
	{
		public uint	MessageID;
		public string	ReceiverName;
		public string  SenderName;
		public byte[]  SenderPUID;

		public MessageInfo(uint msgid, string recname, string sendname, byte[] puid)
		{
			this.MessageID = msgid;
			this.ReceiverName = recname;
			this.SenderName = sendname;
			this.SenderPUID = puid;
		}
	}

	public class MWGlobal
	{
		// Globally visible user lists
		static public PuidName[]	Users;
        static public int UserMax = 102; //static public int  UserMax = 10; //need 101+ for NegSendMaxPlusRecipients test

		static public System.Collections.Hashtable MessageList = new System.Collections.Hashtable();

		static public System.Collections.Queue RevokeList = new System.Collections.Queue();

		static public CPUIDList StressUsers;
		
		static public BulkUserSet userSet;
		static public int myCount;

		MWGlobal()
		{
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Messaging\Test\FuncSendMessage.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using System.IO;
using System.Xml;
using System.Web.Services.Protocols;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.Utilities.AsyncUtils;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.Messaging;
using ServerTestFramework.Web.UserAccount;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;

namespace MessagingWidget
{
	[TestGroup]
	public class FuncSendMessage : TestNode
	{

		static PuidName[] recipientUsers = new PuidName[102];
        static WCMessageType[] messageTypes = {
            /// <remarks/>
            WCMessageType.TitleCustom,

            /// <remarks/>
            WCMessageType.PersonalMessage,

            /// <remarks/>
            WCMessageType.CompReminder,

            /// <remarks/>
            WCMessageType.CompRequest
        };


		// This test case is responsible for populating the DB with any test data needed, but not sent by
		// other cases.  If this case does not run it may cause others to fail

		[TestCase, Description("Send Test Data Messages")]
		class SendTestData : TestBase
		{
			protected uint SendTestMessage(string reciptag, string msgidentifier, WCMessageType messageType)
			{
				WCMessaging service = new WCMessaging();
             
				string[] recipients = new string[ 1 ];
				recipients[ 0 ] = reciptag;

				//WCWebUser user = new WCWebUser();
				//user.GamerTag = MWGlobal.Users[0].GamerTag;
				//user.WebID = MWGlobal.Users[0].WebId;

				WCRecipientResult[] results = null;

				UInt32 hr = service.SendMessage(
					MWGlobal.Users[0].WebId,	   // Sender
					MWGlobal.Users[0].GamerTag,
					0,                             // SenderContext
					WCMessageFlags.TitleReserved0, // MessageFlags
					400001,                        // SenderTitleID
					60,								// Expire Minutes
					messageType,		            // WCMessageType
					recipients,                    // Recipient IDs
					null,	                     // Details
					//null,							// Strings
					null,							// Attachments
					out results );

				if( HResult.Failed(hr) )
				{
					Global.RO.Info("Failed SendMessage, HResult: " + hr.ToString("X"));
					ResultCode = TEST_RESULTS.FAILED;
					return hr;
				}

				if ( (results != null) && (results.Length > 0) )
				{
					if( HResult.Failed(results[0].MessageID ) )
					{
						Global.RO.Info("Failed SendMessage, HResult: " + hr.ToString("X"));
						ResultCode = TEST_RESULTS.FAILED;
					}
					else
					{
						MWGlobal.MessageList.Add(msgidentifier, results[0].MessageID);
					}

					return results[0].MessageID;
				}
				else
				{
					ResultCode = TEST_RESULTS.FAILED;
					return 0x80000000;
				}

			}

			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				// Send 101 messages to User3 for max enum and queue check
				// TODO: this takes 20-30 secs...  something we can do here?

				for(int i = 0; i < 101; i++)
				{
                    SendTestMessage(MWGlobal.Users[3].GamerTag, "maxtest" + i.ToString(), messageTypes[i % messageTypes.Length]);
				}

				// Send basic msg for user1
                SendTestMessage(MWGlobal.Users[1].GamerTag, "BasicMessage", WCMessageType.TitleCustom);

				// Send msg for User5 for Revoke tests
                SendTestMessage(MWGlobal.Users[5].GamerTag, "RevokeMsg", WCMessageType.TitleCustom);
				

				// Send msg for User4 for Delete tests
                SendTestMessage(MWGlobal.Users[4].GamerTag, "DeleteMsg", WCMessageType.TitleCustom);

			}
		}


		[TestCase, Description("BasicSendMessage")]
		class BasicSendMessage : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				string[] recipients = new string[ 1 ];
				recipients[ 0 ] = MWGlobal.Users[1].GamerTag;

				WCMessageDetails smDetails = new WCMessageDetails();
				// TODO: Add some details in new case

				WCMessageAttachment[] attachments = new WCMessageAttachment[ 1 ];
				attachments[ 0 ] = new WCMessageAttachment();
				// TODO: Add some attachments in new case

				//WCWebUser user = new WCWebUser();
				//user.GamerTag = MWGlobal.Users[0].GamerTag;
				//user.WebID = MWGlobal.Users[0].WebId;

				WCRecipientResult[] results = null;

				UInt32 hr = service.SendMessage( 
					MWGlobal.Users[0].WebId,						  // Sender
					MWGlobal.Users[0].GamerTag,
					0,                             // SenderContext
					WCMessageFlags.TitleReserved0, // MessageFlags
					400001,                        // SenderTitleID
					60,								// Expire Minutes
					WCMessageType.TitleCustom,		// WCMessageType
					recipients,                    // Recipient IDs
					smDetails,                     // Details
					//null,                       // Strings
					attachments,                   // Attachments
					out results );

				if( HResult.Failed( hr ) )
				{
					Global.RO.Info("Failed SendMessage, HResult: " + hr.ToString("X"));
					return;
				}

				if( recipients.Length != results.Length )
				{
					Global.RO.Info("Failed to send to all recipients(???).");
					return;
				}

				// Add this MessageID to MessageList so we can pull it for other tests
				MWGlobal.MessageList.Add("BasicSend", results[0].MessageID);

				ConsoleX.WriteLine("Created messageID: " + results[0].MessageID);

				ResultCode = TEST_RESULTS.PASSED;
			}
		}
	
        //helper for SendMaxRecipients
        private static void DoMakeSendMaxRecipientsUser(uint ind, object obj)
        {
            UacsCommon ua = new UacsCommon();

            Owner o = new Owner("MW" + ua.Random.GenerateRandomNameString(10));
            ulong puid = ua.CreateUser(o);

            WCUserAccount wua = new WCUserAccount();

            byte[] webPuid = ua.GenerateWebId(puid);

            if (!(wua.LinkUser(webPuid, true, o)))
            {
                ConsoleX.WriteLine("Could not link gamertag???");
            }
            else
            {
                recipientUsers[ind] = new PuidName(puid, o.gamertag, webPuid);
                Global.RO.Info("recipientUsers[{2}] = new PuidName({0},\"{1}\", ua.GenerateWebId({0}));", puid, o.gamertag, ind);
            }
        }

		// NOTE: This case fails if we don't go through the whole create users process
		[TestCase, Description("SendMAXRecipients")]
		class SendMaxRecipients : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				string[] recipients = new string[ 100 ];

				// need 100 new users for this test
                ParallelRunner.Run(DoMakeSendMaxRecipientsUser, (uint)recipientUsers.Length, 6, 0);

                new SleepInfo("Waiting for cache link", 30000);	

				for(int iUser = 0; iUser < 100; iUser++)
				{
					recipients[iUser] = recipientUsers[iUser].GamerTag;
				}

				WCMessageAttachment[] attachments = new WCMessageAttachment[ 1 ];
				attachments[ 0 ] = new WCMessageAttachment();
				// TODO: Add some attachments in new case

				//WCWebUser user = new WCWebUser();
				//user.GamerTag = MWGlobal.Users[0].GamerTag;
				//user.WebID = MWGlobal.Users[0].WebId;

				WCRecipientResult[] results = null;

				UInt32 hr = service.SendMessage( 
					MWGlobal.Users[0].WebId,						  // Sender
					MWGlobal.Users[0].GamerTag,
					0,                             // SenderContext
					WCMessageFlags.TitleReserved0, // MessageFlags
					400001,                        // SenderTitleID
					60,								// Expire Minutes
					WCMessageType.TitleCustom,    // WCMessageType
					recipients,                   // Recipient IDs
					null,				          // Details
					//null,			              // Strings
					null,		                  // Attachments
					out results );

				if( HResult.Failed( hr ) )
				{
					Global.RO.Info("Failed SendMessage, HResult: " + hr.ToString("X"));
					return;
				}

				if( recipients.Length != results.Length )
				{
					Global.RO.Info("Failed to send to all recipients(???).");
					return;
				}

				for(int i = 0; i < results.Length; i++)
					Global.RO.Info(results[i].User + " : " + results[i].MessageID);


				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		// NOTE: This case fails if we don't go through the whole create users process
		[TestCase, Description("NegSendMaxPlusRecipients")]
		class NegSendMaxPlusRecipients : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				string[] recipients = new string[ 101 ];

				if (recipientUsers[0] == null)
				{
					// need 100 new users for this test
					UacsCommon ua=new UacsCommon();
					for (int i=0; i<recipientUsers.Length; i++)
					{
						Owner o = new Owner("MW" + ua.Random.GenerateRandomNameString(10));
						ulong puid = ua.CreateUser(o);

						WCUserAccount wua = new WCUserAccount();

						byte []webPuid = ua.GenerateWebId(puid);

						if (! (wua.LinkUser(webPuid, true, o)) )
						{
							ConsoleX.WriteLine("Could not link gamertag???");
						}
						else
						{
							recipientUsers[i] = new PuidName(puid, o.gamertag, webPuid);
							Global.RO.Info("recipientUsers[x] = new PuidName({0},\"{1}\", ua.GenerateWebId({0}));", puid, o.gamertag);
						}
					}
				}

				for(int iUser = 0; iUser < 101; iUser++)
				{
					recipients[iUser] = recipientUsers[iUser].GamerTag;
				}

				WCMessageAttachment[] attachments = new WCMessageAttachment[ 1 ];
				attachments[ 0 ] = new WCMessageAttachment();
				// TODO: Add some attachments in new case

				//WCWebUser user = new WCWebUser();
				//user.GamerTag = MWGlobal.Users[0].GamerTag;
				//user.WebID = MWGlobal.Users[0].WebId;

				WCRecipientResult[] results = null;

				UInt32 hr = service.SendMessage( 
					MWGlobal.Users[0].WebId,						  // Sender
					MWGlobal.Users[0].GamerTag,
					0,                             // SenderContext
					WCMessageFlags.TitleReserved0, // MessageFlags
					400001,                        // SenderTitleID
					60,								// Expire Minutes
					WCMessageType.TitleCustom,    // WCMessageType
					recipients,                   // Recipient IDs
					null,				          // Details
					//null,			              // Strings
					null,		                  // Attachments
					out results );

				if( HResult.Succeeded( hr ) )
				{
					Global.RO.Info("Unexpected pass.");
					return;
				}

				if( hr != HResult.E_INVALIDARG )
				{
					Global.RO.Info("Incorrect HRESULT: " + hr.ToString("X") );
					return;
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}


		[TestCase, Description("SendMaxExpireTime")]
		//TODO: This varies by message type according to INI settings in ops -- test around this
		class SendMaxExpireTime : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				string[] recipients = new string[ 1 ];
				recipients[ 0 ] = MWGlobal.Users[2].GamerTag;

				WCMessageDetails smDetails = new WCMessageDetails();
				// TODO: Add some details in new case


				WCMessageAttachment[] attachments = new WCMessageAttachment[ 1 ];
				attachments[ 0 ] = new WCMessageAttachment();
				// TODO: Add some attachments

				//WCWebUser user = new WCWebUser();
				//user.GamerTag = MWGlobal.Users[0].GamerTag;
				//user.WebID = MWGlobal.Users[0].WebId;

				WCRecipientResult[] results = null;

				UInt32 hr = service.SendMessage( 
					MWGlobal.Users[0].WebId,		// Sender
					MWGlobal.Users[0].GamerTag,
					0,                             // SenderContext
					WCMessageFlags.TitleReserved0, // MessageFlags
					400001,                        // SenderTitleID
					ushort.MaxValue,				// Expire Minutes   64800 == 45 days
					WCMessageType.TitleCustom,		// WCMessageType
					recipients,                    // Recipient IDs
					smDetails,                     // Details
					//null,	                       // Strings
					attachments,                   // Attachments
					out results );

				if( HResult.Failed( hr ) )
				{
					Global.RO.Info("Failed SendMessage, HResult: " + hr.ToString("X"));
					return;
				}

				if( recipients.Length != results.Length )
				{
					Global.RO.Info("Failed to send to all recipients(???).");
					return;
				}

				//Add MessageID to list
				MWGlobal.MessageList.Add("MaxExpire", results[0].MessageID);

				ConsoleX.WriteLine("Created messageID: " + results[0].MessageID);

				ResultCode = TEST_RESULTS.PASSED;
			}
		}


		[TestCase, Description("Send MSReserved Flag")]
		class NegSendReservedFlag : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				string[] recipients = new string[ 1 ];
				recipients[ 0 ] = MWGlobal.Users[1].GamerTag;

				WCMessageDetails smDetails = new WCMessageDetails();
				// TODO: Add some details in new case

				WCLocalizedString[] strings = new WCLocalizedString[ 1 ];
				strings[ 0 ] = new WCLocalizedString();

				WCMessageAttachment[] attachments = new WCMessageAttachment[ 1 ];
				attachments[ 0 ] = new WCMessageAttachment();
				// TODO: Add some attachments

				//WCWebUser user = new WCWebUser();
				//user.GamerTag = MWGlobal.Users[1].WebId;
				//user.WebID = MWGlobal.Users[1].WebId;

                //test all reserved flags (note: MSReserved0 through 2 are now in use, so not "reserved" anymore)
                //Xenon bug 34037 made MSReserved0 flag allowed.  1 and 2... happened sometime...
                for (uint rflag = (uint)WCMessageFlags.MSReserved3; ; rflag <<= 1)
                {
                    WCRecipientResult[] results = null;

                    UInt32 hr = service.SendMessage(
                        MWGlobal.Users[0].WebId,		// Sender
                        MWGlobal.Users[0].GamerTag,
                        0,                             // SenderContext
                        (WCMessageFlags)rflag,          // MessageFlags
                        400001,                        // SenderTitleID
                        60,								// Expire Minutes
                        WCMessageType.TitleCustom,		// WCMessageType
                        recipients,                    // Recipient IDs
                        smDetails,                     // Details
                        //strings,                       // Strings
                        attachments,                   // Attachments
                        out results);

                    if (HResult.Succeeded(hr))
                    {
                        Global.RO.Info("Failed NEG SendReservedFlag: sending with MSReserved flag value "+rflag+" succeeded when it shouldn't have");
                        return;
                    }

                    if (rflag == (uint)WCMessageFlags.MSReserved13) break; //13 is the last reserved flag value
                }

				//TODO: Check specific code  0x80070005 ?

				ResultCode = TEST_RESULTS.PASSED;
			}
		}


		[TestCase, Description("Send Type Friend Request Message")]
		class NegSendTypeFriend : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				string[] recipients = new string[ 1 ];
				recipients[ 0 ] = MWGlobal.Users[1].GamerTag;

				WCMessageDetails smDetails = new WCMessageDetails();
				// TODO: Add some details in new case

				WCLocalizedString[] strings = new WCLocalizedString[ 1 ];
				strings[ 0 ] = new WCLocalizedString();

				WCMessageAttachment[] attachments = new WCMessageAttachment[ 1 ];
				attachments[ 0 ] = new WCMessageAttachment();
				// TODO: Add some attachments

				//WCWebUser user = new WCWebUser();
				//user.GamerTag = MWGlobal.Users[1].GamerTag;
				//user.WebID = MWGlobal.Users[1].WebId;

				WCRecipientResult[] results = null;

				UInt32 hr = service.SendMessage( 
					MWGlobal.Users[0].WebId,							// Sender
					MWGlobal.Users[0].GamerTag,
					0,								// SenderContext
					WCMessageFlags.TitleReserved0,	// MessageFlags
					400001,							// SenderTitleID
					60,								// Expire Minutes
					WCMessageType.FriendRequest,	// WCMessageType
					recipients,						// Recipient IDs
					smDetails,						// Details
					//strings,						// Strings
					attachments,					// Attachments
					out results );

				if( HResult.Succeeded( hr ) )
				{
					Global.RO.Info("Failed NEG SendTypeFriend");
					return;
				}

				//TODO: Check specific code  0x80070005 ?

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("Send Type CompRequest Message")]
		class SendTypeCompRequest : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				string[] recipients = new string[ 1 ];
				recipients[ 0 ] = MWGlobal.Users[2].GamerTag;

				//WCWebUser user = new WCWebUser();
				//user.GamerTag = MWGlobal.Users[0].GamerTag;
				//user.WebID = MWGlobal.Users[0].WebId;

				WCRecipientResult[] results = null;

				UInt32 hr = service.SendMessage( 
					MWGlobal.Users[0].WebId,		// Sender
					MWGlobal.Users[0].GamerTag,
					0,								// SenderContext
					0,								// MessageFlags
					400001,							// SenderTitleID
					60,								// Expire Minutes
					WCMessageType.CompRequest,		// WCMessageType
					recipients,						// Recipient IDs
					null,						// Details
					//null,						// Strings
					null,					// Attachments
					out results );

				if( HResult.Failed( hr ) )
				{
					Global.RO.Info("Failed SendMessage, HResult: " + hr.ToString("X"));
					return;
				}

				if( recipients.Length != results.Length )
				{
					Global.RO.Info("Failed to send to all recipients(???).");
					return;
				}

				// Add MessageID to list
				MWGlobal.MessageList.Add("CompRequest", results[0].MessageID);

				ConsoleX.WriteLine("Created messageID: " + results[0].MessageID);

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("Send Type CompReminder Message")]
		class SendTypeCompRemind : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				string[] recipients = new string[ 1 ];
				recipients[ 0 ] = MWGlobal.Users[2].GamerTag;

				//WCWebUser user = new WCWebUser();
				//user.GamerTag = MWGlobal.Users[0].GamerTag;
				//user.WebID = MWGlobal.Users[0].WebId;

				WCRecipientResult[] results = null;

				UInt32 hr = service.SendMessage( 
					MWGlobal.Users[0].WebId,		// Sender
					MWGlobal.Users[0].GamerTag,
					0,								// SenderContext
					0,								// MessageFlags
					400001,							// SenderTitleID
					60,								// Expire Minutes
					WCMessageType.CompReminder,		// WCMessageType
					recipients,						// Recipient IDs
					null,						// Details
					//null,						// Strings
					null,					// Attachments
					out results );

				if( HResult.Failed( hr ) )
				{
					Global.RO.Info("Failed SendMessage, HResult: " + hr.ToString("X"));
					return;
				}

				if( recipients.Length != results.Length )
				{
					Global.RO.Info("Failed to send to all recipients(???).");
					return;
				}

				// Add MessageID to list
				MWGlobal.MessageList.Add("CompRemind", results[0].MessageID);

				ConsoleX.WriteLine("Created messageID: " + results[0].MessageID);

				ResultCode = TEST_RESULTS.PASSED;
			}
		}



		[TestCase, Description("Send Type GameInvite Message")]
		class NegSendTypeInviteMessage : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				string[] recipients = new string[ 1 ];
				recipients[ 0 ] = MWGlobal.Users[1].GamerTag;

				WCMessageDetails smDetails = new WCMessageDetails();
				// TODO: Add some details in new case

				WCLocalizedString[] strings = new WCLocalizedString[ 1 ];
				strings[ 0 ] = new WCLocalizedString();

				WCMessageAttachment[] attachments = new WCMessageAttachment[ 1 ];
				attachments[ 0 ] = new WCMessageAttachment();
				// TODO: Add some attachments

				//WCWebUser user = new WCWebUser();
				//user.GamerTag = MWGlobal.Users[0].GamerTag;
				//user.WebID = MWGlobal.Users[0].WebId;

				WCRecipientResult[] results = null;

				UInt32 hr = service.SendMessage( 
					MWGlobal.Users[0].WebId,	  // Sender
					MWGlobal.Users[0].GamerTag,
					0,                             // SenderContext
					WCMessageFlags.TitleReserved0, // MessageFlags
					400001,                        // SenderTitleID
					60,								// Expire Minutes
					WCMessageType.GameInvite,		// WCMessageType
					recipients,                    // Recipient IDs
					smDetails,                     // Details
					//strings,                       // Strings
					attachments,                   // Attachments
					out results );

				if( HResult.Succeeded( hr ) )
				{
					Global.RO.Info("Failed NEG SendTypeInvite");
					return;
				}

				//TODO: Check specific code  0x80070005 ?

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

	
		[TestCase, Description("Send Invalid Type Message")]
		class NegSendTypeInvalidMessage : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				string[] recipients = new string[ 1 ];
				recipients[ 0 ] = MWGlobal.Users[1].GamerTag;

				WCMessageDetails smDetails = new WCMessageDetails();
				// TODO: Add some details in new case

				WCLocalizedString[] strings = new WCLocalizedString[ 1 ];
				strings[ 0 ] = new WCLocalizedString();

				WCMessageAttachment[] attachments = new WCMessageAttachment[ 1 ];
				attachments[ 0 ] = new WCMessageAttachment();
				// TODO: Add some attachments

				//WCWebUser user = new WCWebUser();
				//user.GamerTag = MWGlobal.Users[1].GamerTag;
				//user.WebID = MWGlobal.Users[1].WebId;

				WCRecipientResult[] results = null;

				UInt32 hr = service.SendMessage( 
					MWGlobal.Users[1].WebId,		// Sender
					MWGlobal.Users[1].GamerTag,
					0,                             // SenderContext
					WCMessageFlags.TitleReserved0, // MessageFlags
					400001,                        // SenderTitleID
					60,								// Expire Minutes
					WCMessageType.Invalid,			// WCMessageType
					recipients,                    // Recipient IDs
					smDetails,                     // Details
					//strings,                       // Strings
					attachments,                   // Attachments
					out results );

				if( HResult.Succeeded( hr ) )
				{
					Global.RO.Info("Failed NEG SendInvalidFlag");
					return;
				}

				//TODO: Check specific code  0x80070005 ?

				ResultCode = TEST_RESULTS.PASSED;
			}
		}


		// THIS TEST CASE IS DEPRECATED -- API no longer accepts strings
		// [TestCase, Description("Send Message String")]
		class SendMessageString : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				string[] recipients = new string[ 1 ];
				recipients[ 0 ] = MWGlobal.Users[2].GamerTag;

				WCLocalizedString[] strings = new WCLocalizedString[ 1 ];
				strings[ 0 ] = new WCLocalizedString();
				strings[0].LangString = new WCLanguageString[1];
				strings[0].LangString[0] = new WCLanguageString();
				strings[0].LangString[0].String = "This is a message string.";
				//strings[0].LangString[0].Language = WCLanguage.English;
				strings[0].LangString[0].Locale = "en-US";
				//strings[0].DefaultLanguage = WCLanguage.English;
				strings[0].DefaultLocale = "en-US";
				strings[0].PropID = 1;



				//WCWebUser user = new WCWebUser();
				//user.GamerTag = MWGlobal.Users[0].GamerTag;
				//user.WebID = MWGlobal.Users[0].WebId;

				WCRecipientResult[] results = null;
				UInt32 hr = service.SendMessage( 
					MWGlobal.Users[0].WebId,		// Sender
					MWGlobal.Users[0].GamerTag,
					0,                             // SenderContext
					WCMessageFlags.TitleReserved0, // MessageFlags
					400001,                        // SenderTitleID
					60,                            // ExpireMinutes
					WCMessageType.TitleCustom,     // MessageType
					recipients,                    // Recipient IDs
					null,	                       // Details
					//strings,                       // Strings
					null,						   // Attachments
					out results );

				if( HResult.Failed( hr ) )
				{
					Global.RO.Info("Failed SendMessage, HResult: " + hr.ToString("X"));
					return;
				}

				if( recipients.Length != results.Length )
				{
					Global.RO.Info("Failed to send to all recipients(???).");
					return;
				}

				// Add MessageID
				MWGlobal.MessageList.Add("MessageString", results[0].MessageID);

				ConsoleX.WriteLine("Created messageID: " + results[0].MessageID);

				ResultCode = TEST_RESULTS.PASSED;
			}
		}


		[TestCase, Description("Send Message Attachment")]
		class SendAttachment : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				string[] recipients = new string[ 1 ];
				recipients[ 0 ] = MWGlobal.Users[2].GamerTag;

				byte[] attachdata = {			// 16 bytes of data
					0x00, 0xFF, 0x01, 0x02,
					0x00, 0xFF, 0x01, 0x02,
					0x00, 0xFF, 0x01, 0x02,
					0x00, 0xFF, 0x01, 0x02			
					};

				WCMessageAttachment[] attach = new WCMessageAttachment[1];
				attach[0] = new WCMessageAttachment();
				attach[0].PropID = 9;
				attach[0].Data = attachdata;
				//attach[0].Data = null
				attach[0].Flags = 0;

				//WCWebUser user = new WCWebUser();
				//user.GamerTag = MWGlobal.Users[0].GamerTag;
				////user.WebID = MWGlobal.Users[0].WebId;

				WCRecipientResult[] results = null;
				UInt32 hr = service.SendMessage( 
					MWGlobal.Users[0].WebId,		// Sender
					MWGlobal.Users[0].GamerTag,
					0,                             // SenderContext
					WCMessageFlags.TitleReserved0, // MessageFlags
					400001,                        // SenderTitleID
					60,                            // ExpireMinutes
					WCMessageType.TitleCustom,     // MessageType
					recipients,                    // Recipient IDs
					null,	                       // Details
					//null,	                       // Strings
					attach,						   // Attachments
					out results );

				if( HResult.Failed( hr ) )
				{
					Global.RO.Info("Failed SendMessage, HResult: " + hr.ToString("X"));
					return;
				}

				if( recipients.Length != results.Length )
				{
					Global.RO.Info("Failed to send to all recipients(???).");
					return;
				}

				// Add MessageID
				MWGlobal.MessageList.Add("MessageAttachment", results[0].MessageID);

				ConsoleX.WriteLine("Created messageID: " + results[0].MessageID);

				ResultCode = TEST_RESULTS.PASSED;
			}
		}


		//TODO: Test case that sends random details

		[TestCase, Description("Send Details StringID")]
		class SendDetailsStringID : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				string[] recipients = new string[ 1 ];
				recipients[ 0 ] = MWGlobal.Users[2].GamerTag;

				WCMessageDetails smDetails = new WCMessageDetails();
				smDetails.StringIdProp = new WCStringIdProp[1];
				smDetails.StringIdProp[0] = new WCStringIdProp();
				smDetails.StringIdProp[0].Value = 1;
				smDetails.StringIdProp[0].PropID = 1;

				WCLocalizedString[] strings = new WCLocalizedString[ 1 ];
				strings[ 0 ] = new WCLocalizedString();

				WCMessageAttachment[] attachments = new WCMessageAttachment[ 1 ];
				attachments[ 0 ] = new WCMessageAttachment();
				// TODO: Add some attachments

				//WCWebUser user = new WCWebUser();
				//user.GamerTag = MWGlobal.Users[0].GamerTag;
				//user.WebID = MWGlobal.Users[0].WebId;

				WCRecipientResult[] results = null;
				UInt32 hr = service.SendMessage( 
					MWGlobal.Users[0].WebId,		// Sender
					MWGlobal.Users[0].GamerTag,
					0,                             // SenderContext
					WCMessageFlags.TitleReserved0, // MessageFlags
					400001,                        // SenderTitleID
					60,                            // ExpireMinutes
					WCMessageType.TitleCustom,     // MessageType
					recipients,                    // Recipient IDs
					smDetails,                     // Details
					//strings,                       // Strings
					attachments,                   // Attachments
					out results );

				if( HResult.Failed( hr ) )
				{
					Global.RO.Info("Failed SendMessage, HResult: " + hr.ToString("X"));
					return;
				}

				if( recipients.Length != results.Length )
				{
					Global.RO.Info("Failed to send to all recipients(???).");
					return;
				}

				// Add this MessageID to MessageList so we can pull it for other tests
				MWGlobal.MessageList.Add("DetailsStringID", results[0].MessageID);

				ConsoleX.WriteLine("Created messageID: " + results[0].MessageID);

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("Send Details Bool")]
		class SendDetailsBool : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				string[] recipients = new string[ 1 ];
				recipients[ 0 ] = MWGlobal.Users[2].GamerTag;

				WCMessageDetails smDetails = new WCMessageDetails();
				smDetails.BoolProp = new WCBoolProp[1];
				smDetails.BoolProp[0] = new WCBoolProp();
				smDetails.BoolProp[0].PropID = 11;
				smDetails.BoolProp[0].Value = true;

				WCLocalizedString[] strings = new WCLocalizedString[ 1 ];
				strings[ 0 ] = new WCLocalizedString();

				WCMessageAttachment[] attachments = new WCMessageAttachment[ 1 ];
				attachments[ 0 ] = new WCMessageAttachment();
				// TODO: Add some attachments

				//WCWebUser user = new WCWebUser();
				//user.GamerTag = MWGlobal.Users[0].GamerTag;
				//user.WebID = MWGlobal.Users[0].WebId;

				WCRecipientResult[] results = null;
				UInt32 hr = service.SendMessage( 
					MWGlobal.Users[0].WebId,		// Sender
					MWGlobal.Users[0].GamerTag,
					0,                             // SenderContext
					WCMessageFlags.TitleReserved0, // MessageFlags
					400001,                        // SenderTitleID
					60,                            // ExpireMinutes
					WCMessageType.TitleCustom,     // MessageType
					recipients,                    // Recipient IDs
					smDetails,                     // Details
					//strings,                       // Strings
					attachments,                   // Attachments
					out results );

				if( HResult.Failed( hr ) )
				{
					Global.RO.Info("Failed SendMessage, HResult: " + hr.ToString("X"));
					return;
				}

				if( recipients.Length != results.Length )
				{
					Global.RO.Info("Failed to send to all recipients(???).");
					return;
				}

				// Add this MessageID to MessageList so we can pull it for other tests
				MWGlobal.MessageList.Add("DetailsBool", results[0].MessageID);

				ConsoleX.WriteLine("Created messageID: " + results[0].MessageID);

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("Send Details Attach")]
		class SendDetailsAttach : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				string[] recipients = new string[ 1 ];
				recipients[ 0 ] = MWGlobal.Users[2].GamerTag;

				WCMessageDetails smDetails = new WCMessageDetails();
				smDetails.AttachmentProp = new WCAttachmentProp[1];
				smDetails.AttachmentProp[0] = new WCAttachmentProp();
				smDetails.AttachmentProp[0].PropID = 22;
				smDetails.AttachmentProp[0].AttachFlags = WCAttachFlags.NonExportable;
				smDetails.AttachmentProp[0].AttachSize = 0;
				smDetails.AttachmentProp[0].AttachUrl = "http://somefakeurl/testcase.html";

				WCLocalizedString[] strings = new WCLocalizedString[ 1 ];
				strings[ 0 ] = new WCLocalizedString();

				WCMessageAttachment[] attachments = new WCMessageAttachment[ 1 ];
				attachments[ 0 ] = new WCMessageAttachment();
				// TODO: Add some attachments

				//WCWebUser user = new WCWebUser();
				//user.GamerTag = MWGlobal.Users[0].GamerTag;
				//user.WebID = MWGlobal.Users[0].WebId;

				WCRecipientResult[] results = null;
				UInt32 hr = service.SendMessage( 
					MWGlobal.Users[0].WebId,		// Sender
					MWGlobal.Users[0].GamerTag,
					0,                             // SenderContext
					WCMessageFlags.TitleReserved0, // MessageFlags
					400001,                        // SenderTitleID
					60,                            // ExpireMinutes
					WCMessageType.TitleCustom,     // MessageType
					recipients,                    // Recipient IDs
					smDetails,                     // Details
					//strings,                       // Strings
					attachments,                   // Attachments
					out results );

				if( HResult.Failed( hr ) )
				{
					Global.RO.Info("Failed SendMessage, HResult: " + hr.ToString("X"));
					return;
				}

				if( recipients.Length != results.Length )
				{
					Global.RO.Info("Failed to send to all recipients(???).");
					return;
				}

				// Add this MessageID to MessageList so we can pull it for other tests
				MWGlobal.MessageList.Add("DetailsAttachment", results[0].MessageID);

				ConsoleX.WriteLine("Created messageID: " + results[0].MessageID);

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("Send Details String")]
		class SendDetailsString : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				string[] recipients = new string[ 1 ];
				recipients[ 0 ] = MWGlobal.Users[2].GamerTag;

				WCMessageDetails smDetails = new WCMessageDetails();
				smDetails.StringProp = new WCStringProp[1];
				smDetails.StringProp[0] = new WCStringProp();
				smDetails.StringProp[0].PropID = 0xFF;
				smDetails.StringProp[0].Value = "Test case string.";

				WCMessageAttachment[] attachments = new WCMessageAttachment[ 1 ];
				attachments[ 0 ] = new WCMessageAttachment();
				// TODO: Add some attachments

				//WCWebUser user = new WCWebUser();
				//user.GamerTag = MWGlobal.Users[0].GamerTag;
				//user.WebID = MWGlobal.Users[0].WebId;

				WCRecipientResult[] results = null;
				UInt32 hr = service.SendMessage( 
					MWGlobal.Users[0].WebId,		// Sender
					MWGlobal.Users[0].GamerTag,
					0,                             // SenderContext
					WCMessageFlags.TitleReserved0, // MessageFlags
					400001,                        // SenderTitleID
					60,                            // ExpireMinutes
					WCMessageType.TitleCustom,     // MessageType
					recipients,                    // Recipient IDs
					smDetails,                     // Details
					//strings,                       // Strings
					attachments,                   // Attachments
					out results );

				if( HResult.Failed( hr ) )
				{
					Global.RO.Info("Failed SendMessage, HResult: " + hr.ToString("X"));
					return;
				}

				if( recipients.Length != results.Length )
				{
					Global.RO.Info("Failed to send to all recipients(???).");
					return;
				}

				// Add this MessageID to MessageList so we can pull it for other tests
				MWGlobal.MessageList.Add("DetailsString", results[0].MessageID);

				ConsoleX.WriteLine("Created messageID: " + results[0].MessageID);

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

        [TestCase, Description("Send Details Personal Message")]
        class SendDetailsPersonalMessage : TestBase
        {
            protected override void Execute()
            {
                WCMessaging service = new WCMessaging();

                string[] recipients = new string[1];
                recipients[0] = MWGlobal.Users[2].GamerTag;

                WCMessageDetails smDetails = new WCMessageDetails();
                smDetails.StringProp = new WCStringProp[1];
                smDetails.StringProp[0] = new WCStringProp();
                smDetails.StringProp[0].PropID = 0xFF;
                smDetails.StringProp[0].Value = "Test case string.";

                WCMessageAttachment[] attachments = new WCMessageAttachment[1];
                attachments[0] = new WCMessageAttachment();
                // TODO: Add some attachments

                //WCWebUser user = new WCWebUser();
                //user.GamerTag = MWGlobal.Users[0].GamerTag;
                //user.WebID = MWGlobal.Users[0].WebId;

                WCRecipientResult[] results = null;
                UInt32 hr = service.SendMessage(
                    MWGlobal.Users[0].WebId,		// Sender
                    MWGlobal.Users[0].GamerTag,
                    0,                             // SenderContext
                    WCMessageFlags.TitleReserved0, // MessageFlags
                    400001,                        // SenderTitleID
                    60,                            // ExpireMinutes
                    WCMessageType.PersonalMessage,     // MessageType
                    recipients,                    // Recipient IDs
                    smDetails,                     // Details
                    //strings,                       // Strings
                    attachments,                   // Attachments
                    out results);

                if (HResult.Failed(hr))
                {
                    Global.RO.Info("Failed SendMessage, HResult: " + hr.ToString("X"));
                    return;
                }

                if (recipients.Length != results.Length)
                {
                    Global.RO.Info("Failed to send to all recipients(???).");
                    return;
                }

                // Add this MessageID to MessageList so we can pull it for other tests
                MWGlobal.MessageList.Add("PersonalMessage", results[0].MessageID);

                ConsoleX.WriteLine("Created messageID: " + results[0].MessageID);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

		[TestCase, Description("Send Details Binary")]
			class SendDetailsBinary : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				string[] recipients = new string[ 1 ];
				recipients[ 0 ] = MWGlobal.Users[2].GamerTag;

				byte[] testdata = { 0x00, 0xFF, 0x01, 0x02, 0x03 };

				WCMessageDetails smDetails = new WCMessageDetails();
				smDetails.BinaryProp = new WCBinaryProp[1];
				smDetails.BinaryProp[0] = new WCBinaryProp();
				smDetails.BinaryProp[0].PropID = 0xFF;
				smDetails.BinaryProp[0].Value = testdata;


				WCLocalizedString[] strings = new WCLocalizedString[ 1 ];
				strings[ 0 ] = new WCLocalizedString();

				WCMessageAttachment[] attachments = new WCMessageAttachment[ 1 ];
				attachments[ 0 ] = new WCMessageAttachment();
				// TODO: Add some attachments

				//WCWebUser user = new WCWebUser();
				//user.GamerTag = MWGlobal.Users[0].GamerTag;
				//user.WebID = MWGlobal.Users[0].WebId;

				WCRecipientResult[] results = null;
				UInt32 hr = service.SendMessage( 
					MWGlobal.Users[0].WebId,		// Sender
					MWGlobal.Users[0].GamerTag,
					0,                             // SenderContext
					WCMessageFlags.TitleReserved0, // MessageFlags
					400001,                        // SenderTitleID
					60,                            // ExpireMinutes
					WCMessageType.TitleCustom,     // MessageType
					recipients,                    // Recipient IDs
					smDetails,                     // Details
					//strings,                       // Strings
					attachments,                   // Attachments
					out results );

				if( HResult.Failed( hr ) )
				{
					Global.RO.Info("Failed SendMessage, HResult: " + hr.ToString("X"));
					return;
				}

				if( recipients.Length != results.Length )
				{
					Global.RO.Info("Failed to send to all recipients(???).");
					return;
				}

				// Add this MessageID to MessageList so we can pull it for other tests
				MWGlobal.MessageList.Add("DetailsBinary", results[0].MessageID);

				ConsoleX.WriteLine("Created messageID: " + results[0].MessageID);

				ResultCode = TEST_RESULTS.PASSED;
			}
		}


		[TestCase, Description("Send Details Qword")]
		class SendDetailsQword : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				string[] recipients = new string[ 1 ];
				recipients[ 0 ] = MWGlobal.Users[2].GamerTag;

				WCMessageDetails smDetails = new WCMessageDetails();
				smDetails.QwordProp = new WCQwordProp[4];
				smDetails.QwordProp[0] = new WCQwordProp();
				smDetails.QwordProp[0].PropID = 0xFF;
				smDetails.QwordProp[0].Value = UInt64.MinValue;
				smDetails.QwordProp[1] = new WCQwordProp();
				smDetails.QwordProp[1].PropID = 0xFE;	
				smDetails.QwordProp[1].Value = UInt64.MaxValue;
				smDetails.QwordProp[2] = new WCQwordProp();
				smDetails.QwordProp[2].PropID = 0xFD;	
				smDetails.QwordProp[2].Value = 0;
				smDetails.QwordProp[3] = new WCQwordProp();
				smDetails.QwordProp[3].PropID = 0xFC;	
				smDetails.QwordProp[3].Value = 1111;

				WCLocalizedString[] strings = new WCLocalizedString[ 1 ];
				strings[ 0 ] = new WCLocalizedString();

				WCMessageAttachment[] attachments = new WCMessageAttachment[ 1 ];
				attachments[ 0 ] = new WCMessageAttachment();
				// TODO: Add some attachments

				//WCWebUser user = new WCWebUser();
				//user.GamerTag = MWGlobal.Users[0].GamerTag;
				//user.WebID = MWGlobal.Users[0].WebId;

				WCRecipientResult[] results = null;
				UInt32 hr = service.SendMessage( 
					MWGlobal.Users[0].WebId,		// Sender
					MWGlobal.Users[0].GamerTag,
					0,                             // SenderContext
					WCMessageFlags.TitleReserved0, // MessageFlags
					400001,                        // SenderTitleID
					60,                            // ExpireMinutes
					WCMessageType.TitleCustom,     // MessageType
					recipients,                    // Recipient IDs
					smDetails,                     // Details
					//strings,                       // Strings
					attachments,                   // Attachments
					out results );

				if( HResult.Failed( hr ) )
				{
					Global.RO.Info("Failed SendMessage, HResult: " + hr.ToString("X"));
					return;
				}

				if( recipients.Length != results.Length )
				{
					Global.RO.Info("Failed to send to all recipients(???).");
					return;
				}

				// Add this MessageID to MessageList so we can pull it for other tests
				MWGlobal.MessageList.Add("DetailsQword", results[0].MessageID);

				ConsoleX.WriteLine("Created messageID: " + results[0].MessageID);

				ResultCode = TEST_RESULTS.PASSED;
			}
		}



		[TestCase, Description("Send Details DWord")]
		class SendDetailsDWord : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				string[] recipients = new string[ 1 ];
				recipients[ 0 ] = MWGlobal.Users[2].GamerTag;

				WCMessageDetails smDetails = new WCMessageDetails();
				smDetails.DwordProp = new WCDwordProp[4];
				smDetails.DwordProp[0] = new WCDwordProp();
				smDetails.DwordProp[0].PropID =  0xFF;
				smDetails.DwordProp[0].Value = (UInt32) 1111;
				smDetails.DwordProp[1] = new WCDwordProp();
				smDetails.DwordProp[1].PropID = 0xFE;	
				smDetails.DwordProp[1].Value = (UInt32) 2222;
				smDetails.DwordProp[2] = new WCDwordProp();
				smDetails.DwordProp[2].PropID = 0xFD;	
				smDetails.DwordProp[2].Value = (UInt32) 3333;
				smDetails.DwordProp[3] = new WCDwordProp();
				smDetails.DwordProp[3].PropID = 0xFC;	
				smDetails.DwordProp[3].Value = (UInt32) 4444;

				WCLocalizedString[] strings = new WCLocalizedString[ 1 ];
				strings[ 0 ] = new WCLocalizedString();

				WCMessageAttachment[] attachments = new WCMessageAttachment[ 1 ];
				attachments[ 0 ] = new WCMessageAttachment();
				// TODO: Add some attachments

				//WCWebUser user = new WCWebUser();
				//user.GamerTag = MWGlobal.Users[0].GamerTag;
				//user.WebID = MWGlobal.Users[0].WebId;

				WCRecipientResult[] results = null;
				UInt32 hr = service.SendMessage( 
					MWGlobal.Users[0].WebId,		// Sender
					MWGlobal.Users[0].GamerTag,
					0,                             // SenderContext
					WCMessageFlags.TitleReserved0, // MessageFlags
					400001,                        // SenderTitleID
					60,                            // ExpireMinutes
					WCMessageType.TitleCustom,     // MessageType
					recipients,                    // Recipient IDs
					smDetails,                     // Details
					//strings,                       // Strings
					attachments,                   // Attachments
					out results );

				if( HResult.Failed( hr ) )
				{
					Global.RO.Info("Failed SendMessage, HResult: " + hr.ToString("X"));
					return;
				}

				if( recipients.Length != results.Length )
				{
					Global.RO.Info("Failed to send to all recipients(???).");
					return;
				}

				// Add this MessageID to MessageList so we can pull it for other tests
				MWGlobal.MessageList.Add("DetailsDword", results[0].MessageID);

				ConsoleX.WriteLine("Created messageID: " + results[0].MessageID);

				ResultCode = TEST_RESULTS.PASSED;
			}
		}


		[TestCase, Description("Send Details Byte")]
		class SendDetailsByte : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				string[] recipients = new string[ 1 ];
				recipients[ 0 ] = MWGlobal.Users[2].GamerTag;

				WCMessageDetails smDetails = new WCMessageDetails();
				smDetails.ByteProp = new WCByteProp[1];
				smDetails.ByteProp[0] = new WCByteProp();
				smDetails.ByteProp[0].PropID = 1;
				smDetails.ByteProp[0].Value = 0xFF;

				WCLocalizedString[] strings = new WCLocalizedString[ 1 ];
				strings[ 0 ] = new WCLocalizedString();

				WCMessageAttachment[] attachments = new WCMessageAttachment[ 1 ];
				attachments[ 0 ] = new WCMessageAttachment();
				// TODO: Add some attachments

				//WCWebUser user = new WCWebUser();
				//user.GamerTag = MWGlobal.Users[0].GamerTag;
				//user.WebID = MWGlobal.Users[0].WebId;

				WCRecipientResult[] results = null;
				UInt32 hr = service.SendMessage( 
					MWGlobal.Users[0].WebId,		// Sender
					MWGlobal.Users[0].GamerTag,
					0,                             // SenderContext
					WCMessageFlags.TitleReserved0, // MessageFlags
					400001,                        // SenderTitleID
					60,                            // ExpireMinutes
					WCMessageType.TitleCustom,     // MessageType
					recipients,                    // Recipient IDs
					smDetails,                     // Details
					//strings,                       // Strings
					attachments,                   // Attachments
					out results );

				if( HResult.Failed( hr ) )
				{
					Global.RO.Info("Failed SendMessage, HResult: " + hr.ToString("X"));
					return;
				}

				if( recipients.Length != results.Length )
				{
					Global.RO.Info("Failed to send to all recipients(???).");
					return;
				}

				// Add this MessageID to MessageList so we can pull it for other tests
				MWGlobal.MessageList.Add("DetailsByte", results[0].MessageID);

				ConsoleX.WriteLine("Created messageID: " + results[0].MessageID);

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("Send Details Word")]
		class SendDetailsWord : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				string[] recipients = new string[ 1 ];
				recipients[ 0 ] = MWGlobal.Users[2].GamerTag;

				WCMessageDetails smDetails = new WCMessageDetails();
				smDetails.WordProp = new WCWordProp[1];
				smDetails.WordProp[0] = new WCWordProp();
				smDetails.WordProp[0].PropID = 1;
				smDetails.WordProp[0].Value = UInt16.MaxValue;

				WCLocalizedString[] strings = new WCLocalizedString[ 1 ];
				strings[ 0 ] = new WCLocalizedString();

				WCMessageAttachment[] attachments = new WCMessageAttachment[ 1 ];
				attachments[ 0 ] = new WCMessageAttachment();
				// TODO: Add some attachments

				//WCWebUser user = new WCWebUser();
				//user.GamerTag = MWGlobal.Users[0].GamerTag;
				//user.WebID = MWGlobal.Users[0].WebId;

				WCRecipientResult[] results = null;
				UInt32 hr = service.SendMessage( 
					MWGlobal.Users[0].WebId,		// Sender
					MWGlobal.Users[0].GamerTag,
					0,                             // SenderContext
					WCMessageFlags.TitleReserved0, // MessageFlags
					400001,                        // SenderTitleID
					60,                            // ExpireMinutes
					WCMessageType.TitleCustom,     // MessageType
					recipients,                    // Recipient IDs
					smDetails,                     // Details
					//strings,                       // Strings
					attachments,                   // Attachments
					out results );

				if( HResult.Failed( hr ) )
				{
					Global.RO.Info("Failed SendMessage, HResult: " + hr.ToString("X"));
					return;
				}

				if( recipients.Length != results.Length )
				{
					Global.RO.Info("Failed to send to all recipients(???).");
					return;
				}

				// Add this MessageID to MessageList so we can pull it for other tests
				MWGlobal.MessageList.Add("DetailsWord", results[0].MessageID);

				ConsoleX.WriteLine("Created messageID: " + results[0].MessageID);

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("NegRepeatedPropID")]
		class NegRepeatedPropID : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				string[] recipients = new string[ 1 ];
				recipients[ 0 ] = MWGlobal.Users[2].GamerTag;

				WCMessageDetails smDetails = new WCMessageDetails();
				smDetails.DwordProp = new WCDwordProp[2];
				smDetails.DwordProp[0] = new WCDwordProp();
				smDetails.DwordProp[0].PropID = 2;
				smDetails.DwordProp[0].Value = (UInt32) 1111;
				smDetails.DwordProp[1] = new WCDwordProp();
				smDetails.DwordProp[1].PropID = 2;	
				smDetails.DwordProp[1].Value = (UInt32) 2222;

				WCLocalizedString[] strings = new WCLocalizedString[ 1 ];
				strings[ 0 ] = new WCLocalizedString();

				WCMessageAttachment[] attachments = new WCMessageAttachment[ 1 ];
				attachments[ 0 ] = new WCMessageAttachment();
				// TODO: Add some attachments

				//WCWebUser user = new WCWebUser();
				//user.GamerTag = MWGlobal.Users[0].GamerTag;
				//user.WebID = MWGlobal.Users[0].WebId;

				WCRecipientResult[] results = null;
				UInt32 hr = service.SendMessage( 
					MWGlobal.Users[0].WebId,		// Sender
					MWGlobal.Users[0].GamerTag,
					0,                             // SenderContext
					WCMessageFlags.TitleReserved0, // MessageFlags
					400001,                        // SenderTitleID
					60,                            // ExpireMinutes
					WCMessageType.TitleCustom,     // MessageType
					recipients,                    // Recipient IDs
					smDetails,                     // Details
					//strings,                       // Strings
					attachments,                   // Attachments
					out results );

				if( hr != HResult.E_INVALIDARG )
				{
					Global.RO.Info("Unexpected HResult: " + hr.ToString("X") );
					return;
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}


		[TestCase, Description("NegRepeatedPropID2")]
			class NegRepeatedPropID2 : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				string[] recipients = new string[ 1 ];
				recipients[ 0 ] = MWGlobal.Users[2].GamerTag;

				// Create two properties with the same ID as different types
				WCMessageDetails smDetails = new WCMessageDetails();
				smDetails.DwordProp = new WCDwordProp[1];
				smDetails.DwordProp[0] = new WCDwordProp();
				smDetails.DwordProp[0].PropID = 1;
				smDetails.DwordProp[0].Value = (UInt32) 1111;

				smDetails.ByteProp = new WCByteProp[1];
				smDetails.ByteProp[0] = new WCByteProp();
				smDetails.ByteProp[0].PropID = 1;    //  same ID as above, but with byte type
				smDetails.ByteProp[0].Value = 0x01;


				//WCWebUser user = new WCWebUser();
				//user.GamerTag = MWGlobal.Users[0].GamerTag;
				//user.WebID = MWGlobal.Users[0].WebId;

				WCRecipientResult[] results = null;
				UInt32 hr = service.SendMessage( 
					MWGlobal.Users[0].WebId,		// Sender
					MWGlobal.Users[0].GamerTag,
					0,                             // SenderContext
					WCMessageFlags.TitleReserved0, // MessageFlags
					400001,                        // SenderTitleID
					60,                            // ExpireMinutes
					WCMessageType.TitleCustom,     // MessageType
					recipients,                    // Recipient IDs
					smDetails,                     // Details
					//null,                       // Strings
					null,                   // Attachments
					out results );

				if( hr != HResult.E_INVALIDARG )
				{
					Global.RO.Info("Unexpected HResult: " + hr.ToString("X") );
					return;
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("SendMaxDetails")]
			class SendMaxDetails : TestBase
		{
			protected override void Execute()
			{
				//TODO: Test case to finish

				//return;
				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("NegNullUser")]
		class NegNullUser : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				string[] recipients = new string[ 1 ];
				recipients[ 0 ] = MWGlobal.Users[1].GamerTag;

				//WCWebUser user = new WCWebUser();
				//user.GamerTag = null;
				//user.WebID = MWGlobal.Users[0].WebId;

				WCRecipientResult[] results = null;

				try 
				{

					UInt32 hr = service.SendMessage( 
						MWGlobal.Users[0].WebId,		// Sender
						null,
						0,                             // SenderContext
						0,								// MessageFlags
						400001,                        // SenderTitleID
						60,								// Expire Minutes
						WCMessageType.TitleCustom,		// WCMessageType
						recipients,                    // Recipient IDs
						null,                     // Details
						//null,                       // Strings
						null,                   // Attachments
						out results );

					if( HResult.Succeeded( hr ) )
					{
						Global.RO.Info("Unexpected pass.");
						return;
					}
				}
				catch(SoapException e)
				{
					// normal
					//TODO: check for code when this is fixed
					Global.RO.Info(e.Message);

				}

				// now try null WebID
				//user.GamerTag = MWGlobal.Users[0].GamerTag;
				//user.WebID = null;
				try 
				{

					UInt32 hr = service.SendMessage( 
						null,	  // Sender
						MWGlobal.Users[0].GamerTag,
						0,                             // SenderContext
						0,								// MessageFlags
						400001,                        // SenderTitleID
						60,								// Expire Minutes
						WCMessageType.TitleCustom,		// WCMessageType
						recipients,                    // Recipient IDs
						null,                     // Details
						//null,                       // Strings
						null,                   // Attachments
						out results );

					if( HResult.Succeeded( hr ) )
					{
						Global.RO.Info("Unexpected pass.");
						return;
					}
				}
				catch(SoapException e)
				{
					// normal
					//TODO: check for code when this is fixed
					Global.RO.Info(e.Message);

				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("NegUnknownUser")]
		class NegUnknownUser : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				string[] recipients = new string[ 1 ];
				recipients[ 0 ] = MWGlobal.Users[1].GamerTag;

				//WCWebUser user = new WCWebUser();
				//user.GamerTag = RandomEx.GlobalRandGen.GenerateRandomString(15);
				//user.WebID = MWGlobal.Users[0].WebId;

				WCRecipientResult[] results = null;

				try 
				{

					UInt32 hr = service.SendMessage( 
						MWGlobal.Users[0].WebId,
						RandomEx.GlobalRandGen.GenerateRandomString(15),	// Sender
						0,                             // SenderContext
						0,								// MessageFlags
						400001,                        // SenderTitleID
						60,								// Expire Minutes
						WCMessageType.TitleCustom,		// WCMessageType
						recipients,                    // Recipient IDs
						null,                     // Details
						//null,                       // Strings
						null,                   // Attachments
						out results );

					if( HResult.Succeeded( hr ) )
					{
						Global.RO.Info("Unexpected pass.");
						return;
					}
				}
				catch(SoapException e)
				{
					Global.RO.Info(e.Message);
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("NegMismatchedUser")]
		class NegMismatchedUser : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				string[] recipients = new string[ 1 ];
				recipients[ 0 ] = MWGlobal.Users[1].GamerTag;

				//WCWebUser user = new WCWebUser();
				//user.GamerTag = MWGlobal.Users[1].GamerTag;		// User 1, Web ID 0
				//user.WebID = MWGlobal.Users[0].WebId;

				WCRecipientResult[] results = null;

				try 
				{

					UInt32 hr = service.SendMessage( 
						MWGlobal.Users[1].WebId,						  // Sender
						MWGlobal.Users[0].GamerTag,
						0,                             // SenderContext
						0,								// MessageFlags
						400001,                        // SenderTitleID
						60,								// Expire Minutes
						WCMessageType.TitleCustom,		// WCMessageType
						recipients,                    // Recipient IDs
						null,                     // Details
						//null,                       // Strings
						null,                   // Attachments
						out results );

					if( HResult.Succeeded( hr ) )
					{
						Global.RO.Info("Unexpected pass.");
						return;
					}
				}
				catch(SoapException e)
				{
					Global.RO.Info(e.Message);
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}
	
		[TestCase, Description("NegBadWebID")]
		class NegBadWebID : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging();
             
				string[] recipients = new string[ 1 ];
				recipients[ 0 ] = MWGlobal.Users[1].GamerTag;

				// unknown 8-byte ID
				byte[] badID = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
				// 10-byte ID
				byte[] badID2 = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x0B };
				// 4-byte ID
				byte[] badID3 = { 0x01, 0x02, 0x03, 0x04 };

				//WCWebUser user = new WCWebUser();
				//user.GamerTag = MWGlobal.Users[1].GamerTag;	
				//user.WebID = badID;

				WCRecipientResult[] results = null;

				try 
				{

					UInt32 hr = service.SendMessage( 
						badID,
						MWGlobal.Users[1].GamerTag,						  // Sender
						0,                             // SenderContext
						0,								// MessageFlags
						400001,                        // SenderTitleID
						60,								// Expire Minutes
						WCMessageType.TitleCustom,		// WCMessageType
						recipients,                    // Recipient IDs
						null,                     // Details
						//null,                       // Strings
						null,                   // Attachments
						out results );

					if( HResult.Succeeded( hr ) )
					{
						Global.RO.Info("Unexpected pass.");
						return;
					}
				}
				catch(SoapException e)
				{
					Global.RO.Info(e.Message);
				}

				//user.WebID = badID2;
				try 
				{

					UInt32 hr = service.SendMessage( 
						badID2,
						MWGlobal.Users[1].GamerTag,						  // Sender
						0,                             // SenderContext
						0,								// MessageFlags
						400001,                        // SenderTitleID
						60,								// Expire Minutes
						WCMessageType.TitleCustom,		// WCMessageType
						recipients,                    // Recipient IDs
						null,                     // Details
						//null,                       // Strings
						null,                   // Attachments
						out results );

					if( HResult.Succeeded( hr ) )
					{
						Global.RO.Info("Unexpected pass.");
						return;
					}
				}
				catch(SoapException e)
				{
					Global.RO.Info(e.Message);
				}

				//user.WebID = badID3;
				try 
				{

					UInt32 hr = service.SendMessage( 
						badID3,							// Sender
						MWGlobal.Users[1].GamerTag,
						0,                             // SenderContext
						0,								// MessageFlags
						400001,                        // SenderTitleID
						60,								// Expire Minutes
						WCMessageType.TitleCustom,		// WCMessageType
						recipients,                    // Recipient IDs
						null,                     // Details
						//null,                       // Strings
						null,                   // Attachments
						out results );

					if( HResult.Succeeded( hr ) )
					{
						Global.RO.Info("Unexpected pass.");
						return;
					}
				}
				catch(SoapException e)
				{
					Global.RO.Info(e.Message);
				}				

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\misc\mgmt\ManagementConsole.cs ===
//
// ManagementConsole.cs
//
// A class for sending management commands. Ripped off from the test framework.
//
// Copyright (C) Microsoft Corporation.  All Rights Reserved.
//

using System;
using System.Net.Sockets;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;

public class ManagementConsole
{
    private const int MGMT_TIMEOUT = 5000;
    private const int MGMT_PORT    = 4100;
    static Regex regexSize = new Regex(@"Size=(?<size>[^/n]*)");
    
    static public string Execute(string target, string command)
    {
        command += "\n";

        //
        //  Set five second send and receive timeouts so we don't hang on management commands.
        //

        TcpClient client      = new TcpClient();        
        client.SendTimeout    = MGMT_TIMEOUT;
        client.ReceiveTimeout = MGMT_TIMEOUT;
        client.NoDelay        = true;
        
        client.Connect(target, MGMT_PORT);

        try
        {
            NetworkStream stream = client.GetStream();
            TextReader    reader = new StreamReader(stream);

            if (!(stream.CanWrite && stream.CanRead))
                throw new Exception("Management command failed, can't read or write network stream");

            byte[] sendBytes = Encoding.ASCII.GetBytes(command);

            stream.Write(sendBytes, 0, sendBytes.Length);

            string t     = reader.ReadLine();
            Match  match = regexSize.Match(t);
            
            if (match.Length == 0)
            {
                // Size line not parsed, this must be an error
                throw new Exception("Management command failed, couldn't parse size.");
            }
            
            int    dataLength = Convert.ToInt32(match.Groups[1].Value);
            char[] buffer     = new char[dataLength];

            reader.Read(buffer, 0, dataLength);
            StringBuilder SB = new StringBuilder(dataLength);
            SB.Append(buffer);
            
            return SB.ToString();
        }
        finally
        {
            client.Close();
        }        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\misc\FormatGen\FormatGen.cs ===
//
// FormatGen.cs
//
// Test dynamic compilation of format strings
//
// Copyright (C) Microsoft Corporation.  All Rights Reserved.
//

using System;
using System.Diagnostics;
using System.Collections;
using System.IO;
using System.Reflection;
using System.CodeDom;
using System.CodeDom.Compiler;
using Microsoft.CSharp;


public interface IStatsAttributeCollection
{
    object this[int index]
    {
        get;
    }
}

public interface IStatsFormatter
{
    object Format(IStatsAttributeCollection attr);
}   

[Serializable]
class StatsAttributeCollection : IStatsAttributeCollection
{
    public object this[int index]
    {
        get { return index; }
    }
}

[Serializable]
class FormatAppDomainLoader : MarshalByRefObject
{
    public static FormatAppDomainLoader CreateFormatLoader(AppDomain ad)
    {
        FormatAppDomainLoader loader;
        Assembly              asm = Assembly.GetExecutingAssembly();

        loader = (FormatAppDomainLoader)ad.CreateInstanceAndUnwrap(asm.FullName, "FormatAppDomainLoader");
        return loader;
    }

    public void SetFormats(string[] formats)
    {
        this.formats = formats;

        string[] formatters = new string[formats.Length];
        for (int i = 0; i < formats.Length; i++)
            formatters[i] = String.Format(FormatClass, i, formats[i]);

        formatSource = String.Join("\n", formatters);
        Console.WriteLine(formatSource);
    }

    public void BuildAssembly()
    {
        CSharpCodeProvider cscp = new CSharpCodeProvider();
        ICodeCompiler      csc  = cscp.CreateCompiler();
        CompilerParameters csp  = new CompilerParameters();

        csp.GenerateExecutable      = false;
        csp.GenerateInMemory        = true;
        csp.IncludeDebugInformation = false;
        csp.TreatWarningsAsErrors   = true;
        csp.WarningLevel            = 4;

        csp.ReferencedAssemblies.Add(Assembly.GetExecutingAssembly().Location);
        
        CompilerResults cr = csc.CompileAssemblyFromSource(csp, formatSource);

        if (cr.NativeCompilerReturnValue != 0)
        {
            foreach (CompilerError err in cr.Errors)
                Console.WriteLine(err);
            
            Console.WriteLine("----------------------------------");
            foreach (string output in cr.Output)
                Console.WriteLine(output);

            return;
        }

        asm = cr.CompiledAssembly;
    }

    public void DumpAssembly()
    {
        AppDomain ad = AppDomain.CurrentDomain;
        Console.WriteLine("Hello from {0}", ad.FriendlyName);

        foreach (Assembly asm in ad.GetAssemblies())
            Console.WriteLine("    {0}", asm.FullName);
    }

    public object RunFormat(int i, IStatsAttributeCollection attr)
    {
        Type            t   = asm.GetType("Formatter" + i);
        IStatsFormatter sf  = (IStatsFormatter)Activator.CreateInstance(t);
        object          o   = sf.Format(attr);

        return o;
    }

    static string FormatClass =     
      "class Formatter{0} : IStatsFormatter\n"
    + "{{\n"
    + "    public object Format(IStatsAttributeCollection attr) {{ return ({1}); }}\n"
    + "}}\n";

    string[] formats;
    string   formatSource;
    Assembly asm;

}


class FormatGen
{
    static void Main(string[] args)
    {
        Console.WriteLine("FormatGen");

        for (int i = 0; i < 3; i++)
        {
            AppDomain             ad  = AppDomain.CreateDomain("FormatDomain");
            FormatAppDomainLoader ldr = FormatAppDomainLoader.CreateFormatLoader(ad);

            ldr.SetFormats(args);
            ldr.BuildAssembly();
            ldr.DumpAssembly();

            for (int j = 0; j < args.Length; j++)
            {
                Console.WriteLine("{0}: {1}", i, ldr.RunFormat(j, new StatsAttributeCollection()));
            }

            AppDomain.Unload(ad);
        }
        
        FormatAppDomainLoader loader = FormatAppDomainLoader.CreateFormatLoader(AppDomain.CurrentDomain);
        loader.DumpAssembly();
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Presence\Dll\PerfCounters.cs ===
using System;
using System.Threading;
using System.Diagnostics;
using xonline.common.mgmt;
using xonline.common.service;

namespace xonline.server.webcache.presence.dll 
{

    [XomPerformanceCounterCategoryAttr( "WebCache: Presence", "Xbox Live: Web Cache server performance counters (Presence)" )]

    public class WebCachePresenceCounter : XomPerformanceCounterCategory
    {
        [XomPerformanceCounterAttr(
             "GetFriends requests per second", 
             "Number of GetFriends requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter GetFriendsRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "GetFriends requests total", 
             "Total GetFriends requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter GetFriendsRequestsTotal;

        [XomPerformanceCounterAttr(
             "GetFriends failed requests per second", 
             "Number of failed GetFriends requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter GetFriendsFailedRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "GetFriends failed requests total", 
             "Total failed GetFriends requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter GetFriendsFailedRequestsTotal;

        [XomPerformanceCounterAttr(
             "GetFriendsEx requests per second", 
             "Number of GetFriendsEx requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter GetFriendsExRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "GetFriendsEx requests total", 
             "Total GetFriendsEx requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter GetFriendsExRequestsTotal;

        [XomPerformanceCounterAttr(
             "GetFriendsEx failed requests per second", 
             "Number of failed GetFriendsEx requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter GetFriendsExFailedRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "GetFriendsEx failed requests total", 
             "Total failed GetFriendsEx requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter GetFriendsExFailedRequestsTotal;

        [XomPerformanceCounterAttr(
             "GetGamertagsFromXUIDS requests per second", 
             "Number of GetGamertagsFromXUIDS requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter GetGamertagsFromXUIDSRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "GetGamertagsFromXUIDS requests total", 
             "Total GetGamertagsFromXUIDS requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter GetGamertagsFromXUIDSRequestsTotal;

        [XomPerformanceCounterAttr(
             "GetGamertagsFromXUIDS failed requests per second", 
             "Number of failed GetGamertagsFromXUIDS requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter GetGamertagsFromXUIDSFailedRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "GetGamertagsFromXUIDS failed requests total", 
             "Total failed GetGamertagsFromXUIDS requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter GetGamertagsFromXUIDSFailedRequestsTotal;

        [XomPerformanceCounterAttr(
             "GetXUIDSFromGamertags requests per second", 
             "Number of GetXUIDSFromGamertags requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter GetXUIDSFromGamertagsRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "GetXUIDSFromGamertags requests total", 
             "Total GetXUIDSFromGamertags requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter GetXUIDSFromGamertagsRequestsTotal;

        [XomPerformanceCounterAttr(
             "GetXUIDSFromGamertags failed requests per second", 
             "Number of failed GetXUIDSFromGamertags requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter GetXUIDSFromGamertagsFailedRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "GetXUIDSFromGamertags failed requests total", 
             "Total failed GetXUIDSFromGamertags requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter GetXUIDSFromGamertagsFailedRequestsTotal;

        [XomPerformanceCounterAttr(
             "GetPresenceInfo requests per second", 
             "Number of GetPresenceInfo requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter GetPresenceInfoRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "GetPresenceInfo requests total", 
             "Total GetPresenceInfo requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter GetPresenceInfoRequestsTotal;

        [XomPerformanceCounterAttr(
             "GetPresenceInfo failed requests per second", 
             "Number of failed GetPresenceInfo requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter GetPresenceInfoFailedRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "GetPresenceInfo failed requests total", 
             "Total failed GetPresenceInfo requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter GetPresenceInfoFailedRequestsTotal;

        [XomPerformanceCounterAttr(
             "Expired cache items flushed per second", 
             "Number of naturally expiring cache items flushed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter ExpiredCacheItemsPerSecond;

        [XomPerformanceCounterAttr(
             "Expired cache items total", 
             "Total cached items expiring naturally in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter ExpiredCacheItemsTotal;

        [XomPerformanceCounterAttr(
             "Underused cache items flushed per second", 
             "Number of underused cache items flushed per second due to memory pressure", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter UnderusedCacheItemsPerSecond;

        [XomPerformanceCounterAttr(
             "Underused cache items total", 
             "Total cached items removed due to memory pressure in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter UnderusedCacheItemsTotal;
        
        [XomPerformanceCounterAttr(
             "Friends cache hit per second", 
             "Number of Friends cache hit per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter FriendsCacheHitPerSecond;

        [XomPerformanceCounterAttr(
             "Friends cache hit total", 
             "Total Friends cache hit in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter FriendsCacheHitTotal;
        
        [XomPerformanceCounterAttr(
             "Friends cache miss per second", 
             "Number of Friends cache miss per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter FriendsCacheMissPerSecond;

        [XomPerformanceCounterAttr(
             "Friends cache miss total", 
             "Total Friends cache miss in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter FriendsCacheMissTotal;

        [XomPerformanceCounterAttr(
             "GetRecentPlayers requests per second",
             "Number of GetRecentPlayers requests executed per second",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter GetRecentPlayersRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "GetRecentPlayers requests total",
             "Total GetRecentPlayers requests recorded in the the current AppDomain.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter GetRecentPlayersRequestsTotal;

        [XomPerformanceCounterAttr(
             "GetRecentPlayers failed requests per second",
             "Number of failed GetRecentPlayers requests executed per second",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter GetRecentPlayersFailedRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "GetRecentPlayers failed requests total",
             "Total failed GetRecentPlayers requests recorded in the the current AppDomain.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter GetRecentPlayersFailedRequestsTotal;

        public virtual WebCachePresenceCounter this[string partnerName]
        {
            get
            {
                return (WebCachePresenceCounter) GetInstance(partnerName);
            }
        }

        static public WebCachePresenceCounter Counters = new WebCachePresenceCounter();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Presence\Dll\SettingsDataAccess.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;

using xonline.common.service;
using xonline.common.protocol;
using xonline.server.webcache.common;


namespace xonline.server.webcache.presence.dll
{

    public enum StatsProfileSetting: uint
    {
        //Web preferences
        Spam            = 0x10042002,
        Flash           = 0x1004200C,
        VideoPreference = 0x1004200D,
        EmailFormat     = 0x10042000,
        FavoriteGenre   = 0x10042003,
        FavoriteGame    = 0x10042004,
        FavoriteGame1   = 0x10042005,
        FavoriteGame2   = 0x10042006,
        FavoriteGame3   = 0x10042007,
        FavoriteGame4   = 0x10042008,
        FavoriteGame5   = 0x10042009,
        PlatformsOwned  = 0x1004200A,
        ConnectionSpeed = 0x1004200B,
        Flags           = 0x10042001,

        //Gamer profile
        GamercardZone   = 0x10040004,
        GamercardTile   = 0x4064000F,
        GamercardMotto  = 0x402C0011,
        GamercardRep    = 0x5004000B,
        GamercardCred   = 0x10040006,
        GamerTier       = 0x1004003A,
        GamerType       = 0x10040001,
        GamerCountry    = 0x10040005,
        ProfilePermissions = 0x10040000,
    }

    public enum XuserDataType : byte
    {
        Context = 0x0,
        Int32 = 0x1,
        Int64 = 0x2,
        Double = 0x3,
        Unicode = 0x4,
        Float = 0x5,
        Binary = 0x6,
        DateTime = 0x7,
        Null = 0xF
    }


    /// <summary>
    /// Summary description for SettingsDataAccess.
    /// </summary>
    public class SettingsDataAccess
    {
        private static uint[] AllSettings
        {
            get
            {
                if (allSettings == null)
                {
                    System.Array allSettingsInEnum = Enum.GetValues(typeof(StatsProfileSetting));
                    uint[] tempAllSettings = new uint[allSettingsInEnum.Length];

                    for (int i=0; i < allSettingsInEnum.Length; i++)
                    {
                        tempAllSettings[i] = Convert.ToUInt32(allSettingsInEnum.GetValue(i));
                    }

                    allSettings = tempAllSettings;                                              
                }

                return allSettings;
            }
        }
        private static uint[] allSettings;
        
        private enum PublicStatsProfileSetting
        {
            //Gamer profile
            GamercardZone   = 0x10040004,
            GamercardTile   = 0x4064000F,
            GamercardMotto  = 0x402C0011,
            GamercardRep    = 0x5004000B,
            GamercardCred   = 0x10040006,
            GamerTier       = 0x1004003A,
            GamerType       = 0x10040001,
            GamerCountry    = 0x10040005
        }

        private static uint[] AllPublicSettings
        {
            get
            {
                if (allPublicSettings == null)
                {
                    System.Array allSettingsInEnum = Enum.GetValues(typeof(PublicStatsProfileSetting));
                    uint[] tempAllSettings = new uint[allSettingsInEnum.Length];

                    for (int i=0; i < allSettingsInEnum.Length; i++)
                    {
                        tempAllSettings[i] = Convert.ToUInt32(allSettingsInEnum.GetValue(i));
                    }

                    allPublicSettings = tempAllSettings;                                              
                }

                return allPublicSettings;
            }
        }
        private static uint[] allPublicSettings;

        public void LoadSettings(ulong callingLivepuid, GamerProfile profile)
        {
            ulong targetLivepuid = 0;

            if (profile != null)
            {
                targetLivepuid = profile.Livepuid;
            }
            ReadSettingsResponse readResp = ReadSettings(callingLivepuid, targetLivepuid);
            LoadSettings(readResp, profile);
        }

        public void LoadSettings(ReadSettingsResponse readResp, GamerProfile profile)
        {
            int numberOfSetting = 0;
            numberOfSetting = readResp.Settings.Length;

            for(int index =0; index<numberOfSetting;index++)
            {
                xonline.common.protocol.UserSetting setting = readResp.Settings[index];
                PopulateSetting(setting, profile);
            }
        }

        public GamerProfile[] LoadSettings(ReadSettingsResponse readResp)
        {
            int numberOfSetting = 0;
            numberOfSetting = readResp.Settings.Length;
            
            System.Collections.Hashtable htGamerProfiles = new System.Collections.Hashtable((int)XOn.XONLINE_MAX_SETTING_USERS);

            for(int index =0; index<numberOfSetting;index++)
            {
                xonline.common.protocol.UserSetting setting = readResp.Settings[index];
                ulong userLivepuid = setting.UserId;
                GamerProfile profile;

                // go through all the results and create a GamerProfile object for each user and stick in hash table
                if (!htGamerProfiles.ContainsKey(userLivepuid))
                {
                    profile = new GamerProfile();
                    profile.Livepuid = userLivepuid;
                    htGamerProfiles.Add(userLivepuid, profile);
                }
                else
                {
                    profile = htGamerProfiles[userLivepuid] as GamerProfile;
                }

                PopulateSetting(setting, profile);
            }

            GamerProfile[] profiles = new GamerProfile[htGamerProfiles.Count];
            htGamerProfiles.Values.CopyTo(profiles, 0);
            return profiles;
        }

        private void PopulateSetting(xonline.common.protocol.UserSetting setting, GamerProfile profile)
        {
            switch ((StatsProfileSetting)setting.SettingId)
            {
                case StatsProfileSetting.ConnectionSpeed:
                case StatsProfileSetting.EmailFormat:
                case StatsProfileSetting.FavoriteGame:
                case StatsProfileSetting.FavoriteGame1:
                case StatsProfileSetting.FavoriteGame2:
                case StatsProfileSetting.FavoriteGame3:
                case StatsProfileSetting.FavoriteGame4:
                case StatsProfileSetting.FavoriteGame5:
                case StatsProfileSetting.FavoriteGenre:
                case StatsProfileSetting.Flash:
                case StatsProfileSetting.PlatformsOwned:
                case StatsProfileSetting.Flags:
                case StatsProfileSetting.VideoPreference:
                    break;

                case StatsProfileSetting.GamercardCred:
                    if (profile != null)
                    {
                        profile.GamerScore = ReadIntSetting(setting, 0, int.MinValue);
                    }
                    break;

                case StatsProfileSetting.GamercardRep:
                    if (profile != null)
                    {
                        byte[] stuff = BitConverter.GetBytes(58.0f);

                        profile.Reputation = ReadFloatSetting(setting, 0F, float.NaN);
                    }
                    break;

                case StatsProfileSetting.GamercardTile:
                    if (profile != null)
                    {
                        // default to xbox logo if we can't find a tile setting
                        profile.GamerTile = ReadStringSetting(setting, "", null);
                    }
                    break;

                case StatsProfileSetting.GamercardZone:
                    if (profile != null)
                    {
                        profile.Zone = (GamercardZones) ReadIntSetting(setting, (int) GamercardZones.None, (int) GamercardZones.Unknown);
                    }
                    break;

                case StatsProfileSetting.GamerCountry:
                    if (profile != null)
                    {
                        profile.Country = ReadIntSetting(setting, int.MinValue, int.MinValue);
                    }
                    break;

                case StatsProfileSetting.GamerTier:
                    if (profile != null)
                    {
                        profile.Tier = (GamerTiers) ReadIntSetting(setting, (int) GamerTiers.None, (int) GamerTiers.Unknown);
                    }
                    break;

                case StatsProfileSetting.GamerType:
                    if (profile != null)
                    {
                        profile.Type = ReadIntSetting(setting, 0, int.MinValue);
                    }
                    break;

                case StatsProfileSetting.ProfilePermissions:
                    if(profile != null)
                    {
                        profile.ProfilePermissions = ReadIntSetting(setting, 0, XOn.XPROFILE_PERMISSION_SHARE_ACTIVITY_NOONE | XOn.XPROFILE_PERMISSION_SHARE_UCC_NOONE);
                    }
                    break;
            }
        }

        private string ReadStringSetting(xonline.common.protocol.UserSetting setting, string defaultValue, string noPermissionValue)
        {
            if (((setting.SettingId >> 28) & 0xf) != (byte) XuserDataType.Unicode)
            {
                throw new XboxComCodeErrorException(
                    "ReadStringSetting was called with a setting ID that does not indicate a Unicode type. Type value for setting " + setting + " is " + ((setting.SettingId >> 28) & 0xf) + ".");
            }

            if (setting.Source == XOn.XSOURCE_PERMISSION_DENIED)
            {
                return noPermissionValue;
            }
            else if (setting.Source == XOn.XSOURCE_NO_VALUE)
            {
                return defaultValue;
            }
            else if (setting.ValueLen <= 2)
            {
                return "";
            }
            else
            {
                Encoding unicode = Encoding.Unicode;
                return unicode.GetString(setting.Value, 0, setting.ValueLen-2);
            }
        }

        private float ReadFloatSetting(xonline.common.protocol.UserSetting setting, float defaultValue, float noPermissionValue)
        {
            if (((setting.SettingId >> 28) & 0xf) != (byte) XuserDataType.Float)
            {
                throw new XboxComCodeErrorException(
                    "ReadFloatSetting was called with a setting ID that does not indicate a Float type. Type value for setting " + setting + " is " + ((setting.SettingId >> 28) & 0xf) + ".");
            }

            if (setting.Source == XOn.XSOURCE_PERMISSION_DENIED)
            {
                return noPermissionValue;
            }
            else if (setting.Source == XOn.XSOURCE_NO_VALUE)
            {
                return defaultValue;
            }
            else
            {
                if (setting.ValueLen == 4)
                {
                    return BitConverter.ToSingle(setting.Value, 0);
                }
                else
                {
                    throw new XboxComCodeErrorException(
                        "Can't convert setting " + ((StatsProfileSetting) setting.SettingId).ToString() + " to a float. " + setting.ValueLen.ToString() + " bytes were in the response - needs to be 4 bytes to convert.");
                }
            }
        }

        private int ReadIntSetting(xonline.common.protocol.UserSetting setting, int defaultValue, int noPermissionValue)
        {
            if (((setting.SettingId >> 28) & 0xf) != (byte) XuserDataType.Int32)
            {
                throw new XboxComCodeErrorException(
                    "ReadIntSetting was called with a setting ID that does not indicate a Int32 type. Type value for setting " + setting + " is " + ((setting.SettingId >> 28) & 0xf) + ".");
            }

            if (setting.Source == XOn.XSOURCE_PERMISSION_DENIED)
            {
                return noPermissionValue;
            }
            else if (setting.Source == XOn.XSOURCE_NO_VALUE)
            {
                return defaultValue;
            }
            else
            {
                if (setting.ValueLen == 1)
                {
                    return (int) setting.Value[0];
                }
                else if (setting.ValueLen == 2)
                {
                    return (int) BitConverter.ToInt16(setting.Value, 0);
                }
                else if (setting.ValueLen == 4)
                {
                    return BitConverter.ToInt32(setting.Value, 0);
                }
                else
                {
                    throw new XboxComCodeErrorException(
                        "Can't convert setting " + ((StatsProfileSetting) setting.SettingId).ToString() + " to an int. " + setting.ValueLen.ToString() + " bytes were in the response - needs to be 1, 2, or 4 bytes to convert.");
                }
            }
        }
        
        public ReadSettingsResponse ReadSettings(ulong callingLivepuid, ulong targetLivepuid)
        {
            ReadSettingsRequest readReq = new ReadSettingsRequest();

            readReq.TitleId = XOn.WEB_TITLE_ID;
            readReq.UserId = callingLivepuid;
            readReq.ForUserIds = new ulong[] { targetLivepuid };

            // request all settings even if this particular request doesn't need them.
            // This will keep the livecache request signature the same between requests,
            // increasing the likelyhood of the data being cached.
            readReq.SettingIds = SettingsDataAccess.AllSettings;
            
            LivecacheDependency dependency = LivecacheDependency.Stats(targetLivepuid);
            LivecacheRequest lcReq = new LivecacheRequest(callingLivepuid, LcserviceId.ReadSettings, readReq, dependency, null);

            HResult hr = lcReq.Send();
          
            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }

            ReadSettingsResponse readResp = new ReadSettingsResponse();  
            readResp.SetBytes(lcReq.ResponseData);    

            return readResp;
        }
        public ReadSettingsResponse PublicReadSettings(ulong targetLivepuid, out DateTime responseTTL)
        {
            const ulong noFriendsFakeLivepuid = 1;

            ReadSettingsRequest readReq = new ReadSettingsRequest();

            readReq.TitleId = XOn.WEB_TITLE_ID;
            readReq.UserId = noFriendsFakeLivepuid;
            readReq.ForUserIds = new ulong[] { targetLivepuid };

            // request all settings even if this particular request doesn't need them.
            // This will keep the livecache request signature the same between requests,
            // increasing the likelyhood of the data being cached.
            readReq.SettingIds = SettingsDataAccess.AllPublicSettings;
            
            HTTPAuthData httpAuthData = LivecacheRequest.CreateHTTPAuthData(
                noFriendsFakeLivepuid,
                LcserviceId.PublicReadSettings,
                0,  // xboxID
                XOn.WEB_TITLE_ID);

            LivecacheDependency dependency = LivecacheDependency.Stats(targetLivepuid);

            LivecacheRequest lcReq = new LivecacheRequest(
                noFriendsFakeLivepuid, 
                LcserviceId.PublicReadSettings, 
                readReq.GetBytes(),
                httpAuthData,
                dependency,
                null,
                readReq);

            HResult hr = lcReq.Send();
          
            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }

            responseTTL = lcReq.ResponseExpiry;

            ReadSettingsResponse readResp = new ReadSettingsResponse();  
            readResp.SetBytes(lcReq.ResponseData);    

            return readResp;
        }

        public ReadSettingsResponse[] ReadProfileSettings(ulong callingLivepuid, ulong[] targetLivepuids, uint[] settings)
        {
            // since stats limits our call to 16 puids at a time, we need to interate in increments of 16
            int iNextStartIndex = 0;
            const int iMaxUsers = (int)XOn.XONLINE_MAX_SETTING_USERS;
            bool bContinue = (iNextStartIndex < targetLivepuids.Length);

            ReadSettingsResponse[] responses = new ReadSettingsResponse[0];
            ArrayList results = new ArrayList();

            while (bContinue)
            {
                ReadSettingsRequest readReq = new ReadSettingsRequest();

                readReq.TitleId = XOn.WEB_TITLE_ID;
                readReq.UserId = callingLivepuid;

                int iArrayLength = Math.Min(iMaxUsers, targetLivepuids.Length - iNextStartIndex);
                readReq.ForUserIds = new ulong[iArrayLength];

                for (int i = 0; i < readReq.ForUserIds.Length; i++)
                {
                    readReq.ForUserIds[i] = targetLivepuids[iNextStartIndex + i];
                }

                iNextStartIndex += iMaxUsers;

                if (iNextStartIndex >= targetLivepuids.Length)
                {
                    bContinue = false;
                }

                readReq.SettingIds = settings;

                //cache livecache request
                LivecacheDependency dependency = LivecacheDependency.Stats(callingLivepuid);
                LivecacheRequest lcReq = LivecacheManager.Current.CreateLivecacheRequest(LcserviceId.ReadSettings, readReq, dependency, null);
                
                HResult hr = lcReq.Send();
          
                if (hr != HResult.S_OK)
                {
                    throw new LivecacheResponseException(lcReq);
                }

                ReadSettingsResponse readResp = new ReadSettingsResponse();  
                readResp.SetBytes(lcReq.ResponseData);    
                results.Add(readResp);
            }
          
            responses = new ReadSettingsResponse[results.Count];
            results.CopyTo(responses);

            return responses;
        }
        
        //GamerProfile
        public GamerProfile GetGamerProfile(ulong callingLivepuid, ulong targetLivepuid)
        {
            GamerProfile profile = new GamerProfile(targetLivepuid);
            LoadSettings(callingLivepuid, profile);
            return profile;
        }

        public GamerProfile GetPublicGamerProfile(ulong targetLivepuid)
        {
            DateTime responseTTL;
            GamerProfile profile = new GamerProfile(targetLivepuid);

            ReadSettingsResponse readResp = PublicReadSettings(targetLivepuid, out responseTTL);
            LoadSettings(readResp, profile);
            profile.DataGoodUntil = responseTTL;

            return profile;
        }

        public GamerProfile[] GetGamerProfilesBySetting(ulong callingLivepuid, ulong[] targetLivepuids, uint[] settings, bool getGamertag)
        {
            ReadSettingsResponse[] responses = ReadProfileSettings(callingLivepuid, targetLivepuids, settings);
            int estimatedArrayListSize = responses.Length * (int)XOn.XONLINE_MAX_SETTING_USERS;
            ArrayList profileList = new ArrayList(estimatedArrayListSize);

            //populate gamer profile
            foreach(ReadSettingsResponse readResp in responses)
            {
                GamerProfile[] profiles = LoadSettings(readResp); 
                foreach(GamerProfile profile in profiles)
                {
                    if(getGamertag)
                    {
                        profile.GamerTag = XCache.LookupGamerTag(profile.Livepuid);
                    }
                    profileList.Add(profile);
                }
            }

            GamerProfile[] totalProfiles = new GamerProfile[profileList.Count];
            profileList.CopyTo(totalProfiles);

            return totalProfiles;
        }
        
        public Hashtable GetGamerProfileCollectionBySetting(ulong callingLivepuid, ulong[] targetLivepuids, uint[] settings, bool getGamertag)
        {
            GamerProfile[] profiles = GetGamerProfilesBySetting(callingLivepuid, targetLivepuids, settings, getGamertag);
            System.Collections.Hashtable htgamerListSettings = new System.Collections.Hashtable(profiles.Length);
            foreach(GamerProfile profile in profiles)
            {
                htgamerListSettings.Add(profile.Livepuid, profile);
            }
            return htgamerListSettings;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Presence\Dll\PresenceDataAccess.cs ===
using System;
using System.Collections;
using System.Text;
using System.Web;

using xonline.common.config;
using xonline.common.service;
using xonline.common.protocol;
using xonline.common.mgmt;
using xonline.server.webcache.common;

namespace xonline.server.webcache.presence.dll
{
    /// <summary>
    /// Summary description for Friends.
    /// </summary>
    public class PresenceDataAccess
    {
        
        #region WebAlive

        public void SendWebAlive(ulong callerLivepuid)
        {
            // enforce only calling once per user request
            HttpContext ctx = HttpContext.Current;

            if (ctx != null)
            {
                string key = "WebAlive_" + callerLivepuid.ToString();

                if (ctx.Items.Contains(key))
                {
                    return;
                }

                ctx.Items[key] = true;
            }

            WebAliveRequest aliveReq = new WebAliveRequest();
            aliveReq.puid = callerLivepuid;

            LivecacheRequest lcReq = new LivecacheRequest(callerLivepuid, LcserviceId.WebAlive, aliveReq);
            HResult hr = lcReq.Send();

            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }

            WebAliveResponse aliveResp = new WebAliveResponse();
            aliveResp.SetBytes(lcReq.ResponseData);

            // see if presence reported an error in the message itself
            if (aliveResp.hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }
        }

        #endregion

        #region RecentPlayers
        public QueryAffiliatesReplyData[] GetQueryAffiliatesReplyData(ulong callingLivepuid, ushort maxCount)
        {
            if(maxCount == 0)
            {
                return new QueryAffiliatesReplyData[0];
            }
            
            // make sure Presence has an online record loaded for the calling user
            SendWebAlive(callingLivepuid);

            // set up Presence request
            PresenceQueryAffiliatesMsg qaReq = new PresenceQueryAffiliatesMsg();

            qaReq.qwSenderID = callingLivepuid;
            qaReq.cdwLimit = maxCount;
            qaReq.dwListFlags = RecentPlayerCollectionBuilder.GetAffiliateListFlag(AffiliateFlag.Encountered);
            qaReq.dwOnlineTitleID = 0;

            // set up the Presence response
            PresenceQueryAffiliatesReplyMsg qaResp = new PresenceQueryAffiliatesReplyMsg();

            uint tier;
            uint[] privileges;
            DateTime lastWebActivity;
            byte parentalControlGroup;
            LivecacheManager.LookupWebInfo(callingLivepuid, out tier, out privileges, out lastWebActivity, out parentalControlGroup);

            LivecacheManager.Current.LivePuid = callingLivepuid;
            LivecacheManager.Current.Tier = tier;
            LivecacheManager.Current.Privileges = privileges;

            //cache the LiveCache request
            LivecacheRequest lcReq = LivecacheManager.Current.CreateLivecacheRequest(LcserviceId.QueryAffiliates, qaReq, null, null);
            // make the call
            HResult hr = lcReq.Send();

            // check for errors
            if (hr != HResult.S_OK)
            {
                throw new LivecacheResponseException(lcReq);
            }

            // get the response
            qaResp.SetBytes(lcReq.ResponseData);
            if((qaResp.cdwResults == 0) && (qaResp.hr != HResult.S_OK))
            {
                switch(qaResp.hr)
                {
                    case 0x80070525: //HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER)
                    case xonline.common.service.HResult.XONLINE_E_NOTIFICATION_NO_PEER_SUBSCRIBE: // non error
                    case xonline.common.service.HResult.E_INVALIDARG: //query affiliates on mute or block list
                    case xonline.common.service.HResult.XONLINE_E_NOTIFICATION_INVALID_PUID: //callerid=0
                        return new QueryAffiliatesReplyData[0];
                    default:
                        throw new Exception(String.Format("QueryAffiliates process failed on the service. hr: {0}, caller:{1}.", qaResp.hr, callingLivepuid));
                }
            }

            return qaResp.rgResults;
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Presence\Dll\Presence.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Web;
using System.Web.Services;
using System.Web.Caching;

using xonline.common.config;
using xonline.common.installer;
using xonline.common.service;
using xonline.common.protocol;
using xonline.common.mgmt;
using xonline.common.utilities;
using xonline.server.mgmt.soap;
using xonline.server.webcache.common;


[assembly: XomIisInstallerAttribute( Interface.wcpresence )]
[assembly: ConfigAttribute(xonline.common.config.Component.wcpresence)]

[assembly: XomAreaDefinition(XomAreaName.wcpresencelog)]

namespace xonline.server.webcache.presence.dll 
{
    [WebService(Namespace="http://websvc.xboxlive.com/Presence/")]
    public class Presence : System.Web.Services.WebService
    {
        const uint MAX_FRIENDS = 100;
        
        static Presence()
        {
            try
            {
                utils = Utilities.Instance;
                
                FriendsCacheExpirationSeconds = Config.GetUIntSetting(Setting.presenceWidget_friendsCacheExpirationSeconds);
            
                onRemove = new CacheItemRemovedCallback(RemovedCallback);
            }
            catch (XboxWebException)
            {
                throw;
            }
            catch (Exception e)
            {
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_38, e);
            }
        }

        public Presence()
        {
            try
            {
                //CODEGEN: This call is required by the ASP.NET Web Services Designer
                InitializeComponent();
            }
            catch (XboxWebException)
            {
                throw;
            }
            catch (Exception e)
            {
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_39, e);
            }
        }

        #region Component Designer generated code
        
        //Required by the Web Services Designer 
        private IContainer components = null;
                
        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
        }

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        protected override void Dispose( bool disposing )
        {
            if(disposing && components != null)
            {
                components.Dispose();
            }
            base.Dispose(disposing);        
        }
        
        #endregion

        public struct OnlineFriend
        {
            public string G;      // GamerTag
            public uint T;        // TitleID friend is playing
            public uint S;        // State flags
            // #define XONLINE_FRIENDSTATE_FLAG_ONLINE            0x00000001
            // #define XONLINE_FRIENDSTATE_FLAG_PLAYING           0x00000002
            // #define XONLINE_FRIENDSTATE_FLAG_VOICE             0x00000008
            // #define XONLINE_FRIENDSTATE_FLAG_JOINABLE          0x00000010
            // #define XONLINE_FRIENDSTATE_MASK_GUESTS            0x00000060
            // #define XONLINE_FRIENDSTATE_FLAG_RESERVED0         0x00000080
            // #define XONLINE_FRIENDSTATE_FLAG_SENTINVITE        0x04000000
            // #define XONLINE_FRIENDSTATE_FLAG_RECEIVEDINVITE    0x08000000
            // #define XONLINE_FRIENDSTATE_FLAG_INVITEACCEPTED    0x10000000
            // #define XONLINE_FRIENDSTATE_FLAG_INVITEREJECTED    0x20000000
            // #define XONLINE_FRIENDSTATE_FLAG_SENTREQUEST       0x40000000
            // #define XONLINE_FRIENDSTATE_FLAG_RECEIVEDREQUEST   0x80000000
        }

        public struct OfflineFriend
        {
            public string G;      // GamerTag
        }

        public class FriendsInfo
        {
            public OnlineFriend[] OnlineFriends;
            public OfflineFriend[] OfflineFriends;
        }

        public class FriendEx
        {
            public ulong XUID;
            public string GamerTag;
            public uint FriendStatus;
            public uint OnlineState;
            public uint LastSeenTitle;
            public uint MinutesSinceStateChange;
            public string RichPresenceString;
        }

        public class PresenceInfo
        {
            public ulong XUID;
            public string GamerTag;
            public uint OnlineState;
            public uint LastSeenTitle;
            public uint MinutesSinceStateChange;
            public string RichPresenceString;
        }

        [WebMethod]
        public string[] GetGamertagsFromXUIDS(
            ulong[] XUIDS
            )
        {
            try
            {
                utils.CheckAPI("Presence.GetGamertagsFromXUIDS");

                WebCachePresenceCounter.Counters.GetGamertagsFromXUIDSRequestsPerSecond.Increment();
                WebCachePresenceCounter.Counters.GetGamertagsFromXUIDSRequestsTotal.Increment();

                SoapFrontEndApp.AddErrorPerfCounter(WebCachePresenceCounter.Counters.GetGamertagsFromXUIDSFailedRequestsPerSecond);
                SoapFrontEndApp.AddErrorPerfCounter(WebCachePresenceCounter.Counters.GetGamertagsFromXUIDSFailedRequestsTotal);
                    
                string partnerName = Utilities.GetSubjectName();
                if (partnerName != null)
                {
                    WebCachePresenceCounter.Counters[partnerName].GetGamertagsFromXUIDSRequestsPerSecond.Increment();
                    WebCachePresenceCounter.Counters[partnerName].GetGamertagsFromXUIDSRequestsTotal.Increment();

                    SoapFrontEndApp.AddErrorPerfCounter(WebCachePresenceCounter.Counters[partnerName].GetGamertagsFromXUIDSFailedRequestsPerSecond);
                    SoapFrontEndApp.AddErrorPerfCounter(WebCachePresenceCounter.Counters[partnerName].GetGamertagsFromXUIDSFailedRequestsTotal);
                }

                if ((XUIDS == null) || (XUIDS.Length == 0) || (XUIDS.Length > 100))
                {
                    throw new XboxWebException(XEvent.Id.WEBCACHE_CODE_57, "specified XUID list is invalid.");
                }

                for (int iXUID = 0; iXUID < XUIDS.Length; iXUID++)
                {
                    if (XUIDS[iXUID] == 0)
                    {
                        throw new XboxWebException(XEvent.Id.WEBCACHE_CODE_57, "XUID at index " + iXUID + " is zero.");
                    }
                }

                string[] gamertags = utils.LookupGamerTags(XUIDS);

                if (gamertags == null)
                {
                    throw new XboxWebException(XEvent.Id.WEBCACHE_CODE_56, "Internal error retrieving gamertags for specified list.");
                }
            
                string szLog = "GMTG|"
                                + Utilities.GetSubjectName() + "|"
                                + Utilities.GetRequestID() + "|"
                                + Utilities.GetClientIPPort() + "|" 
                                + XUIDS.Length + "|"
                                + gamertags.Length;

                Xom.Log(XomAreaName.wcpresencelog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );

                return gamertags;
            }
            catch (XboxWebException)
            {
                throw;
            }
            catch (Exception e)
            {
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_40, e);
            }
        }

        [WebMethod]
        public ulong[] GetXUIDSFromGamertags(
            string[] gamertags
            )
        {
            try
            {
                utils.CheckAPI("Presence.GetXUIDSFromGamertags");

                WebCachePresenceCounter.Counters.GetXUIDSFromGamertagsRequestsPerSecond.Increment();
                WebCachePresenceCounter.Counters.GetXUIDSFromGamertagsRequestsTotal.Increment();

                SoapFrontEndApp.AddErrorPerfCounter(WebCachePresenceCounter.Counters.GetXUIDSFromGamertagsFailedRequestsPerSecond);
                SoapFrontEndApp.AddErrorPerfCounter(WebCachePresenceCounter.Counters.GetXUIDSFromGamertagsFailedRequestsTotal);
                    
                string partnerName = Utilities.GetSubjectName();
                if (partnerName != null)
                {
                    WebCachePresenceCounter.Counters[partnerName].GetXUIDSFromGamertagsRequestsPerSecond.Increment();
                    WebCachePresenceCounter.Counters[partnerName].GetXUIDSFromGamertagsRequestsTotal.Increment();

                    SoapFrontEndApp.AddErrorPerfCounter(WebCachePresenceCounter.Counters[partnerName].GetXUIDSFromGamertagsFailedRequestsPerSecond);
                    SoapFrontEndApp.AddErrorPerfCounter(WebCachePresenceCounter.Counters[partnerName].GetXUIDSFromGamertagsFailedRequestsTotal);
                }

                if ((gamertags == null) || (gamertags.Length == 0) || (gamertags.Length > 100))
                {
                    throw new XboxWebException(XEvent.Id.WEBCACHE_CODE_58, "specified gamertag list is invalid.");
                }

                for (int iGamertag = 0; iGamertag < gamertags.Length; iGamertag++)
                {
                    if ((gamertags[iGamertag] == null) || (gamertags[iGamertag].Length == 0) || (gamertags[iGamertag].Length >= PresDefs.XONLINE_GAMERTAG_SIZE))
                    {
                        throw new XboxWebException(XEvent.Id.WEBCACHE_CODE_58, "Gamertag at index " + iGamertag + " is either null or invalid.");
                    }
                }

                ulong[] XUIDS = utils.LookupXuidsByGamertags(gamertags);

                if (gamertags == null)
                {
                    throw new XboxWebException(XEvent.Id.WEBCACHE_CODE_59, "Internal error retrieving XUIDS for specified list.");
                }
            
                string szLog = "XUID|"
                                + Utilities.GetSubjectName() + "|"
                                + Utilities.GetRequestID() + "|"
                                + Utilities.GetClientIPPort() + "|" 
                                + gamertags.Length + "|"
                                + XUIDS.Length;

                Xom.Log(XomAreaName.wcpresencelog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );

                return XUIDS;
            }
            catch (XboxWebException)
            {
                throw;
            }
            catch (Exception e)
            {
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_40, e);
            }
        }

        [WebMethod]
        public PresenceInfo GetPresenceInfo(
            ulong targetXUID,
            ulong senderXUID,
            ushort senderLocale,
            out uint ValidSeconds
            )
        {
            try
            {
                utils.CheckAPI("Presence.GetPresenceInfo");

                WebCachePresenceCounter.Counters.GetPresenceInfoRequestsPerSecond.Increment();
                WebCachePresenceCounter.Counters.GetPresenceInfoRequestsTotal.Increment();

                SoapFrontEndApp.AddErrorPerfCounter(WebCachePresenceCounter.Counters.GetPresenceInfoFailedRequestsPerSecond);
                SoapFrontEndApp.AddErrorPerfCounter(WebCachePresenceCounter.Counters.GetPresenceInfoFailedRequestsTotal);
                    
                string partnerName = Utilities.GetSubjectName();
                if (partnerName != null)
                {
                    WebCachePresenceCounter.Counters[partnerName].GetPresenceInfoRequestsPerSecond.Increment();
                    WebCachePresenceCounter.Counters[partnerName].GetPresenceInfoRequestsTotal.Increment();

                    SoapFrontEndApp.AddErrorPerfCounter(WebCachePresenceCounter.Counters[partnerName].GetPresenceInfoFailedRequestsPerSecond);
                    SoapFrontEndApp.AddErrorPerfCounter(WebCachePresenceCounter.Counters[partnerName].GetPresenceInfoFailedRequestsTotal);
                }
                    
                Utilities.RequestInfo requestInfo = Utilities.GetRequestInfo();

                MemoryStream puidMemStream = new MemoryStream(18);
                BinaryWriter puidWriter = new BinaryWriter(puidMemStream);
                puidWriter.Write(targetXUID);
                puidWriter.Write(senderXUID);
                puidWriter.Write(senderLocale);
                puidMemStream.Close();
                byte[] cacheRequest = puidMemStream.ToArray();
                
                byte[] cacheResponse = utils.CacheLookup( CacheType.FriendsPresence, cacheRequest );

                byte[] response;
                if (cacheResponse == null)
                {
                    GetPresenceInfoRequest request = new GetPresenceInfoRequest();
                    request.qwSenderID = senderXUID;
                    request.cdwUsers = 1;
                    request.rgUsers = new ulong[1];
                    request.rgUsers[0] = targetXUID;
                    request.header.dwSeqNum = (uint)(requestInfo.qwRequestID & 0xffffffff);
                    request.dwContext = (uint)(requestInfo.qwRequestID & 0xffffffff);
                
                    WebCachePresenceCounter.Counters.FriendsCacheMissPerSecond.Increment();
                    WebCachePresenceCounter.Counters.FriendsCacheMissTotal.Increment();

                    IVirtualInterfaceInfo vpresenceInfo = Config.GetVirtualInterface(VirtualInterface.xpnfd_presence_int, 1);
                    XUIDAndTrust[]  users = new XUIDAndTrust[1];
                    uint userFlags = 0;

                    XUIDAndTrust.SetUserFlagCountry(ref userFlags, Locale.CountryCodeFromv1LanguageId(senderLocale));
                    XUIDAndTrust.SetUserFlagLanguage(ref userFlags, (uint)senderLocale);
                    
                    users[0] = new XUIDAndTrust(senderXUID, userFlags, 0.0F);

                    HTTPAuthData authData = new HTTPAuthData(requestInfo.ClientPort, requestInfo.ClientIP, requestInfo.qwRequestID, 0, users, 0xFFED0000 /* titleID */, (uint)XOService.PresNotification, 0);
                    
                    response = utils.FrontDoorRequest( string.Format("http://{0}:{1}/xpnfront/xpresence.srf", vpresenceInfo.IPAddressString, vpresenceInfo.Port), authData, (uint)XOService.PresNotification, 0, (byte[])request);
                }
                else
                {
                    WebCachePresenceCounter.Counters.FriendsCacheHitPerSecond.Increment();
                    WebCachePresenceCounter.Counters.FriendsCacheHitTotal.Increment();
                    response = cacheResponse;
                }

                PresenceInfo result = new PresenceInfo();
                
                if (response != null)
                {
                    PresenceInfoResponse piReply = new PresenceInfoResponse();
                    piReply.ReadBytes(response);

                    Debug.Assert(piReply.header.dwMsgType == (uint)P_MSG_TYPES.PMSG_PRESENCE_INFO_REPLY);

                    if ((cacheResponse == null) && (piReply.header.dwSeqNum != (uint)(requestInfo.qwRequestID & 0xffffffff)))
                    {
                        throw new XboxWebInternalException(XEvent.Id.WEBCACHE_CODE_60, "Presence FD returned non matching dwSeqNum:" + piReply.header.dwSeqNum.ToString("X") + "/" + ((uint)(requestInfo.qwRequestID & 0xffffffff)).ToString("X"));
                    }

                    Debug.Assert(piReply.header.sgaddr.inaSg == 0);
                    Debug.Assert(piReply.header.sgaddr.dwSpiSg == 0);
                    Debug.Assert(piReply.header.sgaddr.qwXboxId == 0);
                    Debug.Assert(piReply.header.sgaddr.abReserved == 0);
                    
                    if (piReply.cdwUsers != 1)
                    {
                        throw new XboxWebInternalException(XEvent.Id.WEBCACHE_CODE_61, "PresenceInfoResponse contained " + piReply.cdwUsers + "results.  expected 1 result.");
                    }

                    if (piReply.rgUsers[0].Puid != targetXUID)
                    {
                        throw new XboxWebInternalException(XEvent.Id.WEBCACHE_CODE_62, "PresenceInfoResponse returned incorrect PUID:" + piReply.rgUsers[0].Puid.ToString("X"));
                    }

                    // populate the result
                    result.XUID = piReply.rgUsers[0].Puid;
                    result.GamerTag = piReply.rgUsers[0].szGamerTag;
                    result.LastSeenTitle = piReply.rgUsers[0].TitleId;
                    result.RichPresenceString = Encoding.UTF8.GetString(piReply.rgUsers[0].RPData);

                    if (piReply.rgUsers[0].mtLastActive != 0)
                    {
                        DateTime dtLastActive = MsgDefs.MsgTimeToDateTime(piReply.rgUsers[0].mtLastActive);
                        TimeSpan tsDuration = DateTime.Now.Subtract(dtLastActive);
                        result.MinutesSinceStateChange = (uint)tsDuration.TotalMinutes;
                    }
                    else
                    {
                        result.MinutesSinceStateChange = 0;

                        // zero out the titleid if last active time is 0.  this protects privacy settings.
                        // see comments in CGetPresenceInfoContext::ProcessUser() at server\presence\inh\switchboard.h(3592).
                        result.LastSeenTitle = 0;
                    }
                    
                    result.OnlineState = piReply.rgUsers[0].OnlineState;
                    if ((result.OnlineState & PresDefs.P_STATE_FLAG_CLOAKED) != 0)
                    {
                        // dont convey the cloaked bit.  if they are "appear offline," we treat them as offline.
                        result.OnlineState = 0;
                    }

                    if (cacheResponse == null)
                    {
                        utils.CacheInsert( CacheType.FriendsPresence, cacheRequest, response, FriendsCacheExpirationSeconds, onRemove);
                    }
                }

                string szLog = "GPI|"
                                + Utilities.GetSubjectName() + "|"
                                + Utilities.GetRequestID() + "|"
                                + Utilities.GetClientIPPort() + "|" 
                                + targetXUID.ToString("X") + "|"
                                + senderXUID.ToString("X") + "|"
                                + ((cacheResponse == null) ? "0" : "1") + "|"
                                + result.GamerTag;

                Xom.Log(XomAreaName.wcpresencelog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );

                ValidSeconds = FriendsCacheExpirationSeconds;
                return result;
            }
            catch (XboxWebException)
            {
                throw;
            }
            catch (Exception e)
            {
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_40, e);
            }
        }

        [WebMethod]
        public FriendEx[] GetFriendsEx(
            ulong XUID,
            ushort locale,
            out uint ValidSeconds
            )
        {
            try
            {
                utils.CheckAPI("Presence.GetFriendsEx");

                WebCachePresenceCounter.Counters.GetFriendsExRequestsPerSecond.Increment();
                WebCachePresenceCounter.Counters.GetFriendsExRequestsTotal.Increment();

                SoapFrontEndApp.AddErrorPerfCounter(WebCachePresenceCounter.Counters.GetFriendsExFailedRequestsPerSecond);
                SoapFrontEndApp.AddErrorPerfCounter(WebCachePresenceCounter.Counters.GetFriendsExFailedRequestsTotal);
                    
                string partnerName = Utilities.GetSubjectName();
                if (partnerName != null)
                {
                    WebCachePresenceCounter.Counters[partnerName].GetFriendsExRequestsPerSecond.Increment();
                    WebCachePresenceCounter.Counters[partnerName].GetFriendsExRequestsTotal.Increment();

                    SoapFrontEndApp.AddErrorPerfCounter(WebCachePresenceCounter.Counters[partnerName].GetFriendsExFailedRequestsPerSecond);
                    SoapFrontEndApp.AddErrorPerfCounter(WebCachePresenceCounter.Counters[partnerName].GetFriendsExFailedRequestsTotal);
                }
                    
                Utilities.RequestInfo requestInfo = Utilities.GetRequestInfo();

                MemoryStream puidMemStream = new MemoryStream(10);
                BinaryWriter puidWriter = new BinaryWriter(puidMemStream);
                puidWriter.Write(XUID);
                puidWriter.Write(locale);
                puidMemStream.Close();
                byte[] cacheRequest = puidMemStream.ToArray();
                
                byte[] cacheResponse = utils.CacheLookup( CacheType.FriendsPresence, cacheRequest );

                byte[] response;
                if (cacheResponse == null)
                {
                    WebFriendsRequest request = new WebFriendsRequest();
                    request.puid = XUID;
                    request.header.dwSeqNum = (uint)(requestInfo.qwRequestID & 0xffffffff);
                
                    WebCachePresenceCounter.Counters.FriendsCacheMissPerSecond.Increment();
                    WebCachePresenceCounter.Counters.FriendsCacheMissTotal.Increment();

                    try
                    {
                        IVirtualInterfaceInfo vpresenceInfo = Config.GetVirtualInterface(VirtualInterface.xpnfd_presence_int, 1);
                        XUIDAndTrust[]  users = new XUIDAndTrust[1];
                        uint userFlags = 0;

                        XUIDAndTrust.SetUserFlagCountry(ref userFlags, Locale.CountryCodeFromv1LanguageId(locale));
                        XUIDAndTrust.SetUserFlagLanguage(ref userFlags, (uint)locale);
                        
                        users[0] = new XUIDAndTrust(XUID, userFlags, 0.0F);

                        HTTPAuthData authData = new HTTPAuthData(requestInfo.ClientPort, requestInfo.ClientIP, requestInfo.qwRequestID, 0, users, 0xFFED0000 /* titleID */, (uint)XOService.PresNotification, 0);

                        // need to call WebAlive before calling WebFriends.
                        WebAliveRequest webAlive = new WebAliveRequest();
                        webAlive.puid = XUID;
                    
                        response = utils.FrontDoorRequest( string.Format("http://{0}:{1}/xpnfront/xpresence.srf", vpresenceInfo.IPAddressString, vpresenceInfo.Port), authData, (uint)XOService.PresNotification, 0, (byte[])webAlive);

                        WebAliveResponse waResponse = new WebAliveResponse();
                        waResponse.ReadBytes(response);
                        
                        if (waResponse.hr != HResult.S_OK)
                        {
                            throw new XboxWebInternalException(XEvent.Id.WEBCACHE_CODE_50, "Presence FD returned hr  " + ((HResult) waResponse.hr));
                        }

                        if (waResponse.puid != XUID)
                        {
                            throw new XboxWebInternalException(XEvent.Id.WEBCACHE_CODE_51, "Presence FD returned incorrect PUID:" + waResponse.puid.ToString("X"));
                        }
                        
                        response = utils.FrontDoorRequest( string.Format("http://{0}:{1}/xpnfront/xpresence.srf", vpresenceInfo.IPAddressString, vpresenceInfo.Port), authData, (uint)XOService.PresNotification, 0, (byte[])request);
                        
                    }
                    catch (FrontDoorNonFatalException e)
                    {
                        if (e.HResult == HResult.XONLINE_E_USER_NOT_PRESENT)
                            response = null;
                        else
                            throw;
                    }
                }
                else
                {
                    WebCachePresenceCounter.Counters.FriendsCacheHitPerSecond.Increment();
                    WebCachePresenceCounter.Counters.FriendsCacheHitTotal.Increment();
                    response = cacheResponse;
                }

                FriendEx[] friends = null;
                
                if (response != null)
                {
                    WebFriendsResponse wfReply = new WebFriendsResponse();
                    wfReply.ReadBytes(response);

                    friends = new FriendEx[wfReply.cdwFriends];

                    Debug.Assert(wfReply.header.dwMsgType == (uint)P_MSG_TYPES.PMSG_WEB_FRIENDS_REPLY);

                    if ((cacheResponse == null) && (wfReply.header.dwSeqNum != (uint)(requestInfo.qwRequestID & 0xffffffff)))
                    {
                        throw new XboxWebInternalException(XEvent.Id.WEBCACHE_CODE_52, "Presence FD returned non matching dwSeqNum:" + wfReply.header.dwSeqNum.ToString("X") + "/" + ((uint)(requestInfo.qwRequestID & 0xffffffff)).ToString("X"));
                    }

                    Debug.Assert(wfReply.header.sgaddr.inaSg == 0);
                    Debug.Assert(wfReply.header.sgaddr.dwSpiSg == 0);
                    Debug.Assert(wfReply.header.sgaddr.qwXboxId == 0);
                    Debug.Assert(wfReply.header.sgaddr.abReserved == 0);
                    
                    if (wfReply.hr != HResult.S_OK)
                    {
                        throw new XboxWebInternalException(XEvent.Id.WEBCACHE_CODE_53, "Presence FD returned hr = " + ((HResult) wfReply.hr));
                    }

                    if (wfReply.puid != XUID)
                    {
                        throw new XboxWebInternalException(XEvent.Id.WEBCACHE_CODE_54, "Presence FD returned incorrect PUID:" + wfReply.puid.ToString("X"));
                    }

                    if (wfReply.cdwFriends > MAX_FRIENDS)
                    {
                        throw new XboxWebInternalException(XEvent.Id.WEBCACHE_CODE_55, "Friend count " + wfReply.cdwFriends + " returned by Presence");
                    }

                    // populate the result
                    for (int iFriend = 0; iFriend < wfReply.cdwFriends; iFriend++)
                    {
                        friends[iFriend] = new FriendEx();
                        friends[iFriend].XUID = wfReply.rgFriends[iFriend].Puid;
                        friends[iFriend].GamerTag = wfReply.rgFriends[iFriend].szGamerTag;
                        friends[iFriend].FriendStatus = wfReply.rgFriends[iFriend].FriendStatus;
                        friends[iFriend].LastSeenTitle = wfReply.rgFriends[iFriend].TitleId;
                        friends[iFriend].RichPresenceString = Encoding.UTF8.GetString(wfReply.rgFriends[iFriend].RPData);

                        if (wfReply.rgFriends[iFriend].mtLastActive != 0)
                        {
                            DateTime dtLastActive = MsgDefs.MsgTimeToDateTime(wfReply.rgFriends[iFriend].mtLastActive);
                            TimeSpan tsDuration = DateTime.Now.Subtract(dtLastActive);
                            friends[iFriend].MinutesSinceStateChange = (uint)tsDuration.TotalMinutes;
                        }
                        else
                        {
                            friends[iFriend].MinutesSinceStateChange = 0;

                            // zero out the titleid if last active time is 0.  this protects privacy settings.
                            // see comments in CGetPresenceInfoContext::ProcessUser() at server\presence\inh\switchboard.h(3592).
                            friends[iFriend].LastSeenTitle = 0;
                        }
                        
                        friends[iFriend].OnlineState = wfReply.rgFriends[iFriend].OnlineState;
                        if ((friends[iFriend].OnlineState & PresDefs.P_STATE_FLAG_CLOAKED) != 0)
                        {
                            // dont convey the cloaked bit.  if they are "appear offline," we treat them as offline.
                            friends[iFriend].OnlineState = 0;
                        }
                    }

                    if (cacheResponse == null)
                    {
                        utils.CacheInsert( CacheType.FriendsPresence, cacheRequest, response, FriendsCacheExpirationSeconds, onRemove);
                    }
                }
                else
                {
                    friends = new FriendEx[0];
                }

                string szLog = "FRDX|"
                                + Utilities.GetSubjectName() + "|"
                                + Utilities.GetRequestID() + "|"
                                + Utilities.GetClientIPPort() + "|" 
                                + XUID.ToString("X") + "|"
                                + ((cacheResponse == null) ? "0" : "1") + "|"
                                + friends.Length;

                Xom.Log(XomAreaName.wcpresencelog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );

                ValidSeconds = FriendsCacheExpirationSeconds;
                return friends;
            }
            catch (XboxWebException)
            {
                throw;
            }
            catch (Exception e)
            {
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_40, e);
            }
        }

        [WebMethod]
        public RecentPlayerCollection GetRecentPlayers(ulong xuid, ushort maxRequest, ushort locale) 
        {
            try 
            {
                utils.CheckAPI("Presence.GetRecentPlayers");
                WebCachePresenceCounter.Counters.GetRecentPlayersRequestsPerSecond.Increment();
                WebCachePresenceCounter.Counters.GetRecentPlayersRequestsTotal.Increment();

                SoapFrontEndApp.AddErrorPerfCounter(WebCachePresenceCounter.Counters.GetRecentPlayersFailedRequestsPerSecond);
                SoapFrontEndApp.AddErrorPerfCounter(WebCachePresenceCounter.Counters.GetRecentPlayersFailedRequestsTotal);
                    
                string partnerName = Utilities.GetSubjectName();
                if (partnerName != null)
                {
                    WebCachePresenceCounter.Counters[partnerName].GetRecentPlayersRequestsPerSecond.Increment();
                    WebCachePresenceCounter.Counters[partnerName].GetRecentPlayersRequestsTotal.Increment();

                    SoapFrontEndApp.AddErrorPerfCounter(WebCachePresenceCounter.Counters[partnerName].GetRecentPlayersFailedRequestsPerSecond);
                    SoapFrontEndApp.AddErrorPerfCounter(WebCachePresenceCounter.Counters[partnerName].GetRecentPlayersFailedRequestsTotal);
                }

                RecentPlayerCollectionBuilder builder = new RecentPlayerCollectionBuilder(xuid, maxRequest);
                return builder.CreateRecentPlayerCollection(locale);
            }
            catch
            {
                throw;
            }

        }

        [WebMethod]
        public FriendsInfo GetFriends(
            byte[] WebID,
            string GamerTag,
            out uint ValidSeconds
            )
        {
            try
            {
                utils.CheckAPI("Presence.GetFriends");

                WebCachePresenceCounter.Counters.GetFriendsRequestsPerSecond.Increment();
                WebCachePresenceCounter.Counters.GetFriendsRequestsTotal.Increment();

                SoapFrontEndApp.AddErrorPerfCounter(WebCachePresenceCounter.Counters.GetFriendsFailedRequestsPerSecond);
                SoapFrontEndApp.AddErrorPerfCounter(WebCachePresenceCounter.Counters.GetFriendsFailedRequestsTotal);
                    
                string partnerName = Utilities.GetSubjectName();
                if (partnerName != null)
                {
                    WebCachePresenceCounter.Counters[partnerName].GetFriendsRequestsPerSecond.Increment();
                    WebCachePresenceCounter.Counters[partnerName].GetFriendsRequestsTotal.Increment();

                    SoapFrontEndApp.AddErrorPerfCounter(WebCachePresenceCounter.Counters[partnerName].GetFriendsFailedRequestsPerSecond);
                    SoapFrontEndApp.AddErrorPerfCounter(WebCachePresenceCounter.Counters[partnerName].GetFriendsFailedRequestsTotal);
                }
                    
                PUIDAndOwner puidAndOwner = utils.LookupWebID(WebID,GamerTag);
                
                Utilities.RequestInfo requestInfo = Utilities.GetRequestInfo();

                MemoryStream puidMemStream = new MemoryStream(8);
                BinaryWriter puidWriter = new BinaryWriter(puidMemStream);
                puidWriter.Write(puidAndOwner.PUID);
                puidMemStream.Close();
                byte[] cacheRequest = puidMemStream.ToArray();
                
                byte[] cacheResponse = utils.CacheLookup( CacheType.FriendsPresence, cacheRequest );

                byte[] response;
                if (cacheResponse == null)
                {
                    WebFriendsRequest request = new WebFriendsRequest();
                    request.puid = puidAndOwner.PUID;
                    request.header.dwSeqNum = (uint)(requestInfo.qwRequestID & 0xffffffff);
                
                    WebCachePresenceCounter.Counters.FriendsCacheMissPerSecond.Increment();
                    WebCachePresenceCounter.Counters.FriendsCacheMissTotal.Increment();

                    try
                    {
                        IVirtualInterfaceInfo vpresenceInfo = Config.GetVirtualInterface(VirtualInterface.xpnfd_presence_int, 1);
                        XUIDAndTrust[]  users = new XUIDAndTrust[1];
                        uint userFlags = 0;

                        // TODO: In the future, it would be nice to parse the locale in the web request requestInfo 
                        //  and figure out the country & language for this request and pass those to presence. 
                        //  For now, no web feature allows for the fetching of rich presence, so we can safely
                        //  just use english and US as valid defaults. 
                        XUIDAndTrust.SetUserFlagCountry(ref userFlags, 103);
                        XUIDAndTrust.SetUserFlagLanguage(ref userFlags, (uint)Locale.v1LanguageID.english);
                        
                        users[0] = new XUIDAndTrust(puidAndOwner.PUID, userFlags, 0.0F);

                        HTTPAuthData authData = new HTTPAuthData(requestInfo.ClientPort, requestInfo.ClientIP, requestInfo.qwRequestID, 0, users, 0xFFED0000 /* titleID */, (uint)XOService.PresNotification, 0);

                        // need to call WebAlive before calling WebFriends.
                        WebAliveRequest webAlive = new WebAliveRequest();
                        webAlive.puid = puidAndOwner.PUID;
                    
                        response = utils.FrontDoorRequest( string.Format("http://{0}:{1}/xpnfront/xpresence.srf", vpresenceInfo.IPAddressString, vpresenceInfo.Port), authData, (uint)XOService.PresNotification, 0, (byte[])webAlive);

                        WebAliveResponse waResponse = new WebAliveResponse();
                        waResponse.ReadBytes(response);
                        
                        if (waResponse.hr != HResult.S_OK)
                        {
                            throw new XboxWebInternalException(XEvent.Id.WEBCACHE_CODE_48, "Presence FD returned hr = " + waResponse.hr);
                        }

                        if (waResponse.puid != puidAndOwner.PUID)
                        {
                            throw new XboxWebInternalException(XEvent.Id.WEBCACHE_CODE_49, "Presence FD returned incorrect PUID:" + waResponse.puid.ToString("X"));
                        }
                        
                        response = utils.FrontDoorRequest( string.Format("http://{0}:{1}/xpnfront/xpresence.srf", vpresenceInfo.IPAddressString, vpresenceInfo.Port), authData, (uint)XOService.PresNotification, 0, (byte[])request);
                        
                    }
                    catch (FrontDoorNonFatalException e)
                    {
                        if (e.HResult == HResult.XONLINE_E_USER_NOT_PRESENT)
                            response = null;
                        else
                            throw;
                    }
                }
                else
                {
                    WebCachePresenceCounter.Counters.FriendsCacheHitPerSecond.Increment();
                    WebCachePresenceCounter.Counters.FriendsCacheHitTotal.Increment();
                    response = cacheResponse;
                }

                FriendsInfo friends;

                if (response != null)
                {
                    friends = ParseFrontDoorResponse(response, cacheResponse != null,
                                                     requestInfo.qwRequestID, puidAndOwner.PUID);

                    if (cacheResponse == null)
                    {
                        utils.CacheInsert( CacheType.FriendsPresence, cacheRequest, response, FriendsCacheExpirationSeconds, onRemove);
                    }
                }
                else
                {
                    friends = new FriendsInfo();
                    friends.OnlineFriends  = new OnlineFriend[0];
                    friends.OfflineFriends = new OfflineFriend[0];
                }

                string szLog = "FRD|"
                                + Utilities.GetSubjectName() + "|"
                                + Utilities.GetRequestID() + "|"
                                + Utilities.GetClientIPPort() + "|" 
                                + ByteConvert.ToReverseString(WebID) + "|"
                                + GamerTag + "|"
                                + ((cacheResponse == null) ? "0" : "1") + "|"
                                + friends.OnlineFriends.Length + "|"
                                + friends.OfflineFriends.Length;

                Xom.Log(XomAreaName.wcpresencelog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );

                ValidSeconds = FriendsCacheExpirationSeconds;
                return friends;
            }
            catch (XboxWebException)
            {
                throw;
            }
            catch (Exception e)
            {
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_40, e);
            }
        }

        FriendsInfo ParseFrontDoorResponse(byte[] response, bool fromCache, ulong requestId, ulong puid)
        {
            FriendsInfo friends = new FriendsInfo();
            ushort onlineFriendCount = 0;
            ushort offlineFriendCount = 0;
            uint i;
            
            try
            {
                WebFriendsResponse wfReply = new WebFriendsResponse();
                wfReply.ReadBytes( response );
                
                Debug.Assert(wfReply.header.dwMsgType == (uint)P_MSG_TYPES.PMSG_WEB_FRIENDS_REPLY);

                if (!fromCache && wfReply.header.dwSeqNum != (uint)(requestId & 0xffffffff))
                {
                    throw new XboxWebInternalException(XEvent.Id.WEBCACHE_CODE_44, "Presence FD returned non matching dwSeqNum:" + wfReply.header.dwSeqNum.ToString("X") + "/" + ((uint)(requestId & 0xffffffff)).ToString("X"));
                }

                Debug.Assert(wfReply.header.sgaddr.inaSg == 0);
                Debug.Assert(wfReply.header.sgaddr.dwSpiSg == 0);
                Debug.Assert(wfReply.header.sgaddr.qwXboxId == 0);
                Debug.Assert(wfReply.header.sgaddr.abReserved == 0);
                
                if (wfReply.hr != HResult.S_OK)
                {
                    throw new XboxWebInternalException(XEvent.Id.WEBCACHE_CODE_45, "Presence FD returned hr = " + ((HResult) wfReply.hr));
                }

                if (wfReply.puid != puid)
                {
                    throw new XboxWebInternalException(XEvent.Id.WEBCACHE_CODE_46, "Presence FD returned incorrect PUID:" + wfReply.puid.ToString("X"));
                }

                if (wfReply.cdwFriends > MAX_FRIENDS)
                {
                    throw new XboxWebInternalException(XEvent.Id.WEBCACHE_CODE_47, "Friend count " + wfReply.cdwFriends + " returned by Presence");
                }

                // need to convert new style list to the old style list

                // first loop to get list sizes.
                for (i = 0; i < wfReply.cdwFriends; i++)
                {
                    if (wfReply.rgFriends[i].FriendStatus != PresDefs.P_BUDDY_STATUS_OK)
                    {
                        // old style api didnt return these at all, so we filter them out for back compat.
                        continue;
                    }
                    
                    if ((wfReply.rgFriends[i].OnlineState & PresDefs.P_STATE_FLAG_ONLINE) != 0 &&
                        (wfReply.rgFriends[i].OnlineState & PresDefs.P_STATE_FLAG_CLOAKED) == 0)
                    {
                        onlineFriendCount++;
                    }
                    else
                    {
                        offlineFriendCount++;
                    }
                }
                
                friends.OnlineFriends = new OnlineFriend[onlineFriendCount];
                friends.OfflineFriends = new OfflineFriend[offlineFriendCount];
                onlineFriendCount = 0;
                offlineFriendCount = 0;

                // second loop to populate the fields.
                for (i = 0; i < wfReply.cdwFriends; i++)
                {
                    if (wfReply.rgFriends[i].FriendStatus != PresDefs.P_BUDDY_STATUS_OK)
                    {
                        // old style api didnt return these at all, so we filter them out for back compat.
                        continue;
                    }
                    
                    if ((wfReply.rgFriends[i].OnlineState & PresDefs.P_STATE_FLAG_ONLINE) != 0 &&
                        (wfReply.rgFriends[i].OnlineState & PresDefs.P_STATE_FLAG_CLOAKED) == 0)
                    {
                        friends.OnlineFriends[onlineFriendCount].G = wfReply.rgFriends[i].szGamerTag;
                        friends.OnlineFriends[onlineFriendCount].S = wfReply.rgFriends[i].OnlineState;
                        friends.OnlineFriends[onlineFriendCount].T = wfReply.rgFriends[i].TitleId;
                        onlineFriendCount++;
                    }
                    else
                    {
                        friends.OfflineFriends[offlineFriendCount].G = wfReply.rgFriends[i].szGamerTag;
                        offlineFriendCount++;
                    }
                }
            }
            catch (XboxWebInternalException)
            {
                throw;
            }
            catch (Exception e)
            {
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_INTERNAL_NONFATAL_ERROR_1, "Error parsing results from Presence FD", e);
            }

            return friends;
        }

        static void RemovedCallback(
            string key,
            object value,
            CacheItemRemovedReason reason
            )
        {
            if (reason == CacheItemRemovedReason.Underused)
            {
                WebCachePresenceCounter.Counters.UnderusedCacheItemsPerSecond.Increment();
                WebCachePresenceCounter.Counters.UnderusedCacheItemsTotal.Increment();
            }
            else if (reason == CacheItemRemovedReason.Expired)
            {
                WebCachePresenceCounter.Counters.ExpiredCacheItemsPerSecond.Increment();
                WebCachePresenceCounter.Counters.ExpiredCacheItemsTotal.Increment();
            }
            else
            {
                Debug.Assert( false, "Item removed from UserSettings Cache due to " + reason.ToString() );
              Xom.NtEvent( XEvent.Id.WEBCACHE_INTERNAL_NONFATAL_ERROR_2,   "Item removed from UserSettings Cache due to " + reason.ToString());
            }
        }

        static Utilities utils;
        static uint FriendsCacheExpirationSeconds;
        static CacheItemRemovedCallback onRemove;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Messaging\Test\dvt\messagingtest.cs ===
using NUnit.Framework;
using System;
using System.Text;
using System.IO;
using System.Net;
using System.Web;
using System.Xml;
using System.Threading;
using XBOX.Online.nUnit;
using xonline.common.service;

using xonline.server.webcache.messaging.motdtool;


namespace xonline.server.webcache.messaging.test.dvt 
{
    // Change the URL and add the HTTP headers that make the widget validation code happy:).
    public class MessagingWidget : Messaging
    {
        public MessagingWidget()
        {
            Url = "http://localhost/Messaging/Messaging.asmx";
        }

        override protected WebRequest GetWebRequest( Uri url )
        {
            WebRequest wr = base.GetWebRequest( url );
            if( null != wr )
            {
                wr.Headers.Add( "Subject-Name", "DebugPartner" );
                wr.Headers.Add( "Client-IP-Port", "1.1.1.1:1000" );
                wr.Headers.Add( "RequestId", "CAFEBABEDEADBEEF" );
            }

            return wr;
        }
    }

    // Class for testing CAB attachments
    public class XCabAttachment : WireData
    {
        // CFHEADER
        public uint             dwSignature;
        public uint             dwChecksumHeader;
        public uint             cbCabinet;
        public uint             dwChecksumFolders;
        public uint             dwCoffFiles;
        public uint             dwChecksumFiles;

        public ushort           wVersion;
        public ushort           cFolders;
        public ushort           cFiles;
        public ushort           wFlags;
        public ushort           wSetId;
        public ushort           iCabinet;

        // CFRESERVE
        public ushort           cbCFHeader;
        public byte             cbCFFolder;
        public byte             cbCFData;

        // RC4_SHA_HEADER
        [WireInfo(ArraySize=20)]
        public byte[]           rgbDigestFoldersChecksum;
        [WireInfo(ArraySize=8)]
        public byte[]           rgbDigestFoldersConfounder;
        
        // RC4_SHA_HEADER
        [WireInfo(ArraySize=20)]
        public byte[]           rgbDigestFilesChecksum;
        [WireInfo(ArraySize=8)]
        public byte[]           rgbDigestFilesConfounder;

        // RC4_SHA_HEADER
        [WireInfo(ArraySize=20)]
        public byte[]           rgbHmacChecksum;
        [WireInfo(ArraySize=8)]
        public byte[]           rgbHmacConfounder;

        public uint             dwCheckpoint;

        [WireInfo(ArraySize=256)]
        public byte[]           rgbPkSignature;

        [WireInfo(Serialize=false)]
        public uint cbData;
        [WireInfo(Serialize=false)]
        public byte[] pbData;

        public void SendValidLookingGarbage( byte[] pbDataIn )
        {
            cbData = (uint) pbDataIn.Length;
            pbData = pbDataIn;

            dwSignature = 0x4643534D;
            dwChecksumHeader = 0;
            cbCabinet = 384 + cbData;
            dwChecksumFolders = 0;
            dwCoffFiles = 0;
            dwChecksumFiles = 0;
            wVersion = 0x0103;
            cFolders = 0;
            cFiles = 0;
            wFlags = 0x0004; // 4=contains reserve data
            wSetId = 0;
            iCabinet = 0;
            cbCFHeader = 344;
            cbCFFolder = 28;
            cbCFData = 0;
            rgbDigestFoldersChecksum = new byte[ 20 ];
            rgbDigestFoldersConfounder = new byte[ 8 ];
            rgbDigestFilesChecksum = new byte[ 20 ];
            rgbDigestFilesConfounder = new byte[ 8 ];
            rgbHmacChecksum = new byte[ 20 ];
            rgbHmacConfounder = new byte[ 8 ];
            dwCheckpoint = 0;
            rgbPkSignature = new byte[ 256 ];            
        }

        public override void WriteStream( BinaryWriter binaryWriter )
        {
            base.WriteStream( binaryWriter );

            if( 0 != cbData )
            {
                binaryWriter.Write( pbData, 0, (int) cbData );
            }
        }
    };

    [TestFixture]
    public class MessagingTests
    {            
        public const uint    c_titleId = 0x00004d2;
        public const WCMessageFlags c_TitleFlags = 
                                            WCMessageFlags.TitleReserved0 |
                                            WCMessageFlags.TitleReserved1 |
                                            WCMessageFlags.TitleReserved2 |
                                            WCMessageFlags.TitleReserved3 |
                                            WCMessageFlags.TitleReserved4 |
                                            WCMessageFlags.TitleReserved5 |
                                            WCMessageFlags.TitleReserved6; // Bug in wsdl.exe | WCMessageFlags.TitleReserved7;

        // Comparison utility function for user message summaries
        public bool IsSummaryEqual( ref WCMessageSummary s1, ref WCMessageSummary s2 )
        {
            if( s1.Sender == s2.Sender &&
                s1.SenderContext == s2.SenderContext &&
                s1.SentTime == s2.SentTime &&
                s1.MessageID == s2.MessageID &&
                s1.MessageFlags == s2.MessageFlags &&
                s1.SenderTitleID == s2.SenderTitleID &&
                s1.MessageType == s2.MessageType &&
                s1.ExpireMinutes == s2.ExpireMinutes &&
                s1.DetailsSize == s2.DetailsSize )
            {
                return true;
            }

            return false;
        }

        // Comparison utility function for system message summaries
        public bool IsSummaryEqual( ref WCTitleWideMessageSummary s1, ref WCTitleWideMessageSummary s2 )
        {
            if( s1.TitleID == s2.TitleID &&
                s1.Region == s2.Region &&
                s1.SenderName == s2.SenderName &&
                s1.Description == s2.Description &&
                s1.SenderContext == s2.SenderContext &&
                s1.SentTime == s2.SentTime &&
                s1.MessageID == s2.MessageID &&
                s1.MessageFlags == s2.MessageFlags &&
                s1.MessageType == s2.MessageType &&
                s1.ExpireMinutes == s2.ExpireMinutes &&
                s1.DetailsSize == s2.DetailsSize )
            {
                return true;
            }

            return false;
        }

        // Function to dump message details to the console
        public void DumpDetails( ref WCMessageDetails gmdDetails )
        {
            Console.WriteLine( "    Details:" );
            if( null != gmdDetails )
            {
                if( null != gmdDetails.NullProp )
                {
                    for( uint iProp = 0; iProp < gmdDetails.NullProp.Length; iProp++ )
                    {
                        Console.WriteLine( "        Null: PropID={0}", gmdDetails.NullProp[ iProp ].PropID );
                    }
                }
                if( null != gmdDetails.ByteProp )
                {
                    for( uint iProp = 0; iProp < gmdDetails.ByteProp.Length; iProp++ )
                    {
                        Console.WriteLine( "        Byte: PropID={0} Value={1}", gmdDetails.ByteProp[ iProp ].PropID, gmdDetails.ByteProp[ iProp ].Value );
                    }
                }
                if( null != gmdDetails.WordProp )
                {
                    for( uint iProp = 0; iProp < gmdDetails.WordProp.Length; iProp++ )
                    {
                        Console.WriteLine( "        Word: PropID={0} Value={1}", gmdDetails.WordProp[ iProp ].PropID, gmdDetails.WordProp[ iProp ].Value );
                    }
                }
                if( null != gmdDetails.DwordProp )
                {
                    for( uint iProp = 0; iProp < gmdDetails.DwordProp.Length; iProp++ )
                    {
                        Console.WriteLine( "        Dword: PropID={0} Value={1}", gmdDetails.DwordProp[ iProp ].PropID, gmdDetails.DwordProp[ iProp ].Value );
                    }
                }
                if( null != gmdDetails.QwordProp )
                {
                    for( uint iProp = 0; iProp < gmdDetails.QwordProp.Length; iProp++ )
                    {
                        Console.WriteLine( "        Qword: PropID={0} Value={1}", gmdDetails.QwordProp[ iProp ].PropID, gmdDetails.QwordProp[ iProp ].Value );
                    }
                }
                if( null != gmdDetails.StringProp )
                {
                    for( uint iProp = 0; iProp < gmdDetails.StringProp.Length; iProp++ )
                    {
                        Console.WriteLine( "        String: PropID={0} Value={1}", gmdDetails.StringProp[ iProp ].PropID, gmdDetails.StringProp[ iProp ].Value );
                    }
                }
                if( null != gmdDetails.TimeProp )
                {
                    for( uint iProp = 0; iProp < gmdDetails.TimeProp.Length; iProp++ )
                    {
                        Console.WriteLine( "        Time: PropID={0} Value={1}", gmdDetails.TimeProp[ iProp ].PropID, gmdDetails.TimeProp[ iProp ].Value );
                    }
                }
                if( null != gmdDetails.BinaryProp )
                {
                    for( uint iProp = 0; iProp < gmdDetails.BinaryProp.Length; iProp++ )
                    {
                        Console.WriteLine( "        Binary: PropID={0} Value={1}", gmdDetails.BinaryProp[ iProp ].PropID, gmdDetails.BinaryProp[ iProp ].Value );
                    }
                }
                if( null != gmdDetails.AttachmentProp )
                {
                    for( uint iProp = 0; iProp < gmdDetails.AttachmentProp.Length; iProp++ )
                    {
                        Console.WriteLine( "        Attachment: PropID={0} AttachSize={1} AttachFlags={2} AttachURL={2}", 
                            gmdDetails.AttachmentProp[ iProp ].AttachSize, 
                            gmdDetails.AttachmentProp[ iProp ].AttachFlags, 
                            gmdDetails.AttachmentProp[ iProp ].AttachUrl );
                    }
                }
                if( null != gmdDetails.BoolProp )
                {
                    for( uint iProp = 0; iProp < gmdDetails.BoolProp.Length; iProp++ )
                    {
                        Console.WriteLine( "        Bool: PropID={0} Value={1}", gmdDetails.BoolProp[ iProp ].PropID, gmdDetails.BoolProp[ iProp ].Value );
                    }
                }
                if( null != gmdDetails.StringIdProp )
                {
                    for( uint iProp = 0; iProp < gmdDetails.StringIdProp.Length; iProp++ )
                    {
                        Console.WriteLine( "        StringID: PropID={0} Value={1}", gmdDetails.StringIdProp[ iProp ].PropID, gmdDetails.StringIdProp[ iProp ].Value );
                    }
                }
            }

        } // DumpDetails

        //
        // Useful tests for viewing the current DB state //////////////////////
        //

        [Test]
        public void TestEnumMessages()
        {
            MessagingWidget service = new MessagingWidget();
             
            Console.WriteLine( "Calling EnumMessages" );
            Console.WriteLine();

            byte[] webID = new byte[8];

            WCMessageSummary[] summary = null;
            UInt32 hr = service.EnumMessages( webID,       // WebID
                                              "xmsgtest1", // GamerTag
                                              out summary );
            if( HResult.Failed( hr ) )
            {
                throw new ApplicationException( "EnumMessages failed, hr=" + hr );
            }

            Console.WriteLine( "EnumMessages returned {0}", hr );
            if( HResult.Succeeded( hr ) )
            {
                for( int iMessage = 0; iMessage < summary.Length; iMessage++ )
                {
                    Console.WriteLine( "    Message {0}", iMessage );
                    Console.WriteLine( "        szSenderName - {0}", summary[ iMessage ].Sender );
                    Console.WriteLine( "        qwSenderContext - {0}", summary[ iMessage ].SenderContext );
                    Console.WriteLine( "        mtSentTime - {0}", summary[ iMessage ].SentTime );
                    Console.WriteLine( "        dwMessageID - {0}", summary[ iMessage ].MessageID );
                    Console.WriteLine( "        dwMessageFlags - {0}", summary[ iMessage ].MessageFlags );
                    Console.WriteLine( "        dwSenderTitleID - {0}", summary[ iMessage ].SenderTitleID );
                    Console.WriteLine( "        bMessageType - {0}", summary[ iMessage ].MessageType );
                    Console.WriteLine( "        wExpireMinutes - {0}", summary[ iMessage ].ExpireMinutes );
                    Console.WriteLine( "        cbDetails - {0}", summary[ iMessage ].DetailsSize );
                }
            }
            Console.WriteLine();
        }

        [Test]
        public void TestEnumSystemMessages()
        {
            Console.WriteLine( "Begin TestEnumSystemMessages" );

            uint hr;
            MessagingWidget service = new MessagingWidget();

            Console.WriteLine( "    Enumerate messages for title" );

            WCTitleWideMessageSummary[] summaries = null;
            hr = service.EnumTitleWideMessages( c_titleId,       // TitleID
                                                out summaries ); // Message Summaries
            if( HResult.Failed( hr ) )
            {
                throw new ApplicationException( "EnumTitleWideMessages failed, hr=" + hr );
            }

            for( uint iMessage = 0; iMessage < summaries.Length; iMessage++ )
            {
                Console.WriteLine( "    Message {0}", iMessage );
                Console.WriteLine( "        szDescription - {0}",   summaries[ iMessage ].Description );
                Console.WriteLine( "        dwTitleID - {0}",       summaries[ iMessage ].TitleID );
                Console.WriteLine( "        dwRegion - {0}",        summaries[ iMessage ].Region );
                Console.WriteLine( "        szSenderName - {0}",    summaries[ iMessage ].SenderName );
                Console.WriteLine( "        qwSenderContext - {0}", summaries[ iMessage ].SenderContext );
                Console.WriteLine( "        ftSentTime - {0}",      summaries[ iMessage ].SentTime );
                Console.WriteLine( "        dwMessageID - {0}",     summaries[ iMessage ].MessageID );
                Console.WriteLine( "        dwMessageFlags - {0}",  summaries[ iMessage ].MessageFlags );
                Console.WriteLine( "        bMessageType - {0}",    summaries[ iMessage ].MessageType );
                Console.WriteLine( "        wExpireMinutes - {0}",  summaries[ iMessage ].ExpireMinutes );
                Console.WriteLine( "        cbDetails - {0}",       summaries[ iMessage ].DetailsSize );
            }

            Console.WriteLine( "End TestEnumSystemMessages" );

        } // TestEnumSystemMessages

        //
        // Postive test cases /////////////////////////////////////////////////
        //

        [Test]
        public void TestSendRevoke()
        {
            // This test does the following:
            // 1) Sends a message from user 1 to user 2
            // 2) Has user 2 enumerate to find the message
            // 3) Has user 2 get details on the message and set a title reserved flag in the same call
            // 5) Has user 2 get details again to see if the flags changed
            // 4) Has user 2 change flags on the message in a separate call (clear the previous and set a new one)
            // 5) Has user 2 get details again to see if the flags changed
            // 6) Has user 1 revoke the message
            // 7) Has user 2 re-enumerate to see if the message is gone
            
            MessagingWidget service = new MessagingWidget();
             
            byte[] webID1 = new byte[8];
            byte[] webID2 = new byte[8];

            Console.WriteLine( "Begin TestSendRevoke" );

            Console.WriteLine( "    Send a message from user 1 to user 2" );

            string[] recipients = new string[ 1 ];
            recipients[ 0 ] = "xmsgtest2";

            WCMessageDetails smDetails = new WCMessageDetails();

            // Add some details
            smDetails.DwordProp = new WCDwordProp[ 1 ];
            smDetails.DwordProp[ 0 ] = new WCDwordProp();
            smDetails.DwordProp[ 0 ].PropID = 0x01;
            smDetails.DwordProp[ 0 ].Value = 52;

            // Send 2 attachments
            WCMessageAttachment[] attachments = new WCMessageAttachment[ 2 ];

            // Add a blob attachment
            attachments[ 0 ] = new WCMessageAttachment();
            attachments[ 0 ].PropID = 0x02;
            attachments[ 0 ].Flags = 0;
            attachments[ 0 ].Data = new byte[ 100 ];

            // Add a package attachment
            attachments[ 1 ] = new WCMessageAttachment();
            attachments[ 1 ].PropID = 0x03;
            attachments[ 1 ].Flags = WCAttachFlags.Directory;

            byte[] rgbData = new byte[ 100 ];
            XCabAttachment mycabattach = new XCabAttachment();
            mycabattach.SendValidLookingGarbage( rgbData );
            
            attachments[ 1 ].Data = (byte[])mycabattach;
         

            MemoryStream stream = new MemoryStream( attachments[ 0 ].Data );
            BinaryWriter writer = new BinaryWriter( stream );
            writer.Write( "This is a test attachment." );  

            WCRecipientResult[] results = null;
            UInt32 hr = service.SendMessage( webID1,                        // SenderWebID
                                             "xmsgtest1",                   // SenderGamerTag
                                             0,                             // SenderContext
                                             WCMessageFlags.TitleReserved0, // MessageFlags
                                             c_titleId,                     // SenderTitleID
                                             60,                            // ExpireMinutes
                                             WCMessageType.TitleCustom,     // MessageType
                                             recipients,                    // Recipient IDs
                                             smDetails,                     // Details
                                             attachments,                   // Attachments
                                             out results );
            if( HResult.Failed( hr ) )
            {
                throw new ApplicationException( "SendMessage failed, hr=" + hr );
            }

            if( recipients.Length != results.Length )
            {
                throw new ApplicationException( "Returned recipient count doesn't match sent recipient count (" + results.Length + " != " + recipients.Length + ")!" );
            }

            for( uint iRecip = 0; iRecip < results.Length; iRecip++ )
            {
                if( HResult.Failed( results[ iRecip ].MessageID ) )
                {
                    if( HResult.S_FALSE != hr )
                    {
                        throw new ApplicationException( "SendMessage failed for recipient " + results[ iRecip ].User + ", but overall hr is not S_FALSE" );
                    }
                    else
                    {
                        throw new ApplicationException( "SendMessage failed for recipient " + results[ iRecip ].User + ", hr=" + results[ iRecip ].MessageID );
                    }
                }
            }

            uint uiSentMessageID = results[ 0 ].MessageID;

            Console.WriteLine( "    SendMessage returned messageID={0}", uiSentMessageID );

            Console.WriteLine( "    Enumerate messages for user 2" );

            WCMessageSummary[] summaries = null;
            hr = service.EnumMessages( webID2,          // UserWebID
                                       "xmsgtest2",     // UserGamerTag
                                       out summaries ); // Message Summaries
            if( HResult.Failed( hr ) )
            {
                throw new ApplicationException( "EnumMessages failed, hr=" + hr );
            }

            uint iFoundMessage = 0xFFFFFFFF;
            for( uint iMessage = 0; iMessage < summaries.Length; iMessage++ )
            {
                if( uiSentMessageID == summaries[ iMessage ].MessageID ) 
                {
                    iFoundMessage = iMessage;
                    Console.WriteLine( "    Found sent message, ID={0}", summaries[ iMessage ].MessageID );
                }

                Console.WriteLine( "    Message {0}", iMessage );
                Console.WriteLine( "        szSenderName - {0}",    summaries[ iMessage ].Sender );
                Console.WriteLine( "        qwSenderContext - {0}", summaries[ iMessage ].SenderContext );
                Console.WriteLine( "        mtSentTime - {0}",      summaries[ iMessage ].SentTime );
                Console.WriteLine( "        dwMessageID - {0}",     summaries[ iMessage ].MessageID );
                Console.WriteLine( "        dwMessageFlags - {0}",  summaries[ iMessage ].MessageFlags );
                Console.WriteLine( "        dwSenderTitleID - {0}", summaries[ iMessage ].SenderTitleID );
                Console.WriteLine( "        bMessageType - {0}",    summaries[ iMessage ].MessageType );
                Console.WriteLine( "        wExpireMinutes - {0}",  summaries[ iMessage ].ExpireMinutes );
                Console.WriteLine( "        cbDetails - {0}",       summaries[ iMessage ].DetailsSize );
            }
            if( 0xFFFFFFFF == iFoundMessage )
            {
                throw new ApplicationException( "EnumMessages did not return the message sent!" );
            }

            if( WCMessageFlags.TitleReserved0 != ( summaries[ iFoundMessage ].MessageFlags & c_TitleFlags ) )
            {
                throw new ApplicationException( "Flags returned by EnumMessages didn't match ones sent, (" + summaries[ iFoundMessage ].MessageFlags + " != WCMessageFlags.TitleReserved0)!" );
            }

            Console.WriteLine( "    Get message details for Message {0}", uiSentMessageID );

            WCMessageSummary gmdSummary = null;
            WCMessageDetails gmdDetails = null;
            hr = service.GetMessageDetails( webID2,                        // UserWebID
                                            "xmsgtest2",                   // UserGamerTag
                                            uiSentMessageID,               // MessageID
                                            WCMessageFlags.TitleReserved1, // SetFlags
                                            WCMessageFlags.TitleReserved0, // UnsetFlags
                                            out gmdSummary,
                                            out gmdDetails );
            if( HResult.Failed( hr ) )
            {
                throw new ApplicationException( "GetMessageDetails failed, hr=" + hr );
            }

            Console.WriteLine( "    Summary:" );
            Console.WriteLine( "        szSenderName - {0}",    gmdSummary.Sender );
            Console.WriteLine( "        qwSenderContext - {0}", gmdSummary.SenderContext );
            Console.WriteLine( "        mtSentTime - {0}",      gmdSummary.SentTime );
            Console.WriteLine( "        dwMessageID - {0}",     gmdSummary.MessageID );
            Console.WriteLine( "        dwMessageFlags - {0}",  gmdSummary.MessageFlags );
            Console.WriteLine( "        dwSenderTitleID - {0}", gmdSummary.SenderTitleID );
            Console.WriteLine( "        bMessageType - {0}",    gmdSummary.MessageType );
            Console.WriteLine( "        wExpireMinutes - {0}",  gmdSummary.ExpireMinutes );
            Console.WriteLine( "        cbDetails - {0}",       gmdSummary.DetailsSize );

            // Update the enum summary with our flag change
            summaries[ iFoundMessage ].MessageFlags &= ~WCMessageFlags.TitleReserved0;
            summaries[ iFoundMessage ].MessageFlags |= WCMessageFlags.TitleReserved1;

            if( !IsSummaryEqual( ref gmdSummary, ref summaries[ iFoundMessage ] ) )
            {
                throw new ApplicationException( "Summary returned by EnumMessages doesn't match one returned by GetMessageDetails for MessageID=" + uiSentMessageID );
            }

            DumpDetails( ref gmdDetails );

/*
            if( gmdDetails != smDetails )
            {
                throw new ApplicationException( "Details sent don't match those returned by GetMessageDetails for MessageID=" + uiSentMessageID );
            }
*/

            Console.WriteLine( "    Get details again for Message {0} to see if the flags changed", uiSentMessageID );

            hr = service.GetMessageDetails( webID2,           // UserWebID
                                            "xmsgtest2",      // UserGamerTag
                                            uiSentMessageID,  // MessageID
                                            0,                // SetFlags
                                            0,                // UnsetFlags
                                            out gmdSummary,
                                            out gmdDetails );
            if( HResult.Failed( hr ) )
            {
                throw new ApplicationException( "GetMessageDetails failed, hr=" + hr );
            }

            if( WCMessageFlags.TitleReserved1 != ( gmdSummary.MessageFlags & c_TitleFlags ) )
            {
                throw new ApplicationException( "Flags returned by GetMessageDetails didn't match expected, (" + gmdSummary.MessageFlags + " != WCMessageFlags.TitleReserved1)!" );
            }

            Console.WriteLine( "    Change flags for Message {0}", uiSentMessageID );

            hr = service.SetMessageFlags( webID2,                          // UserWebID
                                          "xmsgtest2",                     // UserGamerTag
                                          uiSentMessageID,                 // MessageID
                                          WCMessageFlags.TitleReserved2,   // SetFlags
                                          WCMessageFlags.TitleReserved1 ); // UnsetFlags
            if( HResult.Failed( hr ) )
            {
                throw new ApplicationException( "SetMessageFlags failed, hr=" + hr );
            }

            Console.WriteLine( "    Get details again for Message {0} to see if the flags changed", uiSentMessageID );

            hr = service.GetMessageDetails( webID2,           // UserWebID
                                            "xmsgtest2",      // UserGamerTag
                                            uiSentMessageID,  // MessageID
                                            0,                // SetFlags
                                            0,                // UnsetFlags
                                            out gmdSummary,
                                            out gmdDetails );
            if( HResult.Failed( hr ) )
            {
                throw new ApplicationException( "GetMessageDetails failed, hr=" + hr );
            }

            if( WCMessageFlags.TitleReserved2 != ( gmdSummary.MessageFlags & c_TitleFlags ) )
            {
                throw new ApplicationException( "Flags returned by GetMessageDetails didn't match expected, (" + gmdSummary.MessageFlags + " != WCMessageFlags.TitleReserved2)!" );
            }

            Console.WriteLine( "    Revoke Message " + uiSentMessageID );

            hr = service.RevokeMessage( webID1,      // SenderWebID
                                        "xmsgtest1", // SenderGamerTag
                                        results );
            if( HResult.Failed( hr ) )
            {
                throw new ApplicationException( "RevokeMessage failed, hr=" + hr );
            }

            Console.WriteLine( "    Enumerate again to see if the message is gone" );

            hr = service.EnumMessages( webID2,          // UserWebID
                                       "xmsgtest2",     // UserGamerTag
                                       out summaries ); // Message Summaries
            if( HResult.Failed( hr ) )
            {
                throw new ApplicationException( "EnumMessages failed, hr=" + hr );
            }

            iFoundMessage = 0xFFFFFFFF;
            for( uint iMessage = 0; iMessage < summaries.Length; iMessage++ )
            {
                if( uiSentMessageID == summaries[ iMessage ].MessageID ) 
                {
                    iFoundMessage = iMessage;
                    Console.WriteLine( "    Found sent message, ID={0}", summaries[ iMessage ].MessageID );
                }

                Console.WriteLine( "    Message {0}", iMessage );
                Console.WriteLine( "        szSenderName - {0}",    summaries[ iMessage ].Sender );
                Console.WriteLine( "        qwSenderContext - {0}", summaries[ iMessage ].SenderContext );
                Console.WriteLine( "        mtSentTime - {0}",      summaries[ iMessage ].SentTime );
                Console.WriteLine( "        dwMessageID - {0}",     summaries[ iMessage ].MessageID );
                Console.WriteLine( "        dwMessageFlags - {0}",  summaries[ iMessage ].MessageFlags );
                Console.WriteLine( "        dwSenderTitleID - {0}", summaries[ iMessage ].SenderTitleID );
                Console.WriteLine( "        bMessageType - {0}",    summaries[ iMessage ].MessageType );
                Console.WriteLine( "        wExpireMinutes - {0}",  summaries[ iMessage ].ExpireMinutes );
                Console.WriteLine( "        cbDetails - {0}",       summaries[ iMessage ].DetailsSize );
            }
            if( 0xFFFFFFFF != iFoundMessage )
            {
                throw new ApplicationException( "EnumMessages returned the message, but it should have been revoked!" );
            }

            Console.WriteLine( "End TestSendRevoke" );

        } // TestSendRevoke

        [Test]
        public void TestSendDelete()
        {
            // This test does the following:
            // 1) Sends a message from user 1 to user 2
            // 2) Has user 2 enumerate to find the message
            // 3) Has user 2 get details on the message
            // 4) Has user 2 change flags on the message
            // 5) Has user 2 re-enumerate to see if the flags changed
            // 6) Has user 2 delete the message
            // 7) Has user 2 re-enumerate to see if the message is gone

            MessagingWidget service = new MessagingWidget();
             
            byte[] webID1 = new byte[8];
            byte[] webID2 = new byte[8];

            Console.WriteLine( "Begin TestSendDelete" );

            Console.WriteLine( "    Send a message from user 1 to user 2" );

            string[] recipients = new string[ 1 ];
            recipients[ 0 ] = "xmsgtest2";

            WCMessageDetails smDetails = new WCMessageDetails();

            WCMessageAttachment[] attachments = new WCMessageAttachment[ 1 ];
            attachments[ 0 ] = new WCMessageAttachment();

            WCRecipientResult[] results = null;
            UInt32 hr = service.SendMessage( webID1,                        // SenderWebID
                                             "xmsgtest1",                   // SenderGamerTag
                                             0,                             // SenderContext
                                             WCMessageFlags.TitleReserved0, // MessageFlags
                                             c_titleId,                     // SenderTitleID
                                             60,                            // ExpireMinutes
                                             WCMessageType.TitleCustom,     // MessageType
                                             recipients,                    // Recipient IDs
                                             smDetails,                     // Details
                                             attachments,                   // Attachments
                                             out results );
            if( HResult.Failed( hr ) )
            {
                throw new ApplicationException( "SendMessage failed, hr=" + hr );
            }

            if( recipients.Length != results.Length )
            {
                throw new ApplicationException( "Returned recipient count doesn't match sent recipient count (" + results.Length + " != " + recipients.Length + ")!" );
            }

            for( uint iRecip = 0; iRecip < results.Length; iRecip++ )
            {
                if( HResult.Failed( results[ iRecip ].MessageID ) )
                {
                    if( HResult.S_FALSE != hr )
                    {
                        throw new ApplicationException( "SendMessage failed for recipient " + results[ iRecip ].User + ", but overall hr is not S_FALSE" );
                    }
                    else
                    {
                        throw new ApplicationException( "SendMessage failed for recipient " + results[ iRecip ].User + ", hr=" + results[ iRecip ].MessageID );
                    }
                }
            }

            uint uiSentMessageID = results[ 0 ].MessageID;

            Console.WriteLine( "    SendMessage returned messageID={0}", uiSentMessageID );

            Console.WriteLine( "    Enumerate messages for user 2" );

            WCMessageSummary[] summaries = null;
            hr = service.EnumMessages( webID2,          // UserWebID
                                       "xmsgtest2",     // UserGamerTag
                                       out summaries ); // Message Summaries
            if( HResult.Failed( hr ) )
            {
                throw new ApplicationException( "EnumMessages failed, hr=" + hr );
            }

            uint iFoundMessage = 0xFFFFFFFF;
            for( uint iMessage = 0; iMessage < summaries.Length; iMessage++ )
            {
                if( uiSentMessageID == summaries[ iMessage ].MessageID ) 
                {
                    iFoundMessage = iMessage;
                    Console.WriteLine( "    Found sent message, ID={0}", summaries[ iMessage ].MessageID );
                }

                Console.WriteLine( "    Message {0}", iMessage );
                Console.WriteLine( "        szSenderName - {0}",    summaries[ iMessage ].Sender );
                Console.WriteLine( "        qwSenderContext - {0}", summaries[ iMessage ].SenderContext );
                Console.WriteLine( "        mtSentTime - {0}",      summaries[ iMessage ].SentTime );
                Console.WriteLine( "        dwMessageID - {0}",     summaries[ iMessage ].MessageID );
                Console.WriteLine( "        dwMessageFlags - {0}",  summaries[ iMessage ].MessageFlags );
                Console.WriteLine( "        dwSenderTitleID - {0}", summaries[ iMessage ].SenderTitleID );
                Console.WriteLine( "        bMessageType - {0}",    summaries[ iMessage ].MessageType );
                Console.WriteLine( "        wExpireMinutes - {0}",  summaries[ iMessage ].ExpireMinutes );
                Console.WriteLine( "        cbDetails - {0}",       summaries[ iMessage ].DetailsSize );
            }
            if( 0xFFFFFFFF == iFoundMessage )
            {
                throw new ApplicationException( "EnumMessages did not return the message sent!" );
            }

            if( WCMessageFlags.TitleReserved0 != ( summaries[ iFoundMessage ].MessageFlags & c_TitleFlags ) )
            {
                throw new ApplicationException( "Flags returned by EnumMessages didn't match ones sent, (" + summaries[ iFoundMessage ].MessageFlags + " != WCMessageFlags.TitleReserved0)!" );
            }

            Console.WriteLine( "    Get message details for Message {0}", uiSentMessageID );

            WCMessageSummary gmdSummary = null;
            WCMessageDetails gmdDetails = null;
            hr = service.GetMessageDetails( webID2,                        // UserWebID
                                            "xmsgtest2",                   // UserGamerTag
                                            uiSentMessageID,               // MessageID
                                            WCMessageFlags.TitleReserved1, // SetFlags
                                            WCMessageFlags.TitleReserved0, // UnsetFlags
                                            out gmdSummary,
                                            out gmdDetails );
            if( HResult.Failed( hr ) )
            {
                throw new ApplicationException( "GetMessageDetails failed, hr=" + hr );
            }

            Console.WriteLine( "    Summary:" );
            Console.WriteLine( "        szSenderName - {0}",    gmdSummary.Sender );
            Console.WriteLine( "        qwSenderContext - {0}", gmdSummary.SenderContext );
            Console.WriteLine( "        mtSentTime - {0}",      gmdSummary.SentTime );
            Console.WriteLine( "        dwMessageID - {0}",     gmdSummary.MessageID );
            Console.WriteLine( "        dwMessageFlags - {0}",  gmdSummary.MessageFlags );
            Console.WriteLine( "        dwSenderTitleID - {0}", gmdSummary.SenderTitleID );
            Console.WriteLine( "        bMessageType - {0}",    gmdSummary.MessageType );
            Console.WriteLine( "        wExpireMinutes - {0}",  gmdSummary.ExpireMinutes );
            Console.WriteLine( "        cbDetails - {0}",       gmdSummary.DetailsSize );

            // Update the enum summary with our flag change
            summaries[ iFoundMessage ].MessageFlags &= ~WCMessageFlags.TitleReserved0;
            summaries[ iFoundMessage ].MessageFlags |= WCMessageFlags.TitleReserved1;

            if( !IsSummaryEqual( ref gmdSummary, ref summaries[ iFoundMessage ] ) )
            {
                throw new ApplicationException( "Summary returned by EnumMessages doesn't match one returned by GetMessageDetails for MessageID=" + uiSentMessageID );
            }

            DumpDetails( ref gmdDetails );

/*
            if( gmdDetails != smDetails )
            {
                throw new ApplicationException( "Details sent don't match those returned by GetMessageDetails for MessageID=" + uiSentMessageID );
            }
*/

            Console.WriteLine( "    Get details again for Message {0} to see if the flags changed", uiSentMessageID );

            hr = service.GetMessageDetails( webID2,           // UserWebID
                                            "xmsgtest2",      // UserGamerTag
                                            uiSentMessageID,  // MessageID
                                            0,                // SetFlags
                                            0,                // UnsetFlags
                                            out gmdSummary,
                                            out gmdDetails );
            if( HResult.Failed( hr ) )
            {
                throw new ApplicationException( "GetMessageDetails failed, hr=" + hr );
            }

            if( WCMessageFlags.TitleReserved1 != ( gmdSummary.MessageFlags & c_TitleFlags ) )
            {
                throw new ApplicationException( "Flags returned by GetMessageDetails didn't match expected, (" + gmdSummary.MessageFlags + " != WCMessageFlags.TitleReserved1)!" );
            }

            Console.WriteLine( "    Change flags for Message {0}", uiSentMessageID );

            hr = service.SetMessageFlags( webID2,                          // UserWebID
                                          "xmsgtest2",                     // UserGamerTag
                                          uiSentMessageID,                 // MessageID
                                          WCMessageFlags.TitleReserved2,   // SetFlags
                                          WCMessageFlags.TitleReserved1 ); // UnsetFlags
            if( HResult.Failed( hr ) )
            {
                throw new ApplicationException( "SetMessageFlags failed, hr=" + hr );
            }

            Console.WriteLine( "    Get details again for Message {0} to see if the flags changed", uiSentMessageID );

            hr = service.GetMessageDetails( webID2,           // UserWebID
                                            "xmsgtest2",      // UserGamerTag
                                            uiSentMessageID,  // MessageID
                                            0,                // SetFlags
                                            0,                // UnsetFlags
                                            out gmdSummary,
                                            out gmdDetails );
            if( HResult.Failed( hr ) )
            {
                throw new ApplicationException( "GetMessageDetails failed, hr=" + hr );
            }

            if( WCMessageFlags.TitleReserved2 != ( gmdSummary.MessageFlags & c_TitleFlags ) )
            {
                throw new ApplicationException( "Flags returned by GetMessageDetails didn't match expected, (" + gmdSummary.MessageFlags + " != WCMessageFlags.TitleReserved2)!" );
            }

            Console.WriteLine( "    Delete Message " + uiSentMessageID );

            hr = service.DeleteMessage( webID2,               // UserWebID
                                        "xmsgtest2",          // UserGamerTag
                                        uiSentMessageID,      // MessageID
                                        0 );                  // Flags
            if( HResult.Failed( hr ) )
            {
                throw new ApplicationException( "DeleteMessage failed, hr=" + hr );
            }

            Console.WriteLine( "    Enumerate again to see if the message is gone" );

            hr = service.EnumMessages( webID2,          // UserWebID
                                       "xmsgtest2",     // UserGamerTag
                                       out summaries ); // Message Summaries
            if( HResult.Failed( hr ) )
            {
                throw new ApplicationException( "EnumMessages failed, hr=" + hr );
            }

            iFoundMessage = 0xFFFFFFFF;
            for( uint iMessage = 0; iMessage < summaries.Length; iMessage++ )
            {
                if( uiSentMessageID == summaries[ iMessage ].MessageID ) 
                {
                    iFoundMessage = iMessage;
                    Console.WriteLine( "    Found sent message, ID={0}", summaries[ iMessage ].MessageID );
                }

                Console.WriteLine( "    Message {0}", iMessage );
                Console.WriteLine( "        szSenderName - {0}",    summaries[ iMessage ].Sender );
                Console.WriteLine( "        qwSenderContext - {0}", summaries[ iMessage ].SenderContext );
                Console.WriteLine( "        mtSentTime - {0}",      summaries[ iMessage ].SentTime );
                Console.WriteLine( "        dwMessageID - {0}",     summaries[ iMessage ].MessageID );
                Console.WriteLine( "        dwMessageFlags - {0}",  summaries[ iMessage ].MessageFlags );
                Console.WriteLine( "        dwSenderTitleID - {0}", summaries[ iMessage ].SenderTitleID );
                Console.WriteLine( "        bMessageType - {0}",    summaries[ iMessage ].MessageType );
                Console.WriteLine( "        wExpireMinutes - {0}",  summaries[ iMessage ].ExpireMinutes );
                Console.WriteLine( "        cbDetails - {0}",       summaries[ iMessage ].DetailsSize );
            }
            if( 0xFFFFFFFF != iFoundMessage )
            {
                throw new ApplicationException( "EnumMessages returned the message, but it should have been deleted!" );
            }

            Console.WriteLine( "End TestSendDelete" );

        } // TestSendDelete

        [Test]
        public void TestUserTitles()
        {
            // This test does the following:
            // 1) Has user 1 enumerate their owned titles
            // 2) Has user 1 delete an owned title
            // 3) Has user 1 re-enumerate to see if the title is gone

            MessagingWidget service = new MessagingWidget();

            byte[] webID = new byte[8];
             
            Console.WriteLine( "Begin TestUserTitles" );

            Console.WriteLine( "    Enumerate user titles for user 1" );

            WCUserTitle[] rgUserTitles = null;
            UInt32 hr = service.EnumUserTitles( webID,              // UserWebID
                                                "xmsgtest1",        // UserGamerTag
                                                out rgUserTitles );
            if( HResult.Failed( hr ) )
            {
                throw new ApplicationException( "EnumUserTitles failed, hr=" + hr );
            }

            uint uiTitleToDelete = 0;
            for( uint iTitle = 0; iTitle < rgUserTitles.Length; iTitle++ )
            {
                if( 0 == iTitle )
                {
                    uiTitleToDelete = rgUserTitles[ iTitle ].TitleID;
                    Console.WriteLine( "    Found title to delete, ID={0}", rgUserTitles[ iTitle ].TitleID );
                }

                Console.WriteLine( "    Title {0}", iTitle );
                Console.WriteLine( "        dwTitleID - {0}",       rgUserTitles[ iTitle ].TitleID );
                Console.WriteLine( "        ftLastLogonTime - {0}", rgUserTitles[ iTitle ].LastLogonTime );
                Console.WriteLine( "        dwFlags - {0}",         rgUserTitles[ iTitle ].Flags );
            }

            if( 0 == uiTitleToDelete )
            {
                Console.WriteLine( "    No user title found to delete, can't finish test" );
            }
            else
            {
                Console.WriteLine( "    Deleting title {0} for user 1", uiTitleToDelete );

                hr = service.DeleteUserTitle( webID,             // UserWebID
                                              "xmsgtest1",       // UserGamerTag
                                              uiTitleToDelete );
                if( HResult.Failed( hr ) )
                {
                    throw new ApplicationException( "DeleteUserTitle failed, hr=" + hr );
                }

                Console.WriteLine( "    Re-enumerate titles for user 1 to see if the deleted one is gone" );

                hr = service.EnumUserTitles( webID,              // UserWebID
                                             "xmsgtest1",        // UserGamerTag
                                             out rgUserTitles );
                if( HResult.Failed( hr ) )
                {
                    throw new ApplicationException( "EnumUserTitles failed, hr=" + hr );
                }
        
                for( uint iTitle = 0; iTitle < rgUserTitles.Length; iTitle++ )
                {
                    if( uiTitleToDelete == rgUserTitles[ iTitle ].TitleID )
                    {
                        uiTitleToDelete = 0;
                        Console.WriteLine( "    Found deleted title, ID={0}", rgUserTitles[ iTitle ].TitleID );
                    }

                    Console.WriteLine( "    Title {0}", iTitle );
                    Console.WriteLine( "        dwTitleID - {0}",       rgUserTitles[ iTitle ].TitleID );
                    Console.WriteLine( "        ftLastLogonTime - {0}", rgUserTitles[ iTitle ].LastLogonTime );
                    Console.WriteLine( "        dwFlags - {0}",         rgUserTitles[ iTitle ].Flags );
                }
                if( 0 == uiTitleToDelete )
                {
                    throw new ApplicationException( "EnumUserTitles returned the title, but it should have been deleted!" );
                }
            }

            Console.WriteLine( "End TestUserTitles" );

        } // TestUserTitles

        [Test]
        public void TestSystemSendDelete()
        {
            // This test does the following:
            // 1) Sends a system message from a title 
            // 2) Enumerates to find the message
            // 3) Get details on the message
            // 4) Delete the message
            // 5) Re-enumerate to see if the message is gone

            MessagingWidget service = new MessagingWidget();
             
            Console.WriteLine( "Begin TestSystemSendDelete" );

            Console.WriteLine( "    Send a message from title" );

            WCMessageDetails smDetails = new WCMessageDetails();

            // Add some details
            smDetails.DwordProp = new WCDwordProp[ 1 ];
            smDetails.DwordProp[ 0 ] = new WCDwordProp();
            smDetails.DwordProp[ 0 ].PropID = 0x01;
            smDetails.DwordProp[ 0 ].Value = 52;

            WCLocalizedString[] strings = new WCLocalizedString[ 1 ];
            strings[ 0 ] = new WCLocalizedString();

            // TODO: Add some strings

            WCMessageAttachment[] attachments = new WCMessageAttachment[ 1 ];
            attachments[ 0 ] = new WCMessageAttachment();

            // TODO: Add some attachments

            uint uiSentMessageID = 0;
            ushort usDelay = 0;
            UInt32 hr = service.SendTitleWideMessage( "MsgWidgetTest", // SenderName
                                                      0,               // SenderContext
                                                      DateTime.UtcNow, // SentTime
                                                      0,               // Region
                                                      WCMessageFlags.TitleReserved0, // MessageFlags
                                                      c_titleId,       // TitleID
                                                      60,              // ExpireMinutes
                                                      WCMessageType.TitleCustom,     // MessageType
                                                      "My System Message", // Description
                                                      smDetails,       // Details
                                                      strings,         // Strings
                                                      attachments,     // Attachments
                                                      out usDelay,     // Submission delay added
                                                      out uiSentMessageID ); // MessageID

            if( HResult.Failed( hr ) )
            {
                throw new ApplicationException( "SendTitleWideMessage failed, hr=" + hr );
            }

            Console.WriteLine( "    SendTitleWideMessage returned messageID={0}", uiSentMessageID );

            Console.WriteLine( "    Enumerate messages for title" );

            WCTitleWideMessageSummary[] summaries = null;
            hr = service.EnumTitleWideMessages( c_titleId,       // TitleID
                                                out summaries ); // Message Summaries
            if( HResult.Failed( hr ) )
            {
                throw new ApplicationException( "EnumTitleWideMessages failed, hr=" + hr );
            }

            uint iFoundMessage = 0xFFFFFFFF;
            for( uint iMessage = 0; iMessage < summaries.Length; iMessage++ )
            {
                if( uiSentMessageID == summaries[ iMessage ].MessageID ) 
                {
                    iFoundMessage = iMessage;
                    Console.WriteLine( "    Found sent message, ID={0}", summaries[ iMessage ].MessageID );
                }

                Console.WriteLine( "    Message {0}", iMessage );
                Console.WriteLine( "        szDescription - {0}",   summaries[ iMessage ].Description );
                Console.WriteLine( "        dwTitleID - {0}",       summaries[ iMessage ].TitleID );
                Console.WriteLine( "        dwRegion - {0}",        summaries[ iMessage ].Region );
                Console.WriteLine( "        szSenderName - {0}",    summaries[ iMessage ].SenderName );
                Console.WriteLine( "        qwSenderContext - {0}", summaries[ iMessage ].SenderContext );
                Console.WriteLine( "        ftSentTime - {0}",      summaries[ iMessage ].SentTime );
                Console.WriteLine( "        dwMessageID - {0}",     summaries[ iMessage ].MessageID );
                Console.WriteLine( "        dwMessageFlags - {0}",  summaries[ iMessage ].MessageFlags );
                Console.WriteLine( "        bMessageType - {0}",    summaries[ iMessage ].MessageType );
                Console.WriteLine( "        wExpireMinutes - {0}",  summaries[ iMessage ].ExpireMinutes );
                Console.WriteLine( "        cbDetails - {0}",       summaries[ iMessage ].DetailsSize );
            }
            if( 0xFFFFFFFF == iFoundMessage )
            {
                throw new ApplicationException( "EnumTitleWideMessages did not return the message sent!" );
            }

            if( WCMessageFlags.TitleReserved0 != ( summaries[ iFoundMessage ].MessageFlags & c_TitleFlags ) )
            {
                throw new ApplicationException( "Flags returned by EnumTitleWideMessages didn't match ones sent, (" + summaries[ iFoundMessage ].MessageFlags + " != WCMessageFlags.TitleReserved0)!" );
            }

            Console.WriteLine( "    Get message details for Message {0}", uiSentMessageID );

            WCTitleWideMessageSummary gmdSummary = null;
            WCMessageDetails gmdDetails = null;
            hr = service.GetTitleWideMessageDetails( c_titleId,        // TitleID
                                                     uiSentMessageID,  // MessageID
                                                     out gmdSummary,
                                                     out gmdDetails );
            if( HResult.Failed( hr ) )
            {
                throw new ApplicationException( "GetTitleWideMessageDetails failed, hr=" + hr );
            }

            Console.WriteLine( "    Summary:" );
            Console.WriteLine( "        szDescription - {0}",   gmdSummary.Description );
            Console.WriteLine( "        dwTitleID - {0}",       gmdSummary.TitleID );
            Console.WriteLine( "        dwRegion - {0}",        gmdSummary.Region );
            Console.WriteLine( "        szSenderName - {0}",    gmdSummary.SenderName );
            Console.WriteLine( "        qwSenderContext - {0}", gmdSummary.SenderContext );
            Console.WriteLine( "        ftSentTime - {0}",      gmdSummary.SentTime );
            Console.WriteLine( "        dwMessageID - {0}",     gmdSummary.MessageID );
            Console.WriteLine( "        dwMessageFlags - {0}",  gmdSummary.MessageFlags );
            Console.WriteLine( "        bMessageType - {0}",    gmdSummary.MessageType );
            Console.WriteLine( "        wExpireMinutes - {0}",  gmdSummary.ExpireMinutes );
            Console.WriteLine( "        cbDetails - {0}",       gmdSummary.DetailsSize );

            if( !IsSummaryEqual( ref gmdSummary, ref summaries[ iFoundMessage ] ) )
            {
                throw new ApplicationException( "Summary returned by EnumTitleWideMessages doesn't match one returned by GetTitleWideMessageDetails for MessageID=" + uiSentMessageID );
            }

            DumpDetails( ref gmdDetails );

/*
            if( gmdDetails != smDetails )
            {
                throw new ApplicationException( "Details sent don't match those returned by GetTitleWideMessageDetails for MessageID=" + uiSentMessageID );
            }
*/

            Console.WriteLine( "    Delete Message " + uiSentMessageID );

            hr = service.DeleteTitleWideMessage( c_titleId,         // TitleID
                                                 uiSentMessageID,   // MessageID
                                                 0 );               // Flags
            if( HResult.Failed( hr ) )
            {
                throw new ApplicationException( "DeleteTitleWideMessage failed, hr=" + hr );
            }

            Console.WriteLine( "    Enumerate again to see if the message is gone" );

            hr = service.EnumTitleWideMessages( c_titleId,       // TitleID
                                                out summaries ); // Message Summaries
            if( HResult.Failed( hr ) )
            {
                throw new ApplicationException( "EnumTitleWideMessages failed, hr=" + hr );
            }

            iFoundMessage = 0xFFFFFFFF;
            for( uint iMessage = 0; iMessage < summaries.Length; iMessage++ )
            {
                if( uiSentMessageID == summaries[ iMessage ].MessageID ) 
                {
                    iFoundMessage = iMessage;
                    Console.WriteLine( "    Found sent message, ID={0}", summaries[ iMessage ].MessageID );
                }

                Console.WriteLine( "    Message {0}", iMessage );
                Console.WriteLine( "        szDescription - {0}",   summaries[ iMessage ].Description );
                Console.WriteLine( "        dwTitleID - {0}",       summaries[ iMessage ].TitleID );
                Console.WriteLine( "        dwRegion - {0}",        summaries[ iMessage ].Region );
                Console.WriteLine( "        szSenderName - {0}",    summaries[ iMessage ].SenderName );
                Console.WriteLine( "        qwSenderContext - {0}", summaries[ iMessage ].SenderContext );
                Console.WriteLine( "        ftSentTime - {0}",      summaries[ iMessage ].SentTime );
                Console.WriteLine( "        dwMessageID - {0}",     summaries[ iMessage ].MessageID );
                Console.WriteLine( "        dwMessageFlags - {0}",  summaries[ iMessage ].MessageFlags );
                Console.WriteLine( "        bMessageType - {0}",    summaries[ iMessage ].MessageType );
                Console.WriteLine( "        wExpireMinutes - {0}",  summaries[ iMessage ].ExpireMinutes );
                Console.WriteLine( "        cbDetails - {0}",       summaries[ iMessage ].DetailsSize );
            }
            if( 0xFFFFFFFF != iFoundMessage )
            {
                throw new ApplicationException( "EnumTitleWideMessages returned the message, but it should have been deleted!" );
            }

            Console.WriteLine( "End TestSystemSendDelete" );

        } // TestSystemSendDelete

        [Test]
        public void TestSystemSendString()
        {
            // This test does the following:
            // 1) Sends a system message from a title 
            // 2) Enumerates to find the message
            // 3) Get details on the message
            // 4) Delete the message
            // 5) Re-enumerate to see if the message is gone

            MessagingWidget service = new MessagingWidget();
             
            Console.WriteLine( "Begin TestSystemSendString" );

            Console.WriteLine( "    Send a message from title" );

            // Create a message string in two languages
            WCLocalizedString[] strings = new WCLocalizedString[ 1 ];
            strings[ 0 ] = new WCLocalizedString();
            strings[ 0 ].DefaultLocale = "en-us";
            strings[ 0 ].PropID = 0x01;
            strings[ 0 ].LangString = new WCLanguageString[ 2 ];
            strings[ 0 ].LangString[ 0 ] = new WCLanguageString();
            strings[ 0 ].LangString[ 0 ].Locale = "en-us";
            strings[ 0 ].LangString[ 0 ].String = "This is an English string that should push to the string server.";
            strings[ 0 ].LangString[ 1 ] = new WCLanguageString();
            strings[ 0 ].LangString[ 1 ].Locale = "fr-fr";
            strings[ 0 ].LangString[ 1 ].String = "Ici les mots francais.  Vraiment, je suis tout ce qui est homme.";


            uint uiSentMessageID = 0;
            ushort usDelay = 0;
            UInt32 hr = service.SendTitleWideMessage( "MsgWidgetTest", // SenderName
                                                      0,               // SenderContext
                                                      DateTime.UtcNow, // SentTime
                                                      0,               // Region
                                                      WCMessageFlags.TitleReserved0, // MessageFlags
                                                      c_titleId,       // TitleID
                                                      60,              // ExpireMinutes
                                                      WCMessageType.TitleCustom,     // MessageType
                                                      "My System Message", // Description
                                                      null,            // Details
                                                      strings,         // Strings
                                                      null,            // Attachments
                                                      out usDelay,     // Submission delay added
                                                      out uiSentMessageID ); // MessageID

            if( HResult.Failed( hr ) )
            {
                throw new ApplicationException( "SendTitleWideMessage failed, hr=" + hr );
            }

            Console.WriteLine( "    SendTitleWideMessage returned messageID={0}", uiSentMessageID );

            Console.WriteLine( "    Delete Message " + uiSentMessageID );

            hr = service.DeleteTitleWideMessage( c_titleId,         // TitleID
                                                 uiSentMessageID,   // MessageID
                                                 0 );               // Flags
            if( HResult.Failed( hr ) )
            {
                throw new ApplicationException( "DeleteTitleWideMessage failed, hr=" + hr );
            }

            Console.WriteLine( "End TestSystemSendString" );

        } // TestSystemSendString

        [Test]
        public void TestBlockSender()
        {
            // This test does the following:
            // 1) Sends a message from user 1 to user 2
            // 2) Has user 2 delete the message and block user 1
            // 3) Has user 2 delete the message again to make sure it is truly gone
            // 4) Sends another message from user 1 to user 2, it should be blocked
            // 5) Sends a message from user 2 to user 1, this should unblock user 1
            // 6) Has user 1 delete the message
            // 7) Sends a third message from user 1 to user 2, it should go through
            // 8) Has user 2 delete the message

            MessagingWidget service = new MessagingWidget();
             
            byte[] webID1 = new byte[8];
            byte[] webID2 = new byte[8];

            string[] recipients = new string[ 1 ];
            WCRecipientResult[] results = null;
            uint uiSentMessageID;
            uint hr;

            Console.WriteLine( "Begin TestBlockSender" );

            Console.WriteLine( "    Send a message from user 1 to user 2" );

            recipients[ 0 ] = "xmsgtest2";
            hr = service.SendMessage( webID1,                        // SenderWebID
                                      "xmsgtest1",                   // SenderGamerTag
                                      0,                             // SenderContext
                                      WCMessageFlags.TitleReserved0, // MessageFlags
                                      c_titleId,                     // SenderTitleID
                                      60,                            // ExpireMinutes
                                      WCMessageType.TitleCustom,     // MessageType
                                      recipients,                    // Recipient IDs
                                      null,                          // Details
                                      null,                          // Attachments
                                      out results );
            if( HResult.Failed( hr ) )
            {
                throw new ApplicationException( "SendMessage failed, hr=" + hr );
            }
            if( HResult.Failed( results[ 0 ].MessageID ) )
            {
                throw new ApplicationException( "SendMessage failed for recipient " + results[ 0 ].User + ", hr=" + results[ 0 ].MessageID );
            }

            uiSentMessageID = results[ 0 ].MessageID;

            Console.WriteLine( "        SendMessage returned messageID={0}", uiSentMessageID );

            Console.WriteLine( "    Have user 2 delete the message and block user 1" );

            hr = service.DeleteMessage( webID2,                         // UserWebID
                                        "xmsgtest2",                    // UserGamerTag
                                        uiSentMessageID,                // MessageID
                                        WCDeleteMsgFlags.BlockSender ); // Flags
            if( HResult.Failed( hr ) )
            {
                throw new ApplicationException( "DeleteMessage failed, hr=" + hr );
            }

            Console.WriteLine( "    Have user 2 delete the message again to make sure it is truly gone" );

            hr = service.DeleteMessage( webID2,                         // UserWebID
                                        "xmsgtest2",                    // UserGamerTag
                                        uiSentMessageID,                // MessageID
                                        0 );                            // Flags
            if( HResult.XONLINE_E_MESSAGE_INVALID_MESSAGE_ID != hr  )
            {
                throw new ApplicationException( "DeleteMessage failed, hr=" + hr );
            }

            Console.WriteLine( "    Send another message from user 1 to user 2, it should be blocked" );

            recipients[ 0 ] = "xmsgtest2";
            hr = service.SendMessage( webID1,                        // SenderWebID
                                      "xmsgtest1",                   // SenderGamerTag
                                      0,                             // SenderContext
                                      WCMessageFlags.TitleReserved0, // MessageFlags
                                      c_titleId,                     // SenderTitleID
                                      60,                            // ExpireMinutes
                                      WCMessageType.TitleCustom,     // MessageType
                                      recipients,                    // Recipient IDs
                                      null,                          // Details
                                      null,                          // Attachments
                                      out results );
            if( HResult.Failed( hr ) )
            {
                throw new ApplicationException( "SendMessage failed, hr=" + hr );
            }
            if( HResult.XONLINE_E_MESSAGE_SENDER_BLOCKED != results[ 0 ].MessageID )
            {
                throw new ApplicationException( "SendMessage failed for recipient " + results[ 0 ].User + ", hr=" + results[ 0 ].MessageID );
            }

            Console.WriteLine( "    Send a message from user 2 to user 1, this should unblock user 1" );

            recipients[ 0 ] = "xmsgtest1";
            hr = service.SendMessage( webID2,                        // SenderWebID
                                      "xmsgtest2",                   // SenderGamerTag
                                      0,                             // SenderContext
                                      WCMessageFlags.TitleReserved0, // MessageFlags
                                      c_titleId,                     // SenderTitleID
                                      60,                            // ExpireMinutes
                                      WCMessageType.TitleCustom,     // MessageType
                                      recipients,                    // Recipient IDs
                                      null,                          // Details
                                      null,                          // Attachments
                                      out results );
            if( HResult.Failed( hr ) )
            {
                throw new ApplicationException( "SendMessage failed, hr=" + hr );
            }
            if( HResult.Failed( results[ 0 ].MessageID ) )
            {
                throw new ApplicationException( "SendMessage failed for recipient " + results[ 0 ].User + ", hr=" + results[ 0 ].MessageID );
            }

            uiSentMessageID = results[ 0 ].MessageID;

            Console.WriteLine( "    Have user 1 delete the message" );

            hr = service.DeleteMessage( webID1,                         // UserWebID
                                        "xmsgtest1",                    // UserGamerTag
                                        uiSentMessageID,                // MessageID
                                        0 );                            // Flags
            if( HResult.Failed( hr ) )
            {
                throw new ApplicationException( "DeleteMessage failed, hr=" + hr );
            }

            Console.WriteLine( "    Send a third message from user 1 to user 2, it should go through" );

            recipients[ 0 ] = "xmsgtest2";
            hr = service.SendMessage( webID1,                        // SenderWebID
                                      "xmsgtest1",                   // SenderGamerTag
                                      0,                             // SenderContext
                                      WCMessageFlags.TitleReserved0, // MessageFlags
                                      c_titleId,                     // SenderTitleID
                                      60,                            // ExpireMinutes
                                      WCMessageType.TitleCustom,     // MessageType
                                      recipients,                    // Recipient IDs
                                      null,                          // Details
                                      null,                          // Attachments
                                      out results );
            if( HResult.Failed( hr ) )
            {
                throw new ApplicationException( "SendMessage failed, hr=" + hr );
            }
            if( HResult.Failed( results[ 0 ].MessageID ) )
            {
                throw new ApplicationException( "SendMessage failed for recipient " + results[ 0 ].User + ", hr=" + results[ 0 ].MessageID );
            }

            uiSentMessageID = results[ 0 ].MessageID;

            Console.WriteLine( "    Have user 2 delete the message" );

            hr = service.DeleteMessage( webID2,                         // UserWebID
                                        "xmsgtest2",                    // UserGamerTag
                                        uiSentMessageID,                // MessageID
                                        0 );                            // Flags
            if( HResult.Failed( hr ) )
            {
                throw new ApplicationException( "DeleteMessage failed, hr=" + hr );
            }

            Console.WriteLine( "End TestBlockSender" );

        } // TestBlockSender

        [Test]
        public void TestGetString()
        {
            // This test does the following:
            // 1) Sends a system message from a title 
            // 2) Enumerates to find the message
            // 3) Get details on the message
            // 4) Delete the message
            // 5) Re-enumerate to see if the message is gone

            MessagingWidget service = new MessagingWidget();
            string str;
             
            Console.WriteLine( "Begin TestGetString" );

            Console.WriteLine( "    Attempt to get string for this title in English" );

            str = service.GetMessageString( c_titleId, // TitleID
                                           0,         // StringID
                                           "en-us" ); // Locale
            if( "" == str )
            {
                throw new ApplicationException( "GetMessageString failed" );
            }

            Console.WriteLine( "    Attempt to get string for this title in unavailable language" );

            str = service.GetMessageString( c_titleId, // TitleID
                                           0,         // StringID
                                           "fr-fr" ); // Locale
            if( "" == str )
            {
                throw new ApplicationException( "GetMessageString failed" );
            }

            Console.WriteLine( "    Attempt to get string for this title in unsupported language" );

            str = service.GetMessageString( c_titleId, // TitleID
                                           0,         // StringID
                                           "bogus" ); // Locale
            if( "" == str )
            {
                throw new ApplicationException( "GetMessageString failed" );
            }

            Console.WriteLine( "End TestGetString" );

        } // TestGetString

        //
        // Negative test cases ////////////////////////////////////////////////
        //

        [Test]
        public void TestInvalidMessageId()
        {
            // This test does the following:
            // 1) Calls GetMessageDetails with an invalid message ID
            // 2) Calls DeleteMessage with an invalid message ID
            // 3) Calls SetMessageFlags with an invalid message ID
            // 4) Calls GetTitleWideMessageDetails with an invalid message ID
            // 5) Calls DeleteTitleWideMessage with an invalid message ID
            // 6) Calls DeleteUserTitle with an invalid title ID
             
            Console.WriteLine( "Begin TestInvalidMessageId" );

            uint hr;
            MessagingWidget service = new MessagingWidget();

            byte[] webID = new byte[8];

            Console.WriteLine( "    Calling GetMessageDetails with an invalid message ID" );

            WCMessageSummary gmdSummary = null;
            WCMessageDetails gmdDetails = null;
            hr = service.GetMessageDetails( webID,       // UserWebID
                                            "xmsgtest1", // UserGamerTag
                                            0x0000FFFF,  // MessageID
                                            0,           // SetFlags
                                            0,           // UnsetFlags
                                            out gmdSummary,
                                            out gmdDetails );
            if( HResult.XONLINE_E_MESSAGE_INVALID_MESSAGE_ID != hr )
            {
                throw new ApplicationException( "GetMessageDetails failed, hr=" + hr );
            }

            Console.WriteLine( "    Calling DeleteMessage with an invalid message ID" );

            hr = service.DeleteMessage( webID,          // UserWebID
                                        "xmsgtest1",    // UserGamerTag
                                        0x0000FFFF,     // MessageID
                                        0 );            // Flags
            if( HResult.XONLINE_E_MESSAGE_INVALID_MESSAGE_ID != hr )
            {
                throw new ApplicationException( "DeleteMessage failed, hr=" + hr );
            }

            Console.WriteLine( "    Calling SetMessageFlags with an invalid message ID" );

            hr = service.SetMessageFlags( webID,        // UserWebID
                                          "xmsgtest1",  // UserGamerTag
                                          0x0000FFFF,   // MessageID
                                          0,            // SetFlags
                                          0 );          // UnsetFlags
            if( HResult.XONLINE_E_MESSAGE_INVALID_MESSAGE_ID != hr )
            {
                throw new ApplicationException( "SetMessageFlags failed, hr=" + hr );
            }

            Console.WriteLine( "    Calling GetTitleWideMessageDetails with an invalid message ID" );

            WCTitleWideMessageSummary gsmdSummary = null;
            WCMessageDetails gsmdDetails = null;
            hr = service.GetTitleWideMessageDetails( c_titleId,         // TitleID
                                                     0x4000FFFF,        // MessageID
                                                     out gsmdSummary,
                                                     out gsmdDetails );
            if( HResult.XONLINE_E_MESSAGE_INVALID_MESSAGE_ID != hr )
            {
                throw new ApplicationException( "GetTitleWideMessageDetails failed, hr=" + hr );
            }

            Console.WriteLine( "    Calling DeleteTitleWideMessage with an invalid message ID" );

            hr = service.DeleteTitleWideMessage( c_titleId,   // TitleID
                                                 0x4000FFFF,  // MessageID
                                                 0 );         // Flags
            if( HResult.XONLINE_E_MESSAGE_INVALID_MESSAGE_ID != hr )
            {
                throw new ApplicationException( "DeleteTitleWideMessage failed, hr=" + hr );
            }

            Console.WriteLine( "    Calling DeleteUserTitle with an invalid title ID" );

            hr = service.DeleteUserTitle( webID,        // User
                                          "xmsgtest1",  // UserGamerTag
                                          0xFFFFFFFF );
            if( HResult.XONLINE_E_MESSAGE_INVALID_TITLE_ID != hr )
            {
                throw new ApplicationException( "DeleteUserTitle failed, hr=" + hr );
            }

            Console.WriteLine( "End TestInvalidMessageId" );

        } // TestInvalidMessageId

        [Test]
        public void TestSystemMessageTimeout()
        {
            // This test does the following:
            // 1) Sends 80 system messages
            // 2) Enumerates system messages
            // 3) Deletes the system messages
             
            Console.WriteLine( "Begin TestSystemMessageTimeout" );

            uint hr;
            MessagingWidget service = new MessagingWidget();

            Console.WriteLine( "    Send 80 messages from title" );

            WCMessageDetails smDetails = new WCMessageDetails();

            // Add some details
            smDetails.DwordProp = new WCDwordProp[ 1 ];
            smDetails.DwordProp[ 0 ] = new WCDwordProp();
            smDetails.DwordProp[ 0 ].PropID = 0x01;
            smDetails.DwordProp[ 0 ].Value = 52;

            uint[] rguiSentMessageIDs = new uint[ 80 ];

            for( int iSend = 0; iSend < 80; iSend++ )
            {
                ushort usDelay = 0;
                hr = service.SendTitleWideMessage( "MsgWidgetTest", // SenderName
                                                   0,               // SenderContext
                                                   DateTime.UtcNow, // SentTime
                                                   0,               // Region
                                                   WCMessageFlags.TitleReserved0, // MessageFlags
                                                   c_titleId,       // TitleID
                                                   60,              // ExpireMinutes
                                                   WCMessageType.TitleCustom,     // MessageType
                                                   "My System Message" + iSend.ToString(), // Description
                                                   smDetails,       // Details
                                                   null,            // Strings
                                                   null,            // Attachments
                                                   out usDelay,     // Submission delay added
                                                   out rguiSentMessageIDs[ iSend ] ); // MessageID
                if( HResult.Failed( hr ) )
                {
                    throw new ApplicationException( "SendTitleWideMessage failed, hr=" + hr );
                }

                Console.WriteLine( "    SendTitleWideMessage returned messageID={0}", rguiSentMessageIDs[ iSend ] );
            }

            Console.WriteLine( "    Enumerate messages for title" );

            WCTitleWideMessageSummary[] summaries = null;
            hr = service.EnumTitleWideMessages( c_titleId,       // TitleID
                                                out summaries ); // Message Summaries
            if( HResult.Failed( hr ) )
            {
                throw new ApplicationException( "EnumTitleWideMessages failed, hr=" + hr );
            }

            for( uint iMessage = 0; iMessage < summaries.Length; iMessage++ )
            {
                Console.WriteLine( "    Message {0}", iMessage );
                Console.WriteLine( "        szDescription - {0}",   summaries[ iMessage ].Description );
                Console.WriteLine( "        dwTitleID - {0}",       summaries[ iMessage ].TitleID );
                Console.WriteLine( "        dwRegion - {0}",        summaries[ iMessage ].Region );
                Console.WriteLine( "        szSenderName - {0}",    summaries[ iMessage ].SenderName );
                Console.WriteLine( "        qwSenderContext - {0}", summaries[ iMessage ].SenderContext );
                Console.WriteLine( "        ftSentTime - {0}",      summaries[ iMessage ].SentTime );
                Console.WriteLine( "        dwMessageID - {0}",     summaries[ iMessage ].MessageID );
                Console.WriteLine( "        dwMessageFlags - {0}",  summaries[ iMessage ].MessageFlags );
                Console.WriteLine( "        bMessageType - {0}",    summaries[ iMessage ].MessageType );
                Console.WriteLine( "        wExpireMinutes - {0}",  summaries[ iMessage ].ExpireMinutes );
                Console.WriteLine( "        cbDetails - {0}",       summaries[ iMessage ].DetailsSize );
            }

            Console.WriteLine( "    Delete the 80 messages we sent" );

            for( int iSend = 0; iSend < 80; iSend++ )
            {
                hr = service.DeleteTitleWideMessage( c_titleId,                   // TitleID
                                                     rguiSentMessageIDs[ iSend ], // MessageID
                                                     0 );                         // Flags
                if( HResult.Failed( hr ) )
                {
                    throw new ApplicationException( "DeleteTitleWideMessage failed, hr=" + hr );
                }
            }

            Console.WriteLine( "End TestSystemMessageTimeout" );

        } // TestSystemMessageTimeout

        [Test]
        public void TestSendInvalidDetails()
        {
            // This test does the following:
            // 1) Send a message with details that repeat a property
            // 2) Send a message with details that contain a zero prop type
            // 3) Send a message with details that contain a zero prop ID
            
            Console.WriteLine( "Begin TestSendInvalidDetails" );

            uint hr;
            MessagingWidget service = new MessagingWidget();
             
            WCMessageDetails smDetails;
            uint uiSentMessageID;
            ushort usDelay = 0;

            Console.WriteLine( "    Send a message with details that repeat a property" );

            // Create details that repeat a property
            smDetails = new WCMessageDetails();
            smDetails.DwordProp = new WCDwordProp[ 2 ];
            smDetails.DwordProp[ 0 ] = new WCDwordProp();
            smDetails.DwordProp[ 0 ].PropID = 0x01;
            smDetails.DwordProp[ 0 ].Value = 52;
            smDetails.DwordProp[ 1 ] = new WCDwordProp();
            smDetails.DwordProp[ 1 ].PropID = 0x01;
            smDetails.DwordProp[ 1 ].Value = 52;

            hr = service.SendTitleWideMessage( "MsgWidgetTest", // SenderName
                                               0,               // SenderContext
                                               DateTime.UtcNow, // SentTime
                                               0,               // Region
                                               WCMessageFlags.TitleReserved0, // MessageFlags
                                               c_titleId,       // TitleID
                                               60,              // ExpireMinutes
                                               WCMessageType.TitleCustom,     // MessageType
                                               "My System Message", // Description
                                               smDetails,       // Details
                                               null,            // Strings
                                               null,            // Attachments
                                               out usDelay,     // Submission delay added
                                               out uiSentMessageID ); // MessageID
            if( HResult.Succeeded( hr ) )
            {
                throw new ApplicationException( "SendTitleWideMessage failed, hr=" + hr );
            }

            smDetails = null;

            Console.WriteLine( "    Send a message with details that contain a zero prop ID" );

            // Create details that contain a zero prop ID
            smDetails = new WCMessageDetails();
            smDetails.DwordProp = new WCDwordProp[ 1 ];
            smDetails.DwordProp[ 0 ] = new WCDwordProp();
            smDetails.DwordProp[ 0 ].PropID = 0x00;
            smDetails.DwordProp[ 0 ].Value = 52;

            hr = service.SendTitleWideMessage( "MsgWidgetTest", // SenderName
                                               0,               // SenderContext
                                               DateTime.UtcNow, // SentTime
                                               0,               // Region
                                               WCMessageFlags.TitleReserved0, // MessageFlags
                                               c_titleId,       // TitleID
                                               60,              // ExpireMinutes
                                               WCMessageType.TitleCustom,     // MessageType
                                               "My System Message", // Description
                                               smDetails,       // Details
                                               null,            // Strings
                                               null,            // Attachments
                                               out usDelay,     // Submission delay added
                                               out uiSentMessageID ); // MessageID
            if( HResult.Succeeded( hr ) )
            {
                throw new ApplicationException( "SendTitleWideMessage failed, hr=" + hr );
            }

            Console.WriteLine( "End TestSendInvalidDetails" );

        } // TestSendInvalidDetails


        [Test]
        public void TestNullGamerTag()
        {
            Console.WriteLine( "Begin TestNullGamerTag" );

            MessagingWidget service = new MessagingWidget();

            uint hr; 
            WCMessageSummary[] summary = null;

            byte[] webID = new byte[8];

            Console.WriteLine( "    Calling EnumMessages with null GamerTag" );

            hr = 0x80004005;
            try
            {
                hr = service.EnumMessages( webID,      // UserWebID
                                           null,       // UserGamerTag
                                           out summary );
                throw new ApplicationException( "EnumMessages failed, hr=" + hr );
            }
            catch( System.Web.Services.Protocols.SoapException e )
            {
                Console.WriteLine( "    Exception - " + e.Message );
            }


            Console.WriteLine( "End TestNullGamerTag" );

        } // TestNullGamerTag

    } // class MessagingTests
}    

// TODO: Add the ability to call Alive and DeadUser in Presence to add a user and add titles for that user
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Presence\Test\FuncGetGamertags.cs ===
using System;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.UserAccount;

namespace PresWidgetTest
{
	public class FuncGetGamertags : TestNode
	{
        public static int sleepTime = 30000;
        public static FriendsCommon _fc;

        [TestGroupSetup]
		public void Setup()
		{
			_fc = new FriendsCommon();
		}

        [TestGroupTearDown]
		public void TearDown()
		{
			_fc = null;
        }

        [TestCase, Description( "User Exists" )]
		class GetValidUser : TestBase
		{
			override protected void Execute()
			{
                // Create Xbox 1 User
                Owner o = _fc.UACS.GenerateOwner();
                ulong userXuid = _fc.UACS.CreateUser(o);

                // Wait for the cache to pick up the change
                Thread.Sleep(sleepTime);
                
                // Fetch the gamertag
                ulong[] xuidUsers = new ulong[]{userXuid};
                string [] gamertags = new string[1];
                WCPresence wp = new WCPresence();
				gamertags = wp.GetGamertagsFromXUIDS(xuidUsers);

                ValueCheck.Test("Presence Widget", o.gamertag, gamertags[0] );

                ResultCode = TEST_RESULTS.PASSED;
			}
		}
	
        [TestCase, Description( "Get Multiple Valid Users" )]
		class GetMultipleValidUser : TestBase
		{
			override protected void Execute()
			{
                // Create Xbox 1 User
                Owner o = _fc.UACS.GenerateOwner();
                ulong userXuid = _fc.UACS.CreateUser(o);

                Owner ob = _fc.UACS.GenerateOwner();
                ulong userXuidB = _fc.UACS.CreateUser(ob);

                // Wait for the cache to pick up the change
                Thread.Sleep(sleepTime);

                // Fetch the gamertag
                ulong[] xuidUsers = new ulong[]{userXuid, userXuidB};
                string [] gamertags = new string[2];
                WCPresence wp = new WCPresence();
				gamertags = wp.GetGamertagsFromXUIDS(xuidUsers);

                ValueCheck.Test("Presence Widget", o.gamertag, gamertags[0] );
                ValueCheck.Test("Presence Widget", ob.gamertag, gamertags[1] );

                ResultCode = TEST_RESULTS.PASSED;
			}
		}

        [TestCase, Description( "Valid Duplicates" )]
		class GetValidDuplicateUsers : TestBase
		{
			override protected void Execute()
			{
                // Create Xbox 1 User
                Owner o = _fc.UACS.GenerateOwner();
                ulong userXuid = _fc.UACS.CreateUser(o);

                // Wait for the cache to pick up the change
                Thread.Sleep(sleepTime);
                
                // Fetch the gamertag
                ulong[] xuidUsers = new ulong[]{userXuid, userXuid};
                string [] gamertags = new string[2];
                WCPresence wp = new WCPresence();
				gamertags = wp.GetGamertagsFromXUIDS(xuidUsers);

                ValueCheck.Test("Presence Widget", o.gamertag, gamertags[0] );
                ValueCheck.Test("Presence Widget", o.gamertag, gamertags[1] );

                ResultCode = TEST_RESULTS.PASSED;
			}
		}

        [TestCase, Description( "Invalid XUID - 0" )]
		class InvalidXUIDZero : TestBase
		{
			override protected void Execute()
			{
                ulong[] xuidUsers = new ulong[]{0};
                string [] gamertags = new string[1];
                WCPresence wp = new WCPresence();
                try
                {
				    gamertags = wp.GetGamertagsFromXUIDS(xuidUsers);
                }
                catch
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
			}
        }

        [TestCase, Description( "Invalid XUID - MAX ULong" )]
		class InvalidXUIDMaxUlong : TestBase
		{
			override protected void Execute()
			{
                ulong[] xuidUsers = new ulong[]{ulong.MaxValue};
                string [] gamertags = new string[1];
                WCPresence wp = new WCPresence();
				gamertags = wp.GetGamertagsFromXUIDS(xuidUsers);

                ValueCheck.Test("Presence Widget", "??????", gamertags[0] );

                ResultCode = TEST_RESULTS.PASSED;
			}
        }

        [TestCase, Description( "Invalid XUID - Doesn't Exist" )]
		class InvalidXUIDNoSuchUser : TestBase
		{
			override protected void Execute()
			{
                ulong[] xuidUsers = new ulong[]{42};
                string [] gamertags = new string[1];
                WCPresence wp = new WCPresence();
				gamertags = wp.GetGamertagsFromXUIDS(xuidUsers);

                ValueCheck.Test("Presence Widget", "??????", gamertags[0] );

                ResultCode = TEST_RESULTS.PASSED;
			}
        }

        [TestCase, Description( "Mixed XUIDs, some valid, some not" )]
		class MixedXUIDs : TestBase
		{
			override protected void Execute()
			{
                // Create Xbox 1 User
                Owner o = _fc.UACS.GenerateOwner();
                ulong userXuid = _fc.UACS.CreateUser(o);

                // Wait for the cache to pick up the change
                Thread.Sleep(sleepTime);

                ulong[] xuidUsers = new ulong[]{userXuid, 42, 0, userXuid, 666};
                string [] gamertags = new string[5];
                WCPresence wp = new WCPresence();
                try
                {
				    gamertags = wp.GetGamertagsFromXUIDS(xuidUsers);
                }
                catch
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
			}
        }

        [TestCase, Description( "Invalid XUID - Array too large" )]
		class InvalidXUIDArrayTooLarge : TestBase
		{
			override protected void Execute()
			{
                ResultCode = TEST_RESULTS.FAILED;

                ulong[] xuidUsers = new ulong[101];
                string [] gamertags = new string[101];
                WCPresence wp = new WCPresence();
                try
                {
				    gamertags = wp.GetGamertagsFromXUIDS(xuidUsers);
                }
                catch
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
			}
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Presence\Test\FuncGetFriendsEx.cs ===
using System;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Web.Presence;

namespace PresWidgetTest
{
	public class FuncGetFriendsEx : TestNode
	{
        private static UserSetup _us;
        public static int sleepTime = 30000;
        public static FriendsCommon _fc;
        public const uint P_BUDDY_STATUS_PENDING = 1;
        public const uint P_BUDDY_STATUS_REQUEST = 2;

        [TestGroupSetup]
		public void Setup()
		{
			_fc = new FriendsCommon();
            _us = new UserSetup();
		}

        [TestGroupTearDown]
		public void TearDown()
		{
			_fc = null;
            _us = null;
        }

        [TestCase, Description( "User Exists Xbox 360" )]
		class GetXbox360Friends : TestBase
		{
			override protected void Execute()
			{
                FriendEx [] myFriends;
                uint sec = 0;

                // Create Xbox 360 User
                XeUser u = UserSetup.CreateXbox360User();
                ulong userPuid = u.UserPuid;
                XeUser u2 = UserSetup.CreateXbox360User();

                // Wait for the cache to pick up the change
                Thread.Sleep(sleepTime);

                // Make friends
                UserSetup.MakeFriend(u, u2);

                // Wait for the cache to pick up the change
                Thread.Sleep(sleepTime);

                // Fetch the Friends List
                WCPresence wp = new WCPresence();
				myFriends = wp.GetFriendsEx(userPuid, 1, out sec);   // 1 = en-US

                ValueCheck.Test("Presence Widget", myFriends[0].GamerTag, u2.Gamertag);

                ResultCode = TEST_RESULTS.PASSED;
			}
        }


        [TestCase, Description( "User has 0 Friends" )]
		class GetFriends_Zero : TestBase
		{
			override protected void Execute()
			{
                ResultCode = TEST_RESULTS.FAILED;
                FriendEx [] myFriends;
                uint sec = 0;

                // Create Xbox 1 User
                Owner o = _fc.UACS.GenerateOwner();
                ulong userPuid = _fc.UACS.CreateUser(o);

                // Wait for the cache to pick up the change
                Thread.Sleep(sleepTime);

                // Fetch the Friends List
                WCPresence wp = new WCPresence();
				myFriends = wp.GetFriendsEx(userPuid, 1, out sec);   // 1 = en-US

                if(myFriends.Length == 0)
                    ResultCode = TEST_RESULTS.PASSED;
			}
		}

        [TestCase, Description( "User has n Friends" )]
		class GetFriends_N : TestBase
		{
			override protected void Execute()
			{
                FriendEx [] myFriends;
                uint sec = 0;

                // Create 6 Users
                XeUser u1 = UserSetup.CreateXbox360User();
                XeUser u2 = UserSetup.CreateXbox360User();
                XeUser u3 = UserSetup.CreateXbox360User();
                XeUser u4 = UserSetup.CreateXbox360User();
                XeUser u5 = UserSetup.CreateXbox360User();
                XeUser u6 = UserSetup.CreateXbox360User();

                // Wait for the cache to pick up the change
                Thread.Sleep(sleepTime);

                PNUser pu1 = new PNUser(u1.Gamertag, u1.UserPuid);
                PNUser pu2 = new PNUser(u2.Gamertag, u2.UserPuid);
                PNUser pu3 = new PNUser(u3.Gamertag, u3.UserPuid);
                PNUser pu4 = new PNUser(u4.Gamertag, u4.UserPuid);
                PNUser pu5 = new PNUser(u5.Gamertag, u5.UserPuid);
                PNUser pu6 = new PNUser(u6.Gamertag, u6.UserPuid);

                // Make 5 friends
                _fc.MakeFriend(pu1,pu2);
                _fc.MakeFriend(pu1,pu3);
                _fc.MakeFriend(pu1,pu4);
                _fc.MakeFriend(pu1,pu5);
                _fc.MakeFriend(pu1,pu6);

                // Fetch the Friends List
                WCPresence wp = new WCPresence();
				myFriends = wp.GetFriendsEx(u1.UserPuid, 1, out sec);   // 1 = en-US

                ValueCheck.Test("Presence Widget", u2.Gamertag, myFriends[0].GamerTag);
                ValueCheck.Test("Presence Widget", u3.Gamertag, myFriends[1].GamerTag);
                ValueCheck.Test("Presence Widget", u4.Gamertag, myFriends[2].GamerTag);
                ValueCheck.Test("Presence Widget", u5.Gamertag, myFriends[3].GamerTag);
                ValueCheck.Test("Presence Widget", u6.Gamertag, myFriends[4].GamerTag);

                ResultCode = TEST_RESULTS.PASSED;
			}
		}

        [TestCase, Description( "User has Pending Friends" )]
		class GetFriends_Pending : TestBase
		{
			override protected void Execute()
			{
                FriendEx [] myFriends;
                uint sec = 0;

                // Create Xbox User
                XeUser u = UserSetup.CreateXbox360User();
                XeUser u2 = UserSetup.CreateXbox360User();

                PNUser pnRequestor = new PNUser (u.Gamertag, u.UserPuid);
		    	PNUser pnFriend = new PNUser (u2.Gamertag, u2.UserPuid);

                // Wait for the cache to pick up the change
                Thread.Sleep(sleepTime);

                // Log-on users
                _fc.LogonUser(pnRequestor);

                // Make pending friends
                _fc.RequestFriend( pnRequestor, pnFriend);

                // Wait for the cache to pick up the change
                Thread.Sleep(sleepTime);

                // Fetch the Friends List
                WCPresence wp = new WCPresence();
				myFriends = wp.GetFriendsEx( u.UserPuid, 1, out sec);   // 1 = en-US

                // Check to see if the friends state is pending
                ValueCheck.Test("Presence Widget", myFriends[0].FriendStatus, P_BUDDY_STATUS_PENDING);

                // Check the reverse relationship
				myFriends = wp.GetFriendsEx( u2.UserPuid, 1, out sec);   // 1 = en-US

                ValueCheck.Test("Presence Widget", myFriends[0].FriendStatus, P_BUDDY_STATUS_REQUEST);

                ResultCode = TEST_RESULTS.PASSED;
			}
		}

        [TestCase, Description( "Get Friends for all locales" )]
		class GetFriends_AllLocales : TestBase
		{
			override protected void Execute()
			{
                FriendEx [] myFriends;
                uint sec = 0;

                // Create Xbox 360 User
                XeUser u = UserSetup.CreateXbox360User();
                ulong userPuid = u.UserPuid;
                XeUser u2 = UserSetup.CreateXbox360User();

                // Wait for the cache to pick up the change
                Thread.Sleep(sleepTime);

                // Make friends
                UserSetup.MakeFriend(u, u2);

                // Wait for the cache to pick up the change
                Thread.Sleep(sleepTime);

                // Fetch the Friends List in each locale
                WCPresence wp = new WCPresence();
                for(ushort langCode = 1; langCode < 10; langCode++)
                {
    				myFriends = wp.GetFriendsEx(userPuid, langCode, out sec);   // 1 = en-US

                    ValueCheck.Test("Presence Widget", u2.Gamertag, myFriends[0].GamerTag);
                }

                ResultCode = TEST_RESULTS.PASSED;
			}
		}

        [TestCase, Description( "Invalid 0 XUID" )]
		class GetFriends_Invalid_ZeroXuid : TestBase
		{
			override protected void Execute()
			{
                FriendEx [] myFriends;
                uint sec = 0;

                // Fetch the Friends List
                WCPresence wp = new WCPresence();
                try
                {
    				myFriends = wp.GetFriendsEx(0, 1, out sec);   // 1 = en-US
                }
                catch
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
			}
		}

        [TestCase, Description( "Invalid MAX XUID" )]
		class GetFriends_Invalid_MaxXuid : TestBase
		{
			override protected void Execute()
			{
                FriendEx [] myFriends;
                uint sec = 0;

                // Fetch the Friends List
                WCPresence wp = new WCPresence();
                try
                {
    				myFriends = wp.GetFriendsEx(ulong.MaxValue, 1, out sec);   // 1 = en-US
                }
                catch
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
			}
		}

        [TestCase, Description( "Non existant User" )]
		class GetFriends_User_Doesnt_Exist : TestBase
		{
			override protected void Execute()
			{
                FriendEx [] myFriends;
                uint sec = 0;

                // Fetch the Friends List
                WCPresence wp = new WCPresence();
                try
                {
    				myFriends = wp.GetFriendsEx(42, 1, out sec);   // 1 = en-US
                }
                catch
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
			}
		}

        [TestCase, Description( "Get Friends invalid locale 0" )]
		class GetFriends_InvalidLocale_0 : TestBase
		{
			override protected void Execute()
			{
                FriendEx [] myFriends;
                uint sec = 0;

                // Create Xbox 1 User
                Owner o = _fc.UACS.GenerateOwner();
                ulong userPuid = _fc.UACS.CreateUser(o);
                XeUser u2 = UserSetup.CreateXbox360User();

                // Make Friends
                PNUser pnRequestor = new PNUser (o.gamertag, userPuid);
		    	PNUser pnFriend = new PNUser (u2.Gamertag, u2.UserPuid);

                // Wait for the cache to pick up the change
                Thread.Sleep(sleepTime);

	    		// Time for some magic...
    			_fc.MakeFriend (pnRequestor, pnFriend);   

                // Wait for the cache to pick up the change
                Thread.Sleep(sleepTime);

                // Fetch the Friends List in an invalid locale
                WCPresence wp = new WCPresence();
   				myFriends = wp.GetFriendsEx(userPuid, 0, out sec);   // 1 = en-US

                // Invalid locale's come back as EN-US by default
                ValueCheck.Test("Presence Widget", 1, myFriends.Length);

                ResultCode = TEST_RESULTS.PASSED;
			}
		}

        [TestCase, Description( "Get Friends invalid locale N" )]
		class GetFriends_InvalidLocale_N : TestBase
		{
			override protected void Execute()
			{
                FriendEx [] myFriends;
                uint sec = 0;

                // Create Xbox 1 User
                Owner o = _fc.UACS.GenerateOwner();
                ulong userPuid = _fc.UACS.CreateUser(o);
                XeUser u2 = UserSetup.CreateXbox360User();

                // Make Friends
                PNUser pnRequestor = new PNUser (o.gamertag, userPuid);
		    	PNUser pnFriend = new PNUser (u2.Gamertag, u2.UserPuid);

                // Wait for the cache to pick up the change
                Thread.Sleep(sleepTime);

	    		// Time for some magic...
    			_fc.MakeFriend (pnRequestor, pnFriend);   

                // Wait for the cache to pick up the change
                Thread.Sleep(sleepTime);

                // Fetch the Friends List in an invalid locale
                WCPresence wp = new WCPresence();
   				myFriends = wp.GetFriendsEx(userPuid, 10, out sec);   // 1 = en-US

                // Invalid locale's come back as EN-US by default
                ValueCheck.Test("Presence Widget", 1, myFriends.Length);

                ResultCode = TEST_RESULTS.PASSED;
			}
		}

        [TestCase, Description( "Get Friends invalid locale MAX" )]
		class GetFriends_InvalidLocale_MAX : TestBase
		{
			override protected void Execute()
			{
                FriendEx [] myFriends;
                uint sec = 0;

                // Create Xbox 1 User
                Owner o = _fc.UACS.GenerateOwner();
                ulong userPuid = _fc.UACS.CreateUser(o);
                XeUser u2 = UserSetup.CreateXbox360User();

                // Make Friends
                PNUser pnRequestor = new PNUser (o.gamertag, userPuid);
		    	PNUser pnFriend = new PNUser (u2.Gamertag, u2.UserPuid);

                // Wait for the cache to pick up the change
                Thread.Sleep(sleepTime);

	    		// Time for some magic...
    			_fc.MakeFriend (pnRequestor, pnFriend);   

                // Wait for the cache to pick up the change
                Thread.Sleep(sleepTime);

                // Fetch the Friends List in an invalid locale
                WCPresence wp = new WCPresence();
   				myFriends = wp.GetFriendsEx(userPuid, ushort.MaxValue, out sec);   // 1 = en-US

                // Invalid locale's come back as EN-US by default
                ValueCheck.Test("Presence Widget", 1, myFriends.Length);

                ResultCode = TEST_RESULTS.PASSED;
			}
		}    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Presence\Test\FuncGetPresenceInfo.cs ===
using System;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Web.Presence;

namespace PresWidgetTest
{
	public class FuncGetPresenceInfo : TestNode
	{
        public static int sleepTime = 30000;
        public static FriendsCommon _fc;

        [TestGroupSetup]
		public void Setup()
		{
			_fc = new FriendsCommon();
        }

        [TestGroupTearDown]
		public void TearDown()
		{
			_fc = null;
        }

        [TestCase, Description( "Xbox 360 asks for Xbox 360" )]
		class Xbox360Get360Presence : TestBase
		{
			override protected void Execute()
			{
                uint sec = 0;

                // Create Xbox 360 User
                XeUser x = UserSetup.CreateXbox360User();
                ulong senderXuid = x.UserPuid;

                // Create Xbox 360 User
                XeUser x2 = UserSetup.CreateXbox360User();
                ulong targetXuid = x2.UserPuid;

                // Log-on users
                PNUser pnX = new PNUser (x.Gamertag, x.UserPuid);
                PNUser pnX2 = new PNUser (x2.Gamertag, x2.UserPuid);
                _fc.LogonUser(pnX);
                _fc.LogonUser(pnX2);

                // Wait for the cache to pick up the change
                Thread.Sleep(sleepTime);

                // Fetch the Friends List
                WCPresence wp = new WCPresence();
				ServerTestFramework.Web.Presence.PresenceInfo pInfo = wp.GetPresenceInfo(targetXuid, senderXuid, 1, out sec);   // 1 = en-US

                ValueCheck.Test("Presence Widget", pInfo.XUID, targetXuid);
                ValueCheck.Test("Presence Widget", pInfo.GamerTag, x2.Gamertag);

                ResultCode = TEST_RESULTS.PASSED;
			}
		}

        [TestCase, Description( "Argo asks for Xbox 360" ), Ignore]
		class ArgoGet360Presence : TestBase
		{
			override protected void Execute()
			{
                uint sec = 0;

                // TODO: Create Argo User
                XeUser x = UserSetup.CreateXbox360User();
                ulong senderXuid = x.UserPuid;

                // Create Xbox 360 User
                XeUser x2 = UserSetup.CreateXbox360User();
                ulong targetXuid = x2.UserPuid;

                // Log-on users
                PNUser pnX = new PNUser (x.Gamertag, x.UserPuid);
                PNUser pnX2 = new PNUser (x2.Gamertag, x2.UserPuid);
                _fc.LogonUser(pnX);
                _fc.LogonUser(pnX2);

                // Wait for the cache to pick up the change
                Thread.Sleep(sleepTime);

                // Fetch the Friends List
                WCPresence wp = new WCPresence();
				ServerTestFramework.Web.Presence.PresenceInfo pInfo = wp.GetPresenceInfo(targetXuid, senderXuid, 1, out sec);   // 1 = en-US

                ValueCheck.Test("Presence Widget", pInfo.XUID, targetXuid);
                ValueCheck.Test("Presence Widget", pInfo.GamerTag, x2.Gamertag);

                ResultCode = TEST_RESULTS.PASSED;
			}
		}

        [TestCase, Description( "All locales" )]
		class GetFriendsPresenceAllLocales : TestBase
		{
			override protected void Execute()
			{
                uint sec = 0;

                // Create Xbox 360 User
                XeUser x = UserSetup.CreateXbox360User();
                ulong senderXuid = x.UserPuid;

                // Create Xbox 360 User
                XeUser x2 = UserSetup.CreateXbox360User();
                ulong targetXuid = x2.UserPuid;

                // Log-on users
                PNUser pnX = new PNUser (x.Gamertag, x.UserPuid);
                PNUser pnX2 = new PNUser (x2.Gamertag, x2.UserPuid);
                _fc.LogonUser(pnX);
                _fc.LogonUser(pnX2);

                // Wait for the cache to pick up the change
                Thread.Sleep(sleepTime);

                // Fetch the Friends List
                WCPresence wp = new WCPresence();
				ServerTestFramework.Web.Presence.PresenceInfo pInfo;
               
                // Check all 9 locales
                for(ushort localeId = 1; localeId < 10; localeId++)
                {
                    pInfo = wp.GetPresenceInfo(targetXuid, senderXuid, localeId, out sec);
                    ValueCheck.Test("Presence Widget", pInfo.XUID, targetXuid);
                    ValueCheck.Test("Presence Widget", pInfo.GamerTag, x2.Gamertag);
                }

                ResultCode = TEST_RESULTS.PASSED;
			}
		}

        [TestCase, Description("Sender XUID MAX")]
        class GetPresenceSenderXUID_MAX : TestBase
        {
            override protected void Execute()
            {
                uint sec = 0;

                // Create Xbox 360 User
                XeUser x = UserSetup.CreateXbox360User();
                ulong targetXuid = x.UserPuid;

                // Log-on users
                PNUser pnX = new PNUser(x.Gamertag, x.UserPuid);
                _fc.LogonUser(pnX);

                // Wait for the cache to pick up the change
                Thread.Sleep(sleepTime);

                // Fetch the Friends List
                WCPresence wp = new WCPresence();
                ServerTestFramework.Web.Presence.PresenceInfo pInfo = wp.GetPresenceInfo(targetXuid, ulong.MaxValue, 1, out sec);   // 1 = en-US

                ValueCheck.Test("Presence Widget", pInfo.GamerTag, x.Gamertag);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("Sender XUID NA")]
        class GetPresenceSenderXUID_NA : TestBase
        {
            override protected void Execute()
            {
                uint sec = 0;

                // Create Xbox 360 User
                XeUser x = UserSetup.CreateXbox360User();
                ulong targetXuid = x.UserPuid;

                // Log-on users
                PNUser pnX = new PNUser(x.Gamertag, x.UserPuid);
                _fc.LogonUser(pnX);

                // Wait for the cache to pick up the change
                Thread.Sleep(sleepTime);

                // Fetch the Friends List
                WCPresence wp = new WCPresence();
                ServerTestFramework.Web.Presence.PresenceInfo pInfo = wp.GetPresenceInfo(targetXuid, 42, 1, out sec);   // 1 = en-US

                ValueCheck.Test("Presence Widget", pInfo.GamerTag, x.Gamertag);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        // ---------- NEGATIVE ----------------

        [TestCase, Description( "Sender XUID Invalid 0" )]
		class Invalid_GetPresenceSenderXUID_0 : TestBase
		{
			override protected void Execute()
			{
                uint sec = 0;

                // Create Xbox 360 User
                XeUser x2 = UserSetup.CreateXbox360User();
                ulong targetXuid = x2.UserPuid;

                // Log-on users
                PNUser pnX = new PNUser (x2.Gamertag, x2.UserPuid);
                _fc.LogonUser(pnX);

                // Wait for the cache to pick up the change
                Thread.Sleep(sleepTime);

                // Fetch the Friends List
                WCPresence wp = new WCPresence();
                try
                {
    				ServerTestFramework.Web.Presence.PresenceInfo pInfo = wp.GetPresenceInfo(targetXuid, 0, 1, out sec);   // 1 = en-US
                }
                catch
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
			}
		}


        [TestCase, Description( "Target XUID Invalid 0" )]
		class Invalid_GetPresenceTargetXUID_0 : TestBase
		{
			override protected void Execute()
			{
                uint sec = 0;

                // Create Xbox 360 User
                XeUser x = UserSetup.CreateXbox360User();
                ulong senderXuid = x.UserPuid;

                // Log-on users
                PNUser pnX = new PNUser (x.Gamertag, x.UserPuid);
                _fc.LogonUser(pnX);
                
                // Wait for the cache to pick up the change
                Thread.Sleep(sleepTime);

                // Fetch the Friends List
                WCPresence wp = new WCPresence();
                try
                {
    				ServerTestFramework.Web.Presence.PresenceInfo pInfo = wp.GetPresenceInfo(0, senderXuid, 1, out sec);   // 1 = en-US
                }
                catch
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
			}
		}

        [TestCase, Description( "Target XUID Invalid Max" )]
		class Invalid_GetPresenceTargetXUID_Max : TestBase
		{
			override protected void Execute()
			{
                uint sec = 0;

                // Create Xbox 360 User
                XeUser x = UserSetup.CreateXbox360User();
                ulong senderXuid = x.UserPuid;

                // Log-on users
                PNUser pnX = new PNUser (x.Gamertag, x.UserPuid);
                _fc.LogonUser(pnX);
                
                // Wait for the cache to pick up the change
                Thread.Sleep(sleepTime);

                // Fetch the Friends List
                WCPresence wp = new WCPresence();
                try
                {
    				ServerTestFramework.Web.Presence.PresenceInfo pInfo = wp.GetPresenceInfo(ulong.MaxValue, senderXuid, 1, out sec);   // 1 = en-US
                }
                catch
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
			}
		}

        [TestCase, Description( "Target XUID Invalid 0" )]
		class Invalid_GetPresenceTargetXUID_NA : TestBase
		{
			override protected void Execute()
			{
                uint sec = 0;

                // Create Xbox 360 User
                XeUser x = UserSetup.CreateXbox360User();
                ulong senderXuid = x.UserPuid;

                // Log-on users
                PNUser pnX = new PNUser (x.Gamertag, x.UserPuid);
                _fc.LogonUser(pnX);

                // Wait for the cache to pick up the change
                Thread.Sleep(sleepTime);

                // Fetch the Friends List
                WCPresence wp = new WCPresence();
                try
                {
    				ServerTestFramework.Web.Presence.PresenceInfo pInfo = wp.GetPresenceInfo(42, senderXuid, 1, out sec);   // 1 = en-US
                }
                catch
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
			}
		}

        [TestCase, Description( "Get Presence for an invalid Locale 0" )]
		class Invalid_GetPresenceLocale_0 : TestBase
		{
			override protected void Execute()
			{
                uint sec = 0;

                // Create Xbox 360 User
                XeUser x = UserSetup.CreateXbox360User();
                ulong senderXuid = x.UserPuid;

                // Create Xbox 360 User
                XeUser x2 = UserSetup.CreateXbox360User();
                ulong targetXuid = x2.UserPuid;

                // Log-on users
                PNUser pnX = new PNUser (x.Gamertag, x.UserPuid);
                PNUser pnX2 = new PNUser (x2.Gamertag, x2.UserPuid);
                _fc.LogonUser(pnX);
                _fc.LogonUser(pnX2);

                // Wait for the cache to pick up the change
                Thread.Sleep(sleepTime);

                // Fetch the Friends List
                WCPresence wp = new WCPresence();

   				ServerTestFramework.Web.Presence.PresenceInfo pInfo = wp.GetPresenceInfo(targetXuid, senderXuid, 0, out sec);   // 1 = en-US

                // Invalid region code (not 1-9) returns an EN-US object
                ValueCheck.Test("Presence Widget", pInfo.XUID, targetXuid);
                ValueCheck.Test("Presence Widget", pInfo.GamerTag, x2.Gamertag);

                ResultCode = TEST_RESULTS.PASSED;
			}
        }	

        [TestCase, Description( "Get Presence for an invalid Locale >9" )]
		class Invalid_GetPresenceLocale_10 : TestBase
		{
			override protected void Execute()
			{
                uint sec = 0;

                // Create Xbox 360 User
                XeUser x = UserSetup.CreateXbox360User();
                ulong senderXuid = x.UserPuid;

                // Create Xbox 360 User
                XeUser x2 = UserSetup.CreateXbox360User();
                ulong targetXuid = x2.UserPuid;

                // Log-on users
                PNUser pnX = new PNUser (x.Gamertag, x.UserPuid);
                PNUser pnX2 = new PNUser (x2.Gamertag, x2.UserPuid);
                _fc.LogonUser(pnX);
                _fc.LogonUser(pnX2);

                // Wait for the cache to pick up the change
                Thread.Sleep(sleepTime);

                // Fetch the Friends List
                WCPresence wp = new WCPresence();

    			ServerTestFramework.Web.Presence.PresenceInfo pInfo = wp.GetPresenceInfo(targetXuid, senderXuid, 10, out sec);   // 1 = en-US

                // Invalid region code (not 1-9) returns an EN-US object
                ValueCheck.Test("Presence Widget", pInfo.XUID, targetXuid);
                ValueCheck.Test("Presence Widget", pInfo.GamerTag, x2.Gamertag);
                
                ResultCode = TEST_RESULTS.PASSED;
			}
        }

        [TestCase, Description( "Get Presence for an invalid Locale MAX" )]
		class Invalid_GetPresenceLocale_MAX : TestBase
		{
			override protected void Execute()
			{
                uint sec = 0;

                // Create Xbox 360 User
                XeUser x = UserSetup.CreateXbox360User();
                ulong senderXuid = x.UserPuid;

                // Create Xbox 360 User
                XeUser x2 = UserSetup.CreateXbox360User();
                ulong targetXuid = x2.UserPuid;

                // Log-on users
                PNUser pnX = new PNUser (x.Gamertag, x.UserPuid);
                PNUser pnX2 = new PNUser (x2.Gamertag, x2.UserPuid);
                _fc.LogonUser(pnX);
                _fc.LogonUser(pnX2);

                // Wait for the cache to pick up the change
                Thread.Sleep(sleepTime);

                // Fetch the Friends List
                WCPresence wp = new WCPresence();

    			ServerTestFramework.Web.Presence.PresenceInfo pInfo = wp.GetPresenceInfo(targetXuid, senderXuid, ushort.MaxValue, out sec);   // 1 = en-US

                // Invalid region code (not 1-9) returns an EN-US object
                ValueCheck.Test("Presence Widget", pInfo.XUID, targetXuid);
                ValueCheck.Test("Presence Widget", pInfo.GamerTag, x2.Gamertag);

                ResultCode = TEST_RESULTS.PASSED;
			}
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Presence\Test\BuddyGroup.cs ===
// BuddyGroup.cs
//
//	A group of users used by widget functional tests
//

using System;
using System.Xml;
using System.Threading;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Presence;

namespace PresWidgetTest
{
	////////////////////////////////////////////////
	// Buddy Group
	//	Sets up and manipulate a user's group of buddies
	//
	public class BuddyGroup
	{

		public static void WaitCache()
		{
			new SleepInfo( 
					"Waiting for Cache to update",
					(uint)(1000 * (PWT.CacheExpDelay + 5)));
		}

		public enum Hash   { Same, Diff };
		public enum Status { Online , Offline };

		public PNUser   User;
		public PNUser[] BuddiesOnSame;
		public PNUser[] BuddiesOnDiff;

		/////////////////////////////////////////////
		// Total counts
		//	 Max buddies 
		byte Same
		{
			get{ return (byte)( BuddiesOnSame.Length ); }
		}
		byte Diff
		{
			get{ return (byte)( BuddiesOnDiff.Length ); }
		}

		/////////////////////////////////////////////
		// Deleted counts
		//	 Number deleted regardless of current onlline status
		byte SameDeleted = 0;
		byte DiffDeleted = 0;
		byte Deleted
		{ 
			get{ return (byte)( SameDeleted + DiffDeleted ); } 
		}

		/////////////////////////////////////////////
		// Online / Offline  counts
		//
		// ... Number online regardless of current buddy status
		byte SameOnline = 0;
		byte DiffOnline = 0;
		// ... Number offline regardless of current buddy status
		byte SameOffline
		{
			get{ return (byte)( BuddiesOnSame.Length - SameOnline ); }
		}
		byte DiffOffline
		{
			get{ return (byte)( BuddiesOnDiff.Length - DiffOnline ); }
		}
		// ... Total current buddies online
		public byte Online 
		{
			get{ return (byte)( (SameOnline + DiffOnline) - Deleted ); }
		}
		// ... Total current buddies offline
		public byte Offline
		{
			get{ return (byte)( (SameOffline + DiffOffline) - Deleted ); }
		}

		public static void DeleteAllBuddies(PNUser u)
		{
			ArrayList al = new ArrayList();
			IDictionaryEnumerator e = u.BuddyEnumerator;
			while(e.MoveNext())
			{
				ulong x = (ulong)e.Key;
				PNUser del = PNUser.Find(x);
				if(del == null)
				{
					PNUser.BuddyInfo info = u.GetBuddyInfo(x);
					del = new PNUser(info.Name, x);
				}
				al.Add(del);
			}
			foreach(PNUser del in al)
			{
                u.DeleteBuddy(del);
                u.WaitForBuddyStatusDeleted(del);
			}
			u.GetListChangeNotifications();
			al.Clear();
		}


		////////////////////////////////////////////////
		// Ctor
		//	Grabs a user and sets up buddy lists.  
		//	Everybody ends up logged off.
		//
		// This test seems to be moot now for users on different INH, but keeping this anyway.
		public BuddyGroup( Stack[] userPools, Stack[] buddyPools, int same, int other )
		{
			// Try to balance pool usage 
			int iPoolSame = (userPools[0].Count > userPools[1].Count) ? 0 : 1;
			int iPoolDiff = (iPoolSame == 0) ? 1 : 0;
	
			// Get the main linked user
			User = (PNUser) userPools[ iPoolSame ].Pop();
			PWT.Friends.LogonUser( User );

			if(User.BuddiesAny > 0)
			{
				DeleteAllBuddies( User );
			}
			ConsoleX.WriteLine( "Creating buddy group for "+User.Name );

			// Add buddies from the same INH
			BuddiesOnSame = new PNUser[ same ];
			int maxTry = 4;
			for( int i = 0; i < same; ++i )
			{
				ConsoleX.ClearLine();
				Console.Write( "Adding buddy "+(i+1)+"\r" );

                PNXbox xbox = new PNXbox(true);
                BuddiesOnSame[i] = (PNUser) buddyPools[ iPoolSame ].Pop();
                PWT.Friends.LogonUser(BuddiesOnSame[i], xbox);
                int j = 0;
                while (j<maxTry)
                {
                    try
                    {
                        PWT.Friends.MakeFriend( User, BuddiesOnSame[i] );
                        break;
                    }
                    catch
                    {
                        ConsoleX.WriteLine("Error while MakeFriend. Try: " + j.ToString());
                    }
                    j++;
                }
                if (j>=maxTry)
                {
                    throw new Exception("Couldn't MakeFriend for " + User.UserId + " + with " + BuddiesOnSame[i].UserId);
                }
                PWT.Friends.LogoffUser( BuddiesOnSame[i] );
			}
			ConsoleX.ClearLine();
			ConsoleX.WriteLine( "   Buddies with same hash: "+BuddiesOnSame.Length );

			// Add buddies from another INH
			BuddiesOnDiff = new PNUser[ other ];
			for( int i = 0; i < other; ++i )
			{
				ConsoleX.ClearLine();
				Console.Write( "Adding buddy "+(i+1)+"\r" );

				PNXbox xbox = new PNXbox(true);
				BuddiesOnDiff[i] = (PNUser) buddyPools[ iPoolDiff ].Pop();
				PWT.Friends.LogonUser( BuddiesOnDiff[i], xbox );
                int j = 0;
                while (j < maxTry)
                {
                    try
                    {
                        PWT.Friends.MakeFriend(User, BuddiesOnDiff[i]);
                        break;
                    }
                    catch
                    {
                        ConsoleX.WriteLine("Error while MakeFriend. Try: " + j.ToString());
                    }
                    j++;
                }
                if (j >= maxTry)
                {
                    throw new Exception("Couldn't MakeFriend for " + User.UserId + " + with " + BuddiesOnDiff[i].UserId);
                }
				PWT.Friends.LogoffUser( BuddiesOnDiff[i] );
			}
			ConsoleX.ClearLine();
			ConsoleX.WriteLine( "   Buddies with different hash: "+BuddiesOnDiff.Length );
			
			// Logoff User
			PWT.Friends.LogoffUser( User );
		}

		//////////////////////////////////////////////
		// Get Buddy 
		//	Returns the indexed non deleted budddy with the given status
		//	  from the specified list
		//
		public PNUser GetBuddy( int index, Hash hash, Status status )
		{
			PNUser[] buddyList = (hash==Hash.Same) ? BuddiesOnSame : BuddiesOnDiff;
			
			int i = index + ((hash==Hash.Same) ? SameDeleted : DiffDeleted);
			if( status == Status.Offline )
				i += ((hash==Hash.Same) ? SameOnline : DiffOnline);

			return buddyList[ i ];
		}

		////////////////////////////////////////////////
		// Check Web Friends 
		//	Validates the contents of a Web Freinds reply
		//
		public void CheckWebFriends( WebFriendData wf )
		{
			wf.CheckCount( Online, Offline );
			for( int i = 0; i < SameOnline; ++i )
			{
				wf.CheckUser( GetBuddy( i, Hash.Same, Status.Online));
			}
			for( int i = 0; i < DiffOnline; ++i )
			{
				wf.CheckUser( GetBuddy( i, Hash.Diff, Status.Online));
			}
			for( int i = 0; i < SameOffline; ++i )
			{
				wf.CheckUser( GetBuddy( i, Hash.Same, Status.Offline ) );
			}
			for( int i = 0; i < DiffOffline; ++i )
			{
				wf.CheckUser( GetBuddy( i, Hash.Diff, Status.Offline ) );
			}
		}

		////////////////////////////////////////////////
		// Logon All
		//
		public void LogonAll( bool waitForCache )
		{
			SetLoggedOn( Same, Diff, waitForCache );
		}

		////////////////////////////////////////////////
		// Logoff All
		//
		public void LogoffAll( bool waitForCache )
		{
			SetLoggedOn( 0, 0, waitForCache );
		}

		////////////////////////////////////////////////
		// Set Logged On
		//	Logs buddies on or off to match amounts given.
		//	starting from begining of buddy arrays and working up 
		//
		public void SetLoggedOn( byte same, byte other )                    { SetLoggedOn( same, other, 10, true ); }
		public void SetLoggedOn( byte same, byte other, bool waitForCache ) { SetLoggedOn( same, other, 10, waitForCache ); }
		public void SetLoggedOn( byte same, byte other, uint titleId, bool waitForCache )
		{
			// Check if anything is going to change and bail if it isn't
			if( (SameOnline == same) && (DiffOnline == other) )
				return;

			// Logon some from same
			while( SameOnline < same )
			{
				ConsoleX.ClearLine();
				Console.Write( "Logging on same hash buddy: "+(SameOnline+1)+", Target: "+same+"\r" );
				PWT.Friends.LogonUser( BuddiesOnSame[ SameOnline ], titleId );
				BuddiesOnSame[ SameOnline ].SetTitleData( XonPresNoti.P_STATE_MASK_ONLINE );
				++SameOnline;
			}
			// ... or logoff some from same
			while( SameOnline > same )
			{
				--SameOnline;
				ConsoleX.ClearLine();
				Console.Write( "Logging off same hash buddy: "+(SameOnline+1)+", Target: "+same+"\r" );
				PWT.Friends.LogoffUser( BuddiesOnSame[ SameOnline ] );
			}

			// Logon some from other
			while( DiffOnline < other )
			{
				ConsoleX.ClearLine();
				Console.Write( "Logging on different hash buddy: "+(DiffOnline+1)+", Target: "+other+"\r" );
				PWT.Friends.LogonUser( BuddiesOnDiff[ DiffOnline ], titleId );
				BuddiesOnDiff[ DiffOnline ].SetTitleData( XonPresNoti.P_STATE_MASK_ONLINE );
				++DiffOnline;
			}
			// ... or logoff some from other
			while( DiffOnline > other )
			{
				--DiffOnline;
				ConsoleX.ClearLine();
				Console.Write( "Logging off different hash buddy: "+(DiffOnline+1)+", Target: "+other+"\r" );
				PWT.Friends.LogoffUser( BuddiesOnDiff[ DiffOnline ] );
			}

			ConsoleX.ClearLine();

			if( waitForCache )
			{
				WaitCache();	
			}
		}
	
		////////////////////////////////////////////////
		// Delete All Buddies
		//
		public void DeleteAllBuddies( bool waitForCache )
		{
			SetDeleted( Same, Diff, waitForCache );
		}

		////////////////////////////////////////////////
		// Restore All Buddies 
		//
		public void RestoreAllBuddies( bool waitForCache )
		{
			SetDeleted( 0, 0, waitForCache );
		}
		
		////////////////////////////////////////////////
		// Delete Buddy
		//	Deletes or fully accepts buddies to match amounts given
		//	starting from begining of buddy arrays and working up 
		//
		public void SetDeleted( byte same, byte other ) { SetDeleted( same, other, true ); }
		public void SetDeleted( byte same, byte other, bool waitForCache )
		{
			// Check if anything is going to change and bail if it isn't
			if( (SameDeleted == same) && (DiffDeleted == other) )
				return;

			bool userLoggedOn = User.LoggedOn;
			if( ! userLoggedOn )
			{
				PWT.Friends.LogonUser( User );
			}

			// Delete some from same
			while( SameDeleted < same )
			{
				ConsoleX.ClearLine();
				Console.Write( "Deleting same hash buddy: "+(SameDeleted+1)+", Deleted Target: "+same+"\r" );
				PWT.Friends.DeleteFriend( User, BuddiesOnSame[ SameDeleted ] );
				SameDeleted++;
			}
			// ... or Add back some from same
			while( SameDeleted > same )
			{
				--SameDeleted;
				ConsoleX.ClearLine();
				Console.Write( "Adding same hash buddy: "+(SameDeleted+1)+", Deleted Target: "+same+"\r" );
				PWT.Friends.MakeFriend( User, BuddiesOnSame[ SameDeleted ] );
			}

			// Delete  some from other
			while( DiffDeleted < other )
			{
				ConsoleX.ClearLine();
				Console.Write( "Deleting same different buddy: "+(DiffDeleted+1)+", Deleted Target: "+other+"\r" );
				PWT.Friends.DeleteFriend( User, BuddiesOnDiff[ DiffDeleted ] );
				DiffDeleted++;
			}
			// ... or add back some from other
			while( DiffDeleted > other )
			{
				--DiffDeleted;
				ConsoleX.ClearLine();
				Console.Write( "Adding different hash buddy: "+(DiffDeleted+1)+", Deleted Target: "+other+"\r" );
				PWT.Friends.MakeFriend( User, BuddiesOnDiff[ DiffDeleted ] );
			}

			if( ! userLoggedOn )
			{
				PWT.Friends.LogoffUser( User );
			}

			ConsoleX.ClearLine();
			
			if( waitForCache )
			{
				WaitCache();	
			}
		}

		////////////////////////////////////////////////
		// Request to Deleted 
		//	Makes requests to specified number of deleted buddies 
		//	starting with last deleted buddy and working down
		//
		public void RequestToDeleted( byte same, byte other ) { RequestToDeleted( same, other, true ); }
		public void RequestToDeleted( byte same, byte other, bool waitForCache )
		{
			bool userLoggedOn = User.LoggedOn;
			if( ! userLoggedOn )
			{
				PWT.Friends.LogonUser( User );
			}

			for( int i = 0; i < same; ++i )
			{
				--SameDeleted;					
				ConsoleX.ClearLine();
				Console.Write( "Requesting same hash buddy: "+(i+1)+", Target: "+same+"\r" );
				PWT.Friends.RequestFriend( User, BuddiesOnSame[ SameDeleted ] );
			}

			for( int i = 0; i < other; ++i )
			{
				--DiffDeleted;					
				ConsoleX.ClearLine();
				Console.Write( "Requesting different hash buddy: "+(i+1)+", Target: "+same+"\r" );
				PWT.Friends.RequestFriend( User, BuddiesOnDiff[ DiffDeleted ] );
			}
			
			if( ! userLoggedOn )
			{
				PWT.Friends.LogoffUser( User );
			}

			ConsoleX.ClearLine();
			
			if( waitForCache )
			{
				WaitCache();
			}
		}

		////////////////////////////////////////////////
		// Request from Deleted 
		//	Gets requests from specified number of deleted buddies
		//	starting with last deleted buddy and working down
		//
		public void RequestFromDeleted( byte same, byte other ) { RequestFromDeleted( same, other, true ); }
		public void RequestFromDeleted( byte same, byte other, bool waitForCache )
		{
			bool userLoggedOn = User.LoggedOn;
			if( ! userLoggedOn )
			{
				PWT.Friends.LogonUser( User );
			}

			for( int i = 0; i < same; ++i )
			{
				--SameDeleted;					
				ConsoleX.ClearLine();
				Console.Write( "Requesting same hash buddy: "+(i+1)+", Target: "+same+"\r" );
				PWT.Friends.RequestFriend( BuddiesOnSame[ SameDeleted ], User );
			}

			for( int i = 0; i < other; ++i )
			{
				--DiffDeleted;					
				ConsoleX.ClearLine();
				Console.Write( "Requesting different hash buddy: "+(i+1)+", Target: "+same+"\r" );
				PWT.Friends.RequestFriend( BuddiesOnDiff[ DiffDeleted ], User );
			}

			ConsoleX.ClearLine();
			
			if( waitForCache )
			{
				WaitCache();
			}
		}

		////////////////////////////////////////////////
		// Reject Requested 
		//	Rejects request from specified number of buddies 
		//	starting with first non deleted buddy and working up
		//
		public void RejectRequested( byte same, byte other ) { RejectRequested( same, other, true ); }
		public void RejectRequested( byte same, byte other, bool waitForCache )
		{
			bool userLoggedOn = User.LoggedOn;
			if( ! userLoggedOn )
			{
				PWT.Friends.LogonUser( User );
			}

			for( int i = 0; i < same; ++i )
			{
				ConsoleX.ClearLine();
				Console.Write( "Rejecting ame hash buddy: "+(i+1)+", Target: "+same+"\r" );
				PWT.Friends.RejectFriend( User, BuddiesOnSame[ SameDeleted ] );
				DiffDeleted++;					
			}

			for( int i = 0; i < other; ++i )
			{
				ConsoleX.ClearLine();
				Console.Write( "Rejecting different hash buddy: "+(i+1)+", Target: "+same+"\r" );
				PWT.Friends.RejectFriend( User, BuddiesOnDiff[ DiffDeleted ] );
				DiffDeleted++;					
			}
			
			ConsoleX.ClearLine();
			
			if( waitForCache )
			{
				WaitCache();
			}
		}
	
		////////////////////////////////////////////////
		// Accept Requested 
		//	Accepts a request from specified number of buddies 
		//	starting with first non deleted buddy and working up
		//
		public void AcceptRequested( byte same, byte other ) { AcceptRequested( same, other, true ); }
		public void AcceptRequested( byte same, byte other, bool waitForCache )
		{
			bool userLoggedOn = User.LoggedOn;
			if( ! userLoggedOn )
			{
				PWT.Friends.LogonUser( User );
			}

			for( int i = 0; i < same; ++i )
			{
				ConsoleX.ClearLine();
				Console.Write( "Accepting same hash buddy: "+(i+1)+", Target: "+same+"\r" );
				PWT.Friends.AcceptFriend( User, BuddiesOnSame[ SameDeleted+i ] );
			}

			for( int i = 0; i < other; ++i )
			{
				ConsoleX.ClearLine();
				Console.Write( "Accepting different hash buddy: "+(i+1)+", Target: "+same+"\r" );
				PWT.Friends.AcceptFriend( User, BuddiesOnDiff[ DiffDeleted+i ] );
			}
			
			ConsoleX.ClearLine();
			
			if( waitForCache )
			{
				WaitCache();
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Messaging\Test\dvt\wsdl.cs ===
//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.1.4322.573
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=1.1.4322.573.
// 
namespace xonline.server.webcache.messaging.test.dvt  {    using System.Diagnostics;
    using System.Xml.Serialization;
    using System;
    using System.Web.Services.Protocols;
    using System.ComponentModel;
    using System.Web.Services;
    
    
    /// <remarks/>
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="MessagingSoap", Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class Messaging : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        /// <remarks/>
        public Messaging() {
            this.Url = "https://websvc.xboxlive.com/messaging/messaging.asmx";
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/EnumMessages", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public System.UInt32 EnumMessages([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] UserWebID, string UserGamerTag, [System.Xml.Serialization.XmlElementAttribute("Summary")] out WCMessageSummary[] Summary) {
            object[] results = this.Invoke("EnumMessages", new object[] {
                        UserWebID,
                        UserGamerTag});
            Summary = ((WCMessageSummary[])(results[1]));
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginEnumMessages(System.Byte[] UserWebID, string UserGamerTag, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("EnumMessages", new object[] {
                        UserWebID,
                        UserGamerTag}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.UInt32 EndEnumMessages(System.IAsyncResult asyncResult, out WCMessageSummary[] Summary) {
            object[] results = this.EndInvoke(asyncResult);
            Summary = ((WCMessageSummary[])(results[1]));
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/GetMessageDetails", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public System.UInt32 GetMessageDetails([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] UserWebID, string UserGamerTag, System.UInt32 MessageID, WCMessageFlags SetFlags, WCMessageFlags UnsetFlags, out WCMessageSummary Summary, out WCMessageDetails Details) {
            object[] results = this.Invoke("GetMessageDetails", new object[] {
                        UserWebID,
                        UserGamerTag,
                        MessageID,
                        SetFlags,
                        UnsetFlags});
            Summary = ((WCMessageSummary)(results[1]));
            Details = ((WCMessageDetails)(results[2]));
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetMessageDetails(System.Byte[] UserWebID, string UserGamerTag, System.UInt32 MessageID, WCMessageFlags SetFlags, WCMessageFlags UnsetFlags, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetMessageDetails", new object[] {
                        UserWebID,
                        UserGamerTag,
                        MessageID,
                        SetFlags,
                        UnsetFlags}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.UInt32 EndGetMessageDetails(System.IAsyncResult asyncResult, out WCMessageSummary Summary, out WCMessageDetails Details) {
            object[] results = this.EndInvoke(asyncResult);
            Summary = ((WCMessageSummary)(results[1]));
            Details = ((WCMessageDetails)(results[2]));
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/DeleteMessage", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public System.UInt32 DeleteMessage([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] UserWebID, string UserGamerTag, System.UInt32 MessageID, WCDeleteMsgFlags Flags) {
            object[] results = this.Invoke("DeleteMessage", new object[] {
                        UserWebID,
                        UserGamerTag,
                        MessageID,
                        Flags});
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginDeleteMessage(System.Byte[] UserWebID, string UserGamerTag, System.UInt32 MessageID, WCDeleteMsgFlags Flags, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("DeleteMessage", new object[] {
                        UserWebID,
                        UserGamerTag,
                        MessageID,
                        Flags}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.UInt32 EndDeleteMessage(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/SendMessage", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public System.UInt32 SendMessage([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] SenderWebID, string SenderGamerTag, System.UInt64 SenderContext, WCMessageFlags MessageFlags, System.UInt32 SenderTitleID, System.UInt16 ExpireMinutes, WCMessageType MessageType, [System.Xml.Serialization.XmlElementAttribute("Recipient")] string[] Recipient, WCMessageDetails Details, [System.Xml.Serialization.XmlElementAttribute("Attachment")] WCMessageAttachment[] Attachment, [System.Xml.Serialization.XmlElementAttribute("RecipResult")] out WCRecipientResult[] RecipResult) {
            object[] results = this.Invoke("SendMessage", new object[] {
                        SenderWebID,
                        SenderGamerTag,
                        SenderContext,
                        MessageFlags,
                        SenderTitleID,
                        ExpireMinutes,
                        MessageType,
                        Recipient,
                        Details,
                        Attachment});
            RecipResult = ((WCRecipientResult[])(results[1]));
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSendMessage(System.Byte[] SenderWebID, string SenderGamerTag, System.UInt64 SenderContext, WCMessageFlags MessageFlags, System.UInt32 SenderTitleID, System.UInt16 ExpireMinutes, WCMessageType MessageType, string[] Recipient, WCMessageDetails Details, WCMessageAttachment[] Attachment, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SendMessage", new object[] {
                        SenderWebID,
                        SenderGamerTag,
                        SenderContext,
                        MessageFlags,
                        SenderTitleID,
                        ExpireMinutes,
                        MessageType,
                        Recipient,
                        Details,
                        Attachment}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.UInt32 EndSendMessage(System.IAsyncResult asyncResult, out WCRecipientResult[] RecipResult) {
            object[] results = this.EndInvoke(asyncResult);
            RecipResult = ((WCRecipientResult[])(results[1]));
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/RevokeMessage", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public System.UInt32 RevokeMessage([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] SenderWebID, string SenderGamerTag, [System.Xml.Serialization.XmlElementAttribute("RecipResult")] WCRecipientResult[] RecipResult) {
            object[] results = this.Invoke("RevokeMessage", new object[] {
                        SenderWebID,
                        SenderGamerTag,
                        RecipResult});
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginRevokeMessage(System.Byte[] SenderWebID, string SenderGamerTag, WCRecipientResult[] RecipResult, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("RevokeMessage", new object[] {
                        SenderWebID,
                        SenderGamerTag,
                        RecipResult}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.UInt32 EndRevokeMessage(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/DeleteUserTitle", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public System.UInt32 DeleteUserTitle([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] UserWebID, string UserGamerTag, System.UInt32 TitleID) {
            object[] results = this.Invoke("DeleteUserTitle", new object[] {
                        UserWebID,
                        UserGamerTag,
                        TitleID});
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginDeleteUserTitle(System.Byte[] UserWebID, string UserGamerTag, System.UInt32 TitleID, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("DeleteUserTitle", new object[] {
                        UserWebID,
                        UserGamerTag,
                        TitleID}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.UInt32 EndDeleteUserTitle(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/EnumUserTitles", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public System.UInt32 EnumUserTitles([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] UserWebID, string UserGamerTag, [System.Xml.Serialization.XmlElementAttribute("Title")] out WCUserTitle[] Title) {
            object[] results = this.Invoke("EnumUserTitles", new object[] {
                        UserWebID,
                        UserGamerTag});
            Title = ((WCUserTitle[])(results[1]));
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginEnumUserTitles(System.Byte[] UserWebID, string UserGamerTag, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("EnumUserTitles", new object[] {
                        UserWebID,
                        UserGamerTag}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.UInt32 EndEnumUserTitles(System.IAsyncResult asyncResult, out WCUserTitle[] Title) {
            object[] results = this.EndInvoke(asyncResult);
            Title = ((WCUserTitle[])(results[1]));
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/SetMessageFlags", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public System.UInt32 SetMessageFlags([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] UserWebID, string UserGamerTag, System.UInt32 MessageID, WCMessageFlags SetFlags, WCMessageFlags UnsetFlags) {
            object[] results = this.Invoke("SetMessageFlags", new object[] {
                        UserWebID,
                        UserGamerTag,
                        MessageID,
                        SetFlags,
                        UnsetFlags});
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSetMessageFlags(System.Byte[] UserWebID, string UserGamerTag, System.UInt32 MessageID, WCMessageFlags SetFlags, WCMessageFlags UnsetFlags, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SetMessageFlags", new object[] {
                        UserWebID,
                        UserGamerTag,
                        MessageID,
                        SetFlags,
                        UnsetFlags}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.UInt32 EndSetMessageFlags(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/EnumTitleWideMessages", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public System.UInt32 EnumTitleWideMessages(System.UInt32 TitleID, [System.Xml.Serialization.XmlElementAttribute("Summary")] out WCTitleWideMessageSummary[] Summary) {
            object[] results = this.Invoke("EnumTitleWideMessages", new object[] {
                        TitleID});
            Summary = ((WCTitleWideMessageSummary[])(results[1]));
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginEnumTitleWideMessages(System.UInt32 TitleID, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("EnumTitleWideMessages", new object[] {
                        TitleID}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.UInt32 EndEnumTitleWideMessages(System.IAsyncResult asyncResult, out WCTitleWideMessageSummary[] Summary) {
            object[] results = this.EndInvoke(asyncResult);
            Summary = ((WCTitleWideMessageSummary[])(results[1]));
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/GetTitleWideMessageDetails", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public System.UInt32 GetTitleWideMessageDetails(System.UInt32 TitleID, System.UInt32 MessageID, out WCTitleWideMessageSummary Summary, out WCMessageDetails Details) {
            object[] results = this.Invoke("GetTitleWideMessageDetails", new object[] {
                        TitleID,
                        MessageID});
            Summary = ((WCTitleWideMessageSummary)(results[1]));
            Details = ((WCMessageDetails)(results[2]));
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetTitleWideMessageDetails(System.UInt32 TitleID, System.UInt32 MessageID, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetTitleWideMessageDetails", new object[] {
                        TitleID,
                        MessageID}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.UInt32 EndGetTitleWideMessageDetails(System.IAsyncResult asyncResult, out WCTitleWideMessageSummary Summary, out WCMessageDetails Details) {
            object[] results = this.EndInvoke(asyncResult);
            Summary = ((WCTitleWideMessageSummary)(results[1]));
            Details = ((WCMessageDetails)(results[2]));
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/DeleteTitleWideMessage", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public System.UInt32 DeleteTitleWideMessage(System.UInt32 TitleID, System.UInt32 MessageID, WCDeleteSysMsgFlags Flags) {
            object[] results = this.Invoke("DeleteTitleWideMessage", new object[] {
                        TitleID,
                        MessageID,
                        Flags});
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginDeleteTitleWideMessage(System.UInt32 TitleID, System.UInt32 MessageID, WCDeleteSysMsgFlags Flags, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("DeleteTitleWideMessage", new object[] {
                        TitleID,
                        MessageID,
                        Flags}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.UInt32 EndDeleteTitleWideMessage(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/SendTitleWideMessage", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public System.UInt32 SendTitleWideMessage(string Sender, System.UInt64 SenderContext, System.DateTime SentTime, System.UInt32 Region, WCMessageFlags MessageFlags, System.UInt32 SenderTitleID, System.UInt16 ExpireMinutes, WCMessageType MessageType, string Description, WCMessageDetails Details, [System.Xml.Serialization.XmlElementAttribute("LocalizedString")] WCLocalizedString[] LocalizedString, [System.Xml.Serialization.XmlElementAttribute("Attachment")] WCMessageAttachment[] Attachment, out System.UInt16 Delay, out System.UInt32 MessageID) {
            object[] results = this.Invoke("SendTitleWideMessage", new object[] {
                        Sender,
                        SenderContext,
                        SentTime,
                        Region,
                        MessageFlags,
                        SenderTitleID,
                        ExpireMinutes,
                        MessageType,
                        Description,
                        Details,
                        LocalizedString,
                        Attachment});
            Delay = ((System.UInt16)(results[1]));
            MessageID = ((System.UInt32)(results[2]));
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSendTitleWideMessage(string Sender, System.UInt64 SenderContext, System.DateTime SentTime, System.UInt32 Region, WCMessageFlags MessageFlags, System.UInt32 SenderTitleID, System.UInt16 ExpireMinutes, WCMessageType MessageType, string Description, WCMessageDetails Details, WCLocalizedString[] LocalizedString, WCMessageAttachment[] Attachment, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SendTitleWideMessage", new object[] {
                        Sender,
                        SenderContext,
                        SentTime,
                        Region,
                        MessageFlags,
                        SenderTitleID,
                        ExpireMinutes,
                        MessageType,
                        Description,
                        Details,
                        LocalizedString,
                        Attachment}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.UInt32 EndSendTitleWideMessage(System.IAsyncResult asyncResult, out System.UInt16 Delay, out System.UInt32 MessageID) {
            object[] results = this.EndInvoke(asyncResult);
            Delay = ((System.UInt16)(results[1]));
            MessageID = ((System.UInt32)(results[2]));
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/SendTitleUserMessage", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public System.UInt32 SendTitleUserMessage(string Sender, System.UInt64 SenderContext, WCMessageFlags MessageFlags, System.UInt32 SenderTitleID, System.UInt16 ExpireMinutes, WCMessageType MessageType, [System.Xml.Serialization.XmlElementAttribute("Recipient")] string[] Recipient, WCMessageDetails Details, [System.Xml.Serialization.XmlElementAttribute("Attachment")] WCMessageAttachment[] Attachment, [System.Xml.Serialization.XmlElementAttribute("RecipResult")] out WCRecipientResult[] RecipResult) {
            object[] results = this.Invoke("SendTitleUserMessage", new object[] {
                        Sender,
                        SenderContext,
                        MessageFlags,
                        SenderTitleID,
                        ExpireMinutes,
                        MessageType,
                        Recipient,
                        Details,
                        Attachment});
            RecipResult = ((WCRecipientResult[])(results[1]));
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSendTitleUserMessage(string Sender, System.UInt64 SenderContext, WCMessageFlags MessageFlags, System.UInt32 SenderTitleID, System.UInt16 ExpireMinutes, WCMessageType MessageType, string[] Recipient, WCMessageDetails Details, WCMessageAttachment[] Attachment, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SendTitleUserMessage", new object[] {
                        Sender,
                        SenderContext,
                        MessageFlags,
                        SenderTitleID,
                        ExpireMinutes,
                        MessageType,
                        Recipient,
                        Details,
                        Attachment}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.UInt32 EndSendTitleUserMessage(System.IAsyncResult asyncResult, out WCRecipientResult[] RecipResult) {
            object[] results = this.EndInvoke(asyncResult);
            RecipResult = ((WCRecipientResult[])(results[1]));
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/RevokeTitleUserMessage", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public System.UInt32 RevokeTitleUserMessage([System.Xml.Serialization.XmlElementAttribute("RecipResult")] WCRecipientResult[] RecipResult) {
            object[] results = this.Invoke("RevokeTitleUserMessage", new object[] {
                        RecipResult});
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginRevokeTitleUserMessage(WCRecipientResult[] RecipResult, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("RevokeTitleUserMessage", new object[] {
                        RecipResult}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.UInt32 EndRevokeTitleUserMessage(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/GetMessageString", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("StringData")]
        public string GetMessageString(System.UInt32 TitleID, System.UInt32 StringID, string Locale) {
            object[] results = this.Invoke("GetMessageString", new object[] {
                        TitleID,
                        StringID,
                        Locale});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetMessageString(System.UInt32 TitleID, System.UInt32 StringID, string Locale, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetMessageString", new object[] {
                        TitleID,
                        StringID,
                        Locale}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndGetMessageString(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class WCMessageSummary {
        
        /// <remarks/>
        public string Sender;
        
        /// <remarks/>
        public System.UInt64 SenderContext;
        
        /// <remarks/>
        public System.DateTime SentTime;
        
        /// <remarks/>
        public System.UInt32 MessageID;
        
        /// <remarks/>
        public WCMessageFlags MessageFlags;
        
        /// <remarks/>
        public System.UInt32 SenderTitleID;
        
        /// <remarks/>
        public System.UInt16 ExpireMinutes;
        
        /// <remarks/>
        public System.UInt16 DetailsSize;
        
        /// <remarks/>
        public WCMessageType MessageType;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    [System.FlagsAttribute()]
    public enum WCMessageFlags {
        
        /// <remarks/>
        Required = 1,
        
        /// <remarks/>
        Recommended = 2,
        
        /// <remarks/>
        HasVoice = 4,
        
        /// <remarks/>
        HasText = 8,
        
        /// <remarks/>
        Read = 16,
        
        /// <remarks/>
        NonExportable = 32,
        
        /// <remarks/>
        TeamContext = 64,
        
        /// <remarks/>
        CompContext = 128,
        
        /// <remarks/>
        AlternateTitle = 256,
        
        /// <remarks/>
        Marketing = 512,
        
        /// <remarks/>
        MSReserved0 = 1024,
        
        /// <remarks/>
        MSReserved1 = 2048,
        
        /// <remarks/>
        MSReserved2 = 4096,
        
        /// <remarks/>
        MSReserved3 = 8192,
        
        /// <remarks/>
        MSReserved4 = 16384,
        
        /// <remarks/>
        MSReserved5 = 32768,
        
        /// <remarks/>
        MSReserved6 = 65536,
        
        /// <remarks/>
        MSReserved7 = 131072,
        
        /// <remarks/>
        MSReserved8 = 262144,
        
        /// <remarks/>
        MSReserved9 = 524288,
        
        /// <remarks/>
        MSReserved10 = 1048576,
        
        /// <remarks/>
        MSReserved11 = 2097152,
        
        /// <remarks/>
        MSReserved12 = 4194304,
        
        /// <remarks/>
        MSReserved13 = 8388608,
        
        /// <remarks/>
        TitleReserved0 = 16777216,
        
        /// <remarks/>
        TitleReserved1 = 33554432,
        
        /// <remarks/>
        TitleReserved2 = 67108864,
        
        /// <remarks/>
        TitleReserved3 = 134217728,
        
        /// <remarks/>
        TitleReserved4 = 268435456,
        
        /// <remarks/>
        TitleReserved5 = 536870912,
        
        /// <remarks/>
        TitleReserved6 = 1073741824,
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public enum WCMessageType {
        
        /// <remarks/>
        Invalid,
        
        /// <remarks/>
        TitleCustom,
        
        /// <remarks/>
        FriendRequest,
        
        /// <remarks/>
        GameInvite,
        
        /// <remarks/>
        TeamRecruit,
        
        /// <remarks/>
        CompReminder,
        
        /// <remarks/>
        CompRequest,
        
        /// <remarks/>
        LiveMessage,
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class WCLanguageString {
        
        /// <remarks/>
        public string Locale;
        
        /// <remarks/>
        public string String;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class WCLocalizedString {
        
        /// <remarks/>
        public System.Byte PropID;
        
        /// <remarks/>
        public string DefaultLocale;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("LangString")]
        public WCLanguageString[] LangString;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class WCTitleWideMessageSummary {
        
        /// <remarks/>
        public System.UInt32 TitleID;
        
        /// <remarks/>
        public System.UInt64 SenderContext;
        
        /// <remarks/>
        public System.DateTime SentTime;
        
        /// <remarks/>
        public System.UInt32 Region;
        
        /// <remarks/>
        public System.UInt32 MessageID;
        
        /// <remarks/>
        public WCMessageFlags MessageFlags;
        
        /// <remarks/>
        public System.UInt16 ExpireMinutes;
        
        /// <remarks/>
        public System.UInt16 DetailsSize;
        
        /// <remarks/>
        public WCMessageType MessageType;
        
        /// <remarks/>
        public string SenderName;
        
        /// <remarks/>
        public string Description;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class WCUserTitle {
        
        /// <remarks/>
        public System.UInt32 TitleID;
        
        /// <remarks/>
        public System.DateTime LastLogonTime;
        
        /// <remarks/>
        public WCUserTitleFlags Flags;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    [System.FlagsAttribute()]
    public enum WCUserTitleFlags {
        
        /// <remarks/>
        AcceptMarketing = 1,
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class WCRecipientResult {
        
        /// <remarks/>
        public string User;
        
        /// <remarks/>
        public System.UInt32 MessageID;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class WCMessageAttachment {
        
        /// <remarks/>
        public System.Byte PropID;
        
        /// <remarks/>
        public WCAttachFlags Flags;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
        public System.Byte[] Data;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    [System.FlagsAttribute()]
    public enum WCAttachFlags {
        
        /// <remarks/>
        NonExportable = 1,
        
        /// <remarks/>
        Directory = 2,
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class WCStringIdProp {
        
        /// <remarks/>
        public System.Byte PropID;
        
        /// <remarks/>
        public System.UInt32 Value;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class WCBoolProp {
        
        /// <remarks/>
        public System.Byte PropID;
        
        /// <remarks/>
        public bool Value;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class WCAttachmentProp {
        
        /// <remarks/>
        public System.Byte PropID;
        
        /// <remarks/>
        public System.UInt32 AttachSize;
        
        /// <remarks/>
        public WCAttachFlags AttachFlags;
        
        /// <remarks/>
        public string AttachUrl;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class WCBinaryProp {
        
        /// <remarks/>
        public System.Byte PropID;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
        public System.Byte[] Value;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class WCTimeProp {
        
        /// <remarks/>
        public System.Byte PropID;
        
        /// <remarks/>
        public System.DateTime Value;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class WCStringProp {
        
        /// <remarks/>
        public System.Byte PropID;
        
        /// <remarks/>
        public string Value;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class WCQwordProp {
        
        /// <remarks/>
        public System.Byte PropID;
        
        /// <remarks/>
        public System.UInt64 Value;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class WCDwordProp {
        
        /// <remarks/>
        public System.Byte PropID;
        
        /// <remarks/>
        public System.UInt32 Value;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class WCWordProp {
        
        /// <remarks/>
        public System.Byte PropID;
        
        /// <remarks/>
        public System.UInt16 Value;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class WCByteProp {
        
        /// <remarks/>
        public System.Byte PropID;
        
        /// <remarks/>
        public System.Byte Value;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class WCNullProp {
        
        /// <remarks/>
        public System.Byte PropID;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public class WCMessageDetails {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("NullProp")]
        public WCNullProp[] NullProp;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("ByteProp")]
        public WCByteProp[] ByteProp;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("WordProp")]
        public WCWordProp[] WordProp;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("DwordProp")]
        public WCDwordProp[] DwordProp;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("QwordProp")]
        public WCQwordProp[] QwordProp;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("StringProp")]
        public WCStringProp[] StringProp;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("TimeProp")]
        public WCTimeProp[] TimeProp;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("BinaryProp")]
        public WCBinaryProp[] BinaryProp;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("AttachmentProp")]
        public WCAttachmentProp[] AttachmentProp;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("BoolProp")]
        public WCBoolProp[] BoolProp;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("StringIdProp")]
        public WCStringIdProp[] StringIdProp;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    [System.FlagsAttribute()]
    public enum WCDeleteMsgFlags {
        
        /// <remarks/>
        BlockSender = 1,
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    [System.FlagsAttribute()]
    public enum WCDeleteSysMsgFlags {
        
        /// <remarks/>
        RevokeAll = 1,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Presence\Test\FuncGetRecentPlayers.cs ===
using System;
using System.Threading;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Web.Presence;
using ServerTestFramework.LiveService.GI;

namespace PresWidgetTest
{
    [TestGroup]
    public class FuncGetRecentPlayers : TestNode
    {
        private static FriendsCommon _fc;
        private const ushort MaxRecentPlayers = 50;

        [TestGroupSetup]
        public void Setup()
        {
            _fc = new FriendsCommon();
        }

        [TestGroupTearDown]
        public void TearDown()
        {
            _fc = null;
        }

        private void DoNegativeLocaleTest(ushort Locale)
        {
            ushort Encountered = 50;
            ushort Requested   = 50;
            PNUser owner = _fc.CreateXenonUser(true);
            PNUser[] encountered = new PNUser[Encountered];

            for (ushort user = 0; user < Encountered; user++)
            {
                PNUser newEncountered = _fc.CreateXenonUser(false);
                encountered[user] = newEncountered;
                newEncountered.Xbox.ChangeTitle(newEncountered.Xbox.TitleId + 1, 0, 0);
                _fc.LogonUser(newEncountered);

            }

            AffiliateState state = new AffiliateState(owner);
            ArrayList toAdd = new ArrayList();
            for (int i = 0; i < Encountered; i++)
            {
                toAdd.Add(encountered[i]);
                if (toAdd.Count == XonPresNoti.X_ADD_AFFILIATE_MAX)
                {
                    state.Add((PNUser[])toAdd.ToArray(typeof(PNUser)), (uint)AffiliateFlags.Encountered, owner.Xbox.TitleId);
                    toAdd.Clear();
                }
            }

            if (toAdd.Count > 0)
                state.Add((PNUser[])toAdd.ToArray(typeof(PNUser)), (uint)AffiliateFlags.Encountered, owner.Xbox.TitleId);

            SleepInfo sleep = new SleepInfo("Waiting for Xcache", 15000);

            WCPresence wp = new WCPresence();
            RecentPlayer[] rp = wp.GetRecentPlayers(owner.UserId, Requested, Locale);
            if (rp != null)
            {
                ConsoleX.WriteLine("Recent player(s) found: " + rp.Length);
                for (int i = 0; i < rp.Length; i++)
                {
                    ConsoleX.WriteLine("" + rp[i].UserLivepuid + " " + rp[i].GamerTileUrl);
                }
            }
            else
            {
                ConsoleX.WriteLine("No recent players found.");
            }

            ValueCheck.Test("Presence Widget", Requested < Encountered ? Requested : Encountered, rp.Length);
        }

        private void DoPositiveTest(ushort Encountered, ushort Requested)
        {
            PNUser owner = _fc.CreateXenonUser(true);
            PNUser[] encountered = new PNUser[Encountered];

            for (ushort user = 0; user < Encountered; user++)
            {
                PNUser newEncountered = _fc.CreateXenonUser(false);
                encountered[user] = newEncountered;
                newEncountered.Xbox.ChangeTitle(newEncountered.Xbox.TitleId + 1, 0, 0);
                _fc.LogonUser(newEncountered);

            }

            AffiliateState state = new AffiliateState(owner);
            ArrayList toAdd = new ArrayList();
            for (int i = 0; i < Encountered; i++)
            {
                toAdd.Add(encountered[i]);
                if (toAdd.Count == XonPresNoti.X_ADD_AFFILIATE_MAX)
                {
                    state.Add((PNUser[])toAdd.ToArray(typeof(PNUser)), (uint)AffiliateFlags.Encountered, owner.Xbox.TitleId);
                    toAdd.Clear();
                }
            }

            if(toAdd.Count > 0)
                state.Add((PNUser[])toAdd.ToArray(typeof(PNUser)), (uint)AffiliateFlags.Encountered, owner.Xbox.TitleId);

            SleepInfo sleep = new SleepInfo("Waiting for Xcache", 15000);

            for (ushort Locale = (ushort)PresenceTitleConfig.LanguageId.EN; Locale < (ushort)PresenceTitleConfig.LanguageId.RU; Locale++)
            {

                WCPresence wp = new WCPresence();
                RecentPlayer[] rp = wp.GetRecentPlayers(owner.UserId, Requested, Locale);
                if (rp != null)
                {
                    ConsoleX.WriteLine("Recent player(s) found: " + rp.Length);
                    for (int i = 0; i < rp.Length; i++)
                    {
                        ConsoleX.WriteLine("" + rp[i].UserLivepuid + " " + rp[i].GamerTileUrl);
                    }
                }
                else
                {
                    ConsoleX.WriteLine("No recent players found.");
                }

                ValueCheck.Test("Presence Widget", Requested < Encountered ? Requested : Encountered, rp.Length);
            }
        }

        [TestCase]
        public void Puid_Zero()
        {
            try
            {
                WCPresence wp = new WCPresence();
                RecentPlayer[] rp = wp.GetRecentPlayers(0, 1, 1);
            }
            catch (Exception ex)
            {
                // check for livecache exception
                Console.WriteLine(ex);
            }
        }

        [TestCase]
        public void Puid_Not_Exist()
        {
            try
            {
                WCPresence wp = new WCPresence();
                RecentPlayer[] rp = wp.GetRecentPlayers(ulong.MaxValue, 1, 1);
            }
            catch (Exception ex)
            {
                // check for livecache exception
                Console.WriteLine(ex);
            }
        }

        [TestCase]
        public void Locale_Zero()
        {
            DoNegativeLocaleTest(0);
        }

        [TestCase]
        public void Locale_Invalid()
        {
            DoNegativeLocaleTest(0xFF);
        }

        [TestCase]
        public void Encountered_0_Request_0()
        {
            DoPositiveTest(0, 0);
        }

        [TestCase]
        public void Encountered_0_Request_1()
        {
            DoPositiveTest(0, 1);
        }

        [TestCase]
        public void Encountered_1_Request_1()
        {
            DoPositiveTest(1, 1);
        }

        [TestCase]
        public void Encountered_1_Request_Max()
        {
            DoPositiveTest(1, MaxRecentPlayers);
        }

        [TestCase]
        public void Encountered_Max_Request_1()
        {
            DoPositiveTest(MaxRecentPlayers, 1);
        }

        [TestCase]
        public void Encountered_Max_Request_Max()
        {
            DoPositiveTest(MaxRecentPlayers, MaxRecentPlayers);
        }

        [TestCase]
        public void Encountered_1_Request_MaxPlusOne()
        {
            DoPositiveTest(1, MaxRecentPlayers + 1);
        }

        [TestCase]
        public void Encountered_Max_Request_MaxPlusOne()
        {
            DoPositiveTest(MaxRecentPlayers, MaxRecentPlayers + 1);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Presence\Dll\XboxcomLib.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Web;
using System.Web.Services;
using System.Web.Caching;
using System.Drawing;
using System.Drawing.Imaging;

using xonline.common.config;
using xonline.common.installer;
using xonline.common.service;
using xonline.common.protocol;
using xonline.common.mgmt;
using xonline.common.utilities;
using xonline.server.mgmt.soap;
using xonline.server.webcache.common;


namespace xonline.server.webcache.presence.dll 
{
    public enum RecentPlayerStatus { Neutral, Preferred, Avoided }

    public enum AffiliateFlag
    {
        Encountered,
        Completed,
        Positive,
        Negative,
        Avoiding,
        Friend,
        Block,
        Mute
    }

    public enum GamercardZones : int
    {
        Unknown = -2,
        None = -1,
        Xbox_1 = 0,
        RR,
        Pro,
        Family,
        Underground
    }

    public enum PrivilegeValue
    {
        Allow,
        FriendsOnly,
        Deny
    }

    public enum TitleType
    {
        Utility,
        Xbox1,
        Xbox360,
        Xbox360Demo
    }

    public enum FallbackTileType : byte
    {
        // FallbackTiles expects the members of this enum to start at 0 and be incremented sequentually.
        // The name of the enums should corespond to a .jpg with the same name that is in /xweb/lib/images.
        QuestionMark64x64 = 0,
        QuestionMark32x32
    }

    public class RecentPlayer
    {

        private ulong userLivepuid = 0;
        public ulong UserLivepuid
        {
            get { return userLivepuid; }
            set { userLivepuid = value; }
        }

        private string gamertag = String.Empty;
        public string Gamertag
        {
            get { return gamertag; }
            set { gamertag = value; }
        }

        private string gamerTileUrl = String.Empty;
        public string GamerTileUrl
        {
            get { return gamerTileUrl; }
            set { gamerTileUrl = value; }
        }

        private int reputationBucket = 0;
        public int ReputationBucket
        {
            get { return reputationBucket; }
            set { reputationBucket = value; }
        }

        private int gamerScore = 0;
        public int GamerScore
        {
            get { return gamerScore; }
            set { gamerScore = value; }
        }

        private GamercardZones gamerZone = GamercardZones.Unknown;
        public GamercardZones GamerZone
        {
            get { return gamerZone; }
            set { gamerZone = value; }
        }

        private RecentPlayerStatus status = RecentPlayerStatus.Preferred;
        public RecentPlayerStatus Status
        {
            get { return status; }
            set { status = value; }
        }

        private string gameTitleName = String.Empty;
        public string GameTitleName
        {
            get { return gameTitleName; }
            set { gameTitleName = value; }
        }

        private DateTime lastMetDate = DateTime.MinValue;
        public DateTime LastMetDate
        {
            get { return lastMetDate; }
            set { lastMetDate = value; }
        }

        private string gameTitleTileUrl = String.Empty;
        public string GameTitleTileUrl
        {
            get { return gameTitleTileUrl; }
            set { gameTitleTileUrl = value; }
        }
    }
    
    public class RecentPlayerCollection : CollectionBase
    {
        public RecentPlayer this[int index]
        {
            get
            {
                return ((RecentPlayer)List[index]);
            }
            set
            {
                List[index] = value;
            }
        }

        public int Add(RecentPlayer value)
        {
            return (List.Add(value));
        }

        public bool Contains(RecentPlayer value)
        {
            return (List.Contains(value));
        }
    }

    public class UserSettingBuilder
    {
        private const int defaultInitialCapacity = 10;
        ArrayList settings;

        /// <summary>
        /// Constructs a UserSettingBuilder with a default initial capacity
        /// </summary>
        public UserSettingBuilder(ulong targetLivepuid)
            : this(targetLivepuid, defaultInitialCapacity)
        {
        }

        /// <summary>
        /// Constructs a UserSettingBuilder with the specified initial capacity.
        /// </summary>
        /// <param name="targetLivepuid">The live PUID of the user we want to get information about.</param>
        /// <param name="initialCapacity">Initial capacity of the UserSettingBuilder</param>
        public UserSettingBuilder(ulong targetLivepuid, int initialCapacity)
        {
            settings = new ArrayList(initialCapacity);
            _userId = targetLivepuid;
        }

        /// <summary>
        /// Gets or sets the source that will be used when adding settings
        /// </summary>
        public uint Source
        {
            get { return _source; }
            set { _source = value; }
        }
        private uint _source = XOn.XSOURCE_DEFAULT;

        /// <summary>
        /// Gets the user that the setting is being requested for.
        /// </summary>
        /// <remarks>
        /// This value is set by the constructor. Since we only want to make a request
        /// for a single user's settings, this helps to enforce only having one user defined
        /// in the resulting UserSetting array.</remarks>
        public ulong UserId
        {
            get { return _userId; }
        }
        private ulong _userId = 0;

        public void AddIntSetting(StatsProfileSetting setting, int value)
        {
            if ((((int)setting >> 28) & 0xf) != (byte)XuserDataType.Int32)
            {
                throw new XboxComCodeErrorException(
                    "AddIntSetting was called with a setting ID that does not indicate a Int32 type. Type value for setting " + setting + " is " + (((int)setting >> 28) & 0xf) + ".");
            }

            byte[] byteValue = BitConverter.GetBytes(value);
            xonline.common.protocol.UserSetting newSetting = new xonline.common.protocol.UserSetting(UserId, Source, (uint)setting, byteValue);
            settings.Add(newSetting);
        }

        public void AddStringSetting(StatsProfileSetting setting, string value)
        {
            if ((((int)setting >> 28) & 0xf) != (byte)XuserDataType.Unicode)
            {
                throw new XboxComCodeErrorException(
                    "AddStringSetting was called with a setting ID that does not indicate a Unicode type. Type value for setting " + setting + " is " + (((int)setting >> 28) & 0xf) + ".");
            }

            Encoding unicode = Encoding.Unicode;

            int byteCount = unicode.GetByteCount(value);

            byte[] byteValue = new byte[byteCount + 2];
            unicode.GetBytes(value, 0, value.Length, byteValue, 0);
            byteValue[byteCount] = 0;
            byteValue[byteCount + 1] = 0;

            xonline.common.protocol.UserSetting newSetting = new xonline.common.protocol.UserSetting(UserId, Source, (uint)setting, byteValue);
            settings.Add(newSetting);
        }

        public void AddFloatSetting(StatsProfileSetting setting, float value)
        {
            if ((((int)setting >> 28) & 0xf) != (byte)XuserDataType.Float)
            {
                throw new XboxComCodeErrorException(
                    "AddFloatSetting was called with a setting ID that does not indicate a Float type. Type value for setting " + setting + " is " + (((int)setting >> 28) & 0xf) + ".");
            }

            byte[] byteValue = BitConverter.GetBytes(value);
            xonline.common.protocol.UserSetting newSetting = new xonline.common.protocol.UserSetting(UserId, Source, (uint)setting, byteValue);
            settings.Add(newSetting);
        }

        public xonline.common.protocol.UserSetting[] ToUserSettingArray()
        {
            xonline.common.protocol.UserSetting[] settingsArray = new xonline.common.protocol.UserSetting[settings.Count];

            settings.CopyTo(settingsArray);

            return settingsArray;
        }
    }

    public class Titles : System.MarshalByRefObject
    {
        public string GetLocalizedGameTitle(uint uiTitleId, ushort locale)
        {
            string szTitle;
            ushort languageId = (ushort) Locale.CountryCodeFromv1LanguageId(locale);
            string key = "LocTitle:" + uiTitleId.ToString() + ":" + languageId.ToString();

            szTitle = (string)HttpContext.Current.Cache[key];

            if (szTitle == null)
            {
                DateTime cacheTTL;
                StringSvrAccess sa = new StringSvrAccess();

                try
                {
                    szTitle = sa.LookupString(uiTitleId, 0, languageId, out cacheTTL);

                    if (szTitle == null)
                    {
                        throw new Exception("String server returned a null string for title 0x" + uiTitleId.ToString("X8") + ".");
                    }
                }
                catch
                {
                    try
                    {
                        szTitle = sa.LookupString(xonline.common.service.XOn.DASH_TITLE_ID, 0, languageId, out cacheTTL);
                    }
                    catch
                    {
                        szTitle = "";

                        cacheTTL = DateTime.Now.AddSeconds(1800);
                    }
                }

                HttpContext.Current.Cache.Insert(key, szTitle, null, cacheTTL, Cache.NoSlidingExpiration);
            }

            return szTitle;
        }

        public static string GetLocalizedTitle(uint uiTitleId, ushort locale)
        {
            Titles t = new Titles();
            return t.GetLocalizedGameTitle(uiTitleId, locale);
        }

        public TitleType GetTitleType(uint titleId)
        {
            if ((titleId >= 0xFFED0000) && (titleId <= 0xFFFFFFFF))
            {
                return TitleType.Utility;
            }

            if ((titleId & 0xFF00) == 0x0700)
            {
                return TitleType.Xbox360;
            }

            if ((titleId & 0xFF00) == 0x8700)
            {
                return TitleType.Xbox360Demo;
            }

            return TitleType.Xbox1;
        }
    }

    public class CRC32 : System.Security.Cryptography.HashAlgorithm
    {
        protected static uint AllOnes = 0xffffffff;
        protected static Hashtable cachedCRC32Tables;
        protected static bool autoCache;

        protected uint[] crc32Table;
        private uint m_crc;

        /// <summary>
        /// Returns the default polynomial (used in WinZip, Ethernet, etc)
        /// </summary>
        public static uint DefaultPolynomial
        {
            get { return 0x04C11DB7; }
        }

        /// <summary>
        /// Gets or sets the auto-cache setting of this class.
        /// </summary>
        public static bool AutoCache
        {
            get { return autoCache; }
            set { autoCache = value; }
        }

        /// <summary>
        /// Initialize the cache
        /// </summary>
        static CRC32()
        {
            cachedCRC32Tables = Hashtable.Synchronized(new Hashtable());
            autoCache = true;
        }

        public static void ClearCache()
        {
            cachedCRC32Tables.Clear();
        }


        /// <summary>
        /// Builds a crc32 table given a polynomial
        /// </summary>
        /// <param name="ulPolynomial"></param>
        /// <returns></returns>
        protected static uint[] BuildCRC32Table(uint ulPolynomial)
        {
            uint dwCrc;
            uint[] table = new uint[256];

            // 256 values representing ASCII character codes. 
            for (int i = 0; i < 256; i++)
            {
                dwCrc = (uint)i;
                for (int j = 8; j > 0; j--)
                {
                    if ((dwCrc & 1) == 1)
                        dwCrc = (dwCrc >> 1) ^ ulPolynomial;
                    else
                        dwCrc >>= 1;
                }
                table[i] = dwCrc;
            }

            return table;
        }


        /// <summary>
        /// Creates a CRC32 object using the DefaultPolynomial
        /// </summary>
        public CRC32()
            : this(DefaultPolynomial)
        {
        }

        /// <summary>
        /// Creates a CRC32 object using the specified Creates a CRC32 object 
        /// </summary>
        public CRC32(uint aPolynomial)
            : this(aPolynomial, CRC32.AutoCache)
        {
        }

        /// <summary>
        /// Construct the 
        /// </summary>
        public CRC32(uint aPolynomial, bool cacheTable)
        {
            this.HashSizeValue = 32;

            crc32Table = (uint[])cachedCRC32Tables[aPolynomial];
            if (crc32Table == null)
            {
                crc32Table = CRC32.BuildCRC32Table(aPolynomial);
                if (cacheTable)
                {
                    lock (cachedCRC32Tables)
                    {
                        if (!cachedCRC32Tables.Contains(aPolynomial))
                        {
                            cachedCRC32Tables.Add(aPolynomial, crc32Table);
                        }
                    }
                }
            }
            Initialize();
        }

        /// <summary>
        /// Initializes an implementation of HashAlgorithm.
        /// </summary>
        public override void Initialize()
        {
            m_crc = AllOnes;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="buffer"></param>
        /// <param name="offset"></param>
        /// <param name="count"></param>
        protected override void HashCore(byte[] buffer, int offset, int count)
        {
            // Save the text in the buffer. 
            for (int i = offset; i < count; i++)
            {
                ulong tabPtr = (m_crc & 0xFF) ^ buffer[i];
                m_crc >>= 8;
                m_crc ^= crc32Table[tabPtr];
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        protected override byte[] HashFinal()
        {
            byte[] finalHash = new byte[4];
            ulong finalCRC = m_crc ^ AllOnes;

            finalHash[0] = (byte)((finalCRC >> 24) & 0xFF);
            finalHash[1] = (byte)((finalCRC >> 16) & 0xFF);
            finalHash[2] = (byte)((finalCRC >> 8) & 0xFF);
            finalHash[3] = (byte)((finalCRC >> 0) & 0xFF);

            return finalHash;
        }

        /// <summary>
        /// Computes the hash value for the specified Stream.
        /// </summary>
        new public byte[] ComputeHash(Stream inputStream)
        {
            byte[] buffer = new byte[4096];
            int bytesRead;
            while ((bytesRead = inputStream.Read(buffer, 0, 4096)) > 0)
            {
                HashCore(buffer, 0, bytesRead);
            }
            return HashFinal();
        }


        /// <summary>
        /// Overloaded. Computes the hash value for the input data.
        /// </summary>
        new public byte[] ComputeHash(byte[] buffer)
        {
            return ComputeHash(buffer, 0, buffer.Length);
        }

        /// <summary>
        /// Overloaded. Computes the hash value for the input data.
        /// </summary>
        /// <param name="buffer"></param>
        /// <param name="offset"></param>
        /// <param name="count"></param>
        /// <returns></returns>
        new public byte[] ComputeHash(byte[] buffer, int offset, int count)
        {
            HashCore(buffer, offset, count);
            return HashFinal();
        }
    }

    public class CRC32WireData : xonline.common.service.reflection.WireData
    {
        public virtual bool FromBytes(byte[] buf)
        {
            MemoryStream stream = new MemoryStream(buf);
            BinaryReader reader = new BinaryReader(stream);
            CRC32 crc = new CRC32();

            try
            {
                base.ReadStream(reader);
            }
            catch (xonline.common.service.XRLException ex)
            {
                throw new Exception("Error reading signed data.", ex);
            }

            int posHashStart = (int)stream.Position;
            byte[] hash = crc.ComputeHash(buf, 0, posHashStart);

            if (hash.Length != buf.Length - posHashStart)
            {
                throw new Exception(
                    String.Format("CRC32 not verified: req is {0}, expected {1}.",
                    BytesToHexString(buf, posHashStart),
                    BytesToHexString(hash)));
            }

            for (int i = 0; i < hash.Length; i++)
            {
                if (hash[i] != buf[posHashStart + i])
                {
                    throw new Exception(
                        String.Format("CRC32 not verified: req is {0}, expected {1}.",
                        BytesToHexString(buf, posHashStart),
                        BytesToHexString(hash)));
                }
            }

            return true;
        }

        public virtual byte[] ToBytes()
        {
            MemoryStream stream = new MemoryStream();
            BinaryWriter writer = new BinaryWriter(stream);

            base.WriteStream(writer);
            writer.Flush();

            stream.Position = 0;

            CRC32 crc = new CRC32();
            byte[] hash = crc.ComputeHash(stream);

            writer.Write(hash);
            writer.Flush();

            return stream.ToArray();

        }


        //
        // helper functions
        //

        private static string BytesToHexString(byte[] bytes, int start, int len)
        {
            string hexDigit = "0123456789ABCDEF";

            StringBuilder sb = new StringBuilder(3 * len);
            for (int i = 0; i < len; i++)
            {
                int b = (bytes[start + i]);
                sb.Append(hexDigit[b / 16]);
                sb.Append(hexDigit[b % 16]);
                sb.Append(' ');
            }
            return sb.ToString();
        }

        private static string BytesToHexString(byte[] bytes, int start)
        {
            return BytesToHexString(bytes, start, bytes.Length - start);
        }

        private static string BytesToHexString(byte[] bytes)
        {
            return BytesToHexString(bytes, 0);
        }
    }

    public class FallbackTiles
    {
        private static byte[][] tileData = null;

        private static void InitializeTileData()
        {
            string[] fileNames = Enum.GetNames(typeof(FallbackTileType));

            byte[][] newTileData = new byte[fileNames.Length][];

            for (int i = 0; i < fileNames.Length; i++)
            {
                FileStream stream;

                // TODO: Ideally we should not have to rely on their being a HttpContext. However, I can't think of a 
                // better way to locate the files. Embedding the files as resources into the assembly may be a better
                // way to go, but the semantics for embedding the files at build time are not clear to me.
                try
                {
                    stream = new FileStream(HttpContext.Current.Server.MapPath("/xweb/lib/images/" + fileNames[i] + ".jpg"), FileMode.Open, FileAccess.Read);
                }
                catch
                {
                    throw;
                }

                using (stream)
                {
                    BinaryReader reader = new BinaryReader(stream);

                    using (reader)
                    {
                        newTileData[i] = reader.ReadBytes((int)stream.Length);
                    }
                }
            }

            tileData = newTileData;
        }

        public static Bitmap CreateBitmap(FallbackTileType fallbackTile)
        {
            if (tileData == null)
            {
                InitializeTileData();
            }

            Bitmap bmpCopy = null;
            MemoryStream stream = new MemoryStream(tileData[(int)fallbackTile], false);

            using (stream)
            {
                // A bitmap object created from a stream will hold onto the stream for the liftime of the bitmap.
                // To allow us to return a bitmap without a dangling stream, we need to copy our stream based bitmap
                // into a freshly created one.

                Bitmap streamBM = new Bitmap(stream);

                try
                {
                    bmpCopy = new Bitmap(streamBM.Width, streamBM.Height, PixelFormat.Format32bppArgb);
                    bmpCopy.SetResolution(72f, 72f);

                    Graphics g = Graphics.FromImage(bmpCopy);
                    using (g)
                    {
                        g.PageUnit = GraphicsUnit.Pixel;

                        // Transfer the Image to the Bitmap
                        g.DrawImage(streamBM, 0, 0);
                    }
                }
                catch
                {
                    if (bmpCopy != null)
                    {
                        bmpCopy.Dispose();
                    }

                    throw;
                }
                finally
                {
                    streamBM.Dispose();
                }
            }

            return bmpCopy;
        }
    }

    public class TileSpecifier
    {

        private class TileSpecifierData : CRC32WireData
        {

            public TileSpecifierData()
            {
                wStoragePathSize = 0;
                sStoragePath = "";
                wDimensions = 0;
                bFallbackTile = (byte)FallbackTileType.QuestionMark64x64;
                bBackgroundColorRed = 0;
                bBackgroundColorGreen = 0;
                bBackgroundColorBlue = 0;
            }

            public ushort wStoragePathSize;

            [xonline.common.service.reflection.WireInfo(SizeParam = "wStoragePathSize")]
            public string sStoragePath;

            public ushort wDimensions;

            public byte bFallbackTile;

            public byte bFlags;

            public byte bBackgroundColorRed;
            public byte bBackgroundColorGreen;
            public byte bBackgroundColorBlue;
        }

        private TileSpecifierData _tileData = new TileSpecifierData();

        //
        // constructors
        //

        public TileSpecifier()
        {
        }

        public TileSpecifier(string urlPath)
        {
            UrlPath = urlPath;
        }

        public TileSpecifier(string storagePath, ushort dimensions)
        {
            StoragePath = storagePath;
            Dimensions = dimensions;
        }

        public bool Dimmed
        {
            get
            {
                return (_tileData.bFlags & 0x01) != 0;
            }
            set
            {
                if (value)
                {
                    _tileData.bFlags |= 0x01;
                }
                else
                {
                    _tileData.bFlags &= 0xFE;
                }
            }
        }

        public bool UseFallbackTile
        {
            get
            {
                return (_tileData.bFlags & 0x02) != 0;
            }
            set
            {
                if (value)
                {
                    _tileData.bFlags |= 0x02;
                }
                else
                {
                    _tileData.bFlags &= 0xFD;
                }
            }
        }

        public string UrlPath
        {
            get
            {
                byte[] blob = _tileData.ToBytes();

                // twidle with the first half of the data to give it a bit more random of a distribution.
                // we're using the first few bytes to create some directories in the path. If we dont do
                // anything, these tend to be very uniform, so it defeats the plan to spread the generated
                // files across multiple physical directories.
                int half = blob.Length / 2 - 1;
                int endOffset = blob.Length - 1;

                for (int i = 0; i < half; i++)
                {
                    blob[i] ^= blob[endOffset - i];
                }

                string rawPath = Convert.ToBase64String(blob);
                // forward slashes look like part of the URL, so swap them out with -
                rawPath = rawPath.Replace("/", "-");

                if (rawPath.Length < 5)
                {
                    throw new InvalidOperationException("Path with signed data should always be > 5, but was not");
                }

                StringBuilder fullPath = new StringBuilder(rawPath.Length + 3);

                fullPath.Append("/");
                fullPath.Append(rawPath.Substring(0, 2));
                fullPath.Append("/");
                fullPath.Append(rawPath.Substring(2, 2));
                fullPath.Append("/");
                fullPath.Append(rawPath.Substring(4));
                fullPath.Append(".jpg");

                return fullPath.ToString();
            }
            set
            {
                if (!DoesUrlMatchTilePattern(value))
                {
                    if (value == null)
                    {
                        throw new ArgumentNullException("value");
                    }
                    else
                    {
                        throw new ArgumentException("UrlPath must be at least 12 characters long, and follow the pattern /XX/XX/XX...X.jpg Passed value was " + value, "value");
                    }
                }

                StringBuilder rawPath = new StringBuilder(value.Length);

                int trimSize = value.Length - (4 + 7); //extension length plus initial offset
                rawPath.Append(value.Substring(1, 2));
                rawPath.Append(value.Substring(4, 2));
                rawPath.Append(value.Substring(7, trimSize));

                // convert back the / we removed in the get
                rawPath = rawPath.Replace('-', '/');
                byte[] blob = Convert.FromBase64String(rawPath.ToString());

                // undo the twidling we do in the get
                int half = blob.Length / 2 - 1;
                int endOffset = blob.Length - 1;

                for (int i = 0; i < half; i++)
                {
                    blob[i] ^= blob[endOffset - i];
                }

                _tileData.FromBytes(blob);
            }
        }

        public static bool DoesUrlMatchTilePattern(string urlPath)
        {
            if (urlPath == null)
            {
                return false;
            }

            if ((urlPath.Length < 13) || (urlPath[0] != '/') || (urlPath[3] != '/') || (urlPath[6] != '/') || !urlPath.EndsWith(".jpg"))
            {
                return false;
            }

            return true;
        }

        public string StoragePath
        {
            get
            {
                return _tileData.sStoragePath;
            }
            set
            {
                if (value == null)
                {
                    throw new ArgumentNullException("value");
                }

                _tileData.wStoragePathSize = (ushort)value.Length;
                _tileData.sStoragePath = value;
            }
        }

        public ushort Dimensions
        {
            get { return _tileData.wDimensions; }
            set { _tileData.wDimensions = value; }
        }

        public FallbackTileType FallbackTile
        {
            get { return ((FallbackTileType)_tileData.bFallbackTile); }
            set { _tileData.bFallbackTile = (byte)value; }
        }

        public System.Drawing.Color BackgroundColor
        {
            get
            {
                return System.Drawing.Color.FromArgb(
                    _tileData.bBackgroundColorRed,
                    _tileData.bBackgroundColorGreen,
                    _tileData.bBackgroundColorBlue
                    );
            }

            set
            {
                _tileData.bBackgroundColorRed = value.R;
                _tileData.bBackgroundColorGreen = value.G;
                _tileData.bBackgroundColorBlue = value.B;
            }
        }
    }

    public class StringSvrAccess : System.MarshalByRefObject
    {

        public string LookupString(uint titleId, uint stringId, ushort liveLanguageId, out DateTime responseTTL)
        {
            xonline.common.protocol.StringLookupRequest stringReq = new xonline.common.protocol.StringLookupRequest();

            stringReq.dwTitleID = titleId;
            stringReq.wLanguage = liveLanguageId;
            stringReq.rgdwStringIDs = new uint[] { stringId };

            LivecacheRequest lcReq = new LivecacheRequest(
                0,
                LcserviceId.StringLookup,
                stringReq,
                null,
                null);

            HResult hr = lcReq.Send();

            if (HResult.Failed(hr))
            {
                throw new LivecacheResponseException(lcReq);
            }

            responseTTL = lcReq.ResponseExpiry;

            xonline.common.protocol.StringLookupResponse stringResp = new xonline.common.protocol.StringLookupResponse();
            stringResp.SetBytes(lcReq.ResponseData);

            if (stringResp.wNumStrings != 1)
            {
                return "";
            }

            return stringResp.rgStringData[0].szString;
        }
    }

    [Serializable]
    public class GamerProfile
    {
        private string gamerTag;
        private string motto;
        private string tou;

        public GamerProfile()
        {
        }

        public GamerProfile(string gamertag, ulong livepuid)
        {
            this.GamerTag = gamertag;
            this.Livepuid = livepuid;
        }

        public GamerProfile(ulong livepuid)
        {
            this.livepuid = livepuid;
            gamerTag = XCache.LookupGamerTag(livepuid);
        }

        /// <summary>
        /// 
        /// </summary>
        public ulong Livepuid
        {
            get { return livepuid; }
            set { livepuid = value; }
        }
        private ulong livepuid;


        public string GamerTag
        {
            get
            {
                if (gamerTag == null)
                {
                    return XCache.InvalidGamertag;
                }

                return gamerTag;
            }
            set
            {
                gamerTag = (value == null) ? XCache.InvalidGamertag : value;
                if (gamerTag.Length > XOn.XONLINE_NAME_MAX_SIZE)
                {
                    gamerTag = gamerTag.Substring(0, (int)XOn.XONLINE_NAME_MAX_SIZE);
                }
            }
        }

        public GamercardZones Zone
        {
            get
            {
                return zone;
            }
            set
            {
                zone = value;

            }
        }
        private GamercardZones zone = GamercardZones.Unknown;

        /// <summary>
        /// Gets or sets the gamer tile location information.
        /// </summary>
        /// <remarks>
        /// This property is null if it has not been loaded or the information is unavailable 
        /// (e.g. permission denied when fetching from stats profile service).
        /// This value is a 24 character string in the form of "XXXXXXXXYYYYYYYYZZZZZZZZ", 
        /// with X as the title id for the image, Y as the normal 64x64 image id, and Z as the 32x32 image id.
        /// The storage path for a tile is //global/t:[title id]/tile/0/[image id].
        /// </remarks>
        public string GamerTile
        {
            get
            {
                if ((gamerTile == null) || (gamerTile.Length == 0))
                {
                    if (Zone == GamercardZones.None)
                    {
                        // This is an xbox1 user - return the xbox1 gamer picture
                        return "FFFE07D10002000000010000";
                    }
                }
                return gamerTile;
            }
            set { gamerTile = value; }
        }
        private string gamerTile;

        /// <summary>
        /// Gets the URL for the location of the gamer picture on tile server.
        /// </summary>
        /// <remarks>
        /// Returns the empty string if the GamerTile property is null.
        /// </remarks>
        public string GamerTileUrl
        {
            get
            {
                if (gamerTileUrl.Length == 0)
                {
                    gamerTileUrl = GetGamerTileUrl(GamerTile, true);
                }
                return gamerTileUrl;
            }
            set
            {
                gamerTileUrl = value;
            }
        }
        private string gamerTileUrl = "";
        /// <summary>
        /// Gets the URL for the location of the gamer picture on tile server.
        /// </summary>
        /// <remarks>
        /// Returns the empty string if the GamerTile property is null.
        /// </remarks>
        public string SmallGamerTileUrl
        {
            get
            {
                if (smallGamerTileUrl.Length == 0)
                {
                    smallGamerTileUrl = GetGamerTileUrl(GamerTile, false);
                }
                return smallGamerTileUrl;
            }
            set
            {
                smallGamerTileUrl = value;
            }
        }
        private string smallGamerTileUrl = "";

        public string GetGamerTileUrl(string profileTileId, bool bigTile)
        {
            if ((profileTileId == null) || (profileTileId.Length < 24))
            {
                if (bigTile)
                {
                    return "/xweb/lib/images/QuestionMark64x64.jpg";
                }
                else
                {
                    return "/xweb/lib/images/QuestionMark32x32.jpg";
                }
            }

            uint titleId;
            uint tileId;

            try
            {
                titleId = Convert.ToUInt32(profileTileId.Substring(0, 8), 16);

                if (bigTile)
                {
                    tileId = Convert.ToUInt32(profileTileId.Substring(8, 8), 16);
                }
                else
                {
                    tileId = Convert.ToUInt32(profileTileId.Substring(16, 8), 16);
                }
            }
            catch (FormatException)
            {
                if (bigTile)
                {
                    return "/xweb/lib/images/QuestionMark64x64.jpg";
                }
                else
                {
                    return "/xweb/lib/images/QuestionMark32x32.jpg";
                }
            }

            string storagePath = string.Format("//global/t:{0:x}/tile/0/{1:x}", titleId, tileId);

            TileSpecifier specifier = new TileSpecifier(storagePath, 0);

            if (bigTile)
            {
                specifier.FallbackTile = FallbackTileType.QuestionMark64x64;
            }
            else
            {
                specifier.FallbackTile = FallbackTileType.QuestionMark32x32;
            }

            return /*Config.GetSetting("xboxcom_siteDomainName") +*/ "/tiles" + specifier.UrlPath;
        }

        public string Motto
        {
            get
            {
                return motto;
            }
            set
            {
                /*
                List<int> invalidGlyphPositions = GlyphValidator.Instance.Validate(value);

                if (invalidGlyphPositions.Count > 0)
                {
                    throw new InvalidXboxConsoleGlyphsException(
                        value,
                        invalidGlyphPositions,
                        "Invalid characters detected trying to set GamerProfile motto field.");
                }
                 */

                motto = value;
            }
        }

        public string HtmlMotto
        {
            get { return HttpUtility.HtmlEncode(Motto); }
        }

        public string TOU
        {
            get
            {
                return tou;
            }
            set
            {
                tou = value;

            }
        }

        /// <summary>
        /// Gets the gamerscore for the current user
        /// </summary>
        /// <remarks>
        /// This field is set to int.MinValue as its default value and if permission is denied when trying to fetch it.
        /// </remarks>
        public int GamerScore
        {
            get { return gamerScore; }
            set { gamerScore = value; }
        }
        private int gamerScore = int.MinValue;

        /// <summary>
        /// Gets the gamer's reputation score.
        /// </summary>
        /// <remarks>
        /// This field is set to float.Nan as its default value and if permission is denied when trying to fetch it.</remarks>
        public float Reputation
        {
            get { return reputation; }
            set { reputation = value; }
        }
        private float reputation = float.NaN;

        /// <summary>
        /// Gets the bucket that this user's reputation falls into.
        /// </summary>
        /// <remarks>
        /// User's reputation scores can be divided into 21 buckets which indicate 5% increments of
        /// their overall reputation. This is used to translate the real reputation score into a graphical
        /// indicator of the reputation.
        /// Bucket 0 will be returned if the reputation is &lt;= 0 or if it as undefined (NaN value).
        /// Reputations greater than 0 will be divided into 5% groupings, with bucket 20 also getting any
        /// reputation values &gt; 100 (which should not happen).
        /// </remarks>
        public int ReputationBucket
        {
            get
            {
                if ((float.IsNaN(Reputation)) || (Reputation <= 0))
                {
                    return 0;
                }

                if (Reputation >= 100)
                {
                    return 20;
                }

                int roundedReputation = Convert.ToInt32(Reputation);
                return Convert.ToInt32(Math.Ceiling(roundedReputation / 5.0f));
            }
        }

        /// <summary>
        /// Gets the Gamer's country ID
        /// </summary>
        /// <remarks>
        /// This field is set to int.MinValue as its default value and if permission is denied when trying to fetch it.
        /// </remarks>
        public int Country
        {
            get { return country; }
            set { country = value; }
        }
        private int country = int.MinValue;

        /// <summary>
        /// 
        /// </summary>
        public GamerTiers Tier
        {
            get { return tier; }
            set { tier = value; }
        }
        private GamerTiers tier = GamerTiers.Unknown;

        /// <summary>
        /// 
        /// </summary>
        public int Type
        {
            get { return type; }
            set { type = value; }
        }
        private int type = int.MinValue;

        /// <summary>
        /// 
        /// </summary>
        public DateTime DataGoodUntil
        {
            get { return dataGoodUntil; }
            set { dataGoodUntil = value; }
        }
        private DateTime dataGoodUntil = DateTime.MinValue;


        //XPROFILE_PERMISSION_SHARE_ACTIVITY_NOONE = 0x01;
        //XPROFILE_PERMISSION_SHARE_ACTIVITY_FRIENDS = 0x02;
        //XPROFILE_PERMISSION_SHARE_UCC_NOONE = 0x04;
        //XPROFILE_PERMISSION_SHARE_UCC_FRIENDS = 0x08;
        private int profilePermissions = int.MinValue;
        public int ProfilePermissions
        {
            get { return profilePermissions; }
            set { profilePermissions = value; }
        }

        public PrivilegeValue ProfileActivityPermission
        {
            get
            {
                if (profilePermissions == int.MinValue)
                {
                    throw new XboxComCodeErrorException("ProfilePermissions is invalid");
                }
                return (0 == ((profilePermissions & XOn.XPROFILE_PERMISSION_SHARE_ACTIVITY_NOONE) | (profilePermissions & XOn.XPROFILE_PERMISSION_SHARE_ACTIVITY_FRIENDS))) ?
                    PrivilegeValue.Allow : (0 != (profilePermissions & XOn.XPROFILE_PERMISSION_SHARE_ACTIVITY_FRIENDS)) ?
                    PrivilegeValue.FriendsOnly : PrivilegeValue.Deny;
            }
        }

        public PrivilegeValue ProfileUserCreatedContentPermission
        {
            get
            {
                if (profilePermissions == int.MinValue)
                {
                    throw new XboxComCodeErrorException("ProfilePermissions is invalid");
                }

                return (0 == ((profilePermissions & XOn.XPROFILE_PERMISSION_SHARE_UCC_NOONE) | (profilePermissions & XOn.XPROFILE_PERMISSION_SHARE_UCC_FRIENDS))) ?
                    PrivilegeValue.Allow : (0 != (profilePermissions & XOn.XPROFILE_PERMISSION_SHARE_UCC_FRIENDS)) ?
                    PrivilegeValue.FriendsOnly : PrivilegeValue.Deny;
            }
        }

        public void GetGamerProfile()
        {
            SettingsDataAccess setDataAccess = new SettingsDataAccess();
            setDataAccess.LoadSettings(Livepuid, this);
        }
    }

    public class RecentPlayerCollectionBuilder
    {
        private ulong callerLivepuid = 0;
        private PresenceDataAccess presenceDA;
        private SettingsDataAccess settingsDA;
        private Titles title;
        private ushort maxCount;

        public RecentPlayerCollectionBuilder(ulong callingLivepuid, ushort numRequest)
            : this(callingLivepuid,
                                                                            new PresenceDataAccess(),
                                                                            new SettingsDataAccess(),
                                                                            new Titles(),
                                                                            numRequest)
        { }

        public RecentPlayerCollectionBuilder(ulong callingLivepuid, PresenceDataAccess IPresenceDA, SettingsDataAccess ISettingsDA, Titles titles, ushort maxcount)
        {
            callerLivepuid = callingLivepuid;
            presenceDA = IPresenceDA;
            settingsDA = ISettingsDA;
            title = titles;
            maxCount = maxcount;
            if (maxCount > 100) maxCount = 100;
        }

        private static uint[] RecentPlayerSettingTypes
        {
            get
            {
                if (recentPlayerSettingTypes == null)
                {
                    recentPlayerSettingTypes = new uint[4];
                    recentPlayerSettingTypes[0] = Convert.ToUInt32(StatsProfileSetting.GamercardTile);
                    recentPlayerSettingTypes[1] = Convert.ToUInt32(StatsProfileSetting.GamercardRep);
                    recentPlayerSettingTypes[2] = Convert.ToUInt32(StatsProfileSetting.GamercardCred);
                    recentPlayerSettingTypes[3] = Convert.ToUInt32(StatsProfileSetting.GamercardZone);
                }

                return recentPlayerSettingTypes;
            }
        }
        private static uint[] recentPlayerSettingTypes;


        public RecentPlayerCollection CreateRecentPlayerCollection(ushort locale)
        {
            RecentPlayerCollection list = new RecentPlayerCollection();

            //get query affiliates data
            QueryAffiliatesReplyData[] affiliates = presenceDA.GetQueryAffiliatesReplyData(callerLivepuid, maxCount);

            if (affiliates.Length == 0)
            {
                return list;
            }

            //get target live puids for retrieving gamer settings
            //filtering out friends
            int recentplayerCount = 0;
            for (int i = 0; i < affiliates.Length; i++)
            {
                if ((affiliates[i].dwListFlags & GetAffiliateListFlag(AffiliateFlag.Friend)) == 0)
                {
                    recentplayerCount++;
                }
            }

            if (recentplayerCount == 0)
            {
                return list;
            }

            ulong[] targetLivepuids = new ulong[recentplayerCount];
            int index = 0;
            for (int i = 0; i < affiliates.Length; i++)
            {
                if ((affiliates[i].dwListFlags & GetAffiliateListFlag(AffiliateFlag.Friend)) == 0)
                {
                    targetLivepuids[index] = affiliates[i].qwAffiliateID;
                    index++;
                }
            }

            //get gamer settings
            //currently the QueryAffiliates API call returns gamertag based on the request port
            //for console port, the call will lookup gamertag and return valid gamertag
            //for datacenter port, the call will NOT lookup gamertag and return empty string
            //therefore we need to lookup gamertag ourselves.
            Hashtable settings = settingsDA.GetGamerProfileCollectionBySetting(callerLivepuid, targetLivepuids, RecentPlayerSettingTypes, true);

            //set recentplayer object and populate recentplayercollection
            for (int i = 0; i < affiliates.Length; i++)
            {
                ulong livepuid = affiliates[i].qwAffiliateID;
                if (!settings.ContainsKey(livepuid))
                {
                    //can't find gamer information, skip it
                    continue;
                }
                GamerProfile profile = (GamerProfile)settings[livepuid];
                RecentPlayer rp = new RecentPlayer();
                rp.UserLivepuid = livepuid;
                rp.GamerTileUrl = profile.SmallGamerTileUrl;
                rp.Gamertag = profile.GamerTag;
                rp.ReputationBucket = profile.ReputationBucket;
                rp.GamerScore = profile.GamerScore;
                rp.GamerZone = profile.Zone;
                rp.GameTitleName = title.GetLocalizedGameTitle(affiliates[i].dwTitleID, locale);
                rp.GameTitleTileUrl = SmallTitleTileUrl(affiliates[i].dwTitleID);
                rp.LastMetDate = GetLastMetDate(affiliates[i].mtDateUpdated);

                list.Add(rp);
            }
            return list;
        }

        public string SmallTitleTileUrl(uint uiTitleId)
        {
            StringBuilder storagePath = new StringBuilder(40);

            storagePath.Append("//global/t:");
            storagePath.Append(uiTitleId.ToString("X"));
            storagePath.Append("/icon/0/8000");

            TileSpecifier specifier = new TileSpecifier(storagePath.ToString(), 32);
            specifier.FallbackTile = FallbackTileType.QuestionMark32x32;

            return /* Config.GetSetting("xboxcom_siteDomainName") +*/ "/tiles" + specifier.UrlPath;
        }


        /*
        // Copied from PresDefs -- not a public class, so can't use them directly
        // PresDefs will be public class in next service release
        // Affiliate flags
        public const uint X_AFFILIATE_ENCOUNTERED_INDEX         = 0;
        public const uint X_AFFILIATE_COMPLETED_GAME_INDEX      = 1;
        public const uint X_AFFILIATE_POSITIVE_FEEDBACK_INDEX   = 2;
        public const uint X_AFFILIATE_NEGATIVE_FEEDBACK_INDEX   = 3;
        public const uint X_AFFILIATE_AVOIDING_ME_INDEX         = 4;
        public const uint X_AFFILIATE_FRIEND_INDEX              = 16;
        public const uint X_AFFILIATE_BLOCK_INDEX               = 17;
        public const uint X_AFFILIATE_MUTE_INDEX                = 18;
        */
        public static uint GetAffiliateListFlag(AffiliateFlag flag)
        {
            int index = 0;
            switch (flag)
            {
                case AffiliateFlag.Encountered:
                    index = 0;
                    //index = (int)PresDefs.X_AFFILIATE_ENCOUNTERED_INDEX;
                    break;
                case AffiliateFlag.Completed:
                    index = 1;
                    //index = (int)PresDefs.X_AFFILIATE_COMPLETED_GAME_INDEX;
                    break;
                case AffiliateFlag.Positive:
                    index = 2;
                    //index = (int)PresDefs.X_AFFILIATE_POSITIVE_FEEDBACK_INDEX;
                    break;
                case AffiliateFlag.Negative:
                    index = 3;
                    //index = (int)PresDefs.X_AFFILIATE_NEGATIVE_FEEDBACK_INDEX;
                    break;
                case AffiliateFlag.Avoiding:
                    index = 4;
                    //index = (int)PresDefs.X_AFFILIATE_AVOIDING_ME_INDEX;
                    break;
                case AffiliateFlag.Friend:
                    index = 16;
                    //index = (int)PresDefs.X_AFFILIATE_FRIEND_INDEX;
                    break;
                case AffiliateFlag.Block:
                    index = 17;
                    //index = (int)PresDefs.X_AFFILIATE_BLOCK_INDEX;
                    break;
                case AffiliateFlag.Mute:
                    index = 18;
                    //index = (int)PresDefs.X_AFFILIATE_MUTE_INDEX;
                    break;
            }
            return (uint)(1 << index);
        }


        //        private RecentPlayerStatus SetRecentPlayerStatus(uint affiliateFlags)
        //        {
        //            RecentPlayerStatus status = RecentPlayerStatus.Neutral;
        //            if((GetAffiliateListFlag(AffiliateFlag.Negative) & affiliateFlags) > 0)
        //            {
        //                status = RecentPlayerStatus.Avoided;
        //            }
        //            else if((GetAffiliateListFlag(AffiliateFlag.Positive) & affiliateFlags) > 0)
        //            {
        //                status = RecentPlayerStatus.Preferred;
        //            }
        //            return status;
        //        }

        private DateTime GetLastMetDate(uint dataUpdated)
        {
            return MsgDefs.MsgTimeToDateTime(dataUpdated);
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Presence\Test\FuncInvalidUserID.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Presence;

namespace PresWidgetTest
{
	public class FuncInvalidUserID : TestNode
	{
		[TestCase, Description( "Invalid FDMsg UserID 1: Zero" )]
		class Zero : TestBase
		{
			override protected void Execute()
			{
				PNXbox xbox = new PNXbox();
				PNUser user = new PNUser( "NullPuid", 0 );
				user.Connect( xbox );

				PNMsg replyMsg;
				PMsgWebFriends webFriendsMsg = new PMsgWebFriends( user );

				try
				{
                    webFriendsMsg.TransactFD(out replyMsg);
				}
				catch( XErrException e )
				{
					if( e.XErr != HResult.E_INVALIDARG )
						throw new UnexpectedTestResultException( "Expected X-Err: 0x"+HResult.E_INVALIDARG.ToString("X8"), e ); 
				}
				
				ResultCode=TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description( "Invalid FDMsg UserID 2: Does Not Exist" )]
		class DoesNotExist : TestBase
		{
			override protected void Execute()
			{
				PNXbox xbox = new PNXbox();
				PNUser user = new PNUser( "BadPuid", 1 );
				user.Connect( xbox );

				PNMsg replyMsg;
				PMsgWebFriends webFriendsMsg = new PMsgWebFriends( user );

				try
				{
                    webFriendsMsg.TransactFD(out replyMsg);
				}
				catch( XErrException e )
				{
					if( e.XErr != HResult.XONLINE_E_USER_NOT_PRESENT )
						throw new UnexpectedTestResultException( "Expected X-Err: 0x"+HResult.XONLINE_E_USER_NOT_PRESENT.ToString("X8"), e ); 
				}

				ResultCode=TEST_RESULTS.PASSED;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Presence\Test\FuncInvalidGamerTag.cs ===
using System;
using System.Net;
using System.Web.Services.Protocols;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace PresWidgetTest
{
	public class FuncInvalidGamerTag : TestNode
	{
		public static void TryBadGamerTag( string name, string error )
		{
			try
			{
				uint vSec;
				PWT.WcPN.GetFriends( PWT.GoodLink.WebId, name, out vSec ); 
			}
			catch( SoapException e )
			{
				if( e.Message != error )
					throw e;
			}
			catch( WebException w )
			{
				if( w.Message != error )
					throw w;
			}
		}

		[TestCase, Description( "Invalid Soap Gamertag 1: Empty" )]
		class Empty : TestBase
		{
			override protected void Execute()
			{
				string empty = "";
				TryBadGamerTag( 
					empty, 
					"Server was unable to process request. ---> "+
					"(webID,GamerTag) pair ("+
					Hexer.tohex( PWT.GoodLink.WebId, true )+
					","+
					") is not linked in our system" );
				ResultCode=TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description( "Invalid Soap Gamertag 2: Null" )]
		class Null : TestBase
		{
			override protected void Execute()
			{
				TryBadGamerTag( 
					null, 
					"Server was unable to process request. ---> "+
					"Bad GamerTag provided, null not allowed" );
				ResultCode=TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description( "Invalid Soap Gamertag 3: Too long" )]
		class TooLong : TestBase
		{
			override protected void Execute()
			{
				string toLong = PWT.Friends.Random.GenerateRandomString( PWT.GoodLink.Name, 16 );
				TryBadGamerTag( 
					toLong, 
					"Server was unable to process request. ---> The web service encountered an internal error." );
				ResultCode=TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description( "Invalid Soap Gamertag 4: Way too long" )]
		class WayTooLong : TestBase
		{
			override protected void Execute()
			{
				string wayToLong = PWT.Friends.Random.GenerateRandomString( PWT.GoodLink.Name, 50000 );
				TryBadGamerTag( 
					wayToLong, 
					"Server was unable to process request. ---> The web service encountered an internal error." );
				ResultCode=TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description( "Invalid Soap Gamertag 5: User doesn't exist" )]
		class DoeNotExist : TestBase
		{
			override protected void Execute()
			{
				string invalid = PWT.Friends.Random.GenerateRandomString( 15 );
				TryBadGamerTag( 
					invalid, 
					"Server was unable to process request. ---> "+
					"(webID,GamerTag) pair ("+
					Hexer.tohex( PWT.GoodLink.WebId, true )+
					","+
					invalid+
					") is not linked in our system" );
				ResultCode=TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description( "Invalid Soap Gamertag 6: Not linked in our system" )]
		class NotLinked : TestBase
		{
			override protected void Execute()
			{
				ConsoleX.WriteLine();
				PNUser notLinked = PWT.Friends.CreateUser();
				TryBadGamerTag( 
					notLinked.Name, 
					"Server was unable to process request. ---> "+
					"(webID,GamerTag) pair ("+
					Hexer.tohex( PWT.GoodLink.WebId, true )+
					","+
					notLinked.Name+
					") is not linked in our system" );
				ResultCode=TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description( "Invalid Soap Gamertag 7: Linked to other" )]
		class LinkedToOther : TestBase
		{
			override protected void Execute()
			{
				ConsoleX.WriteLine();
				PNUser wrongLinked = PWT.Friends.CreateLinkedUser();
				TryBadGamerTag( 
					wrongLinked.Name, 
					"Server was unable to process request. ---> "+
					"(webID,GamerTag) pair ("+
					Hexer.tohex( PWT.GoodLink.WebId, true )+
					","+
					wrongLinked.Name+
					") is not linked in our system" );
				ResultCode=TEST_RESULTS.PASSED;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Presence\Test\FuncInvalidWebID.cs ===
using System;
using System.Web.Services.Protocols;
using System.Net;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace PresWidgetTest
{
	public class FuncInvalidWebID : TestNode
	{
		public static void TryBadWebId( byte[] webID, string error )
		{
			TryBadWebId( webID, PWT.GoodLink.Name, error );
		}
		public static void TryBadWebId( byte[] webID, string name, string error )
		{
			try
			{
				uint vSec;
				PWT.WcPN.GetFriends( webID, name, out vSec ); 
			}
			catch( SoapException e )
			{
				if( e.Message != error )
					throw e;
			}
			catch( WebException w )
			{
				if( w.Message != error )
					throw w;
			}
		}
		

		[TestCase, Description( "Invalid Soap WebID 1: Empty" )]
		class Empty : TestBase
		{
			override protected void Execute()
			{
				byte[] empty = new byte[0];
				TryBadWebId( 
					empty, 
					"Server was unable to process request. ---> "+
					"Bad Passport web ID, length is 0" );
				ResultCode=TEST_RESULTS.PASSED;
			}
		}


		[TestCase, Description( "Invalid Soap WebID 2: Null" )]
		class Null : TestBase
		{
			override protected void Execute()
			{
				TryBadWebId( 
					null, 
					"Server was unable to process request. ---> "+
					"Bad Passport web ID, null not allowed" );
				ResultCode=TEST_RESULTS.PASSED;
			}
		}


		[TestCase, Description( "Invalid Soap WebID 3: To short" )]
		class ToShort : TestBase
		{
			override protected void Execute()
			{
				byte[] toShort = new byte[PWT.GoodLink.WebId.Length-1];
				Array.Copy( PWT.GoodLink.WebId, toShort, toShort.Length );
				TryBadWebId( 
					toShort, 
					"Server was unable to process request. ---> "+
					"Bad Passport web ID, length is 7" );
				ResultCode=TEST_RESULTS.PASSED;
			}
		}


		[TestCase, Description( "Invalid Soap WebID 4: To long" )]
		class ToLong : TestBase
		{
			override protected void Execute()
			{
				byte[] toLong = new byte[PWT.GoodLink.WebId.Length + 1];
				Array.Copy( PWT.GoodLink.WebId, toLong, PWT.GoodLink.WebId.Length );
				TryBadWebId( 
					toLong, 
					"Server was unable to process request. ---> "+
					"Bad Passport web ID, length is 9" );
				ResultCode=TEST_RESULTS.PASSED;
			}
		}


		[TestCase, Description( "Invalid Soap WebID 5: Way too long" )]
		class WayToLong : TestBase
		{
			override protected void Execute()
			{
				byte[] wayToLong = new byte[50000];
				Array.Copy( PWT.GoodLink.WebId, wayToLong, PWT.GoodLink.WebId.Length );
				TryBadWebId( 
					wayToLong, 
					"Server was unable to process request. ---> "+
					"Bad Passport web ID, length is 50000" );
				ResultCode=TEST_RESULTS.PASSED;
			}
		}


		[TestCase, Description( "Invalid Soap WebID 6: All zeros" )]
		class AllZeros : TestBase
		{
			override protected void Execute()
			{
				byte[] allZeros = new byte[ PWT.GoodLink.WebId.Length ];
				Array.Clear( allZeros, 0, allZeros.Length );
				TryBadWebId( 
					allZeros, 
					"Server was unable to process request. ---> "+
					"(webID,GamerTag) pair ("+
					"0000000000000000"+
					","+
					PWT.GoodLink.Name+
					") is not linked in our system" );
				ResultCode=TEST_RESULTS.PASSED;
			}
		}


		[TestCase, Description( "Invalid Soap WebID 7: Doesn't exist" )]
		class DoesNotExist : TestBase
		{
			override protected void Execute()
			{
				ConsoleX.WriteLine();
				PNUser notLinked = PWT.Friends.CreateUser();
				byte[] invalid = WCUserAccount.PuidToWebID( notLinked.UserId );
				TryBadWebId( 
					invalid,
					notLinked.Name,
					"Server was unable to process request. ---> "+
					"(webID,GamerTag) pair ("+
					Hexer.tohex( invalid, true )+
					","+
					notLinked.Name+
					") is not linked in our system" );
				ResultCode=TEST_RESULTS.PASSED;
			}
		}


		[TestCase, Description( "Invalid Soap WebID 8: Linked to other" )]
		class LinkedToOther : TestBase
		{
			override protected void Execute()
			{
				ConsoleX.WriteLine();
				PNUser linked = PWT.Friends.CreateLinkedUser();
				byte[] wrongLinked = WCUserAccount.PuidToWebID( linked.UserId );
				TryBadWebId( 
					wrongLinked, 
					"Server was unable to process request. ---> "+
					"(webID,GamerTag) pair ("+
					Hexer.tohex( wrongLinked, true )+
					","+
					PWT.GoodLink.Name+
					") is not linked in our system" );
				ResultCode=TEST_RESULTS.PASSED;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Presence\Test\FuncListChangeFDMsg.cs ===
using System;
using ServerTestFramework;

namespace PresWidgetTest
{
	public class FuncListChangeFDMsg : TestNode
	{
		[TestCase, Description( "List Change FD Msg: Zero To One, Accepted, Same Hash" )]
		class ZeroToOne_Accepted_SameHash : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "List Change FD Msg: Zero To One, Accepted, Diff Hash" )]
		class ZeroToOne_Accepted_DiffHash : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "List Change FD Msg: Zero To One, Request Sent, Same Hash" )]
		class ZeroToOne_Sent_SameHash : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "List Change FD Msg: Zero To One, Request Sent, Diff Hash" )]
		class ZeroToOne_Sent_DiffHash : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "List Change FD Msg: Zero To One, Request Received, Same Hash" )]
		class ZeroToOne_Received_SameHash : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "List Change FD Msg: Zero To One, Request Received, Diff Hash" )]
		class ZeroToOne_Received_DiffHash : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "List Change FD Msg: One To Zero, Accept Deleted, Same Hash" )]
		class OneToZero_AcceptedDeleted_SameHash : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "List Change FD Msg: One To Zero, Accept Deleted, Diff Hash" )]
		class OneToZero_AcceptedDeleted_DiffHash : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "List Change FD Msg: One To Zero, Sent Deleted, Same Hash" )]
		class OneToZero_SentDeleted_SameHash : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "List Change FD Msg: One To Zero, Sent Deleted, Diff Hash" )]
		class OneToZero_SentDeleted_DiffHash : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "List Change FD Msg: One To Zero, Receive Rejected, Same Hash" )]
		class OneToZero_ReceiveRejected_SameHash : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "List Change FD Msg: One To Zero, Receive Rejected, Diff Hash" )]
		class OneToZero_ReceiveRejected_DiffHash : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "List Change FD Msg: NintyNine To Hundred, Accepted, Same Hash" )]
		class NinetyNineToHundred_Accepted_SameHash : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "List Change FD Msg: NintyNine To Hundred, Accepted, DIff Hash" )]
		class NinetyNineToHundred_Accepted_DiffHash : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "List Change FD Msg: NintyNine To Hundred, Request Sent, Same Hash" )]
		class NinetyNineToHundred_Sent_SameHash : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "List Change FD Msg: NintyNine To Hundred, Request Sent, Diff Hash" )]
		class NinetyNineToHundred_Sent_DiffHash : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "List Change FD Msg: NintyNine To Hundred, Request Received, Same Hash" )]
		class NinetyNineToHundred_Received_SameHash : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "List Change FD Msg: NintyNine To Hundred, Request Received, Diff Hash" )]
		class NinetyNineToHundred_Received_DiffHash : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "List Change FD Msg: Hundred To NintyNine, Accept Deleted, Same Hash" )]
		class HundredToNinetyNine_AcceptedDeleted_SameHash : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "List Change FD Msg: Hundred To NintyNine, Accept Deleted, Diff Hash" )]
		class HundredToNinetyNine_AcceptedDeleted_DiffHash : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "List Change FD Msg: Hundred To NintyNine, Sent Deleted, Same Hash" )]
		class HundredToNinetyNine_SentDeleted_SameHash : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "List Change FD Msg: Hundred To NintyNine, Sent Deleted, Diff Hash" )]
		class HundredToNinetyNine_SentDeleted_DiffHash : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "List Change FD Msg: Hundred To NintyNine, Receive Rejected, Same Hash" )]
		class HundredToNinetyNine_ReceiveRejected_SameHash : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "List Change FD Msg: Hundred To NintyNine, Receive Rejected, Diff Hash" )]
		class HundredToNinetyNine_ReceiveRejected_DiffHash : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "List Change FD Msg: Zero To Two, Accepted And Sent" )]
		class ZeroToTwo_AcceptedAndSent : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "List Change FD Msg: Zero To Two, Accepted And Received" )]
		class ZeroToTwo_AcceptedAndReceived : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "List Change FD Msg: Zero To Two, Sent And Received" )]
		class ZeroToTwo_SentAndReceived : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "List Change FD Msg: Two To Zero, Delete Accepted And Sent" )]
		class TwoToZero_DeleteAcceptedAndSent : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "List Change FD Msg: Two To Zero, Delete Accepted And Reject" )]
		class TwoToZero_DeleteAcceptedAndReject : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "List Change FD Msg: Two To Zero, Delete Sent And Reject" )]
		class TwoToZero_DeleteSentAndReject : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "List Change FD Msg: Zero To Three, Accepted Sent Received" )]
		class ZeroToThree_AcceptedSentRecieved : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "List Change FD Msg: Three To Zero, Delete Reject" )]
		class ThreeToZero_DeleteReject : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "List Change FD Msg: NinetyEight To Hundred, Accepted And Sent" )]
		class NinetyEightToHundred_AcceptedAndSent : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "List Change FD Msg: NinetyEight To Hundred, Accepted And Received" )]
		class NinetyEightToHundred_AcceptedAndReceived : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "List Change FD Msg: NinetyEight To Hundred, Sent And Received" )]
		class NinetyEightToHundred_SentAndReceived : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "List Change FD Msg: Hundred To NinetyEight, Delete Accept And Sent" )]
		class HundredToNinetyEight_DeleteAcceptedAndSent : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "List Change FD Msg: Hundred To NinetyEight, Delete Accept And Reject" )]
		class HundredToNinetyEight_DeleteAcceptedAndReject : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "List Change FD Msg: Hundred To NinetyEight, Delete Sent And Reject" )]
		class HundredToNinetyEight_DeleteSentAndReject : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "List Change FD Msg: NinetySeven To Hundred, Accepted Sent Received" )]
		class NinetySevenToHundred_AcceptedSentRecieved : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "List Change FD Msg: Hundred To NinetySeven, Delete And Reject" )]
		class HundredToNintySeven_DeleteReject : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "List Change FD Msg: Twenty, Accepted With Accept Deleted" )]
		class Twenty_AcceptedWithAcceptDeleted : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "List Change FD Msg: Twenty, Accepted With Sent Deleted" )]
		class Twenty_AcceptedWithSentDeleted : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "List Change FD Msg: Twenty, Accepted With Receive Rejected" )]
		class Twenty_AcceptedWithReject : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "List Change FD Msg: Twenty, Request Sent With Accept Deleted" )]
		class Twenty_SentWithAcceptDeleted : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "List Change FD Msg: Twenty, Request Sent With Sent Deleted" )]
		class Twenty_SentWithSentDeleted : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "List Change FD Msg: Twenty, Request Sent With Receive Rejected" )]
		class Twenty_SentWithReject : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "List Change FD Msg: Twenty, Request Received With Accept Deleted" )]
		class Twenty_ReceivedWithAcceptDeleted : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "List Change FD Msg: Twenty, Request Received With Sent Deleted" )]
		class Twenty_ReceivedWithSentDeleted : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "List Change FD Msg: Twenty, Request Received With Receive Rejected" )]
		class Twenty_ReceivedWithReject : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Presence\Test\FuncListChangeSoap.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.WebWidget;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Presence;

namespace PresWidgetTest
{
	public class FuncListChangeSoap : TestNode
	{
		public static void VerifyCounts( BuddyGroup group, byte expectedOnline, byte ExpectedOffline )
		{
			WebFriendData wf = PWT.GetWebFriends( group.User );
			wf.CheckCount( expectedOnline, ExpectedOffline );
		}

        [TestGroupSetup]
        public void Setup()
        {
            PWT.Initialize();
        }

		[TestCase, Description( "List Change Soap 1a: One To Zero, Sent and accepted - deleted, Same Hash" )]
		class OneToZero_SentAndAcceptedThenDeleted_SameHash : TestBase
		{
			override protected void Execute()
			{
				// Set up
				PWT.OneBudOnSame.LogonAll( false );
				PWT.OneBudOnSame.DeleteAllBuddies( false );
				PWT.OneBudOnSame.SetDeleted( 0, 0 );
				VerifyCounts( PWT.OneBudOnSame, 1, 0 );

				// Test
				PWT.OneBudOnSame.SetDeleted( 1, 0 );
				VerifyCounts( PWT.OneBudOnSame, 0, 0 );
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "List Change Soap 1b: One To Zero, Sent and accepted - deleted, Diff Hash" )]
		class OneToZero_SentAndAcceptedThenDeleted_DiffHash : TestBase
		{
			override protected void Execute()
			{
				// Set up
				PWT.OneBudOnDiff.LogonAll( false );
				PWT.OneBudOnDiff.DeleteAllBuddies( false );
				PWT.OneBudOnDiff.SetDeleted( 0, 0 );
				VerifyCounts( PWT.OneBudOnDiff, 1, 0 );

				// Test
				PWT.OneBudOnDiff.SetDeleted( 0, 1 );
				VerifyCounts( PWT.OneBudOnDiff, 0, 0 );
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "List Change Soap 2a: One To Zero, Recieved and accepted - deleted, Same Hash" )]
		class OneToZero_RecievedAndAcceptedThenDeleted_SameHash : TestBase
		{
			override protected void Execute()
			{
				// Set up
				PWT.OneBudOnSame.LogonAll( false );
				PWT.OneBudOnSame.DeleteAllBuddies( false );
				PWT.OneBudOnSame.RequestFromDeleted( 1, 0, false );
				PWT.OneBudOnSame.AcceptRequested( 1, 0 );
				VerifyCounts( PWT.OneBudOnSame, 1, 0 );

				// Test
				PWT.OneBudOnSame.SetDeleted( 1, 0 );
				VerifyCounts( PWT.OneBudOnSame, 0, 0 );
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}

		[TestCase, Description( "List Change Soap 2b: One To Zero, Recieved and accepted - deleted, Diff Hash" )]
		class OneToZero_RecievedAndAcceptedThenDeleted_DiffHash : TestBase
		{
			override protected void Execute()
			{
				// Set up
				PWT.OneBudOnDiff.LogonAll( false );
				PWT.OneBudOnDiff.DeleteAllBuddies( false );
				PWT.OneBudOnDiff.RequestFromDeleted( 0, 1, false );
				PWT.OneBudOnDiff.AcceptRequested( 0, 1 );
				VerifyCounts( PWT.OneBudOnDiff, 1, 0 );

				// Test
				PWT.OneBudOnDiff.SetDeleted( 0, 1 );
				VerifyCounts( PWT.OneBudOnDiff, 0, 0 );
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}

		[TestCase, Description( "List Change Soap 3a: One To Zero, Sent - deleted, Same Hash" )]
		class OneToZero_SentThenDeleted_SameHash : TestBase
		{
			override protected void Execute()
			{
				// Set up
				PWT.OneBudOnSame.LogonAll( false );
				PWT.OneBudOnSame.DeleteAllBuddies( false );
				PWT.OneBudOnSame.RequestToDeleted( 1, 0 );
				VerifyCounts( PWT.OneBudOnSame, 0, 0 );
	
				// Test
				PWT.OneBudOnSame.SetDeleted( 1, 0 );
				VerifyCounts( PWT.OneBudOnSame, 0, 0 );
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "List Change Soap 3b: One To Zero, Sent Deleted, Diff Hash" )]
		class OneToZero_SentThenDeleted_DiffHash : TestBase
		{
			override protected void Execute()
			{
				// Set up
				PWT.OneBudOnDiff.LogonAll(false );	
				PWT.OneBudOnDiff.DeleteAllBuddies( false );	
				PWT.OneBudOnDiff.RequestToDeleted( 0, 1);
				VerifyCounts( PWT.OneBudOnDiff, 0, 0 );

				// Test
				PWT.OneBudOnDiff.SetDeleted( 0, 1 );
				VerifyCounts( PWT.OneBudOnDiff, 0, 0 );
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}

		[TestCase, Description( "List Change Soap 4a: One To Zero, Receive Rejected, Same Hash" )]
		class OneToZero_ReceiveRejected_SameHash : TestBase
		{
			override protected void Execute()
			{
				// Set up
				PWT.OneBudOnSame.LogonAll( false );
				PWT.OneBudOnSame.DeleteAllBuddies( false );
				PWT.OneBudOnSame.RequestFromDeleted( 1, 0 );
				VerifyCounts( PWT.OneBudOnSame, 0, 0 );
	
				// Test
				PWT.OneBudOnSame.SetDeleted( 1, 0 );
				VerifyCounts( PWT.OneBudOnSame, 0, 0 );
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}

		[TestCase, Description( "List Change Soap 3b: One To Zero, Receive Rejected, Diff Hash" )]
		class OneToZero_ReceiveRejected_DiffHash : TestBase
		{
			override protected void Execute()
			{
				PWT.OneBudOnDiff.SetDeleted( 0, 0, false );	
				PWT.OneBudOnDiff.SetDeleted( 0, 1, false );	
				PWT.OneBudOnDiff.RequestFromDeleted( 0, 1, false );	
				VerifyCounts( PWT.OneBudOnDiff, 0, 0 );

				PWT.OneBudOnDiff.SetDeleted( 0, 1 );
				VerifyCounts( PWT.OneBudOnDiff, 0, 0 );
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}

		[TestCase, Description( "List Change Soap 4a: Zero To One, Sent and Accepted, Same Hash" )]
		class ZeroToOne_SentAndAccepted_SameHash : TestBase
		{
			override protected void Execute()
			{
				PWT.OneBudOnSame.LogonAll( false );
				PWT.OneBudOnSame.SetDeleted( 1, 0, false );	

				PWT.OneBudOnSame.SetDeleted( 0, 0 );
				VerifyCounts( PWT.OneBudOnSame, 1, 0 );
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "List Change Soap 4b: Zero To One, Accepted, Diff Hash" )]
		class ZeroToOne_SentAndAccepted_DiffHash : TestBase
		{
			override protected void Execute()
			{
				PWT.OneBudOnDiff.LogonAll( false );
				PWT.OneBudOnDiff.SetDeleted( 0, 1, false );	

				PWT.OneBudOnDiff.SetDeleted( 0, 0 );
				VerifyCounts( PWT.OneBudOnDiff, 1, 0 );
				ResultCode=TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description( "List Change Soap 4a: Zero To One, Recieved and Accepted, Same Hash" )]
		class ZeroToOne_RecievedAndAccepted_SameHash : TestBase
		{
			override protected void Execute()
			{
				PWT.OneBudOnSame.LogonAll( false );
				PWT.OneBudOnSame.SetDeleted( 1, 0 );	
				VerifyCounts( PWT.OneBudOnSame, 0, 0 );

				PWT.OneBudOnSame.RequestFromDeleted( 1, 0, false );
				PWT.OneBudOnSame.AcceptRequested( 1, 0 );
				VerifyCounts( PWT.OneBudOnSame, 1, 0 );
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}

		[TestCase, Description( "List Change Soap 5a: Zero To One, Request Sent, Same Hash" )]
		class ZeroToOne_Sent_SameHash : TestBase
		{
			override protected void Execute()
			{
				PWT.OneBudOnSame.SetDeleted( 1, 0, false );	

				PWT.OneBudOnSame.RequestToDeleted( 1, 0 );
				VerifyCounts( PWT.OneBudOnSame, 0, 0 );
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}

		[TestCase, Description( "List Change Soap 5b: Zero To One, Request Sent, Diff Hash" )]
		class ZeroToOne_Sent_DiffHash : TestBase
		{
			override protected void Execute()
			{
				PWT.OneBudOnDiff.SetDeleted( 0, 1, false );	

				PWT.OneBudOnDiff.RequestToDeleted( 0, 1 );
				VerifyCounts( PWT.OneBudOnDiff, 0, 0 );
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}

		[TestCase, Description( "List Change Soap 6a: Zero To One, Request Received, Same Hash" )]
		class ZeroToOne_Received_SameHash : TestBase
		{
			override protected void Execute()
			{
				PWT.OneBudOnSame.SetDeleted( 1, 0, false );	

				PWT.OneBudOnSame.RequestFromDeleted( 1, 0 );
				VerifyCounts( PWT.OneBudOnSame, 0, 0 );
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}

		[TestCase, Description( "List Change Soap 6b: Zero To One, Request Received, Diff Hash" )]
		class ZeroToOne_Received_DiffHash : TestBase
		{
			override protected void Execute()
			{
				PWT.OneBudOnDiff.SetDeleted( 0, 1, false );	

				PWT.OneBudOnDiff.RequestFromDeleted( 0, 1 );
				VerifyCounts( PWT.OneBudOnDiff, 0, 0 );
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Presence\Test\FuncGetXUIDs.cs ===
using System;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.UserAccount;

namespace PresWidgetTest
{
	public class FuncGetXUIDs : TestNode
	{
        public static int sleepTime = 30000;
        public static FriendsCommon _fc;

        [TestGroupSetup]
		public void Setup()
		{
			_fc = new FriendsCommon();
		}

        [TestGroupTearDown]
		public void TearDown()
		{
			_fc = null;
        }

        [TestCase, Description( "User Exists" )]
		class GetValidUser : TestBase
		{
			override protected void Execute()
			{
                // Create Xbox 1 User
                Owner o = _fc.UACS.GenerateOwner();
                ulong userPuid = _fc.UACS.CreateUser(o);

                // Wait for the cache to pick up the change
                Thread.Sleep(sleepTime);

                // Fetch the gamertag
                string [] gamertags = new string[1]{o.gamertag};
                ulong[] xuidUsers = new ulong[1];
                WCPresence wp = new WCPresence();
				xuidUsers = wp.GetXUIDSFromGamertags(gamertags);

                ValueCheck.Test("Presence Widget", userPuid,xuidUsers[0] );

                ResultCode = TEST_RESULTS.PASSED;
			}
		}
	
        [TestCase, Description( "Get Multiple Valid Users" )]
		class GetMultipleValidUsers : TestBase
		{
			override protected void Execute()
			{
                // Create Xbox 1 User
                Owner o = _fc.UACS.GenerateOwner();
                ulong userPuid = _fc.UACS.CreateUser(o);

                Owner ob = _fc.UACS.GenerateOwner();
                ulong userPuidB = _fc.UACS.CreateUser(ob);

                // Wait for the cache to pick up the change
                Thread.Sleep(sleepTime);

                // Fetch the gamertag
                string [] gamertags = new string[2]{o.gamertag, ob.gamertag};
                ulong[] xuidUsers = new ulong[2];
                WCPresence wp = new WCPresence();
				xuidUsers = wp.GetXUIDSFromGamertags(gamertags);

                ValueCheck.Test("Presence Widget", userPuid, xuidUsers[0] );
                ValueCheck.Test("Presence Widget", userPuidB, xuidUsers[1] );

                ResultCode = TEST_RESULTS.PASSED;
			}
		}

        [TestCase, Description( "Valid Duplicates" )]
		class GetValidDuplicateUsers : TestBase
		{
			override protected void Execute()
			{
                // Create Xbox 1 User
                Owner o = _fc.UACS.GenerateOwner();
                ulong userPuid = _fc.UACS.CreateUser(o);

                // Wait for the cache to pick up the change
                Thread.Sleep(sleepTime);

                // Fetch the gamertag
                string [] gamertags = new string[2]{o.gamertag, o.gamertag};
                ulong[] xuidUsers = new ulong[2];
                WCPresence wp = new WCPresence();
				xuidUsers = wp.GetXUIDSFromGamertags(gamertags);

                ValueCheck.Test("Presence Widget", userPuid, xuidUsers[0] );
                ValueCheck.Test("Presence Widget", userPuid, xuidUsers[1] );

                ResultCode = TEST_RESULTS.PASSED;
			}
		}

        [TestCase, Description( "Invalid Gamertag - null" )]
		class InvalidNullGamertag : TestBase
		{
			override protected void Execute()
			{
                string [] gamertags = new string[1];
                ulong[] xuidUsers = new ulong[1];
                WCPresence wp = new WCPresence();
                try
                {
				    xuidUsers = wp.GetXUIDSFromGamertags(gamertags);
                }
                catch
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
			}
        }

        [TestCase, Description( "Invalid Gamertag - Empty" )]
		class InvalidEmptyGamertag : TestBase
		{
			override protected void Execute()
			{
                string [] gamertags = new string[1]{""};
                ulong[] xuidUsers = new ulong[1];
                WCPresence wp = new WCPresence();
                try
                {
				    xuidUsers = wp.GetXUIDSFromGamertags(gamertags);
                }
                catch
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
			}
        }

        [TestCase, Description( "Invalid Gamertag - Too Long" )]
		class InvalidLongGamertag : TestBase
		{
			override protected void Execute()
			{
                string [] gamertags = new string[1]{"TooLongIsGreater"};
                ulong[] xuidUsers = new ulong[1];
                WCPresence wp = new WCPresence();
                try
                {
				    xuidUsers = wp.GetXUIDSFromGamertags(gamertags);
                }
                catch
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
			}
        }

        [TestCase, Description( "Invalid Gamertag - Doesn't Exist" )]
		class InvalidGamertagDoesntExist : TestBase
		{
			override protected void Execute()
			{
                string [] gamertags = new string[1]{"NotExistf0b"};
                ulong[] xuidUsers = new ulong[1];
                WCPresence wp = new WCPresence();
				xuidUsers = wp.GetXUIDSFromGamertags(gamertags);

                ValueCheck.Test("Presence Widget", 0, xuidUsers[0] );

                ResultCode = TEST_RESULTS.PASSED;
			}
        }

        [TestCase, Description( "Invalid Gamertag - Array too long" )]
		class InvalidGamertagLargeArray : TestBase
		{
			override protected void Execute()
			{
                ResultCode = TEST_RESULTS.FAILED;
                string [] gamertags = new string[101];
                ulong[] xuidUsers = new ulong[101];
                WCPresence wp = new WCPresence();
                try
                {
    				xuidUsers = wp.GetXUIDSFromGamertags(gamertags);
                }
                catch
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
			}
        }

        [TestCase, Description( "Invalid Gamertag - Mix of valid and invalid tags" )]
		class InvalidGamertagMixedArray : TestBase
		{
			override protected void Execute()
			{
                // Create Xbox User
                Owner o = _fc.UACS.GenerateOwner();
                ulong userPuid = _fc.UACS.CreateUser(o);
                Owner oB = _fc.UACS.GenerateOwner();
                ulong userPuidB = _fc.UACS.CreateUser(oB);

                // Wait for the cache to pick up the change
                Thread.Sleep(sleepTime);

                string [] gamertags = new string[5]{o.gamertag, "", "0Bad", oB.gamertag, "!@#%!#^%"};
                ulong[] xuidUsers = new ulong[5];
                WCPresence wp = new WCPresence();
                try
                {
   				    xuidUsers = wp.GetXUIDSFromGamertags(gamertags);
                }
                catch
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
			}
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Presence\Test\FuncTitleIDChangeSoap.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.WebWidget;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Presence;

namespace PresWidgetTest
{
	public class FuncTitleIDChangeSoap : TestNode
	{
		public static void DoGroupCase( BuddyGroup group, byte onlineSame, byte onlineDiff )
		{
			group.SetLoggedOn( onlineSame, onlineDiff, 1010, false );
			group.SetLoggedOn( 0, 0 );
			group.SetLoggedOn( onlineSame, onlineDiff, 9999, true );
			WebFriendData wf = PWT.GetWebFriends( group.User );
			wf.CheckCount( group.Online, group.Offline );
			for( byte i = 0; i < group.Online; ++i )
			{
				if( wf.TitleId( i ) != 9999 )
				{
					string msg = "Expected Title ID: 9999 Not "+wf.TitleId( i );
					throw new UnexpectedTestResultException( msg );
				}
			}
		}

        [TestGroupSetup]
        public void Setup()
        {
            PWT.Initialize();
        }

		[TestCase, Description( "Title ID Change Soap 1a: One, Same Hash" )]
		class One_SameHash : TestBase
		{
			override protected void Execute()
			{
				DoGroupCase( PWT.OneBudOnEach, 1, 0 );
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}

		[TestCase, Description( "Title ID Change Soap 1b: One, Diff Hash" )]
		class One_DiffHash : TestBase
		{
			override protected void Execute()
			{
				DoGroupCase( PWT.OneBudOnEach, 0, 1 );
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}

		[TestCase, Description( "Title ID Change Soap 2a: One of Twenty, Same Hash" )]
		class OneOfTwenty_SameHash : TestBase
		{
			override protected void Execute()
			{
				DoGroupCase( PWT.TwentyBuds, 1, 0 );
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}

		[TestCase, Description( "Title ID Change Soap 2b: One of Twenty, Diff Hash" )]
		class OneOfTwenty_DiffHash : TestBase
		{
			override protected void Execute()
			{
				DoGroupCase( PWT.TwentyBuds, 0, 1 );
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}

		[TestCase, Description( "Title ID Change Soap 2c: Five of Twenty" )]
		class FiveOfTwenty : TestBase
		{
			override protected void Execute()
			{
				DoGroupCase( PWT.TwentyBuds, 2, 3 );
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}

		[TestCase, Description( "Title ID Change Soap 2d: Twenty of Twenty" )]
		class TWentyOfTwenty : TestBase
		{
			override protected void Execute()
			{
				DoGroupCase( PWT.TwentyBuds, 10, 10 );
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}

		[TestCase, Description( "Title ID Change Soap 3a: One of Hundred, Same Hash" )]
		class OneOfHundred_SameHash : TestBase
		{
			override protected void Execute()
			{
				DoGroupCase( PWT.HundredBuds, 1, 0 );
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}

		[TestCase, Description( "Title ID Change Soap 3b: One of Hundred, Diff Hash" )]
		class OneOfHundred_DiffHash : TestBase
		{
			override protected void Execute()
			{
				DoGroupCase( PWT.HundredBuds, 0, 1 );
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}

		[TestCase, Description( "Title ID Change Soap 3c: Ten of Hundred" )]
		class TenOfHundred : TestBase
		{
			override protected void Execute()
			{
				DoGroupCase( PWT.HundredBuds, 5, 5 );
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}

		[TestCase, Description( "Title ID Change Soap 3d: Hundred of Hundred" )]
		class HundredOfHundred : TestBase
		{
			override protected void Execute()
			{
				DoGroupCase( PWT.HundredBuds, 50, 50 );
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Presence\Test\FuncTitleDataChangeFDMsg.cs ===
using System;
using ServerTestFramework;

namespace PresWidgetTest
{
	public class FuncTitleDataChangeFDMsg : TestNode
	{
		[TestCase, Description( "Title Data Change FD Msg: Some" )]
		class Some : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "Title Data Change FD Msg: All" )]
		class All : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "Title Data Change FD Msg: None to Max" )]
		class NoneToMax : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "Title Data Change FD Msg: None to Some" )]
		class NoneToSome : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "Title Data Change FD Msg: Max to None" )]
		class MaxToNone : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "Title Data Change FD Msg: Max to Some" )]
		class MaxToSome : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "Title Data Change FD Msg: Ten, One of One" )]
		class Ten_OneOfOne : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "Title Data Change FD Msg: Ten, One of Five" )]
		class Ten_OneOfFive : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "Title Data Change FD Msg: Ten, One of Ten" )]
		class Ten_OneOfTen : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "Title Data Change FD Msg: Ten, Five of Five" )]
		class Ten_FiveOfFive : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "Title Data Change FD Msg: Ten, Five of Ten" )]
		class Ten_FiveOfTen : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "Title Data Change FD Msg: Ten, Ten of Ten" )]
		class Ten_TenOfTen : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "Title Data Change FD Msg: Hundred, One of One" )]
		class Hundred_OneOfOne : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "Title Data Change FD Msg: Hundred, One of Ten" )]
		class Hundred_OneOfTen : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "Title Data Change FD Msg: Hundred, One of Hundred" )]
		class Hundred_OneOfHundred : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "Title Data Change FD Msg: Hundred, Ten of Ten" )]
		class Hundred_TenOfTen : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "Title Data Change FD Msg: Hundred, Ten of Hundred" )]
		class Hundred_TenOfHundred : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "Title Data Change FD Msg: Hundred, Hundred of Hundred" )]
		class Hundred_HundredOfHundred : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Presence\Test\FuncStateChangeFDMsg.cs ===
using System;
using ServerTestFramework;

namespace PresWidgetTest
{
/*
	Online
	Playing
	Voice
	Joinable
	OneGuest
	TwoGuests
	ThreeGuests
	SentInvite
	ReceivedInvite
	InviteAccepted
	InviteRejected
	SentRequest
	RecievedRequest
*/
	public class FuncStateChangeFDMsg : TestNode
	{
		[TestCase, Description( "State Change FD Msg: One, Offline to Online" )]
		class One_OfflineToOnline : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "State Change FD Msg: One, Offline to Online Cloaked" )]
		class One_OfflineToOnlineCloaked : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "State Change FD Msg: One, Offline to Online and Back" )]
		class One_OfflineToOnlineAndBack : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "State Change FD Msg: One, Online to Offline" )]
		class One_OnlineToOffline : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "State Change FD Msg: One, Online to Offline and Back" )]
		class One_OnlineToOfflineAndBack : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "State Change FD Msg: One, Online to Online Cloaked and Back" )]
		class One_OnlineToOnlineCloaedAndBack : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "State Change FD Msg: One, Online Cloaked to Offline" )]
		class One_OnlineCloaedToOffline : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "State Change FD Msg: One, Online Cloaked to Online" )]
		class One_OnlineCloaedToOnline : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "State Change FD Msg: One, Online Cloaked to Online and Back" )]
		class One_OnlineCloaedToOnlineAndBack : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "State Change FD Msg: One, All To All" )]
		class One_AllToAll : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "State Change FD Msg: One, All To All and Back" )]
		class One_AllToAllAndBack : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "State Change FD Msg: Ten, One All to All" )]
		class Ten_One_AllToAll : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "State Change FD Msg: Ten, Five All to All" )]
		class Ten_Five_AllToAll : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "State Change FD Msg: Ten, All to All" )]
		class Ten_AllToAll : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "State Change FD Msg: Hundred, One All to All" )]
		class Hundred_One_AllToAll : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "State Change FD Msg: Hundred, Ten All to All" )]
		class Hundred_Ten_AllToAll : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "State Change FD Msg: Hundred, All to All" )]
		class Hundred_AllToAll : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Presence\Test\FuncTitleIDChangeFDMsg.cs ===
using System;
using ServerTestFramework;

namespace PresWidgetTest
{
	public class FuncTitleIDChangeFDMsg : TestNode
	{
		[TestCase, Description( "Title ID Change FD Msg: One" )]
		class One : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "Title ID Change FD Msg: Ten, One of One" )]
		class Ten_OneOfOne : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "Title ID Change FD Msg: Ten, One of Five" )]
		class Ten_OneOfFive : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "Title ID Change FD Msg: Ten, One of Ten" )]
		class Ten_OneOfTen : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "Title ID Change FD Msg: Ten, Five of Five" )]
		class Ten_FiveOfFive : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "Title ID Change FD Msg: Ten, Five of Ten" )]
		class Ten_FiveOfTen : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "Title ID Change FD Msg: Ten, Ten of Ten" )]
		class Ten_TenOfTen : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "Title ID Change FD Msg: Hundred, One of One" )]
		class Hundred_OneOfOne : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "Title ID Change FD Msg: Hundred, One of Ten" )]
		class Hundred_OneOfTen : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "Title ID Change FD Msg: Hundred, One of Hundred" )]
		class Hundred_OneOfHundred : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "Title ID Change FD Msg: Hundred, Ten of Ten" )]
		class Hundred_TenOfTen : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "Title ID Change FD Msg: Hundred, Ten of Hundred" )]
		class Hundred_TenOfHundred : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "Title ID Change FD Msg: Hundred, Hundred of Hundred" )]
		class Hundred_HundredOfHundred : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Presence\Test\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Presence\Test\FuncValidFdMsg.cs ===
using System;
using System.Net;
using System.Net.Sockets;
using ServerTestFramework;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Presence;

namespace PresWidgetTest
{
	public class FuncValidFdMsg : TestNode
	{
		[TestCase, Description( "Valid FD Msg: No Friends" )]
		class NoFriends : TestBase
		{
			override protected void Execute()
			{
				PNUser user = new PNUser();
				PWT.Friends.LogonUser( user );

				PNMsg replyMsg;
				PMsgWebFriends webFriendsMsg = new PMsgWebFriends( user );
                webFriendsMsg.TransactFD(out replyMsg);
				
				ResultCode = TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "Valid FD Msg: One Friend, Online, Same Hash" )]
		class OneFriend_Online_SameHash : TestBase
		{
			override protected void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;
			}
		}


		[TestCase, Description( "Valid FD Msg: One Friend, Online, Diff Hash" )]
		class OneFriend_Online_DiffHash : TestBase
		{
			override protected void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		
		[TestCase, Description( "Valid FD Msg: One Friend, Offline, Same Hash" )]
		class OneFriend_Offline_SameHash : TestBase
		{
			override protected void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;
			}
		}


		[TestCase, Description( "Valid FD Msg: One Friend, Offline, Diff Hash" )]
		class OneFriend_Offline_DiffHash : TestBase
		{
			override protected void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;
			}
		}


		[TestCase, Description( "Valid FD Msg: Two Friends, Both Offline" )]
		class TwoFriends_BothOffline : TestBase
		{
			override protected void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;
			}
		}


		[TestCase, Description( "Valid FD Msg: Two Friends, Both Online" )]
		class TwoFriends_BothOnline : TestBase
		{
			override protected void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;
			}
		}


		[TestCase, Description( "Valid FD Msg: Two Friends, Same Hash Online" )]
		class TwoFriends_SameOnline : TestBase
		{
			override protected void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;
			}
		}


		[TestCase, Description( "Valid FD Msg: Two Friends, Diff Hash Online" )]
		class TwoFriends_DiffOnline : TestBase
		{
			override protected void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;
			}
		}


		[TestCase, Description( "Valid FD Msg: 100 Friends, 1 Online, Same Hash" )]
		class HundredFriends_OneOnline_SameHash : TestBase
		{
			override protected void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;
			}
		}


		[TestCase, Description( "Valid FD Msg: 100 Friends, 1 Online, Diff Hash" )]
		class HundredFriends_OneOnline_DiffHash : TestBase
		{
			override protected void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;
			}
		}


		[TestCase, Description( "Valid FD Msg: 100 Friends, 1 Offline, Same Hash" )]
		class HundredFriends_OneOffline_SameHash : TestBase
		{
			override protected void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;
			}
		}


		[TestCase, Description( "Valid FD Msg: 100 Friends, 1 Offline, Diff Hash" )]
		class HundredFriends_OneOffline_DiffHash : TestBase
		{
			override protected void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;
			}
		}


		[TestCase, Description( "Valid FD Msg: 100 Friends, Online" )]
		class HundredFriends_Online : TestBase
		{
			override protected void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;
			}
		}


		[TestCase, Description( "Valid FD Msg: 100 Friends, Offline" )]
		class HundredFriends_Offline : TestBase
		{
			override protected void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;
			}
		}


		[TestCase, Description( "Valid FD Msg: 20 Friends, 4 Online" )]
		class TwentyFriends_FourOnline : TestBase
		{
			override protected void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Presence\Test\FuncStateChangeSoap.cs ===
using System;
using ServerTestFramework;

namespace PresWidgetTest
{
	/*
		Online
		Playing
		Voice
		Joinable
		OneGuest
		TwoGuests
		ThreeGuests
		SentInvite
		ReceivedInvite
		InviteAccepted
		InviteRejected
		SentRequest
		RecievedRequest
	*/
	public class FuncStateChangeSoap : TestNode
	{
		[TestCase, Description( "State Change Soap: One, Offline to Online" )]
		class One_OfflineToOnline : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "State Change Soap: One, Offline to Online Cloaked" )]
		class One_OfflineToOnlineCloaked : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "State Change Soap: One, Offline to Online and Back" )]
		class One_OfflineToOnlineAndBack : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "State Change Soap: One, Online to Offline" )]
		class One_OnlineToOffline : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "State Change Soap: One, Online to Offline and Back" )]
		class One_OnlineToOfflineAndBack : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "State Change Soap: One, Online to Online Cloaked and Back" )]
		class One_OnlineToOnlineCloaedAndBack : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "State Change Soap: One, Online Cloaked to Offline" )]
		class One_OnlineCloaedToOffline : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "State Change Soap: One, Online Cloaked to Online" )]
		class One_OnlineCloaedToOnline : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "State Change Soap: One, Online Cloaked to Online and Back" )]
		class One_OnlineCloaedToOnlineAndBack : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "State Change Soap: One, All To All" )]
		class One_AllToAll : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "State Change Soap: One, All To All and Back" )]
		class One_AllToAllAndBack : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "State Change Soap: Ten, One All to All" )]
		class Ten_One_AllToAll : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "State Change Soap: Ten, Five All to All" )]
		class Ten_Five_AllToAll : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "State Change Soap: Ten, All to All" )]
		class Ten_AllToAll : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "State Change Soap: Hundred, One All to All" )]
		class Hundred_One_AllToAll : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "State Change Soap: Hundred, Ten All to All" )]
		class Hundred_Ten_AllToAll : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "State Change Soap: Hundred, All to All" )]
		class Hundred_AllToAll : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Presence\Test\FuncValidSeconds.cs ===
using System;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Presence;

namespace PresWidgetTest
{
	public class FuncValidSeconds : TestNode
	{
		public static void DoValidSecCase( PNUser user )
		{
			WebFriendData wf = PWT.GetWebFriends( user );
			if( wf.ValidSec != PWT.CacheExpDelay )
			{
				string msg = "Expected 1st ValidSec: "+PWT.CacheExpDelay+" Not "+wf.ValidSec;
				throw new UnexpectedTestResultException( msg );
			}

			Thread.Sleep( 5000 );
			wf = PWT.GetWebFriends( user );
			if( wf.ValidSec != PWT.CacheExpDelay )
			{
				string msg = "Expected 2nd ValidSec: "+PWT.CacheExpDelay+" Not "+wf.ValidSec;
				throw new UnexpectedTestResultException( msg );
			}
		}

		[TestCase, Description( "Soap ValidSeconds 1: Never Logged In" )]
		class NeverLoggedIn : TestBase
		{
			override protected void Execute()
			{
				ConsoleX.WriteLine();
				PNUser user = PWT.Friends.CreateLinkedUser( false ); // Don't logon
				Thread.Sleep( 30000 );
				DoValidSecCase( user );
				ResultCode=TEST_RESULTS.PASSED;
			}
		}
		
		[TestCase, Description( "Soap ValidSeconds 2: No Friends" )]
		class NoFriends : TestBase
		{
			override protected void Execute()
			{
				ConsoleX.WriteLine();
				PNUser user = PWT.Friends.CreateLinkedUser( true ); // Logon too
				Thread.Sleep( 30000 );
				DoValidSecCase( user );
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}

		[TestCase, Description( "Soap ValidSeconds 3: 20 Friends, 4 Online" )]
		class TwentyFriends_FourOnline : TestBase
		{
			override protected void Execute()
			{
				PWT.TwentyBuds.SetLoggedOn( 2, 2 );
				DoValidSecCase( PWT.TwentyBuds.User );
				ResultCode=TEST_RESULTS.PASSED;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Presence\Test\FuncValidSoapApi.cs ===
using System;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Presence;

namespace PresWidgetTest
{
	public class FuncValidSoapApi : TestNode
	{
		public static void DoGroupCase( BuddyGroup group, byte onlineSame, byte onlineDiff )
		{
			group.SetLoggedOn( onlineSame, onlineDiff );
			WebFriendData wf = PWT.GetWebFriends( group.User );
			group.CheckWebFriends( wf );
		}

        [TestGroupSetup]
        public void Setup()
        {
            PWT.Initialize();
        }

		[TestCase, Description( "Valid Soap API 1: Never logged on" )]
		class NeverLoggedOn : TestBase
		{
			override protected void Execute()
			{
				PNUser user = PWT.Friends.CreateLinkedUser( false ); // Don't logon
				Thread.Sleep( 30000 );
				WebFriendData wf = PWT.GetWebFriends( user );
				ValueCheck.Test("wf.Count", 0, wf.Count);
				ResultCode=TEST_RESULTS.PASSED;
			}
		}
		

		[TestCase, Description( "Valid Soap API 2: No Friends" )]
		class NoFriends : TestBase
		{
			override protected void Execute()
			{
				PNUser user = PWT.Friends.CreateLinkedUser( true ); // Logon too
				Thread.Sleep( 30000 );
				WebFriendData wf = PWT.GetWebFriends( user );
				ValueCheck.Test("wf.Count", 0, wf.Count);
				ResultCode=TEST_RESULTS.PASSED;
			}		
		}


		[TestCase, Description( "Valid Soap API 3a: One Friend, Offline, Same Hash" )]
		class OneFriend_Offline_SameHash : TestBase
		{
			override protected void Execute()
			{
				DoGroupCase( PWT.OneBudOnSame, 0, 0 );
				ResultCode=TEST_RESULTS.PASSED;
			}
		}


		[TestCase, Description( "Valid Soap API 3b: One Friend, Offline, Diff Hash" )]
		class OneFriend_Offline_DiffHash : TestBase
		{
			override protected void Execute()
			{
				DoGroupCase( PWT.OneBudOnDiff, 0, 0 );
				ResultCode=TEST_RESULTS.PASSED;
			}
		}


		[TestCase, Description( "Valid Soap API 4a: One Friend, Online, Same Hash" )]
		class OneFriend_Online_SameHash : TestBase
		{
			override protected void Execute()
			{
				DoGroupCase( PWT.OneBudOnSame, 1, 0 );
				ResultCode=TEST_RESULTS.PASSED;	
			}
		}


		[TestCase, Description( "Valid Soap API 4b: One Friend, Online, Diff Hash" )]
		class OneFriend_Online_DiffHash : TestBase
		{
			override protected void Execute()
			{
				DoGroupCase( PWT.OneBudOnDiff, 0, 1 );
				ResultCode=TEST_RESULTS.PASSED;
			}
		}
		

		[TestCase, Description( "Valid Soap API 5: 100 Friends, Offline" )]
		class HundredFriends_Offline : TestBase
		{
			override protected void Execute()
			{
				DoGroupCase( PWT.HundredBuds, 0, 0 );
				ResultCode=TEST_RESULTS.PASSED;
			}
		}


		[TestCase, Description( "Valid Soap API 6a: 100 Friends, 1 Online, Same Hash" )]
		class HundredFriends_OneOnline_SameHash : TestBase
		{
			override protected void Execute()
			{
				DoGroupCase( PWT.HundredBuds, 1, 0 );
				ResultCode=TEST_RESULTS.PASSED;
			}
		}


		[TestCase, Description( "Valid Soap API 6b: 100 Friends, 1 Online, Diff Hash" )]
		class HundredFriends_OneOnline_DiffHash : TestBase
		{
			override protected void Execute()
			{
				DoGroupCase( PWT.HundredBuds, 0, 1 );
				ResultCode=TEST_RESULTS.PASSED;
			}
		}


		[TestCase, Description( "Valid Soap API 7a: 100 Friends, 1 Offline, Same Hash" )]
		class HundredFriends_OneOffline_SameHash : TestBase
		{
			override protected void Execute()
			{
				DoGroupCase( PWT.HundredBuds, 49, 50 );
				ResultCode=TEST_RESULTS.PASSED;
			}
		}


		[TestCase, Description( "Valid Soap API 7b: 100 Friends, 1 Offline, Diff Hash" )]
		class HundredFriends_OneOffline_DiffHash : TestBase
		{
			override protected void Execute()
			{
				DoGroupCase( PWT.HundredBuds, 50, 49 );
				ResultCode=TEST_RESULTS.PASSED;
			}
		}


		[TestCase, Description( "Valid Soap API 8: 100 Friends, Online" )]
		class HundredFriends_Online : TestBase
		{
			override protected void Execute()
			{
				DoGroupCase( PWT.HundredBuds, 50, 50 );
				ResultCode=TEST_RESULTS.PASSED;
			}
		}


		[TestCase, Description( "Valid Soap API 9: 20 Friends, 4 Online" )]
		class TwentyFriends_FourOnline : TestBase
		{
			override protected void Execute()
			{
				DoGroupCase( PWT.TwentyBuds, 2, 2 );
				ResultCode=TEST_RESULTS.PASSED;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Presence\Test\PresWidgetTest.cs ===
using System;
using System.Xml;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;

[assembly: RootNode(typeof(PresWidgetTest.PresWidgetTest))]

namespace PresWidgetTest
{
	////////////////////////////////////////////////
	// Pres Widget Test
	//
	//	STF Test Suite for Presence Widget
	//
    [Owner("shailesh"), TestFrequency("Regression"), TestCasePriority(3), Description("Presence Widget tests.")]
	public class PresWidgetTest : TestNode
	{
        public PresWidgetTest()
        {
            //functional tests
            AddChild( new PresenceDVTs() );
            AddChild( new FuncValidFdMsg() );
            AddChild( new FuncValidSoapApi() );
            AddChild( new FuncValidSeconds() );
            AddChild( new FuncInvalidGamerTag() );
            AddChild( new FuncInvalidUserID() );
            AddChild( new FuncInvalidWebID() );
            AddChild( new FuncListChangeSoap() );
//          AddChild( new FuncListChangeFDMsg() );
//          AddChild( new FuncStateChangeSoap() );
//          AddChild( new FuncStateChangeFDMsg() );
            AddChild( new FuncTitleIDChangeSoap() );
//          AddChild( new FuncTitleIDChangeFDMsg() );
//          AddChild( new FuncTitleDataChangeFDMsg() );
            AddChild( new FuncGetGamertags() );
            AddChild( new FuncGetXUIDs() );
            AddChild( new FuncGetFriendsEx() );
            AddChild( new FuncGetPresenceInfo() );
            AddChild( new FuncGetRecentPlayers());

            //stress tests
            AddStressChildWithPriority( typeof( GetFriends ),         50 );
            AddStressChildWithPriority( typeof( GetFriendsEx ),       50 );
            AddStressChildWithPriority( typeof( GetCachedFriends ),   30 );
            AddStressChildWithPriority( typeof( GetCachedFriendsEx ), 30 );
            AddStressChildWithPriority( typeof( GetGamertags ),       20 );
            AddStressChildWithPriority( typeof( GetXUIDs ),           20 );
            AddStressChildWithPriority( typeof( GetPresInfo ),        10 );
            AddStressChildWithPriority( typeof( GetRecentPlayers),    10 );
            AddStressChildWithPriority( typeof( LogonOrOff ),         7  );
            AddStressChildWithPriority( typeof( AddBuddy ),           2  );
        }

        ////////////////////////////////////////////////
		// Initialize Stress
		//
		//	Setup for Stress Suite
		//
		public override void PreRun(RUN_TYPE runType)
		{
            if (runType != RUN_TYPE.STRESS)
            {
                return;
            }

			//PWT.Initialize();
			PWT.InitializeStress();
		}

        private void AddStressChildWithPriority(System.Type t, int priority)
        {
            TestNode n=TestNode.ConstructFromType(t);
            AddChild(n, false, true);
            n.StressData.Priority=priority;
        }

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Presence\Test\presencetest.cs ===
using System;
using System.Collections;
//using System.Text;
//using System.IO;
//using System.Net;
//using System.Web;
//using System.Web.Services;
//using System.Web.Services.Protocols;
//using System.Xml;
using System.Threading;

using ServerTestFramework;
//using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.GI;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.Notification;
using ServerTestFramework.Utilities;
//using xonline.common.config;
using xonline.common.diagnostics;
using xonline.common.nUnit;
//using xonline.common.service;
//using xonline.common.utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.Presence;


namespace PresWidgetTest
{
    public class PresenceDVTs : TestNode
    {            
        public const uint    c_titleId = 0x00004d2;
        public const uint    c_pongTitleId = 0xFFFF400A;
        public byte[]        c_publisherWebId1 = new byte[8] { 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8 };
       
        [TestCase, Description("Basic Get Presence DVT")]
        class TestGetPresenceDVT : TestBase
        {
            override protected void Execute()
            {
                WCPresence      pService = new WCPresence();
                PNUser c = PWT.Friends.CreateLinkedUser(false); // Don't logon
                Thread.Sleep(3000);
                         
                uint                validSeconds;
                FriendsInfo         friends;
            
                Console.WriteLine("Calling Presence.GetFriends");
                Console.WriteLine();

                friends = pService.GetFriends(c.WebId, c.Name, out validSeconds);

                Console.WriteLine("found " + friends.OnlineFriends.Length + " friends online, and " + friends.OfflineFriends.Length + " friends offline.");
                Console.WriteLine();

                ResultCode = TEST_RESULTS.PASSED;
            }     
        }

        [TestCase, Ignore, Description("Full Get Presence DVT")]
        class TestFriendsPresence : TestBase
        {
            override protected void Execute()
            {
                // 
                // Setup friend relationship
                //
                FriendsCommon fc = new FriendsCommon();

                PNUser          user1    = fc.CreateLinkedUser( false );
                PNUser          user2    = fc.CreateLinkedUser( false );
                PNUser.BuddyInfo bi; 

                // Create a xenon xbox client
                PNXbox xbox1 = new PNXbox(true);
                fc.LogonUser(user1, xbox1);

                // Create a xenon xbox client
                PNXbox xbox2 = new PNXbox(true);
                fc.LogonUser(user2, xbox2);


                fc.MakeFriend( user1, user2 );

                user1.ProcessNotifications();
                bi= user1.GetBuddyInfo(user2.UserId);

                // pi now contains the Information about user2 according to user1
                Assert.IsTrue(null != bi.RichPresenceData, "Xenon Presence ListItem for user 2 is NULL, when user 1 is a Xenon client and a Xenon Presence2Item is expected.");  
                Assert.IsTrue(user1.GetBuddyInfo(user2.UserId).RichPresenceData.RichPresenceStringLength == 0, "Presence DataLen for user 2 is not 8 length, even though it has not yet been set ");

                // 
                // Set state and fetch the Rich Presence data from the other user
                //
                Console.WriteLine("setting rich presence title data for user 2.");

                user2.State = user2.State | XonPresNoti.P_STATE_ENUM_AWAY;
                user2.State &= ~XonPresNoti.P_STATE_MASK_CLOAKED;
                user2.Xbox.ChangeTitle(c_pongTitleId, 0, 0);
                GIBlob gi = new GIBlob();
                gi.TitlePresence = 0;
                gi.AddContext(new GIContext(0x0000800B, 0)); // 0 = single player, 1 = multi player
                gi.AddContext(new GIContext(1, 2)); // 0 = small, 1 = medium, 2 = large
                gi.AddContext (new GIContext(20, 1));     // 0 = slow, 1 = fast
                user2.SetTitleData(gi.GetBytes());

                // Wait for the notification. Can't wait for notif since they are autoprocessed.
                Thread.Sleep(2000);
                user1.ProcessNotifications();
                bi = user1.GetBuddyInfo(user2.UserId);

                // pi now contains the Information about user2 according to user1
                Assert.IsTrue(null != bi.RichPresenceData, "Xenon Presence ListItem for user 2 is NULL, when user 1 is a Xenon client and a Xenon Presence2Item is expected.");

                Assert.IsTrue(bi.RichPresenceData.RichPresenceStringLength != 0, "Presence RichPresenceLen for user 2 is 0 length, even though it has been set to a value. Check for errors on the server");
                Assert.IsTrue(bi.RichPresenceData.RichPresenceString.Length != 0, "Presence RichPresence.Length for user 2 is 0 length, even though it has been set to a value. Check for errors on the server");

				String rpString = bi.RichPresenceData.RichPresenceString;
                Console.WriteLine("user 1 received rich presence string for user 2: " + rpString);


                // 
                // Check presence with the widget
                //
                WCPresence      pService = new WCPresence();
                          
                uint                validSeconds;
                FriendsInfo         friends;
            
                Console.WriteLine("Calling Presence.GetFriends");
                Console.WriteLine();            

                friends = pService.GetFriends(user1.WebId, user1.Name, out validSeconds);

				Assert.IsTrue(friends.OnlineFriends.Length == 1, "Found 1 online friend.");
				Assert.IsTrue(friends.OfflineFriends.Length == 0, "No friends offline.");

                FriendEx[] friendsEx;
                Console.WriteLine("Calling Presence.GetFriends Ex");
                friendsEx = pService.GetFriendsEx(user1.UserId, 1, out validSeconds);
				Assert.IsTrue(friendsEx[0].RichPresenceString == rpString, "Webcall gives the correct rich presence string.");
				
                ResultCode = TEST_RESULTS.PASSED;
            }
        }             
    }        
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Presence\Test\Stress.cs ===
using System;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.WebWidget;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.Web.Presence;

namespace PresWidgetTest
{
    [StressInstantiate]
	public class GetFriends : TestBase
	{
		protected override void Execute()
		{
			StressUser user = PWT.StressUsers.GetRandom();	
			if( user.HasLoggedOnOnce )
			{
				user.GetFriends();
				ResultCode = TEST_RESULTS.PASSED;
			}
			else
			{
				user.ChangeLogonState();
				ResultCode = TEST_RESULTS.NOT_EXECUTED;
			}
		}
	}

    [StressInstantiate]
    public class GetFriendsEx : TestBase
	{
		protected override void Execute()
		{
			StressUser user = PWT.StressUsers.GetRandom();	
			if( user.HasLoggedOnOnce )
			{
				user.GetFriendsEx();
				ResultCode = TEST_RESULTS.PASSED;
			}
			else
			{
				user.ChangeLogonState();
				ResultCode = TEST_RESULTS.NOT_EXECUTED;
			}
		}
    }

    [StressInstantiate]
	public class GetCachedFriends : TestBase
	{
		protected override void Execute()
		{
			StressUser user;
			if( ! PWT.StressUsers.GetCached( out user ) )
			{
				user = PWT.StressUsers.GetRandom();	
				if( user.HasLoggedOnOnce )
				{
					user.GetFriends();
					ResultCode = TEST_RESULTS.PASSED;
				}
				else
				{
					user.ChangeLogonState();
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
				}
			}
			user.GetFriends();

			ResultCode = TEST_RESULTS.PASSED;
		}
	}

    [StressInstantiate]
    public class GetCachedFriendsEx : TestBase
	{
		protected override void Execute()
		{
			StressUser user;
			if( ! PWT.StressUsers.GetCached( out user ) )
			{
				user = PWT.StressUsers.GetRandom();	
				if( user.HasLoggedOnOnce )
				{
					user.GetFriendsEx();
					ResultCode = TEST_RESULTS.PASSED;
				}
				else
				{
					user.ChangeLogonState();
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
				}
			}
			user.GetFriendsEx();

			ResultCode = TEST_RESULTS.PASSED;
		}
    }

    [StressInstantiate]
    public class GetRecentPlayers : TestBase
    {
        protected override void Execute()
        {
            StressUser user = PWT.StressUsers.GetRandom();
            if (user.HasLoggedOnOnce)
            {
                user.GetRecentPlayers();
                ResultCode = TEST_RESULTS.PASSED;
            }
            else
            {
                user.ChangeLogonState();
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
            }
        }
    }

    [StressInstantiate]
    public class GetPresInfo : TestBase
	{
		protected override void Execute()
		{
			StressUser user= PWT.StressUsers.GetRandom();
			user.GetPresInfo();

			ResultCode = TEST_RESULTS.PASSED;
		}
    }

    [StressInstantiate]
    public class GetGamertags : TestBase
	{
		protected override void Execute()
		{
			StressUser user= PWT.StressUsers.GetRandom();
			user.GetGamertags();

			ResultCode = TEST_RESULTS.PASSED;
		}
    }

    [StressInstantiate]
    public class GetXUIDs : TestBase
	{
		protected override void Execute()
		{
			StressUser user= PWT.StressUsers.GetRandom();
			user.GetXUIDs();

			ResultCode = TEST_RESULTS.PASSED;
		}
    }

    [StressInstantiate]
    public class LogonOrOff : TestBase
	{
		protected override void Execute()
		{
			StressUser user= PWT.StressUsers.GetRandom();
			user.ChangeLogonState();

			ResultCode = TEST_RESULTS.PASSED;
		}
	}

    [StressInstantiate]
	public class AddBuddy : TestBase
	{
		protected override void Execute()
		{
			StressUser user;
			do
			{
				user = PWT.StressUsers.GetRandom();
			}
			while( ! user.AddABuddy() );

			ResultCode = TEST_RESULTS.PASSED;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Presence\Test\StressUser.cs ===
// StressUser.cs
//
//	Wrapper for stress related state of a PNUser
//

using System;
using System.Collections;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.WebWidget;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Web.Presence;

namespace PresWidgetTest
{
	public class StressUser : PNUser
	{
		// Timing variables used to keep from getting ahead of Web Cache
		public static TimeSpan PropDelay = new TimeSpan( 0, 0, 30 );
		public        DateTime LastMod   = DateTime.Now.Subtract( PropDelay );

		public static TimeSpan ReuseDelay    = new TimeSpan( 0, 0, (int)(PWT.CacheExpDelay + 1) );
		public        DateTime LastGetFriend = DateTime.Now.Subtract( ReuseDelay );
        public        DateTime LastGetRecentPlayers = DateTime.Now.Subtract(ReuseDelay);

		public bool HasLoggedOnOnce { get{ return bLoggedOnOnce; }}
		bool bLoggedOnOnce = false;

		// List User belongs too
		StressUserList Parent;

		////////////////////////////////////////////////
		// Ctor 
		//
		public StressUser( PuidName puidName, StressUserList parent ) : base( puidName ) 
		{
			Parent = parent;
		}

		////////////////////////////////////////////////
		// GetFriends
		//
		public bool GetFriends()
		{
			bool done = false;
			if( Monitor.TryEnter( this, 0 ) )
			{
				try
				{
					if( LastMod.Add( PropDelay ) < DateTime.Now )
					{
						WebFriendData wf = PWT.GetWebFriends( this );
						LastGetFriend = DateTime.Now;
						Parent.PutWebAlive( this );

						// TBD!! add validation
						// when it comes to buddies, try to grab then to check but if their locked don't bother.
						done = true;
					}
				}
				finally
				{
					Monitor.Exit( this );
				}
			}
			return done;
		}

        ////////////////////////////////////////////////
		// GetFriendsEx
		//
		public bool GetFriendsEx()
		{
			bool done = false;
			if( Monitor.TryEnter( this, 0 ) )
			{
				try
				{
					if( LastMod.Add( PropDelay ) < DateTime.Now )
					{
						FriendEx [] friends = PWT.GetFriendsEx( this );
						LastGetFriend = DateTime.Now;
						Parent.PutWebAlive( this );

						// TODO!! add validation
						done = true;
					}
				}
				finally
				{
					Monitor.Exit( this );
				}
			}
			return done;
        }

        ////////////////////////////////////////////////
        // GetRecentPlayers
        //
        public bool GetRecentPlayers()
        {
            bool done = false;
            if (Monitor.TryEnter(this, 0))
            {
                try
                {
                    if (LastMod.Add(PropDelay) < DateTime.Now)
                    {
                        RecentPlayer[] rp = PWT.GetRecentPlayers(this);
                        LastGetRecentPlayers = DateTime.Now;
                        Parent.PutWebAlive(this);

                        // TBD!! add validation
                        // when it comes to buddies, try to grab then to check but if their locked don't bother.
                        done = true;
                    }
                }
                finally
                {
                    Monitor.Exit(this);
                }
            }
            return done;
        }

        ////////////////////////////////////////////////
		// GetPresenceInfo
		//
		public bool GetPresInfo()
		{
			bool done = false;
			if( Monitor.TryEnter( this, 0 ) )
			{
				try
				{
					ServerTestFramework.Web.Presence.PresenceInfo pInfo = PWT.GetPresInfo( this );
                    
                    // TODO:!! add validation
                    done = true;

                    //well here's a start...
                    if (pInfo.XUID==0)
                    {
                        throw new System.Exception("uid in presense info is 0");
                    }

				}
				finally
				{
					Monitor.Exit( this );
				}
			}
			return done;
        }

        ////////////////////////////////////////////////
		// GetGamertags
		//
		public bool GetGamertags()
		{
			bool done = false;
			if( Monitor.TryEnter( this, 0 ) )
			{
				try
				{
					string [] gamertags = PWT.GetGamertags( this );
                    // TODO!! add validation
					done = true;
				}
				finally
				{
					Monitor.Exit( this );
				}
			}
			return done;
        }

        ////////////////////////////////////////////////
		// GetXUIDs
		//
		public bool GetXUIDs()
		{
			bool done = false;
			if( Monitor.TryEnter( this, 0 ) )
			{
				try
				{
					ulong [] XUIDs = PWT.GetXUIDs( );
                    // TODO!! add validation
					done = true;
				}
				finally
				{
					Monitor.Exit( this );
				}
			}
			return done;
        }

		////////////////////////////////////////////////
		// Change Logon State
		//
		public bool ChangeLogonState()
		{
			bool done = false;
			if( Monitor.TryEnter( this, 0 ) )
			{
				try
				{
					if( ! LoggedOn )
					{
						PWT.Friends.LogonUser( this  );
                        if (!bLoggedOnOnce)
                        {
                            AddAffiliates();
                        }
						bLoggedOnOnce = true;
						LastMod = DateTime.Now;
						done = true;
					}
					else
					{
						PWT.Friends.LogoffUser( this );
						LastMod = DateTime.Now;
						done = true;
					}
				}
				finally
				{
					Monitor.Exit( this );
				}
			}	
			return done;
		}

        private void AddAffiliates()
        {
            ushort Encountered = 50;

            AffiliateState state = new AffiliateState(this);
            ArrayList toAdd = new ArrayList();
            for (int i = 0; i < Encountered; i++)
            {
                StressUser su = PWT.StressUsers.GetRandom();
                while (UserId == su.UserId)
                {
                    su = PWT.StressUsers.GetRandom();
                }
                toAdd.Add(su);
                if (toAdd.Count == XonPresNoti.X_ADD_AFFILIATE_MAX)
                {
                    state.Add((PNUser[])toAdd.ToArray(typeof(PNUser)), (uint)AffiliateFlags.Encountered, this.Xbox.TitleId);
                    toAdd.Clear();
                }
            }

            if (toAdd.Count > 0)
                state.Add((PNUser[])toAdd.ToArray(typeof(PNUser)), (uint)AffiliateFlags.Encountered, this.Xbox.TitleId);
        }

		////////////////////////////////////////////////
		// Add a Buddy
		//
		public bool AddABuddy()
		{
			bool done = false;
			if( Monitor.TryEnter( this, 0 ) )
			{
				try
				{
					StressUser requestee;
					do 
					{
						requestee = Parent.GetRandom();
					} 
					while( ! requestee.BeABuddy( this ) );
					done = true;
				}
				finally
				{
					Monitor.Exit( this );
				}
			}
			return done;
		}				
				
		////////////////////////////////////////////////
		// Be A Buddy
		//
		bool BeABuddy( StressUser requestor )
		{
			bool done = false;
			if( Monitor.TryEnter( this, 0 ) ) 
			{
				try
				{
					PWT.Friends.MakeFriend( requestor, this );
					LastMod           = DateTime.Now;
					requestor.LastMod = DateTime.Now;
					done = true;
				}
				finally
				{
					Monitor.Exit( this );
				}
			}
			return done;
		}
	}

	////////////////////////////////////////////////
	// Stress User List 
	//	Manages the list of Stress Users
	//
	public class StressUserList
	{
		BulkUserSet userSet;
		static int myCount;
		StressUser[] Users = new StressUser[ myCount ];
		Queue Cached = Queue.Synchronized( new Queue() );

		static Random Rand = new Random();

		public StressUserList()
		{
			userSet = STFLiveGlobal.GetUserSet("xenon");
			myCount = (int)userSet.Count;
			CPUIDList puidList = userSet.GetPuidList();
			//UodbWS.PopulatePuidListFromNames( userSet.Prefix, userSet.Base, userSet.Count, ref puidList );


			for( int i = 0; i < puidList.GetSize(); ++i )
			{
				puidList[i].WebId = WCUserAccount.PuidToWebID( puidList[i].Puid );
			}

            if (Users==null || Users.Length<puidList.GetSize()) //stress was crashing here because Users array empty... this is a fix to that
            {
                Users=new StressUser[puidList.GetSize()];
            }

			for( int i = 0; i < puidList.GetSize(); ++i )
			{
				Users[i] = new StressUser( puidList[i], this );
			}
		}

		public StressUser this[ int index ]
		{
			get{ return( Users[ index ] ); }
		}

		public StressUser GetRandom()
		{
			lock( this )
			{
				return( Users[ Rand.Next( 0, (int)userSet.Count - 1 ) ] );
			}
		}

 		public void PutWebAlive( StressUser user )
		{
			Cached.Enqueue( user );
		}
		
		public bool GetCached( out StressUser user)
		{
			user = null;

			lock( this )
			{
				if( Cached.Count > 0 )
				{
					user = (StressUser) Cached.Dequeue();
					if( user.LastGetFriend.Add( StressUser.ReuseDelay ) > DateTime.Now )
					{
						user = null;
					}
				}
			}

			return( user != null );
		}
	}	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Presence\Test\TestGobals.cs ===
// TestGlobals.cs
//
//	Stuff that is initialized with the suite and available to all cases
//

using System;
using System.Xml;
using System.Threading;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.Presence;

namespace PresWidgetTest
{
	////////////////////////////////////////////////
	// PWT
	//	Keeper of global test data
	//
	class PWT
	{
		// Friend utility class
		public static FriendsCommon Friends = null;

		// Web cache widget wrappers
		public static WCPresence WcPN = null;
        public static WCUserAccount WcUACS = null;

		// Good linked user for invalid SOAP cases
		public static PNUser GoodLink;

		// Reusable Buddy Groups
		public static BuddyGroup OneBudOnSame;
		public static BuddyGroup OneBudOnDiff;
		public static BuddyGroup OneBudOnEach;
		public static BuddyGroup HundredBuds;
		public static BuddyGroup TwentyBuds; 

		// Stress Users
		public static StressUserList StressUsers;

		// Flag for initializing Users
		public static bool fInit = false;

		// Time it takes a presence cache entry to refresh 
		//	This should be the same as:
		//		FriendsCacheExpirationSeconds in wcpresence.ini on cache server
		public static uint CacheExpDelay = 120; // seconds for PresWidget to relead

        static PWT()
        {
            // Let the fake SG know where to send state updates
            ServerTestFramework.LiveService.FakeSG.GlobalFakeSG.FakeSG.SetStateEndpoint(Global.XEnv.GetVirtualInterface(xonline.common.config.VirtualInterface.xpnfd_presence).ToString());

            // set the ReceiveTimeout and SendTimeout for TCP and UDP connection
            FDTransaction.sReceiveTimeOut = 65000;

            Friends = new FriendsCommon();
            WcPN = new WCPresence();
            WcUACS = new WCUserAccount();
        }

		///////////////////////////////////////////////////////////////////////
		// Initialize
		//
		public static void Initialize()
		{
			if(!fInit)
			{
				// Create pools of linked users and unlinked users to be their buddies
				// Note: once the users have been created once they will be just quickly pulled
				// from the UODB.  The assumption that they will always come back in the same 
				// order is important because the buddy relationships are set up based on that.
				CPUIDList userList  = Friends.UACS.CreatePrivateUsers( "PwcTLnk", 50, true );
				CPUIDList buddyList = Friends.UACS.CreatePrivateUsers( "PwcTBud", 500 );
	
				// Sort the rest into buckets depending on what server their PUID hases to
				Stack[] userPools;
				userList.SortByPuid();
				SortUsersByHash( userList, out userPools );
			
				Stack[] buddyPools;
				buddyList.SortByPuid();
				SortUsersByHash( buddyList, out buddyPools );
	
				// Setup Users and Buddy Groups
				// Note: If anything is added or changed it could conflict with 
				// previously setup relationships. Always add stuff to the end or be 
				// starting with a clean Profile DB.

				GoodLink = (PNUser) userPools[0].Pop();

				OneBudOnSame = new BuddyGroup( userPools, buddyPools, 1, 0 );
				OneBudOnDiff = new BuddyGroup( userPools, buddyPools, 0, 1 );
				OneBudOnEach = new BuddyGroup( userPools, buddyPools, 1, 1 );
				HundredBuds  = new BuddyGroup( userPools, buddyPools, 50, 50 );
				TwentyBuds   = new BuddyGroup( userPools, buddyPools, 10, 10 );

				fInit = true;
			}
		}

		public static WebFriendData GetWebFriends(PNUser user)
		{
			uint validSeconds;
			ServerTestFramework.Web.Presence.FriendsInfo fi = WcPN.GetFriends(user.WebId, user.Name, out validSeconds);
			if(null == fi)
			{
				throw new UnexpectedTestResultException("GetFriends failed, FriendsInfo was null");
			}
			return new WebFriendData(fi, validSeconds);
		}

		public static FriendEx [] GetFriendsEx(PNUser user)
		{
			uint validSeconds;
			FriendEx [] myFriends = WcPN.GetFriendsEx(user.UserId, 1, out validSeconds);
			if(null == myFriends)
			{
				throw new UnexpectedTestResultException("GetFriendsEx failed, FriendEx was null");
			}
			return myFriends;
		}

        public static RecentPlayer[] GetRecentPlayers(PNUser user)
        {
            RecentPlayer[] rp = WcPN.GetRecentPlayers(user.UserId, 100, 1);
            if (null == rp)
            {
                throw new UnexpectedTestResultException("GetRecentPlayers failed, RecentPlayers was null");
            }
            return rp;
        }

        public static ServerTestFramework.Web.Presence.PresenceInfo GetPresInfo(PNUser user)
		{
			uint validSeconds;
			ServerTestFramework.Web.Presence.PresenceInfo pInfo = WcPN.GetPresenceInfo(user.UserId, user.UserId+1, 1, out validSeconds);
			if(null == pInfo)
			{
				throw new UnexpectedTestResultException("GetPresenceInfo failed, pInfo was null");
			}
			return pInfo;
        }

        public static string [] GetGamertags(PNUser user)
		{
            ulong [] XUIDs = new ulong[100];

            for(uint i = 0; i < XUIDs.Length; i++)
            {
                // This will overflow on the edges of the user list
                // But that's ok, negative test cases are good right?
                XUIDs[i] = user.UserId+i;
            }

			string [] gamertags = WcPN.GetGamertagsFromXUIDS(XUIDs);
			if(null == gamertags)
			{
				throw new UnexpectedTestResultException("GetGamertags failed, gamertags was null");
			}
			return gamertags;
        }


        public static ulong [] GetXUIDs()
		{
            string [] gamertags = new string[100];

            for(uint i = 0; i < gamertags.Length; i++)
            {
                gamertags[i] = "webuser"+i;
            }

			ulong [] XUIDs = WcPN.GetXUIDSFromGamertags(gamertags);
			if(null == XUIDs)
			{
				throw new UnexpectedTestResultException("GetXUIDs failed, XUIDs was null");
			}
			return XUIDs;
        }

		///////////////////////////////////////////////////////////////////////
		// Sort Users By Hash
		//	Create two buckets of users: One for PresINh001, and one for the others (if any)
		//
		public static void SortUsersByHash( CPUIDList users, out Stack[] pools )
		{
			pools = new Stack[ 2 ];

			int listSize = users.GetSize();

			pools[0] = new Stack( listSize/2 );
			pools[1] = new Stack( listSize - (listSize/2) );
			int i = 0;
			while( i <= listSize/2 )
			{
				pools[0].Push( new PNUser( users[ i++ ] ) );
			}
			while( i < listSize )
			{
				pools[1].Push( new PNUser( users[ i++ ] ) );
			}

			ConsoleX.ClearLine();
			ConsoleX.WriteLine( "Sorted "+listSize+" Users into hash pools, Sizes: "+pools[0].Count+","+pools[1].Count );
		}

		///////////////////////////////////////////////////////////////////////
		// Initialize Stress
		//
		public static void InitializeStress()
		{
			StressUsers = new StressUserList();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Profile\dll\wcProfilePublicType.cs ===
using System;

namespace xonline.server.webcache.profile.dll 
{
    public class wcAchievement
    {
       public uint uiAchievementId;
       public DateTime dtAchieved;
       public int nFlags;
       public byte byType;
       public int nCred;
       public uint nImageId;
       public string szTitle;
       public string szDescription;
       public string szHowTo;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Profile\test\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Profile\dll\wcProfile.cs ===
using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Web;
using System.Web.Services;
using System.Web.Services.Protocols;
using System.Web.Services.Description;
using System.IO;
using System.Collections;
using System.Collections.Generic;
using System.Xml.Serialization;


using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.protocol;
using xonline.server.webcache.common;
using xonline.common.config;
using xonline.common.installer;


using perf = xonline.server.webcache.profile.dll.WebCacheProfileCounter;

[assembly: XomIisInstallerAttribute( Interface.wcprofile)]
[assembly: ConfigAttribute(xonline.common.config.Component.wcProfile)]

namespace xonline.server.webcache.profile.dll
{
    [WebService(Namespace="http://websvc.xboxlive.com/Profile/")]
    public class Profile : System.Web.Services.WebService
    {
        public const ushort MAX_READ_ACHIEVEMENTS                 = 150;
        public const string HIDDEN_TEXT                           = "HIDDEN"; //the caller needs to unlock the achievement first to see the description
        Utilities m_util = null;

        public Profile()
        {
            try
            {
                //CODEGEN: This call is required by the ASP.NET Web Services Designer
                InitializeComponent();
                CallSource.Check(VirtualInterface.wcprofile);

                string vi = CallSource.Check(VirtualInterface.wcprofile);
                if (vi != VirtualInterface.wcprofile)
                {
                    throw new XboxWebInternalException(XEvent.Id.WEBCACHE_PROFILE_HACK_1, "wcProfile Call Source Check Failed");
                }

                m_util = Utilities.Instance;
            }
            catch (Exception e)
            {
                XEvent.Id eventId = e is ExceptionWithEvent ? ((ExceptionWithEvent)e).EventId : XEvent.Id.WEBCACHE_PROFILE_BUG_1;
                throw new XboxWebInternalException(eventId, e);
            }
        }

        #region Component Designer generated code

        //Required by the Web Services Designer
        private IContainer components = null;

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
        }

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        protected override void Dispose( bool disposing )
        {
            if(disposing && components != null)
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #endregion

        [WebMethod]
        public wcAchievement [] ReadAchievements(ulong ul64Xuid, uint uiTitleID, ushort uslocaleId, ulong ul64ForXuid)
        {
            wcAchievement [] arrRet = null;
            try
            {
                //a couple of verification first
                m_util.CheckAPIAndTitle("Profile.ReadAchievements", uiTitleID, TitlePrivilege.ReadOnly);
                string partnerName = Utilities.GetSubjectName();

                IncrementGlobalRequestCounter(partnerName);

                perf.ctr.ReadAchievementsPerSecond.Increment();
                perf.ctr.ReadAchievementsTotal    .Increment();

                if (null != partnerName)
                {
                    perf.ctr[partnerName].ReadAchievementsPerSecond.Increment();
                    perf.ctr[partnerName].ReadAchievementsTotal    .Increment();
                }

                if (Utilities.IsInvalidGamertag(m_util.LookupGamerTag(ul64Xuid)))
                {
                    throw new XboxWebClientException((uint)ErrorCode.INVALID_CALLER_XUID, ErrorCode.GetErrorDescription(ErrorCode.INVALID_CALLER_XUID));
                }

                if (Utilities.IsInvalidGamertag(m_util.LookupGamerTag(ul64ForXuid)))
                {
                    throw new XboxWebClientException((uint)ErrorCode.INVALID_FOR_XUID, ErrorCode.GetErrorDescription(ErrorCode.INVALID_FOR_XUID));
                }

                if (0 == uslocaleId)
                {
                    uslocaleId = (ushort)Locales.en_US;
                }

                //first enumerates own achievements to determine privilege to view achievement descriptions
                AchievementEnumRequest achievementReq = new AchievementEnumRequest();
                achievementReq.TitleId         = uiTitleID;
                achievementReq.Puid            = ul64Xuid;
                achievementReq.ForPuid         = ul64Xuid;
                achievementReq.LocaleId        = uslocaleId;
                achievementReq.StartingIndex   = 0;
                achievementReq.MaxAchievements = MAX_READ_ACHIEVEMENTS;

                Achievement [] arrAchievementForCaller = GetAchievementsFromFD(achievementReq);

                achievementReq.ForPuid         = ul64ForXuid;

                //now enumerate for user
                Achievement [] arrAchievement          = GetAchievementsFromFD(achievementReq);

                arrRet = ProcessAchievementToReturn(arrAchievementForCaller, arrAchievement);
            }
            catch (FrontDoorNonFatalException e)
            {
                if (e.HResult == HResult.XONLINE_E_STAT_PERMISSION_DENIED)
                {
                    throw new XboxWebClientException((uint)ErrorCode.NO_PERMISSION, ErrorCode.GetErrorDescription(ErrorCode.NO_PERMISSION));
                }
                else
                    throw new XboxWebInternalException(XEvent.Id.WEBCACHE_PROFILE_BUG_2, e);
            }
            catch (XboxWebClientException)
            {
                throw;
            }
            catch (XboxWebException)
            {
                throw;
            }
            catch (Exception e)
            {
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_PROFILE_BUG_3, e);
            }
            finally
            {

            }

            return arrRet;
        }


        [WebMethod]
        public xonline.server.webcache.common.UserSetting [] ReadSettings(ulong ulXuid, uint uiTitleID, ushort usLocaleId, ulong [] arrulForXuid, uint [] arruiSettings)
        {
            xonline.server.webcache.common.UserSetting [] arrRet = null;

            try
            {
                m_util.CheckAPIAndTitle("Profile.ReadSettings", uiTitleID, TitlePrivilege.ReadOnly);
                string partnerName = Utilities.GetSubjectName();

                IncrementGlobalRequestCounter(partnerName);

                perf.ctr.ReadSettingsPerSecond.Increment();
                perf.ctr.ReadSettingsTotal    .Increment();

                if (null != partnerName)
                {
                    perf.ctr[partnerName].ReadSettingsPerSecond.Increment();
                    perf.ctr[partnerName].ReadSettingsTotal    .Increment();
                }

                if (Utilities.IsInvalidGamertag(m_util.LookupGamerTag(ulXuid)))
                {
                    throw new XboxWebClientException((uint)ErrorCode.INVALID_CALLER_XUID, ErrorCode.GetErrorDescription(ErrorCode.INVALID_CALLER_XUID));
                }

                //other verification should be done in common code Read Profile
                arrRet = CommunityUtil.ReadProfile(ulXuid, uiTitleID, arrulForXuid, arruiSettings); //NOTE: Locale is currently not supported in version 1 of this web service
            }
            catch (XboxWebClientException)
            {
                throw;
            }
            catch (XboxWebException)
            {
                throw;
            }
            catch (Exception e)
            {
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_PROFILE_BUG_4, e);
            }
            finally
            {

            }
            return arrRet;
        }


        //This is where we hide the achievement description if the caller did not achieve it yet and the achievment is marked hidden
        private wcAchievement [] ProcessAchievementToReturn(Achievement [] arrAchievementsForCaller, Achievement [] arrAchievements)
        {
            List<wcAchievement> listAchivement = new List<wcAchievement>();

            for (int i=0;i<arrAchievements.Length;i++)
            {
                if (((arrAchievements[i].Flags & XOn.XACHIEVEMENT_DETAILS_ACHIEVED) == 0) &&
                    ((arrAchievements[i].Flags & XOn.XACHIEVEMENT_DETAILS_ACHIEVED_ONLINE) == 0)
                    )
                    continue; //not achieved

                wcAchievement achievement = new wcAchievement();

                achievement.nCred           = arrAchievements[i].Cred;
                achievement.byType          = arrAchievements[i].Type;
                achievement.nFlags          = arrAchievements[i].Flags;
                achievement.nImageId        = arrAchievements[i].ImageId;
                achievement.uiAchievementId = arrAchievements[i].AchievementId;
                achievement.dtAchieved      = arrAchievements[i].Achieved;

                if (((achievement.nFlags & XOn.XACHIEVEMENT_DETAILS_SHOWUNACHIEVED)!=0) || AchievementExistAndAchieved(arrAchievementsForCaller, achievement.uiAchievementId))
                {
                    achievement.szDescription = arrAchievements[i].Description;
                    achievement.szTitle       = arrAchievements[i].Title;
                    achievement.szHowTo       = arrAchievements[i].HowTo;
                }
                else
                {
                    achievement.szDescription = HIDDEN_TEXT;
                    achievement.szTitle       = HIDDEN_TEXT;
                    achievement.szHowTo       = HIDDEN_TEXT;
                }

                listAchivement.Add(achievement);
            }

            return listAchivement.ToArray();
        }

        private bool AchievementExistAndAchieved(Achievement [] arrAchievements, uint uiAchievementID)
        {
            foreach (Achievement achievement in arrAchievements)
            {
                if (achievement.AchievementId == uiAchievementID)
                {
                    if (((achievement.Flags & XOn.XACHIEVEMENT_DETAILS_ACHIEVED) != 0) ||
                        ((achievement.Flags & XOn.XACHIEVEMENT_DETAILS_ACHIEVED_ONLINE) != 0)
                       )
                    {
                        return true;
                    }
                }
            }

            return false;
        }

        //This will retrieve all types of achievement whether they are achieved or not and will restrict its count to usMaxAchievement
        private Achievement [] GetAchievementsFromFD(AchievementEnumRequest req)
        {
            MemoryStream ms = new MemoryStream();
            BinaryWriter bw = new BinaryWriter(ms);

            req.WriteStream(bw);
            ms.Close();

            IVirtualInterfaceInfo vii = Config.GetVirtualInterface(VirtualInterface.progressfd_int, xonline.common.config.Site.same);

            Utilities.RequestInfo requestInfo = Utilities.GetRequestInfo();
            HTTPAuthData authData   = new HTTPAuthData(requestInfo.ClientPort, requestInfo.ClientIP, requestInfo.qwRequestID, req.Puid, req.TitleId, (uint)XOService.Progress, 0);

            xonline.core.user.UserPrivileges userPriv = new xonline.core.user.UserPrivileges(req.Puid);
            if (userPriv[XOn.XPRIVILEGE_PROFILE_VIEWING])
            {
                authData.SetPrivilege((byte)XOn.XPRIVILEGE_PROFILE_VIEWING);
            }
            else if (userPriv[XOn.XPRIVILEGE_PROFILE_VIEWING_FRIENDS_ONLY])
            {
                authData.SetPrivilege((byte)XOn.XPRIVILEGE_PROFILE_VIEWING_FRIENDS_ONLY);
            }

            byte[]       repBytes = m_util.FrontDoorRequest(
                                                                ConstructURL(vii, req.GetXRL()),
                                                                authData,
                                                                (uint)XOService.Progress,
                                                                0,
                                                                ms.ToArray()
                                                            );

            BinaryReader br                  = new BinaryReader(new MemoryStream(repBytes));
            AchievementEnumResponse rep      = new AchievementEnumResponse();

            rep.ReadStream(br);

            return rep.Achievements;

        }

        private string ConstructURL(IVirtualInterfaceInfo vii, string szXRL)
        {
            return string.Format("http://{0}:{1}{2}", vii.IPAddressString, vii.Port, szXRL);
        }

        private void IncrementGlobalRequestCounter(string szPartnerName)
        {
            perf.ctr.RequestsPerSecond                .Increment();
            perf.ctr.RequestsTotal                    .Increment();

            if (szPartnerName != null)
            {
                perf.ctr[szPartnerName].RequestsPerSecond                .Increment();
                perf.ctr[szPartnerName].RequestsTotal                    .Increment();
            }
        }

    }

    public static class ErrorCode
    {
        public const uint NO_PERMISSION        = 0xffffffff;
        public const uint INVALID_CALLER_XUID  = 0xfffffffe;
        public const uint INVALID_FOR_XUID     = 0xfffffffd;

        public static string GetErrorDescription(uint uiErrorCode)
        {
            string szReturn = "UNKNOWN_ERROR";
            switch (uiErrorCode)
            {
                case NO_PERMISSION:
                    szReturn =  "NO_PERMISSION";
                    break;

                case INVALID_CALLER_XUID:
                    szReturn =  "INVALID_CALLER_XUID";
                    break;

                case INVALID_FOR_XUID:
                    szReturn =  "INVALID_FOR_XUID";
                    break;

                default:
                    break;
            };

            return szReturn;
        }
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Profile\test\AchievementWidgetTests.cs ===
/*

AchievementsWidgetTests.cs : Tests for the Achievements widget.

*/

#define CREATE_FRIENDS

using System;
using System.Collections;
using System.Threading;
using System.Web.Services.Protocols;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.UserSettings;
using ServerTestFramework.Utilities;
using ServerTestFramework.Web.Profile;
using ServerTestFramework.WebWidget;
using xonline.common.config;

using UserSetting=ServerTestFramework.LiveService.UserSettings.UserSetting;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;
namespace WCProfileTest
{
    [TestGroup, AsyncGroup(1, 0), Owner("KKline"), TestFrequency("Regression"), TestCasePriority(3)]
    public class ReadAchievementsTestGroup : TestNode
    {
        static readonly string SoapExcepStarter = "Server was unable to process request.";
        static readonly uint goodTitleID = 0xFFFF07A3;
        static readonly uint badTitleID = 0xABCDEF12;
        static readonly uint lockedTitleID = 0x4D530064;
        static readonly uint userCreationWaitTime = 30000;
        static readonly uint achievementsAddedWaitTime = 30000;
        static readonly ulong badPuid = 0x0123456789ABCDEF;
        static readonly ushort LOCALE_EN_US = 1033;
        static readonly ushort LOCALE_FR_FR = 1036;
        static readonly ushort LOCALE_EN_AU = 3081;
        static readonly ushort LOCALE_FR_CA = 3084;
        static readonly ushort LOCALE_DA_DK = 1030;
        static readonly ushort[] LOCALE_DASH_TO_WIN = { 1033, 1041, 1031, 1036, 3082, 1040, 1042, 31748, 2070 };

        const uint XACHIEVEMENT_DETAILS_SHOWUNACHIEVED = 0x00000008;
        const uint XACHIEVEMENT_DETAILS_ACHIEVED = 0x00020000;

        WCProfile profile;
        static XeUser[] callers, callerFriends, targets, achievers;
        uint[][] achiever_ments;

        [TestGroupSetup]
        public void Setup()
        {
            // Let the fake SG know where to send state updates   
            ServerTestFramework.LiveService.FakeSG.GlobalFakeSG.FakeSG.SetStateEndpoint(Global.XEnv.GetVirtualInterface(xonline.common.config.VirtualInterface.xpnfd_presence).ToString());

            profile = new WCProfile();

            /*
            UacsCommon2 uc2 = new UacsCommon2();
            userA = uc2.CreateUser(UserType.Gold);
            userB = uc2.CreateUser(UserType.Gold);
            */

            // Create storage areas once
            if (callers == null)
            {
                callers = new XeUser[4];
                callerFriends = new XeUser[4];
                targets = new XeUser[6];
                achievers = new XeUser[5];
                achiever_ments = new uint[5][];
            }

            ////////////////////////////////////////////////
            // Create All Users, then wait for cache time //
            ////////////////////////////////////////////////

            const int account_tries = 2;

            // Create both sets of callers, all Gold
            // Adult Callers...
            if (null == callers[0])
            {
                if (null == (callers[0] = CreateUserRetry(account_tries)))
                    throw new Exception("Creating User: adult, caller[0], non-friend failed");
            }
            if (null == callerFriends[0])
            {
                if (null == (callerFriends[0] = CreateUserRetry(account_tries)))
                    throw new Exception("Creating User: adult, caller[0], friend failed");
            }

            // Child Callers (All, change priveleges later)
            for (int i = 1; i < 4; ++i)
            {
                if (null == callers[i])
                {
                    if (null == (callers[i] = CreateChildRetry(account_tries)))
                        throw new Exception("Creating User: child, caller[" + i + "], non-friend failed");
                }
                if (null == callerFriends[i])
                {
                    if (null == (callerFriends[i] = CreateChildRetry(account_tries)))
                        throw new Exception("Creating User: child, caller[" + i + "], friend failed");
                }
            }

            // Create targets, all Gold as well
            for (int i = 0; i < 3; ++i)
            {
                if (null == targets[i])
                {
                    if (null == (targets[i] = CreateUserRetry(account_tries)))
                        throw new Exception("Creating User: adult, target[" + i + "] failed");
                }
                if (null == targets[i + 3])
                {
                    if (null == (targets[i + 3] = CreateChildRetry(account_tries)))
                        throw new Exception("Creating User: child, target[" + (i + 3) + "] failed");
                }
            }

            // Create achievers
            for (int i = 0; i < 5; ++i)
            {
                if (null == achievers[i])
                {
                    if (null == (achievers[i] = CreateUserRetry(account_tries)))
                        throw new Exception("Creating User: adult, achiever[" + i + "] failed");
                }
            }

            new SleepInfo("Post user creation cache wait", userCreationWaitTime);
            //Thread.Sleep(userCreationWaitTime);

            //////////////////////////////////////////////////////////////////////////
            // Update Privileges, Settings, Friends relationships, and Achievements //
            //////////////////////////////////////////////////////////////////////////

            ArrayList allPrivsSet = new ArrayList();
            for (int i = UserPrivileges.XONLINE_PRIVILEGE_MIN; i <= UserPrivileges.XONLINE_PRIVILEGE_MAX; ++i)
            {
                if (i == 236) continue;  //Priv 236 is currently not present.
                allPrivsSet.Add(i);
            }

            // Give these children all access (to profiles)
            {
                ArrayList tempGrant = new ArrayList(allPrivsSet);
                tempGrant.Remove(UserPrivileges.XONLINE_XPRIVILEGE_PROFILE_VIEWING_FRIENDS_ONLY);
                ArrayList tempRestrict = new ArrayList();
                tempRestrict.Add(UserPrivileges.XONLINE_XPRIVILEGE_PROFILE_VIEWING_FRIENDS_ONLY);

                UserSetup.UpdatePrivileges(callers[1], tempGrant, tempRestrict);
                UserSetup.UpdatePrivileges(callerFriends[1], tempGrant, tempRestrict);
            }

            // Limit these children to only friends
            {
                ArrayList tempGrant = new ArrayList(allPrivsSet);
                tempGrant.Remove(UserPrivileges.XONLINE_XPRIVILEGE_PROFILE_VIEWING);
                ArrayList tempRestrict = new ArrayList();
                tempRestrict.Add(UserPrivileges.XONLINE_XPRIVILEGE_PROFILE_VIEWING);

                UserSetup.UpdatePrivileges(callers[2], tempGrant, tempRestrict);
                UserSetup.UpdatePrivileges(callerFriends[2], tempGrant, tempRestrict);
            }

            // Don't let these children see any profiles
            {
                ArrayList tempGrant = new ArrayList(allPrivsSet);
                tempGrant.Remove(UserPrivileges.XONLINE_XPRIVILEGE_PROFILE_VIEWING);
                tempGrant.Remove(UserPrivileges.XONLINE_XPRIVILEGE_PROFILE_VIEWING_FRIENDS_ONLY);
                ArrayList tempRestrict = new ArrayList();
                tempRestrict.Add(UserPrivileges.XONLINE_XPRIVILEGE_PROFILE_VIEWING);
                tempRestrict.Add(UserPrivileges.XONLINE_XPRIVILEGE_PROFILE_VIEWING_FRIENDS_ONLY);

                UserSetup.UpdatePrivileges(callers[3], tempGrant, tempRestrict);
                UserSetup.UpdatePrivileges(callerFriends[3], tempGrant, tempRestrict);
            }

            // Restrict access to targets' profiles
            SetPermissions(targets[0].UserPuid, false, false);
            SetPermissions(targets[3].UserPuid, false, false);

            SetPermissions(targets[1].UserPuid, false, true);
            SetPermissions(targets[4].UserPuid, false, true);

            SetPermissions(targets[2].UserPuid, true, false);
            SetPermissions(targets[5].UserPuid, true, false);

            PNUser[] users1 = new PNUser[callerFriends.Length] ;
            PNUser[] users2 = new PNUser[targets.Length];

            //Convert targets and callers to PNUsers to use them in makefriends call.
            for (int i = 0; i < callerFriends.Length; i++)
            {
                PNUser pu = new PNUser(callerFriends[i].Gamertag, callerFriends[i].UserPuid);
                users1[i] = pu;
            }

            for (int i = 0; i < targets.Length; i++)
            {
                PNUser pu = new PNUser(targets[i].Gamertag, targets[i].UserPuid);
                users2[i] = pu;
            }


            // Create friends relationships
#if CREATE_FRIENDS
            for (int i = 0; i < 4; ++i)
            {
                for (int j = 0; j < 6; ++j)
                {
                    FriendsCommon fc = new FriendsCommon();
                    fc.MakeFriend(users1[i], users2[j]);
                }
            }
#endif

            // Make it so everyone has played our title
            // Well, not the friends of the targets
            uint[] titles = new uint[1];
            titles[0] = goodTitleID;

            for (int i = 0; i < 4; ++i)
            {
                UserSetup.AddPlayedTitles(callers[i].UserPuid, titles);
            }

            for (int i = 0; i < 6; ++i)
            {
                UserSetup.AddPlayedTitles(targets[i].UserPuid, titles);
            }

            for (int i = 0; i < 5; ++i)
            {
                UserSetup.AddPlayedTitles(achievers[i].UserPuid, titles);
            }

            // Give some users a small group of achievements
            uint[] standardAchievements = new uint[10];
            for (uint i = 0; i < 10; ++i) { standardAchievements[i] = i + 1; }

            // If the title has not been propped, it will error here
            try
            {
                for (int i = 0; i < 4; ++i)
                {
                    UserSetup.AddEarnedAchievements(callers[i].UserPuid, goodTitleID, standardAchievements);
                }
            }
            catch
            {
                Global.RO.Warn("-----------------------------------------------------------------------------");
                Global.RO.Warn("| Attempt to add Achievements Failed!  Did you prop the title (0x{0:X8})? |", goodTitleID);
                Global.RO.Warn("-----------------------------------------------------------------------------");

                throw;
            }

            for (int i = 0; i < 6; ++i)
            {
                UserSetup.AddEarnedAchievements(targets[i].UserPuid, goodTitleID, standardAchievements);
            }

            // Give our achievers something to brag about
            achiever_ments[0] = new uint[0];

            achiever_ments[1] = new uint[35];
            uint temp = 0;
            for (uint i = 1; i <= 50; ++i)
            {
                if (i % 10 < 7)
                {
                    achiever_ments[1][temp++] = i;
                }
            }

            achiever_ments[2] = new uint[50];
            for (uint i = 1; i <= 50; ++i)
            {
                achiever_ments[2][i - 1] = i;
            }

            achiever_ments[3] = new uint[150];
            for (uint i = 1; i <= 150; ++i)
            {
                achiever_ments[3][i - 1] = i;
            }

            achiever_ments[4] = new uint[1];
            achiever_ments[4][0] = 51;

            for (int i = 0; i < 5; ++i)
            {
                UserSetup.AddEarnedAchievements(achievers[i].UserPuid, goodTitleID, achiever_ments[i]);
            }

            new SleepInfo("Post achievement update cache wait", achievementsAddedWaitTime);
            //Thread.Sleep(achievementsAddedWaitTime);

            Global.RO.Info("Adding Titles to t_partner_allowed_titles");

            string query1 = "exec wsp_MSins_t_partner_allowed_titles 1," + (int)goodTitleID + ",7,'" + DateTime.UtcNow + "'";

            WebstoreDB.ExecuteSQLNonQuery("WebDB", query1, null);
            Global.RO.Info("Reloading WCprofile titles and partners vis xmgmt");

            Global.XEnv.ExecuteXmgmtCommand(Interface.wcprofile, "e :wcprofile reloadtitles");
            Global.XEnv.ExecuteXmgmtCommand(Interface.wcprofile, "e :wcprofile reloadpartners");
        }

        /// <summary>
        /// Attempts to create a user tries times.
        /// </summary>
        /// <param name="tries">The number of times to try to create a user.</param>
        /// <returns>The XeUser object that we created.</returns>
        protected XeUser CreateUserRetry(int tries)
        {
            for (int i = 0; i < tries - 1; ++i)
            {
                try
                {
                    XeUser temp = UserSetup.CreateXbox360User(true, true);
                    if (temp != null)
                    {
                        return temp;
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Warn("CreateUser try {0}: {1}", i, e.Message);
                }
            }

            return UserSetup.CreateXbox360User(true, true);
        }

        /// <summary>
        /// Attempts to create a child user tries times.
        /// </summary>
        /// <param name="tries">The number of times to try to create a child user.</param>
        /// <returns>The XeUser object that we created.</returns>
        protected XeUser CreateChildRetry(int tries)
        {
            for (int i = 0; i < tries - 1; ++i)
            {
                try
                {
                    XeUser temp = UserSetup.CreateXbox360Child(true, true, 10);
                    if (temp != null)
                    {
                        return temp;
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Warn("CreateChild try {0}: {1}", i, e.Message);
                }
            }

            return UserSetup.CreateXbox360Child(true, true, 10);
        }

        [TestGroupTearDown]
        public void Teardown()
        {
        }

        [TestCase, Description("Everything is bad here.")]
        public void EverythingBad()
        {
            try
            {
                wcAchievement[] achieved = profile.ReadAchievements(0, 0, 0, 0);
            }
            catch (SoapException se)
            {
                if (se.Message.Contains("The web service encountered an internal error."))
                {
                    throw se;
                }
                return;
            }

            throw new UnexpectedTestResultException("Expecting ReadAchievements to throw an error for every input being zero.");
        }

        #region TitleID Cases

        [TestCase, Description("Tests an invalid TitleID")]
        public void TitleIDInvalid()
        {
            try
            {
                wcAchievement[] achieved = profile.ReadAchievements(callers[0].UserPuid, badTitleID, LOCALE_EN_US, targets[0].UserPuid);
            }
            catch (SoapException se)
            {
                validateTitleIDException(se);
                return;
            }

            throw new UnexpectedTestResultException(string.Format("Expecting ReadAchievements to throw an exception for invalid TitleID: 0x{0:X8}", badTitleID));
        }

        [TestCase, Description("Tests boundary case of TitleID == 0")]
        public void TitleIDZero()
        {
            try
            {
                wcAchievement[] achieved = profile.ReadAchievements(callers[0].UserPuid, 0, LOCALE_EN_US, targets[0].UserPuid);
            }
            catch (SoapException se)
            {
                validateTitleIDException(se);
                return;
            }

            throw new UnexpectedTestResultException("Expecting ReadAchievements to throw an exception for boundary TitleID: 0x0");
        }

        [TestCase, Description("Tests boundary case of TitleID == Max")]
        public void TitleIDMax()
        {
            try
            {
                wcAchievement[] achieved = profile.ReadAchievements(callers[0].UserPuid, uint.MaxValue, LOCALE_EN_US, targets[0].UserPuid);
            }
            catch (SoapException se)
            {
                validateTitleIDException(se);
                return;
            }

            throw new UnexpectedTestResultException(string.Format("Expecting ReadAchievements to throw an exception for boundary TitleID: 0x{0:X8}", uint.MaxValue));
        }

        [TestCase, Description("Tests reading from a title without the proper permissions")]
        public void TitleIDNoPermissions()
        {
            try
            {
                wcAchievement[] achieved = profile.ReadAchievements(callers[0].UserPuid, lockedTitleID, LOCALE_EN_US, targets[0].UserPuid);
            }
            catch (SoapException se)
            {
                validateTitleIDException(se);
                return;
            }

            throw new UnexpectedTestResultException(string.Format("Expecting ReadAchievements to throw an exception for unprivileged TitleID: 0x{0:X8}", lockedTitleID));
        }

        #endregion

        #region LocaleID Cases

        [TestCase, Description("Tests the boundary locale == 0")]
        public void LocaleIDZero()
        {
            wcAchievement[] achieved = profile.ReadAchievements(callers[0].UserPuid, goodTitleID, 0, targets[0].UserPuid);
            checkFirstNAchievements(10, LOCALE_EN_US, achieved);
        }

        [TestCase, Description("Tests the boundary locale == 10")]
        public void LocaleIDTen()
        {
            wcAchievement[] achieved = profile.ReadAchievements(callers[0].UserPuid, goodTitleID, 10, targets[0].UserPuid);
            checkFirstNAchievements(10, LOCALE_EN_US, achieved);
        }

        [TestCase, Description("Tests the boundary locale == Max")]
        public void LocaleIDMax()
        {
            wcAchievement[] achieved = profile.ReadAchievements(callers[0].UserPuid, goodTitleID, ushort.MaxValue, targets[0].UserPuid);
            checkFirstNAchievements(10, LOCALE_EN_US, achieved);
        }

        [TestCase, Description("Tests each valid locale to ensure that they return the proper achievement strings")]
        public void LocaleIDValid()
        {
            bool excd = false;

            for (ushort i = 0; i < 9; ++i)
            {
                try
                {
                    wcAchievement[] achieved = profile.ReadAchievements(callers[0].UserPuid, goodTitleID, LOCALE_DASH_TO_WIN[i], targets[0].UserPuid);
                    checkFirstNAchievements(10, LOCALE_DASH_TO_WIN[i], achieved);
                }
                catch (Exception e)
                {
                    excd = true;
                    Global.RO.Warn(String.Format("LocaleID {0}[{1}] failed --> ", i, LOCALE_DASH_TO_WIN[i]) + e.Message);
                }
            }

            if (excd)
            {
                throw new Exception("Some LocaleIDs failed, see info for details.");
            }
        }

        [TestCase, Description("Tests a Live locale (en-AU) for which no localized string is defined, but the Dash language is (en-US)")]
        public void LocaleID_en_AU()
        {
            wcAchievement[] achieved = profile.ReadAchievements(callers[0].UserPuid, goodTitleID, LOCALE_EN_AU, targets[0].UserPuid);
            checkFirstNAchievements(10, LOCALE_EN_AU, achieved);
        }

        /* Taking out this test case, because from the comments and the behavior, I'm not sure how this was ever
         * expected to return what it was asking for, note the comments themselves.  
        [TestCase, Description("Tests a Live locale (fr-CA) for which no localized string is defined, but the Dash language is (fr-FR)")]
        public void LocaleID_fr_CA ()
        {
            wcAchievement[] achieved = profile.ReadAchievements(callers[0].UserPuid, goodTitleID, LOCALE_FR_CA, targets[0].UserPuid);

            try
            {
                checkFirstNAchievements(10, LOCALE_FR_CA, achieved);
            }
            catch (ExpectedValueCheckException e)
            {
                if (e.Message != "Value Mismatch! Title: Expected: Achievement Name 000 (FR), Got: Achievement Name 000")
                    throw e;

                Global.RO.Warn("ReadAchievements will not currently return language match, country mismatch strings (thus fr-CA will not return fr-FR).");
                Global.RO.Warn("The verification threw the expected error, but it may change in the future.");
            }
        }
        */

        [TestCase, Description("Tests a Live locale (da-DK) for which no localized string is defined, and there isn't a Dash language equivalent")]
        public void LocaleID_da_DK()
        {
            wcAchievement[] achieved = profile.ReadAchievements(callers[0].UserPuid, goodTitleID, LOCALE_DA_DK, targets[0].UserPuid);
            checkFirstNAchievements(10, LOCALE_DA_DK, achieved);
        }

        #endregion

        #region (Mostly) Negative PUID Cases

        [TestCase, Description("Tests both PUIDs being equal")]
        public void CallerID_Equals_TargetID()
        {
            wcAchievement[] achieved = profile.ReadAchievements(targets[0].UserPuid, goodTitleID, LOCALE_EN_US, targets[0].UserPuid);
            checkFirstNAchievements(10, LOCALE_EN_US, achieved);
        }

        [TestCase, Description("Tests an invalid PUID for the caller")]
        public void CallerIDInvalid()
        {
            try
            {
                wcAchievement[] achieved = profile.ReadAchievements(badPuid, goodTitleID, LOCALE_EN_US, targets[0].UserPuid);
            }
            catch (SoapException se)
            {
                validateCallerException(se);
                return;
            }

            throw new UnexpectedTestResultException(String.Format("Expecting ReadAchievements to throw an " +
                "exception for invalid Caller puid: 0x{0:X8}", badPuid));
        }

        [TestCase, Description("Tests an invalid PUID for the target")]
        public void TargetIDInvalid()
        {
            try
            {
                wcAchievement[] achieved = profile.ReadAchievements(callers[0].UserPuid, goodTitleID, LOCALE_EN_US, badPuid);
            }
            catch (SoapException se)
            {
                validateTargetException(se);
                return;
            }

            throw new UnexpectedTestResultException(String.Format("Expecting ReadAchievements to throw an " +
                "exception for invalid Target puid: 0x{0:X8}", badPuid));
        }

        [TestCase, Description("Tests a PUID of 0 for the caller")]
        public void CallerIDZero()
        {
            try
            {
                wcAchievement[] achieved = profile.ReadAchievements(0, goodTitleID, LOCALE_EN_US, targets[0].UserPuid);
            }
            catch (SoapException se)
            {
                validateCallerException(se);
                return;
            }

            throw new UnexpectedTestResultException("Expecting ReadAchievements to throw an " +
                "exception for invalid Caller puid: 0");
        }

        [TestCase, Description("Tests a PUID of 0 for the target")]
        public void TargetIDZero()
        {
            try
            {
                wcAchievement[] achieved = profile.ReadAchievements(callers[0].UserPuid, goodTitleID, LOCALE_EN_US, 0);
            }
            catch (SoapException se)
            {
                validateTargetException(se);
                return;
            }

            throw new UnexpectedTestResultException("Expecting ReadAchievements to throw an " +
                "exception for invalid Target puid: 0");
        }

        [TestCase, Description("Tests a PUID of MAX(ulong) for the caller")]
        public void CallerIDMax()
        {
            try
            {
                wcAchievement[] achieved = profile.ReadAchievements(ulong.MaxValue, goodTitleID, LOCALE_EN_US, targets[0].UserPuid);
            }
            catch (SoapException se)
            {
                validateCallerException(se);
                return;
            }

            throw new UnexpectedTestResultException(String.Format("Expecting ReadAchievements to throw an " +
                "exception for invalid Caller puid: 0x{0:X8}", ulong.MaxValue));
        }

        [TestCase, Description("Tests a PUID of MAX(ulong) for the target")]
        public void TargetIDMax()
        {
            try
            {
                wcAchievement[] achieved = profile.ReadAchievements(callers[0].UserPuid, goodTitleID, LOCALE_EN_US, ulong.MaxValue);
            }
            catch (SoapException se)
            {
                validateTargetException(se);
                return;
            }

            throw new UnexpectedTestResultException(String.Format("Expecting ReadAchievements to throw an " +
                "exception for invalid Target puid: 0x{0:X8}", ulong.MaxValue));
        }

        #endregion

        #region Caller Privileges Cases

        [TestCase, Description("An adult caller targeting an adult with an open profile, not friends.")]
        public void C_Adult_T_AdultOpen_NoFriend()
        {
            wcAchievement[] achieved = profile.ReadAchievements(callers[0].UserPuid, goodTitleID, LOCALE_EN_US, targets[0].UserPuid);
            checkFirstNAchievements(10, LOCALE_EN_US, achieved);
        }

        [TestCase, Description("A child caller with all privileges targeting an adult with an open profile, not friends.")]
        public void C_ChildAll_T_AdultOpen_NoFriend()
        {
            wcAchievement[] achieved = profile.ReadAchievements(callers[1].UserPuid, goodTitleID, LOCALE_EN_US, targets[0].UserPuid);
            checkFirstNAchievements(10, LOCALE_EN_US, achieved);
        }

        [TestCase, Description("A child caller with only friends privileges targeting an adult with an open profile, not friends.")]
        public void C_ChildFriends_T_AdultOpen_NoFriend()
        {
            try
            {
                wcAchievement[] achieved = profile.ReadAchievements(callers[2].UserPuid, goodTitleID, LOCALE_EN_US, targets[0].UserPuid);
            }
            catch (SoapException se)
            {
                validatePermissionException(se);
                return;
            }

            throw new UnexpectedTestResultException(
                string.Format("Expecting ReadAchievements to throw an exception for a child with friends only " +
                "priveleges (0x{0:X8}) calling a non-friend (0x{1:X8})", callers[2].UserPuid, targets[0].UserPuid));
        }

        [TestCase, Description("A child caller with no privileges targeting an adult with an open profile, not friends.")]
        public void C_ChildNone_T_AdultOpen_NoFriend()
        {
            try
            {
                wcAchievement[] achieved = profile.ReadAchievements(callers[3].UserPuid, goodTitleID, LOCALE_EN_US, targets[0].UserPuid);
            }
            catch (SoapException se)
            {
                validatePermissionException(se);
                return;
            }

            throw new UnexpectedTestResultException(
                string.Format("Expecting ReadAchievements to throw an exception for a child with no " +
                "priveleges (0x{0:X8}) calling a non-friend (0x{1:X8})", callers[3].UserPuid, targets[0].UserPuid));
        }

        [TestCase, Description("An adult caller targeting an adult with an open profile, friends.")]
        public void C_Adult_T_AdultOpen_Friend()
        {
            wcAchievement[] achieved = profile.ReadAchievements(callerFriends[0].UserPuid, goodTitleID, LOCALE_EN_US, targets[0].UserPuid);
            checkFirstNAchievements(10, LOCALE_EN_US, achieved);
        }

        [TestCase, Description("A child caller with all privileges targeting an adult with an open profile, friends.")]
        public void C_ChildAll_T_AdultOpen_Friend()
        {
            wcAchievement[] achieved = profile.ReadAchievements(callerFriends[1].UserPuid, goodTitleID, LOCALE_EN_US, targets[0].UserPuid);
            checkFirstNAchievements(10, LOCALE_EN_US, achieved);
        }

        [TestCase, Description("A child caller with only friends privileges targeting an adult with an open profile, friends.")]
        public void C_ChildFriends_T_AdultOpen_Friend()
        {
            wcAchievement[] achieved = profile.ReadAchievements(callerFriends[2].UserPuid, goodTitleID, LOCALE_EN_US, targets[0].UserPuid);
            checkFirstNAchievements(10, LOCALE_EN_US, achieved);
        }

        [TestCase, Description("A child caller with no privileges targeting an adult with an open profile, friends.")]
        public void C_ChildNone_T_AdultOpen_Friend()
        {
            try
            {
                wcAchievement[] achieved = profile.ReadAchievements(callerFriends[3].UserPuid, goodTitleID, LOCALE_EN_US, targets[0].UserPuid);
            }
            catch (SoapException se)
            {
                validatePermissionException(se);
                return;
            }

            throw new UnexpectedTestResultException(
                string.Format("Expecting ReadAchievements to throw an exception for a child with no " +
                "priveleges (0x{0:X8}) calling a friend (0x{1:X8})", callerFriends[3].UserPuid, targets[0].UserPuid));
        }

        [TestCase, Description("A child caller with friends only privileges targeting self.")]
        public void C_ChildFriends_T_Self()
        {
            wcAchievement[] achieved = profile.ReadAchievements(callers[2].UserPuid, goodTitleID, LOCALE_EN_US, callers[2].UserPuid);
            checkFirstNAchievements(10, LOCALE_EN_US, achieved);
        }

        [TestCase, Description("A child caller with no privileges targeting self.")]
        public void C_ChildNone_T_Self()
        {
            wcAchievement[] achieved = profile.ReadAchievements(callers[3].UserPuid, goodTitleID, LOCALE_EN_US, callers[3].UserPuid);
            checkFirstNAchievements(10, LOCALE_EN_US, achieved);
        }

        #endregion

        #region Target Permissions Cases

        [TestCase, Description("An adult caller targeting an adult with a friends only profile, not friends.")]
        public void C_Adult_T_AdultFriends_NoFriend()
        {
            try
            {
                wcAchievement[] achieved = profile.ReadAchievements(callers[0].UserPuid, goodTitleID, LOCALE_EN_US, targets[1].UserPuid);
            }
            catch (SoapException se)
            {
                validatePermissionException(se);
                return;
            }

            throw new UnexpectedTestResultException(
                string.Format("Expecting ReadAchievements to throw an exception for an adult " +
                "(0x{0:X8}) calling a non-friend adult (0x{1:X8}) with friends only permissions", callers[0].UserPuid, targets[1].UserPuid));
        }

        [TestCase, Description("An adult caller targeting an adult with a closed profile, not friends.")]
        public void C_Adult_T_AdultClosed_NoFriend()
        {
            try
            {
                wcAchievement[] achieved = profile.ReadAchievements(callers[0].UserPuid, goodTitleID, LOCALE_EN_US, targets[2].UserPuid);
            }
            catch (SoapException se)
            {
                validatePermissionException(se);
                return;
            }

            throw new UnexpectedTestResultException(
                string.Format("Expecting ReadAchievements to throw an exception for an adult " +
                "(0x{0:X8}) calling a non-friend adult (0x{1:X8}) with no permissions", callers[0].UserPuid, targets[2].UserPuid));
        }

        [TestCase, Description("An adult caller targeting a child with an open profile, not friends.")]
        public void C_Adult_T_ChildOpen_NoFriend()
        {
            wcAchievement[] achieved = profile.ReadAchievements(callers[0].UserPuid, goodTitleID, LOCALE_EN_US, targets[3].UserPuid);
            checkFirstNAchievements(10, LOCALE_EN_US, achieved);
        }

        [TestCase, Description("An adult caller targeting a child with a friends only profile, not friends.")]
        public void C_Adult_T_ChildFriends_NoFriend()
        {
            try
            {
                wcAchievement[] achieved = profile.ReadAchievements(callers[0].UserPuid, goodTitleID, LOCALE_EN_US, targets[4].UserPuid);
            }
            catch (SoapException se)
            {
                validatePermissionException(se);
                return;
            }

            throw new UnexpectedTestResultException(
                string.Format("Expecting ReadAchievements to throw an exception for an adult " +
                "(0x{0:X8}) calling a non-friend child (0x{1:X8}) with friends only permissions", callers[0].UserPuid, targets[4].UserPuid));
        }

        [TestCase, Description("An adult caller targeting a child with a closed profile, not friends.")]
        public void C_Adult_T_ChildClosed_NoFriend()
        {
            try
            {
                wcAchievement[] achieved = profile.ReadAchievements(callers[0].UserPuid, goodTitleID, LOCALE_EN_US, targets[5].UserPuid);
            }
            catch (SoapException se)
            {
                validatePermissionException(se);
                return;
            }

            throw new UnexpectedTestResultException(
                string.Format("Expecting ReadAchievements to throw an exception for an adult " +
                "(0x{0:X8}) calling a non-friend child (0x{1:X8}) with no permissions", callers[0].UserPuid, targets[5].UserPuid));
        }

        [TestCase, Description("An adult caller targeting an adult with a friends only profile, friends.")]
        public void C_Adult_T_AdultFriends_Friend()
        {
            wcAchievement[] achieved = profile.ReadAchievements(callerFriends[0].UserPuid, goodTitleID, LOCALE_EN_US, targets[1].UserPuid);
            checkFirstNAchievements(10, LOCALE_EN_US, achieved);
        }

        [TestCase, Description("An adult caller targeting an adult with a closed profile, friends.")]
        public void C_Adult_T_AdultClosed_Friend()
        {
            try
            {
                wcAchievement[] achieved = profile.ReadAchievements(callerFriends[0].UserPuid, goodTitleID, LOCALE_EN_US, targets[2].UserPuid);
            }
            catch (SoapException se)
            {
                validatePermissionException(se);
                return;
            }

            throw new UnexpectedTestResultException(
                string.Format("Expecting ReadAchievements to throw an exception for an adult " +
                "(0x{0:X8}) calling a friend adult (0x{1:X8}) with no permissions", callerFriends[0].UserPuid, targets[2].UserPuid));
        }

        [TestCase, Description("An adult caller targeting a child with an open profile, friends.")]
        public void C_Adult_T_ChildOpen_Friend()
        {
            wcAchievement[] achieved = profile.ReadAchievements(callerFriends[0].UserPuid, goodTitleID, LOCALE_EN_US, targets[3].UserPuid);
            checkFirstNAchievements(10, LOCALE_EN_US, achieved);
        }

        [TestCase, Description("An adult caller targeting a child with a friends only profile, friends.")]
        public void C_Adult_T_ChildFriends_Friend()
        {
            wcAchievement[] achieved = profile.ReadAchievements(callerFriends[0].UserPuid, goodTitleID, LOCALE_EN_US, targets[4].UserPuid);
            checkFirstNAchievements(10, LOCALE_EN_US, achieved);
        }

        [TestCase, Description("An adult caller targeting a child with a closed profile, friends.")]
        public void C_Adult_T_ChildClosed_Friend()
        {
            try
            {
                wcAchievement[] achieved = profile.ReadAchievements(callerFriends[0].UserPuid, goodTitleID, LOCALE_EN_US, targets[5].UserPuid);
            }
            catch (SoapException se)
            {
                validatePermissionException(se);
                return;
            }

            throw new UnexpectedTestResultException(
                string.Format("Expecting ReadAchievements to throw an exception for an adult " +
                "(0x{0:X8}) calling a friend child (0x{1:X8}) with no permissions", callerFriends[0].UserPuid, targets[5].UserPuid));
        }

        [TestCase, Description("An adult caller with a friends only profile targeting self.")]
        public void C_AdultFriends_T_Self()
        {
            wcAchievement[] achieved = profile.ReadAchievements(targets[1].UserPuid, goodTitleID, LOCALE_EN_US, targets[1].UserPuid);
            checkFirstNAchievements(10, LOCALE_EN_US, achieved);
        }

        [TestCase, Description("An adult caller with a closed profile targeting self.")]
        public void C_AdultClosed_T_Self()
        {
            wcAchievement[] achieved = profile.ReadAchievements(targets[2].UserPuid, goodTitleID, LOCALE_EN_US, targets[2].UserPuid);
            checkFirstNAchievements(10, LOCALE_EN_US, achieved);
        }

        #endregion

        #region Achievement Specific Cases

        [TestCase, Description("Checks the achievements returned after gaining one from having none"), AsyncGroup(0)]
        public void Increment_0_1()
        {
            wcAchievement[] achieved;

            try
            {
                // Make sure we get what we expect now
                achieved = profile.ReadAchievements(callers[0].UserPuid, goodTitleID, LOCALE_EN_US, achievers[0].UserPuid);
                checkAchievements(achiever_ments[0], LOCALE_EN_US, achieved);
            }
            catch (Exception e)
            {
                throw new Exception("ReadAchievements didn't work BEFORE we updated the achievements --> " + e.Message);
            }

            // Add the first achievement
            uint[] added_ments = new uint[1];
            added_ments[0] = 1;
            UserSetup.AddEarnedAchievements(achievers[0].UserPuid, goodTitleID, added_ments);

            // Wait for cache time...
            new SleepInfo("Achievements updated, waiting on cache", achievementsAddedWaitTime);
            //Thread.Sleep(achievementsAddedWaitTime);

            // Now we should be getting the one achievement
            achieved = profile.ReadAchievements(callers[0].UserPuid, goodTitleID, LOCALE_EN_US, achievers[0].UserPuid);
            checkAchievements(added_ments, LOCALE_EN_US, achieved);
        }

        [TestCase, Description("Checks the achievements returned after gaining some from having some"), AsyncGroup(0)]
        public void Increment_Some_Some()
        {
            wcAchievement[] achieved;

            try
            {
                // Make sure we get what we expect now
                achieved = profile.ReadAchievements(callers[0].UserPuid, goodTitleID, LOCALE_EN_US, achievers[1].UserPuid);
                checkAchievements(achiever_ments[1], LOCALE_EN_US, achieved);
            }
            catch (Exception e)
            {
                throw new Exception("ReadAchievements didn't work BEFORE we updated the achievements --> " + e.Message);
            }

            // Add the first achievement
            uint[] added_ments = new uint[40];
            uint temp = 0;
            for (uint i = 1; i <= 50; ++i)
            {
                if (i % 10 < 8)
                {
                    added_ments[temp++] = i;
                }
            }
            UserSetup.AddEarnedAchievements(achievers[1].UserPuid, goodTitleID, added_ments);

            // Wait for cache time...
            new SleepInfo("Achievements updated, waiting on cache", achievementsAddedWaitTime);
            //Thread.Sleep(achievementsAddedWaitTime);

            // Now we should be getting the new achievement list
            achieved = profile.ReadAchievements(callers[0].UserPuid, goodTitleID, LOCALE_EN_US, achievers[1].UserPuid);
            checkAchievements(added_ments, LOCALE_EN_US, achieved);
        }

        [TestCase, Description("Checks when the user has 50 achievements")]
        public void Achievemets_50()
        {
            wcAchievement[] achieved = profile.ReadAchievements(callers[0].UserPuid, goodTitleID, LOCALE_EN_US, achievers[2].UserPuid);
            checkAchievements(achiever_ments[2], LOCALE_EN_US, achieved);
        }

        [TestCase, Description("Checks when the user has 150 achievements")]
        public void Achievemets_150()
        {
            wcAchievement[] achieved = profile.ReadAchievements(callers[0].UserPuid, goodTitleID, LOCALE_EN_US, achievers[3].UserPuid);
            checkAchievements(achiever_ments[3], LOCALE_EN_US, achieved);
        }

        [TestCase, Description("Checks a single hidden achievement for the proper hidden info")]
        public void AchievementHidden()
        {
            wcAchievement[] achieved = profile.ReadAchievements(callers[0].UserPuid, goodTitleID, LOCALE_EN_US, achievers[4].UserPuid);
            checkAchievements(achiever_ments[4], LOCALE_EN_US, achieved);
        }

        [TestCase, Description("Checks a single hidden achievement for the proper info when it should be visible")]
        public void AchievementExposed()
        {
            wcAchievement[] achieved = profile.ReadAchievements(achievers[4].UserPuid, goodTitleID, LOCALE_EN_US, achievers[4].UserPuid);
            checkAchievements(achiever_ments[4], LOCALE_EN_US, achieved, true);
        }

        #endregion

        #region Setup Helper Functions

        public enum Permission : byte
        {
            XPROFILE_PERMISSION_SHARE_ACTIVITY_NOONE = 0x01,
            XPROFILE_PERMISSION_SHARE_ACTIVITY_FRIENDS = 0x02,
            XPROFILE_PERMISSION_SHARE_UCC_NOONE = 0x04,
            XPROFILE_PERMISSION_SHARE_UCC_FRIENDS = 0x08
        }

        /// <summary>
        /// Sets the profile permissions for the given user.
        /// </summary>
        /// <param name="puid">The user id to set permissions for.</param>
        /// <param name="act_noone">If true, no one will be able to see the profile. Overrides act_friends.</param>
        /// <param name="act_friends">If true, only friends can see the profile.</param>
        public static void SetPermissions(ulong puid, bool act_noone, bool act_friends)
        {
            // Create permissions mask
            byte[] val = new byte[1];
            val[0] = 0;
            if (act_noone)
            {
                val[0] = (byte)Permission.XPROFILE_PERMISSION_SHARE_ACTIVITY_NOONE;
            }
            else if (act_friends)
            {
                val[0] = (byte)Permission.XPROFILE_PERMISSION_SHARE_ACTIVITY_FRIENDS;
            }

            if (val[0] == 0 && (act_friends || act_noone))
                throw new Exception(String.Format("Values: {0}, {1}, {2}", val[0], (byte)Permission.XPROFILE_PERMISSION_SHARE_ACTIVITY_NOONE, (byte)Permission.XPROFILE_PERMISSION_SHARE_ACTIVITY_FRIENDS));

            // Create settings array
            UserSetting[] settings = new UserSetting[1];
            settings[0] = new UserSetting(puid, PROFILE_FLG.XPROFILE_PERMISSIONS, val, SettingSource.XSOURCE_DEFAULT);

            // Create request
            SyncSettingsRequest req = new SyncSettingsRequest(0, puid, settings, DateTime.UtcNow);

            // Execute and check for errors
            SyncSettingsResponse resp = req.Execute();
            if (resp.XError != 0)
            {
                throw new Exception(String.Format("Unable to sync settings for user: 0x{0:X8}", puid));
            }
        }

        #endregion

        #region Validation Helper Functions

        /// <summary>
        /// Validates a TitleID exception to ensure that we are actually getting one that we expected.
        /// </summary>
        /// <param name="se">The exception generated by the test call.</param>
        public static void validateTitleIDException(SoapException se)
        {
            if (SoapException.IsServerFaultCode(se.Code) && se.Message.StartsWith(SoapExcepStarter) && se.Message.Contains("not allowed to access TitleID"))
            {
                return;
            }

            throw se;
        }

        /// <summary>
        /// Validates a permission exception to ensure that we are actually getting one that we expected.
        /// </summary>
        /// <param name="se">The exception generated by the test call.</param>
        public static void validatePermissionException(SoapException se)
        {
            validateClientException(se, "NO_PERMISSION");
        }

        /// <summary>
        /// Validates an invalid caller exception to ensure that we are actually getting one that we expected.
        /// </summary>
        /// <param name="se">The exception generated by the test call.</param>
        public static void validateCallerException(SoapException se)
        {
            validateClientException(se, "INVALID_CALLER_XUID");
        }

        /// <summary>
        /// Validates an invalid target exception to ensure that we are actually getting one that we expected.
        /// </summary>
        /// <param name="se">The exception generated by the test call.</param>
        public static void validateTargetException(SoapException se)
        {
            validateClientException(se, "INVALID_FOR_XUID");
        }

        /// <summary>
        /// Validates a client based SOAP exception.
        /// </summary>
        /// <param name="se">The exception generated by the test call.</param>
        /// <param name="search">The string that must be contained within the message.</param>
        public static void validateClientException(SoapException se, string search)
        {
            if (SoapException.IsClientFaultCode(se.Code) && se.Message.Contains(search))
            {
                return;
            }

            throw se;
        }

        /// <summary>
        /// Propagates the ID list for the first n achievements.
        /// </summary>
        /// <param name="n">The number of achievements to check.</param>
        /// <param name="locale">The expected locale.</param>
        /// <param name="got">The values returned from the call to ReadAchievements.</param>
        public void checkFirstNAchievements(uint n, ushort locale, wcAchievement[] got)
        {
            uint[] achs = new uint[n];
            for (uint i = 0; i < n; ++i) { achs[i] = i + 1; }

            checkAchievements(achs, locale, got);
        }

        /// <summary>
        /// Checks the given array of achievements to ensure that it is truly what you were expecting to get.
        /// </summary>
        /// <remarks>Remember, the array of expected IDs is sorted by the caller, but the array of return values
        /// will be sorted for the caller by this function.</remarks>
        /// <param name="expected">A _sorted_ array of achievement IDs to check against.</param>
        /// <param name="locale">The expected locale.</param>
        /// <param name="got">The values returned from the call to ReadAchievements.</param>
        public void checkAchievements(uint[] expected, ushort locale, wcAchievement[] got)
        {
            checkAchievements(expected, locale, got, false);
        }

        /// <summary>
        /// Checks the given array of achievements to ensure that it is truly what you were expecting to get.
        /// </summary>
        /// <remarks>Remember, the array of expected IDs is sorted by the caller, but the array of return values
        /// will be sorted for the caller by this function.</remarks>
        /// <param name="expected">A _sorted_ array of achievement IDs to check against.</param>
        /// <param name="locale">The expected locale.</param>
        /// <param name="got">The values returned from the call to ReadAchievements.</param>
        /// <param name="overrideHidden">True to ignore the hidden flag (viewer has achievements); false to not.</param>
        public void checkAchievements(uint[] expected, ushort locale, wcAchievement[] got, bool overrideHidden)
        {
            if (got.Length != expected.Length)
            {
                throw new UnexpectedTestResultException(String.Format("ReadAchievements returned {0} values; we were expecting {1}.", got.Length, expected.Length));
            }

            // Sort the achivements on ID
            Array.Sort(got, new wcAchievementSorter());

            for (int i = 0; i < expected.Length; ++i)
            {
                try
                {
                    checkSingleAchievement(expected[i], locale, got[i], overrideHidden);
                }
                catch
                {
                    Global.RO.Warn("Achievement: ID[{0}], Date[{1}], Hidden[{2}], Achieved[{3}], Type[{4}:{5}], " +
                        "Cred[{6}], Image[{7}], Title[{8}], Desc[{9}], Howto[{10}]", got[i].uiAchievementId,
                        got[i].dtAchieved, ((got[i].nFlags & XACHIEVEMENT_DETAILS_SHOWUNACHIEVED) == XACHIEVEMENT_DETAILS_SHOWUNACHIEVED ? "False" : "True"),
                        ((got[i].nFlags & XACHIEVEMENT_DETAILS_ACHIEVED) == XACHIEVEMENT_DETAILS_ACHIEVED ? "True" : "False"),
                        got[i].byType, getTypeFromID(got[i].uiAchievementId), got[i].nCred, got[i].nImageId,
                        got[i].szTitle, got[i].szDescription, got[i].szHowTo);
                    throw;
                }
            }
        }

        #region wcAchievementSorter

        /// <summary>
        /// Used for sorting the array of achievements... you don't want an order n^2 search to compare them do you?
        /// </summary>
        class wcAchievementSorter : IComparer
        {
            public wcAchievementSorter() { }

            public int Compare(object x, object y)
            {
                return ((wcAchievement)x).uiAchievementId.CompareTo(((wcAchievement)y).uiAchievementId);
            }
        }

        #endregion

        /// <summary>
        /// Checks the values of a single achievement.
        /// </summary>
        /// <param name="id">The expected ID of the achievement.</param>
        /// <param name="locale">The expected locale of the achievement.</param>
        /// <param name="ach">An achievement returned from the call to ReadAchievements.</param>
        /// <param name="overrideHidden">True to ignore the hidden flag (viewer has achievements); false to not.</param>
        private void checkSingleAchievement(uint id, ushort locale, wcAchievement ach, bool overrideHidden)
        {
            bool expectHidden = getHiddenFromID(id);

            ValueCheck.Test("ID", id, ach.uiAchievementId);
            ValueCheck.Test("Date Achieved", DateTime.UtcNow, ach.dtAchieved, new TimeSpan(2, 0, 0, 0));
            if (expectHidden)
            {
                ValueCheck.TestBits("Flags (Hidden)", XACHIEVEMENT_DETAILS_SHOWUNACHIEVED, ~((uint)ach.nFlags));
            }
            else
            {
                ValueCheck.TestBits("Flags (Hidden)", XACHIEVEMENT_DETAILS_SHOWUNACHIEVED, (uint)ach.nFlags);
            }
            ValueCheck.TestBits("Flags (Achieved)", XACHIEVEMENT_DETAILS_ACHIEVED, (uint)ach.nFlags);
            ValueCheck.Test("Type", getTypeFromID(id), ach.byType);
            ValueCheck.Test("Cred", getCredFromID(id), ach.nCred);
            ValueCheck.Test("Image ID", 32768, ach.nImageId);

            if (expectHidden && !overrideHidden)
            {
                ValueCheck.Test("Title", "HIDDEN", ach.szTitle);
                ValueCheck.Test("Description", "HIDDEN", ach.szDescription);
                ValueCheck.Test("How-to", "HIDDEN", ach.szHowTo);
            }
            else
            {
                // If French (our other language defined in the title)
                if (locale == LOCALE_FR_FR || locale == LOCALE_FR_CA)
                {
                    ValueCheck.Test("Title", String.Format("Achievement Name {0:d3} (FR)", id - 1), ach.szTitle);
                    ValueCheck.Test("Description", String.Format("Achievement Description {0:d3} (FR)", id - 1), ach.szDescription);
                    ValueCheck.Test("How-to", String.Format("Achievement How-to {0:d3} (FR)", id - 1), ach.szHowTo);
                }
                else
                {
                    ValueCheck.Test("Title", String.Format("Achievement Name {0:d3}", id - 1), ach.szTitle);
                    ValueCheck.Test("Description", String.Format("Achievement Description {0:d3}", id - 1), ach.szDescription);
                    ValueCheck.Test("How-to", String.Format("Achievement How-to {0:d3}", id - 1), ach.szHowTo);
                }
            }
        }

        #region Achievement Validation Mapping Functions

        /// <summary>
        /// Mapping from ID (to XLAST alphabetic order) to xbox.h order.
        /// </summary>
        /// <param name="id">The ID of the achievement.</param>
        /// <returns>The xbox.h code for achievement type.</returns>
        private byte getTypeFromID(uint id)
        {
            switch ((id - 1) % 7)
            {
                case 0: return 0x06;
                case 1: return 0x01;
                case 2: return 0x04;
                case 3: return 0x02;
                case 4: return 0x07;
                case 5: return 0x05;
                case 6: return 0x03;
            }

            throw new Exception("I can only forsee this happening if a non-positive ID is passed in.");
        }

        /// <summary>
        /// Mapping from ID to cred.
        /// </summary>
        /// <param name="id">The ID of the achievement.</param>
        /// <returns>The expected amount of cred for the achievement.</returns>
        private int getCredFromID(uint id)
        {
            int ans = (((int)id) - 1) % 15;
            return (ans == 14 ? 9 : ans);
        }

        /// <summary>
        /// Mapping from ID to hidden.
        /// </summary>
        /// <param name="id">The ID of the achievement.</param>
        /// <returns>True if the achievement should be hidden, false if not.</returns>
        private bool getHiddenFromID(uint id)
        {
            bool expectHidden = false;

            if (id <= 50)
            {
                expectHidden = false;
            }
            else if (id <= 100)
            {
                expectHidden = true;
            }
            else
            {
                if (id % 2 == 1)
                {
                    expectHidden = false;
                }
                else
                {
                    expectHidden = true;
                }
            }

            return expectHidden;
        }

        #endregion

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Profile\dll\wcProfileCounters.cs ===
using System;
using System.Diagnostics;
using xonline.common.mgmt;

namespace xonline.server.webcache.profile.dll 
{
    [XomPerformanceCounterCategoryAttr( "WebCache: Profile", "Xbox Live: Web Cache Profile server performance counters" )]

    public class WebCacheProfileCounter : XomPerformanceCounterCategory
    {
        [XomPerformanceCounterAttr(
             "Profile requests per second", 
             "Number of Profile requests executed per second.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecond;

        [XomPerformanceCounterAttr(
             "Profile requests total", 
             "Total Profile requests recorded in the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RequestsTotal;       

        [XomPerformanceCounterAttr(
             "ReadAchievements requests per second",
             "Number of ReadAchievements requests executed per second.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter ReadAchievementsPerSecond;

        [XomPerformanceCounterAttr(
             "ReadAchievements requests total",
             "Number of ReadAchievements requests recorded in the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter ReadAchievementsTotal;

        [XomPerformanceCounterAttr(
             "ReadSettings requests per second",
             "Number of ReadSettings requests executed per second.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter ReadSettingsPerSecond;

        [XomPerformanceCounterAttr(
             "ReadSettings requests total",
             "Number of ReadSettings requests recorded in the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter ReadSettingsTotal;

        
        public virtual WebCacheProfileCounter this[string partnerName]
        {
            get
            {
                return (WebCacheProfileCounter) GetInstance(partnerName);
            }
        }

        static public WebCacheProfileCounter ctr = new WebCacheProfileCounter();
    }   
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Profile\test\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_wcprofiletest_none_12.4.56.0_none_3df86463e99763fa
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_wcprofiletest_no-public-key_12.4.56.0_x-ww_4b69ad12
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=wcprofiletest
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_wcprofiletest_no-public-key_12.4.56.0_x-ww_4b69ad12
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_wcprofiletest_no-public-key_12.4.56.0_x-ww_4b69ad12.manifest
XP_MANIFEST_PATH=manifests\msil_wcprofiletest_no-public-key_12.4.56.0_x-ww_4b69ad12.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_wcprofiletest_no-public-key_12.4.56.0_x-ww_4b69ad12.cat
XP_CATALOG_PATH=manifests\msil_wcprofiletest_no-public-key_12.4.56.0_x-ww_4b69ad12.cat
XP_PAYLOAD_PATH=msil_wcprofiletest_no-public-key_12.4.56.0_x-ww_4b69ad12
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=wcprofiletest,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Profile\test\AchievementStress.cs ===
/*

AchievementStress.cs : Stress tests for the Achievements widget.

 * Set a BulkUser setting in the XML file given to STFRunner for testing against.
 * Make sure to run BulkAchievements to give users some achievements.
*/


using System;
using System.Web.Services.Protocols;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities.AsyncUtils;
using ServerTestFramework.Web.Profile;
using ServerTestFramework.WebWidget;

namespace AchievementsWidgetTests
{
    public class ReadAchievementsStressTestGroup
    {
        static WCProfile profile = new WCProfile();
        static BulkUserSet bus = SafeGetUserSet("");
        static BulkUserSet busPrivate = SafeGetUserSet("private");
        static Random rand = new Random();
        static uint titleID = 0xFFFF07A3;
        static uint badTitleID = 0x4D530064;
        static ushort localeID = 1033;
        static ulong mod = 10;

        static bool needsInit = true;

        /// <summary>
        /// A safe version of GetUserSet that catches.
        /// </summary>
        /// <returns>The default BulkUserSet from the Global object.</returns>
        protected static BulkUserSet SafeGetUserSet (string tag)
        {
            try
            {
                return Global.GetUserSet(tag);
            }
            catch
            {
                return null;
            }
        }

        /// <summary>
        /// The base class for ReadAchievements stress tests.
        /// </summary>
        [StressInstantiate]
        class ReadAchievementsStressBase : TestBase
        {
            protected override void Execute ()
            {
                if (needsInit && busPrivate != null)
                {
                    lock (busPrivate)
                    {
                        if (needsInit)
                        {
                            ulong b = busPrivate.Base;
                            ParallelRunner.Run(SetPermissions, busPrivate.Count, 10, b);
                            needsInit = false;
                        }
                    }
                }

                RunStressTest();
            }

            /// <summary>
            /// Delegate passed to the parallel runner.
            /// </summary>
            protected static void SetPermissions (uint index, object obj)
            {
                ReadAchievementsTestGroup.SetPermissions(((ulong) obj) + index, false, true);
            }

            /// <summary>
            /// The function to be overriden by a derived class for running the actual stress test.
            /// </summary>
            protected virtual void RunStressTest ()
            {
                throw new Exception("This method is abstract, stop calling it.");
            }
        }

        /// <summary>
        /// This is the main test, it should work properly.
        /// </summary>
        [StressTest(Priority=90)]
        class ReadAchievements_Mainline : ReadAchievementsStressBase
        {
            protected override void RunStressTest ()
            {
                ulong viewer = bus.Base + (ulong) (bus.Count * rand.NextDouble());
                ulong viewee = bus.Base + (ulong) (bus.Count * rand.NextDouble());

                wcAchievement[] achieved;
                try
                {
                    achieved = profile.ReadAchievements(viewer, titleID, localeID, viewee);
                }
                catch
                {
                    Global.RO.Warn("Call failed: ReadAchievements([caller]{0:X}, {1:X}, {2}, [for]{3:X})", viewer,
                        titleID, localeID, viewee);
                    throw;
                }
                
                if (achieved.Length != (int) (viewee % mod))
                {
                    //if (viewee % mod >= 4)
                    throw new UnexpectedTestResultException(String.Format("ReadAchievements(0x{0:X16}, 0x{1:X8}, " +
                        "{2}, 0x{3:X16}) returned {4} results, it should have been {5} (mod {6}).", viewer, titleID, 
                        localeID, viewee, achieved.Length, viewee % mod, mod));
                }
                
                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// A bad title ID, should happen infrequently.
        /// </summary>
        [StressTest(Priority=1)]
        class ReadAchievements_BadTitle : ReadAchievementsStressBase
        {
            protected override void RunStressTest ()
            {
                ulong viewer = bus.Base + (ulong) (bus.Count * rand.NextDouble());
                ulong viewee = bus.Base + (ulong) (bus.Count * rand.NextDouble());

                try
                {
                    wcAchievement[] achieved = profile.ReadAchievements(viewer, badTitleID, localeID, viewee);
                }
                catch (SoapException se)
                {
                    if (se.Message.Contains("not allowed to access TitleID"))
                    {
                        ResultCode = TEST_RESULTS.PASSED;
                        return;
                    }

                    Global.RO.Error("ReadAchievements(0x{0:X16}, 0x{1:X8}, {2}, 0x{3:X16}) threw the following error:",
                        viewer, titleID, localeID, viewee);
                    throw se;
                }
            }
        }

        /// <summary>
        /// User attempts to access achievements they shouldn't see.
        /// </summary>
        [StressTest(Priority=9)]
        class ReadAchievements_NoPermission : ReadAchievementsStressBase
        {
            protected override void RunStressTest ()
            {
                ulong viewer = bus.Base + (ulong) (bus.Count * rand.NextDouble());
                ulong viewee = busPrivate.Base + (ulong) (busPrivate.Count * rand.NextDouble());

                try
                {
                    wcAchievement[] achieved = profile.ReadAchievements(viewer, titleID, localeID, viewee);
                }
                catch (SoapException se)
                {
                    if (se.Message.Contains("NO_PERMISSION"))
                    {
                        ResultCode = TEST_RESULTS.PASSED;
                        return;
                    }

                    Global.RO.Error("ReadAchievements(0x{0:X16}, 0x{1:X8}, {2}, 0x{3:X16}) threw the following error:", 
                        viewer, titleID, localeID, viewee);
                    throw se;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Profile\test\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Profile\test\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_wcprofiletest_none_12.4.56.0_none_3df86463e99763fa
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_wcprofiletest_no-public-key_12.4.56.0_x-ww_4b69ad12
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=wcprofiletest
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_wcprofiletest_no-public-key_12.4.56.0_x-ww_4b69ad12
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_wcprofiletest_no-public-key_12.4.56.0_x-ww_4b69ad12.manifest
XP_MANIFEST_PATH=manifests\msil_wcprofiletest_no-public-key_12.4.56.0_x-ww_4b69ad12.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_wcprofiletest_no-public-key_12.4.56.0_x-ww_4b69ad12.cat
XP_CATALOG_PATH=manifests\msil_wcprofiletest_no-public-key_12.4.56.0_x-ww_4b69ad12.cat
XP_PAYLOAD_PATH=msil_wcprofiletest_no-public-key_12.4.56.0_x-ww_4b69ad12
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=wcprofiletest,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Profile\test\ReadSettingsStress.cs ===
using ServerTestFramework;
using ServerTestFramework.Database;
//using wcProfileTest;
using ServerTestFramework.Utilities;
using ServerTestFramework.Utilities.AsyncUtils;
using ServerTestFramework.Web.Profile;
using ServerTestFramework.WebWidget;

/// <summary>
/// ReadSettings stress stuff
/// </summary>
namespace StressReadSettings
{
    public class ReadSettingsStressGroup
    {
        //public const uint titleID=0xFFFE07D1;
        public static /*GRRC#const*/ uint titleID=FuncReadProfile.titleID;

        //public static /*GRRC#const*/ uint XPROFILE_GAMERCARD_TITLE_ACHIEVEMENTS_EARNED=FuncReadProfile.CalcSettingID(1,4,57); //based on xonline.h
        public static uint settingID=FuncReadProfile.CalcSettingID(1,4,21); //1=32 bit int, 4 bytes, difficulty=21 (from xonline.h)
        public static int settingVal=80;

        //bulk users
        static BulkUserSet bulk=Global.GetUserSet("xenon");
        static WCProfile profile=new WCProfile();
        static System.Random rand=new System.Random();

        static volatile bool needsInit=true;
        static volatile bool isInited=false;
        static ParallelRunner.Status initStatus=null;

        // -- base for ReadSettings stress tests
        [StressInstantiate]
        class ReadSettingsStressBase: TestBase
        {
            //init class if needed, else run the test
            protected sealed override void Execute()
            {
                //start async init
                if (needsInit && bulk!=null)
                {
                    lock (bulk)
                    {
                        if (needsInit)
                        {
                            needsInit=false;
                            InitStressStuff();
                        }
                    }
                }

                //if we're not inited, check on async status
                if (!isInited)
                {
                    System.Threading.Thread.Sleep(15000);
                    if (!initStatus.IsStillRunning)
                        isInited=true;
                }

                //if not ready yet, skip us for now (better than timing out)
                if (!isInited)
                {
                    ResultCode=TEST_RESULTS.NOT_EXECUTED;
                    return;
                }

                RunStressTest();
            }

            //class init stuff
            private static void InitStressStuff()
            {
                ServerTestFramework.LiveService.UserSettings.DBHelper.AddSetting((int)settingID,"FuncReadProfile" + settingID,"t_user_settings",0);

                initStatus=ParallelRunner.RunAsync(SetOneSetting,bulk.Count,8,(ulong)bulk.Base);

                //Global.RO.Info("sleeping 30s to wait on that slow cache");
                //System.Threading.Thread.Sleep(30000);
            }

            //helper for init (parallelrunner callback)
            private static void SetOneSetting(uint num, object baseID)
            {
                FuncReadProfile.SetUserSetting((ulong)baseID+num,settingID,FuncReadProfile.PackIntArray(settingVal),titleID);
                if (num % 1000 == 999) Global.RO.Info("Set setting for user #" + num + " of " + bulk.Count + " ... (" + ((ulong)baseID+num) + ")");
            }

            //you implement this for each test
            protected virtual void RunStressTest() {} //since C# is retarted about abstract methods
        }

        // -- actual tests

        [StressTest(Priority=0x19), Description("read 1 setting from self and make sure it's correct")]
        class ReadSettings_One: ReadSettingsStressBase
        {
            override protected void RunStressTest()
            {
                ulong myUid=bulk.Base + (ulong)(bulk.Count * rand.NextDouble());

                UserSetting[] us;

                ulong[] userArray = new ulong[] { myUid };
                uint[] settingArray = new uint[] { settingID };

                // Fetch the user settings
                us = profile.ReadSettings(myUid,titleID,1,userArray,settingArray);   // 1 = en-US

                ValueCheck.Test("Profile Widget",us.Length,settingArray.Length * userArray.Length);
                ValueCheck.Test("Profile Widget",ReadProfileStatus.SUCCESS_DEFAULT,us[0].status);
                ValueCheck.Test("Profile Widget",us[0].uiSettingId,settingArray[0]);
                FuncReadProfile.DoValCheckSetting("Profile Widget",us[0],settingVal);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [StressTest(Priority=0x19), Description("read 1 setting from self and make sure it's correct")]
        class ReadSettings_MultipleSettings: ReadSettingsStressBase
        {
            override protected void RunStressTest()
            {
                ulong myUid=bulk.Base + (ulong)(bulk.Count * rand.NextDouble());

                UserSetting[] us;

                ulong[] userArray = new ulong[] { myUid };

                // Add the rest of the possible data types
                uint[] settingArray = new uint[] { 0x1040A001, 0x10040000, 0x10040006, 0x10040012, 0x10040013, 0x5004000B,
                                                   0x20080001, 0x30080002, 0x40080003, 0x40080004, 0x60040005, 0x70070006};

                // Fetch the user settings
                us = profile.ReadSettings(myUid,titleID,1,userArray,settingArray);   // 1 = en-US

                ValueCheck.Test("Profile Widget", us.Length, settingArray.Length * userArray.Length);
                for (int i = 0; i < us.Length; i++)
                {
                    ValueCheck.Test("Profile Widget", us[i].uiSettingId, settingArray[i]);
                }
                
                //...hrm...values of these setting need checked?  what are they expected to be, and where did those id numbers come from?

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [StressTest(Priority = 0x19), Description("read 1 bad setting id from self")]
        class ReadSettings_BadSettingID : ReadSettingsStressBase
        {
            override protected void RunStressTest()
            {
                ulong myUid=bulk.Base + (ulong)(bulk.Count * rand.NextDouble());

                UserSetting[] us;

                ulong[] userArray = new ulong[] { myUid };
                uint[] settingArray = new uint[] { 0xFFFFFFFF };

                // Fetch the user settings
                us = profile.ReadSettings(myUid,titleID,1,userArray,settingArray);   // 1 = en-US

                ValueCheck.Test("Profile Widget", us.Length, settingArray.Length * userArray.Length);
                ValueCheck.Test("Profile Widget", ReadProfileStatus.WARNING_NO_VALUE, us[0].status);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [StressTest(Priority = 0x19), Description("read 1 bad setting id + bad title id from bad user id")]
        class ReadSettings_BadSettingBadTitleBadUser : ReadSettingsStressBase
        {
            override protected void RunStressTest()
            {
                ulong myUid=bulk.Base + (ulong)(bulk.Count * rand.NextDouble());

                UserSetting[] us;

                ulong[] userArray = new ulong[] { 0xffffffff };
                uint[] settingArray = new uint[] { 0xFFFFFFFF };

                // Fetch the user settings
                try
                {
                    us = profile.ReadSettings(myUid,0x12121212,1,userArray,settingArray);   // 1 = en-US
                }
                catch
                {
                    ResultCode = TEST_RESULTS.PASSED;
                    return;
                }

                ResultCode = TEST_RESULTS.FAILED;
            }
        }

    } //class ReadSettingsStressGroup
}; //namespace StressReadSettings
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Profile\test\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Profile\test\wcProfileTest.cs ===
//
// StatsTest.cs
//
// A unit test that hits the real web-cache.
//
// Copyright (C) Microsoft Corporation.  All Rights Reserved.
//

#define DEBUG

using System;
using System.Diagnostics;
using System.Collections;
using System.Web.Services.Protocols;
using System.IO;

using ServerTestFramework;
using LiveService = ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.Web.Profile;

using xonline.common.diagnostics;
using xonline.common.config;
using xonline.common.service;
using xonline.common.protocol;
using xonline.server.webcache.common;

using ServerTestFramework.LiveService.UserAccount;

namespace WCProfileTest
{
    [TestGroup, Owner("KKline"), TestFrequency("Regression"), TestCasePriority(3), DVT] 
    public class wcProfileDevTest: TestNode
    {
        /* 
            MAKE SURE THESE ARE DONE FIRST - Prop the Pankaj test title 50
            Make Passport = FAKE by tuning t_settings
            Prop the DASH title ConfigureSingleTitle.cmd fffe07d1 hpleung5 hpleung5
            Give DEBUGPARTNER permission to execute against title 50
        */

        public int XCachePollingInSeconds
        {
            get
            {
                int nRet = 1;
                try
                {
                    nRet = Config.GetIntSetting(Setting.xcache_db_pollingInterval);
                }
                catch
                {
                    
                }

                return nRet;
            }
        }

        
        [TestGroupSetup]
        public void Setup()
        {
            //moved from InitializerInfo
            // Let the fake SG know where to send state updates
            GlobalFakeSG.FakeSG.SetStateEndpoint(Global.XEnv.GetVirtualInterface(xonline.common.config.VirtualInterface.xpnfd_presence).ToString());
            IVirtualInterfaceInfo face = xonline.common.config.Config.GetVirtualInterface(VirtualInterface.wcprofile, Site.main);
            string szUrl = string.Format("http://{0}:{1}/profile/profile.asmx", face.IPAddressString, face.Port);
            profile = new Profile();
            profile.Url = szUrl;

            m_ulUserAPuid = CreateUser( -18, XOn.PARENTAL_CONTROL_GROUP_OPEN);
            m_ulUserBPuid = CreateUser( -18, XOn.PARENTAL_CONTROL_GROUP_OPEN );
            m_ulUserCPuid = CreateUser( -18, XOn.PARENTAL_CONTROL_GROUP_OPEN );
            m_ulUserChildPuid1 = CreateMinorUser(); //can't see anybody

            System.Threading.Thread.Sleep(XCachePollingInSeconds * 1000);
            
            for (uint i=1;i<=8;i++)
            {
                WriteAchievement(m_ulUserAPuid, i);
            }

            for (uint i=5;i<=10;i++)
            {
                WriteAchievement(m_ulUserBPuid, i);
            }

            for (uint i=1;i<=10;i++)
            {
                WriteAchievement(m_ulUserCPuid, i);
            }
        }
        
        Profile profile;
        Utilities m_util = Utilities.Instance;
        ulong m_ulUserAPuid;
        ulong m_ulUserBPuid;
        ulong m_ulUserCPuid; //achieved all
        ulong m_ulUserChildPuid1;
        const int TITLE_ID = 50;
        const int EXPECTED_NUM_ACHIEVEMENT_FOR_USER_A = 8;
        const int EXPECTED_NUM_ACHIEVEMENT_FOR_USER_B = 6;
        const ushort LOCALE_EN_US    = 1033;
        const ushort LOCALE_fr_fr    = 1036;
        const ushort LOCALE_UNKNOWN = 999;
        const string LOCALE_EN_US_SZ = "en-us";
        const string LOCALE_FR_FR_SZ = "fr-fr";
        DateTime m_dtAchieved = DateTime.UtcNow;
        

        /*
            We will have User A, B
            Our Title 50 has achievement ID 1-10
            Let User A achieved 1-8 (8 Achievement)
            Let User B achieved 5-10 (5 Achievement)

            Locale supported in XLAST = en-US, fr-FR

            User A is not parental controlled
            User B is parental controlled
        */
        protected ulong CreateUser(int nBirthYearAgo, int nParentalGroup)
        {
            XeUser user = new XeUser(true);
            user.BirthDate = DateTime.UtcNow.AddYears(nBirthYearAgo);
            user.ParentalControlGroup = nParentalGroup;

            user.CreateAsGold = true;
            ulong puid = user.Create();

            if(0 == puid)
            {
                throw new UnexpectedTestResultException("Failed to create user from billing: " + user.GetDumpString());
            }

            return puid;
        }

        protected ulong CreateMinorUser()
        {
            XeUser userParent               = new XeUser(true);
            userParent.BirthDate            = DateTime.UtcNow.AddYears(-18);
            userParent.ParentalControlGroup = XOn.PARENTAL_CONTROL_GROUP_OPEN;
            userParent.Create();

            XeUser user = new XeUser(true);
            user.BirthDate = DateTime.UtcNow.AddYears(-15);
            user.CreateAsGold = true;
            user.ParentalControlGroup = XOn.PARENTAL_CONTROL_GROUP_RESTRICTED;
            ulong puid = user.CreateMinor(userParent, true);

            if(0 == puid)
            {
                throw new UnexpectedTestResultException("Failed to create user from billing: " + user.GetDumpString());
            }

            return puid;
        }

        protected void WriteAchievement(ulong ulPuid, uint uiAchievementID)
        {
            SyncAchievementsRequest req = new SyncAchievementsRequest();

            req.TitleId = TITLE_ID;
            req.UserId = ulPuid;
            req.Version = DateTime.Now;
            req.LocaleId = 1;
            req.AchievementCount = 1;
            req.Achievements = new Achievement[1];

            req.Achievements[0] = new Achievement();

            req.Achievements[0].AchievementId = uiAchievementID;
            req.Achievements[0].Achieved = m_dtAchieved;
            req.Achievements[0].Sequence = 0xffffffff;
            req.Achievements[0].Flags |= (int)XOn.XACHIEVEMENT_DETAILS_ACHIEVED_ONLINE;
                
           
            IVirtualInterfaceInfo vii = Config.GetVirtualInterface(VirtualInterface.progressfd_int, 1);
            HTTPAuthData authData = new HTTPAuthData(0, 0, 0, ulPuid, TITLE_ID, (uint)XOService.Progress, 0);
            
            m_util.FrontDoorRequest("http://" + vii.IPAddress + ":" + vii.Port + req.GetXRL(),authData,(uint)XOService.Progress, 0, req.GetBytes());
        }

        [TestCase]
        public void ReadAchievement_EnumerateOwnAchievementForUserA()
        {
            EnumerateOwnAchivementCommonForUserA(LOCALE_fr_fr, LOCALE_FR_FR_SZ);
            EnumerateOwnAchivementCommonForUserA(LOCALE_EN_US, LOCALE_EN_US_SZ);
            EnumerateOwnAchivementCommonForUserA(LOCALE_UNKNOWN, null);
        }

        [TestCase]
        public void ReadAchievement_UserAEnumerateUserB()
        {
            wcAchievement[] arrAchievements = profile.ReadAchievements(m_ulUserAPuid, (uint)TITLE_ID, LOCALE_EN_US, m_ulUserBPuid);

            if (arrAchievements == null || arrAchievements.Length != EXPECTED_NUM_ACHIEVEMENT_FOR_USER_B)
                throw new Exception("Unexpected Achievment Count");

            TitleConfig titleConfig = TitleConfig.GetTitle(TITLE_ID, true);

            foreach (wcAchievement webAchievement in arrAchievements)
            {
                TitleAchievement achievement = (TitleAchievement)titleConfig.Achievements[webAchievement.uiAchievementId];
                if (achievement == null)
                    throw new Exception("Achievement does not Exist in the Title");

                VerifyAchievement(achievement, webAchievement, LOCALE_EN_US_SZ);
            }
        }

        [TestCase]
        public void ReadAchievement_UserBEnumerateUserA()
        {
            wcAchievement[] arrAchievements = profile.ReadAchievements(m_ulUserBPuid, (uint)TITLE_ID, LOCALE_UNKNOWN, m_ulUserAPuid);

            if (arrAchievements == null || arrAchievements.Length != EXPECTED_NUM_ACHIEVEMENT_FOR_USER_A)
                throw new Exception("Unexpected Achievment Count");

            TitleConfig titleConfig = TitleConfig.GetTitle(TITLE_ID, true);

            foreach (wcAchievement webAchievement in arrAchievements)
            {
                TitleAchievement achievement = (TitleAchievement)titleConfig.Achievements[webAchievement.uiAchievementId];
                if (achievement == null)
                    throw new Exception("Achievement does not Exist in the Title");

                VerifyAchievement(achievement, webAchievement, null);
            }
        }

        [TestCase]
        public void ReadAchievement_UserCEnumerateUserB() //hidden achievement should be unlocked
        {
            wcAchievement[] arrAchievements = profile.ReadAchievements(m_ulUserCPuid, (uint)TITLE_ID, LOCALE_UNKNOWN, m_ulUserBPuid);

            if (arrAchievements == null || arrAchievements.Length != EXPECTED_NUM_ACHIEVEMENT_FOR_USER_B)
                throw new Exception("Unexpected Achievment Count");

            TitleConfig titleConfig = TitleConfig.GetTitle(TITLE_ID, true);

            foreach (wcAchievement webAchievement in arrAchievements)
            {
                TitleAchievement achievement = (TitleAchievement)titleConfig.Achievements[webAchievement.uiAchievementId];
                if (achievement == null)
                    throw new Exception("Achievement does not Exist in the Title");

                VerifyAchievement(achievement, webAchievement, null);
            }
        }

        [TestCase]
        public void ReadAchievement_RestrictedUser()
        {
            try
            {
                wcAchievement[] arrAchievements = profile.ReadAchievements(m_ulUserChildPuid1, (uint)TITLE_ID, LOCALE_UNKNOWN, m_ulUserAPuid);
            }
            catch (SoapException se)
            {
                if ((se.Detail.InnerText != "ffffffff" && ((System.Exception)(se)).Message != "NO_PERMISSION"))
                {
                    throw new Exception("No Permission Expected");
                }
            }

        }

        [TestCase]
        public void ReadAchievement_InvalidCallerXuid()
        {
            try
            {
                wcAchievement[] arrAchievements = profile.ReadAchievements(123, (uint)TITLE_ID, LOCALE_UNKNOWN, m_ulUserAPuid);
            }
            catch (SoapException se)
            {
                if ((se.Detail.InnerText != "fffffffe" && ((System.Exception)(se)).Message != "INVALID_CALLER_XUID"))
                {
                    throw new Exception("INVALID_CALLER_XUID Expected");
                }
            }

        }


        [TestCase]
        public void ReadAchievement_InvalidForXuid()
        {
            try
            {
                wcAchievement[] arrAchievements = profile.ReadAchievements(m_ulUserAPuid, (uint)TITLE_ID, LOCALE_UNKNOWN, 123);
            }
            catch (SoapException se)
            {
                if ((se.Detail.InnerText != "fffffffd" && ((System.Exception)(se)).Message != "INVALID_FOR_XUID"))
                {
                    throw new Exception("INVALID_FOR_XUID Expected");
                }
            }
        }

        /*
            Note: We are only going to test some error condition code (more test code found in crux test dvt)
        */

        [TestCase]
        public void ReadSetting_InvalidCallerXuid()
        {
            try
            {
                ServerTestFramework.Web.Profile.UserSetting [] arrSettings = profile.ReadSettings(123, (uint)TITLE_ID, LOCALE_UNKNOWN, null, null);
            }
            catch (SoapException se)
            {
                if ((se.Detail.InnerText != "fffffffe" && ((System.Exception)(se)).Message != "INVALID_CALLER_XUID"))
                {
                    throw new Exception("INVALID_CALLER_XUID Expected");
                }
            }

        }
        
        protected void EnumerateOwnAchivementCommonForUserA(ushort usLocaleId, string szLocale)
        {
            wcAchievement[] arrAchievements = profile.ReadAchievements(m_ulUserAPuid, (uint)TITLE_ID, usLocaleId, m_ulUserAPuid);

            if (arrAchievements == null || arrAchievements.Length != EXPECTED_NUM_ACHIEVEMENT_FOR_USER_A)
                throw new Exception("Unexpected Result");

            TitleConfig titleConfig = TitleConfig.GetTitle(TITLE_ID, true);

            foreach (wcAchievement webAchievement in arrAchievements)
            {
                TitleAchievement achievement = (TitleAchievement)titleConfig.Achievements[webAchievement.uiAchievementId];
                if (achievement == null)
                    throw new Exception("Achievement does not Exist in the Title");

                VerifyAchievement(achievement, webAchievement, szLocale);
            }
        }


        protected void VerifyAchievement(TitleAchievement titleAchievement ,wcAchievement webAchievement, string szLocale)
        {
            if (szLocale == null)
                szLocale = "";
            
            if (titleAchievement.Cred != webAchievement.nCred)
                throw new Exception("Credit Not Equal");

            if ((byte)titleAchievement.Type != webAchievement.byType)
                throw new Exception("Type Not Equal");

            if (titleAchievement.ImageId != webAchievement.nImageId)
                throw new Exception(String.Format("Image Id Not Equal Web {0} FD {1}",webAchievement.nImageId, titleAchievement.ImageId));

            if ((webAchievement.nFlags & XOn.XACHIEVEMENT_DETAILS_ACHIEVED_ONLINE) == 0)
                throw new Exception("All My Achievement are currently expected to be online");

            if (titleAchievement.Title[szLocale] != webAchievement.szTitle && webAchievement.szTitle != "HIDDEN")
            {
                throw new Exception("Localized Title Not Expected");
            }

            if (titleAchievement.Description[szLocale] != webAchievement.szDescription && webAchievement.szDescription != "HIDDEN")
            {
                throw new Exception("Localized Description Not Expected");
            }

            if (titleAchievement.Unachieved[szLocale] != webAchievement.szHowTo && webAchievement.szHowTo != "HIDDEN")
            {
                throw new Exception("Localized HowTo Not Expected");
            } 
        }

     }


       
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Profile\test\FuncReadProfile.cs ===
using System;
using System.Threading;
using ServerTestFramework;
using System.Collections;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService;
//using ServerTestFramework.LiveService.UserSettings;
using ServerTestFramework.Web.Profile;
using xonline.common.config;

namespace WCProfileTest
{
    [TestGroup, AsyncThreadCount(64), AsyncGroup(1, 0), Owner("KKline"), TestFrequency("Regression"), TestCasePriority(3)]
    public class FuncReadProfile : TestNode
    {
        public static int sleepTime = 30000;
        public static uint titleID = 0xFFFF07A2;

        public static WCProfile wp;
        public static XeUser u;
        private static FriendsCommon _fc;

        public static uint settingDiffID; //difficulty setting id
        public static uint settingSensID; //sensitivity setting id
        private static uint settingBinAtMax; //title-specific #1

        private const ushort XPROFILE_SETTING_MAX_SIZE = 1000; //from xonline.h -- biggest title data that can be stored

        public static int uSettingDiff = (int)0x11223344; //value of main user's difficulty setting for testing
        public static int uSettingSens = (int)0x7feeddcc; //value of main user's sensitivity setting for testing
        public static int oSettingDiff = (int)0x6ba98765; //value of other user's difficulty setting for testing
        public static int oSettingSens = (int)0x23456789; //value of other user's sensitivity setting for testing
        public static byte[] uSettingBinAtMax; //bunch of binary data (at exact max size)

        [TestGroupSetup]
        public void Setup()
        {
            // Let the fake SG know where to send state updates
            ServerTestFramework.LiveService.FakeSG.GlobalFakeSG.FakeSG.SetStateEndpoint(Global.XEnv.GetVirtualInterface(xonline.common.config.VirtualInterface.xpnfd_presence).ToString());

            wp = new WCProfile();
            _fc = new FriendsCommon();

            // Create a user
            u = UserSetup.CreateXbox360User();

            //some setting id's
            settingDiffID = CalcSettingID(1, 4, 21); //1=32 bit int, 4 bytes, difficulty=21 (from xonline.h)
            settingSensID = CalcSettingID(1, 4, 24); //1=32 bit int, 4 bytes, sensitivity=24 (from xonline.h)
            settingBinAtMax = CalcSettingID(6, XPROFILE_SETTING_MAX_SIZE, 0x3FFF); //1=binary, bytes, title1=0x3FFF (from xonline.h)

            uSettingBinAtMax = new byte[XPROFILE_SETTING_MAX_SIZE];
            for (uint i = 0; i < XPROFILE_SETTING_MAX_SIZE; ++i)
                uSettingBinAtMax[i] = (byte)(i & 0xff);

            //set setting into user
            SetSettingDifficulty(u, uSettingDiff);
            SetSettingSensitivity(u, uSettingSens);

            SetUserSetting(u, settingBinAtMax, uSettingBinAtMax);

            // Wait for the cache to pick up the change
            Thread.Sleep(sleepTime);

            Global.RO.Info("Adding Titles to t_partner_allowed_titles");

            string query1 = "exec wsp_MSins_t_partner_allowed_titles 1," + (int)titleID + ",7,'" + DateTime.UtcNow + "'";

            WebstoreDB.ExecuteSQLNonQuery("WebDB", query1, null);

            Global.RO.Info("Reloading WCprofile titles and partners vis xmgmt");

            Global.XEnv.ExecuteXmgmtCommand(Interface.wcprofile, "e :wcprofile reloadtitles");
            Global.XEnv.ExecuteXmgmtCommand(Interface.wcprofile, "e :wcprofile reloadpartners");

        }

        [TestGroupTearDown]
        public void TearDown()
        {
            _fc = null;
            wp = null;
        }

        public static void MakeFriends(XeUser x, XeUser u2)
        {
            lock (_fc)
            {
                // Make Friends
                PNUser pnRequestor = new PNUser(u.Gamertag, u.UserPuid);
                PNUser pnFriend = new PNUser(u2.Gamertag, u2.UserPuid);

                _fc.MakeFriend(pnRequestor, pnFriend);
            }
        }

        //constructs a setting ID
        public static uint CalcSettingID(byte type, ushort size, ushort id)
        {
            return ((uint)type << 28) | (((uint)size & 0xfff) << 16) | (uint)(id & 0x3fff);
        }

        //sets a setting for a user
        public static void SetUserSetting(XeUser user, uint setid, byte[] data)
        {
            SetUserSetting(user.UserPuid, setid, data, titleID);
        }
        public static void SetUserSetting(ulong userID, uint setid, byte[] data, uint myTitleID)
        {
            //hrm...
            //ServerTestFramework.LiveService.UserSettings.DBHelper.AddSetting((int)setid, "FuncReadProfile"+setid, "t_user_settings", 0);

            //make setting
            ServerTestFramework.LiveService.UserSettings.UserSetting[] settings = new ServerTestFramework.LiveService.UserSettings.UserSetting[1];
            settings[0] = new ServerTestFramework.LiveService.UserSettings.UserSetting(userID, setid, data, ServerTestFramework.LiveService.UserSettings.SettingSource.XSOURCE_DEFAULT);

            //create request
            ServerTestFramework.LiveService.UserSettings.SyncSettingsRequest req = new ServerTestFramework.LiveService.UserSettings.SyncSettingsRequest(myTitleID, userID, settings, DateTime.UtcNow);

            //execute and check for errors
            ServerTestFramework.LiveService.UserSettings.SyncSettingsResponse resp = req.Execute();
            if (resp.XError != 0) throw new Exception(String.Format("Unable to sync settings for user: 0x{0:X8}", userID));

            if (settings[0].Value[0] != data[0]) throw new Exception(String.Format("Value synched the wrong way??? In SetUserSetting, for 0x{0:X8}", userID));
            //Global.RO.Info("set user setting: title=" + titleID + ", user=" + user.UserPuid + ", sid=" + setid + ", total_bytes=" + data.Length);
        }

        //set a users difficulty setting
        public static void SetSettingDifficulty(XeUser user, int value)
        {
            byte[] val = PackIntArray(value);
            SetUserSetting(user, settingDiffID, val);
        }

        //set a users sensitivity setting
        public static void SetSettingSensitivity(XeUser user, int value)
        {
            byte[] val = PackIntArray(value);
            SetUserSetting(user, settingSensID, val);
        }

        //load a int into a 4 byte array since c# can't just cast as a pointer...
        public static byte[] PackIntArray(int value)
        {
            byte[] val = new byte[4];
            val[3] = (byte)(value & 0xff); val[2] = (byte)((value >> 8) & 0xff); val[1] = (byte)((value >> 16) & 0xff); val[0] = (byte)((value >> 24) & 0xff);
            return val;
        }

        //does a ValueCheck.Test for an int user setting
        public static void DoValCheckSetting(string name, UserSetting us, int value)
        {
            //ValueCheck.Test(name, ((byte[])us.value)[0], (byte)(value&0xff));
            //ValueCheck.Test(name, ((byte[])us.value)[1], (byte)((value>>8)&0xff));
            //ValueCheck.Test(name, ((byte[])us.value)[2], (byte)((value>>16)&0xff));
            //ValueCheck.Test(name, ((byte[])us.value)[3], (byte)((value>>24)&0xff));

            if (!(us.value is int)) throw new UnexpectedTestResultException(name + ": DoValCheckSetting: UserSetting's value object is not an int as expected.");
            ValueCheck.Test(name, value, (int)us.value);
        }

        [TestCase, Description("Read the stock settings")]
        class ReadSettings_Basic : TestBase
        {
            override protected void Execute()
            {
                UserSetting[] us;

                UInt64[] userArray = new UInt64[] { u.UserPuid };
                uint[] settingArray = new uint[] { settingDiffID, settingSensID };

                // Fetch the user settings
                us = wp.ReadSettings(u.UserPuid, titleID, 1, userArray, settingArray);   // 1 = en-US

                ValueCheck.Test("Profile Widget", us.Length, settingArray.Length * userArray.Length);
                ValueCheck.Test("Profile Widget", ReadProfileStatus.SUCCESS_DEFAULT, us[0].status);
                ValueCheck.Test("Profile Widget", ReadProfileStatus.SUCCESS_DEFAULT, us[1].status);
                ValueCheck.Test("Profile Widget", us[0].uiSettingId, settingArray[0]);
                ValueCheck.Test("Profile Widget", us[1].uiSettingId, settingArray[1]);
                DoValCheckSetting("Profile Widget", us[0], uSettingDiff);
                DoValCheckSetting("Profile Widget", us[1], uSettingSens);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("Read the settings of a non friend")]
        class ReadSettings_NonFriend : TestBase
        {
            override protected void Execute()
            {
                UserSetting[] us;

                // Create another user
                XeUser nonFriend = UserSetup.CreateXbox360User();

                SetSettingDifficulty(nonFriend, oSettingDiff);
                SetSettingSensitivity(nonFriend, oSettingSens);

                UInt64[] userArray = new UInt64[] { nonFriend.UserPuid };
                uint[] settingArray = new uint[] { settingDiffID, settingSensID };

                // Wait for the cache to pick up the change
                Thread.Sleep(sleepTime);

                // Fetch the user settings
                us = wp.ReadSettings(u.UserPuid, titleID, 1, userArray, settingArray);   // 1 = en-US

                ValueCheck.Test("Profile Widget", us.Length, settingArray.Length * userArray.Length);
                ValueCheck.Test("Profile Widget", ReadProfileStatus.ERROR_NO_PERMISSION, us[0].status);
                ValueCheck.Test("Profile Widget", ReadProfileStatus.ERROR_NO_PERMISSION, us[1].status);
                ValueCheck.Test("Profile Widget", us[0].uiSettingId, settingArray[0]);
                ValueCheck.Test("Profile Widget", us[1].uiSettingId, settingArray[1]);
                DoValCheckSetting("Profile Widget", us[0], 0);
                DoValCheckSetting("Profile Widget", us[1], 0);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("Read the settings of a friend")]
        class ReadSettings_Friend : TestBase
        {
            override protected void Execute()
            {
                UserSetting[] us;

                // Create another user
                XeUser Friend = UserSetup.CreateXbox360User();

                SetSettingDifficulty(Friend, oSettingDiff);
                SetSettingSensitivity(Friend, oSettingSens);

                // Make Friends
                // Make Friends
                PNUser pnRequestor = new PNUser(u.Gamertag, u.UserPuid);
                PNUser pnFriend = new PNUser(Friend.Gamertag, Friend.UserPuid);
                _fc.MakeFriend(pnRequestor, pnFriend);

                //MakeFriends(u, Friend);


                UInt64[] userArray = new UInt64[] { Friend.UserPuid };
                uint[] settingArray = new uint[] { settingDiffID, settingSensID };

                // Wait for the cache to pick up the change
                Thread.Sleep(sleepTime);

                // Fetch the user settings
                us = wp.ReadSettings(u.UserPuid, titleID, 1, userArray, settingArray);   // 1 = en-US

                ValueCheck.Test("Profile Widget", us.Length, settingArray.Length * userArray.Length);
                ValueCheck.Test("Profile Widget", ReadProfileStatus.ERROR_NO_PERMISSION, us[0].status);
                ValueCheck.Test("Profile Widget", ReadProfileStatus.ERROR_NO_PERMISSION, us[1].status);
                ValueCheck.Test("Profile Widget", us[0].uiSettingId, settingArray[0]);
                ValueCheck.Test("Profile Widget", us[1].uiSettingId, settingArray[1]);
                DoValCheckSetting("Profile Widget", us[0], 0);
                DoValCheckSetting("Profile Widget", us[1], 0);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("Read the settings of a friend twice")]
        class ReadSettings_DuplicateFriends : TestBase
        {
            override protected void Execute()
            {
                UserSetting[] us;

                // Create another user
                XeUser Friend = UserSetup.CreateXbox360User();

                PNUser pnRequestor = new PNUser(u.Gamertag, u.UserPuid);
                PNUser pnFriend = new PNUser(Friend.Gamertag, Friend.UserPuid);
                _fc.MakeFriend(pnRequestor, pnFriend);

                // Make Friends
                //MakeFriends(u, Friend);

                SetSettingDifficulty(Friend, oSettingDiff);
                SetSettingSensitivity(Friend, oSettingSens);

                UInt64[] userArray = new UInt64[] { Friend.UserPuid, Friend.UserPuid };
                uint[] settingArray = new uint[] { settingDiffID, settingSensID };

                // Wait for the cache to pick up the change
                Thread.Sleep(sleepTime);

                // Fetch the user settings
                us = wp.ReadSettings(u.UserPuid, titleID, 1, userArray, settingArray);   // 1 = en-US

                ValueCheck.Test("Profile Widget", us.Length, settingArray.Length * userArray.Length);
                ValueCheck.Test("Profile Widget", ReadProfileStatus.ERROR_NO_PERMISSION, us[0].status);
                ValueCheck.Test("Profile Widget", ReadProfileStatus.ERROR_NO_PERMISSION, us[1].status);
                ValueCheck.Test("Profile Widget", ReadProfileStatus.ERROR_NO_PERMISSION, us[2].status);
                ValueCheck.Test("Profile Widget", ReadProfileStatus.ERROR_NO_PERMISSION, us[3].status);
                ValueCheck.Test("Profile Widget", us[0].uiSettingId, settingArray[0]);
                ValueCheck.Test("Profile Widget", us[1].uiSettingId, settingArray[1]);
                ValueCheck.Test("Profile Widget", us[2].uiSettingId, settingArray[0]);
                ValueCheck.Test("Profile Widget", us[3].uiSettingId, settingArray[1]);
                DoValCheckSetting("Profile Widget", us[0], 0);
                DoValCheckSetting("Profile Widget", us[1], 0);
                DoValCheckSetting("Profile Widget", us[2], 0);
                DoValCheckSetting("Profile Widget", us[3], 0);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("Read the settings of a non friend twice")]
        class ReadSettings_DuplicateNonFriends : TestBase
        {
            override protected void Execute()
            {
                UserSetting[] us;

                // Create another user
                XeUser nonFriend = UserSetup.CreateXbox360User();

                SetSettingDifficulty(nonFriend, oSettingDiff);
                SetSettingSensitivity(nonFriend, oSettingSens);

                UInt64[] userArray = new UInt64[] { nonFriend.UserPuid, nonFriend.UserPuid };
                uint[] settingArray = new uint[] { settingDiffID, settingSensID };

                // Wait for the cache to pick up the change
                Thread.Sleep(sleepTime);

                // Fetch the user settings
                us = wp.ReadSettings(u.UserPuid, titleID, 1, userArray, settingArray);   // 1 = en-US

                ValueCheck.Test("Profile Widget", us.Length, settingArray.Length * userArray.Length);
                ValueCheck.Test("Profile Widget", ReadProfileStatus.ERROR_NO_PERMISSION, us[0].status);
                ValueCheck.Test("Profile Widget", ReadProfileStatus.ERROR_NO_PERMISSION, us[1].status);
                ValueCheck.Test("Profile Widget", ReadProfileStatus.ERROR_NO_PERMISSION, us[2].status);
                ValueCheck.Test("Profile Widget", ReadProfileStatus.ERROR_NO_PERMISSION, us[3].status);
                ValueCheck.Test("Profile Widget", us[0].uiSettingId, settingArray[0]);
                ValueCheck.Test("Profile Widget", us[1].uiSettingId, settingArray[1]);
                ValueCheck.Test("Profile Widget", us[2].uiSettingId, settingArray[0]);
                ValueCheck.Test("Profile Widget", us[3].uiSettingId, settingArray[1]);
                ValueCheck.Test("Profile Widget", us[0].ulUserId, nonFriend.UserPuid);
                ValueCheck.Test("Profile Widget", us[1].ulUserId, nonFriend.UserPuid);
                ValueCheck.Test("Profile Widget", us[2].ulUserId, nonFriend.UserPuid);
                ValueCheck.Test("Profile Widget", us[3].ulUserId, nonFriend.UserPuid);
                DoValCheckSetting("Profile Widget", us[0], 0);
                DoValCheckSetting("Profile Widget", us[1], 0);
                DoValCheckSetting("Profile Widget", us[2], 0);
                DoValCheckSetting("Profile Widget", us[3], 0);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("Read the settings of multiple non friends")]
        class ReadSettings_MultipleNonFriends : TestBase
        {
            override protected void Execute()
            {
                UserSetting[] us;

                // Create another user
                XeUser nonFriend1 = UserSetup.CreateXbox360User();
                XeUser nonFriend2 = UserSetup.CreateXbox360User();

                SetSettingDifficulty(nonFriend1, oSettingDiff);
                SetSettingSensitivity(nonFriend1, oSettingSens);
                SetSettingDifficulty(nonFriend2, oSettingDiff);
                SetSettingSensitivity(nonFriend2, oSettingSens);

                UInt64[] userArray = new UInt64[] { nonFriend1.UserPuid, nonFriend2.UserPuid };
                uint[] settingArray = new uint[] { settingDiffID, settingSensID };

                // Wait for the cache to pick up the change
                Thread.Sleep(sleepTime);

                // Fetch the user settings
                us = wp.ReadSettings(u.UserPuid, titleID, 1, userArray, settingArray);   // 1 = en-US

                ValueCheck.Test("Profile Widget", us.Length, settingArray.Length * userArray.Length);
                ValueCheck.Test("Profile Widget", ReadProfileStatus.ERROR_NO_PERMISSION, us[0].status);
                ValueCheck.Test("Profile Widget", ReadProfileStatus.ERROR_NO_PERMISSION, us[1].status);
                ValueCheck.Test("Profile Widget", ReadProfileStatus.ERROR_NO_PERMISSION, us[2].status);
                ValueCheck.Test("Profile Widget", ReadProfileStatus.ERROR_NO_PERMISSION, us[3].status);
                ValueCheck.Test("Profile Widget", us[0].uiSettingId, settingArray[0]);
                ValueCheck.Test("Profile Widget", us[1].uiSettingId, settingArray[1]);
                ValueCheck.Test("Profile Widget", us[2].uiSettingId, settingArray[0]);
                ValueCheck.Test("Profile Widget", us[3].uiSettingId, settingArray[1]);
                ValueCheck.Test("Profile Widget", us[0].ulUserId, nonFriend1.UserPuid);
                ValueCheck.Test("Profile Widget", us[1].ulUserId, nonFriend1.UserPuid);
                ValueCheck.Test("Profile Widget", us[2].ulUserId, nonFriend2.UserPuid);
                ValueCheck.Test("Profile Widget", us[3].ulUserId, nonFriend2.UserPuid);
                DoValCheckSetting("Profile Widget", us[0], 0);
                DoValCheckSetting("Profile Widget", us[1], 0);
                DoValCheckSetting("Profile Widget", us[2], 0);
                DoValCheckSetting("Profile Widget", us[3], 0);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }


        [TestCase, Description("Read the settings of multiple friends")]
        class ReadSettings_MultipleFriends : TestBase
        {
            override protected void Execute()
            {
                UserSetting[] us;

                // Create another user
                XeUser Friend1 = UserSetup.CreateXbox360User();
                XeUser Friend2 = UserSetup.CreateXbox360User();

                SetSettingDifficulty(Friend1, oSettingDiff);
                SetSettingSensitivity(Friend1, oSettingSens);
                SetSettingDifficulty(Friend2, oSettingDiff);
                SetSettingSensitivity(Friend2, oSettingSens);

                // Make Friends
                PNUser pnRequestor = new PNUser(u.Gamertag, u.UserPuid);
                PNUser pnFriend1 = new PNUser(Friend1.Gamertag, Friend1.UserPuid);
                PNUser pnFriend2 = new PNUser(Friend2.Gamertag, Friend2.UserPuid);

                _fc.MakeFriend(pnRequestor, pnFriend1);
                _fc.MakeFriend(pnRequestor, pnFriend2);


                //MakeFriends(u, Friend1);
                //MakeFriends(u, Friend2);

                UInt64[] userArray = new UInt64[] { Friend1.UserPuid, Friend2.UserPuid };
                uint[] settingArray = new uint[] { settingDiffID, settingSensID };

                // Wait for the cache to pick up the change
                Thread.Sleep(sleepTime);

                // Fetch the user settings
                us = wp.ReadSettings(u.UserPuid, titleID, 1, userArray, settingArray);   // 1 = en-US

                ValueCheck.Test("Profile Widget", us.Length, settingArray.Length * userArray.Length);
                ValueCheck.Test("Profile Widget", ReadProfileStatus.ERROR_NO_PERMISSION, us[0].status);
                ValueCheck.Test("Profile Widget", ReadProfileStatus.ERROR_NO_PERMISSION, us[1].status);
                ValueCheck.Test("Profile Widget", ReadProfileStatus.ERROR_NO_PERMISSION, us[2].status);
                ValueCheck.Test("Profile Widget", ReadProfileStatus.ERROR_NO_PERMISSION, us[3].status);
                ValueCheck.Test("Profile Widget", us[0].uiSettingId, settingArray[0]);
                ValueCheck.Test("Profile Widget", us[1].uiSettingId, settingArray[1]);
                ValueCheck.Test("Profile Widget", us[2].uiSettingId, settingArray[0]);
                ValueCheck.Test("Profile Widget", us[3].uiSettingId, settingArray[1]);
                ValueCheck.Test("Profile Widget", us[0].ulUserId, Friend1.UserPuid);
                ValueCheck.Test("Profile Widget", us[1].ulUserId, Friend1.UserPuid);
                ValueCheck.Test("Profile Widget", us[2].ulUserId, Friend2.UserPuid);
                ValueCheck.Test("Profile Widget", us[3].ulUserId, Friend2.UserPuid);
                DoValCheckSetting("Profile Widget", us[0], 0);
                DoValCheckSetting("Profile Widget", us[1], 0);
                DoValCheckSetting("Profile Widget", us[2], 0);
                DoValCheckSetting("Profile Widget", us[3], 0);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("Read the settings of multiple users, friends and non friends")]
        class ReadSettings_FriendsAndNonFriends : TestBase
        {
            override protected void Execute()
            {
                UserSetting[] us;

                // Create another user
                XeUser Friend = UserSetup.CreateXbox360User();
                XeUser nonFriend = UserSetup.CreateXbox360User();

                SetSettingDifficulty(Friend, oSettingDiff);
                SetSettingSensitivity(Friend, oSettingSens);
                SetSettingDifficulty(nonFriend, oSettingDiff);
                SetSettingSensitivity(nonFriend, oSettingSens);

                PNUser pnRequestor = new PNUser(u.Gamertag, u.UserPuid);
                PNUser pnFriend = new PNUser(Friend.Gamertag, Friend.UserPuid);
                _fc.MakeFriend(pnRequestor, pnFriend);

                // Make Friends
                //MakeFriends(u, Friend);

                UInt64[] userArray = new UInt64[] { Friend.UserPuid, nonFriend.UserPuid };
                uint[] settingArray = new uint[] { settingDiffID, settingSensID };

                // Wait for the cache to pick up the change
                Thread.Sleep(sleepTime);

                // Fetch the user settings
                us = wp.ReadSettings(u.UserPuid, titleID, 1, userArray, settingArray);   // 1 = en-US

                ValueCheck.Test("Profile Widget", us.Length, settingArray.Length * userArray.Length);
                ValueCheck.Test("Profile Widget", ReadProfileStatus.ERROR_NO_PERMISSION, us[0].status);
                ValueCheck.Test("Profile Widget", ReadProfileStatus.ERROR_NO_PERMISSION, us[1].status);
                ValueCheck.Test("Profile Widget", ReadProfileStatus.ERROR_NO_PERMISSION, us[2].status);
                ValueCheck.Test("Profile Widget", ReadProfileStatus.ERROR_NO_PERMISSION, us[3].status);
                ValueCheck.Test("Profile Widget", us[0].uiSettingId, settingArray[0]);
                ValueCheck.Test("Profile Widget", us[1].uiSettingId, settingArray[1]);
                ValueCheck.Test("Profile Widget", us[2].uiSettingId, settingArray[0]);
                ValueCheck.Test("Profile Widget", us[3].uiSettingId, settingArray[1]);
                ValueCheck.Test("Profile Widget", us[0].ulUserId, Friend.UserPuid);
                ValueCheck.Test("Profile Widget", us[1].ulUserId, Friend.UserPuid);
                ValueCheck.Test("Profile Widget", us[2].ulUserId, nonFriend.UserPuid);
                ValueCheck.Test("Profile Widget", us[3].ulUserId, nonFriend.UserPuid);
                DoValCheckSetting("Profile Widget", us[0], 0);
                DoValCheckSetting("Profile Widget", us[1], 0);
                DoValCheckSetting("Profile Widget", us[2], 0);
                DoValCheckSetting("Profile Widget", us[3], 0);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("Read duplicate settings")]
        class ReadSettings_SettingDuplicates : TestBase
        {
            override protected void Execute()
            {
                UserSetting[] us;

                UInt64[] userArray = new UInt64[] { u.UserPuid };
                uint[] settingArray = new uint[] { settingDiffID, settingDiffID, settingDiffID };

                // Fetch the user settings
                us = wp.ReadSettings(u.UserPuid, titleID, 1, userArray, settingArray);   // 1 = en-US

                ValueCheck.Test("Profile Widget", us.Length, settingArray.Length * userArray.Length);
                for (int i = 0; i < us.Length; i++)
                {
                    ValueCheck.Test("Profile Widget", us[i].uiSettingId, settingArray[i]);
                    DoValCheckSetting("Profile Widget", us[i], uSettingDiff);
                }

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("Read all of the settings")]
        class ReadSettings_MultipleSettings : TestBase
        {
            override protected void Execute()
            {
                UserSetting[] us;

                UInt64[] userArray = new UInt64[] { u.UserPuid };

                // Add the rest of the possible data types
                uint[] settingArray = new uint[] { 0x1040A001, 0x10040000, 0x10040006, 0x10040012, 0x10040013, 0x5004000B,
                                                   0x20080001, 0x30080002, 0x40080003, 0x40080004, 0x60040005, 0x70070006};

                // Fetch the user settings
                us = wp.ReadSettings(u.UserPuid, titleID, 1, userArray, settingArray);   // 1 = en-US

                ValueCheck.Test("Profile Widget", us.Length, settingArray.Length * userArray.Length);
                for (int i = 0; i < us.Length; i++)
                {
                    ValueCheck.Test("Profile Widget", us[i].uiSettingId, settingArray[i]);
                }

                ////TODO:...hrm...values of these setting need checked?  what are they expected to be, and where did those id numbers come from?

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("Get setting with max binary size data")]
        class ReadSettings_MaxBinaryDataInSetting : TestBase
        {
            override protected void Execute()
            {
                UserSetting[] us;

                UInt64[] userArray = new UInt64[] { u.UserPuid };
                uint[] settingArray = new uint[] { settingBinAtMax };

                //fetch the user settings
                us = wp.ReadSettings(u.UserPuid, titleID, 1, userArray, settingArray);

                //check it
                ValueCheck.Test("Profile Widget", us.Length, settingArray.Length * userArray.Length);
                ValueCheck.Test("Profile Widget", ReadProfileStatus.SUCCESS_DEFAULT, us[0].status);
                ValueCheck.Test("Profile Widget", XPROFILE_SETTING_MAX_SIZE, ((byte[])(us[0].value)).Length);

                for (uint i = 0; i < XPROFILE_SETTING_MAX_SIZE; ++i)
                    if (((byte[])(us[0].value))[i] != uSettingBinAtMax[i]) throw new UnexpectedTestResultException("Profile Widget: array values in big array setting don't match\n");

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        // --- Negative

        [TestCase, Description("Empty User array")]
        class Neg_EmptyUserArray : TestBase
        {
            override protected void Execute()
            {
                UserSetting[] us;

                UInt64[] userArray = new UInt64[] { };
                uint[] settingArray = new uint[] { settingSensID };

                // Fetch the user settings
                us = wp.ReadSettings(u.UserPuid, titleID, 1, userArray, settingArray);   // 1 = en-US

                //UserSetting[] should be empty.
                ValueCheck.Test("Profile Widget", us.Length, 0);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }


        [TestCase, Description("Invalid Locale")]
        class Neg_BadLocale : TestBase
        {
            override protected void Execute()
            {
                UserSetting[] us;

                UInt64[] userArray = new UInt64[] { u.UserPuid };
                uint[] settingArray = new uint[] { settingSensID };

                // Fetch the user settings
                us = wp.ReadSettings(u.UserPuid, titleID, 10, userArray, settingArray);   // 10 = invalid

                // should default to the title's default language ID and succeed
                ValueCheck.Test("Profile Widget", us.Length, settingArray.Length * userArray.Length);
                ValueCheck.Test("Profile Widget", ReadProfileStatus.SUCCESS_DEFAULT, us[0].status);
                DoValCheckSetting("Profile Widget", us[0], uSettingSens);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("Bad User ID")]
        class Neg_ReadSettings_BadUserID : TestBase
        {
            override protected void Execute()
            {
                UserSetting[] us;

                UInt64[] userArray = new UInt64[] { u.UserPuid };
                uint[] settingArray = new uint[] { settingSensID };

                // Fetch the user settings
                try
                {
                    us = wp.ReadSettings(0, titleID, 1, userArray, settingArray);   // 1 = en-US
                }
                catch
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

        [TestCase, Description("Bad Title ID")]
        class Neg_ReadSettings_BadTitleID : TestBase
        {
            override protected void Execute()
            {
                UserSetting[] us;

                UInt64[] userArray = new UInt64[] { u.UserPuid };
                uint[] settingArray = new uint[] { settingSensID };

                // Fetch the user settings
                try
                {
                    us = wp.ReadSettings(u.UserPuid, 0, 1, userArray, settingArray);   // 1 = en-US
                }
                catch
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

        [TestCase, Description("Empty Settings array")]
        class Neg_EmptySettingsArray : TestBase
        {
            override protected void Execute()
            {
                UserSetting[] us;

                UInt64[] userArray = new UInt64[] { u.UserPuid };
                uint[] settingArray = new uint[] { };

                // Fetch the user settings
                us = wp.ReadSettings(u.UserPuid, titleID, 1, userArray, settingArray);   // 1 = en-US

                //UserSetting[] should be empty.
                ValueCheck.Test("Profile Widget", us.Length, 0);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("Bad Settings ID")]
        class Neg_ReadSettings_BadSettingsID : TestBase
        {
            override protected void Execute()
            {
                UserSetting[] us;

                UInt64[] userArray = new UInt64[] { u.UserPuid };
                uint[] settingArray = new uint[] { 0xFFFFFFFF };

                // Fetch the user settings
                us = wp.ReadSettings(u.UserPuid, titleID, 1, userArray, settingArray);   // 1 = en-US

                ValueCheck.Test("Profile Widget", us.Length, settingArray.Length * userArray.Length);
                ValueCheck.Test("Profile Widget", ReadProfileStatus.WARNING_NO_VALUE, us[0].status);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("Multiple Bad Settings ID")]
        class Neg_ReadSettings_MultipleBadSettingsID : TestBase
        {
            override protected void Execute()
            {
                UserSetting[] us;

                UInt64[] userArray = new UInt64[] { u.UserPuid };
                uint[] settingArray = new uint[] { 0xFFFFFFFF, 778312 };

                // Fetch the user settings
                us = wp.ReadSettings(u.UserPuid, titleID, 1, userArray, settingArray);   // 1 = en-US

                ValueCheck.Test("Profile Widget", us.Length, settingArray.Length * userArray.Length);
                ValueCheck.Test("Profile Widget", ReadProfileStatus.WARNING_NO_VALUE, us[0].status);
                ValueCheck.Test("Profile Widget", ReadProfileStatus.WARNING_NO_VALUE, us[1].status);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("Duplicate Bad Settings ID")]
        class Neg_ReadSettings_DuplicateBadSettingsID : TestBase
        {
            override protected void Execute()
            {
                UserSetting[] us;

                UInt64[] userArray = new UInt64[] { u.UserPuid };
                uint[] settingArray = new uint[] { 0xFFFFFFFF, 778312, 778312 };

                // Fetch the user settings
                us = wp.ReadSettings(u.UserPuid, titleID, 1, userArray, settingArray);   // 1 = en-US

                ValueCheck.Test("Profile Widget", us.Length, settingArray.Length * userArray.Length);
                ValueCheck.Test("Profile Widget", ReadProfileStatus.WARNING_NO_VALUE, us[0].status);
                ValueCheck.Test("Profile Widget", ReadProfileStatus.WARNING_NO_VALUE, us[1].status);
                ValueCheck.Test("Profile Widget", ReadProfileStatus.WARNING_NO_VALUE, us[2].status);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("Mixed Settings ID")]
        class Neg_ReadSettings_MixedSettingsID : TestBase
        {
            override protected void Execute()
            {
                UserSetting[] us;

                UInt64[] userArray = new UInt64[] { u.UserPuid };
                uint[] settingArray = new uint[] { settingSensID, 0xFFFFFFFF, settingDiffID };

                // Fetch the user settings
                us = wp.ReadSettings(u.UserPuid, titleID, 1, userArray, settingArray);   // 1 = en-US

                ValueCheck.Test("Profile Widget", us.Length, settingArray.Length * userArray.Length);
                ValueCheck.Test("Profile Widget", ReadProfileStatus.SUCCESS_DEFAULT, us[0].status);
                ValueCheck.Test("Profile Widget", ReadProfileStatus.WARNING_NO_VALUE, us[1].status);
                ValueCheck.Test("Profile Widget", ReadProfileStatus.SUCCESS_DEFAULT, us[2].status);
                DoValCheckSetting("Profile Widget", us[0], uSettingSens);
                DoValCheckSetting("Profile Widget", us[2], uSettingDiff);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("Oversized Settings Array")]
        class Neg_ReadSettings_OversizedSettingsArray : TestBase
        {
            override protected void Execute()
            {
                UserSetting[] us;

                UInt64[] userArray = new UInt64[] { u.UserPuid };
                uint[] settingArray = new uint[] { settingSensID, settingDiffID, settingSensID, settingDiffID, settingSensID, settingDiffID,
                                                   settingSensID, settingDiffID, settingSensID, settingDiffID, settingSensID, settingDiffID,
                                                   settingSensID, settingDiffID, settingSensID, settingDiffID, settingSensID, settingDiffID,
                                                   settingSensID, settingDiffID, settingSensID, settingDiffID, settingSensID, settingDiffID,
                                                   settingSensID, settingDiffID, settingSensID, settingDiffID, settingSensID, settingDiffID,
                                                   settingSensID, settingDiffID, settingSensID}; //33 total

                // Fetch the user settings
                try
                {
                    us = wp.ReadSettings(u.UserPuid, titleID, 1, userArray, settingArray);   // 1 = en-US
                }
                catch
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

        [TestCase, Description("Bad User Array 0")]
        class Neg_ReadSettings_BadUserArray_0 : TestBase
        {
            override protected void Execute()
            {
                UserSetting[] us;

                UInt64[] userArray = new UInt64[] { 0 };
                uint[] settingArray = new uint[] { settingSensID, settingDiffID };

                // Fetch the user settings
                us = wp.ReadSettings(u.UserPuid, titleID, 1, userArray, settingArray);   // 1 = en-US
                ValueCheck.Test("Profile Widget", ReadProfileStatus.ERROR_PUID_INVALID, us[0].status);
                ValueCheck.Test("Profile Widget", ReadProfileStatus.ERROR_PUID_INVALID, us[1].status);

                ValueCheck.Test("Profile Widget", us.Length, settingArray.Length * userArray.Length);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("Bad User Array MAX")]
        class Neg_ReadSettings_BadUserArray_MAX : TestBase
        {
            override protected void Execute()
            {
                UserSetting[] us;

                UInt64[] userArray = new UInt64[] { ulong.MaxValue };
                uint[] settingArray = new uint[] { settingDiffID };

                // Fetch the user settings
                us = wp.ReadSettings(u.UserPuid, titleID, 1, userArray, settingArray);   // 1 = en-US

                ValueCheck.Test("Profile Widget", us.Length, settingArray.Length * userArray.Length);
                ValueCheck.Test("Profile Widget", ReadProfileStatus.ERROR_PUID_INVALID, us[0].status);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("Duplicate non existing users")]
        class Neg_ReadSettings_BadDuplicateUsers : TestBase
        {
            override protected void Execute()
            {
                UserSetting[] us;

                UInt64[] userArray = new UInt64[] { 42, 42 };
                uint[] settingArray = new uint[] { settingDiffID };

                // Fetch the user settings
                us = wp.ReadSettings(u.UserPuid, titleID, 1, userArray, settingArray);   // 1 = en-US

                ValueCheck.Test("Profile Widget", us.Length, settingArray.Length * userArray.Length);
                ValueCheck.Test("Profile Widget", ReadProfileStatus.ERROR_PUID_INVALID, us[0].status);
                ValueCheck.Test("Profile Widget", ReadProfileStatus.ERROR_PUID_INVALID, us[1].status);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("Mixed User Array")]
        class Neg_ReadSettings_MixedUserArray : TestBase
        {
            override protected void Execute()
            {
                UserSetting[] us;

                UInt64[] userArray = new UInt64[] { 0, u.UserPuid };
                uint[] settingArray = new uint[] { settingDiffID };

                // Fetch the user settings
                us = wp.ReadSettings(u.UserPuid, titleID, 1, userArray, settingArray);   // 1 = en-US

                ValueCheck.Test("Profile Widget", us.Length, settingArray.Length * userArray.Length);

                // The return array will be sorted in valid puids first, and then the invalid puids
                ValueCheck.Test("Profile Widget", ReadProfileStatus.SUCCESS_DEFAULT, us[0].status);
                ValueCheck.Test("Profile Widget", ReadProfileStatus.ERROR_PUID_INVALID, us[1].status);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("Oversized User Array > 16 - This should pass")]
        class ReadSettings_OversizedUserArray : TestBase
        {
            override protected void Execute()
            {
                UserSetting[] us;

                UInt64[] userArray = new UInt64[] { u.UserPuid, u.UserPuid, u.UserPuid, u.UserPuid,
                                                    u.UserPuid, u.UserPuid, u.UserPuid, u.UserPuid,
                                                    u.UserPuid, u.UserPuid, u.UserPuid, u.UserPuid,
                                                    u.UserPuid, u.UserPuid, u.UserPuid, u.UserPuid,  u.UserPuid };
                uint[] settingArray = new uint[] { settingDiffID };

                // Fetch the user settings
                try
                {
                    us = wp.ReadSettings(u.UserPuid, titleID, 1, userArray, settingArray);   // 1 = en-US
                    if (us.Length == userArray.Length)
                        ResultCode = TEST_RESULTS.PASSED;
                    else
                        ResultCode = TEST_RESULTS.FAILED;

                }
                catch (Exception e)
                {
                    Global.RO.Error("ReadSettings request threw an exception");
                    Global.RO.Error(e.Message);
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

    } //group class
} //ReadProfileTests
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Query\dll\PerfCounters.cs ===
using System;
using System.Threading;
using System.Diagnostics;
using xonline.common.mgmt;
using xonline.common.service;

namespace xonline.server.webcache.query.dll 
{

    [XomPerformanceCounterCategoryAttr( "WebCache: Query", "Xbox Live: Web Cache server performance counters (Query)" )]

    public class WebCacheQueryCounter : XomPerformanceCounterCategory
    {
        //
        // Base Query API counters
        //
        [XomPerformanceCounterAttr(
             "Query Add requests per second", 
             "Number of Query Add requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter QueryAddRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "Query Add requests total", 
             "Total Query Add requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter QueryAddRequestsTotal;


        [XomPerformanceCounterAttr(
             "Query Update requests per second", 
             "Number of Query Update requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter QueryUpdateRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "Query Update requests total", 
             "Total Query Update requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter QueryUpdateRequestsTotal;


        [XomPerformanceCounterAttr(
             "Query UpdateId requests per second", 
             "Number of Query UpdateId requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter QueryUpdateIdRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "Query UpdateId requests total", 
             "Total Query UpdateId requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter QueryUpdateIdRequestsTotal;


        [XomPerformanceCounterAttr(
             "Query Search requests per second", 
             "Number of Query Search requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter QuerySearchRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "Query Search requests total", 
             "Total Query Search requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter QuerySearchRequestsTotal;


        [XomPerformanceCounterAttr(
             "Query FindFromIds requests per second", 
             "Number of Query FindFromIds requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter QueryFindFromIdsRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "Query FindFromIds requests total", 
             "Total Query FindFromIds requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter QueryFindFromIdsRequestsTotal;


        [XomPerformanceCounterAttr(
             "Query Remove requests per second", 
             "Number of Query Remove requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter QueryRemoveRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "Query Remove requests total", 
             "Total Query Remove requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter QueryRemoveRequestsTotal;

        
        [XomPerformanceCounterAttr(
             "Query RemoveId requests per second", 
             "Number of Query RemoveId requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter QueryRemoveIdRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "Query RemoveId requests total", 
             "Total Query RemoveId requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter QueryRemoveIdRequestsTotal;

        
        [XomPerformanceCounterAttr(
             "Query Select requests per second", 
             "Number of Query Select requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter QuerySelectRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "Query Select requests total", 
             "Total Query Select requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter QuerySelectRequestsTotal;


        //
        // Tools/Utility Counters
        //
        [XomPerformanceCounterAttr(
             "GetXQSConfig requests per second", 
             "Number of GetXQSConfig requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter QueryGetXQSRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "GetXQSConfig requests total", 
             "Total GetXQSConfig requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter QueryGetXQSRequestsTotal;


        //
        // Competition Counters
        //
        [XomPerformanceCounterAttr(
             "Competition Create requests per second", 
             "Number of Competition Create requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter CompetitionCreateRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "Competition Create requests total", 
             "Total Competition Create requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter CompetitionCreateRequestsTotal;


        [XomPerformanceCounterAttr(
             "Competition Create Single Elimination requests per second", 
             "Number of Competition Create Single Elimination requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter CompetitionCreateSERequestsPerSecond;

        [XomPerformanceCounterAttr(
             "Competition Create Single Elimination requests total", 
             "Total Competition Create Single Elimination requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter CompetitionCreateSERequestsTotal;


        [XomPerformanceCounterAttr(
             "Competition Search requests per second", 
             "Number of Competition Search requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter CompetitionSearchRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "Competition Search requests total", 
             "Total Competition Search requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter CompetitionSearchRequestsTotal;


        [XomPerformanceCounterAttr(
             "Competition Manage Entrant requests per second", 
             "Number of Competition Manage Entrant requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter CompetitionManageEntrantRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "Competition Manage Entrant requests total", 
             "Total Competition Manage Entrant requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter CompetitionManageEntrantRequestsTotal;


        [XomPerformanceCounterAttr(
             "Competition Cancel requests per second", 
             "Number of Competition Cancel requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter CompetitionCancelRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "Competition Cancel requests total", 
             "Total Competition Cancel requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter CompetitionCancelRequestsTotal;


        [XomPerformanceCounterAttr(
             "Competition Topology requests per second", 
             "Number of Competition Topology requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter CompetitionTopologyRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "Competition Topology requests total", 
             "Total Competition Topology requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter CompetitionTopologyRequestsTotal;


        [XomPerformanceCounterAttr(
             "Competition Topology Single Elimination requests per second", 
             "Number of Competition Topology Single Elimination requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter CompetitionTopologySERequestsPerSecond;

        [XomPerformanceCounterAttr(
             "Competition Topology Single Elimination requests total", 
             "Total Competition Topology Single Elimination requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter CompetitionTopologySERequestsTotal;

        

        public virtual WebCacheQueryCounter this[string partnerName]
        {
            get
            {
                return (WebCacheQueryCounter) GetInstance(partnerName);
            }
        }

        static public WebCacheQueryCounter Counters = new WebCacheQueryCounter();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Query\test\FuncQueryAdd.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using System.IO;
using System.Xml;
using ServerTestFramework;
using System.Data;
using System.Data.SqlClient;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web;
using ServerTestFramework.Web.Query;
using xonline.common.config;

namespace QueryWidget
{
	[TestGroup]
	public class FuncQueryAdd : TestNode
	{
		// struct to hold input values to the Add method
		struct QueryAddParams
		{
			public System.UInt32 titleId;
			public System.Byte[] webId;
			public string gamerTag;
			public string teamName;
			public System.UInt32 datasetId;
			public QueryAttribute[] attributes;
		}

		/// <summary>
		/// function that uses XML file to return valid parameters
		/// </summary>
		/// <param name="QAP">struct to fill with parameters for call to Add</param>
		/// <param name="attribSel">zero-based short to identify which QA to use in given set of parameters</param>
		/// <returns>false if any errors parsing XML file, else true</returns>
		static bool GetValidParams(ref QueryAddParams QAP)
		{
			return GetValidParams(ref QAP,0);
		}

		static bool GetValidParams(ref QueryAddParams QAP, short attribSel)
		{
			QAP.titleId = QueryWidgetCommon.QUERY_TITLE_ID;
			QAP.webId = QueryWidgetCommon.QUERY_WEBID;
			QAP.gamerTag = QueryWidgetCommon.QUERY_GAMERTAG;
			QAP.teamName = QueryWidgetCommon.QUERY_TEAMNAME;
			QAP.datasetId = QueryWidgetCommon.QUERY_DATASET_ID;

			XmlDocument parameters = new XmlDocument();
			parameters.Load("QueryWidget.xml");

			try
			{
				XmlNodeList paramNodes = parameters.SelectNodes("/stf/parameters/add/attributes");
				if (paramNodes.Count <= attribSel)
					throw new Exception();
				QAP.attributes = new QueryAttribute[paramNodes[attribSel].ChildNodes.Count];
				for (int i=0; i<paramNodes[attribSel].ChildNodes.Count; i++)
				{
					if (paramNodes[attribSel].ChildNodes[i].Name != "attrib")
						throw new Exception();

					QAP.attributes[i] = new QueryAttribute();

					QAP.attributes[i].Id = System.UInt32.Parse(paramNodes[attribSel].ChildNodes[i].Attributes["a_id"].Value,System.Globalization.NumberStyles.AllowHexSpecifier);
					switch (QAP.attributes[i].Id)
					{
						case 1:
							QAP.attributes[i].Value = (long)Convert.ToInt32(paramNodes[attribSel].ChildNodes[i].Attributes["a_value"].Value);
							break;
						case 1048579:
							QAP.attributes[i].Value = paramNodes[attribSel].ChildNodes[i].Attributes["a_value"].Value;
							break;
						case 2097157:
							QAP.attributes[i].Value = Hexer.unhex(paramNodes[attribSel].ChildNodes[i].Attributes["a_value"].Value);
							break;
					}
				}
			}
			catch (Exception)
			{
				ConsoleX.WriteLine("Invalid parameter element found in xml.");
				return false;
			}
			return true;
		}

		static bool RemoveEntry(UInt64 entityId, QueryAddParams QAP)
		{
			bool bRet = true;
			uint nRecords = QueryWidgetCommon.GetNumRecords(QAP.titleId,QAP.datasetId);

			// set up database query
			string sql="DELETE FROM [QueryDB].[dbo].[t_query_dataset_"+Hexer.tohex(QAP.titleId)+"_"+QAP.datasetId.ToString("x")+"] WHERE bi_entity_id = "+entityId;
			SqlCommand mySqlCommand = null;
			SqlDataReader myDataReader = null;
			int nUpdated = 0;

			for (int iSql=0; iSql<QueryWidgetCommon.qrySqlConn.Length; iSql++)
			{
				try
				{
					mySqlCommand = new SqlCommand(sql,QueryWidgetCommon.qrySqlConn[iSql]);
					myDataReader = mySqlCommand.ExecuteReader();

					if (!myDataReader.HasRows && iSql < QueryWidgetCommon.qrySqlConn.Length+1)
						continue;

					// keep track of # entries updated
					nUpdated += myDataReader.RecordsAffected;

					if (myDataReader != null && !myDataReader.IsClosed)
						myDataReader.Close();

					if (nUpdated != 1)
						bRet = false;
				}
				catch (Exception)
				{
					ConsoleX.WriteLine("Failed to remove entity.");
					bRet = false;
					if (QueryWidgetCommon.qrySqlConn[iSql].State != ConnectionState.Open)
						QueryWidgetCommon.qrySqlConn[iSql].Open();
				}
				finally
				{
					// Always call Close when done reading.
					if (myDataReader != null && !myDataReader.IsClosed)
						myDataReader.Close();
				}
			}

			return bRet;
		}

		/// <summary>
		/// function to ensure Add method worked as expected
		/// </summary>
		/// <param name="entityId">value returned from a call to Add</param>
		/// <param name="QAP">parameters passed in the call to Add</param>
		/// <returns>true if entityId found in row of DB with correct attributes and
		/// no other changes to DB, otherwise false</returns>
 		static bool VerifyAdd(UInt64 entityId, QueryAddParams QAP, uint nPrevRecords, DateTime dtTestStart)
		{
			// REM "SELECT [bi_entity_id], [bi_owner_id], [dt_change_datetime], [att_00000001], [att_00100003], [att_00200005] FROM [QueryDB].[dbo].[t_query_dataset_0000b2d2_1]"

			bool bRet=false;
			string strDate = dtTestStart.GetDateTimeFormats()[71];

			// set up database query
			System.Int64 ownerId = (long)QueryWidgetCommon.QUERY_TEAMID;
			if (QAP.gamerTag == null)
				ownerId = QAP.titleId;
			else if (QAP.teamName == null || QAP.teamName == "")
				ownerId = 2814749767106559 - Convert.ToInt32(QAP.gamerTag.Substring(7));	// gamerTags are of format webuserX (X = 0 thru 1023) and PUID starts at 2814749767106559 going down

			string sql="SELECT Count(*) FROM [QueryDB].[dbo].[t_query_dataset_"+Hexer.tohex(QAP.titleId)+"_"+QAP.datasetId.ToString("x")+"] WHERE dt_change_datetime >= '"+strDate+"' AND bi_entity_id = '"+entityId+"' AND bi_owner_id = "+ownerId;
			for (int i=0; i<QAP.attributes.Length; i++)
			{
				sql += " AND att_"+Hexer.tohex((uint)QAP.attributes[i].Id)+" = ";
				if (QAP.attributes[i].Value.GetType() == typeof(long))
					sql += ((long)QAP.attributes[i].Value).ToString();
				else if (QAP.attributes[i].Value.GetType() == typeof(string))
					sql += "'"+(string)QAP.attributes[i].Value+"'";
				else
					sql += "0x" + Hexer.tohex((byte[])QAP.attributes[i].Value);
			}
			SqlCommand mySqlCommand = null;
			SqlDataReader myDataReader = null;
			int nMatchingRecords = 0;

			for (int iSql=0; iSql<QueryWidgetCommon.qrySqlConn.Length; iSql++)
			{
				try
				{
					mySqlCommand = new SqlCommand(sql,QueryWidgetCommon.qrySqlConn[iSql]);
					myDataReader = mySqlCommand.ExecuteReader();

					if (!myDataReader.HasRows && iSql < QueryWidgetCommon.qrySqlConn.Length+1)
						continue;

					// get number of matching records
					if (myDataReader.Read() != false)
						nMatchingRecords += myDataReader.GetInt32(0);

					if (myDataReader != null && !myDataReader.IsClosed)
						myDataReader.Close();

					// verify a record in dataset matches our input

					if (1 == nMatchingRecords)
					{
						// make sure dataset has same # rows as before + 1
						bRet = (nPrevRecords + 1 == QueryWidgetCommon.GetNumRecords(QAP.titleId,QAP.datasetId));

						// make sure no other changes to dataset
						sql="SELECT Count(*) FROM [QueryDB].[dbo].[t_query_dataset_"+Hexer.tohex(QAP.titleId)+"_"+QAP.datasetId.ToString("x")+"] WHERE dt_change_datetime >= '"+strDate+"' AND bi_entity_id <> '"+entityId+"'";
						mySqlCommand = new SqlCommand(sql,QueryWidgetCommon.qrySqlConn[iSql]);
						myDataReader = mySqlCommand.ExecuteReader();

						// check if any entries updated after test started
						bRet &= (myDataReader.Read() != false && myDataReader.GetInt32(0) == 0);

						if (myDataReader != null && !myDataReader.IsClosed)
							myDataReader.Close();
					}
					return bRet;
				}
				catch (Exception e)
				{
					ConsoleX.WriteLine("SQL error in VerifyAdd(): " + e.Message);
					bRet = false;
					if (QueryWidgetCommon.qrySqlConn[iSql].State != ConnectionState.Open)
						QueryWidgetCommon.qrySqlConn[iSql].Open();
				}
				finally
				{
					// Always call Close when done reading.
					if (myDataReader != null && !myDataReader.IsClosed)
						myDataReader.Close();
				}
			}

			return bRet;
		}

		// Positive test cases

		// uncomment following test case for teams/xcache testing
		//		don't forget to uncomment sections in MainClass.cs
/*		[TestCase, Description("QueryAdd Valid: Teams/XCache Testing")]
			class Teams_XCache_Test : TestBase
		{
			protected override void Execute()
			{
				UInt64 result = 0;
				QueryAddParams QAP = new QueryAddParams();
				ResultCode = TEST_RESULTS.FAILED;

				if (!GetValidParams(ref QAP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				WCQuery wc = new WCQuery();

				// create teams
				QueryWidgetCommon.CreateTeams(QueryWidgetCommon.QUERY_TITLE_ID,QueryWidgetCommon.userQuery,QueryWidgetCommon.QueryTeams,QueryWidgetCommon.xboxQuery);

				// wait 12 seconds
				System.Threading.Thread.Sleep(12000);

				// do teams lookup thru Add
				try
				{
					result = wc.WidgetAdd(QAP.titleId,QAP.webId,QAP.gamerTag,QAP.teamName,QAP.datasetId,QAP.attributes);
				}
				catch (Exception e)
				{
					ConsoleX.WriteLine("Add after 12 second interval failed with: "+e.Message);
				}
				finally
				{
					if (0 != result)
						RemoveEntry(result, QAP);
				}

				// wait a bit
//				System.Threading.Thread.Sleep(10000);

				// delete team
				QueryWidgetCommon.QueryTeams[0].Delete();

				// wait a minute
				System.Threading.Thread.Sleep(60000);

				// do teams lookup thru Add
				try
				{
					result = wc.WidgetAdd(QAP.titleId,QAP.webId,QAP.gamerTag,QAP.teamName,QAP.datasetId,QAP.attributes);
				}
				catch (Exception e)
				{
					ConsoleX.WriteLine("Add after team deleted failed with: "+e.Message);
					if (e.Message.EndsWith("Team "+QAP.teamName+" could not be found in the team cache for titleId "+Hexer.tohex(QAP.titleId).ToLower()+" aborting."))
						ResultCode = TEST_RESULTS.PASSED;
				}
				finally
				{
					if (0 != result)
						RemoveEntry(result, QAP);
				}
			}
		}
*/
		[TestCase, Description("QueryAdd Valid: basic verification")]
			class Query_Add_Valid_Basic : TestBase
		{
			protected override void Execute()
			{
				UInt64 result = 0;
				QueryAddParams QAP = new QueryAddParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QAP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				QueryWidgetCommon.FillDBBasedOnAPI(0,0);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QAP.titleId,QAP.datasetId);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					result = wc.WidgetAdd(QAP.titleId,QAP.webId,QAP.gamerTag,QAP.teamName,QAP.datasetId,QAP.attributes);

					if (!VerifyAdd(result, QAP, nRecords, dtTestStart))
						throw new Exception("Verification failed.");
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
				finally
				{
					if (0 != result)
						RemoveEntry(result, QAP);
				}
			}
		}

		[TestCase, Description("QueryAdd Valid: basic verification - Partner")]
			class Query_Add_Valid_Basic_Partner : TestBase
		{
			protected override void Execute()
			{
				UInt64 result = 0;
				QueryAddParams QAP = new QueryAddParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QAP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				QAP.teamName = null;
				QAP.gamerTag = null;
				QAP.webId = BitConverter.GetBytes((UInt64)QAP.titleId);
				QAP.attributes[1].Value = "partner query test";

				QueryWidgetCommon.FillDBBasedOnAPI(0,0);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QAP.titleId,QAP.datasetId);

				RequestInfo rInfo = new RequestInfo("DebugAdmin");
				WCQuery wc = new WCQuery(Global.XEnv.GetVirtualInterface(VirtualInterface.wcquery),rInfo);
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					result = wc.WidgetAdd(QAP.titleId,QAP.webId,QAP.gamerTag,QAP.teamName,QAP.datasetId,QAP.attributes);

					if (!VerifyAdd(result, QAP, nRecords, dtTestStart))
						throw new Exception("Verification failed.");
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
				finally
				{
					if (0 != result)
						RemoveEntry(result, QAP);
				}
			}
		}

		[TestCase, Description("QueryAdd Valid: teamName null")]
			class Query_Add_Valid_teamName_Null : TestBase
		{
			protected override void Execute()
			{
				UInt64 result = 0;
				QueryAddParams QAP = new QueryAddParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QAP))		// get params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set teamName to null so method will use userId
				QAP.teamName = null;

				QueryWidgetCommon.FillDBBasedOnAPI(0,0);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QAP.titleId,QAP.datasetId);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					result = wc.WidgetAdd(QAP.titleId,QAP.webId,QAP.gamerTag,QAP.teamName,QAP.datasetId,QAP.attributes);

					if (!VerifyAdd(result, QAP, nRecords, dtTestStart))
						throw new Exception("Verification failed.");
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
				finally
				{
					if (0 != result)
						RemoveEntry(result, QAP);
				}
			}
		}

		[TestCase, Description("QueryAdd Valid: teamName empty")]
			class Query_Add_Valid_teamName_Empty : TestBase
		{
			protected override void Execute()
			{
				UInt64 result = 0;
				QueryAddParams QAP = new QueryAddParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QAP))		// get params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set teamName to null so method will use userId
				QAP.teamName = "";

				QueryWidgetCommon.FillDBBasedOnAPI(0,0);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QAP.titleId,QAP.datasetId);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					result = wc.WidgetAdd(QAP.titleId,QAP.webId,QAP.gamerTag,QAP.teamName,QAP.datasetId,QAP.attributes);

					if (!VerifyAdd(result, QAP, nRecords, dtTestStart))
						throw new Exception("Verification failed.");
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
				finally
				{
					if (0 != result)
						RemoveEntry(result, QAP);
				}
			}
		}

		[TestCase, Description("QueryAdd Valid: teamName padded with spaces")]
			class Query_Add_Valid_TeamName_Padded : TestBase
		{
			protected override void Execute()
			{
				UInt64 [] result = new UInt64[2];
				result[0] = 0;
				result[1] = 0;
				QueryAddParams QAP = new QueryAddParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QAP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				QueryWidgetCommon.FillDBBasedOnAPI(0,0);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QAP.titleId,QAP.datasetId);
				QAP.teamName += " ";

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					// try teamName padded at end
					result[0] = wc.WidgetAdd(QAP.titleId,QAP.webId,QAP.gamerTag,QAP.teamName,QAP.datasetId,QAP.attributes);
					if (!VerifyAdd(result[0], QAP, nRecords, dtTestStart))
						throw new Exception();

					nRecords++;
					Thread.Sleep(1500);	// sleep a second so next call to get time will have different value

					// try teamName padded at beginning
					QAP.teamName = " " + QAP.teamName.Trim();
					dtTestStart = QueryWidgetCommon.GetSqlServerTime();

					result[1] = wc.WidgetAdd(QAP.titleId,QAP.webId,QAP.gamerTag,QAP.teamName,QAP.datasetId,QAP.attributes);
					if (!VerifyAdd(result[1], QAP, nRecords, dtTestStart))
						throw new Exception();
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}

				for (int i=0; i<result.Length; i++)
				{
					if (0 != result[i])
						RemoveEntry(result[i],QAP);
				}
			}
		}

		[TestCase, Description("QueryAdd Valid: database empty")]
			class Query_Add_Valid_Database_Empty : TestBase
		{
			protected override void Execute()
			{
				UInt64 result = 0;
				QueryAddParams QAP = new QueryAddParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QAP))		// get params used in basic verify
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// clear the dataset
				QueryWidgetCommon.ClearDataSet(QAP.titleId, QAP.datasetId);

				uint nRecords = QueryWidgetCommon.GetNumRecords(QAP.titleId,QAP.datasetId);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					result = wc.WidgetAdd(QAP.titleId,QAP.webId,QAP.gamerTag,QAP.teamName,QAP.datasetId,QAP.attributes);

					if (!VerifyAdd(result, QAP, nRecords, dtTestStart))
						throw new Exception("Verification failed.");
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
				finally
				{
					if (0 != result)
						RemoveEntry(result, QAP);
					// restore the dataset
					QueryWidgetCommon.FillDBBasedOnAPI(0,0);
				}
			}
		}

		[TestCase, Description("QueryAdd Valid: almost identical entries, except teamName null/X")]
			class Query_Add_Valid_Identical_But_Team : TestBase
		{
			protected override void Execute()
			{
				UInt64 result=0, secondresult=0;
				QueryAddParams QAP = new QueryAddParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QAP))		// get params with teamName NOT 0
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				QueryWidgetCommon.FillDBBasedOnAPI(0,0);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QAP.titleId,QAP.datasetId);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					result = wc.WidgetAdd(QAP.titleId,QAP.webId,QAP.gamerTag,QAP.teamName,QAP.datasetId,QAP.attributes);

					if (!VerifyAdd(result, QAP, nRecords, dtTestStart))
						throw new Exception("Verification failed for first call to Add.");

					QAP.teamName = null;				// now try identical add, but teamName = null so will use user ID

					nRecords++;
					Thread.Sleep(1000);	// sleep a second so next call to get time will have different value
					dtTestStart = QueryWidgetCommon.GetSqlServerTime();
					secondresult = wc.WidgetAdd(QAP.titleId,QAP.webId,QAP.gamerTag,QAP.teamName,QAP.datasetId,QAP.attributes);

					if (!VerifyAdd(secondresult, QAP, nRecords, dtTestStart))
						throw new Exception("Verification failed for second call to Add.");
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
				finally
				{
					if (0 != result)
						RemoveEntry(result, QAP);
					if (0 != secondresult)
						RemoveEntry(secondresult, QAP);
				}
			}
		}

		[TestCase, Description("QueryAdd Valid: user/team at one below quota")]
			class Query_Add_Valid_User_One_Below_Quota : TestBase
		{
			protected override void Execute()
			{
				UInt64 [] result = new UInt64[QueryWidgetCommon.USER_QUOTA];
				for (int i=0; i<QueryWidgetCommon.USER_QUOTA; i++)
					result[i] = 0;
				QueryAddParams QAP = new QueryAddParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QAP))		// get params
					throw new Exception("Could not obtain params from xml file.");

				QueryWidgetCommon.FillDBBasedOnAPI(0,0);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QAP.titleId,QAP.datasetId);

				try
				{
					for (short i=0; i<QueryWidgetCommon.USER_QUOTA; i++)
					{
						if (!GetValidParams(ref QAP,i))		// get params, different QA per call
							throw new Exception("Could not obtain params from xml file.");

						WCQuery wc = new WCQuery();
						DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
						result[i] = wc.WidgetAdd(QAP.titleId,QAP.webId,QAP.gamerTag,QAP.teamName,QAP.datasetId,QAP.attributes);

						if (!VerifyAdd(result[i], QAP, nRecords, dtTestStart))
							throw new Exception("Verification failed on add #"+i.ToString());

						nRecords++;
						Thread.Sleep(1000);	// sleep a second so next call to get time will have different value
					}
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
				finally
				{
					for (int i=0; i<QueryWidgetCommon.USER_QUOTA; i++)
					{
						if (0 != result[i])
							RemoveEntry(result[i], QAP);
					}
				}
			}
		}

		[TestCase, Description("QueryAdd Valid: add identical entry twice")]
			class Query_Add_Valid_Add_Twice : TestBase
		{
			protected override void Execute()
			{
				UInt64 [] result = new UInt64[2];
				result[0] = 0;
				result[1] = 0;
				QueryAddParams QAP = new QueryAddParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QAP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				QueryWidgetCommon.FillDBBasedOnAPI(0,0);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QAP.titleId,QAP.datasetId);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					for (int i=0; i<2; i++)
					{
						result[i] = wc.WidgetAdd(QAP.titleId,QAP.webId,QAP.gamerTag,QAP.teamName,QAP.datasetId,QAP.attributes);

						if (!VerifyAdd(result[i], QAP, nRecords, dtTestStart))
							throw new Exception();
						nRecords++;
						Thread.Sleep(1500);	// sleep a second so next call to get time will have different value
						dtTestStart = QueryWidgetCommon.GetSqlServerTime();
					}
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}

				for (int i=0; i<result.Length; i++)
				{
					if (0 != result[i])
						RemoveEntry(result[i],QAP);
				}
			}
		}

		// Negative test cases

		[TestCase, Description("QueryAdd Invalid: user/team at quota")]
			class Query_Add_Invalid_Owner_At_Quota : TestBase
		{
			protected override void Execute()
			{
				UInt64 [] result = new UInt64[QueryWidgetCommon.USER_QUOTA+1];
				for (int i=0; i<result.Length; i++)
					result[i] = 0;
				QueryAddParams QAP = new QueryAddParams();
				ResultCode = TEST_RESULTS.PASSED;
				WCQuery wc;
				DateTime dtTestStart;

				if (!GetValidParams(ref QAP))		// get params
				{
					ResultCode = TEST_RESULTS.FAILED;
					goto Cleanup;
				}

				QueryWidgetCommon.FillDBBasedOnAPI(0,0);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QAP.titleId,QAP.datasetId);

				try
				{
					for (short i=0; i<QueryWidgetCommon.USER_QUOTA; i++)
					{
						if (!GetValidParams(ref QAP,i))		// get params, different QA per call
						{
							ResultCode = TEST_RESULTS.FAILED;
							goto Cleanup;
						}

						wc = new WCQuery();
						dtTestStart = QueryWidgetCommon.GetSqlServerTime();
						result[i] = wc.WidgetAdd(QAP.titleId,QAP.webId,QAP.gamerTag,QAP.teamName,QAP.datasetId,QAP.attributes);

						if (!VerifyAdd(result[i], QAP, nRecords, dtTestStart))
							throw new Exception();

						nRecords++;
						Thread.Sleep(1000);	// sleep a second so next call to get time will have different value
					}
				}
				catch (Exception)
				{
					ConsoleX.WriteLine("Adding entries for user/team prior to exceeding quota failed.");
					ResultCode = TEST_RESULTS.FAILED;
					goto Cleanup;
				}

				if (!GetValidParams(ref QAP,QueryWidgetCommon.USER_QUOTA))		// get params, different QA than before
				{
					ResultCode = TEST_RESULTS.FAILED;
					goto Cleanup;
				}

				wc = new WCQuery();
				dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					result[QueryWidgetCommon.USER_QUOTA] = wc.WidgetAdd(QAP.titleId,QAP.webId,QAP.gamerTag,QAP.teamName,QAP.datasetId,QAP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("This user or teams quota for the dataset is full.  You must first remove an entity before more can be added."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QAP.titleId,QAP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					goto Cleanup;
				}

				ResultCode = TEST_RESULTS.FAILED;

				Cleanup:
					for (int i=0; i<result.Length; i++)
					{
						if (0 != result[i])
							RemoveEntry(result[i],QAP);
					}
			}
		}

		[TestCase, Description("QueryAdd Invalid: partner with read-only access")]
			class Query_Add_Invalid_ReadOnly_Partner : TestBase
		{
			protected override void Execute()
			{
				UInt64 result = 0;
				QueryAddParams QAP = new QueryAddParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QAP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				QueryWidgetCommon.FillDBBasedOnAPI(0,0);

				WCQuery wc = new WCQuery(Global.XEnv.GetVirtualInterface(VirtualInterface.wcquery), new RequestInfo("asschw"));
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					result = wc.WidgetAdd(QAP.titleId,QAP.webId,QAP.gamerTag,QAP.teamName,QAP.datasetId,QAP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Partner:asschw not allowed to access TitleID:"+Hexer.tohex(QAP.titleId)))
						ResultCode = TEST_RESULTS.FAILED;
					goto Cleanup;
				}

				ResultCode = TEST_RESULTS.FAILED;

				Cleanup:
					if (0 != result)
						RemoveEntry(result,QAP);
			}
		}

		[TestCase, Description("QueryAdd Invalid: unknown titleId")]
			class Query_Add_Invalid_Unknown_Title : TestBase
		{
			protected override void Execute()
			{
				UInt64 result = 0;
				QueryAddParams QAP = new QueryAddParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QAP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				QueryWidgetCommon.FillDBBasedOnAPI(0,0);
				QAP.titleId = QueryWidgetCommon.TITLEID_NOT_EXIST;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					result = wc.WidgetAdd(QAP.titleId,QAP.webId,QAP.gamerTag,QAP.teamName,QAP.datasetId,QAP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Partner:DebugPartner not allowed to access TitleID:"+Hexer.tohex(QAP.titleId)))
						ResultCode = TEST_RESULTS.FAILED;
					goto Cleanup;
				}

				ResultCode = TEST_RESULTS.FAILED;

				Cleanup:
					if (0 != result)
						RemoveEntry(result,QAP);
			}
		}

		[TestCase, Description("QueryAdd Invalid: titleId doesn't support Query Service")]
			class Query_Add_Invalid_Title_Unsupported : TestBase
		{
			protected override void Execute()
			{
				UInt64 result = 0;
				QueryAddParams QAP = new QueryAddParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QAP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				QueryWidgetCommon.FillDBBasedOnAPI(0,0);

				QAP.titleId = QueryWidgetCommon.TITLEID_NO_QUERY;
				QAP.teamName = "";

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					result = wc.WidgetAdd(QAP.titleId,QAP.webId,QAP.gamerTag,QAP.teamName,QAP.datasetId,QAP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;
					goto Cleanup;
				}

				ResultCode = TEST_RESULTS.FAILED;

				Cleanup:
					if (0 != result)
						RemoveEntry(result,QAP);
			}
		}

		[TestCase, Description("QueryAdd Invalid: titleId MAX_UINT32")]
			class Query_Add_Invalid_TitleId_Max : TestBase
		{
			protected override void Execute()
			{
				UInt64 result = 0;
				QueryAddParams QAP = new QueryAddParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QAP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				QueryWidgetCommon.FillDBBasedOnAPI(0,0);
				QAP.titleId = UInt32.MaxValue;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					result = wc.WidgetAdd(QAP.titleId,QAP.webId,QAP.gamerTag,QAP.teamName,QAP.datasetId,QAP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Partner:DebugPartner not allowed to access TitleID:"+Hexer.tohex(QAP.titleId)))
						ResultCode = TEST_RESULTS.FAILED;
					goto Cleanup;
				}

				ResultCode = TEST_RESULTS.FAILED;

				Cleanup:
					if (0 != result)
						RemoveEntry(result,QAP);
			}
		}

		[TestCase, Description("QueryAdd Invalid: webId null")]
			class Query_Add_Invalid_WebId_Null : TestBase
		{
			protected override void Execute()
			{
				UInt64 result = 0;
				QueryAddParams QAP = new QueryAddParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QAP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				QueryWidgetCommon.FillDBBasedOnAPI(0,0);
				QAP.webId = null;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					result = wc.WidgetAdd(QAP.titleId,QAP.webId,QAP.gamerTag,QAP.teamName,QAP.datasetId,QAP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Bad Passport web ID, null not allowed"))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QAP.titleId,QAP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					goto Cleanup;
				}

				ResultCode = TEST_RESULTS.FAILED;

				Cleanup:
					if (0 != result)
						RemoveEntry(result,QAP);
			}
		}

		[TestCase, Description("QueryAdd Invalid: webId doesn't exist")]
			class Query_Add_Invalid_WebId_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				UInt64 result = 0;
				QueryAddParams QAP = new QueryAddParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QAP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				QueryWidgetCommon.FillDBBasedOnAPI(0,0);
				QAP.webId = QueryWidgetCommon.WEBID_NOT_EXIST;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					result = wc.WidgetAdd(QAP.titleId,QAP.webId,QAP.gamerTag,QAP.teamName,QAP.datasetId,QAP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("(webID,GamerTag) pair ("+Hexer.tohex(QAP.webId,true)+","+QAP.gamerTag+") is not linked in our system"))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QAP.titleId,QAP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					goto Cleanup;
				}

				ResultCode = TEST_RESULTS.FAILED;

				Cleanup:
					if (0 != result)
						RemoveEntry(result,QAP);
			}
		}

		[TestCase, Description("QueryAdd Invalid: webId/gamerTag mismatch")]
			class Query_Add_Invalid_WebId_GamerTag_Mismatch : TestBase
		{
			protected override void Execute()
			{
				UInt64 result = 0;
				QueryAddParams QAP = new QueryAddParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QAP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				QueryWidgetCommon.FillDBBasedOnAPI(0,0);
				QAP.webId = QueryWidgetCommon.WEBID_NO_MATCH;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					result = wc.WidgetAdd(QAP.titleId,QAP.webId,QAP.gamerTag,QAP.teamName,QAP.datasetId,QAP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("(webID,GamerTag) pair ("+Hexer.tohex(QAP.webId,true)+","+QAP.gamerTag+") is not linked in our system"))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QAP.titleId,QAP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					goto Cleanup;
				}

				ResultCode = TEST_RESULTS.FAILED;

				Cleanup:
					if (0 != result)
						RemoveEntry(result,QAP);
			}
		}

		[TestCase, Description("QueryAdd Invalid: webId too short")]
			class Query_Add_Invalid_WebId_Too_Short : TestBase
		{
			protected override void Execute()
			{
				UInt64 result = 0;
				QueryAddParams QAP = new QueryAddParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QAP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				QueryWidgetCommon.FillDBBasedOnAPI(0,0);
				QAP.webId = QueryWidgetCommon.WEBID_TOO_SHORT;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					result = wc.WidgetAdd(QAP.titleId,QAP.webId,QAP.gamerTag,QAP.teamName,QAP.datasetId,QAP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Bad Passport web ID, length is "+QAP.webId.Length.ToString()))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QAP.titleId,QAP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					goto Cleanup;
				}

				ResultCode = TEST_RESULTS.FAILED;

				Cleanup:
					if (0 != result)
						RemoveEntry(result,QAP);
			}
		}

		[TestCase, Description("QueryAdd Invalid: webId too long")]
			class Query_Add_Invalid_WebId_Too_Long : TestBase
		{
			protected override void Execute()
			{
				UInt64 result = 0;
				QueryAddParams QAP = new QueryAddParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QAP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				QueryWidgetCommon.FillDBBasedOnAPI(0,0);
				QAP.webId = QueryWidgetCommon.WEBID_TOO_LONG;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					result = wc.WidgetAdd(QAP.titleId,QAP.webId,QAP.gamerTag,QAP.teamName,QAP.datasetId,QAP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Bad Passport web ID, length is "+QAP.webId.Length.ToString()))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QAP.titleId,QAP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					goto Cleanup;
				}

				ResultCode = TEST_RESULTS.FAILED;

				Cleanup:
					if (0 != result)
						RemoveEntry(result,QAP);
			}
		}

		[TestCase, Description("QueryAdd Invalid: VERY long webId")]
			class Query_Add_Invalid_WebId_VERY_long : TestBase
		{
			protected override void Execute()
			{
				UInt64 result = 0;
				QueryAddParams QAP = new QueryAddParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QAP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				QueryWidgetCommon.FillDBBasedOnAPI(0,0);
				QAP.webId = new byte[999999];
				for (int i=0; i<999999; i++)
				{
					QAP.webId[i] = (byte)(i%16);
				}

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					result = wc.WidgetAdd(QAP.titleId,QAP.webId,QAP.gamerTag,QAP.teamName,QAP.datasetId,QAP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Bad Passport web ID, length is 999999"))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QAP.titleId,QAP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					goto Cleanup;
				}

				ResultCode = TEST_RESULTS.FAILED;

				Cleanup:
					if (0 != result)
						RemoveEntry(result,QAP);
			}
		}

		[TestCase, Description("QueryAdd Invalid: gamerTag null")]
			class Query_Add_Invalid_GamerTag_Null : TestBase
		{
			protected override void Execute()
			{
				UInt64 result = 0;
				QueryAddParams QAP = new QueryAddParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QAP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				QueryWidgetCommon.FillDBBasedOnAPI(0,0);
				QAP.gamerTag = null;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					result = wc.WidgetAdd(QAP.titleId,QAP.webId,QAP.gamerTag,QAP.teamName,QAP.datasetId,QAP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Bad GamerTag provided, null not allowed"))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QAP.titleId,QAP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					goto Cleanup;
				}

				ResultCode = TEST_RESULTS.FAILED;

				Cleanup:
					if (0 != result)
						RemoveEntry(result,QAP);
			}
		}

		[TestCase, Description("QueryAdd Invalid: gamerTag empty string")]
			class Query_Add_Invalid_GamerTag_Empty : TestBase
		{
			protected override void Execute()
			{
				UInt64 result = 0;
				QueryAddParams QAP = new QueryAddParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QAP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				QueryWidgetCommon.FillDBBasedOnAPI(0,0);
				QAP.gamerTag = "";

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					result = wc.WidgetAdd(QAP.titleId,QAP.webId,QAP.gamerTag,QAP.teamName,QAP.datasetId,QAP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("(webID,GamerTag) pair ("+Hexer.tohex(QAP.webId,true)+","+QAP.gamerTag+") is not linked in our system"))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QAP.titleId,QAP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					goto Cleanup;
				}

				ResultCode = TEST_RESULTS.FAILED;

				Cleanup:
					if (0 != result)
						RemoveEntry(result,QAP);
			}
		}

		[TestCase, Description("QueryAdd Invalid: gamerTag padded with spaces")]
			class Query_Add_Invalid_GamerTag_Padded : TestBase
		{
			protected override void Execute()
			{
				UInt64 [] result = new UInt64[2];
				result[0] = 0;
				result[1] = 0;
				QueryAddParams QAP = new QueryAddParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QAP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				QueryWidgetCommon.FillDBBasedOnAPI(0,0);
				QAP.gamerTag += " ";

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					// try gamerTag padded at end
					result[0] = wc.WidgetAdd(QAP.titleId,QAP.webId,QAP.gamerTag,QAP.teamName,QAP.datasetId,QAP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("(webID,GamerTag) pair ("+Hexer.tohex(QAP.webId,true)+","+QAP.gamerTag+") is not linked in our system"))
					{
						ResultCode = TEST_RESULTS.FAILED;
						goto Cleanup;
					}

					if (!QueryWidgetCommon.VerifyNoChange(QAP.titleId,QAP.datasetId,dtTestStart))
					{
						ResultCode = TEST_RESULTS.FAILED;
						goto Cleanup;
					}

					try
					{
						// try gamerTag padded at beginning
						QAP.gamerTag = " " + QAP.gamerTag.Trim();
						wc = new WCQuery();
						dtTestStart = QueryWidgetCommon.GetSqlServerTime();
						result[1] = wc.WidgetAdd(QAP.titleId,QAP.webId,QAP.gamerTag,QAP.teamName,QAP.datasetId,QAP.attributes);
					}
					catch (Exception ex)
					{
						if (!ex.Message.EndsWith("(webID,GamerTag) pair ("+Hexer.tohex(QAP.webId,true)+","+QAP.gamerTag+") is not linked in our system"))
							ResultCode = TEST_RESULTS.FAILED;

						if (!QueryWidgetCommon.VerifyNoChange(QAP.titleId,QAP.datasetId,dtTestStart))
							ResultCode = TEST_RESULTS.FAILED;
						goto Cleanup;
					}
				}
				ResultCode = TEST_RESULTS.FAILED;

				Cleanup:
					for (int i=0; i<result.Length; i++)
					{
						if (0 != result[i])
							RemoveEntry(result[i],QAP);
					}
			}
		}

		[TestCase, Description("QueryAdd Invalid: gamerTag too long")]
			class Query_Add_Invalid_GamerTag_Too_Long : TestBase
		{
			protected override void Execute()
			{
				UInt64 result = 0;
				QueryAddParams QAP = new QueryAddParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QAP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				QueryWidgetCommon.FillDBBasedOnAPI(0,0);
				QAP.gamerTag = QueryWidgetCommon.GAMERTAG_TOO_LONG;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					result = wc.WidgetAdd(QAP.titleId,QAP.webId,QAP.gamerTag,QAP.teamName,QAP.datasetId,QAP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("(webID,GamerTag) pair ("+Hexer.tohex(QAP.webId,true)+","+QAP.gamerTag+") is not linked in our system"))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QAP.titleId,QAP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					goto Cleanup;
				}

				ResultCode = TEST_RESULTS.FAILED;

				Cleanup:
					if (0 != result)
						RemoveEntry(result,QAP);
			}
		}

		[TestCase, Description("QueryAdd Invalid: teamName too long")]
			class Query_Add_Invalid_TeamName_Too_Long : TestBase
		{
			protected override void Execute()
			{
				UInt64 result = 0;
				QueryAddParams QAP = new QueryAddParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QAP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				QueryWidgetCommon.FillDBBasedOnAPI(0,0);
				QAP.teamName = QueryWidgetCommon.TEAMNAME_TOO_LONG;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					result = wc.WidgetAdd(QAP.titleId,QAP.webId,QAP.gamerTag,QAP.teamName,QAP.datasetId,QAP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Team "+QAP.teamName+" could not be found in the team cache for titleId "+Hexer.tohex(QAP.titleId).ToLower()+" aborting."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QAP.titleId,QAP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					goto Cleanup;
				}

				ResultCode = TEST_RESULTS.FAILED;

				Cleanup:
					if (0 != result)
						RemoveEntry(result,QAP);
			}
		}

		[TestCase, Description("QueryAdd Invalid: teamName unknown")]
			class Query_Add_Invalid_TeamName_Unknown : TestBase
		{
			protected override void Execute()
			{
				UInt64 result = 0;
				QueryAddParams QAP = new QueryAddParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QAP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				QueryWidgetCommon.FillDBBasedOnAPI(0,0);
				QAP.teamName = QueryWidgetCommon.TEAMNAME_NOT_EXIST;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					result = wc.WidgetAdd(QAP.titleId,QAP.webId,QAP.gamerTag,QAP.teamName,QAP.datasetId,QAP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Team "+QAP.teamName+" could not be found in the team cache for titleId "+Hexer.tohex(QAP.titleId).ToLower()+" aborting."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QAP.titleId,QAP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					goto Cleanup;
				}

				ResultCode = TEST_RESULTS.FAILED;

				Cleanup:
					if (0 != result)
						RemoveEntry(result,QAP);
			}
		}

		[TestCase, Description("QueryAdd Invalid: user/team mismatch")]
			class Query_Add_Invalid_User_Team_Mismatch : TestBase
		{
			protected override void Execute()
			{
				UInt64 result = 0;
				QueryAddParams QAP = new QueryAddParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QAP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				QueryWidgetCommon.FillDBBasedOnAPI(0,0);
				QAP.teamName = QueryWidgetCommon.TEAMNAME_NO_MATCH;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					result = wc.WidgetAdd(QAP.titleId,QAP.webId,QAP.gamerTag,QAP.teamName,QAP.datasetId,QAP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("User "+QAP.gamerTag+" could not be validated as a member of team "+QAP.teamName+" in title "+Hexer.tohex(QAP.titleId).ToLower()))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QAP.titleId,QAP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					goto Cleanup;
				}

				ResultCode = TEST_RESULTS.FAILED;

				Cleanup:
					if (0 != result)
						RemoveEntry(result,QAP);
			}
		}

		[TestCase, Description("QueryAdd Invalid: datasetId 0")]
			class Query_Add_Invalid_DatasetId_0 : TestBase
		{
			protected override void Execute()
			{
				UInt64 result = 0;
				QueryAddParams QAP = new QueryAddParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QAP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				QueryWidgetCommon.FillDBBasedOnAPI(0,0);
				QAP.datasetId = 0;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					result = wc.WidgetAdd(QAP.titleId,QAP.webId,QAP.gamerTag,QAP.teamName,QAP.datasetId,QAP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;
					goto Cleanup;
				}

				ResultCode = TEST_RESULTS.FAILED;

				Cleanup:
					if (0 != result)
						RemoveEntry(result,QAP);
			}
		}

/*		[TestCase, Description("QueryAdd Invalid: datasetId 2")]
			class Query_Add_Invalid_DatasetId_2 : TestBase
		{
			protected override void Execute()
			{
				UInt64 result = 0;
				QueryAddParams QAP = new QueryAddParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QAP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				QueryWidgetCommon.FillDBBasedOnAPI(0,0);
				QAP.datasetId = 2;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					result = wc.WidgetAdd(QAP.titleId,QAP.webId,QAP.gamerTag,QAP.teamName,QAP.datasetId,QAP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;

					if (QAP.titleId != QueryWidgetCommon.QUERY_TITLE_ID && !QueryWidgetCommon.VerifyNoChange(QAP.titleId,QAP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					goto Cleanup;
				}

				ResultCode = TEST_RESULTS.FAILED;

				Cleanup:
					if (0 != result)
						RemoveEntry(result,QAP);
			}
		}
*/
		[TestCase, Description("QueryAdd Invalid: datasetId 3")]
			class Query_Add_Invalid_DatasetId_3 : TestBase
		{
			protected override void Execute()
			{
				UInt64 result = 0;
				QueryAddParams QAP = new QueryAddParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QAP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				QueryWidgetCommon.FillDBBasedOnAPI(0,0);
				QAP.datasetId = 3;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					result = wc.WidgetAdd(QAP.titleId,QAP.webId,QAP.gamerTag,QAP.teamName,QAP.datasetId,QAP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;

					if (QAP.titleId != QueryWidgetCommon.QUERY_TITLE_ID && !QueryWidgetCommon.VerifyNoChange(QAP.titleId,QAP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					goto Cleanup;
				}

				ResultCode = TEST_RESULTS.FAILED;

				Cleanup:
					if (0 != result)
						RemoveEntry(result,QAP);
			}
		}

		[TestCase, Description("QueryAdd Invalid: datasetId MAX_UINT32")]
			class Query_Add_Invalid_DatasetId_Max : TestBase
		{
			protected override void Execute()
			{
				UInt64 result = 0;
				QueryAddParams QAP = new QueryAddParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QAP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				QueryWidgetCommon.FillDBBasedOnAPI(0,0);
				QAP.datasetId = UInt32.MaxValue;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					result = wc.WidgetAdd(QAP.titleId,QAP.webId,QAP.gamerTag,QAP.teamName,QAP.datasetId,QAP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;
					goto Cleanup;
				}

				ResultCode = TEST_RESULTS.FAILED;

				Cleanup:
					if (0 != result)
						RemoveEntry(result,QAP);
			}
		}

		[TestCase, Description("QueryAdd Invalid: attributes null")]
			class Query_Add_Invalid_Attrib_Null : TestBase
		{
			protected override void Execute()
			{
				UInt64 result = 0;
				QueryAddParams QAP = new QueryAddParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QAP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				QueryWidgetCommon.FillDBBasedOnAPI(0,0);
				QAP.attributes = null;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					result = wc.WidgetAdd(QAP.titleId,QAP.webId,QAP.gamerTag,QAP.teamName,QAP.datasetId,QAP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Object reference not set to an instance of an object."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QAP.titleId,QAP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					goto Cleanup;
				}

				ResultCode = TEST_RESULTS.FAILED;

				Cleanup:
					if (0 != result)
						RemoveEntry(result,QAP);
			}
		}

		[TestCase, Description("QueryAdd Invalid: too few attributes")]
			class Query_Add_Invalid_Attrib_Too_Short : TestBase
		{
			protected override void Execute()
			{
				UInt64 result = 0;
				QueryAddParams QAP = new QueryAddParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QAP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// remove attribute from end of array
				QueryAttribute [] QAtooshort = new QueryAttribute[QAP.attributes.Length-1];
				Array.Copy(QAP.attributes,QAtooshort,QAtooshort.Length);
				QAP.attributes = QAtooshort;

				QueryWidgetCommon.FillDBBasedOnAPI(0,0);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					result = wc.WidgetAdd(QAP.titleId,QAP.webId,QAP.gamerTag,QAP.teamName,QAP.datasetId,QAP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("An unexpected attribute passed to the method caused a database error."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QAP.titleId,QAP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					goto Cleanup;
				}

				ResultCode = TEST_RESULTS.FAILED;

				Cleanup:
					if (0 != result)
						RemoveEntry(result,QAP);
			}
		}

		[TestCase, Description("QueryAdd Invalid: too many attributes")]
			class Query_Add_Invalid_Attrib_Too_Long : TestBase
		{
			protected override void Execute()
			{
				UInt64 result = 0;
				QueryAddParams QAP = new QueryAddParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QAP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// duplicate attribute at end of array
				QueryAttribute [] QAtoolong = new QueryAttribute[QAP.attributes.Length+1];
				QAP.attributes.CopyTo(QAtoolong,0);
				QAtoolong[QAtoolong.Length-1] = QAP.attributes[QAP.attributes.Length-1];
				QAP.attributes = QAtoolong;

				QueryWidgetCommon.FillDBBasedOnAPI(0,0);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					result = wc.WidgetAdd(QAP.titleId,QAP.webId,QAP.gamerTag,QAP.teamName,QAP.datasetId,QAP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("An unexpected attribute passed to the method caused a database error."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QAP.titleId,QAP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					goto Cleanup;
				}

				ResultCode = TEST_RESULTS.FAILED;

				Cleanup:
					if (0 != result)
						RemoveEntry(result,QAP);
			}
		}

		[TestCase, Description("QueryAdd Invalid: invalid attributes")]
			class Query_Add_Invalid_Attrib_Invalid : TestBase
		{
			protected override void Execute()
			{
				UInt64 result = 0;
				QueryAddParams QAP = new QueryAddParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QAP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				foreach (QueryAttribute QA in QAP.attributes)
				{
					// lowest 16 bits of ID represent the actual attrib ID
					// in LiveService\Comps\CompDefs, nothing more than 0x20 defined
					QA.Id += 0x100;		// this will make all IDs invalid
				}

				QueryWidgetCommon.FillDBBasedOnAPI(0,0);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					result = wc.WidgetAdd(QAP.titleId,QAP.webId,QAP.gamerTag,QAP.teamName,QAP.datasetId,QAP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("An unexpected attribute passed to the method caused a database error."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QAP.titleId,QAP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					goto Cleanup;
				}

				ResultCode = TEST_RESULTS.FAILED;

				Cleanup:
					if (0 != result)
						RemoveEntry(result,QAP);
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Query\test\FuncQueryFindFromIds.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Threading;
using System.IO;
using System.Xml;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web;
using ServerTestFramework.Web.Query;
using xonline.common.config;

namespace QueryWidget
{
	[TestGroup]
	public class FuncQueryFindFromIds : TestNode
	{
		// struct to hold input values to the FindFromIds method
		struct QueryFindParams
		{
			public System.UInt32 titleId;
			public System.UInt32 datasetId;
			public System.UInt32 procIndex;
			public QueryAttributeSpec[] specs;
			public System.UInt64[] entityIds;
		}

		/// <summary>
		/// function that uses XML file to return valid parameters
		/// </summary>
		/// <param name="QFP">struct to fill with parameters for call to FindFromIds</param>
		/// <param name="procSel">zero-based short to identify which procIndex to use in the xml.</param>
		/// <returns>false if any errors parsing XML file, else true</returns>
		static bool GetValidParams(ref QueryFindParams QFP)
		{
			return GetValidParams(ref QFP,0);
		}

		static bool GetValidParams(ref QueryFindParams QFP, short procSel)
		{
			QFP.titleId = QueryWidgetCommon.QUERY_TITLE_ID;
			QFP.datasetId = QueryWidgetCommon.QUERY_DATASET_ID;

			XmlDocument parameters = new XmlDocument();
			parameters.Load("QueryWidget.xml");

			try
			{
				XmlNodeList paramNodes = parameters.SelectNodes("/stf/parameters/findfromids/procIndex");
				if (paramNodes.Count <= procSel)
					throw new Exception();
				QFP.procIndex = Convert.ToUInt32(paramNodes[procSel].InnerText);

				paramNodes = parameters.SelectNodes("/stf/parameters/findfromids/specs");
				if (paramNodes.Count <= procSel)
					throw new Exception();
				QFP.specs = new QueryAttributeSpec[paramNodes[procSel].ChildNodes.Count];
				for (int i=0; i<paramNodes[procSel].ChildNodes.Count; i++)
				{
					if (paramNodes[procSel].ChildNodes[i].Name != "attrib")
						throw new Exception();

					QFP.specs[i] = new QueryAttributeSpec();

					QFP.specs[i].len = Convert.ToUInt32(paramNodes[procSel].ChildNodes[i].Attributes["s_len"].Value);
					QFP.specs[i].type = System.UInt32.Parse(paramNodes[procSel].ChildNodes[i].Attributes["s_type"].Value,System.Globalization.NumberStyles.AllowHexSpecifier);
				}
			}
			catch (Exception)
			{
				ConsoleX.WriteLine("Invalid parameter element found in xml.");
				return false;
			}
			return true;
		}

		static bool GetEntityIds(ref QueryFindParams QFP, uint nDesiredEntries)
		{
			// REM "SELECT [bi_entity_id], [bi_owner_id], [dt_change_datetime], [att_00000001], [att_00100003], [att_00200005] FROM [QueryDB].[dbo].[t_query_dataset_0000b2d2_1]"

			QueryWidgetCommon.FillDBBasedOnAPI(6,0);
			bool bRet = true;

			SqlCommand mySqlCommand = null;
			SqlDataReader myDataReader = null;

			QFP.entityIds = new UInt64[nDesiredEntries];
			int entityIndex = 0;

			for (int iSql=0; iSql<QueryWidgetCommon.qrySqlConn.Length; iSql++)
			{
				try
				{
					string sql="SELECT [bi_entity_id] FROM [QueryDB].[dbo].[t_query_dataset_"+Hexer.tohex(QFP.titleId)+"_"+QFP.datasetId.ToString("x")+"]";
					mySqlCommand = new SqlCommand(sql,QueryWidgetCommon.qrySqlConn[iSql]);
					myDataReader = mySqlCommand.ExecuteReader();

					if (!myDataReader.HasRows && iSql < QueryWidgetCommon.qrySqlConn.Length+1)
						continue;

					// get entityId for QFP
					while (entityIndex < nDesiredEntries && myDataReader.Read() != false)
					{
						QFP.entityIds[entityIndex] = Convert.ToUInt64(myDataReader.GetInt64(0));
						if (0 == QFP.entityIds[entityIndex])
							throw new Exception("entityId = 0");
						entityIndex++;
					}

					if (myDataReader != null && !myDataReader.IsClosed)
						myDataReader.Close();
				}
				catch (Exception e)
				{
					ConsoleX.WriteLine("SQL error in GetEntityIds(): " + e.Message);
					bRet = false;
					if (QueryWidgetCommon.qrySqlConn[iSql].State != ConnectionState.Open)
						QueryWidgetCommon.qrySqlConn[iSql].Open();
				}
				finally
				{
					// Always call Close when done reading.
					if (myDataReader != null && !myDataReader.IsClosed)
						myDataReader.Close();
				}
			}

			return bRet;
		}

		/// <summary>
		/// function to ensure FindFromIds method worked as expected
		/// </summary>
		/// <param name="QFP"></param>
		/// <returns></returns>
		static bool VerifyFind(FindFromIdsResponse result, QueryFindParams QFP, uint nPrevRecords, DateTime dtTestStart)
		{
			// REM "SELECT [bi_entity_id], [bi_owner_id], [dt_change_datetime], [att_00000001], [att_00100003], [att_00200005] FROM [QueryDB].[dbo].[t_query_dataset_0000b2d2_1]"

			// verify # of results
			if (result.returnedResults != QFP.entityIds.Length ||
				result.attribCount != result.returnedResults * QFP.specs.Length)
			{
				ConsoleX.WriteLine("Number of results does not match.");
				return false;
			}

			// verify returned attributes match expected
			bool bRet = true;

			string sql="";
			SqlCommand mySqlCommand = null;
			SqlDataReader myDataReader = null;

			uint i = 0;
			foreach (UInt64 entityId in QFP.entityIds)
			{
				for (int iSql=0; iSql<QueryWidgetCommon.qrySqlConn.Length; iSql++)
				{
					try
					{
						sql="SELECT * FROM [QueryDB].[dbo].[t_query_dataset_"+Hexer.tohex(QFP.titleId)+"_"+QFP.datasetId.ToString("x")+"] WHERE bi_entity_id = '"+entityId+"'";
						mySqlCommand = new SqlCommand(sql,QueryWidgetCommon.qrySqlConn[iSql]);
						myDataReader = mySqlCommand.ExecuteReader();

						if (!myDataReader.HasRows && iSql < QueryWidgetCommon.qrySqlConn.Length+1)
						{
							if (myDataReader != null && !myDataReader.IsClosed)
								myDataReader.Close();
							continue;
						}

						// compare returned attributes
						switch (QFP.procIndex)
						{
							case 1:
								if (myDataReader.Read() == false ||
									result.attribs[i].Id != 0x80000000 ||
									myDataReader.GetInt64(0) != (long)result.attribs[i++].Value ||
									result.attribs[i].Id != 1 ||
									myDataReader.GetInt64(3) != (long)result.attribs[i++].Value ||
									result.attribs[i].Id != 2097157 ||
									0 != Hexer.tohex((byte[])myDataReader.GetValue(5)).CompareTo(Hexer.tohex((byte[])result.attribs[i++].Value)))
									throw new Exception("Results don't match expected.");
								break;
							case 2:
								if (myDataReader.Read() == false ||
									result.attribs[i].Id != 0x80000000 ||
									myDataReader.GetInt64(0) != (long)result.attribs[i++].Value ||
									result.attribs[i].Id != 1048579 ||
									0 != myDataReader.GetString(4).CompareTo(result.attribs[i++].Value))
									throw new Exception("Results don't match expected.");
								break;
							case 3:
								if (myDataReader.Read() == false ||
									result.attribs[i].Id != 0x80000000 ||
									myDataReader.GetInt64(0) != (long)result.attribs[i++].Value ||
									result.attribs[i].Id != 1 ||
									myDataReader.GetInt64(3) != (long)result.attribs[i++].Value ||
									result.attribs[i].Id != 1048579 ||
									0 != myDataReader.GetString(4).CompareTo(result.attribs[i++].Value) ||
									result.attribs[i].Id != 2097157 ||
									0 != Hexer.tohex((byte[])myDataReader.GetValue(5)).CompareTo(Hexer.tohex((byte[])result.attribs[i++].Value)))
									throw new Exception("Results don't match expected.");
								break;
						}
						if (myDataReader != null && !myDataReader.IsClosed)
							myDataReader.Close();

						// verify same # records as before
						bRet = (nPrevRecords == QueryWidgetCommon.GetNumRecords(QFP.titleId,QFP.datasetId));
					}
					catch (Exception e)
					{
						ConsoleX.WriteLine("SQL error in VerifyFind(): " + e.Message);
						bRet = false;
						if (QueryWidgetCommon.qrySqlConn[iSql].State != ConnectionState.Open)
							QueryWidgetCommon.qrySqlConn[iSql].Open();
					}
					finally
					{
						// Always call Close when done reading.
						if (myDataReader != null && !myDataReader.IsClosed)
							myDataReader.Close();
					}
				}
			}

			// verify no changes to dataset
			return bRet && QueryWidgetCommon.VerifyNoChange(QFP.titleId,QFP.datasetId,dtTestStart);
		}

		// Positive test cases

		[TestCase, Description("QueryFindFromIds Valid: basic verify")]
			class Query_FindFromIds_Valid_Basic : TestBase
		{
			protected override void Execute()
			{
				FindFromIdsResponse result = null;
				QueryFindParams QFP = new QueryFindParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QFP) ||
					!GetEntityIds(ref QFP, 10))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				uint nRecords = QueryWidgetCommon.GetNumRecords(QFP.titleId,QFP.datasetId);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					result = wc.WidgetFindFromIds(QFP.titleId,QFP.datasetId,QFP.procIndex,QFP.specs,QFP.entityIds);

					if (!VerifyFind(result,QFP,nRecords,dtTestStart))
						throw new Exception("Verification failed.");
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		[TestCase, Description("QueryFindFromIds Valid: procIndex match Find proc 1")]
			class Query_FindFromIds_Valid_ProcIndex_Match_1 : TestBase
		{
			protected override void Execute()
			{
				FindFromIdsResponse result = null;
				QueryFindParams QFP = new QueryFindParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QFP,1) ||
					!GetEntityIds(ref QFP, 10))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				uint nRecords = QueryWidgetCommon.GetNumRecords(QFP.titleId,QFP.datasetId);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					result = wc.WidgetFindFromIds(QFP.titleId,QFP.datasetId,QFP.procIndex,QFP.specs,QFP.entityIds);

					if (!VerifyFind(result,QFP,nRecords,dtTestStart))
						throw new Exception("Verification failed.");
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		[TestCase, Description("QueryFindFromIds Valid: procIndex match Find proc 2")]
			class Query_FindFromIds_Valid_ProcIndex_Match_2 : TestBase
		{
			protected override void Execute()
			{
				FindFromIdsResponse result = null;
				QueryFindParams QFP = new QueryFindParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QFP,2) ||
					!GetEntityIds(ref QFP, 10))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				uint nRecords = QueryWidgetCommon.GetNumRecords(QFP.titleId,QFP.datasetId);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					result = wc.WidgetFindFromIds(QFP.titleId,QFP.datasetId,QFP.procIndex,QFP.specs,QFP.entityIds);

					if (!VerifyFind(result,QFP,nRecords,dtTestStart))
						throw new Exception("Verification failed.");
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		[TestCase, Description("QueryFindFromIds Valid: single entityId")]
			class Query_FindFromIds_Valid_Single_EntityId : TestBase
		{
			protected override void Execute()
			{
				FindFromIdsResponse result = null;
				QueryFindParams QFP = new QueryFindParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QFP) ||
					!GetEntityIds(ref QFP, 1))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				uint nRecords = QueryWidgetCommon.GetNumRecords(QFP.titleId,QFP.datasetId);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					result = wc.WidgetFindFromIds(QFP.titleId,QFP.datasetId,QFP.procIndex,QFP.specs,QFP.entityIds);

					if (!VerifyFind(result,QFP,nRecords,dtTestStart))
						throw new Exception("Verification failed.");
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		// Negative test cases

		[TestCase, Description("QueryFindFromIds Invalid: unknown titleId")]
			class Query_FindFromIds_Invalid_Unknown_Title : TestBase
		{
			protected override void Execute()
			{
				QueryFindParams QFP = new QueryFindParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QFP) ||
					!GetEntityIds(ref QFP, 10))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set titleId
				QFP.titleId = QueryWidgetCommon.TITLEID_NOT_EXIST;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetFindFromIds(QFP.titleId,QFP.datasetId,QFP.procIndex,QFP.specs,QFP.entityIds);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Partner:DebugPartner not allowed to access TitleID:"+Hexer.tohex(QFP.titleId)))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryFindFromIds Invalid: titleId MAX_UINT32")]
			class Query_FindFromIds_Invalid_Title_Max : TestBase
		{
			protected override void Execute()
			{
				QueryFindParams QFP = new QueryFindParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QFP) ||
					!GetEntityIds(ref QFP, 10))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set titleId
				QFP.titleId = UInt32.MaxValue;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetFindFromIds(QFP.titleId,QFP.datasetId,QFP.procIndex,QFP.specs,QFP.entityIds);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Partner:DebugPartner not allowed to access TitleID:"+Hexer.tohex(QFP.titleId)))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryFindFromIds Invalid: titleId doesn't support Query Service")]
			class Query_FindFromIds_Invalid_Title_Unsupported : TestBase
		{
			protected override void Execute()
			{
				QueryFindParams QFP = new QueryFindParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QFP) || !GetEntityIds(ref QFP, 10))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set titleId
				QFP.titleId = QueryWidgetCommon.TITLEID_NO_QUERY;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetFindFromIds(QFP.titleId,QFP.datasetId,QFP.procIndex,QFP.specs,QFP.entityIds);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryFindFromIds Invalid: titleId doesn't support FindFromIds")]
			class Query_FindFromIds_Invalid_FindFromIds_Unsupported : TestBase
		{
			protected override void Execute()
			{
				QueryFindParams QFP = new QueryFindParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QFP) || !GetEntityIds(ref QFP, 10))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set datasetId
				QFP.datasetId = 2;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetFindFromIds(QFP.titleId,QFP.datasetId,QFP.procIndex,QFP.specs,QFP.entityIds);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QFP.titleId,QFP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryFindFromIds Invalid: datasetId 0")]
			class Query_FindFromIds_Invalid_DatasetId_0 : TestBase
		{
			protected override void Execute()
			{
				QueryFindParams QFP = new QueryFindParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QFP) || !GetEntityIds(ref QFP, 10))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set datasetId
				QFP.datasetId = 0;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetFindFromIds(QFP.titleId,QFP.datasetId,QFP.procIndex,QFP.specs,QFP.entityIds);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryFindFromIds Invalid: datasetId 2")]
			class Query_FindFromIds_Invalid_DatasetId_2 : TestBase
		{
			protected override void Execute()
			{
				QueryFindParams QFP = new QueryFindParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QFP) || !GetEntityIds(ref QFP, 10))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set datasetId
				QFP.datasetId = 2;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetFindFromIds(QFP.titleId,QFP.datasetId,QFP.procIndex,QFP.specs,QFP.entityIds);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;

					if (QFP.titleId != QueryWidgetCommon.QUERY_TITLE_ID && !QueryWidgetCommon.VerifyNoChange(QFP.titleId,QFP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryFindFromIds Invalid: datasetId 3")]
			class Query_FindFromIds_Invalid_DatasetId_3 : TestBase
		{
			protected override void Execute()
			{
				QueryFindParams QFP = new QueryFindParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QFP) || !GetEntityIds(ref QFP, 10))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set datasetId
				QFP.datasetId = 3;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetFindFromIds(QFP.titleId,QFP.datasetId,QFP.procIndex,QFP.specs,QFP.entityIds);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;

					if (QFP.titleId != QueryWidgetCommon.QUERY_TITLE_ID && !QueryWidgetCommon.VerifyNoChange(QFP.titleId,QFP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryFindFromIds Invalid: datasetId MAX_UINT32")]
			class Query_FindFromIds_Invalid_DatasetId_Max : TestBase
		{
			protected override void Execute()
			{
				QueryFindParams QFP = new QueryFindParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QFP) || !GetEntityIds(ref QFP, 10))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set datasetId
				QFP.datasetId = UInt32.MaxValue;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetFindFromIds(QFP.titleId,QFP.datasetId,QFP.procIndex,QFP.specs,QFP.entityIds);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryFindFromIds Invalid: procIndex MAX_UINT32")]
			class Query_FindFromIds_Invalid_ProcIndex_Max : TestBase
		{
			protected override void Execute()
			{
				QueryFindParams QFP = new QueryFindParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QFP) || !GetEntityIds(ref QFP, 10))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set procIndex
				QFP.procIndex = UInt32.MaxValue;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetFindFromIds(QFP.titleId,QFP.datasetId,QFP.procIndex,QFP.specs,QFP.entityIds);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QFP.titleId,QFP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryFindFromIds Invalid: procIndex off by 1")]
			class Query_FindFromIds_Invalid_ProcIndex_Off_By_One : TestBase
		{
			protected override void Execute()
			{
				QueryFindParams QFP = new QueryFindParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QFP) || !GetEntityIds(ref QFP, 10))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set procIndex
				QFP.procIndex = 0;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetFindFromIds(QFP.titleId,QFP.datasetId,QFP.procIndex,QFP.specs,QFP.entityIds);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QFP.titleId,QFP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryFindFromIds Invalid: all entityIds invalid")]
			class Query_FindFromIds_Invalid_EntityIds_Invalid : TestBase
		{
			protected override void Execute()
			{
				QueryFindParams QFP = new QueryFindParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QFP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set entityIds to all invalid values
				QFP.entityIds = new UInt64[10];
				for (int i=0; i<QFP.entityIds.Length; i++)
				{
					QFP.entityIds[i] = UInt64.MaxValue;
				}

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetFindFromIds(QFP.titleId,QFP.datasetId,QFP.procIndex,QFP.specs,QFP.entityIds);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The requested entity does not exist in the dataset specified."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QFP.titleId,QFP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryFindFromIds Invalid: single entityId invalid")]
			class Query_FindFromIds_Invalid_One_EntityId_Invalid : TestBase
		{
			protected override void Execute()
			{
				QueryFindParams QFP = new QueryFindParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QFP) || !GetEntityIds(ref QFP, 10))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set one entityId invalid
				QFP.entityIds[5] = UInt64.MaxValue;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetFindFromIds(QFP.titleId,QFP.datasetId,QFP.procIndex,QFP.specs,QFP.entityIds);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The requested entity does not exist in the dataset specified."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QFP.titleId,QFP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryFindFromIds Invalid: entityIds don't match titleId/datasetId")]
			class Query_FindFromIds_Invalid_EntityIds_Dataset_Mismatch : TestBase
		{
			protected override void Execute()
			{
				QueryFindParams QFP = new QueryFindParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QFP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				QFP.datasetId = 5;
				if (!GetEntityIds(ref QFP, 10))		// get entityIds from wrong dataset
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// reset datasetId
				QFP.datasetId = 1;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetFindFromIds(QFP.titleId,QFP.datasetId,QFP.procIndex,QFP.specs,QFP.entityIds);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The requested entity does not exist in the dataset specified."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QFP.titleId,QFP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryFindFromIds Invalid: entityIds null")]
			class Query_FindFromIds_Invalid_EntityIds_Null : TestBase
		{
			protected override void Execute()
			{
				QueryFindParams QFP = new QueryFindParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QFP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set entityIds
				QFP.entityIds = null;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetFindFromIds(QFP.titleId,QFP.datasetId,QFP.procIndex,QFP.specs,QFP.entityIds);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Object reference not set to an instance of an object."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QFP.titleId,QFP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryFindFromIds Invalid: specs mismatched with proc")]
			class Query_FindFromIds_Invalid_Specs_Mismatched : TestBase
		{
			protected override void Execute()
			{
				QueryFindParams QFP = new QueryFindParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QFP) || !GetEntityIds(ref QFP, 10))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set specs so doesn't match procIndex
				QueryFindParams QPtemp = new QueryFindParams();
				if (!GetValidParams(ref QPtemp, 2))
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				QFP.specs = QPtemp.specs;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetFindFromIds(QFP.titleId,QFP.datasetId,QFP.procIndex,QFP.specs,QFP.entityIds);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The provided number of QUERY_ATTRIBUTE_SPECs doesn't match the number returned by the procedure."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QFP.titleId,QFP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryFindFromIds Invalid: too few specs")]
			class Query_FindFromIds_Invalid_Specs_Too_Few : TestBase
		{
			protected override void Execute()
			{
				QueryFindParams QFP = new QueryFindParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QFP) || !GetEntityIds(ref QFP, 10))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// remove attribute from end of array
				QueryAttributeSpec [] QAStooshort = new QueryAttributeSpec[QFP.specs.Length-1];
				for (int i=0; i<QAStooshort.Length; i++)
					QAStooshort[i] = QFP.specs[i];
				QFP.specs = QAStooshort;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetFindFromIds(QFP.titleId,QFP.datasetId,QFP.procIndex,QFP.specs,QFP.entityIds);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The provided number of QUERY_ATTRIBUTE_SPECs doesn't match the number returned by the procedure."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QFP.titleId,QFP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryFindFromIds Invalid: too many specs")]
			class Query_FindFromIds_Invalid_Specs_Too_Many : TestBase
		{
			protected override void Execute()
			{
				QueryFindParams QFP = new QueryFindParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QFP) || !GetEntityIds(ref QFP, 10))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// add valid attribute at end of array
				QueryAttributeSpec [] QAStoolong = new QueryAttributeSpec[QFP.specs.Length+1];
				QFP.specs.CopyTo(QAStoolong,0);
				QAStoolong[QAStoolong.Length-1] = new QueryAttributeSpec();
				QAStoolong[QAStoolong.Length-1].len = 400;
				QAStoolong[QAStoolong.Length-1].type = 1048579;
				QFP.specs = QAStoolong;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetFindFromIds(QFP.titleId,QFP.datasetId,QFP.procIndex,QFP.specs,QFP.entityIds);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The provided number of QUERY_ATTRIBUTE_SPECs doesn't match the number returned by the procedure."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QFP.titleId,QFP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryFindFromIds Invalid: null specs")]
			class Query_FindFromIds_Invalid_Specs_Null : TestBase
		{
			protected override void Execute()
			{
				QueryFindParams QFP = new QueryFindParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QFP) || !GetEntityIds(ref QFP, 10))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set specs
				QFP.specs = null;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetFindFromIds(QFP.titleId,QFP.datasetId,QFP.procIndex,QFP.specs,QFP.entityIds);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Object reference not set to an instance of an object."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QFP.titleId,QFP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryFindFromIds Valid: 11 entityIds")]
			class Query_FindFromIds_Valid_Max_Allowed_EntityIds_PLUS_One : TestBase
		{
			protected override void Execute()
			{
				FindFromIdsResponse result = null;
				QueryFindParams QFP = new QueryFindParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QFP) || !GetEntityIds(ref QFP, 11))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				uint nRecords = QueryWidgetCommon.GetNumRecords(QFP.titleId,QFP.datasetId);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					result = wc.WidgetFindFromIds(QFP.titleId,QFP.datasetId,QFP.procIndex,QFP.specs,QFP.entityIds);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The method was called with some invalid arguments or attributes and could not be completed."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QFP.titleId,QFP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryFindFromIds Invalid: large number of entityIds")]
			class Query_FindFromIds_Invalid_Many_EntityIds : TestBase
		{
			protected override void Execute()
			{
				FindFromIdsResponse result = null;
				QueryFindParams QFP = new QueryFindParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QFP) ||
					!GetEntityIds(ref QFP, 500))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				uint nRecords = QueryWidgetCommon.GetNumRecords(QFP.titleId,QFP.datasetId);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					result = wc.WidgetFindFromIds(QFP.titleId,QFP.datasetId,QFP.procIndex,QFP.specs,QFP.entityIds);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QFP.titleId,QFP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Query\dll\query.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Text;
using System.Web;
using System.Web.Services;
using System.Web.Services.Protocols;
using System.Web.Caching;

using xonline.common.config;
using xonline.common.installer;
using xonline.common.protocol;
using xonline.common.service;
using xonline.server.comps.common;
using xonline.common.mgmt;
using xonline.server.mgmt.soap;
using xonline.server.webcache.common;

[assembly: XomIisInstallerAttribute( Interface.wcquery )]
[assembly: ConfigAttribute( xonline.common.config.Component.wcquery )]

[assembly: XomAreaDefinition(XomAreaName.wcQueryLog)]

namespace xonline.server.webcache.query.dll 
{
    [WebService(Namespace="http://websvc.xboxlive.com/Query/")]
    public class Query : System.Web.Services.WebService
    {   
        public Query()
        {
            try
            {
                //CODEGEN: This call is required by the ASP.NET Web Services Designer
                InitializeComponent();
            }
            catch (XboxWebException we)
            {
                throw we;
            }
            catch (Exception e)
            {
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_41, e);
            }
        }

        #region Component Designer generated code
        
        //Required by the Web Services Designer 
        private IContainer components = null;
                
        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
        }

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        protected override void Dispose( bool disposing )
        {
            if(disposing && components != null)
            {
                components.Dispose();
            }
            base.Dispose(disposing);        
        }
        
        #endregion


        //
        // Error Handling
        //
        private void TranslateError(HResult hr)
        {
            string eventText = "The web service encountered an internal error.";
            
            switch (hr)
            {
            // Global Errors
            case HResult.E_INVALIDARG:
                eventText = "The method was called with some invalid arguments or attributes and could not be completed.";
                break;
                
            // Query Service Errors
            case HResult.XONLINE_E_QUERY_QUOTA_FULL:
                eventText = "This user or teams quota for the dataset is full.  You must first remove an entity before more can be added.";
                break;

            case HResult.XONLINE_E_QUERY_ENTITY_NOT_FOUND:
                eventText = "The requested entity does not exist in the dataset specified.";
                break;

            case HResult.XONLINE_E_QUERY_PERMISSION_DENIED:
                eventText = "The user tried to update or delete an entity that he does not own.";
                break;

            case HResult.XONLINE_E_QUERY_ATTRIBUTE_TOO_LONG:
                eventText = "An string or binary attribute length exceeded the schema definition.";
                break;

            case HResult.XONLINE_E_QUERY_UNEXPECTED_ATTRIBUTE:
                eventText = "An unexpected attribute passed to the method caused a database error.";
                break;

            case HResult.XONLINE_E_QUERY_SPEC_COUNT_MISMATCH:
                eventText = "The provided number of QUERY_ATTRIBUTE_SPECs doesn't match the number returned by the procedure.";
                break;


            // Competitions Specific Errors
            case HResult.XONLINE_E_COMP_ACCESS_DENIED:
                eventText = "The specified source (client) is not permitted to execute this method.";
                break;

            case HResult.XONLINE_E_COMP_REGISTRATION_CLOSED:
                eventText = "The competition is closed to registration.";
                break;

            case HResult.XONLINE_E_COMP_FULL:
                eventText = "The competition has reached it's max enrollment.";
                break;

            case HResult.XONLINE_E_COMP_NOT_REGISTERED:
                eventText = "The user or team isn't registered for the competition.";
                break;

            case HResult.XONLINE_E_COMP_CANCELLED:
                eventText = "The competition has been cancelled, and the operation is invalid.";
                break;

            case HResult.XONLINE_E_COMP_UNEXPECTED:
                eventText = "Results from the Database are unexpected or inconsistent with the current operation.";
                break;
            }
            
            throw new XboxWebExceptionNoEvent("hr = " + hr + " : " + eventText);            
        } 


        void ValidateAttributeTypes(QueryAttribute [] attribs, bool fAttribsCanBeNull)
        {
            bool    fBadType = false;
            HResult hr = HResult.E_INVALIDARG;

            if ( (fAttribsCanBeNull == false) && (attribs == null) )
            {
                throw new XboxWebExceptionNoEvent("hr = " + hr + " : The method was called with a null array of attributes and could not be completed.");            
            }
            
            // Walk the list of attributes and verify types
            if (attribs != null)
            {
                foreach (QueryAttribute qa in attribs)
                {
                    switch(qa.Id & XOn.X_ATTRIBUTE_DATATYPE_MASK)
                    {
                    case XOn.X_ATTRIBUTE_DATATYPE_INTEGER:
                        if (!(qa.Value is long))
                        {
                            fBadType = true;
                        }
                        break;
                    
                    case XOn.X_ATTRIBUTE_DATATYPE_STRING:
                        if (!(qa.Value is string))
                        {
                            fBadType = true;
                        }
                        break;
                        
                    case XOn.X_ATTRIBUTE_DATATYPE_BLOB:
                        if (!(qa.Value is byte[]))
                        {
                            fBadType = true;
                        }
                        break;
                    
                    default:
                        throw new XboxWebExceptionNoEvent("Unrecgonized QueryAttribute datatype: 0x" + (qa.Id & XOn.X_ATTRIBUTE_DATATYPE_MASK).ToString("x") + "! attribute id: " + qa.Id);
                    }

                    if (fBadType)
                    {
                        throw new XboxWebExceptionNoEvent(" Error: " + hr + ": One or more QueryAttributes objects had values that do not match the specified attribute type. Be sure to cast values to the correct type; eg. \"qa.Value = (long)0\"; not \"qa.Value = 0;\"");            
                    }
                }
            }
        }

        
        private void WebAliveUser(ulong puid, HTTPAuthData httpAuthData)
        {
            WebAliveRequest webAlive = new WebAliveRequest();
            webAlive.puid = puid;

            WebAliveResponse waResponse = new WebAliveResponse();
            XRLObject2 xrlo = waResponse;

            // TODO - need to fix calls to XboxWebException constructor
            // we are passing HR codes where an  XEvent.Id. is  expected

            HResult hr = XRLUtil.PostXrlRequest( VirtualInterface.xpnfd_presence_int, webAlive.GetXRL(), httpAuthData.GetBase64EncodedString(), webAlive, ref xrlo );
            if( HResult.Failed( hr ) )
            {
                throw new XboxWebException(XEvent.Id.WCQUERY_WEBALIVE_CODE_1, "WebAliveUser: PostXrlRequest failed, hr = " + hr);
            }

            hr = waResponse.hr;
            if(waResponse.hr != HResult.S_OK)
            {
                throw new XboxWebException(XEvent.Id.WCQUERY_WEBALIVE_CODE_2, "WebAliveUser: failed response, hr = " + hr);
            }

            if (waResponse.puid != puid)
            {
                throw new XboxWebException(XEvent.Id.WCQUERY_WEBALIVE_CODE_3, "WebAliveUser: puid mismatch on response: " + waResponse.puid.ToString("X") + " != " + puid.ToString("X"));
            }
        }

        //
        // Team support functions
        //
        private TeamTicket [] GetTeamTicket(uint titleId, ulong puid)
        {
            TeamGetTicketMsg    request = new TeamGetTicketMsg();
            TeamGetTicketReply  response = new TeamGetTicketReply();
            TeamTicket []       rgtt = new TeamTicket[1];                    
            
            // Add any properties
            request.qwUserID = puid;
            request.dwTitleID = titleId;

            XRLObject2 xrlo = (XRLObject2) response;

            Utilities.RequestInfo requestInfo = Utilities.GetRequestInfo();
            HTTPAuthData httpAuthData = new HTTPAuthData( requestInfo.ClientPort, requestInfo.ClientIP, requestInfo.qwRequestID, puid, titleId, (uint) XOService.Query, 0 );

            // call webalive to ensure that presence knows about this user.
            WebAliveUser(puid, httpAuthData);
            
            HResult hr = XRLUtil.PostXrlRequest( VirtualInterface.xpnfd_teams_int, "/xpnfront/xteams.srf", httpAuthData.GetBase64EncodedString(), request, ref xrlo );

            // TODO - fix calls to XboxWebException constructor
            // don't pass HResults where XEvent.Id. are expected
            
            if( HResult.Failed( hr ) )
            {
                throw new XboxWebException((XEvent.Id) (uint) hr, " Error: failed requesting team tickets from Teams service for user " + puid + " in title " + titleId);
            }                                    

            if (( HResult.Failed( response.hr )) || (null == response.sTeamTicket))
            {
                throw new XboxWebException((XEvent.Id) (uint) response.hr, " Teams service returned an error while requesting team tickets for user " + puid + " in title " + titleId);            
            }                                    

            rgtt[0] = response.sTeamTicket;
            
            return rgtt;
        }


        //
        // Authorization
        //
        private void AuthorizeCaller(
            uint titleId,
            byte[] webId,
            string gamerTag,
            string teamName,
            out ulong puid,
            out ulong teamId,
            out TeamTicket[] tt
            )
        {
            puid = 0;
            teamId = 0;
            tt = null;

            Utilities.RequestInfo requestInfo = Utilities.GetRequestInfo();

            if (Utilities.IsAdminPartner())
            {
                if ((gamerTag != null) && (gamerTag != ""))
                {
                    throw new XboxWebExceptionNoEvent(" Error: gamerTag parameter must be null for administrator operations");                                
                }

                if ((teamName != null) && (teamName != ""))
                {
                    throw new XboxWebExceptionNoEvent(" Error: teamName parameter must be null for administrator operations");                                
                }
                
                // For admin requests, the PUID is overloaded with the titleId for
                //  use in the Query service
                puid = titleId;
                teamId = 0;
            }
            else
            {
                try
                {
                    puid = Utilities.Instance.LookupWebID(webId, gamerTag).PUID;
                }
                catch (ArgumentException ae)
                {
                    // For back compat, we must throw the same message we used to. 
                    throw new XboxWebExceptionNoEvent("(webID,GamerTag) pair ("+ByteConvert.ToReverseString(webId) +","+gamerTag+") is not linked in our system", ae);
                }

                try
                {
                    if ((teamName != null) && (teamName != ""))
                    {
                        teamId = Utilities.Instance.LookupTeamPUID(titleId, teamName);            
                        
                        if (teamId != 0)
                        {
                            // Team request - must validate the users team membership info
                            tt = GetTeamTicket(titleId, puid);
                            
                            if (false == tt[0].VerifyMembership(puid, teamId))
                            {                    
                                throw new XboxWebExceptionNoEvent(" Error: User " + gamerTag + " could not be validated as a member of team " + teamName + " in title " + titleId.ToString("x8"));            
                            }
                        }
                        else
                        {
                            throw new ArgumentException("Team not found");
                        }
                    }
                }
                catch (ArgumentException ae)
                {
                    throw new XboxWebExceptionNoEvent(" Error: Team " + teamName + " could not be found in the team cache for titleId " + titleId.ToString("x8") + " aborting.", ae);
                }
            }            
        }

        
        //
        // Base Query Service APIs
        //
        public ulong InternalAdd(
            uint titleId,
            byte[] webId,
            string gamerTag,
            string teamName,
            uint datasetId,
            QueryAttribute[] attributes
            )
        {
            AddRequest          request = new AddRequest();
            AddResponse         response = new AddResponse();
            MemoryStream        stream = new MemoryStream();
            BinaryWriter        writer = new BinaryWriter(stream);
            byte[]              respBuf;
            ulong               entityId = 0;

            ulong               puid;
            ulong               teamId;
            TeamTicket []       tt = null;

            AuthorizeCaller(titleId, webId, gamerTag, teamName, out puid, out teamId, out tt);
            
            request.titleId = titleId;
            request.userId = puid;
            request.teamId = teamId;
            request.datasetId = datasetId;
            request.attribCount = (uint)attributes.Length;                
            request.attribs = attributes;                

            request.WriteStream(writer);

            if (tt != null)
            {
                TeamTickets     tts = new TeamTickets(tt);
                tts.WriteStream(writer);                    
            }

            WebHeaderCollection headers = new WebHeaderCollection();
            headers[XHttpHdr.WEBCACHEREQUEST] = "TRUE";

            Utilities.RequestInfo requestInfo = Utilities.GetRequestInfo();
            HTTPAuthData httpAuthData = new HTTPAuthData( requestInfo.ClientPort, requestInfo.ClientIP, requestInfo.qwRequestID, puid, titleId, (uint) XOService.Query, 0 );
            
            HResult hr = XRLUtil.PostXrlRequest(XOService.Query, request.GetXRL(), -1, httpAuthData.GetBase64EncodedString(), stream.ToArray(), headers, out respBuf);

            if (HResult.Succeeded(hr))
            {
                response.ReadBytes(respBuf);
                entityId = response.entityId;
            }
            else
            {
                TranslateError(hr);
            }        

            return entityId;
        }


        public void InternalUpdate(
            uint titleId,
            byte[] webId,
            string gamerTag,
            string teamName,
            uint datasetId,
            uint procIndex,
            QueryAttribute[] attributes
            )
        {
            UpdateRequest       request = new UpdateRequest();
            MemoryStream        stream = new MemoryStream();
            BinaryWriter        writer = new BinaryWriter(stream);
            byte[]              respBuf;

            ulong       puid;
            ulong       teamId;
            TeamTicket [] tt = null;
            
            AuthorizeCaller(titleId, webId, gamerTag, teamName, out puid, out teamId, out tt);            

            request.titleId = titleId;
            request.userId = puid;
            request.teamId = teamId;
            request.datasetId = datasetId;
            request.procIndex = procIndex;            
            request.attribCount = (uint)attributes.Length;
            request.attribs = attributes;

            request.WriteStream(writer);
            
            if (tt != null)
            {
                TeamTickets     tts = new TeamTickets(tt);
                tts.WriteStream(writer);                    
            }
            
            WebHeaderCollection headers = new WebHeaderCollection();
            headers[XHttpHdr.WEBCACHEREQUEST] = "TRUE";
            
            Utilities.RequestInfo requestInfo = Utilities.GetRequestInfo();
            HTTPAuthData httpAuthData = new HTTPAuthData( requestInfo.ClientPort, requestInfo.ClientIP, requestInfo.qwRequestID, puid, titleId, (uint) XOService.Query, 0 );
            
            HResult hr = XRLUtil.PostXrlRequest(XOService.Query, request.GetXRL(), -1, httpAuthData.GetBase64EncodedString(), stream.ToArray(), headers, out respBuf);

            if (HResult.Failed(hr))
            {
                TranslateError(hr);
            }
        }


        public void InternalUpdateId(
            uint titleId,
            byte[] webId,
            string gamerTag,
            string teamName,
            uint datasetId,
            uint procIndex,
            ulong entityId,
            QueryAttribute[] attributes
            )
        {
            UpdateIdRequest     request = new UpdateIdRequest();
            MemoryStream        stream = new MemoryStream();
            BinaryWriter        writer = new BinaryWriter(stream);
            byte[]              respBuf;

            ulong       puid;
            ulong       teamId;
            TeamTicket [] tt = null;
            
            AuthorizeCaller(titleId, webId, gamerTag, teamName, out puid, out teamId, out tt);            
                            
            request.titleId = titleId;
            request.userId = puid;
            request.teamId = teamId;
            request.datasetId = datasetId;
            request.procIndex = procIndex;          
            request.entityId = entityId;
            request.attribCount = (uint)attributes.Length;
            request.attribs = attributes;
            
            request.WriteStream(writer);

            if (tt != null)
            {
                TeamTickets     tts = new TeamTickets(tt);
                tts.WriteStream(writer);                    
            }
            
            WebHeaderCollection headers = new WebHeaderCollection();
            headers[XHttpHdr.WEBCACHEREQUEST] = "TRUE";

            Utilities.RequestInfo requestInfo = Utilities.GetRequestInfo();
            HTTPAuthData httpAuthData = new HTTPAuthData( requestInfo.ClientPort, requestInfo.ClientIP, requestInfo.qwRequestID, puid, titleId, (uint) XOService.Query, 0 );
            
            HResult hr = XRLUtil.PostXrlRequest(XOService.Query, request.GetXRL(), -1, httpAuthData.GetBase64EncodedString(), stream.ToArray(), headers, out respBuf);

            if (HResult.Failed(hr))
            {
                TranslateError(hr);
            }
        }


        public SearchResponse InternalSearch(
            uint titleId,
            uint datasetId,
            uint procIndex,
            uint page,
            uint resultsPerPage,
            QueryAttributeSpec[] specs,
            QueryAttribute[] attributes
            )
        {
            SearchRequest       request = new SearchRequest();
            SearchResponse      response = new SearchResponse();
            byte[]              respBuf;
                
            request.titleId = titleId;
            request.datasetId = datasetId;
            request.procIndex = procIndex;          
            request.page = page;
            request.resultsPerPage = resultsPerPage;
            request.specCount = (uint)specs.Length;
            request.attribCount = (uint)attributes.Length;
            request.specs = specs;
            request.attribs = attributes;
            
            WebHeaderCollection headers = new WebHeaderCollection();
            headers[XHttpHdr.WEBCACHEREQUEST] = "TRUE";
            
            Utilities.RequestInfo requestInfo = Utilities.GetRequestInfo();
            HTTPAuthData httpAuthData = new HTTPAuthData( requestInfo.ClientPort, requestInfo.ClientIP, requestInfo.qwRequestID, 0, titleId, (uint) XOService.Query, 0 );
            
            HResult hr = XRLUtil.PostXrlRequest(XOService.Query, request.GetXRL(), -1, httpAuthData.GetBase64EncodedString(), (byte[])request, headers, out respBuf);

            if (HResult.Succeeded(hr))
            {
                response.ReadBytes(respBuf);
            }
            else
            {
                TranslateError(hr);
            }
            
            return response;
        }
        
        public FindFromIdsResponse InternalFindFromIds(
            uint titleId,
            uint datasetId,
            uint procIndex,
            QueryAttributeSpec[] specs,
            ulong[] entityIds
            )
        {
            FindFromIdsRequest request = new FindFromIdsRequest();
            FindFromIdsResponse response = new FindFromIdsResponse();
            byte[]              respBuf;

            request.titleId = titleId;
            request.datasetId = datasetId;
            request.procIndex = procIndex;          
            request.specCount = (uint)specs.Length;
            request.idCount = (uint)entityIds.Length;

            request.specs = specs;
            request.entityIds = entityIds;

            WebHeaderCollection headers = new WebHeaderCollection();
            headers[XHttpHdr.WEBCACHEREQUEST] = "TRUE";
            
            Utilities.RequestInfo requestInfo = Utilities.GetRequestInfo();
            HTTPAuthData httpAuthData = new HTTPAuthData( requestInfo.ClientPort, requestInfo.ClientIP, requestInfo.qwRequestID, 0, titleId, (uint) XOService.Query, 0 );
            
            HResult hr = XRLUtil.PostXrlRequest(XOService.Query, request.GetXRL(), -1, httpAuthData.GetBase64EncodedString(), (byte[])request, headers, out respBuf);

            if (HResult.Succeeded(hr))
            {
                response.ReadBytes(respBuf);
            }
            else
            {
                TranslateError(hr);
            }
            
            return response;
        }


        public void InternalRemove(
            uint titleId,
            byte[] webId,
            string gamerTag,
            string teamName,
            uint datasetId,
            uint procIndex,
            QueryAttribute[] attributes
            )
        {
            RemoveRequest       request = new RemoveRequest();
            MemoryStream        stream = new MemoryStream();
            BinaryWriter        writer = new BinaryWriter(stream);
            byte[]              respBuf;

            ulong       puid;
            ulong       teamId;
            TeamTicket [] tt = null;
            
            AuthorizeCaller(titleId, webId, gamerTag, teamName, out puid, out teamId, out tt);            
            
            request.titleId = titleId;
            request.userId = puid;
            request.teamId = teamId;
            request.datasetId = datasetId;
            request.procIndex = procIndex;          
            request.attribCount = (uint)attributes.Length;
            request.attribs = attributes;

            request.WriteStream(writer);

            if (tt != null)
            {
                TeamTickets     tts = new TeamTickets(tt);
                tts.WriteStream(writer);                    
            }
            
            WebHeaderCollection headers = new WebHeaderCollection();
            headers[XHttpHdr.WEBCACHEREQUEST] = "TRUE";
            
            Utilities.RequestInfo requestInfo = Utilities.GetRequestInfo();
            HTTPAuthData httpAuthData = new HTTPAuthData( requestInfo.ClientPort, requestInfo.ClientIP, requestInfo.qwRequestID, puid, titleId, (uint) XOService.Query, 0 );
            
            HResult hr = XRLUtil.PostXrlRequest(XOService.Query, request.GetXRL(), -1, httpAuthData.GetBase64EncodedString(), stream.ToArray(), headers, out respBuf);

            if (HResult.Failed(hr))
            {
                TranslateError(hr);
            }
        }      


        public void InternalRemoveId(
            uint titleId,
            byte[] webId,
            string gamerTag,
            string teamName,
            uint datasetId,
            ulong entityId
            )
        {
            RemoveIdRequest     request = new RemoveIdRequest();
            MemoryStream        stream = new MemoryStream();
            BinaryWriter        writer = new BinaryWriter(stream);
            byte[]              respBuf;

            ulong       puid;
            ulong       teamId;
            TeamTicket [] tt = null;
            
            AuthorizeCaller(titleId, webId, gamerTag, teamName, out puid, out teamId, out tt);            
            request.titleId = titleId;
            request.userId = puid;
            request.teamId = teamId;
            request.datasetId = datasetId;
            request.entityId = entityId;

            request.WriteStream(writer);

            if (tt != null)
            {
                TeamTickets     tts = new TeamTickets(tt);
                tts.WriteStream(writer);                    
            }
            
            WebHeaderCollection headers = new WebHeaderCollection();
            headers[XHttpHdr.WEBCACHEREQUEST] = "TRUE";
            
            Utilities.RequestInfo requestInfo = Utilities.GetRequestInfo();
            HTTPAuthData httpAuthData = new HTTPAuthData( requestInfo.ClientPort, requestInfo.ClientIP, requestInfo.qwRequestID, puid, titleId, (uint) XOService.Query, 0 );
            
            HResult hr = XRLUtil.PostXrlRequest(XOService.Query, request.GetXRL(), -1, httpAuthData.GetBase64EncodedString(), stream.ToArray(), headers, out respBuf);

            if (HResult.Failed(hr))
            {
                TranslateError(hr);
            }
        }


        public void InternalSelect(
            uint titleId,
            byte[] webId,
            string gamerTag,
            string teamName,
            uint datasetId,
            ulong entityId,
            uint action,
            QueryAttribute[] attributes
            )
        {
            SelectRequest       request = new SelectRequest();
            MemoryStream        stream = new MemoryStream();
            BinaryWriter        writer = new BinaryWriter(stream);
            byte[]              respBuf;

            ulong       puid;
            ulong       teamId;
            TeamTicket [] tt = null;
            
            AuthorizeCaller(titleId, webId, gamerTag, teamName, out puid, out teamId, out tt);            
                            
            request.titleId = titleId;
            request.userId = puid;
            request.teamId = teamId;
            request.datasetId = datasetId;
            request.entityId = entityId;
            request.actionId = action;

            if (null != attributes)
            {
                request.attribCount = (uint)attributes.Length;
                request.attribs = attributes;
            }
            else
            {
                request.attribCount = 0;
                request.attribs = null;                    
            }

            request.WriteStream(writer);

            if (tt != null)
            {
                TeamTickets     tts = new TeamTickets(tt);
                tts.WriteStream(writer);                    
            }
            
            WebHeaderCollection headers = new WebHeaderCollection();
            headers[XHttpHdr.WEBCACHEREQUEST] = "TRUE";
            
            Utilities.RequestInfo requestInfo = Utilities.GetRequestInfo();
            HTTPAuthData httpAuthData = new HTTPAuthData( requestInfo.ClientPort, requestInfo.ClientIP, requestInfo.qwRequestID, puid, titleId, (uint) XOService.Query, 0 );
            
            HResult hr = XRLUtil.PostXrlRequest(XOService.Query, request.GetXRL(), -1, httpAuthData.GetBase64EncodedString(), stream.ToArray(), headers, out respBuf);

            if (HResult.Failed(hr))
            {
                TranslateError(hr);
            }
        }


        //
        // Base Query Service WebMethods
        //
        [WebMethod]
        public ulong Add(
            uint titleId,
            byte[] webId,
            string gamerTag,
            string teamName,
            uint datasetId,
            QueryAttribute[] attributes
            )
        {
            ulong   entityId = 0;
            
            try
            {
                // Check Authorization
                Utilities.Instance.CheckAPIAndTitle("Query.Add", titleId, TitlePrivilege.ReadWrite);

                // Do Perf counter stuff
                WebCacheQueryCounter.Counters.QueryAddRequestsPerSecond .Increment();
                WebCacheQueryCounter.Counters.QueryAddRequestsTotal .Increment();
                    
                string partnerName = Utilities.GetSubjectName();
                if (partnerName != null)
                {
                    WebCacheQueryCounter.Counters[partnerName].QueryAddRequestsPerSecond .Increment();
                    WebCacheQueryCounter.Counters[partnerName].QueryAddRequestsTotal .Increment();
                }

                entityId = InternalAdd(titleId, webId, gamerTag, teamName, datasetId, attributes);
                
            }
            catch (XboxWebException we)
            {
                throw we;
            }
            catch (Exception e)
            {
                ValidateAttributeTypes(attributes, false);
                
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_42, e);
            }
            finally
            {
                string szLog = "Query|Add|" 
                        + Utilities.GetSubjectName() + "|"
                        + Utilities.GetRequestID() + "|"
                        + Utilities.GetClientIPPort() + "|"
                        + titleId.ToString("X") + "|"
                        + ByteConvert.ToReverseString(webId)+ "|" 
                        + gamerTag + "|" 
                        + teamName + "|"
                        + datasetId + "|" 
                        + attributes.Length;

                Xom.Log(XomAreaName.wcQueryLog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );
            }
            
            return entityId;
        }
        

        [WebMethod]
        public void Update(
            uint titleId,
            byte[] webId,
            string gamerTag,
            string teamName,
            uint datasetId,
            uint procIndex,
            QueryAttribute[] attributes
            )
        {
            try
            {
                // Check Authorization
                Utilities.Instance.CheckAPIAndTitle("Query.Update", titleId, TitlePrivilege.ReadWrite);

                // Do Perf counter stuff
                WebCacheQueryCounter.Counters.QueryUpdateRequestsPerSecond .Increment();
                WebCacheQueryCounter.Counters.QueryUpdateRequestsTotal .Increment();
                    
                string partnerName = Utilities.GetSubjectName();
                if (partnerName != null)
                {
                    WebCacheQueryCounter.Counters[partnerName].QueryUpdateRequestsPerSecond .Increment();
                    WebCacheQueryCounter.Counters[partnerName].QueryUpdateRequestsTotal .Increment();
                }

                // Do Work
                InternalUpdate(titleId, webId, gamerTag, teamName, datasetId, procIndex, attributes);
            }
            catch (XboxWebException we)
            {
                throw we;
            }
            catch (Exception e)
            {
                ValidateAttributeTypes(attributes, false);
            
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_43, e);
            }      
            finally
            {
                string szLog = "Query|Update|"
                        + Utilities.GetSubjectName() + "|"
                        + Utilities.GetRequestID() + "|"
                        + Utilities.GetClientIPPort() + "|"
                        + titleId.ToString("X") + "|"
                        + ByteConvert.ToReverseString(webId)+ "|" 
                        + gamerTag + "|" 
                        + teamName + "|" 
                        + datasetId + "|" 
                        + procIndex + "|"
                        + attributes.Length;

                Xom.Log(XomAreaName.wcQueryLog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );
            }
            
        }
        

        [WebMethod]
        public void UpdateId(
            uint titleId,
            byte[] webId,
            string gamerTag,
            string teamName,
            uint datasetId,
            uint procIndex,
            ulong entityId,
            QueryAttribute[] attributes
            )
        {
            try
            {
                // Check Authorization
                Utilities.Instance.CheckAPIAndTitle("Query.UpdateId", titleId, TitlePrivilege.ReadWrite);

                // Do Perf counter stuff
                WebCacheQueryCounter.Counters.QueryUpdateIdRequestsPerSecond .Increment();
                WebCacheQueryCounter.Counters.QueryUpdateIdRequestsTotal .Increment();
                    
                string partnerName = Utilities.GetSubjectName();
                if (partnerName != null)
                {
                    WebCacheQueryCounter.Counters[partnerName].QueryUpdateIdRequestsPerSecond .Increment();
                    WebCacheQueryCounter.Counters[partnerName].QueryUpdateIdRequestsTotal .Increment();
                }

                // Do Work
                InternalUpdateId(titleId, webId, gamerTag, teamName, datasetId, procIndex, entityId, attributes);
            }
            catch (XboxWebException we)
            {
                throw we;
            }
            catch (Exception e)
            {
                ValidateAttributeTypes(attributes, false);
            
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_44, e);
            }     
            finally
            {
                string szLog = "Query|UpdateId|" 
                        + Utilities.GetSubjectName() + "|"
                        + Utilities.GetRequestID() + "|"
                        + Utilities.GetClientIPPort() + "|"
                        + titleId.ToString("X") + "|" 
                        + ByteConvert.ToReverseString(webId)+ "|" 
                        + gamerTag + "|" 
                        + teamName + "|" 
                        + datasetId + "|" 
                        + procIndex + "|" 
                        + entityId + "|"
                        + attributes.Length;
            
                Xom.Log(XomAreaName.wcQueryLog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );
            }
        }


        [WebMethod]
        public SearchResponse Search(
            uint titleId,
            uint datasetId,
            uint procIndex,
            uint page,
            uint resultsPerPage,
            QueryAttributeSpec[] specs,
            QueryAttribute[] attributes
            )
        {
            SearchResponse      response;

            try
            {
                // Check Authorization
                Utilities.Instance.CheckAPIAndTitle("Query.Search", titleId, TitlePrivilege.ReadOnly);
                
                // REVIEW: Should we require web creds here anyway?

                // Do Perf counter stuff
                WebCacheQueryCounter.Counters.QuerySearchRequestsPerSecond .Increment();
                WebCacheQueryCounter.Counters.QuerySearchRequestsTotal .Increment();
                    
                string partnerName = Utilities.GetSubjectName();
                if (partnerName != null)
                {
                    WebCacheQueryCounter.Counters[partnerName].QuerySearchRequestsPerSecond .Increment();
                    WebCacheQueryCounter.Counters[partnerName].QuerySearchRequestsTotal .Increment();
                }

                // Do Work
                response = InternalSearch(titleId, datasetId, procIndex, page, resultsPerPage, specs, attributes);
            }
            catch (XboxWebException we)
            {                
                throw we;
            }
            catch (Exception e)
            {
                ValidateAttributeTypes(attributes, false);
            
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_45, e);
            }      
            finally
            {
                string szLog = "Query|Search|"
                        + Utilities.GetSubjectName() + "|"
                        + Utilities.GetRequestID() + "|"
                        + Utilities.GetClientIPPort() + "|"
                        + titleId.ToString("X") + "|" 
                        + datasetId + "|" 
                        + procIndex + "|"
                        + page + "|"
                        + resultsPerPage + "|"
                        + specs.Length + "|"
                        + attributes.Length;
            
                Xom.Log(XomAreaName.wcQueryLog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );
            }
            
            return response;
        }
        

        [WebMethod]
        public FindFromIdsResponse FindFromIds(
            uint titleId,
            uint datasetId,
            uint procIndex,
            QueryAttributeSpec[] specs,
            ulong[] entityIds
            )
        {
            FindFromIdsResponse response;

            try
            {
                // Check Authorization
                Utilities.Instance.CheckAPIAndTitle("Query.FindFromIds", titleId, TitlePrivilege.ReadOnly);

                // REVIEW: Should we require web creds here anyway?
                
                // Do Perf counter stuff
                WebCacheQueryCounter.Counters.QueryFindFromIdsRequestsPerSecond .Increment();
                WebCacheQueryCounter.Counters.QueryFindFromIdsRequestsTotal .Increment();
                    
                string partnerName = Utilities.GetSubjectName();
                if (partnerName != null)
                {
                    WebCacheQueryCounter.Counters[partnerName].QueryFindFromIdsRequestsPerSecond .Increment();
                    WebCacheQueryCounter.Counters[partnerName].QueryFindFromIdsRequestsTotal .Increment();
                }

                // Do Work
                response = InternalFindFromIds(titleId, datasetId, procIndex, specs, entityIds);
                
            }
            catch (XboxWebException we)
            {
                throw we;
            }
            catch (Exception e)
            {
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_46, e);
            }      
            finally
            {
                string szLog = "Query|Find|"
                        + Utilities.GetSubjectName() + "|"
                        + Utilities.GetRequestID() + "|"
                        + Utilities.GetClientIPPort() + "|"
                        + titleId.ToString("X") + "|" 
                        + datasetId + "|" 
                        + procIndex + "|"
                        + specs.Length + "|"
                        + entityIds.Length;

                Xom.Log(XomAreaName.wcQueryLog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );
            }
            
            return response;
        }


        [WebMethod]
        public void Remove(
            uint titleId,
            byte[] webId,
            string gamerTag,
            string teamName,
            uint datasetId,
            uint procIndex,
            QueryAttribute[] attributes
            )
        {
            try
            {
                // Check Authorization
                Utilities.Instance.CheckAPIAndTitle("Query.Remove", titleId, TitlePrivilege.ReadWrite);

                // Do Perf counter stuff
                WebCacheQueryCounter.Counters.QueryRemoveRequestsPerSecond .Increment();
                WebCacheQueryCounter.Counters.QueryRemoveRequestsTotal .Increment();
                    
                string partnerName = Utilities.GetSubjectName();
                if (partnerName != null)
                {
                    WebCacheQueryCounter.Counters[partnerName].QueryRemoveRequestsPerSecond .Increment();
                    WebCacheQueryCounter.Counters[partnerName].QueryRemoveRequestsTotal .Increment();
                }

                // Do Work
                InternalRemove(titleId, webId, gamerTag, teamName, datasetId, procIndex, attributes);                
            }
            catch (XboxWebException we)
            {
                throw we;
            }
            catch (Exception e)
            {
                ValidateAttributeTypes(attributes, false);
            
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_47, e);
            }      
            finally
            {
                string szLog = "Query|Remove|"
                        + Utilities.GetSubjectName() + "|"
                        + Utilities.GetRequestID() + "|"
                        + Utilities.GetClientIPPort() + "|"
                        + titleId.ToString("X") + "|" 
                        + ByteConvert.ToReverseString(webId)+ "|" 
                        + gamerTag + "|" 
                        + teamName + "|" 
                        + datasetId + "|" 
                        + procIndex + "|" 
                        + attributes.Length;

                Xom.Log(XomAreaName.wcQueryLog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );
            }
            
        }

        
        [WebMethod]
        public void RemoveId(
            uint titleId,
            byte[] webId,
            string gamerTag,
            string teamName,
            uint datasetId,
            ulong entityId
            )
        {
            try
            {
                // Check Authorization
                Utilities.Instance.CheckAPIAndTitle("Query.RemoveId", titleId, TitlePrivilege.ReadWrite);

                // Do Perf counter stuff
                WebCacheQueryCounter.Counters.QueryRemoveIdRequestsPerSecond .Increment();
                WebCacheQueryCounter.Counters.QueryRemoveIdRequestsTotal .Increment();
                    
                string partnerName = Utilities.GetSubjectName();
                if (partnerName != null)
                {
                    WebCacheQueryCounter.Counters[partnerName].QueryRemoveIdRequestsPerSecond .Increment();
                    WebCacheQueryCounter.Counters[partnerName].QueryRemoveIdRequestsTotal .Increment();
                }

                // Do Work
                InternalRemoveId(titleId, webId, gamerTag, teamName, datasetId, entityId);                
            }
            catch (XboxWebException we)
            {
                throw we;
            }
            catch (Exception e)
            {
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_48, e);
            }      
            finally
            {
                string szLog = "Query|RemoveId|"
                        + Utilities.GetSubjectName() + "|"
                        + Utilities.GetRequestID() + "|"
                        + Utilities.GetClientIPPort() + "|"
                        + titleId.ToString("X") + "|" 
                        + ByteConvert.ToReverseString(webId)+ "|" 
                        + gamerTag + "|" 
                        + teamName + "|" 
                        + datasetId + "|" 
                        + entityId + "|";

                Xom.Log(XomAreaName.wcQueryLog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );
            }
            
        }
        

        [WebMethod]
        public void Select(
            uint titleId,
            byte[] webId,
            string gamerTag,
            string teamName,
            uint datasetId,
            ulong entityId,
            uint action,
            QueryAttribute[] attributes
            )
        {
            try
            {
                // Check Authorization
                Utilities.Instance.CheckAPIAndTitle("Query.Select", titleId, TitlePrivilege.ReadWrite);

                // Do Perf counter stuff
                WebCacheQueryCounter.Counters.QuerySelectRequestsPerSecond .Increment();
                WebCacheQueryCounter.Counters.QuerySelectRequestsTotal .Increment();
                    
                string partnerName = Utilities.GetSubjectName();
                if (partnerName != null)
                {
                    WebCacheQueryCounter.Counters[partnerName].QuerySelectRequestsPerSecond .Increment();
                    WebCacheQueryCounter.Counters[partnerName].QuerySelectRequestsTotal .Increment();
                }

                // Do Work
                InternalSelect(titleId, webId, gamerTag, teamName, datasetId, entityId, action, attributes);                
            }
            catch (XboxWebException we)
            {
                throw we;
            }
            catch (Exception e)
            {
                ValidateAttributeTypes(attributes, true);
            
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_49, e);
            }      
            finally
            {
                int     attrLen = 0;

                if (attributes != null)
                {
                    attrLen = attributes.Length;
                }
               
                string szLog = "Query|Select|"
                        + Utilities.GetSubjectName() + "|"
                        + Utilities.GetRequestID() + "|"
                        + Utilities.GetClientIPPort() + "|"
                        + titleId.ToString("X") + "|" 
                        + ByteConvert.ToReverseString(webId)+ "|" 
                        + gamerTag + "|" 
                        + teamName + "|" 
                        + datasetId + "|" 
                        + entityId + "|"
                        + action + "|" 
                        + attrLen;

                Xom.Log(XomAreaName.wcQueryLog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );
            }
            
        }


        //
        // Returns XQS file for Comp Manager tool configuration
        //
        [WebMethod]
        [SoapDocumentMethod]
        public string GetXQSConfig(
            uint titleId,
            byte[] webId,        // Required for logging purposes
            ulong haveVersion    // To enable client caching
            )
        {
            string          xqs = "You have the latest version";
            SqlDataReader   reader = null;
            SqlConnection   con = null;
            SqlCommand      cmd = null;
            
            if (( null == webId ) || ( webId.Length == 0 ))
            {
                throw new XboxWebExceptionNoEvent(" Error: No webId was specified by the caller.");            
            }                
            
            try
            {
                // Check Authorization
                Utilities.Instance.CheckAPIAndTitle("Query.GetXQSConfig", titleId, TitlePrivilege.ReadOnly);

                // Do Perf counter stuff
                WebCacheQueryCounter.Counters.QueryGetXQSRequestsPerSecond .Increment();
                WebCacheQueryCounter.Counters.QueryGetXQSRequestsTotal .Increment();
                    
                string partnerName = Utilities.GetSubjectName();
                if (partnerName != null)
                {
                    WebCacheQueryCounter.Counters[partnerName].QueryGetXQSRequestsPerSecond .Increment();
                    WebCacheQueryCounter.Counters[partnerName].QueryGetXQSRequestsTotal .Increment();
                }

                // Do Work
                SqlParameter    param;
                HResult         hr = HResult.S_OK;

                con = new SqlConnection(Config.NpdbConnectionString);
                con.Open();

                cmd = new SqlCommand("p_query_get_config", con);
                cmd.CommandType = CommandType.StoredProcedure;

                param = new SqlParameter();
                param.ParameterName = "@ret";
                param.Direction = ParameterDirection.ReturnValue;
                param.SqlDbType = SqlDbType.Int;                
                cmd.Parameters.Add(param);

                cmd.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)titleId;
                cmd.Parameters.Add("@bi_have_version", SqlDbType.BigInt).Value = (long)haveVersion;

                reader = cmd.ExecuteReader();

                object o = cmd.Parameters["@ret"].Value;

                if (o is int)
                {
                    unchecked
                    {
                       hr = (uint)(int)o;
                    }
                }

                if (HResult.Failed(hr))
                {
                    throw new XboxWebExceptionNoEvent(" Error: titleid " + titleId + " does not have an XQS configuration on XBOX Live. hr = " + hr);            
                }                

                if (reader.Read())
                {
                    xqs = reader.GetString(0);
                }
                
            }
            catch (XboxWebException we)
            {
                throw we;
            }
            catch (Exception e)
            {
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_50, e);
            }
            finally
            {
                if (null != reader)
                {
                    reader.Close();
                    reader = null;
                }

                if (null != cmd)
                {
                    cmd.Cancel();
                    cmd = null;
                }

                if (null != con)
                {
                    con.Close();
                    con = null;
                }
                
                string szLog = "GetXQSConfig|"
                        + Utilities.GetSubjectName() + "|"
                        + Utilities.GetRequestID() + "|"
                        + Utilities.GetClientIPPort() + "|"
                        + titleId.ToString("X") + "|" 
                        + ByteConvert.ToReverseString(webId)+ "|" 
                        + haveVersion.ToString("X");
                
                Xom.Log(XomAreaName.wcQueryLog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );
            }
            
            return xqs;
        }


        //
        // Extended Query Service APIs (Parity with client APIs)
        //        
        [WebMethod]
        public ulong CompetitionCreate(
            uint        titleId,
            byte[]      webId,
            string      gamerTag,
            string      teamName,
            uint        datasetId,
            QueryAttribute[] attributes
            )
        {
            ulong   compId = 0;
            
            try
            {
                // Check Authorization
                Utilities.Instance.CheckAPIAndTitle("Query.CompetitionCreate", titleId, TitlePrivilege.ReadWrite);
                
                // Do Perf counter stuff
                WebCacheQueryCounter.Counters.CompetitionCreateRequestsPerSecond .Increment();
                WebCacheQueryCounter.Counters.CompetitionCreateRequestsTotal .Increment();
                    
                string partnerName = Utilities.GetSubjectName();
                if (partnerName != null)
                {
                    WebCacheQueryCounter.Counters[partnerName].CompetitionCreateRequestsPerSecond .Increment();
                    WebCacheQueryCounter.Counters[partnerName].CompetitionCreateRequestsTotal .Increment();
                }

                // Do Work
                compId = InternalAdd(titleId, webId, gamerTag, teamName, datasetId, attributes);
            }
            catch (XboxWebException we)
            {
                throw we;
            }
            catch (Exception e)
            {
                ValidateAttributeTypes(attributes, false);
                
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_51, e);
            }        
            finally
            {
                string szLog = "Comp|Create|"
                        + Utilities.GetSubjectName() + "|"
                        + Utilities.GetRequestID() + "|"
                        + Utilities.GetClientIPPort() + "|"
                        + titleId.ToString("X") + "|" 
                        + ByteConvert.ToReverseString(webId)+ "|" 
                        + gamerTag + "|" 
                        + teamName + "|" 
                        + datasetId + "|" 
                        + attributes.Length;

                Xom.Log(XomAreaName.wcQueryLog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );
            }

            return compId;
        }       


        [WebMethod]
        public ulong CompetitionCreateSingleElimination(
            uint        titleId,
            byte[]      webId,
            string      gamerTag,
            string      teamName,
            uint        datasetId,

            // Typed attributes
            uint        cPrivateSlots,
            uint        cPublicSlots,
            uint        cMinimumPlayers,
            DateTime    dtRegistrationOpen,
            DateTime    dtRegistrationClose,
            DateTime    dtCompetitionStart,
            DateTime    dtRoundOneStart,
            DateTime    dtRoundOneEnd,
            uint        dwMatchReminderAdvanceMinutes,
            uint        UnitOrMask,
            uint        Interval,
            bool        fTeamCompetition,
            uint        dwTeamSize,

            // Custom attributes
            QueryAttribute[] additionalAttributes
            )
        {
            ulong   compId = 0;
            
            try
            {
                // Check Authorization
                Utilities.Instance.CheckAPIAndTitle("Query.CompetitionCreateSingleElimination", titleId, TitlePrivilege.ReadWrite);
                
                // Do Perf counter stuff
                WebCacheQueryCounter.Counters.CompetitionCreateSERequestsPerSecond .Increment();
                WebCacheQueryCounter.Counters.CompetitionCreateSERequestsTotal .Increment();
                    
                string partnerName = Utilities.GetSubjectName();
                if (partnerName != null)
                {
                    WebCacheQueryCounter.Counters[partnerName].CompetitionCreateSERequestsPerSecond .Increment();
                    WebCacheQueryCounter.Counters[partnerName].CompetitionCreateSERequestsTotal .Increment();
                }

                // Do Work
                int                 cAttributes = 15;
                QueryAttribute[]    attributes;

                uint                rounds = EliminationHelper.RoundsFromEntrants((uint)(cPublicSlots + cPrivateSlots));;
                uint                units = Interval == Comp.XONLINE_COMP_INTERVAL_DAY ? 1 : UnitOrMask;
                uint                dayMask = Interval == Comp.XONLINE_COMP_INTERVAL_DAY ? UnitOrMask : Comp.XONLINE_COMP_DAY_MASK_ALL;
                
                if (null != additionalAttributes)
                {
                    cAttributes += additionalAttributes.Length;
                }

                attributes = new QueryAttribute[cAttributes];

                for (int i=0; i<15; i++)
                {
                    attributes[i] = new QueryAttribute();
                }

                attributes[0].Id = Comp.XONLINE_COMP_ATTR_MAX_PRIVATE_SLOTS;
                attributes[0].lValue = (long)cPrivateSlots;
                attributes[1].Id = Comp.XONLINE_COMP_ATTR_MAX_PUBLIC_SLOTS;
                attributes[1].lValue = (long)cPublicSlots;
                attributes[2].Id = Comp.XONLINE_COMP_ATTR_MIN_SLOTS;
                attributes[2].lValue = (long)cMinimumPlayers;
                attributes[3].Id = Comp.XONLINE_COMP_ATTR_REG_OPEN;
                attributes[3].lValue = dtRegistrationOpen.ToFileTimeUtc();
                attributes[4].Id = Comp.XONLINE_COMP_ATTR_REG_CLOSE;
                attributes[4].lValue = dtRegistrationClose.ToFileTimeUtc();
                attributes[5].Id = Comp.XONLINE_COMP_ATTR_COMP_START;
                attributes[5].lValue = dtCompetitionStart.ToFileTimeUtc();
                attributes[6].Id = Comp.XONLINE_COMP_ATTR_ROUND_ONE_START;
                attributes[6].lValue = dtRoundOneStart.ToFileTimeUtc();
                attributes[7].Id = Comp.XONLINE_COMP_ATTR_ROUND_ONE_END;
                attributes[7].lValue = dtRoundOneEnd.ToFileTimeUtc();
                attributes[8].Id = Comp.XONLINE_COMP_ATTR_REMINDER_MIN;
                attributes[8].lValue = (long)dwMatchReminderAdvanceMinutes;
                attributes[9].Id = Comp.XONLINE_COMP_ATTR_ROUND_FREQUENCY;
                attributes[9].lValue = (long)units;
                attributes[10].Id = Comp.XONLINE_COMP_ATTR_ROUND_DAY_MASK;
                attributes[10].lValue = (long)dayMask; 
                attributes[11].Id = Comp.XONLINE_COMP_ATTR_ROUND_INTERVAL;
                attributes[11].lValue = (long)Interval;
                attributes[12].Id = Comp.XONLINE_COMP_ATTR_IS_TEAM_COMP;
                attributes[12].lValue = fTeamCompetition == true ? 1 : 0;
                attributes[13].Id = Comp.XONLINE_COMP_ATTR_TEAM_SIZE;
                attributes[13].lValue = (long)dwTeamSize;
                attributes[14].Id = Comp.XONLINE_COMP_ATTR_COMP_CLEANUP;
                attributes[14].lValue = (long)30;
                
                if (null != additionalAttributes)
                {
                    for (int i=0; i<additionalAttributes.Length; i++)
                    {
                        attributes[i+15] = additionalAttributes[i];                        
                    }
                }
            
                compId = InternalAdd(titleId, webId, gamerTag, teamName, datasetId, attributes);        
            }
            catch (XboxWebException we)
            {
                throw we;
            }
            catch (Exception e)
            {
                ValidateAttributeTypes(additionalAttributes, true);
                
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_52, e);
            }            
            finally
            {
                int     attrLen = 0;

                if (additionalAttributes != null)
                {
                    attrLen = additionalAttributes.Length;
                }
               
                string szLog = "Comp|CreateSE|"
                        + Utilities.GetSubjectName() + "|"
                        + Utilities.GetRequestID() + "|"
                        + Utilities.GetClientIPPort() + "|"
                        + titleId.ToString("X") + "|" 
                        + ByteConvert.ToReverseString(webId)+ "|" 
                        + gamerTag + "|" 
                        + teamName + "|" 
                        + datasetId + "|" 
                        + attrLen;

                Xom.Log(XomAreaName.wcQueryLog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );
            }

            return compId;
        }
        

        [WebMethod]
        public SearchResponse CompetitionSearch(
            uint titleId,
            uint datasetId,
            uint queryId,
            uint page,
            uint resultsPerPage,
            QueryAttributeSpec[] specs,
            QueryAttribute[] attributes
            )            
        {
            SearchResponse response = null;
            
            try
            {
                // Check Authorization
                Utilities.Instance.CheckAPIAndTitle("Query.CompetitionSearch", titleId, TitlePrivilege.ReadWrite);
                
                // Do Perf counter stuff
                WebCacheQueryCounter.Counters.CompetitionSearchRequestsPerSecond .Increment();
                WebCacheQueryCounter.Counters.CompetitionSearchRequestsTotal .Increment();
                    
                string partnerName = Utilities.GetSubjectName();
                if (partnerName != null)
                {
                    WebCacheQueryCounter.Counters[partnerName].CompetitionSearchRequestsPerSecond .Increment();
                    WebCacheQueryCounter.Counters[partnerName].CompetitionSearchRequestsTotal .Increment();
                }

                // Do Work
                response = InternalSearch(titleId, datasetId, queryId, page, resultsPerPage, specs, attributes);                    
            }
            catch (XboxWebException we)
            {
                throw we;
            }
            catch (Exception e)
            {
                ValidateAttributeTypes(attributes, false);
                
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_53, e);
            }            
            finally
            {
                string szLog = "Comp|Search|"
                        + Utilities.GetSubjectName() + "|"
                        + Utilities.GetRequestID() + "|"
                        + Utilities.GetClientIPPort() + "|"
                        + titleId.ToString("X") + "|" 
                        + datasetId + "|" 
                        + queryId + "|" 
                        + page + "|"
                        + resultsPerPage + "|"
                        + specs.Length + "|"
                        + attributes.Length;

                Xom.Log(XomAreaName.wcQueryLog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );
            }

            return response;
        }


        [WebMethod]
        public void CompetitionManageEntrant(
            uint titleId,
            byte[] webId,
            string gamerTag,
            uint action,
            string teamName,
            uint datasetId,
            ulong competitionId,
            QueryAttribute[] attributes
            )
        {
            try
            {
                // Check Authorization
                Utilities.Instance.CheckAPIAndTitle("Query.CompetitionManageEntrant", titleId, TitlePrivilege.ReadWrite);
                
                // Do Perf counter stuff
                WebCacheQueryCounter.Counters.CompetitionManageEntrantRequestsPerSecond .Increment();
                WebCacheQueryCounter.Counters.CompetitionManageEntrantRequestsTotal .Increment();
                    
                string partnerName = Utilities.GetSubjectName();
                if (partnerName != null)
                {
                    WebCacheQueryCounter.Counters[partnerName].CompetitionManageEntrantRequestsPerSecond .Increment();
                    WebCacheQueryCounter.Counters[partnerName].CompetitionManageEntrantRequestsTotal .Increment();
                }

                // Do Work
                InternalSelect(titleId, webId, gamerTag, teamName, datasetId, competitionId, action, attributes);            
            }
            catch (XboxWebException we)
            {
                throw we;
            }
            catch (Exception e)
            {
                ValidateAttributeTypes(attributes, true);
                
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_54, e);
            }            
            finally
            {
                int     attrLen = 0;

                if (attributes != null)
                {
                    attrLen = attributes.Length;
                }
               
                string szLog = "Comp|ManageEntrant|"
                        + Utilities.GetSubjectName() + "|"
                        + Utilities.GetRequestID() + "|"
                        + Utilities.GetClientIPPort() + "|"
                        + titleId.ToString("X") + "|" 
                        + ByteConvert.ToReverseString(webId)+ "|" 
                        + gamerTag + "|" 
                        + action + "|"
                        + teamName + "|" 
                        + datasetId + "|" 
                        + competitionId + "|"
                        + attrLen;

                Xom.Log(XomAreaName.wcQueryLog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );
            }
                
        }


        [WebMethod]
        public void CompetitionCancel(
            uint titleId,
            byte[] webId,
            string gamerTag,
            string teamName,
            uint datasetId,
            ulong competitionId
            )
        {
            try
            {
                // Check Authorization
                Utilities.Instance.CheckAPIAndTitle("Query.CompetitionCancel", titleId, TitlePrivilege.ReadWrite);
                
                // Do Perf counter stuff
                WebCacheQueryCounter.Counters.CompetitionCancelRequestsPerSecond .Increment();
                WebCacheQueryCounter.Counters.CompetitionCancelRequestsTotal .Increment();
                    
                string partnerName = Utilities.GetSubjectName();
                if (partnerName != null)
                {
                    WebCacheQueryCounter.Counters[partnerName].CompetitionCancelRequestsPerSecond .Increment();
                    WebCacheQueryCounter.Counters[partnerName].CompetitionCancelRequestsTotal .Increment();
                }

                // Do Work
                InternalSelect(titleId, webId, gamerTag, teamName, datasetId, competitionId, Comp.XONLINE_COMP_ACTION_CANCEL, null);                    
            }
            catch (XboxWebException we)
            {
                throw we;
            }
            catch (Exception e)
            {
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_55, e);
            }            
                
        }
        

        [WebMethod]
        public SearchResponse CompetitionTopology(
            uint titleId,
            uint datasetId,
            ulong competitionId,
            uint page,
            uint resultsPerPage,
            long startingEventId,
            long endingEventId,
            QueryAttributeSpec[] specs
            )
        {
            SearchResponse response = null;
            
            try
            {
                // Check Authorization
                Utilities.Instance.CheckAPIAndTitle("Query.CompetitionTopology", titleId, TitlePrivilege.ReadWrite);
                
                // Do Perf counter stuff
                WebCacheQueryCounter.Counters.CompetitionTopologyRequestsPerSecond .Increment();
                WebCacheQueryCounter.Counters.CompetitionTopologyRequestsTotal .Increment();
                    
                string partnerName = Utilities.GetSubjectName();
                if (partnerName != null)
                {
                    WebCacheQueryCounter.Counters[partnerName].CompetitionTopologyRequestsPerSecond .Increment();
                    WebCacheQueryCounter.Counters[partnerName].CompetitionTopologyRequestsTotal .Increment();
                }

                // Do Work
                QueryAttribute[] attributes = new QueryAttribute[3];

                for (int i = 0; i < attributes.Length; i++)    { attributes[i] = new QueryAttribute(); }

                attributes[0].Id = Comp.XONLINE_COMP_ATTR_ID;
                attributes[0].lValue = (long)competitionId;
                attributes[1].Id = Comp.XONLINE_COMP_ATTR_EVENT_MIN;
                attributes[1].lValue = (long)startingEventId;
                attributes[2].Id = Comp.XONLINE_COMP_ATTR_EVENT_MAX;
                attributes[2].lValue = (long)endingEventId;

                response = InternalSearch(titleId, datasetId, 1, page, resultsPerPage, specs, attributes);                                
            }
            catch (XboxWebException we)
            {
                throw we;
            }
            catch (Exception e)
            {
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_56, e);
            }            
            finally
            {
                string szLog = "Comp|Topology|"
                        + Utilities.GetSubjectName() + "|"
                        + Utilities.GetRequestID() + "|"
                        + Utilities.GetClientIPPort() + "|"
                        + titleId.ToString("X") + "|" 
                        + datasetId + "|" 
                        + competitionId + "|" 
                        + page + "|"
                        + resultsPerPage + "|"
                        + startingEventId + "|"
                        + endingEventId + "|"
                        + specs.Length;

                Xom.Log(XomAreaName.wcQueryLog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );
            }

            return response;
        }
        

        [WebMethod]
        public SearchResponse CompetitionTopologySingleElimination(
            uint titleId,
            uint datasetId,
            ulong competitionId,
            ulong originEventId,
            uint roundsForward,
            uint roundsBackward,
            uint topWidth,
            QueryAttributeSpec[] specs            
            )        
        {
            SearchResponse  response = null;

            try
            {
                // Check Authorization
                Utilities.Instance.CheckAPIAndTitle("Query.CompetitionTopologySingleElimination", titleId, TitlePrivilege.ReadWrite);
                
                // Do Perf counter stuff
                WebCacheQueryCounter.Counters.CompetitionTopologySERequestsPerSecond .Increment();
                WebCacheQueryCounter.Counters.CompetitionTopologySERequestsTotal .Increment();
                    
                string partnerName = Utilities.GetSubjectName();
                if (partnerName != null)
                {
                    WebCacheQueryCounter.Counters[partnerName].CompetitionTopologySERequestsPerSecond .Increment();
                    WebCacheQueryCounter.Counters[partnerName].CompetitionTopologySERequestsTotal .Increment();
                }

                // Do Work
                uint                originRound = (uint)(originEventId >> 16);
                uint                originEvent = ((uint)originEventId & Comp.XONLINE_COMP_ELIMINATION_EVENT_ID_MASK);
                uint                totalEntries;
                uint                baseWidth = 1;
                uint                round;

                // Prevent the caller from doing something truly stupid
                originRound = Math.Min(originRound, Comp.XONLINE_COMP_ELIMINATION_MAX_ROUNDS);
                
                roundsForward = Math.Min(roundsForward, Comp.XONLINE_COMP_ELIMINATION_MAX_ROUNDS - originRound - 1);                
                roundsBackward = Math.Min(roundsBackward, originRound);

                topWidth = Math.Min(topWidth, Comp.XONLINE_COMP_ELIMINATION_MAX_SLOTS - 1);

                
                if (roundsForward > 0)
                {
                    originRound += roundsForward;
                    originEvent >>= (int)roundsForward;
                }

                roundsBackward += roundsForward;

                // Setup the search params
                QueryAttribute[] attributes = new QueryAttribute[3];

                for (int i = 0; i < attributes.Length; i++)    { attributes[i] = new QueryAttribute(); }
                
                attributes[0].Id = Comp.XONLINE_COMP_ATTR_ID;
                attributes[0].lValue = (long)competitionId;

                attributes[1].Id = Comp.XONLINE_COMP_ATTR_EVENT_MIN;
                attributes[2].Id = Comp.XONLINE_COMP_ATTR_EVENT_MAX;
                
                totalEntries = 0;
                for (int i=0; i<=roundsBackward; i++)
                {
                    // Keep some sanity around the math. We should never be requesting with widths greater than 1024 for SE
                    baseWidth = Math.Min((1 + 2 * topWidth) * (uint)(1 << i), Comp.XONLINE_COMP_ELIMINATION_MAX_SLOTS - 1);                    
                    
                    totalEntries += baseWidth;
                }

                // Full SE comp has at most 1023 events
                totalEntries = Math.Min(totalEntries, Comp.XONLINE_COMP_ELIMINATION_MAX_SLOTS - 1);    
                
                response = new SearchResponse();

                response.totalResults = totalEntries;
                response.returnedResults = 0;
                response.attribCount = 0;
                response.attribs = new QueryAttribute[totalEntries * specs.Length];
                
                // Do the searches from lowest to highest round order. 
                for (round=originRound - roundsBackward; round<=originRound; round++)
                {
                    SearchResponse roundResponse = null;
                    
                    uint width = Math.Min((1 + 2 * topWidth) * (uint)(1 << (int)(originRound - round)), Comp.XONLINE_COMP_ELIMINATION_MAX_SLOTS - 1);
                    uint startingEventId = ((originEvent - topWidth) << (int)(originRound - round));
                    uint endingEventId;
                    
                    if (topWidth > originEvent)
                    {
                        startingEventId = 0;                        
                    }
                    
                    endingEventId = startingEventId + width - 1;

                    attributes[1].lValue = ((long)round << 16) + (long)startingEventId;
                    attributes[2].lValue = ((long)round << 16) + (long)endingEventId;

                    roundResponse = InternalSearch(titleId, datasetId, 1 /* procId */, 0 /*page */, width + 1 /* resultsPerPage */, specs, attributes);                                

                    if (roundResponse.attribCount > 0)
                    {                        
                        Debug.Assert(roundResponse.attribCount == roundResponse.attribs.Length);
                        
                        // REVIEW: Do we want to spend time validating that the attribs are in EventId order??

                        roundResponse.attribs.CopyTo(response.attribs, response.attribCount);
                        
                        response.returnedResults += roundResponse.returnedResults;
                        response.attribCount += roundResponse.attribCount;
                    }
                }

                if (response.returnedResults != response.totalResults)
                {
                    // Caller was dumb and requested data off the edge of the competition. Let's fix it
                    //  up for them. 
                    attributes = new QueryAttribute[response.attribCount];

                    Array.Copy(response.attribs, attributes, response.attribCount);
                    
                    response.attribs = attributes;                    
                    response.totalResults = response.returnedResults;
                }
            }
            catch (XboxWebException we)
            {
                throw we;
            }
            catch (Exception e)
            {
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_57, e);
            }            
            finally
            {
                string szLog = "Comp|TopologySE|"
                        + Utilities.GetSubjectName() + "|"
                        + Utilities.GetRequestID() + "|"
                        + Utilities.GetClientIPPort() + "|"
                        + titleId.ToString("X") + "|" 
                        + datasetId + "|" 
                        + competitionId + "|" 
                        + originEventId + "|"
                        + roundsForward + "|"
                        + roundsBackward + "|"
                        + topWidth + "|"
                        + specs.Length;

                Xom.Log(XomAreaName.wcQueryLog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );
            }


            return response;        
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Query\test\FuncQueryGetXQSConfig.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using System.IO;
using System.Xml;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web;
using ServerTestFramework.Web.Query;
using xonline.common.config;

namespace QueryWidget
{
	[TestGroup]
	public class FuncQueryGetXQSConfig : TestNode
	{
		// struct to hold input values to the GetXQSConfig method
		struct QueryGetXQSConfigParams
		{
			public System.UInt32 titleId;
			public System.Byte[] webId;
			public System.UInt64 haveVersion;
		}

		/// <summary>
		/// function that uses XML file to return valid parameters
		/// </summary>
		/// <param name="QGCP">struct to fill with parameters for call to GetXQSConfig</param>
		/// <returns>false if any errors parsing XML file, else true</returns>
		static bool GetValidParams(ref QueryGetXQSConfigParams QGCP)
		{
			XmlDocument parameters = new XmlDocument();
			parameters.Load("QueryWidget.xml");
			XmlNode paramNode;

			try
			{
				paramNode = parameters.SelectSingleNode("/stf/parameters/titleId");
				if (null == paramNode)
					throw new Exception();
				QGCP.titleId = Convert.ToUInt32(paramNode.InnerText);

				paramNode = parameters.SelectSingleNode("/stf/parameters/webId");
				if (null == paramNode)
					throw new Exception();
				QGCP.webId = BitConverter.GetBytes(Convert.ToUInt64(paramNode.InnerText));

				paramNode = parameters.SelectSingleNode("/stf/parameters/getXQSconfig/haveVersion");
				if (null == paramNode)
					throw new Exception();
				QGCP.haveVersion = Convert.ToUInt64(paramNode.InnerText);
			}
			catch (Exception)
			{
				ConsoleX.WriteLine("Invalid parameter element found in xml.");
				return false;
			}
			return true;
		}

		/// <summary>
		/// function to ensure GetXQSConfig method worked as expected
		/// </summary>
		/// <param name="result"></param>
		/// <param name="QGCP"></param>
		/// <returns></returns>
		static bool VerifyGetXQSConfig(string result, QueryGetXQSConfigParams QGCP, DateTime dtTestStart)
		{
			return result.ToLower().StartsWith("<?xml version=\"1.0\" encoding=\"utf-8\"?>");
		}

		// Positive test cases

		[TestCase, Description("QueryGetXQSConfig Valid: basic verify")]
			class Query_GetXQSConfig_Valid_Basic : TestBase
		{
			protected override void Execute()
			{
				string result = "";
				QueryGetXQSConfigParams QGCP = new QueryGetXQSConfigParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QGCP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				WCQuery wc = new WCQuery(Global.XEnv.GetVirtualInterface(VirtualInterface.wcquery),new RequestInfo("DebugAdmin"));
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					result = wc.WidgetGetXQSConfig(QGCP.titleId,QGCP.webId,QGCP.haveVersion);

					if (!VerifyGetXQSConfig(result, QGCP, dtTestStart))
						throw new Exception("Verification failed.");
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		[TestCase, Description("QueryGetXQSConfig Valid: haveVersion 0")]
			class Query_GetXQSConfig_Valid_Version_0 : TestBase
		{
			protected override void Execute()
			{
				QueryGetXQSConfigParams QGCP = new QueryGetXQSConfigParams();
				ResultCode = TEST_RESULTS.PASSED;
				string result;

				if (!GetValidParams(ref QGCP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set haveVersion
				QGCP.haveVersion = 0;

				WCQuery wc = new WCQuery(Global.XEnv.GetVirtualInterface(VirtualInterface.wcquery),new RequestInfo("DebugAdmin"));
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					result = wc.WidgetGetXQSConfig(QGCP.titleId,QGCP.webId,QGCP.haveVersion);

					if (!VerifyGetXQSConfig(result, QGCP, dtTestStart))
						throw new Exception("Verification failed.");
				}
				catch (Exception e)
				{
					ConsoleX.WriteLine(e.Message);
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		[TestCase, Description("QueryGetXQSConfig Valid: haveVersion > version in database")]
			class Query_GetXQSConfig_Valid_Version_Greater : TestBase
		{
			protected override void Execute()
			{
				QueryGetXQSConfigParams QGCP = new QueryGetXQSConfigParams();
				ResultCode = TEST_RESULTS.PASSED;
				string result;

				if (!GetValidParams(ref QGCP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set haveVersion -- test should not return XQS, but also should NOT except
				QGCP.haveVersion = 0xFFFFFFFFFFFFFF;

				WCQuery wc = new WCQuery(Global.XEnv.GetVirtualInterface(VirtualInterface.wcquery),new RequestInfo("DebugAdmin"));
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					result = wc.WidgetGetXQSConfig(QGCP.titleId,QGCP.webId,QGCP.haveVersion);

					if (result != "You have the latest version")
						ResultCode = TEST_RESULTS.FAILED;
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		[TestCase, Description("QueryGetXQSConfig Valid: haveVersion MAX_UINT64")]
			class Query_GetXQSConfig_Valid_Version_Max : TestBase
		{
			protected override void Execute()
			{
				QueryGetXQSConfigParams QGCP = new QueryGetXQSConfigParams();
				ResultCode = TEST_RESULTS.PASSED;
				string result;

				if (!GetValidParams(ref QGCP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set haveVersion -- test should succeed because MAX_UINT64 is negative when converted to INT64
				QGCP.haveVersion = UInt64.MaxValue;

				WCQuery wc = new WCQuery(Global.XEnv.GetVirtualInterface(VirtualInterface.wcquery),new RequestInfo("DebugAdmin"));
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					result = wc.WidgetGetXQSConfig(QGCP.titleId,QGCP.webId,QGCP.haveVersion);

					if (!VerifyGetXQSConfig(result, QGCP, dtTestStart))
						throw new Exception("Verification failed.");
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		// Negative test cases

		[TestCase, Description("QueryGetXQSConfig Invalid: wrong credential type")]
			class Query_GetXQSConfig_Invalid_Wrong_Credentials : TestBase
		{
			protected override void Execute()
			{
				QueryGetXQSConfigParams QGCP = new QueryGetXQSConfigParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QGCP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				WCQuery wc = new WCQuery(Global.XEnv.GetVirtualInterface(VirtualInterface.wcquery),new RequestInfo("DebugPartner"));
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetGetXQSConfig(QGCP.titleId,QGCP.webId,QGCP.haveVersion);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Partner:DebugPartner not allowed to call API:Query.GetXQSConfig"))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryGetXQSConfig Invalid: unknown titleId")]
			class Query_GetXQSConfig_Invalid_Unknown_Title : TestBase
		{
			protected override void Execute()
			{
				QueryGetXQSConfigParams QGCP = new QueryGetXQSConfigParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QGCP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set titleId
				QGCP.titleId = QueryWidgetCommon.TITLEID_NOT_EXIST;

				WCQuery wc = new WCQuery(Global.XEnv.GetVirtualInterface(VirtualInterface.wcquery),new RequestInfo("DebugAdmin"));
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetGetXQSConfig(QGCP.titleId,QGCP.webId,QGCP.haveVersion);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Partner:DebugAdmin not allowed to access TitleID:"+Hexer.tohex(QGCP.titleId)))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryGetXQSConfig Invalid: titleId MAX_UINT32")]
			class Query_GetXQSConfig_Invalid_Title_Max : TestBase
		{
			protected override void Execute()
			{
				QueryGetXQSConfigParams QGCP = new QueryGetXQSConfigParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QGCP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set titleId
				QGCP.titleId = UInt32.MaxValue;

				WCQuery wc = new WCQuery(Global.XEnv.GetVirtualInterface(VirtualInterface.wcquery),new RequestInfo("DebugAdmin"));
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetGetXQSConfig(QGCP.titleId,QGCP.webId,QGCP.haveVersion);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Partner:DebugAdmin not allowed to access TitleID:"+Hexer.tohex(QGCP.titleId)))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryGetXQSConfig Invalid: titleId doesn't support Query Service")]
			class Query_GetXQSConfig_Invalid_Title_Unsupported : TestBase
		{
			protected override void Execute()
			{
				QueryGetXQSConfigParams QGCP = new QueryGetXQSConfigParams();
				ResultCode = TEST_RESULTS.PASSED;
				string result;

				if (!GetValidParams(ref QGCP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set titleId
				QGCP.titleId = QueryWidgetCommon.TITLEID_NO_QUERY;

				WCQuery wc = new WCQuery(Global.XEnv.GetVirtualInterface(VirtualInterface.wcquery),new RequestInfo("DebugAdmin"));
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					result = wc.WidgetGetXQSConfig(QGCP.titleId,QGCP.webId,QGCP.haveVersion);
				}
				catch (Exception e)
				{
					if (-1 == e.Message.IndexOf("Error: titleid "+QGCP.titleId+" does not have an XQS configuration on XBOX Live."))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryGetXQSConfig Invalid: webId null")]
			class Query_GetXQSConfig_Invalid_WebId_Null : TestBase
		{
			protected override void Execute()
			{
				QueryGetXQSConfigParams QGCP = new QueryGetXQSConfigParams();
				ResultCode = TEST_RESULTS.PASSED;
				string result;

				if (!GetValidParams(ref QGCP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set webId
				QGCP.webId = null;

				WCQuery wc = new WCQuery(Global.XEnv.GetVirtualInterface(VirtualInterface.wcquery),new RequestInfo("DebugAdmin"));
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					result = wc.WidgetGetXQSConfig(QGCP.titleId,QGCP.webId,QGCP.haveVersion);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("No webId was specified by the caller."))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryGetXQSConfig Invalid: VERY long webId")]
			class Query_GetXQSConfig_Invalid_WebId_VERY_long : TestBase
		{
			protected override void Execute()
			{
				QueryGetXQSConfigParams QGCP = new QueryGetXQSConfigParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QGCP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				QGCP.webId = new byte[6*1048576];
				for (int i=0; i<QGCP.webId.Length; i++)
				{
					QGCP.webId[i] = (byte)(i%16);
				}

				WCQuery wc = new WCQuery(Global.XEnv.GetVirtualInterface(VirtualInterface.wcquery),new RequestInfo("DebugAdmin"));
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetGetXQSConfig(QGCP.titleId,QGCP.webId,QGCP.haveVersion);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Maximum request length exceeded."))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Query\test\FuncQuerySearch.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Threading;
using System.IO;
using System.Xml;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web;
using ServerTestFramework.Web.Query;
using xonline.common.config;

namespace QueryWidget
{
	[TestGroup]
	public class FuncQuerySearch : TestNode
	{
		// struct to hold input values to the Search method
		struct QuerySearchParams
		{
			public System.UInt32 titleId;
			public System.UInt32 datasetId;
			public System.UInt32 procIndex;
			public System.UInt32 page;
			public System.UInt32 resultsPerPage;
			public QueryAttributeSpec[] specs;
			public QueryAttribute[] attributes;
		}

		/// <summary>
		/// function that uses XML file to return valid parameters
		/// </summary>
		/// <param name="QSRP">struct to fill with parameters for call to Search</param>
		/// <param name="procSel">zero-based short to identify which procIndex to use in the xml.</param>
		/// <returns>false if any errors parsing XML file, else true</returns>
		static bool GetValidParams(ref QuerySearchParams QSRP)
		{
			return GetValidParams(ref QSRP,0);
		}

		static bool GetValidParams(ref QuerySearchParams QSRP, short procSel)
		{
			QSRP.titleId = QueryWidgetCommon.QUERY_TITLE_ID;
			QSRP.datasetId = QueryWidgetCommon.QUERY_DATASET_ID;

			XmlDocument parameters = new XmlDocument();
			parameters.Load("QueryWidget.xml");

			QSRP.page = 0;
			QSRP.resultsPerPage = 100;

			try
			{
				XmlNodeList paramNodes = parameters.SelectNodes("/stf/parameters/search/procIndex");
				if (paramNodes.Count <= procSel)
					throw new Exception();
				QSRP.procIndex = Convert.ToUInt32(paramNodes[procSel].InnerText);

				paramNodes = parameters.SelectNodes("/stf/parameters/search/specs");
				if (paramNodes.Count <= procSel)
					throw new Exception();
				QSRP.specs = new QueryAttributeSpec[paramNodes[procSel].ChildNodes.Count];
				for (int i=0; i<paramNodes[procSel].ChildNodes.Count; i++)
				{
					if (paramNodes[procSel].ChildNodes[i].Name != "attrib")
						throw new Exception();

					QSRP.specs[i] = new QueryAttributeSpec();

					QSRP.specs[i].len = Convert.ToUInt32(paramNodes[procSel].ChildNodes[i].Attributes["s_len"].Value);
					QSRP.specs[i].type = System.UInt32.Parse(paramNodes[procSel].ChildNodes[i].Attributes["s_type"].Value,System.Globalization.NumberStyles.AllowHexSpecifier);
				}

				paramNodes = parameters.SelectNodes("/stf/parameters/search/attributes");
				if (paramNodes.Count <= procSel)
					throw new Exception();
				QSRP.attributes = new QueryAttribute[paramNodes[procSel].ChildNodes.Count];
				for (int i=0; i<paramNodes[procSel].ChildNodes.Count; i++)
				{
					if (paramNodes[procSel].ChildNodes[i].Name != "attrib")
						throw new Exception();

					QSRP.attributes[i] = new QueryAttribute();

					QSRP.attributes[i].Id = System.UInt32.Parse(paramNodes[procSel].ChildNodes[i].Attributes["a_id"].Value,System.Globalization.NumberStyles.AllowHexSpecifier);
					switch (QSRP.attributes[i].Id)
					{
						case 1:
							QSRP.attributes[i].Value = (long)Convert.ToInt64(paramNodes[procSel].ChildNodes[i].Attributes["a_value"].Value);
							break;
						case 1048579:
							QSRP.attributes[i].Value = paramNodes[procSel].ChildNodes[i].Attributes["a_value"].Value;
							break;
						case 2097157:
							QSRP.attributes[i].Value = Hexer.unhex(paramNodes[procSel].ChildNodes[i].Attributes["a_value"].Value);
							break;
					}
				}
			}
			catch (Exception)
			{
				ConsoleX.WriteLine("Invalid parameter element found in xml.");
				return false;
			}
			return true;
		}

		/// <summary>
		/// function to ensure Search method worked as expected
		/// </summary>
		/// <param name="QSRP"></param>
		/// <returns></returns>
		static bool VerifySearch(SearchResponse result, QuerySearchParams QSRP, uint nPrevRecords, DateTime dtTestStart)
		{
			// REM "SELECT [bi_entity_id], [bi_owner_id], [dt_change_datetime], [att_00000001], [att_00100003], [att_00200005] FROM [QueryDB].[dbo].[t_query_dataset_0000b2d2_1]"

			bool bRet = true;

			ArrayList alSearchResults = new ArrayList();

			string sql="";
			SqlCommand mySqlCommand = null;
			SqlDataReader myDataReader = null;

			switch (QSRP.procIndex)
			{
				case 514:
					sql="SELECT bi_entity_id, att_00000001, att_00200005 FROM [QueryDB].[dbo].[t_query_dataset_"+Hexer.tohex(QSRP.titleId)+"_"+QSRP.datasetId.ToString("x")+"] WHERE att_00100003 = '"+(string)QSRP.attributes[0].Value+"' AND att_00200005 = 0x"+Hexer.tohex((byte[])QSRP.attributes[1].Value);
					break;
				case 518:
					sql="SELECT bi_entity_id, att_00000001, att_00100003, att_00200005 FROM [QueryDB].[dbo].[t_query_dataset_"+Hexer.tohex(QSRP.titleId)+"_"+QSRP.datasetId.ToString("x")+"] WHERE att_00000001 = "+((long)QSRP.attributes[0].Value).ToString()+" AND att_00100003 = '"+(string)QSRP.attributes[1].Value+"' AND att_00200005 = 0x"+Hexer.tohex((byte[])QSRP.attributes[2].Value);
					break;
				case 256:
					sql="SELECT bi_entity_id, att_00000001, att_00100003 FROM [QueryDB].[dbo].[t_query_dataset_"+Hexer.tohex(QSRP.titleId)+"_"+QSRP.datasetId.ToString("x")+"] WHERE att_00200005 = 0x"+Hexer.tohex((byte[])QSRP.attributes[0].Value);
					break;
				case 4:
					sql="SELECT bi_entity_id, att_00000001, att_00100003, att_00200005 FROM [QueryDB].[dbo].[t_query_dataset_"+Hexer.tohex(QSRP.titleId)+"_"+QSRP.datasetId.ToString("x")+"] WHERE att_00000001 = "+((long)QSRP.attributes[0].Value).ToString()+" AND att_00100003 = '"+(string)QSRP.attributes[1].Value+"'";
					break;
				default:
					return false;
			}

			for (int iSql=0; iSql<QueryWidgetCommon.qrySqlConn.Length; iSql++)
			{
				try
				{
					mySqlCommand = new SqlCommand(sql,QueryWidgetCommon.qrySqlConn[iSql]);
					myDataReader = mySqlCommand.ExecuteReader();

					if (!myDataReader.HasRows && iSql < QueryWidgetCommon.qrySqlConn.Length+1)
						continue;

					// store matching rows
					while (myDataReader.Read() != false)
					{
						object [] res = new object[QSRP.specs.Length];
						for (int j=0; j<res.Length; j++)
							res[j] = myDataReader.GetValue(j);
						alSearchResults.Add(res);
					}

					if (myDataReader != null && !myDataReader.IsClosed)
						myDataReader.Close();

					// start index of DB results to correct starting position based on page
					int dbIndex = (int)(QSRP.page*QSRP.resultsPerPage);
					if (dbIndex >= alSearchResults.Count && dbIndex > 0)
						throw new Exception("Number of results doesn't match.");

					// see if # results match expected
					if (result.attribCount != result.returnedResults * QSRP.specs.Length ||
						result.returnedResults > QSRP.resultsPerPage ||
						result.totalResults != alSearchResults.Count)
						throw new Exception("Number of results doesn't match.");

					uint i = 0;
					switch (QSRP.procIndex)
					{
						case 514:
							while (i + 2 < result.attribCount)
							{
								// compare each set of returned attributes
								if (result.attribs[i].Id == 0x80000000 &&
									(long)(((object [])alSearchResults[dbIndex])[0]) == (long)result.attribs[i++].Value &&
									result.attribs[i].Id == 1 &&
									(long)(((object [])alSearchResults[dbIndex])[1]) == (long)result.attribs[i++].Value &&
									result.attribs[i].Id == 2097157 &&
									0 == Hexer.tohex((byte[])((object [])alSearchResults[dbIndex++])[2]).CompareTo(Hexer.tohex((byte[])result.attribs[i++].Value)))
									continue;
								throw new Exception("Result values don't match.");
							}
							break;
						case 518:
							while (i + 3 < result.attribCount)
							{
								// compare each set of returned attributes
								if (result.attribs[i].Id == 0x80000000 &&
									(long)(((object [])alSearchResults[dbIndex])[0]) == (long)result.attribs[i++].Value &&
									result.attribs[i].Id == 1 &&
									(long)(((object [])alSearchResults[dbIndex])[1]) == (long)result.attribs[i++].Value &&
									result.attribs[i].Id == 1048579 &&
									0 == ((string)(((object [])alSearchResults[dbIndex])[2])).CompareTo(result.attribs[i++].Value) &&
									result.attribs[i].Id == 2097157 &&
									0 == Hexer.tohex((byte[])((object [])alSearchResults[dbIndex++])[3]).CompareTo(Hexer.tohex((byte[])result.attribs[i++].Value)))
									continue;
								throw new Exception("Result values don't match.");
							}
							break;
						case 256:
							while (i + 2 < result.attribCount)
							{
								// compare each set of returned attributes
								if (result.attribs[i].Id == 0x80000000 &&
									(long)(((object [])alSearchResults[dbIndex])[0]) == (long)result.attribs[i++].Value &&
									result.attribs[i].Id == 1 &&
									(long)(((object [])alSearchResults[dbIndex])[1]) == (long)result.attribs[i++].Value &&
									result.attribs[i].Id == 1048579 &&
									0 == ((string)(((object [])alSearchResults[dbIndex++])[2])).CompareTo(result.attribs[i++].Value))
									continue;
								throw new Exception("Result values don't match.");
							}
							break;
						case 4:
							goto case 518;
					}
					// verify same # records as before
					bRet = (nPrevRecords == QueryWidgetCommon.GetNumRecords(QSRP.titleId,QSRP.datasetId));
				}
				catch (Exception e)
				{
					ConsoleX.WriteLine("SQL error in VerifySearch(): " + e.Message);
					bRet = false;
					if (QueryWidgetCommon.qrySqlConn[iSql].State != ConnectionState.Open)
						QueryWidgetCommon.qrySqlConn[iSql].Open();
				}
				finally
				{
					// Always call Close when done reading.
					if (myDataReader != null && !myDataReader.IsClosed)
						myDataReader.Close();
				}
			}

			// verify no changes to dataset
			return bRet && QueryWidgetCommon.VerifyNoChange(QSRP.titleId,QSRP.datasetId,dtTestStart);
		}

		// Positive test cases

		[TestCase, Description("QuerySearch Valid: basic verify")]
			class Query_Search_Valid_Basic : TestBase
		{
			protected override void Execute()
			{
				SearchResponse result = null;
				QuerySearchParams QSRP = new QuerySearchParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				QueryWidgetCommon.FillDBBasedOnAPI(5,0);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QSRP.titleId,QSRP.datasetId);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					result = wc.WidgetSearch(QSRP.titleId,QSRP.datasetId,QSRP.procIndex,QSRP.page,QSRP.resultsPerPage,QSRP.specs,QSRP.attributes);

					if (!VerifySearch(result,QSRP,nRecords,dtTestStart))
						throw new Exception("Verification failed.");
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		[TestCase, Description("QuerySearch Valid: procIndex match Search proc 1")]
			class Query_Search_Valid_ProcIndex_Match_1 : TestBase
		{
			protected override void Execute()
			{
				SearchResponse result = null;
				QuerySearchParams QSRP = new QuerySearchParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSRP,1))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				QueryWidgetCommon.FillDBBasedOnAPI(5,0);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QSRP.titleId,QSRP.datasetId);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					result = wc.WidgetSearch(QSRP.titleId,QSRP.datasetId,QSRP.procIndex,QSRP.page,QSRP.resultsPerPage,QSRP.specs,QSRP.attributes);

					if (!VerifySearch(result,QSRP,nRecords,dtTestStart))
						throw new Exception("Verification failed.");
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		[TestCase, Description("QuerySearch Valid: procIndex match Search proc 2")]
			class Query_Search_Valid_ProcIndex_Match_2 : TestBase
		{
			protected override void Execute()
			{
				SearchResponse result = null;
				QuerySearchParams QSRP = new QuerySearchParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSRP,2))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				QueryWidgetCommon.FillDBBasedOnAPI(5,0);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QSRP.titleId,QSRP.datasetId);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					result = wc.WidgetSearch(QSRP.titleId,QSRP.datasetId,QSRP.procIndex,QSRP.page,QSRP.resultsPerPage,QSRP.specs,QSRP.attributes);

					if (!VerifySearch(result,QSRP,nRecords,dtTestStart))
						throw new Exception("Verification failed.");
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		[TestCase, Description("QuerySearch Valid: procIndex match Search proc 3")]
			class Query_Search_Valid_ProcIndex_Match_3 : TestBase
		{
			protected override void Execute()
			{
				SearchResponse result = null;
				QuerySearchParams QSRP = new QuerySearchParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSRP,3))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				QueryWidgetCommon.FillDBBasedOnAPI(5,0);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QSRP.titleId,QSRP.datasetId);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					result = wc.WidgetSearch(QSRP.titleId,QSRP.datasetId,QSRP.procIndex,QSRP.page,QSRP.resultsPerPage,QSRP.specs,QSRP.attributes);

					if (!VerifySearch(result,QSRP,nRecords,dtTestStart))
						throw new Exception("Verification failed.");
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		[TestCase, Description("QuerySearch Valid: page 0,1,2,3, resultsPerPage < number results")]
			class Query_Search_Valid_Page_0_1_2_3_Results_Beyond_One_Page : TestBase
		{
			protected override void Execute()
			{
				SearchResponse result = null;
				QuerySearchParams QSRP = new QuerySearchParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set resultsPerPage
				QSRP.resultsPerPage = 2;

				QueryWidgetCommon.FillDBBasedOnAPI(5,0);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QSRP.titleId,QSRP.datasetId);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart;
				try
				{
					for (QSRP.page = 0; QSRP.page < 4; QSRP.page++)
					{
						wc = new WCQuery();
						dtTestStart = QueryWidgetCommon.GetSqlServerTime();
						result = wc.WidgetSearch(QSRP.titleId,QSRP.datasetId,QSRP.procIndex,QSRP.page,QSRP.resultsPerPage,QSRP.specs,QSRP.attributes);

						if (!VerifySearch(result,QSRP,nRecords,dtTestStart))
							throw new Exception("Verification failed.");
					}
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		[TestCase, Description("QuerySearch Valid: resultsPerPage 1")]
			class Query_Search_Valid_resultsPerPage_1 : TestBase
		{
			protected override void Execute()
			{
				SearchResponse result = null;
				QuerySearchParams QSRP = new QuerySearchParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set resultsPerPage
				QSRP.resultsPerPage = 1;

				QueryWidgetCommon.FillDBBasedOnAPI(5,0);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QSRP.titleId,QSRP.datasetId);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					result = wc.WidgetSearch(QSRP.titleId,QSRP.datasetId,QSRP.procIndex,QSRP.page,QSRP.resultsPerPage,QSRP.specs,QSRP.attributes);

					if (!VerifySearch(result,QSRP,nRecords,dtTestStart))
						throw new Exception("Verification failed.");
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		[TestCase, Description("QuerySearch Valid: resultsPerPage > actual number results")]
			class Query_Search_Valid_resultsPerPage_Greater : TestBase
		{
			protected override void Execute()
			{
				SearchResponse result = null;
				QuerySearchParams QSRP = new QuerySearchParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set resultsPerPage such that its value is greater than the # matches in the dataset
				QSRP.resultsPerPage = 500;

				QueryWidgetCommon.FillDBBasedOnAPI(5,0);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QSRP.titleId,QSRP.datasetId);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					result = wc.WidgetSearch(QSRP.titleId,QSRP.datasetId,QSRP.procIndex,QSRP.page,QSRP.resultsPerPage,QSRP.specs,QSRP.attributes);

					if (!VerifySearch(result,QSRP,nRecords,dtTestStart))
						throw new Exception("Verification failed.");
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		[TestCase, Description("QuerySearch Valid: vary attribute values between paging calls")]
			class Query_Search_Valid_Vary_Attrib_Paging : TestBase
		{
			protected override void Execute()
			{
				SearchResponse result = null;
				QuerySearchParams QSRP = new QuerySearchParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set page, resultsPerPage
				QSRP.resultsPerPage = 3;

				QueryWidgetCommon.FillDBBasedOnAPI(5,0);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QSRP.titleId,QSRP.datasetId);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					result = wc.WidgetSearch(QSRP.titleId,QSRP.datasetId,QSRP.procIndex,QSRP.page,QSRP.resultsPerPage,QSRP.specs,QSRP.attributes);

					if (!VerifySearch(result,QSRP,nRecords,dtTestStart))
						throw new Exception("Verification failed.");

					// vary attributes and search again with page = 1
					QSRP.attributes[0].Value = "entry in query test dataset";
					QSRP.attributes[1].Value = Hexer.unhex("43215678");
					QSRP.page = 1;

					wc.WidgetSearch(QSRP.titleId,QSRP.datasetId,QSRP.procIndex,QSRP.page,QSRP.resultsPerPage,QSRP.specs,QSRP.attributes);

					if (!QueryWidgetCommon.VerifyNoChange(QSRP.titleId,QSRP.datasetId,dtTestStart))
						throw new Exception("Verification failed.");
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		[TestCase, Description("QuerySearch Valid: page out of range")]
			class Query_Search_Valid_Page_Out_Range : TestBase
		{
			protected override void Execute()
			{
				DateTime dtTestStart;
				QuerySearchParams QSRP = new QuerySearchParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set page
				QSRP.page = 100;
				QSRP.resultsPerPage = 5;

				QueryWidgetCommon.FillDBBasedOnAPI(5,0);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QSRP.titleId,QSRP.datasetId);
				WCQuery wc = new WCQuery();
				dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				SearchResponse result;
				try
				{
					result = wc.WidgetSearch(QSRP.titleId,QSRP.datasetId,QSRP.procIndex,QSRP.page,QSRP.resultsPerPage,QSRP.specs,QSRP.attributes);

					if (result.returnedResults != 0)
						throw new Exception("found match when shouldn't have");
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		[TestCase, Description("QuerySearch Valid: max allowed page")]
			class Query_Search_Valid_Max_Allowed_page : TestBase
		{
			protected override void Execute()
			{
				DateTime dtTestStart;
				QuerySearchParams QSRP = new QuerySearchParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set resultsPerPage
				QSRP.resultsPerPage = 1;
				QSRP.page = 255;

				QueryWidgetCommon.FillDBBasedOnAPI(5,0);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QSRP.titleId,QSRP.datasetId);
				WCQuery wc = new WCQuery();
				dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				SearchResponse result;
				try
				{
					result = wc.WidgetSearch(QSRP.titleId,QSRP.datasetId,QSRP.procIndex,QSRP.page,QSRP.resultsPerPage,QSRP.specs,QSRP.attributes);

					if (result.totalResults != 200 ||
						result.returnedResults != 0)
						throw new Exception("Verification failed.");
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		[TestCase, Description("QuerySearch Valid: max allowed resultsPerPage")]
			class Query_Search_Valid_Max_Allowed_resultsPerPage : TestBase
		{
			protected override void Execute()
			{
				DateTime dtTestStart;
				QuerySearchParams QSRP = new QuerySearchParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set resultsPerPage
				QSRP.resultsPerPage = 1024;

				QueryWidgetCommon.FillDBBasedOnAPI(5,0);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QSRP.titleId,QSRP.datasetId);
				WCQuery wc = new WCQuery();
				dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				SearchResponse result;
				try
				{
					result = wc.WidgetSearch(QSRP.titleId,QSRP.datasetId,QSRP.procIndex,QSRP.page,QSRP.resultsPerPage,QSRP.specs,QSRP.attributes);

					if (!VerifySearch(result,QSRP,nRecords,dtTestStart))
						throw new Exception("Verification failed.");
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		[TestCase, Description("QuerySearch Valid: match empty set")]
			class Query_Search_Valid_Match_Nothing : TestBase
		{
			protected override void Execute()
			{
				SearchResponse result = null;
				QuerySearchParams QSRP = new QuerySearchParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				QSRP.attributes[0].Value = "this string should not match";

				QueryWidgetCommon.FillDBBasedOnAPI(5,0);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QSRP.titleId,QSRP.datasetId);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					result = wc.WidgetSearch(QSRP.titleId,QSRP.datasetId,QSRP.procIndex,QSRP.page,QSRP.resultsPerPage,QSRP.specs,QSRP.attributes);

					if (result.totalResults != 0)
						throw new Exception("found match when shouldn't have");
					if (!VerifySearch(result,QSRP,nRecords,dtTestStart))
						throw new Exception("Verification failed.");
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		[TestCase, Description("QuerySearch Valid: match single entry")]
			class Query_Search_Valid_Match_One : TestBase
		{
			protected override void Execute()
			{
				SearchResponse result = null;
				QuerySearchParams QSRP = new QuerySearchParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// select attribs that have only one matching entry
				QSRP.attributes[0].Value = "only one entry has this string";
				QSRP.attributes[1].Value = Hexer.unhex("9898");

				QueryWidgetCommon.FillDBBasedOnAPI(5,0);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QSRP.titleId,QSRP.datasetId);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart;
				try
				{
					dtTestStart = QueryWidgetCommon.GetSqlServerTime();
					result = wc.WidgetSearch(QSRP.titleId,QSRP.datasetId,QSRP.procIndex,QSRP.page,QSRP.resultsPerPage,QSRP.specs,QSRP.attributes);

					if (!VerifySearch(result,QSRP,nRecords,dtTestStart))
						throw new Exception("Verification failed.");
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		[TestCase, Description("QuerySearch Invalid: unknown titleId")]
			class Query_Search_Invalid_Unknown_Title : TestBase
		{
			protected override void Execute()
			{
				DateTime dtTestStart;
				QuerySearchParams QSRP = new QuerySearchParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set titleId
				QSRP.titleId = QueryWidgetCommon.TITLEID_NOT_EXIST;

				QueryWidgetCommon.FillDBBasedOnAPI(5,0);
				WCQuery wc = new WCQuery();
				dtTestStart = QueryWidgetCommon.GetSqlServerTime();

				try
				{
					wc.WidgetSearch(QSRP.titleId,QSRP.datasetId,QSRP.procIndex,QSRP.page,QSRP.resultsPerPage,QSRP.specs,QSRP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Partner:DebugPartner not allowed to access TitleID:"+Hexer.tohex(QSRP.titleId)))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QuerySearch Invalid: titleId MAX_UINT32")]
			class Query_Search_Invalid_Title_Max : TestBase
		{
			protected override void Execute()
			{
				DateTime dtTestStart;
				QuerySearchParams QSRP = new QuerySearchParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set titleId
				QSRP.titleId = UInt32.MaxValue;

				QueryWidgetCommon.FillDBBasedOnAPI(5,0);
				WCQuery wc = new WCQuery();
				dtTestStart = QueryWidgetCommon.GetSqlServerTime();

				try
				{
					wc.WidgetSearch(QSRP.titleId,QSRP.datasetId,QSRP.procIndex,QSRP.page,QSRP.resultsPerPage,QSRP.specs,QSRP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Partner:DebugPartner not allowed to access TitleID:"+Hexer.tohex(QSRP.titleId)))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QuerySearch Invalid: titleId doesn't support Query Service")]
			class Query_Search_Invalid_Title_Unsupported : TestBase
		{
			protected override void Execute()
			{
				DateTime dtTestStart;
				QuerySearchParams QSRP = new QuerySearchParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set titleId
				QSRP.titleId = QueryWidgetCommon.TITLEID_NO_QUERY;

				QueryWidgetCommon.FillDBBasedOnAPI(5,0);
				WCQuery wc = new WCQuery();
				dtTestStart = QueryWidgetCommon.GetSqlServerTime();

				try
				{
					wc.WidgetSearch(QSRP.titleId,QSRP.datasetId,QSRP.procIndex,QSRP.page,QSRP.resultsPerPage,QSRP.specs,QSRP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QuerySearch Invalid: titleId doesn't support Search")]
			class Query_Search_Invalid_Search_Unsupported : TestBase
		{
			protected override void Execute()
			{
				DateTime dtTestStart;
				QuerySearchParams QSRP = new QuerySearchParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set datasetId
				QSRP.datasetId = 2;

				QueryWidgetCommon.FillDBBasedOnAPI(5,0);
				WCQuery wc = new WCQuery();
				dtTestStart = QueryWidgetCommon.GetSqlServerTime();

				try
				{
					wc.WidgetSearch(QSRP.titleId,QSRP.datasetId,QSRP.procIndex,QSRP.page,QSRP.resultsPerPage,QSRP.specs,QSRP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QSRP.titleId,QSRP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QuerySearch Invalid: datasetId 0")]
			class Query_Search_Invalid_DatasetId_0 : TestBase
		{
			protected override void Execute()
			{
				DateTime dtTestStart;
				QuerySearchParams QSRP = new QuerySearchParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set datasetId
				QSRP.datasetId = 0;

				QueryWidgetCommon.FillDBBasedOnAPI(5,0);
				WCQuery wc = new WCQuery();
				dtTestStart = QueryWidgetCommon.GetSqlServerTime();

				try
				{
					wc.WidgetSearch(QSRP.titleId,QSRP.datasetId,QSRP.procIndex,QSRP.page,QSRP.resultsPerPage,QSRP.specs,QSRP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QuerySearch Invalid: datasetId 2")]
			class Query_Search_Invalid_DatasetId_2 : TestBase
		{
			protected override void Execute()
			{
				DateTime dtTestStart;
				QuerySearchParams QSRP = new QuerySearchParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set datasetId
				QSRP.datasetId = 2;

				WCQuery wc = new WCQuery();
				dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				QueryWidgetCommon.FillDBBasedOnAPI(5,0);

				try
				{
					wc.WidgetSearch(QSRP.titleId,QSRP.datasetId,QSRP.procIndex,QSRP.page,QSRP.resultsPerPage,QSRP.specs,QSRP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;

					if (QSRP.titleId != QueryWidgetCommon.QUERY_TITLE_ID && !QueryWidgetCommon.VerifyNoChange(QSRP.titleId,QSRP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QuerySearch Invalid: datasetId 3")]
			class Query_Search_Invalid_DatasetId_3 : TestBase
		{
			protected override void Execute()
			{
				DateTime dtTestStart;
				QuerySearchParams QSRP = new QuerySearchParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set datasetId
				QSRP.datasetId = 3;

				WCQuery wc = new WCQuery();
				dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				QueryWidgetCommon.FillDBBasedOnAPI(5,0);

				try
				{
					wc.WidgetSearch(QSRP.titleId,QSRP.datasetId,QSRP.procIndex,QSRP.page,QSRP.resultsPerPage,QSRP.specs,QSRP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;

					if (QSRP.titleId != QueryWidgetCommon.QUERY_TITLE_ID && !QueryWidgetCommon.VerifyNoChange(QSRP.titleId,QSRP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QuerySearch Invalid: datasetId MAX_UINT32")]
			class Query_Search_Invalid_DatasetId_Max : TestBase
		{
			protected override void Execute()
			{
				DateTime dtTestStart;
				QuerySearchParams QSRP = new QuerySearchParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set datasetId
				QSRP.datasetId = UInt32.MaxValue;

				QueryWidgetCommon.FillDBBasedOnAPI(5,0);
				WCQuery wc = new WCQuery();
				dtTestStart = QueryWidgetCommon.GetSqlServerTime();

				try
				{
					wc.WidgetSearch(QSRP.titleId,QSRP.datasetId,QSRP.procIndex,QSRP.page,QSRP.resultsPerPage,QSRP.specs,QSRP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QuerySearch Invalid: procIndex MAX_UINT32")]
			class Query_Search_Invalid_ProcIndex_Max : TestBase
		{
			protected override void Execute()
			{
				DateTime dtTestStart;
				QuerySearchParams QSRP = new QuerySearchParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set procIndex
				QSRP.procIndex = UInt32.MaxValue;

				QueryWidgetCommon.FillDBBasedOnAPI(5,0);
				WCQuery wc = new WCQuery();
				dtTestStart = QueryWidgetCommon.GetSqlServerTime();

				try
				{
					wc.WidgetSearch(QSRP.titleId,QSRP.datasetId,QSRP.procIndex,QSRP.page,QSRP.resultsPerPage,QSRP.specs,QSRP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QSRP.titleId,QSRP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QuerySearch Invalid: procIndex off by 1")]
			class Query_Search_Invalid_ProcIndex_Off_By_One : TestBase
		{
			protected override void Execute()
			{
				DateTime dtTestStart;
				QuerySearchParams QSRP = new QuerySearchParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set procIndex
				QSRP.procIndex++;

				QueryWidgetCommon.FillDBBasedOnAPI(5,0);
				WCQuery wc = new WCQuery();
				dtTestStart = QueryWidgetCommon.GetSqlServerTime();

				try
				{
					wc.WidgetSearch(QSRP.titleId,QSRP.datasetId,QSRP.procIndex,QSRP.page,QSRP.resultsPerPage,QSRP.specs,QSRP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QSRP.titleId,QSRP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QuerySearch Invalid: attributes null")]
			class Query_Search_Invalid_Attrib_Null : TestBase
		{
			protected override void Execute()
			{
				DateTime dtTestStart;
				QuerySearchParams QSRP = new QuerySearchParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set attributes
				QSRP.attributes = null;

				QueryWidgetCommon.FillDBBasedOnAPI(5,0);
				WCQuery wc = new WCQuery();
				dtTestStart = QueryWidgetCommon.GetSqlServerTime();

				try
				{
					wc.WidgetSearch(QSRP.titleId,QSRP.datasetId,QSRP.procIndex,QSRP.page,QSRP.resultsPerPage,QSRP.specs,QSRP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Object reference not set to an instance of an object."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QSRP.titleId,QSRP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QuerySearch Invalid: too few attributes")]
			class Query_Search_Invalid_Attrib_Too_Short : TestBase
		{
			protected override void Execute()
			{
				DateTime dtTestStart;
				QuerySearchParams QSRP = new QuerySearchParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// remove attribute from end of array
				QueryAttribute [] QAtooshort = new QueryAttribute[QSRP.attributes.Length-1];
				Array.Copy(QSRP.attributes,QAtooshort,QAtooshort.Length);
				QSRP.attributes = QAtooshort;

				QueryWidgetCommon.FillDBBasedOnAPI(5,0);
				WCQuery wc = new WCQuery();
				dtTestStart = QueryWidgetCommon.GetSqlServerTime();

				try
				{
					wc.WidgetSearch(QSRP.titleId,QSRP.datasetId,QSRP.procIndex,QSRP.page,QSRP.resultsPerPage,QSRP.specs,QSRP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("An unexpected attribute passed to the method caused a database error."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QSRP.titleId,QSRP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QuerySearch Invalid: too many attributes")]
			class Query_Search_Invalid_Attrib_Too_Long : TestBase
		{
			protected override void Execute()
			{
				DateTime dtTestStart;
				QuerySearchParams QSRP = new QuerySearchParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// add valid attribute at end of array
				QueryAttribute [] QAtoolong = new QueryAttribute[QSRP.attributes.Length+1];
				QSRP.attributes.CopyTo(QAtoolong,0);
				QAtoolong[QAtoolong.Length-1] = new QueryAttribute();
				QAtoolong[QAtoolong.Length-1].Id = 1;
				QAtoolong[QAtoolong.Length-1].Value = (long)1024;
				QSRP.attributes = QAtoolong;

				QueryWidgetCommon.FillDBBasedOnAPI(5,0);
				WCQuery wc = new WCQuery();
				dtTestStart = QueryWidgetCommon.GetSqlServerTime();

				try
				{
					wc.WidgetSearch(QSRP.titleId,QSRP.datasetId,QSRP.procIndex,QSRP.page,QSRP.resultsPerPage,QSRP.specs,QSRP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("An unexpected attribute passed to the method caused a database error."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QSRP.titleId,QSRP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QuerySearch Invalid: invalid attributes")]
			class Query_Search_Invalid_Attrib_Invalid : TestBase
		{
			protected override void Execute()
			{
				DateTime dtTestStart;
				QuerySearchParams QSRP = new QuerySearchParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				foreach (QueryAttribute QA in QSRP.attributes)
				{
					// lowest 16 bits of ID represent the actual attrib ID
					// in LiveService\Comps\CompDefs, nothing more than 0x20 defined
					QA.Id += 0x100;		// this will make all IDs invalid
				}

				QueryWidgetCommon.FillDBBasedOnAPI(5,0);
				WCQuery wc = new WCQuery();
				dtTestStart = QueryWidgetCommon.GetSqlServerTime();

				try
				{
					wc.WidgetSearch(QSRP.titleId,QSRP.datasetId,QSRP.procIndex,QSRP.page,QSRP.resultsPerPage,QSRP.specs,QSRP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("An unexpected attribute passed to the method caused a database error."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QSRP.titleId,QSRP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QuerySearch Invalid: max allowed + 1 for resultsPerPage")]
			class Query_Search_Invalid_resultsPerPage_Max_Allowed_Plus_One : TestBase
		{
			protected override void Execute()
			{
				SearchResponse result = null;
				QuerySearchParams QSRP = new QuerySearchParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set resultsPerPage
				QSRP.resultsPerPage = 1025;

				QueryWidgetCommon.FillDBBasedOnAPI(5,0);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QSRP.titleId,QSRP.datasetId);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					result = wc.WidgetSearch(QSRP.titleId,QSRP.datasetId,QSRP.procIndex,QSRP.page,QSRP.resultsPerPage,QSRP.specs,QSRP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The method was called with some invalid arguments or attributes and could not be completed."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QSRP.titleId,QSRP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QuerySearch Invalid: max allowed + 1 for page")]
			class Query_Search_Invalid_Page_Max_Allowed_Plus_One : TestBase
		{
			protected override void Execute()
			{
				DateTime dtTestStart;
				QuerySearchParams QSRP = new QuerySearchParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set page
				QSRP.page = 256;

				QueryWidgetCommon.FillDBBasedOnAPI(5,0);
				WCQuery wc = new WCQuery();
				dtTestStart = QueryWidgetCommon.GetSqlServerTime();

				try
				{
					wc.WidgetSearch(QSRP.titleId,QSRP.datasetId,QSRP.procIndex,QSRP.page,QSRP.resultsPerPage,QSRP.specs,QSRP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The method was called with some invalid arguments or attributes and could not be completed."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QSRP.titleId,QSRP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QuerySearch Invalid: resultsPerPage 0")]
			class Query_Search_Invalid_resultsPerPage_0 : TestBase
		{
			protected override void Execute()
			{
				SearchResponse result = null;
				QuerySearchParams QSRP = new QuerySearchParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set resultsPerPage
				QSRP.resultsPerPage = 0;

				QueryWidgetCommon.FillDBBasedOnAPI(5,0);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QSRP.titleId,QSRP.datasetId);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					result = wc.WidgetSearch(QSRP.titleId,QSRP.datasetId,QSRP.procIndex,QSRP.page,QSRP.resultsPerPage,QSRP.specs,QSRP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The method was called with some invalid arguments or attributes and could not be completed."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QSRP.titleId,QSRP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QuerySearch Invalid: resultsPerPage MAX_UINT32")]
			class Query_Search_Invalid_resultsPerPage_Max : TestBase
		{
			protected override void Execute()
			{
				SearchResponse result = null;
				QuerySearchParams QSRP = new QuerySearchParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set resultsPerPage
				QSRP.resultsPerPage = UInt32.MaxValue;

				QueryWidgetCommon.FillDBBasedOnAPI(5,0);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QSRP.titleId,QSRP.datasetId);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					result = wc.WidgetSearch(QSRP.titleId,QSRP.datasetId,QSRP.procIndex,QSRP.page,QSRP.resultsPerPage,QSRP.specs,QSRP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The method was called with some invalid arguments or attributes and could not be completed."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QSRP.titleId,QSRP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QuerySearch Invalid: page MAX_UINT32")]
			class Query_Search_Invalid_Page_Max : TestBase
		{
			protected override void Execute()
			{
				DateTime dtTestStart;
				QuerySearchParams QSRP = new QuerySearchParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set page
				QSRP.page = UInt32.MaxValue;

				QueryWidgetCommon.FillDBBasedOnAPI(5,0);
				WCQuery wc = new WCQuery();
				dtTestStart = QueryWidgetCommon.GetSqlServerTime();

				try
				{
					wc.WidgetSearch(QSRP.titleId,QSRP.datasetId,QSRP.procIndex,QSRP.page,QSRP.resultsPerPage,QSRP.specs,QSRP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The method was called with some invalid arguments or attributes and could not be completed."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QSRP.titleId,QSRP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QuerySearch Invalid: specs mismatched with proc")]
			class Query_Search_Invalid_Specs_Mismatched : TestBase
		{
			protected override void Execute()
			{
				DateTime dtTestStart;
				QuerySearchParams QSRP = new QuerySearchParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set specs so doesn't match procIndex
				QuerySearchParams QPtemp = new QuerySearchParams();
				if (!GetValidParams(ref QPtemp, 2))
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				QSRP.specs = QPtemp.specs;

				QueryWidgetCommon.FillDBBasedOnAPI(5,0);
				WCQuery wc = new WCQuery();
				dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				SearchResponse result;
				try
				{
					result = wc.WidgetSearch(QSRP.titleId,QSRP.datasetId,QSRP.procIndex,QSRP.page,QSRP.resultsPerPage,QSRP.specs,QSRP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("An unexpected attribute passed to the method caused a database error."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QSRP.titleId,QSRP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QuerySearch Invalid: too few specs")]
			class Query_Search_Invalid_Specs_Too_Few : TestBase
		{
			protected override void Execute()
			{
				DateTime dtTestStart;
				QuerySearchParams QSRP = new QuerySearchParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// remove attribute from end of array
				QueryAttributeSpec [] QAStooshort = new QueryAttributeSpec[QSRP.specs.Length-1];
				for (int i=0; i<QAStooshort.Length; i++)
					QAStooshort[i] = QSRP.specs[i];
				QSRP.specs = QAStooshort;

				QueryWidgetCommon.FillDBBasedOnAPI(5,0);
				WCQuery wc = new WCQuery();
				dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				SearchResponse result;
				try
				{
					result = wc.WidgetSearch(QSRP.titleId,QSRP.datasetId,QSRP.procIndex,QSRP.page,QSRP.resultsPerPage,QSRP.specs,QSRP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The provided number of QUERY_ATTRIBUTE_SPECs doesn't match the number returned by the procedure."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QSRP.titleId,QSRP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QuerySearch Invalid: too many specs")]
			class Query_Search_Invalid_Specs_Too_Many : TestBase
		{
			protected override void Execute()
			{
				DateTime dtTestStart;
				QuerySearchParams QSRP = new QuerySearchParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// add valid spec at end of array
				QueryAttributeSpec [] QAStoolong = new QueryAttributeSpec[QSRP.specs.Length+1];
				QSRP.specs.CopyTo(QAStoolong,0);
				QAStoolong[QAStoolong.Length-1] = new QueryAttributeSpec();
				QAStoolong[QAStoolong.Length-1].len = 400;
				QAStoolong[QAStoolong.Length-1].type = 1048579;
				QSRP.specs = QAStoolong;

				QueryWidgetCommon.FillDBBasedOnAPI(5,0);
				WCQuery wc = new WCQuery();
				dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				SearchResponse result;
				try
				{
					result = wc.WidgetSearch(QSRP.titleId,QSRP.datasetId,QSRP.procIndex,QSRP.page,QSRP.resultsPerPage,QSRP.specs,QSRP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The provided number of QUERY_ATTRIBUTE_SPECs doesn't match the number returned by the procedure."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QSRP.titleId,QSRP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QuerySearch Invalid: null specs")]
			class Query_Search_Invalid_Specs_Null : TestBase
		{
			protected override void Execute()
			{
				DateTime dtTestStart;
				QuerySearchParams QSRP = new QuerySearchParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set specs
				QSRP.specs = null;

				QueryWidgetCommon.FillDBBasedOnAPI(5,0);
				WCQuery wc = new WCQuery();
				dtTestStart = QueryWidgetCommon.GetSqlServerTime();

				try
				{
					wc.WidgetSearch(QSRP.titleId,QSRP.datasetId,QSRP.procIndex,QSRP.page,QSRP.resultsPerPage,QSRP.specs,QSRP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Object reference not set to an instance of an object."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QSRP.titleId,QSRP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Query\test\FuncQuerySelect.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Threading;
using System.IO;
using System.Xml;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web;
using ServerTestFramework.Web.Query;
using xonline.common.config;

namespace QueryWidget
{
	[TestGroup]
	public class FuncQuerySelect : TestNode
	{
		// struct to hold input values to the Select method
		struct QuerySelectParams
		{
			public System.UInt32 titleId;
			public System.Byte[] webId;
			public string gamerTag;
			public string teamName;
			public System.UInt32 datasetId;
			public System.UInt64 entityId;
			public System.UInt32 action;
			public QueryAttribute[] attributes;
		}

		/// <summary>
		/// function that uses XML file to return valid parameters
		/// </summary>
		/// <param name="QSLP">struct to fill with parameters for call to Select</param>
		/// <param name="actionSel">zero-based short to identify which action to use in the xml.</param>
		/// <returns>false if any errors parsing XML file, else true</returns>
		static bool GetValidParams(ref QuerySelectParams QSLP)
		{
			return GetValidParams(ref QSLP,0);
		}

		static bool GetValidParams(ref QuerySelectParams QSLP, short actionSel)
		{
			QSLP.titleId = QueryWidgetCommon.COMPS_TITLE_ID;
			QSLP.datasetId = QueryWidgetCommon.COMPS_DATASET_ID;
			QSLP.gamerTag = QueryWidgetCommon.COMPS_GAMERTAG;
			QSLP.webId = QueryWidgetCommon.COMPS_WEBID;
			QSLP.teamName = QueryWidgetCommon.COMPS_TEAMNAME;

			XmlDocument parameters = new XmlDocument();
			parameters.Load("QueryWidget.xml");

			try
			{
				XmlNodeList paramNodes = parameters.SelectNodes("/stf/competitions/select/action");
				if (paramNodes.Count <= actionSel)
					throw new Exception();
				QSLP.action = Convert.ToUInt32(paramNodes[actionSel].InnerText);

				paramNodes = parameters.SelectNodes("/stf/competitions/select/attributes");
				if (paramNodes.Count <= actionSel)
					throw new Exception();
				if (paramNodes[actionSel].ChildNodes.Count > 0)
				{
					QSLP.attributes = new QueryAttribute[paramNodes[actionSel].ChildNodes.Count];
					for (int i=0; i<paramNodes[actionSel].ChildNodes.Count; i++)
					{
						if (paramNodes[actionSel].ChildNodes[i].Name != "attrib")
							throw new Exception();

						QSLP.attributes[i] = new QueryAttribute();

						QSLP.attributes[i].Id = System.UInt32.Parse(paramNodes[actionSel].ChildNodes[i].Attributes["a_id"].Value,System.Globalization.NumberStyles.AllowHexSpecifier);
						if (QSLP.attributes[i].Id == 0x00130002)
							QSLP.attributes[i].Value = paramNodes[actionSel].ChildNodes[i].Attributes["a_value"].Value;
						else if (QSLP.attributes[i].Id == 0x00230003)
							QSLP.attributes[i].Value = Hexer.unhex(paramNodes[actionSel].ChildNodes[i].Attributes["a_value"].Value);
						else
							QSLP.attributes[i].Value = (long)Convert.ToInt64(paramNodes[actionSel].ChildNodes[i].Attributes["a_value"].Value);
					}
				}
				else
					QSLP.attributes = null;
			}
			catch (Exception)
			{
				ConsoleX.WriteLine("Invalid parameter element found in xml.");
				return false;
			}
			return true;
		}

		static bool GetEntityId(ref QuerySelectParams QSLP)
		{
			// REM "SELECT [bi_entity_id], [bi_owner_id], [dt_change_datetime], [att_80010001], [att_80010002], [att_80010003], [att_80010004], [att_80010005], [att_80010006], [att_80010007], [att_8001000c], [att_8001000d], [att_80010010], [att_80010011], [att_80010012], [att_80010013], [att_80010014], [att_8001001a], [att_8011000e], [att_80010008], [att_80010009], [att_8001000a], [att_8001000b], [att_80010018], [att_80010019], [att_8001001d], [att_80010020], [att_80010021], [att_80010022], [att_8011001e], [att_8011001f], [att_00010001], [att_00110002], [att_00210003] FROM [QueryDB].[dbo].[t_query_dataset_0000c3b0_1]"

			QueryWidgetCommon.FillDBBasedOnAPI(8,0);
			bool bRet = true;

			Int64 ownerId = (long)QueryWidgetCommon.COMPS_TEAMID;
			if (QSLP.teamName == null || QSLP.teamName == "")
				ownerId = 2814749767106559 - Convert.ToInt32(QSLP.gamerTag.Substring(7));

			SqlCommand mySqlCommand = null;
			SqlDataReader myDataReader = null;

			for (int iSql=0; iSql<QueryWidgetCommon.qrySqlConn.Length; iSql++)
			{
				try
				{
					string sql="SELECT [bi_entity_id] FROM [QueryDB].[dbo].[t_query_dataset_"+Hexer.tohex(QSLP.titleId)+"_"+QSLP.datasetId.ToString("x")+"] WHERE att_8001001d = 0 AND att_00010001 = 77000 AND bi_owner_id = "+ownerId;
					mySqlCommand = new SqlCommand(sql,QueryWidgetCommon.qrySqlConn[iSql]);
					myDataReader = mySqlCommand.ExecuteReader();

					if (!myDataReader.HasRows && iSql < QueryWidgetCommon.qrySqlConn.Length+1)
						continue;

					// get entityId for QSLP
					if (myDataReader.Read() != false)
						QSLP.entityId = Convert.ToUInt64(myDataReader.GetInt64(0));

					if (myDataReader != null && !myDataReader.IsClosed)
						myDataReader.Close();

					if (0 == QSLP.entityId)
						throw new Exception("entityId = 0");

				}
				catch (Exception e)
				{
					ConsoleX.WriteLine("SQL error in GetEntityId(): " + e.Message);
					bRet = false;
					if (QueryWidgetCommon.qrySqlConn[iSql].State != ConnectionState.Open)
						QueryWidgetCommon.qrySqlConn[iSql].Open();
				}
				finally
				{
					// Always call Close when done reading.
					if (myDataReader != null && !myDataReader.IsClosed)
						myDataReader.Close();
				}
			}

			return bRet;
		}

		// Positive test cases

		[TestCase, Description("QuerySelect Valid: basic verify")]
			public class Query_Select_Valid_Basic : TestBase
		{
			protected override void Execute()
			{
				QuerySelectParams QSLP = new QuerySelectParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSLP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				if (!GetEntityId(ref QSLP))
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetSelect(QSLP.titleId,QSLP.webId,QSLP.gamerTag,QSLP.teamName,QSLP.datasetId,QSLP.entityId,QSLP.action,QSLP.attributes);

					if (!QueryWidgetCommon.VerifyNoChange(QSLP.titleId,QSLP.datasetId,dtTestStart))
						throw new Exception("Verification failed.");
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		[TestCase, Description("QuerySelect Valid: basic verify - Partner Comp")]
			public class Query_Select_Valid_Basic_Partner_Comp : TestBase
		{
			protected override void Execute()
			{
				QuerySelectParams QSLP = new QuerySelectParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSLP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				QSLP.gamerTag = null;
				QSLP.teamName = null;
				QSLP.webId = BitConverter.GetBytes(QSLP.titleId);
				QSLP.action = 99;	// warp
				QSLP.attributes = new QueryAttribute[1];
				QSLP.attributes[0] = new QueryAttribute();
				QSLP.attributes[0].Id = 0x80010023;
				QSLP.attributes[0].Value = (long)100;

				RequestInfo rInfo = new RequestInfo("DebugAdmin");
				WCQuery wc = new WCQuery(Global.XEnv.GetVirtualInterface(VirtualInterface.wcquery),rInfo);
				try
				{
					// get comp to select
					QueryAttribute [] attribs = new QueryAttribute[3];
					for (int i=0; i<3; i++)
						attribs[i] = new QueryAttribute();
					attribs[0].Id = 0x00010001;	// map (int)
					attribs[1].Id = 0x00110002;	// name (string)
					attribs[2].Id = 0x00210003;	// icon (blob)
					attribs[0].Value = (long)2;
					attribs[1].Value = "partner comps test";
					attribs[2].Value = Hexer.unhex("BAD");
					QSLP.entityId = wc.WidgetCompetitionCreateSingleElimination(QSLP.titleId,QSLP.webId,QSLP.gamerTag,QSLP.teamName,QSLP.datasetId,200,200,10,
						DateTime.Now,DateTime.Now.AddMinutes(5),DateTime.Now.AddMinutes(6),DateTime.Now.AddMinutes(7),DateTime.Now.AddMinutes(12),0,6,2,false,
						0,attribs);

					Thread.Sleep(2000);
					DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();

					wc.WidgetSelect(QSLP.titleId,QSLP.webId,QSLP.gamerTag,QSLP.teamName,QSLP.datasetId,QSLP.entityId,QSLP.action,QSLP.attributes);

					if (!QueryWidgetCommon.VerifyNoChange(QSLP.titleId,QSLP.datasetId,dtTestStart))
						throw new Exception("Verification failed.");
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		[TestCase, Description("QuerySelect Valid: teamName null")]
			public class Query_Select_Valid_teamName_Null : TestBase
		{
			protected override void Execute()
			{
				QuerySelectParams QSLP = new QuerySelectParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSLP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set teamName
				QSLP.teamName = null;

				if (!GetEntityId(ref QSLP))
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetSelect(QSLP.titleId,QSLP.webId,QSLP.gamerTag,QSLP.teamName,QSLP.datasetId,QSLP.entityId,QSLP.action,QSLP.attributes);

					if (!QueryWidgetCommon.VerifyNoChange(QSLP.titleId,QSLP.datasetId,dtTestStart))
						throw new Exception("Verification failed.");
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		[TestCase, Description("QuerySelect Valid: teamName empty")]
			public class Query_Select_Valid_teamName_Empty : TestBase
		{
			protected override void Execute()
			{
				QuerySelectParams QSLP = new QuerySelectParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSLP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set teamName
				QSLP.teamName = "";

				if (!GetEntityId(ref QSLP))
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetSelect(QSLP.titleId,QSLP.webId,QSLP.gamerTag,QSLP.teamName,QSLP.datasetId,QSLP.entityId,QSLP.action,QSLP.attributes);

					if (!QueryWidgetCommon.VerifyNoChange(QSLP.titleId,QSLP.datasetId,dtTestStart))
						throw new Exception("Verification failed.");
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		[TestCase, Description("QuerySelect Valid: teamName padded with spaces")]
			public class Query_Select_Valid_TeamName_Padded : TestBase
		{
			protected override void Execute()
			{
				QuerySelectParams QSLP = new QuerySelectParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSLP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				if (!GetEntityId(ref QSLP))
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				QSLP.teamName += " ";

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					// try teamName padded at end
					wc.WidgetSelect(QSLP.titleId,QSLP.webId,QSLP.gamerTag,QSLP.teamName,QSLP.datasetId,QSLP.entityId,QSLP.action,QSLP.attributes);
					if (!QueryWidgetCommon.VerifyNoChange(QSLP.titleId,QSLP.datasetId,dtTestStart))
						throw new Exception("Verification failed.");

					// try teamName padded at beginning
					if (!GetEntityId(ref QSLP))
					{
						ResultCode = TEST_RESULTS.FAILED;
						return;
					}
					QSLP.teamName = " " + QSLP.teamName.Trim();
					dtTestStart = QueryWidgetCommon.GetSqlServerTime();
					wc.WidgetSelect(QSLP.titleId,QSLP.webId,QSLP.gamerTag,QSLP.teamName,QSLP.datasetId,QSLP.entityId,QSLP.action,QSLP.attributes);
					if (!QueryWidgetCommon.VerifyNoChange(QSLP.titleId,QSLP.datasetId,dtTestStart))
						throw new Exception("Verification failed.");
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		[TestCase, Description("QuerySelect Valid: action that takes no attributes")]
			public class Query_Select_Valid_Action_Null_Attribs : TestBase
		{
			protected override void Execute()
			{
				QuerySelectParams QSLP = new QuerySelectParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSLP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				if (!GetEntityId(ref QSLP))
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set attrib to null (acceptable for JOIN action)
				QSLP.attributes = null;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetSelect(QSLP.titleId,QSLP.webId,QSLP.gamerTag,QSLP.teamName,QSLP.datasetId,QSLP.entityId,QSLP.action,QSLP.attributes);

					if (!QueryWidgetCommon.VerifyNoChange(QSLP.titleId,QSLP.datasetId,dtTestStart))
						throw new Exception("Verification failed.");
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		// Negative test cases

		[TestCase, Description("QuerySelect Invalid: partner with read-only access")]
			public class Query_Select_Invalid_ReadOnly_Partner : TestBase
		{
			protected override void Execute()
			{
				QuerySelectParams QSLP = new QuerySelectParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSLP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				if (!GetEntityId(ref QSLP))
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				WCQuery wc = new WCQuery(Global.XEnv.GetVirtualInterface(VirtualInterface.wcquery), new RequestInfo("asschw"));
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetSelect(QSLP.titleId,QSLP.webId,QSLP.gamerTag,QSLP.teamName,QSLP.datasetId,QSLP.entityId,QSLP.action,QSLP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Partner:asschw not allowed to access TitleID:"+Hexer.tohex(QSLP.titleId)))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QuerySelect Invalid: unknown titleId")]
			public class Query_Select_Invalid_Unknown_Title : TestBase
		{
			protected override void Execute()
			{
				QuerySelectParams QSLP = new QuerySelectParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSLP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				if (!GetEntityId(ref QSLP))
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set titleId
				QSLP.titleId = QueryWidgetCommon.TITLEID_NOT_EXIST;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetSelect(QSLP.titleId,QSLP.webId,QSLP.gamerTag,QSLP.teamName,QSLP.datasetId,QSLP.entityId,QSLP.action,QSLP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Partner:DebugPartner not allowed to access TitleID:"+Hexer.tohex(QSLP.titleId)))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QuerySelect Invalid: titleId MAX_UINT32")]
			public class Query_Select_Invalid_Title_Max : TestBase
		{
			protected override void Execute()
			{
				QuerySelectParams QSLP = new QuerySelectParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSLP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				if (!GetEntityId(ref QSLP))
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				// set titleId
				QSLP.titleId = UInt32.MaxValue;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetSelect(QSLP.titleId,QSLP.webId,QSLP.gamerTag,QSLP.teamName,QSLP.datasetId,QSLP.entityId,QSLP.action,QSLP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Partner:DebugPartner not allowed to access TitleID:"+Hexer.tohex(QSLP.titleId)))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QuerySelect Invalid: titleId doesn't support Query Service")]
			public class Query_Select_Invalid_Title_Unsupported : TestBase
		{
			protected override void Execute()
			{
				QuerySelectParams QSLP = new QuerySelectParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSLP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				if (!GetEntityId(ref QSLP))
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				// set titleId
				QSLP.titleId = QueryWidgetCommon.TITLEID_NO_QUERY;
				QSLP.teamName = "";

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetSelect(QSLP.titleId,QSLP.webId,QSLP.gamerTag,QSLP.teamName,QSLP.datasetId,QSLP.entityId,QSLP.action,QSLP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QuerySelect Invalid: titleId doesn't support Select")]
			public class Query_Select_Invalid_Select_Unsupported : TestBase
		{
			protected override void Execute()
			{
				QuerySelectParams QSLP = new QuerySelectParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSLP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				if (!GetEntityId(ref QSLP))
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				// set datasetId
				QSLP.datasetId = 2;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetSelect(QSLP.titleId,QSLP.webId,QSLP.gamerTag,QSLP.teamName,QSLP.datasetId,QSLP.entityId,QSLP.action,QSLP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QSLP.titleId,QSLP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QuerySelect Invalid: webId null")]
			public class Query_Select_Invalid_WebId_Null : TestBase
		{
			protected override void Execute()
			{
				QuerySelectParams QSLP = new QuerySelectParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSLP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				if (!GetEntityId(ref QSLP))
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				// set webId
				QSLP.webId = null;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetSelect(QSLP.titleId,QSLP.webId,QSLP.gamerTag,QSLP.teamName,QSLP.datasetId,QSLP.entityId,QSLP.action,QSLP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Bad Passport web ID, null not allowed"))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QSLP.titleId,QSLP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QuerySelect Invalid: webId doesn't exist")]
			public class Query_Select_Invalid_WebId_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				QuerySelectParams QSLP = new QuerySelectParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSLP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				if (!GetEntityId(ref QSLP))
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				// set webId
				QSLP.webId = QueryWidgetCommon.WEBID_NOT_EXIST;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetSelect(QSLP.titleId,QSLP.webId,QSLP.gamerTag,QSLP.teamName,QSLP.datasetId,QSLP.entityId,QSLP.action,QSLP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("(webID,GamerTag) pair ("+Hexer.tohex(QSLP.webId,true)+","+QSLP.gamerTag+") is not linked in our system"))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QSLP.titleId,QSLP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QuerySelect Invalid: webId/gamerTag mismatch")]
			public class Query_Select_Invalid_WebId_GamerTag_Mismatch : TestBase
		{
			protected override void Execute()
			{
				QuerySelectParams QSLP = new QuerySelectParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSLP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				if (!GetEntityId(ref QSLP))
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				// set webId
				QSLP.webId = QueryWidgetCommon.WEBID_NO_MATCH;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetSelect(QSLP.titleId,QSLP.webId,QSLP.gamerTag,QSLP.teamName,QSLP.datasetId,QSLP.entityId,QSLP.action,QSLP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("(webID,GamerTag) pair ("+Hexer.tohex(QSLP.webId,true)+","+QSLP.gamerTag+") is not linked in our system"))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QSLP.titleId,QSLP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QuerySelect Invalid: webId too short")]
			public class Query_Select_Invalid_WebId_Too_Short : TestBase
		{
			protected override void Execute()
			{
				QuerySelectParams QSLP = new QuerySelectParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSLP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				if (!GetEntityId(ref QSLP))
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				// set webId
				QSLP.webId = QueryWidgetCommon.WEBID_TOO_SHORT;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetSelect(QSLP.titleId,QSLP.webId,QSLP.gamerTag,QSLP.teamName,QSLP.datasetId,QSLP.entityId,QSLP.action,QSLP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Bad Passport web ID, length is "+QSLP.webId.Length.ToString()))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QSLP.titleId,QSLP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QuerySelect Invalid: webId too long")]
			public class Query_Select_Invalid_WebId_Too_Long : TestBase
		{
			protected override void Execute()
			{
				QuerySelectParams QSLP = new QuerySelectParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSLP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				if (!GetEntityId(ref QSLP))
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				// set webId
				QSLP.webId = QueryWidgetCommon.WEBID_TOO_LONG;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetSelect(QSLP.titleId,QSLP.webId,QSLP.gamerTag,QSLP.teamName,QSLP.datasetId,QSLP.entityId,QSLP.action,QSLP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Bad Passport web ID, length is "+QSLP.webId.Length.ToString()))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QSLP.titleId,QSLP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QuerySelect Invalid: VERY long webId")]
			public class Query_Select_Invalid_WebId_VERY_long : TestBase
		{
			protected override void Execute()
			{
				QuerySelectParams QSLP = new QuerySelectParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSLP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				if (!GetEntityId(ref QSLP))
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				// set webId
				QSLP.webId = new byte[999999];
				for (int i=0; i<999999; i++)
				{
					QSLP.webId[i] = (byte)(i%16);
				}

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetSelect(QSLP.titleId,QSLP.webId,QSLP.gamerTag,QSLP.teamName,QSLP.datasetId,QSLP.entityId,QSLP.action,QSLP.attributes);
				}
				catch (Exception e)
				{
                    if (!e.Message.EndsWith("Bad Passport web ID, length is 999999"))
                    {
                        Global.RO.Info("expected bad passport exception, got: " + e.Message);
                        ResultCode = TEST_RESULTS.FAILED;
                    }

					if (!QueryWidgetCommon.VerifyNoChange(QSLP.titleId,QSLP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QuerySelect Invalid: gamerTag null")]
			public class Query_Select_Invalid_GamerTag_Null : TestBase
		{
			protected override void Execute()
			{
				QuerySelectParams QSLP = new QuerySelectParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSLP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				if (!GetEntityId(ref QSLP))
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				// set gamerTag
				QSLP.gamerTag = null;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetSelect(QSLP.titleId,QSLP.webId,QSLP.gamerTag,QSLP.teamName,QSLP.datasetId,QSLP.entityId,QSLP.action,QSLP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Bad GamerTag provided, null not allowed"))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QSLP.titleId,QSLP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QuerySelect Invalid: gamerTag empty string")]
			public class Query_Select_Invalid_GamerTag_Empty : TestBase
		{
			protected override void Execute()
			{
				QuerySelectParams QSLP = new QuerySelectParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSLP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				if (!GetEntityId(ref QSLP))
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				// set gamerTag
				QSLP.gamerTag = "";

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetSelect(QSLP.titleId,QSLP.webId,QSLP.gamerTag,QSLP.teamName,QSLP.datasetId,QSLP.entityId,QSLP.action,QSLP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("(webID,GamerTag) pair ("+Hexer.tohex(QSLP.webId,true)+","+QSLP.gamerTag+") is not linked in our system"))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QSLP.titleId,QSLP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QuerySelect Invalid: gamerTag padded with spaces")]
			public class Query_Select_Invalid_GamerTag_Padded : TestBase
		{
			protected override void Execute()
			{
				QuerySelectParams QSLP = new QuerySelectParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSLP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				if (!GetEntityId(ref QSLP))
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				// pad gamerTag with space at end
				QSLP.gamerTag += " ";

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					// try gamerTag padded at end
					wc.WidgetSelect(QSLP.titleId,QSLP.webId,QSLP.gamerTag,QSLP.teamName,QSLP.datasetId,QSLP.entityId,QSLP.action,QSLP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("(webID,GamerTag) pair ("+Hexer.tohex(QSLP.webId,true)+","+QSLP.gamerTag+") is not linked in our system"))
					{
						ResultCode = TEST_RESULTS.FAILED;
						return;
					}

					if (!QueryWidgetCommon.VerifyNoChange(QSLP.titleId,QSLP.datasetId,dtTestStart))
					{
						ResultCode = TEST_RESULTS.FAILED;
						return;
					}

					try
					{
						// try gamerTag padded at beginning
						QSLP.gamerTag = " " + QSLP.gamerTag.Trim();
						wc.WidgetSelect(QSLP.titleId,QSLP.webId,QSLP.gamerTag,QSLP.teamName,QSLP.datasetId,QSLP.entityId,QSLP.action,QSLP.attributes);
					}
					catch (Exception ex)
					{
						if (!ex.Message.EndsWith("(webID,GamerTag) pair ("+Hexer.tohex(QSLP.webId,true)+","+QSLP.gamerTag+") is not linked in our system"))
							ResultCode = TEST_RESULTS.FAILED;

						if (!QueryWidgetCommon.VerifyNoChange(QSLP.titleId,QSLP.datasetId,dtTestStart))
							ResultCode = TEST_RESULTS.FAILED;
						return;
					}
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QuerySelect Invalid: gamerTag too long")]
			public class Query_Select_Invalid_GamerTag_Too_Long : TestBase
		{
			protected override void Execute()
			{
				QuerySelectParams QSLP = new QuerySelectParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSLP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				if (!GetEntityId(ref QSLP))
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				// set gamerTag
				QSLP.gamerTag = QueryWidgetCommon.GAMERTAG_TOO_LONG;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetSelect(QSLP.titleId,QSLP.webId,QSLP.gamerTag,QSLP.teamName,QSLP.datasetId,QSLP.entityId,QSLP.action,QSLP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("(webID,GamerTag) pair ("+Hexer.tohex(QSLP.webId,true)+","+QSLP.gamerTag+") is not linked in our system"))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QSLP.titleId,QSLP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}


		[TestCase, Description("QuerySelect Invalid: user/team mismatch")]
			public class Query_Select_Invalid_User_Team_Mismatch : TestBase
		{
			protected override void Execute()
			{
				QuerySelectParams QSLP = new QuerySelectParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSLP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				if (!GetEntityId(ref QSLP))
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				// set teamName
				QSLP.teamName = QueryWidgetCommon.TEAMNAME_NO_MATCH;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetSelect(QSLP.titleId,QSLP.webId,QSLP.gamerTag,QSLP.teamName,QSLP.datasetId,QSLP.entityId,QSLP.action,QSLP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("User "+QSLP.gamerTag+" could not be validated as a member of team "+QSLP.teamName+" in title "+Hexer.tohex(QSLP.titleId).ToLower()))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QSLP.titleId,QSLP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QuerySelect Invalid: teamName doesn't exist")]
			public class Query_Select_Invalid_teamName_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				QuerySelectParams QSLP = new QuerySelectParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSLP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				if (!GetEntityId(ref QSLP))
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				// set teamName
				QSLP.teamName = QueryWidgetCommon.TEAMNAME_NOT_EXIST;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetSelect(QSLP.titleId,QSLP.webId,QSLP.gamerTag,QSLP.teamName,QSLP.datasetId,QSLP.entityId,QSLP.action,QSLP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Team "+QSLP.teamName+" could not be found in the team cache for titleId "+Hexer.tohex(QSLP.titleId).ToLower()+" aborting."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QSLP.titleId,QSLP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QuerySelect Invalid: teamName too long")]
			public class Query_Select_Invalid_TeamName_Too_Long : TestBase
		{
			protected override void Execute()
			{
				QuerySelectParams QSLP = new QuerySelectParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSLP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				if (!GetEntityId(ref QSLP))
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				// set teamName
				QSLP.teamName = QueryWidgetCommon.TEAMNAME_TOO_LONG;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetSelect(QSLP.titleId,QSLP.webId,QSLP.gamerTag,QSLP.teamName,QSLP.datasetId,QSLP.entityId,QSLP.action,QSLP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Team "+QSLP.teamName+" could not be found in the team cache for titleId "+Hexer.tohex(QSLP.titleId).ToLower()+" aborting."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QSLP.titleId,QSLP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QuerySelect Invalid: datasetId 0")]
			public class Query_Select_Invalid_DatasetId_0 : TestBase
		{
			protected override void Execute()
			{
				QuerySelectParams QSLP = new QuerySelectParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSLP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				if (!GetEntityId(ref QSLP))
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				// set datasetId
				QSLP.datasetId = 0;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetSelect(QSLP.titleId,QSLP.webId,QSLP.gamerTag,QSLP.teamName,QSLP.datasetId,QSLP.entityId,QSLP.action,QSLP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QuerySelect Invalid: datasetId 2")]
			public class Query_Select_Invalid_DatasetId_2 : TestBase
		{
			protected override void Execute()
			{
				QuerySelectParams QSLP = new QuerySelectParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSLP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				if (!GetEntityId(ref QSLP))
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				// set datasetId
				QSLP.datasetId = 2;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetSelect(QSLP.titleId,QSLP.webId,QSLP.gamerTag,QSLP.teamName,QSLP.datasetId,QSLP.entityId,QSLP.action,QSLP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;

					if (QSLP.titleId != QueryWidgetCommon.QUERY_TITLE_ID && !QueryWidgetCommon.VerifyNoChange(QSLP.titleId,QSLP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QuerySelect Invalid: datasetId 3")]
			public class Query_Select_Invalid_DatasetId_3 : TestBase
		{
			protected override void Execute()
			{
				QuerySelectParams QSLP = new QuerySelectParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSLP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				if (!GetEntityId(ref QSLP))
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				// set datasetId
				QSLP.datasetId = 3;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetSelect(QSLP.titleId,QSLP.webId,QSLP.gamerTag,QSLP.teamName,QSLP.datasetId,QSLP.entityId,QSLP.action,QSLP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;

					if (QSLP.titleId != QueryWidgetCommon.QUERY_TITLE_ID && !QueryWidgetCommon.VerifyNoChange(QSLP.titleId,QSLP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QuerySelect Invalid: datasetId MAX_UINT32")]
			public class Query_Select_Invalid_DatasetId_Max : TestBase
		{
			protected override void Execute()
			{
				QuerySelectParams QSLP = new QuerySelectParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSLP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				if (!GetEntityId(ref QSLP))
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				// set datasetId
				QSLP.datasetId = UInt32.MaxValue;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetSelect(QSLP.titleId,QSLP.webId,QSLP.gamerTag,QSLP.teamName,QSLP.datasetId,QSLP.entityId,QSLP.action,QSLP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QuerySelect Invalid: entityId doesn't exist")]
			public class Query_Select_Invalid_EntityId_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				QuerySelectParams QSLP = new QuerySelectParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSLP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				QueryWidgetCommon.FillDBBasedOnAPI(8,0);
				// set entityId
				QSLP.entityId = 100;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetSelect(QSLP.titleId,QSLP.webId,QSLP.gamerTag,QSLP.teamName,QSLP.datasetId,QSLP.entityId,QSLP.action,QSLP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The competition has been cancelled, and the operation is invalid."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QSLP.titleId,QSLP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QuerySelect Invalid: entityId 0")]
			public class Query_Select_Invalid_EntityId_0 : TestBase
		{
			protected override void Execute()
			{
				QuerySelectParams QSLP = new QuerySelectParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSLP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set entityId
				QSLP.entityId = 0;

				QueryWidgetCommon.FillDBBasedOnAPI(8,0);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetSelect(QSLP.titleId,QSLP.webId,QSLP.gamerTag,QSLP.teamName,QSLP.datasetId,QSLP.entityId,QSLP.action,QSLP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The competition has been cancelled, and the operation is invalid."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QSLP.titleId,QSLP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QuerySelect Invalid: entityId MAX_UINT64")]
			public class Query_Select_Invalid_EntityId_Max : TestBase
		{
			protected override void Execute()
			{
				QuerySelectParams QSLP = new QuerySelectParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSLP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set entityId
				QSLP.entityId = UInt64.MaxValue;

				QueryWidgetCommon.FillDBBasedOnAPI(8,0);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetSelect(QSLP.titleId,QSLP.webId,QSLP.gamerTag,QSLP.teamName,QSLP.datasetId,QSLP.entityId,QSLP.action,QSLP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The competition has been cancelled, and the operation is invalid."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QSLP.titleId,QSLP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QuerySelect Invalid: attributes null")]
			public class Query_Select_Invalid_Attrib_Null : TestBase
		{
			protected override void Execute()
			{
				QuerySelectParams QSLP = new QuerySelectParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSLP, 1))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set attributes
				QSLP.attributes = null;

				if (!GetEntityId(ref QSLP))
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetSelect(QSLP.titleId,QSLP.webId,QSLP.gamerTag,QSLP.teamName,QSLP.datasetId,QSLP.entityId,QSLP.action,QSLP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The method was called with some invalid arguments or attributes and could not be completed."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QSLP.titleId,QSLP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QuerySelect Invalid: too many attributes")]
			public class Query_Select_Invalid_Attrib_Too_Long : TestBase
		{
			protected override void Execute()
			{
				QuerySelectParams QSLP = new QuerySelectParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSLP, 1))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// add attribute to end of array
				QueryAttribute [] QAtoolong = new QueryAttribute[QSLP.attributes.Length+1];
				QSLP.attributes.CopyTo(QAtoolong,0);
				QAtoolong[QAtoolong.Length-1] = new QueryAttribute();
				QAtoolong[QAtoolong.Length-1].Id = 0x80010004;	// comp_cleanup attrib
				QAtoolong[QAtoolong.Length-1].Value = (long)3;
				QSLP.attributes = QAtoolong;

				if (!GetEntityId(ref QSLP))
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetSelect(QSLP.titleId,QSLP.webId,QSLP.gamerTag,QSLP.teamName,QSLP.datasetId,QSLP.entityId,QSLP.action,QSLP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The method was called with some invalid arguments or attributes and could not be completed."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QSLP.titleId,QSLP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QuerySelect Invalid: invalid attributes")]
			public class Query_Select_Invalid_Attrib_Invalid : TestBase
		{
			protected override void Execute()
			{
				QuerySelectParams QSLP = new QuerySelectParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSLP, 1))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				foreach (QueryAttribute QA in QSLP.attributes)
				{
					// lowest 16 bits of ID represent the actual attrib ID
					// in LiveService\Comps\CompDefs, nothing more than 0x20 defined
					QA.Id += 0x100;		// this will make all IDs invalid
				}

				if (!GetEntityId(ref QSLP))
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetSelect(QSLP.titleId,QSLP.webId,QSLP.gamerTag,QSLP.teamName,QSLP.datasetId,QSLP.entityId,QSLP.action,QSLP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The method was called with some invalid arguments or attributes and could not be completed."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QSLP.titleId,QSLP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QuerySelect Invalid: entityId/titleId/datasetId mismatch")]
			public class Query_Select_Invalid_EntityId_Not_In_Table : TestBase
		{
			protected override void Execute()
			{
				QuerySelectParams QSLP = new QuerySelectParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSLP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				QSLP.teamName = "";		// user wanted since teams not created for 0x673
				if (!GetEntityId(ref QSLP))
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// change title
				QSLP.titleId = 0x00000673;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetSelect(QSLP.titleId,QSLP.webId,QSLP.gamerTag,QSLP.teamName,QSLP.datasetId,QSLP.entityId,QSLP.action,QSLP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The requested entity does not exist in the dataset specified.") &&
						!e.Message.EndsWith("The competition has been cancelled, and the operation is invalid."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QSLP.titleId,QSLP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		// bug #38337 - submit results now allowed through web
		[TestCase, Ignore, Description("Select Invalid: Submit Results action invalid from widget")]
			public class Query_Select_Invalid_Action_Submit_Results : TestBase
		{
			protected override void Execute()
			{
				QuerySelectParams QSLP = new QuerySelectParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSLP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set action
				QSLP.action = 7;		// submit results (see CompDefs.cs)

				if (!GetEntityId(ref QSLP))
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetSelect(QSLP.titleId,QSLP.webId,QSLP.gamerTag,QSLP.teamName,QSLP.datasetId,QSLP.entityId,QSLP.action,QSLP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The specified source (client) is not permitted to execute this method."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QSLP.titleId,QSLP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("Select Invalid: Check In action invalid from widget")]
			public class Query_Select_Invalid_Action_Check_In : TestBase
		{
			protected override void Execute()
			{
				QuerySelectParams QSLP = new QuerySelectParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSLP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set action
				QSLP.action = 4;		// check-in (see CompDefs.cs)

				if (!GetEntityId(ref QSLP))
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetSelect(QSLP.titleId,QSLP.webId,QSLP.gamerTag,QSLP.teamName,QSLP.datasetId,QSLP.entityId,QSLP.action,QSLP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The specified source (client) is not permitted to execute this method."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QSLP.titleId,QSLP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QuerySelect Invalid: action doesn't exist")]
			public class Query_Select_Invalid_Action_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				QuerySelectParams QSLP = new QuerySelectParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QSLP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set action
				QSLP.action = QueryWidgetCommon.ACTION_NOT_EXIST;

				if (!GetEntityId(ref QSLP))
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetSelect(QSLP.titleId,QSLP.webId,QSLP.gamerTag,QSLP.teamName,QSLP.datasetId,QSLP.entityId,QSLP.action,QSLP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QSLP.titleId,QSLP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Query\test\FuncQueryUpdate.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Threading;
using System.IO;
using System.Xml;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web;
using ServerTestFramework.Web.Query;
using xonline.common.config;

namespace QueryWidget
{
	[TestGroup]
	public class FuncQueryUpdate : TestNode
	{
		// struct to hold input values to the Update method
		struct QueryUpdateParams
		{
			public System.UInt32 titleId;
			public System.Byte[] webId;
			public string gamerTag;
			public string teamName;
			public System.UInt32 datasetId;
			public System.UInt32 procIndex;
			public QueryAttribute[] attributes;
		}

		/// <summary>
		/// function that uses XML file to return valid parameters
		/// </summary>
		/// <param name="QUP">struct to fill with parameters for call to Update</param>
		/// <param name="procSel">zero-based short to identify which procIndex to use in the xml.</param>
		/// <returns>false if any errors parsing XML file, else true</returns>
		static bool GetValidParams(ref QueryUpdateParams QUP)
		{
			return GetValidParams(ref QUP,0);
		}

		static bool GetValidParams(ref QueryUpdateParams QUP, short procSel)
		{
			QUP.titleId = QueryWidgetCommon.QUERY_TITLE_ID;
			QUP.datasetId = QueryWidgetCommon.QUERY_DATASET_ID;
			QUP.gamerTag = QueryWidgetCommon.QUERY_GAMERTAG;
			QUP.webId = QueryWidgetCommon.QUERY_WEBID;
			QUP.teamName = QueryWidgetCommon.QUERY_TEAMNAME;

			XmlDocument parameters = new XmlDocument();
			parameters.Load("QueryWidget.xml");

			try
			{
				XmlNodeList paramNodes = parameters.SelectNodes("/stf/parameters/update/procIndex");
				if (paramNodes.Count <= procSel)
					throw new Exception();
				QUP.procIndex = Convert.ToUInt32(paramNodes[procSel].InnerText);

				paramNodes = parameters.SelectNodes("/stf/parameters/update/attributes");
				if (paramNodes.Count <= procSel)
					throw new Exception();
				QUP.attributes = new QueryAttribute[paramNodes[procSel].ChildNodes.Count];
				for (int i=0; i<paramNodes[procSel].ChildNodes.Count; i++)
				{
					if (paramNodes[procSel].ChildNodes[i].Name != "attrib")
						throw new Exception();

					QUP.attributes[i] = new QueryAttribute();

					QUP.attributes[i].Id = System.UInt32.Parse(paramNodes[procSel].ChildNodes[i].Attributes["a_id"].Value,System.Globalization.NumberStyles.AllowHexSpecifier);
					switch (QUP.attributes[i].Id)
					{
						case 1:
							QUP.attributes[i].Value = (long)Convert.ToInt32(paramNodes[procSel].ChildNodes[i].Attributes["a_value"].Value);
							break;
						case 1048579:
							QUP.attributes[i].Value = paramNodes[procSel].ChildNodes[i].Attributes["a_value"].Value;
							break;
						case 2097157:
							QUP.attributes[i].Value = Hexer.unhex(paramNodes[procSel].ChildNodes[i].Attributes["a_value"].Value);
							break;
					}
				}
			}
			catch (Exception)
			{
				ConsoleX.WriteLine("Invalid parameter element found in xml.");
				return false;
			}
			return true;
		}

		/// <summary>
		/// function to determine how many records should be affected by a call to Update through the Query Widget
		/// </summary>
		/// <param name="QUP"></param>
		/// <returns></returns>
		static uint GetMatchingRecords(QueryUpdateParams QUP)
		{
			System.Int64 ownerId = (long)QueryWidgetCommon.QUERY_TEAMID;
			if (QUP.gamerTag == null)
				ownerId = QUP.titleId;
			else if (null == QUP.teamName || "" == QUP.teamName)
				ownerId = 2814749767106559 - Convert.ToInt64(QUP.gamerTag.Substring(7));	// gamerTags are of format webuserX (X = 0 thru 1023) and PUID starts at 2814749767106559 going down

			// set up database query
			uint nRecordsAffected = 0;
			string sql = "";
			switch (QUP.procIndex)
			{
				case 0:
					sql="SELECT Count(*) FROM [QueryDB].[dbo].[t_query_dataset_"+Hexer.tohex(QUP.titleId)+"_"+QUP.datasetId.ToString("x")+"] WHERE att_00000001 = "+(long)QUP.attributes[0].Value+" AND bi_owner_id = "+ownerId;
					break;
				case 32:
					sql="SELECT Count(*) FROM [QueryDB].[dbo].[t_query_dataset_"+Hexer.tohex(QUP.titleId)+"_"+QUP.datasetId.ToString("x")+"] WHERE att_00200005 = 0x"+Hexer.tohex((byte[])QUP.attributes[2].Value)+" AND bi_owner_id = "+ownerId;
					break;
			}
			SqlCommand mySqlCommand = null;
			SqlDataReader myDataReader = null;

			for (int iSql=0; iSql<QueryWidgetCommon.qrySqlConn.Length; iSql++)
			{
				try
				{
					mySqlCommand = new SqlCommand(sql,QueryWidgetCommon.qrySqlConn[iSql]);
					myDataReader = mySqlCommand.ExecuteReader();

					if (!myDataReader.HasRows && iSql < QueryWidgetCommon.qrySqlConn.Length+1)
						continue;

					// get # matching records
					if (myDataReader.Read() != false)
						nRecordsAffected += (uint)myDataReader.GetInt32(0);

					if (myDataReader != null && !myDataReader.IsClosed)
						myDataReader.Close();
				}
				catch (Exception e)
				{
					ConsoleX.WriteLine("SQL error in GetMatchingRecords(): " + e.Message);
					if (QueryWidgetCommon.qrySqlConn[iSql].State != ConnectionState.Open)
						QueryWidgetCommon.qrySqlConn[iSql].Open();
				}
				finally
				{
					// Always call Close when done reading.
					if (myDataReader != null && !myDataReader.IsClosed)
						myDataReader.Close();
				}
			}

			return nRecordsAffected;
		}

		/// <summary>
		/// function to ensure Update method worked as expected
		/// </summary>
		/// <param name="QUP"></param>
		/// <returns></returns>
		static bool VerifyUpdate(QueryUpdateParams QUP, uint nExpectedRecordsAffected, uint nPrevRecords, DateTime dtTestStart)
		{
			// REM "SELECT [bi_entity_id], [bi_owner_id], [dt_change_datetime], [att_00000001], [att_00100003], [att_00200005] FROM [QueryDB].[dbo].[t_query_dataset_0000b2d2_1]"

			bool bRet=true;
			string strDate = dtTestStart.GetDateTimeFormats()[71];

			System.Int64 ownerId = (long)QueryWidgetCommon.QUERY_TEAMID;
			if (QUP.gamerTag == null)
				ownerId = QUP.titleId;
			else if (null == QUP.teamName || "" == QUP.teamName)
				ownerId = 2814749767106559 - Convert.ToInt64(QUP.gamerTag.Substring(7));	// gamerTags are of format webuserX (X = 0 thru 1023) and PUID starts at 2814749767106559 going down

			// set up database query
			string sql="";
			SqlCommand mySqlCommand = null;
			SqlDataReader myDataReader = null;
			uint nRecordsActuallyAffected = 0;
			bool success = true;
			for (int iSql=0; iSql<QueryWidgetCommon.qrySqlConn.Length; iSql++)
			{
				try
				{
					switch (QUP.procIndex)
					{
						case 0:
							sql="SELECT Count(*) FROM [QueryDB].[dbo].[t_query_dataset_"+Hexer.tohex(QUP.titleId)+"_"+QUP.datasetId.ToString("x")+"] WHERE bi_owner_id ="+ownerId+" AND att_00000001 = "+(long)QUP.attributes[0].Value+" AND att_00100003='"+(string)QUP.attributes[1].Value+"' AND dt_change_datetime >= '"+strDate+"'";
							break;
						case 32:
							sql="SELECT Count(*) FROM [QueryDB].[dbo].[t_query_dataset_"+Hexer.tohex(QUP.titleId)+"_"+QUP.datasetId.ToString("x")+"] WHERE bi_owner_id ="+ownerId+" AND att_00000001 = "+(long)QUP.attributes[0].Value+" AND att_00100003='"+(string)QUP.attributes[1].Value+"' AND att_00200005 = 0x"+Hexer.tohex((byte[])QUP.attributes[2].Value)+" AND dt_change_datetime >= '"+strDate+"'";
							break;
					}

					mySqlCommand = new SqlCommand(sql,QueryWidgetCommon.qrySqlConn[iSql]);
					myDataReader = mySqlCommand.ExecuteReader();

					if (!myDataReader.HasRows && iSql < QueryWidgetCommon.qrySqlConn.Length+1)
						continue;

					// get # matching records
					if (myDataReader.Read() != false)
					{
						nRecordsActuallyAffected += (uint)myDataReader.GetInt32(0);
						success &= true;
					}
					else
						success = false;

					if (myDataReader != null && !myDataReader.IsClosed)
						myDataReader.Close();

					bRet = (success && nRecordsActuallyAffected == nExpectedRecordsAffected);

					if (true == bRet)
					{
						// make sure dataset has same # rows as before
						bRet = (nPrevRecords == QueryWidgetCommon.GetNumRecords(QUP.titleId,QUP.datasetId));
					}
					return bRet;
				}
				catch (Exception e)
				{
					ConsoleX.WriteLine("SQL error in VerifyUpdate(): " + e.Message);
					bRet = false;
					if (QueryWidgetCommon.qrySqlConn[iSql].State != ConnectionState.Open)
						QueryWidgetCommon.qrySqlConn[iSql].Open();
				}
				finally
				{
					// Always call Close when done reading.
					if (myDataReader != null && !myDataReader.IsClosed)
						myDataReader.Close();
				}
			}

			return bRet;
		}

		// Positive test cases

		[TestCase, Description("QueryUpdate Valid: basic verify")]
			class Query_Update_Valid_Basic : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateParams QUP = new QueryUpdateParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				QueryWidgetCommon.FillDBBasedOnAPI(1,0);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QUP.titleId,QUP.datasetId);
				uint nExpectedRecordsAffected = GetMatchingRecords(QUP);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdate(QUP.titleId,QUP.webId,QUP.gamerTag,QUP.teamName,QUP.datasetId,QUP.procIndex,QUP.attributes);

					if (!VerifyUpdate(QUP, nExpectedRecordsAffected, nRecords, dtTestStart))
						throw new Exception("Verification failed.");
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		[TestCase, Description("QueryUpdate Valid: basic verify - Partner Query")]
			class Query_Update_Valid_Basic_Partner_Query : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateParams QUP = new QueryUpdateParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				QUP.gamerTag = null;
				QUP.teamName = null;
				QUP.webId = BitConverter.GetBytes(QUP.titleId);
				QUP.attributes[0].Value = (long)99;

				QueryWidgetCommon.FillDBBasedOnAPI(1,2);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QUP.titleId,QUP.datasetId);
				uint nExpectedRecordsAffected = GetMatchingRecords(QUP);

				RequestInfo rInfo = new RequestInfo("DebugAdmin");
				WCQuery wc = new WCQuery(Global.XEnv.GetVirtualInterface(VirtualInterface.wcquery),rInfo);
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdate(QUP.titleId,QUP.webId,QUP.gamerTag,QUP.teamName,QUP.datasetId,QUP.procIndex,QUP.attributes);

					if (!VerifyUpdate(QUP, nExpectedRecordsAffected, nRecords, dtTestStart))
						throw new Exception("Verification failed.");
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		[TestCase, Description("QueryUpdate Valid: teamName null")]
			class Query_Update_Valid_teamName_Null : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateParams QUP = new QueryUpdateParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set teamName
				QUP.teamName = null;

				QueryWidgetCommon.FillDBBasedOnAPI(1,0);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QUP.titleId,QUP.datasetId);
				uint nExpectedRecordsAffected = GetMatchingRecords(QUP);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdate(QUP.titleId,QUP.webId,QUP.gamerTag,QUP.teamName,QUP.datasetId,QUP.procIndex,QUP.attributes);

					if (!VerifyUpdate(QUP, nExpectedRecordsAffected, nRecords, dtTestStart))
						throw new Exception("Verification failed.");
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		[TestCase, Description("QueryUpdate Valid: teamName empty")]
			class Query_Update_Valid_teamName_Empty : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateParams QUP = new QueryUpdateParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set teamName
				QUP.teamName = "";

				QueryWidgetCommon.FillDBBasedOnAPI(1,0);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QUP.titleId,QUP.datasetId);
				uint nExpectedRecordsAffected = GetMatchingRecords(QUP);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdate(QUP.titleId,QUP.webId,QUP.gamerTag,QUP.teamName,QUP.datasetId,QUP.procIndex,QUP.attributes);

					if (!VerifyUpdate(QUP, nExpectedRecordsAffected, nRecords, dtTestStart))
						throw new Exception("Verification failed.");
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		[TestCase, Description("QueryUpdate Valid: teamName padded with spaces")]
			class Query_Update_Valid_TeamName_Padded : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateParams QUP = new QueryUpdateParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				QueryWidgetCommon.FillDBBasedOnAPI(1,0);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QUP.titleId,QUP.datasetId);
				uint nExpectedRecordsAffected = GetMatchingRecords(QUP);
				QUP.teamName += " ";

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					// try teamName padded at end
					wc.WidgetUpdate(QUP.titleId,QUP.webId,QUP.gamerTag,QUP.teamName,QUP.datasetId,QUP.procIndex,QUP.attributes);
					if (!VerifyUpdate(QUP, nExpectedRecordsAffected, nRecords, dtTestStart))
						throw new Exception("Verification failed.");

					// try teamName padded at beginning
					QueryWidgetCommon.FillDBBasedOnAPI(1,0);
					nRecords = QueryWidgetCommon.GetNumRecords(QUP.titleId,QUP.datasetId);
					nExpectedRecordsAffected = GetMatchingRecords(QUP);
					QUP.teamName = " " + QUP.teamName.Trim();
					dtTestStart = QueryWidgetCommon.GetSqlServerTime();

					wc.WidgetUpdate(QUP.titleId,QUP.webId,QUP.gamerTag,QUP.teamName,QUP.datasetId,QUP.procIndex,QUP.attributes);
					if (!VerifyUpdate(QUP, nExpectedRecordsAffected, nRecords, dtTestStart))
						throw new Exception("Verification failed.");
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		[TestCase, Description("QueryUpdate Valid: procIndex match Update proc 1")]
			class Query_Update_Valid_ProcIndex_Match_1 : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateParams QUP = new QueryUpdateParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUP, 1))		// get all valid params, select proc 1
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				QueryWidgetCommon.FillDBBasedOnAPI(1,1);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QUP.titleId,QUP.datasetId);
				uint nExpectedRecordsAffected = GetMatchingRecords(QUP);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdate(QUP.titleId,QUP.webId,QUP.gamerTag,QUP.teamName,QUP.datasetId,QUP.procIndex,QUP.attributes);

					if (!VerifyUpdate(QUP, nExpectedRecordsAffected, nRecords, dtTestStart))
						throw new Exception("Verification failed.");
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		[TestCase, Description("QueryUpdate Valid: match single entry")]
			class Query_Update_Valid_Match_One : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateParams QUP = new QueryUpdateParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// DB should have only single entry for webuser20 with attrib specified by procIndex 0
				QUP.gamerTag = "webuser20";
				QUP.webId = BitConverter.GetBytes(562949953420307);
				QUP.teamName = null;

				QueryWidgetCommon.FillDBBasedOnAPI(1,0);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QUP.titleId,QUP.datasetId);
				uint nExpectedRecordsAffected = GetMatchingRecords(QUP);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart;
				try
				{
					if (1 != nExpectedRecordsAffected)
						throw new Exception("Tried to match single entry for test, but found "+nExpectedRecordsAffected.ToString()+" matches.");

					dtTestStart = QueryWidgetCommon.GetSqlServerTime();
					wc.WidgetUpdate(QUP.titleId,QUP.webId,QUP.gamerTag,QUP.teamName,QUP.datasetId,QUP.procIndex,QUP.attributes);

					if (!VerifyUpdate(QUP, nExpectedRecordsAffected, nRecords, dtTestStart))
						throw new Exception("Verification failed.");
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		// Negative test cases

		[TestCase, Description("QueryUpdate Invalid: partner with read-only access")]
			class Query_Update_Invalid_ReadOnly_Partner : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateParams QUP = new QueryUpdateParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				QueryWidgetCommon.FillDBBasedOnAPI(1,0);
				WCQuery wc = new WCQuery(Global.XEnv.GetVirtualInterface(VirtualInterface.wcquery), new RequestInfo("asschw"));
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdate(QUP.titleId,QUP.webId,QUP.gamerTag,QUP.teamName,QUP.datasetId,QUP.procIndex,QUP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Partner:asschw not allowed to access TitleID:"+Hexer.tohex(QUP.titleId)))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryUpdate Invalid: unknown titleId")]
			class Query_Update_Invalid_Unknown_Title : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateParams QUP = new QueryUpdateParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set titleId to unknown value
				QUP.titleId = QueryWidgetCommon.TITLEID_NOT_EXIST;

				QueryWidgetCommon.FillDBBasedOnAPI(1,0);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdate(QUP.titleId,QUP.webId,QUP.gamerTag,QUP.teamName,QUP.datasetId,QUP.procIndex,QUP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Partner:DebugPartner not allowed to access TitleID:"+Hexer.tohex(QUP.titleId)))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryUpdate Invalid: titleId MAX_UINT32")]
			class Query_Update_Invalid_Title_Max : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateParams QUP = new QueryUpdateParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set titleId to max
				QUP.titleId = UInt32.MaxValue;

				QueryWidgetCommon.FillDBBasedOnAPI(1,0);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdate(QUP.titleId,QUP.webId,QUP.gamerTag,QUP.teamName,QUP.datasetId,QUP.procIndex,QUP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Partner:DebugPartner not allowed to access TitleID:"+Hexer.tohex(QUP.titleId)))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryUpdate Invalid: titleId doesn't support Query Service")]
			class Query_Update_Invalid_Title_Unsupported : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateParams QUP = new QueryUpdateParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set titleId
				QUP.titleId = QueryWidgetCommon.TITLEID_NO_QUERY;
				QUP.teamName = "";

				QueryWidgetCommon.FillDBBasedOnAPI(1,0);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdate(QUP.titleId,QUP.webId,QUP.gamerTag,QUP.teamName,QUP.datasetId,QUP.procIndex,QUP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryUpdate Invalid: titleId doesn't support Update")]
			class Query_Update_Invalid_Update_Unsupported : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateParams QUP = new QueryUpdateParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set titleId
				QUP.datasetId = 2;

				QueryWidgetCommon.FillDBBasedOnAPI(1,0);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdate(QUP.titleId,QUP.webId,QUP.gamerTag,QUP.teamName,QUP.datasetId,QUP.procIndex,QUP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QUP.titleId,QUP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryUpdate Invalid: webId null")]
			class Query_Update_Invalid_WebId_Null : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateParams QUP = new QueryUpdateParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set webId
				QUP.webId = null;

				QueryWidgetCommon.FillDBBasedOnAPI(1,0);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdate(QUP.titleId,QUP.webId,QUP.gamerTag,QUP.teamName,QUP.datasetId,QUP.procIndex,QUP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Bad Passport web ID, null not allowed"))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QUP.titleId,QUP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryUpdate Invalid: webId doesn't exist")]
			class Query_Update_Invalid_WebId_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateParams QUP = new QueryUpdateParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set webId
				QUP.webId = QueryWidgetCommon.WEBID_NOT_EXIST;

				QueryWidgetCommon.FillDBBasedOnAPI(1,0);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdate(QUP.titleId,QUP.webId,QUP.gamerTag,QUP.teamName,QUP.datasetId,QUP.procIndex,QUP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("(webID,GamerTag) pair ("+Hexer.tohex(QUP.webId,true)+","+QUP.gamerTag+") is not linked in our system"))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QUP.titleId,QUP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryUpdate Invalid: webId/gamerTag mismatch")]
			class Query_Update_Invalid_WebId_GamerTag_Mismatch : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateParams QUP = new QueryUpdateParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set webId
				QUP.webId = QueryWidgetCommon.WEBID_NO_MATCH;

				QueryWidgetCommon.FillDBBasedOnAPI(1,0);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdate(QUP.titleId,QUP.webId,QUP.gamerTag,QUP.teamName,QUP.datasetId,QUP.procIndex,QUP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("(webID,GamerTag) pair ("+Hexer.tohex(QUP.webId,true)+","+QUP.gamerTag+") is not linked in our system"))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QUP.titleId,QUP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryUpdate Invalid: webId too short")]
			class Query_Update_Invalid_WebId_Too_Short : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateParams QUP = new QueryUpdateParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set webId
				QUP.webId = QueryWidgetCommon.WEBID_TOO_SHORT;

				QueryWidgetCommon.FillDBBasedOnAPI(1,0);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdate(QUP.titleId,QUP.webId,QUP.gamerTag,QUP.teamName,QUP.datasetId,QUP.procIndex,QUP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Bad Passport web ID, length is "+QUP.webId.Length.ToString()))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QUP.titleId,QUP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryUpdate Invalid: webId too long")]
			class Query_Update_Invalid_WebId_Too_Long : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateParams QUP = new QueryUpdateParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set webId
				QUP.webId = QueryWidgetCommon.WEBID_TOO_LONG;

				QueryWidgetCommon.FillDBBasedOnAPI(1,0);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdate(QUP.titleId,QUP.webId,QUP.gamerTag,QUP.teamName,QUP.datasetId,QUP.procIndex,QUP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Bad Passport web ID, length is "+QUP.webId.Length.ToString()))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QUP.titleId,QUP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryUpdate Invalid: VERY long webId")]
			class Query_Update_Invalid_WebId_VERY_long : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateParams QUP = new QueryUpdateParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				QUP.webId = new byte[999999];
				for (int i=0; i<999999; i++)
				{
					QUP.webId[i] = (byte)(i%16);
				}

				QueryWidgetCommon.FillDBBasedOnAPI(1,0);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdate(QUP.titleId,QUP.webId,QUP.gamerTag,QUP.teamName,QUP.datasetId,QUP.procIndex,QUP.attributes);
				}
				catch (Exception e)
				{
                    if (!e.Message.EndsWith("Bad Passport web ID, length is 999999"))
                    {
                        Global.RO.Info("expected bad passport exception, got: " + e.Message);
                        ResultCode = TEST_RESULTS.FAILED;
                    }

					if (!QueryWidgetCommon.VerifyNoChange(QUP.titleId,QUP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryUpdate Invalid: gamerTag null")]
			class Query_Update_Invalid_GamerTag_Null : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateParams QUP = new QueryUpdateParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set gamerTag
				QUP.gamerTag = null;

				QueryWidgetCommon.FillDBBasedOnAPI(1,0);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdate(QUP.titleId,QUP.webId,QUP.gamerTag,QUP.teamName,QUP.datasetId,QUP.procIndex,QUP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Bad GamerTag provided, null not allowed"))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QUP.titleId,QUP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryUpdate Invalid: gamerTag empty string")]
			class Query_Update_Invalid_GamerTag_Empty : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateParams QUP = new QueryUpdateParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set gamerTag
				QUP.gamerTag = "";

				QueryWidgetCommon.FillDBBasedOnAPI(1,0);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdate(QUP.titleId,QUP.webId,QUP.gamerTag,QUP.teamName,QUP.datasetId,QUP.procIndex,QUP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("(webID,GamerTag) pair ("+Hexer.tohex(QUP.webId,true)+","+QUP.gamerTag+") is not linked in our system"))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QUP.titleId,QUP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryUpdate Invalid: gamerTag padded with spaces")]
			class Query_Update_Invalid_GamerTag_Padded : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateParams QUP = new QueryUpdateParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// pad gamerTag with space at end
				QUP.gamerTag += " ";

				QueryWidgetCommon.FillDBBasedOnAPI(1,0);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					// try gamerTag padded at end
					wc.WidgetUpdate(QUP.titleId,QUP.webId,QUP.gamerTag,QUP.teamName,QUP.datasetId,QUP.procIndex,QUP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("(webID,GamerTag) pair ("+Hexer.tohex(QUP.webId,true)+","+QUP.gamerTag+") is not linked in our system"))
					{
						ResultCode = TEST_RESULTS.FAILED;
						return;
					}

					if (!QueryWidgetCommon.VerifyNoChange(QUP.titleId,QUP.datasetId,dtTestStart))
					{
						ResultCode = TEST_RESULTS.FAILED;
						return;
					}

					try
					{
						// try gamerTag padded at beginning
						QUP.gamerTag = " " + QUP.gamerTag.Trim();
						dtTestStart = QueryWidgetCommon.GetSqlServerTime();
						wc.WidgetUpdate(QUP.titleId,QUP.webId,QUP.gamerTag,QUP.teamName,QUP.datasetId,QUP.procIndex,QUP.attributes);
					}
					catch (Exception ex)
					{
						if (!ex.Message.EndsWith("(webID,GamerTag) pair ("+Hexer.tohex(QUP.webId,true)+","+QUP.gamerTag+") is not linked in our system"))
							ResultCode = TEST_RESULTS.FAILED;

						if (!QueryWidgetCommon.VerifyNoChange(QUP.titleId,QUP.datasetId,dtTestStart))
							ResultCode = TEST_RESULTS.FAILED;
						return;
					}
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryUpdate Invalid: gamerTag too long")]
			class Query_Update_Invalid_GamerTag_Too_Long : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateParams QUP = new QueryUpdateParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set gamerTag
				QUP.gamerTag = QueryWidgetCommon.GAMERTAG_TOO_LONG;

				QueryWidgetCommon.FillDBBasedOnAPI(1,0);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdate(QUP.titleId,QUP.webId,QUP.gamerTag,QUP.teamName,QUP.datasetId,QUP.procIndex,QUP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("(webID,GamerTag) pair ("+Hexer.tohex(QUP.webId,true)+","+QUP.gamerTag+") is not linked in our system"))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QUP.titleId,QUP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}


		[TestCase, Description("QueryUpdate Invalid: user/team mismatch")]
			class Query_Update_Invalid_User_Team_Mismatch : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateParams QUP = new QueryUpdateParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set teamName
				QUP.teamName = QueryWidgetCommon.TEAMNAME_NO_MATCH;

				QueryWidgetCommon.FillDBBasedOnAPI(1,0);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdate(QUP.titleId,QUP.webId,QUP.gamerTag,QUP.teamName,QUP.datasetId,QUP.procIndex,QUP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("User "+QUP.gamerTag+" could not be validated as a member of team "+QUP.teamName+" in title "+Hexer.tohex(QUP.titleId).ToLower()))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QUP.titleId,QUP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryUpdate Invalid: teamName doesn't exist")]
			class Query_Update_Invalid_teamName_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateParams QUP = new QueryUpdateParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set teamName
				QUP.teamName = QueryWidgetCommon.TEAMNAME_NOT_EXIST;

				QueryWidgetCommon.FillDBBasedOnAPI(1,0);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdate(QUP.titleId,QUP.webId,QUP.gamerTag,QUP.teamName,QUP.datasetId,QUP.procIndex,QUP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Team "+QUP.teamName+" could not be found in the team cache for titleId "+Hexer.tohex(QUP.titleId).ToLower()+" aborting."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QUP.titleId,QUP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryUpdate Invalid: teamName too long")]
			class Query_Update_Invalid_TeamName_Too_Long : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateParams QUP = new QueryUpdateParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set teamName
				QUP.teamName = QueryWidgetCommon.TEAMNAME_TOO_LONG;

				QueryWidgetCommon.FillDBBasedOnAPI(1,0);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdate(QUP.titleId,QUP.webId,QUP.gamerTag,QUP.teamName,QUP.datasetId,QUP.procIndex,QUP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Team "+QUP.teamName+" could not be found in the team cache for titleId "+Hexer.tohex(QUP.titleId).ToLower()+" aborting."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QUP.titleId,QUP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryUpdate Invalid: datasetId 0")]
			class Query_Update_Invalid_DatasetId_0 : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateParams QUP = new QueryUpdateParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set dataset
				QUP.datasetId = 0;

				QueryWidgetCommon.FillDBBasedOnAPI(1,0);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdate(QUP.titleId,QUP.webId,QUP.gamerTag,QUP.teamName,QUP.datasetId,QUP.procIndex,QUP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryUpdate Invalid: datasetId 2")]
			class Query_Update_Invalid_DatasetId_2 : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateParams QUP = new QueryUpdateParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set dataset
				QUP.datasetId = 2;

				QueryWidgetCommon.FillDBBasedOnAPI(1,0);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdate(QUP.titleId,QUP.webId,QUP.gamerTag,QUP.teamName,QUP.datasetId,QUP.procIndex,QUP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;

					if (QUP.titleId != QueryWidgetCommon.QUERY_TITLE_ID && !QueryWidgetCommon.VerifyNoChange(QUP.titleId,QUP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryUpdate Invalid: datasetId 3")]
			class Query_Update_Invalid_DatasetId_3 : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateParams QUP = new QueryUpdateParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set dataset
				QUP.datasetId = 3;

				QueryWidgetCommon.FillDBBasedOnAPI(1,0);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdate(QUP.titleId,QUP.webId,QUP.gamerTag,QUP.teamName,QUP.datasetId,QUP.procIndex,QUP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;

					if (QUP.titleId != QueryWidgetCommon.QUERY_TITLE_ID && !QueryWidgetCommon.VerifyNoChange(QUP.titleId,QUP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryUpdate Invalid: datasetId MAX_UINT32")]
			class Query_Update_Invalid_DatasetId_Max : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateParams QUP = new QueryUpdateParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set dataset
				QUP.datasetId = UInt32.MaxValue;

				QueryWidgetCommon.FillDBBasedOnAPI(1,0);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdate(QUP.titleId,QUP.webId,QUP.gamerTag,QUP.teamName,QUP.datasetId,QUP.procIndex,QUP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryUpdate Invalid: procIndex MAX_UINT32")]
			class Query_Update_Invalid_ProcIndex_Max : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateParams QUP = new QueryUpdateParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set procIndex
				QUP.procIndex = UInt32.MaxValue;

				QueryWidgetCommon.FillDBBasedOnAPI(1,0);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdate(QUP.titleId,QUP.webId,QUP.gamerTag,QUP.teamName,QUP.datasetId,QUP.procIndex,QUP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QUP.titleId,QUP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryUpdate Invalid: procIndex off by 1")]
			class Query_Update_Invalid_ProcIndex_Off_By_One : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateParams QUP = new QueryUpdateParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set procIndex
				QUP.procIndex++;

				QueryWidgetCommon.FillDBBasedOnAPI(1,0);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdate(QUP.titleId,QUP.webId,QUP.gamerTag,QUP.teamName,QUP.datasetId,QUP.procIndex,QUP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QUP.titleId,QUP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

/*		[TestCase, Description("QueryUpdate Invalid: procIndex doesn't exist")]
			class Query_Update_Invalid_ProcIndex_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateParams QUP = new QueryUpdateParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set procIndex
				QUP.procIndex = QueryWidgetCommon.PROCINDEX_NOT_EXIST;

				QueryWidgetCommon.FillDBBasedOnAPI(1,0);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdate(QUP.titleId,QUP.webId,QUP.gamerTag,QUP.teamName,QUP.datasetId,QUP.procIndex,QUP.attributes);
				}
				catch (Exception e)
				{
					ConsoleX.WriteLine("Update with unknown procIndex failed as expected. Exception message: " + e.Message);

					if (!QueryWidgetCommon.VerifyNoChange(QUP.titleId,QUP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}
*/
		[TestCase, Description("QueryUpdate Invalid: attributes null")]
			class Query_Update_Invalid_Attrib_Null : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateParams QUP = new QueryUpdateParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set attributes
				QUP.attributes = null;

				QueryWidgetCommon.FillDBBasedOnAPI(1,0);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdate(QUP.titleId,QUP.webId,QUP.gamerTag,QUP.teamName,QUP.datasetId,QUP.procIndex,QUP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Object reference not set to an instance of an object."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QUP.titleId,QUP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryUpdate Invalid: too few attributes")]
			class Query_Update_Invalid_Attrib_Too_Short : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateParams QUP = new QueryUpdateParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// remove attribute from end of array
				QueryAttribute [] QAtooshort = new QueryAttribute[QUP.attributes.Length-1];
				Array.Copy(QUP.attributes,QAtooshort,QAtooshort.Length);
				QUP.attributes = QAtooshort;

				QueryWidgetCommon.FillDBBasedOnAPI(1,0);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdate(QUP.titleId,QUP.webId,QUP.gamerTag,QUP.teamName,QUP.datasetId,QUP.procIndex,QUP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("An unexpected attribute passed to the method caused a database error."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QUP.titleId,QUP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryUpdate Invalid: too many attributes")]
			class Query_Update_Invalid_Attrib_Too_Long : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateParams QUP = new QueryUpdateParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// add valid attribute at end of array
				QueryAttribute [] QAtoolong = new QueryAttribute[QUP.attributes.Length+1];
				QUP.attributes.CopyTo(QAtoolong,0);
				QAtoolong[QAtoolong.Length-1] = new QueryAttribute();
				QAtoolong[QAtoolong.Length-1].Id = 2097157;
				QAtoolong[QAtoolong.Length-1].Value = Hexer.unhex("123456789");
				QUP.attributes = QAtoolong;

				QueryWidgetCommon.FillDBBasedOnAPI(1,0);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdate(QUP.titleId,QUP.webId,QUP.gamerTag,QUP.teamName,QUP.datasetId,QUP.procIndex,QUP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("An unexpected attribute passed to the method caused a database error."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QUP.titleId,QUP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryUpdate Invalid: invalid attributes")]
			class Query_Update_Invalid_Attrib_Invalid : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateParams QUP = new QueryUpdateParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				foreach (QueryAttribute QA in QUP.attributes)
				{
					// lowest 16 bits of ID represent the actual attrib ID
					// in LiveService\Comps\CompDefs, nothing more than 0x20 defined
					QA.Id += 0x100;		// this will make all IDs invalid
				}

				QueryWidgetCommon.FillDBBasedOnAPI(1,0);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdate(QUP.titleId,QUP.webId,QUP.gamerTag,QUP.teamName,QUP.datasetId,QUP.procIndex,QUP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("An unexpected attribute passed to the method caused a database error."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QUP.titleId,QUP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryUpdate Invalid: match attributes but not user/team")]
			class Query_Update_Invalid_Owner_Not_Match : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateParams QUP = new QueryUpdateParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				QUP.attributes[0].Value = (long)5000;	// entries with matching attrib should be in DB, but with different owner

				QueryWidgetCommon.FillDBBasedOnAPI(1,0);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QUP.titleId,QUP.datasetId);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdate(QUP.titleId,QUP.webId,QUP.gamerTag,QUP.teamName,QUP.datasetId,QUP.procIndex,QUP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The user tried to update or delete an entity that he does not own."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QUP.titleId,QUP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryUpdate Invalid: match empty set")]
			class Query_Update_Invalid_Match_Nothing : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateParams QUP = new QueryUpdateParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				QUP.attributes[0].Value = (long)1000;	// pick value that won't match anything in dataset

				QueryWidgetCommon.FillDBBasedOnAPI(1,0);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QUP.titleId,QUP.datasetId);
				uint nExpectedRecordsAffected = GetMatchingRecords(QUP);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					if (0 != nExpectedRecordsAffected)
						throw new Exception("Found matching entry when trying to match none.");

					wc.WidgetUpdate(QUP.titleId,QUP.webId,QUP.gamerTag,QUP.teamName,QUP.datasetId,QUP.procIndex,QUP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The requested entity does not exist in the dataset specified."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QUP.titleId,QUP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Query\test\FuncQueryUpdateId.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Threading;
using System.IO;
using System.Xml;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web;
using ServerTestFramework.Web.Query;
using xonline.common.config;

namespace QueryWidget
{
	[TestGroup]
	public class FuncQueryUpdateId : TestNode
	{
		// struct to hold input values to the UpdateId method
		struct QueryUpdateIdParams
		{
			public System.UInt32 titleId;
			public System.Byte[] webId;
			public string gamerTag;
			public string teamName;
			public System.UInt32 datasetId;
			public System.UInt32 procIndex;
			public System.UInt64 entityId;
			public QueryAttribute[] attributes;
		}

		/// <summary>
		/// function that uses XML file to return valid parameters
		/// </summary>
		/// <param name="QUIP">struct to fill with parameters for call to UpdateId</param>
		/// <param name="procSel">zero-based short to identify which procIndex to use in the xml.</param>
		/// <returns>false if any errors parsing XML file, else true</returns>
		static bool GetValidParams(ref QueryUpdateIdParams QUIP)
		{
			return GetValidParams(ref QUIP,0);
		}

		static bool GetValidParams(ref QueryUpdateIdParams QUIP, short procSel)
		{
			QUIP.titleId = QueryWidgetCommon.QUERY_TITLE_ID;
			QUIP.datasetId = QueryWidgetCommon.QUERY_DATASET_ID;
			QUIP.gamerTag = QueryWidgetCommon.QUERY_GAMERTAG;
			QUIP.webId = QueryWidgetCommon.QUERY_WEBID;
			QUIP.teamName = QueryWidgetCommon.QUERY_TEAMNAME;

			XmlDocument parameters = new XmlDocument();
			parameters.Load("QueryWidget.xml");

			try
			{
				XmlNodeList paramNodes = parameters.SelectNodes("/stf/parameters/updateId/procIndex");
				if (paramNodes.Count <= procSel)
					throw new Exception();
				QUIP.procIndex = Convert.ToUInt32(paramNodes[procSel].InnerText);

				paramNodes = parameters.SelectNodes("/stf/parameters/updateId/attributes");
				if (paramNodes.Count <= procSel)
					throw new Exception();
				QUIP.attributes = new QueryAttribute[paramNodes[procSel].ChildNodes.Count];
				for (int i=0; i<paramNodes[procSel].ChildNodes.Count; i++)
				{
					if (paramNodes[procSel].ChildNodes[i].Name != "attrib")
						throw new Exception();

					QUIP.attributes[i] = new QueryAttribute();

					QUIP.attributes[i].Id = System.UInt32.Parse(paramNodes[procSel].ChildNodes[i].Attributes["a_id"].Value,System.Globalization.NumberStyles.AllowHexSpecifier);
					switch (QUIP.attributes[i].Id)
					{
						case 1:
							QUIP.attributes[i].Value = (long)Convert.ToInt32(paramNodes[procSel].ChildNodes[i].Attributes["a_value"].Value);
							break;
						case 1048579:
							QUIP.attributes[i].Value = paramNodes[procSel].ChildNodes[i].Attributes["a_value"].Value;
							break;
						case 2097157:
							QUIP.attributes[i].Value = Hexer.unhex(paramNodes[procSel].ChildNodes[i].Attributes["a_value"].Value);
							break;
					}
				}
			}
			catch (Exception)
			{
				ConsoleX.WriteLine("Invalid parameter element found in xml.");
				return false;
			}
			return true;
		}

		static bool GetEntityId(ref QueryUpdateIdParams QUIP)
		{
			// REM "SELECT [bi_entity_id], [bi_owner_id], [dt_change_datetime], [att_00000001], [att_00100003], [att_00200005] FROM [QueryDB].[dbo].[t_query_dataset_0000b2d2_1]"

			QueryWidgetCommon.FillDBBasedOnAPI(2,0);
			bool bRet = true;

			WCQuery wc = null;
			if (QUIP.gamerTag != null)
				wc = new WCQuery();
			else
			{
				RequestInfo rInfo = new RequestInfo("DebugAdmin");
				wc = new WCQuery(Global.XEnv.GetVirtualInterface(VirtualInterface.wcquery),rInfo);
			}
			try
			{
				// get entityId for QUIP
				QueryAttribute [] attribs = new QueryAttribute[3];
				for (int i=0; i<3; i++)
					attribs[i] = new QueryAttribute();
				attribs[0].Id = 1;
				attribs[1].Id = 1048579;
				attribs[2].Id = 2097157;
				attribs[0].Value = (long)3000;
				attribs[1].Value = (string)"this string is for UpdateId";
				attribs[2].Value = Hexer.unhex("392847");
				QUIP.entityId = wc.WidgetAdd(QUIP.titleId,QUIP.webId,QUIP.gamerTag,QUIP.teamName,QUIP.datasetId,attribs);

				if (0 == QUIP.entityId)
					throw new Exception("Error: entityId = 0");
			}
			catch (Exception e)
			{
				ConsoleX.WriteLine("SQL error in GetEntityId(): " + e.Message);
				bRet = false;
			}
			System.Threading.Thread.Sleep(2000);
			return bRet;
		}

		/// <summary>
		/// function to ensure UpdateId method worked as expected
		/// </summary>
		/// <param name="QUIP"></param>
		/// <returns></returns>
		static bool VerifyUpdateId(QueryUpdateIdParams QUIP, uint nPrevRecords, DateTime dtTestStart)
		{
			// REM "SELECT [bi_entity_id], [bi_owner_id], [dt_change_datetime], [att_00000001], [att_00100003], [att_00200005] FROM [QueryDB].[dbo].[t_query_dataset_0000b2d2_1]"

			bool bRet=false;
			string strDate = dtTestStart.GetDateTimeFormats()[71];

			// set up database query
			SqlCommand mySqlCommand = null;
			SqlDataReader myDataReader = null;
			for (int iSql=0; iSql<QueryWidgetCommon.qrySqlConn.Length; iSql++)
			{
				try
				{
					string sql="SELECT * FROM [QueryDB].[dbo].[t_query_dataset_"+Hexer.tohex(QUIP.titleId)+"_"+QUIP.datasetId.ToString("x")+"] WHERE bi_entity_id = '"+QUIP.entityId+"'";
					mySqlCommand = new SqlCommand(sql,QueryWidgetCommon.qrySqlConn[iSql]);
					myDataReader = mySqlCommand.ExecuteReader();

					if (!myDataReader.HasRows && iSql < QueryWidgetCommon.qrySqlConn.Length+1)
						continue;

					// verify record in dataset matches our input
					System.Int64 ownerId = (long)QueryWidgetCommon.QUERY_TEAMID;
					if (QUIP.gamerTag == null)
						ownerId = QUIP.titleId;
					else if (QUIP.teamName == null || QUIP.teamName == "")
						ownerId = 2814749767106559 - Convert.ToInt32(QUIP.gamerTag.Substring(7));	// gamerTags are of format webuserX (X = 0 thru 1023) and PUID starts at 2814749767106559 going down

					switch (QUIP.procIndex)
					{
						case 1:
							bRet = myDataReader.Read() != false &&
								myDataReader.GetInt64(1) == ownerId &&
								myDataReader.GetInt64(3) == (long)QUIP.attributes[0].Value &&
								0 == myDataReader.GetString(4).CompareTo(QUIP.attributes[1].Value);
							break;
						case 16:
							bRet = myDataReader.Read() != false &&
								myDataReader.GetInt64(1) == ownerId &&
								0 == Hexer.tohex((byte[])myDataReader.GetValue(5)).CompareTo(Hexer.tohex((byte[])QUIP.attributes[0].Value));
							break;
						case 256:
							bRet = myDataReader.Read() != false &&
								myDataReader.GetInt64(1) == ownerId &&
								myDataReader.GetInt64(3) == (long)QUIP.attributes[0].Value &&
								0 == myDataReader.GetString(4).CompareTo(QUIP.attributes[1].Value) &&
								0 == Hexer.tohex((byte[])myDataReader.GetValue(5)).CompareTo(Hexer.tohex((byte[])QUIP.attributes[2].Value));
							break;
						case 4096:
							bRet = myDataReader.Read() != false &&
								myDataReader.GetInt64(1) == ownerId &&
								0 == myDataReader.GetString(4).CompareTo(QUIP.attributes[0].Value) &&
								0 == Hexer.tohex((byte[])myDataReader.GetValue(5)).CompareTo(Hexer.tohex((byte[])QUIP.attributes[1].Value));
							break;
					}

					if (true == bRet)
					{
						// make sure no other changes to dataset
						sql="SELECT Count(*) FROM [QueryDB].[dbo].[t_query_dataset_"+Hexer.tohex(QUIP.titleId)+"_"+QUIP.datasetId.ToString("x")+"] WHERE dt_change_datetime >= '"+strDate+"' AND bi_entity_id <> '"+QUIP.entityId+"'";
						if (myDataReader != null && !myDataReader.IsClosed)
							myDataReader.Close();
						mySqlCommand = new SqlCommand(sql,QueryWidgetCommon.qrySqlConn[iSql]);
						myDataReader = mySqlCommand.ExecuteReader();

						if (myDataReader.Read() == false || myDataReader.GetInt32(0) != 0)
							throw new Exception("Changes to dataset other than desired update.");

						if (myDataReader != null && !myDataReader.IsClosed)
							myDataReader.Close();

						// make sure dataset has same # rows as before
						bRet = (nPrevRecords == QueryWidgetCommon.GetNumRecords(QUIP.titleId,QUIP.datasetId));
						return bRet;
					}
				}
				catch (Exception e)
				{
					ConsoleX.WriteLine("SQL error in VerifyUpdateId(): " + e.Message);
					bRet = false;
					if (QueryWidgetCommon.qrySqlConn[iSql].State != ConnectionState.Open)
						QueryWidgetCommon.qrySqlConn[iSql].Open();
				}
				finally
				{
					// Always call Close when done reading.
					if (myDataReader != null && !myDataReader.IsClosed)
						myDataReader.Close();
				}
			}

			return bRet;
		}

		// Positive test cases

		[TestCase, Description("QueryUpdateId Valid: basic verify")]
			class Query_UpdateId_Valid_Basic : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateIdParams QUIP = new QueryUpdateIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				GetEntityId(ref QUIP);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QUIP.titleId,QUIP.datasetId);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdateId(QUIP.titleId,QUIP.webId,QUIP.gamerTag,QUIP.teamName,QUIP.datasetId,QUIP.procIndex,QUIP.entityId,QUIP.attributes);

					if (!VerifyUpdateId(QUIP,nRecords,dtTestStart))
						throw new Exception("Verification failed.");

//					if (!RestoreEntity(QUIP))
//						throw new Exception("Warning: Could not restore entry after UpdateId.");
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		[TestCase, Description("QueryUpdateId Valid: basic verify - Partner Query")]
			class Query_UpdateId_Valid_Basic_Partner_Query : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateIdParams QUIP = new QueryUpdateIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				QUIP.gamerTag = null;
				QUIP.teamName = null;
				QUIP.webId = BitConverter.GetBytes(QUIP.titleId);

				GetEntityId(ref QUIP);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QUIP.titleId,QUIP.datasetId);

				RequestInfo rInfo = new RequestInfo("DebugAdmin");
				WCQuery wc = new WCQuery(Global.XEnv.GetVirtualInterface(VirtualInterface.wcquery),rInfo);
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdateId(QUIP.titleId,QUIP.webId,QUIP.gamerTag,QUIP.teamName,QUIP.datasetId,QUIP.procIndex,QUIP.entityId,QUIP.attributes);

					if (!VerifyUpdateId(QUIP,nRecords,dtTestStart))
						throw new Exception("Verification failed.");

//					if (!RestoreEntity(QUIP))
//						throw new Exception("Warning: Could not restore entry after UpdateId.");
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		[TestCase, Description("QueryUpdateId Valid: teamName null")]
			class Query_UpdateId_Valid_teamName_Null : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateIdParams QUIP = new QueryUpdateIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set teamName
				QUIP.teamName = null;

				GetEntityId(ref QUIP);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QUIP.titleId,QUIP.datasetId);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdateId(QUIP.titleId,QUIP.webId,QUIP.gamerTag,QUIP.teamName,QUIP.datasetId,QUIP.procIndex,QUIP.entityId,QUIP.attributes);

					if (!VerifyUpdateId(QUIP,nRecords,dtTestStart))
						throw new Exception("Verification failed.");

//					if (!RestoreEntity(QUIP))
//						throw new Exception("Warning: Could not remove entry after UpdateId.");
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		[TestCase, Description("QueryUpdateId Valid: teamName empty")]
			class Query_UpdateId_Valid_teamName_Empty : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateIdParams QUIP = new QueryUpdateIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set teamName
				QUIP.teamName = "";

				GetEntityId(ref QUIP);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QUIP.titleId,QUIP.datasetId);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdateId(QUIP.titleId,QUIP.webId,QUIP.gamerTag,QUIP.teamName,QUIP.datasetId,QUIP.procIndex,QUIP.entityId,QUIP.attributes);

					if (!VerifyUpdateId(QUIP,nRecords,dtTestStart))
						throw new Exception("Verification failed.");

//					if (!RestoreEntity(QUIP))
//						throw new Exception("Warning: Could not remove entry after UpdateId.");
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		[TestCase, Description("QueryUpdateId Valid: teamName padded with spaces")]
			class Query_UpdateId_Valid_TeamName_Padded : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateIdParams QUIP = new QueryUpdateIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				GetEntityId(ref QUIP);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QUIP.titleId,QUIP.datasetId);
				QUIP.teamName += " ";

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					// try teamName padded at end
					wc.WidgetUpdateId(QUIP.titleId,QUIP.webId,QUIP.gamerTag,QUIP.teamName,QUIP.datasetId,QUIP.procIndex,QUIP.entityId,QUIP.attributes);
					if (!VerifyUpdateId(QUIP,nRecords,dtTestStart))
						throw new Exception("Verification failed.");

					// try teamName padded at beginning
					GetEntityId(ref QUIP);
					nRecords = QueryWidgetCommon.GetNumRecords(QUIP.titleId,QUIP.datasetId);
					QUIP.teamName = " " + QUIP.teamName.Trim();
					dtTestStart = QueryWidgetCommon.GetSqlServerTime();

					wc.WidgetUpdateId(QUIP.titleId,QUIP.webId,QUIP.gamerTag,QUIP.teamName,QUIP.datasetId,QUIP.procIndex,QUIP.entityId,QUIP.attributes);
					if (!VerifyUpdateId(QUIP,nRecords,dtTestStart))
						throw new Exception("Verification failed.");
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		[TestCase, Description("QueryUpdateId Valid: procIndex match UpdateId proc 1")]
			class Query_UpdateId_Valid_ProcIndex_Match_1 : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateIdParams QUIP = new QueryUpdateIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUIP,1))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				GetEntityId(ref QUIP);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QUIP.titleId,QUIP.datasetId);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdateId(QUIP.titleId,QUIP.webId,QUIP.gamerTag,QUIP.teamName,QUIP.datasetId,QUIP.procIndex,QUIP.entityId,QUIP.attributes);

					if (!VerifyUpdateId(QUIP,nRecords,dtTestStart))
						throw new Exception("Verification failed.");

//					if (!RestoreEntity(QUIP))
//						throw new Exception("Warning: Could not remove entry after UpdateId.");
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		[TestCase, Description("QueryUpdateId Valid: procIndex match UpdateId proc 2")]
			class Query_UpdateId_Valid_ProcIndex_Match_2 : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateIdParams QUIP = new QueryUpdateIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUIP,2))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				GetEntityId(ref QUIP);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QUIP.titleId,QUIP.datasetId);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdateId(QUIP.titleId,QUIP.webId,QUIP.gamerTag,QUIP.teamName,QUIP.datasetId,QUIP.procIndex,QUIP.entityId,QUIP.attributes);

					if (!VerifyUpdateId(QUIP,nRecords,dtTestStart))
						throw new Exception("Verification failed.");

//					if (!RestoreEntity(QUIP))
//						throw new Exception("Warning: Could not remove entry after UpdateId.");
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		[TestCase, Description("QueryUpdateId Valid: procIndex match UpdateId proc 3")]
			class Query_UpdateId_Valid_ProcIndex_Match_3 : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateIdParams QUIP = new QueryUpdateIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUIP,3))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				GetEntityId(ref QUIP);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QUIP.titleId,QUIP.datasetId);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdateId(QUIP.titleId,QUIP.webId,QUIP.gamerTag,QUIP.teamName,QUIP.datasetId,QUIP.procIndex,QUIP.entityId,QUIP.attributes);

					if (!VerifyUpdateId(QUIP,nRecords,dtTestStart))
						throw new Exception("Verification failed.");

//					if (!RestoreEntity(QUIP))
//						throw new Exception("Warning: Could not remove entry after UpdateId.");
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		// Negative test cases

		[TestCase, Description("QueryUpdateId Invalid: partner with read-only access")]
			class Query_UpdateId_Invalid_ReadOnly_Partner : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateIdParams QUIP = new QueryUpdateIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				GetEntityId(ref QUIP);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QUIP.titleId,QUIP.datasetId);

				WCQuery wc = new WCQuery(Global.XEnv.GetVirtualInterface(VirtualInterface.wcquery), new RequestInfo("asschw"));
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdateId(QUIP.titleId,QUIP.webId,QUIP.gamerTag,QUIP.teamName,QUIP.datasetId,QUIP.procIndex,QUIP.entityId,QUIP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Partner:asschw not allowed to access TitleID:"+Hexer.tohex(QUIP.titleId)))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryUpdateId Invalid: unknown titleId")]
			class Query_UpdateId_Invalid_Unknown_Title : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateIdParams QUIP = new QueryUpdateIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				GetEntityId(ref QUIP);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QUIP.titleId,QUIP.datasetId);

				// set titleId
				QUIP.titleId = QueryWidgetCommon.TITLEID_NOT_EXIST;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdateId(QUIP.titleId,QUIP.webId,QUIP.gamerTag,QUIP.teamName,QUIP.datasetId,QUIP.procIndex,QUIP.entityId,QUIP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Partner:DebugPartner not allowed to access TitleID:"+Hexer.tohex(QUIP.titleId)))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryUpdateId Invalid: titleId MAX_UINT32")]
			class Query_UpdateId_Invalid_Title_Max : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateIdParams QUIP = new QueryUpdateIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				GetEntityId(ref QUIP);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QUIP.titleId,QUIP.datasetId);

				// set titleId
				QUIP.titleId = UInt32.MaxValue;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdateId(QUIP.titleId,QUIP.webId,QUIP.gamerTag,QUIP.teamName,QUIP.datasetId,QUIP.procIndex,QUIP.entityId,QUIP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Partner:DebugPartner not allowed to access TitleID:"+Hexer.tohex(QUIP.titleId)))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryUpdateId Invalid: titleId doesn't support Query Service")]
			class Query_UpdateId_Invalid_Title_Unsupported : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateIdParams QUIP = new QueryUpdateIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				GetEntityId(ref QUIP);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QUIP.titleId,QUIP.datasetId);

				// set titleId
				QUIP.titleId = QueryWidgetCommon.TITLEID_NO_QUERY;
				QUIP.teamName = "";

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdateId(QUIP.titleId,QUIP.webId,QUIP.gamerTag,QUIP.teamName,QUIP.datasetId,QUIP.procIndex,QUIP.entityId,QUIP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryUpdateId Invalid: titleId doesn't support UpdateId")]
			class Query_UpdateId_Invalid_UpdateId_Unsupported : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateIdParams QUIP = new QueryUpdateIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				GetEntityId(ref QUIP);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QUIP.titleId,QUIP.datasetId);

				// set titleId
				QUIP.datasetId = 2;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdateId(QUIP.titleId,QUIP.webId,QUIP.gamerTag,QUIP.teamName,QUIP.datasetId,QUIP.procIndex,QUIP.entityId,QUIP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QUIP.titleId,QUIP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryUpdateId Invalid: webId null")]
			class Query_UpdateId_Invalid_WebId_Null : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateIdParams QUIP = new QueryUpdateIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				GetEntityId(ref QUIP);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QUIP.titleId,QUIP.datasetId);

				// set webId
				QUIP.webId = null;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdateId(QUIP.titleId,QUIP.webId,QUIP.gamerTag,QUIP.teamName,QUIP.datasetId,QUIP.procIndex,QUIP.entityId,QUIP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Bad Passport web ID, null not allowed"))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QUIP.titleId,QUIP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryUpdateId Invalid: webId doesn't exist")]
			class Query_UpdateId_Invalid_WebId_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateIdParams QUIP = new QueryUpdateIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				GetEntityId(ref QUIP);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QUIP.titleId,QUIP.datasetId);

				// set webId
				QUIP.webId = QueryWidgetCommon.WEBID_NOT_EXIST;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdateId(QUIP.titleId,QUIP.webId,QUIP.gamerTag,QUIP.teamName,QUIP.datasetId,QUIP.procIndex,QUIP.entityId,QUIP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("(webID,GamerTag) pair ("+Hexer.tohex(QUIP.webId,true)+","+QUIP.gamerTag+") is not linked in our system"))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QUIP.titleId,QUIP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryUpdateId Invalid: webId/gamerTag mismatch")]
			class Query_UpdateId_Invalid_WebId_GamerTag_Mismatch : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateIdParams QUIP = new QueryUpdateIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				GetEntityId(ref QUIP);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QUIP.titleId,QUIP.datasetId);

				// set webId
				QUIP.webId = QueryWidgetCommon.WEBID_NO_MATCH;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdateId(QUIP.titleId,QUIP.webId,QUIP.gamerTag,QUIP.teamName,QUIP.datasetId,QUIP.procIndex,QUIP.entityId,QUIP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("(webID,GamerTag) pair ("+Hexer.tohex(QUIP.webId,true)+","+QUIP.gamerTag+") is not linked in our system"))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QUIP.titleId,QUIP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryUpdateId Invalid: webId too short")]
			class Query_UpdateId_Invalid_WebId_Too_Short : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateIdParams QUIP = new QueryUpdateIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				GetEntityId(ref QUIP);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QUIP.titleId,QUIP.datasetId);

				// set webId
				QUIP.webId = QueryWidgetCommon.WEBID_TOO_SHORT;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdateId(QUIP.titleId,QUIP.webId,QUIP.gamerTag,QUIP.teamName,QUIP.datasetId,QUIP.procIndex,QUIP.entityId,QUIP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Bad Passport web ID, length is "+QUIP.webId.Length.ToString()))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QUIP.titleId,QUIP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryUpdateId Invalid: webId too long")]
			class Query_UpdateId_Invalid_WebId_Too_Long : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateIdParams QUIP = new QueryUpdateIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				GetEntityId(ref QUIP);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QUIP.titleId,QUIP.datasetId);

				// set webId
				QUIP.webId = QueryWidgetCommon.WEBID_TOO_LONG;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdateId(QUIP.titleId,QUIP.webId,QUIP.gamerTag,QUIP.teamName,QUIP.datasetId,QUIP.procIndex,QUIP.entityId,QUIP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Bad Passport web ID, length is "+QUIP.webId.Length.ToString()))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QUIP.titleId,QUIP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryUpdateId Invalid: VERY long webId")]
			class Query_UpdateId_Invalid_WebId_VERY_long : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateIdParams QUIP = new QueryUpdateIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				QUIP.webId = new byte[999999];
				for (int i=0; i<999999; i++)
				{
					QUIP.webId[i] = (byte)(i%16);
				}

				uint nRecords = QueryWidgetCommon.GetNumRecords(QUIP.titleId,QUIP.datasetId);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdateId(QUIP.titleId,QUIP.webId,QUIP.gamerTag,QUIP.teamName,QUIP.datasetId,QUIP.procIndex,QUIP.entityId,QUIP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Bad Passport web ID, length is 999999"))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QUIP.titleId,QUIP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryUpdateId Invalid: gamerTag null")]
			class Query_UpdateId_Invalid_GamerTag_Null : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateIdParams QUIP = new QueryUpdateIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				GetEntityId(ref QUIP);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QUIP.titleId,QUIP.datasetId);

				// set gamerTag
				QUIP.gamerTag = null;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdateId(QUIP.titleId,QUIP.webId,QUIP.gamerTag,QUIP.teamName,QUIP.datasetId,QUIP.procIndex,QUIP.entityId,QUIP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Bad GamerTag provided, null not allowed"))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QUIP.titleId,QUIP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryUpdateId Invalid: gamerTag empty string")]
			class Query_UpdateId_Invalid_GamerTag_Empty : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateIdParams QUIP = new QueryUpdateIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				GetEntityId(ref QUIP);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QUIP.titleId,QUIP.datasetId);

				// set gamerTag
				QUIP.gamerTag = "";

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdateId(QUIP.titleId,QUIP.webId,QUIP.gamerTag,QUIP.teamName,QUIP.datasetId,QUIP.procIndex,QUIP.entityId,QUIP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("(webID,GamerTag) pair ("+Hexer.tohex(QUIP.webId,true)+","+QUIP.gamerTag+") is not linked in our system"))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QUIP.titleId,QUIP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryUpdateId Invalid: gamerTag padded with spaces")]
			class Query_UpdateId_Invalid_GamerTag_Padded : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateIdParams QUIP = new QueryUpdateIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				GetEntityId(ref QUIP);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QUIP.titleId,QUIP.datasetId);

				// pad gamerTag with space at end
				QUIP.gamerTag += " ";

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					// try gamerTag padded at end
					wc.WidgetUpdateId(QUIP.titleId,QUIP.webId,QUIP.gamerTag,QUIP.teamName,QUIP.datasetId,QUIP.procIndex,QUIP.entityId,QUIP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("(webID,GamerTag) pair ("+Hexer.tohex(QUIP.webId,true)+","+QUIP.gamerTag+") is not linked in our system"))
					{
						ResultCode = TEST_RESULTS.FAILED;
						return;
					}

					if (!QueryWidgetCommon.VerifyNoChange(QUIP.titleId,QUIP.datasetId,dtTestStart))
					{
						ResultCode = TEST_RESULTS.FAILED;
						return;
					}

					try
					{
						// try gamerTag padded at beginning
						QUIP.gamerTag = " " + QUIP.gamerTag.Trim();
						wc.WidgetUpdateId(QUIP.titleId,QUIP.webId,QUIP.gamerTag,QUIP.teamName,QUIP.datasetId,QUIP.procIndex,QUIP.entityId,QUIP.attributes);
					}
					catch (Exception ex)
					{
						if (!ex.Message.EndsWith("(webID,GamerTag) pair ("+Hexer.tohex(QUIP.webId,true)+","+QUIP.gamerTag+") is not linked in our system"))
							ResultCode = TEST_RESULTS.FAILED;

						if (!QueryWidgetCommon.VerifyNoChange(QUIP.titleId,QUIP.datasetId,dtTestStart))
							ResultCode = TEST_RESULTS.FAILED;
						return;
					}
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryUpdateId Invalid: gamerTag too long")]
			class Query_UpdateId_Invalid_GamerTag_Too_Long : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateIdParams QUIP = new QueryUpdateIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				GetEntityId(ref QUIP);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QUIP.titleId,QUIP.datasetId);

				// set gamerTag
				QUIP.gamerTag = QueryWidgetCommon.GAMERTAG_TOO_LONG;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdateId(QUIP.titleId,QUIP.webId,QUIP.gamerTag,QUIP.teamName,QUIP.datasetId,QUIP.procIndex,QUIP.entityId,QUIP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("(webID,GamerTag) pair ("+Hexer.tohex(QUIP.webId,true)+","+QUIP.gamerTag+") is not linked in our system"))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QUIP.titleId,QUIP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}


		[TestCase, Description("QueryUpdateId Invalid: user/team mismatch")]
			class Query_UpdateId_Invalid_User_Team_Mismatch : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateIdParams QUIP = new QueryUpdateIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				GetEntityId(ref QUIP);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QUIP.titleId,QUIP.datasetId);

				// set teamName
				QUIP.teamName = QueryWidgetCommon.TEAMNAME_NO_MATCH;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdateId(QUIP.titleId,QUIP.webId,QUIP.gamerTag,QUIP.teamName,QUIP.datasetId,QUIP.procIndex,QUIP.entityId,QUIP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("User "+QUIP.gamerTag+" could not be validated as a member of team "+QUIP.teamName+" in title "+Hexer.tohex(QUIP.titleId).ToLower()))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QUIP.titleId,QUIP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryUpdateId Invalid: teamName doesn't exist")]
			class Query_UpdateId_Invalid_teamName_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateIdParams QUIP = new QueryUpdateIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				GetEntityId(ref QUIP);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QUIP.titleId,QUIP.datasetId);

				// set teamName
				QUIP.teamName = QueryWidgetCommon.TEAMNAME_NOT_EXIST;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdateId(QUIP.titleId,QUIP.webId,QUIP.gamerTag,QUIP.teamName,QUIP.datasetId,QUIP.procIndex,QUIP.entityId,QUIP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Team "+QUIP.teamName+" could not be found in the team cache for titleId "+Hexer.tohex(QUIP.titleId).ToLower()+" aborting."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QUIP.titleId,QUIP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryUpdateId Invalid: teamName too long")]
			class Query_UpdateId_Invalid_TeamName_Too_Long : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateIdParams QUIP = new QueryUpdateIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				GetEntityId(ref QUIP);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QUIP.titleId,QUIP.datasetId);

				// set teamName
				QUIP.teamName = QueryWidgetCommon.TEAMNAME_TOO_LONG;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdateId(QUIP.titleId,QUIP.webId,QUIP.gamerTag,QUIP.teamName,QUIP.datasetId,QUIP.procIndex,QUIP.entityId,QUIP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Team "+QUIP.teamName+" could not be found in the team cache for titleId "+Hexer.tohex(QUIP.titleId).ToLower()+" aborting."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QUIP.titleId,QUIP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryUpdateId Invalid: datasetId 0")]
			class Query_UpdateId_Invalid_DatasetId_0 : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateIdParams QUIP = new QueryUpdateIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				GetEntityId(ref QUIP);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QUIP.titleId,QUIP.datasetId);

				// set datasetId
				QUIP.datasetId = 0;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdateId(QUIP.titleId,QUIP.webId,QUIP.gamerTag,QUIP.teamName,QUIP.datasetId,QUIP.procIndex,QUIP.entityId,QUIP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryUpdateId Invalid: datasetId 2")]
			class Query_UpdateId_Invalid_DatasetId_2 : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateIdParams QUIP = new QueryUpdateIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				GetEntityId(ref QUIP);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QUIP.titleId,QUIP.datasetId);

				// set datasetId
				QUIP.datasetId = 2;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdateId(QUIP.titleId,QUIP.webId,QUIP.gamerTag,QUIP.teamName,QUIP.datasetId,QUIP.procIndex,QUIP.entityId,QUIP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;

					if (QUIP.titleId != QueryWidgetCommon.QUERY_TITLE_ID && !QueryWidgetCommon.VerifyNoChange(QUIP.titleId,QUIP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryUpdateId Invalid: datasetId 3")]
			class Query_UpdateId_Invalid_DatasetId_3 : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateIdParams QUIP = new QueryUpdateIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				GetEntityId(ref QUIP);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QUIP.titleId,QUIP.datasetId);

				// set datasetId
				QUIP.datasetId = 3;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdateId(QUIP.titleId,QUIP.webId,QUIP.gamerTag,QUIP.teamName,QUIP.datasetId,QUIP.procIndex,QUIP.entityId,QUIP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;

					if (QUIP.titleId != QueryWidgetCommon.QUERY_TITLE_ID && !QueryWidgetCommon.VerifyNoChange(QUIP.titleId,QUIP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryUpdateId Invalid: datasetId MAX_UINT32")]
			class Query_UpdateId_Invalid_DatasetId_Max : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateIdParams QUIP = new QueryUpdateIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				GetEntityId(ref QUIP);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QUIP.titleId,QUIP.datasetId);

				// set datasetId
				QUIP.datasetId = UInt32.MaxValue;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdateId(QUIP.titleId,QUIP.webId,QUIP.gamerTag,QUIP.teamName,QUIP.datasetId,QUIP.procIndex,QUIP.entityId,QUIP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryUpdateId Invalid: procIndex MAX_UINT32")]
			class Query_UpdateId_Invalid_ProcIndex_Max : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateIdParams QUIP = new QueryUpdateIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				GetEntityId(ref QUIP);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QUIP.titleId,QUIP.datasetId);

				// set procIndex
				QUIP.procIndex = UInt32.MaxValue;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdateId(QUIP.titleId,QUIP.webId,QUIP.gamerTag,QUIP.teamName,QUIP.datasetId,QUIP.procIndex,QUIP.entityId,QUIP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QUIP.titleId,QUIP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryUpdateId Invalid: procIndex off by 1")]
			class Query_UpdateId_Invalid_ProcIndex_Off_By_One : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateIdParams QUIP = new QueryUpdateIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				GetEntityId(ref QUIP);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QUIP.titleId,QUIP.datasetId);

				// set procIndex
				QUIP.procIndex++;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdateId(QUIP.titleId,QUIP.webId,QUIP.gamerTag,QUIP.teamName,QUIP.datasetId,QUIP.procIndex,QUIP.entityId,QUIP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QUIP.titleId,QUIP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

/*		[TestCase, Description("QueryUpdateId Invalid: procIndex doesn't exist")]
			class Query_UpdateId_Invalid_ProcIndex_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateIdParams QUIP = new QueryUpdateIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				GetEntityId(ref QUIP);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QUIP.titleId,QUIP.datasetId);

				// set procIndex
				QUIP.procIndex = QueryWidgetCommon.PROCINDEX_NOT_EXIST;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdateId(QUIP.titleId,QUIP.webId,QUIP.gamerTag,QUIP.teamName,QUIP.datasetId,QUIP.procIndex,QUIP.entityId,QUIP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QUIP.titleId,QUIP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}
*/
		[TestCase, Description("QueryUpdateId Invalid: entityId doesn't match owner")]
			class Query_UpdateId_Invalid_Owner_EntityId_Mismatch : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateIdParams QUIP = new QueryUpdateIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				GetEntityId(ref QUIP);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QUIP.titleId,QUIP.datasetId);

				// use different owner
				QUIP.gamerTag = "webuser0";
				QUIP.webId = BitConverter.GetBytes(562949953420287);
				QUIP.teamName = "";

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdateId(QUIP.titleId,QUIP.webId,QUIP.gamerTag,QUIP.teamName,QUIP.datasetId,QUIP.procIndex,QUIP.entityId,QUIP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The user tried to update or delete an entity that he does not own."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QUIP.titleId,QUIP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryUpdateId Invalid: entityId doesn't exist")]
			class Query_UpdateId_Invalid_EntityId_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateIdParams QUIP = new QueryUpdateIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				GetEntityId(ref QUIP);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QUIP.titleId,QUIP.datasetId);

				// use invalid entityId
				QUIP.entityId = UInt64.MaxValue;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdateId(QUIP.titleId,QUIP.webId,QUIP.gamerTag,QUIP.teamName,QUIP.datasetId,QUIP.procIndex,QUIP.entityId,QUIP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The requested entity does not exist in the dataset specified."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QUIP.titleId,QUIP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryUpdateId Invalid: entityId 0")]
			class Query_UpdateId_Invalid_EntityId_0 : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateIdParams QUIP = new QueryUpdateIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set entityId
				QUIP.entityId = 0;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdateId(QUIP.titleId,QUIP.webId,QUIP.gamerTag,QUIP.teamName,QUIP.datasetId,QUIP.procIndex,QUIP.entityId,QUIP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The requested entity does not exist in the dataset specified."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QUIP.titleId,QUIP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryUpdateId Invalid: entityId MAX_UINT64")]
			class Query_UpdateId_Invalid_EntityId_Max : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateIdParams QUIP = new QueryUpdateIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				QUIP.entityId = UInt64.MaxValue;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdateId(QUIP.titleId,QUIP.webId,QUIP.gamerTag,QUIP.teamName,QUIP.datasetId,QUIP.procIndex,QUIP.entityId,QUIP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The requested entity does not exist in the dataset specified."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QUIP.titleId,QUIP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryUpdateId Invalid: attributes null")]
			class Query_UpdateId_Invalid_Attrib_Null : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateIdParams QUIP = new QueryUpdateIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				GetEntityId(ref QUIP);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QUIP.titleId,QUIP.datasetId);

				QUIP.attributes = null;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdateId(QUIP.titleId,QUIP.webId,QUIP.gamerTag,QUIP.teamName,QUIP.datasetId,QUIP.procIndex,QUIP.entityId,QUIP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Object reference not set to an instance of an object."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QUIP.titleId,QUIP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryUpdateId Invalid: too few attributes")]
			class Query_UpdateId_Invalid_Attrib_Too_Short : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateIdParams QUIP = new QueryUpdateIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				GetEntityId(ref QUIP);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QUIP.titleId,QUIP.datasetId);

				// Update attribute from end of array
				QueryAttribute [] QAtooshort = new QueryAttribute[QUIP.attributes.Length-1];
				Array.Copy(QUIP.attributes,QAtooshort,QAtooshort.Length);
				QUIP.attributes = QAtooshort;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdateId(QUIP.titleId,QUIP.webId,QUIP.gamerTag,QUIP.teamName,QUIP.datasetId,QUIP.procIndex,QUIP.entityId,QUIP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("An unexpected attribute passed to the method caused a database error."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QUIP.titleId,QUIP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryUpdateId Invalid: too many attributes")]
			class Query_UpdateId_Invalid_Attrib_Too_Long : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateIdParams QUIP = new QueryUpdateIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				GetEntityId(ref QUIP);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QUIP.titleId,QUIP.datasetId);

				// add valid attribute at end of array
				QueryAttribute [] QAtoolong = new QueryAttribute[QUIP.attributes.Length+1];
				QUIP.attributes.CopyTo(QAtoolong,0);
				QAtoolong[QAtoolong.Length-1] = new QueryAttribute();
				QAtoolong[QAtoolong.Length-1].Id = 2097157;
				QAtoolong[QAtoolong.Length-1].Value = Hexer.unhex("123456789");
				QUIP.attributes = QAtoolong;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdateId(QUIP.titleId,QUIP.webId,QUIP.gamerTag,QUIP.teamName,QUIP.datasetId,QUIP.procIndex,QUIP.entityId,QUIP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("An unexpected attribute passed to the method caused a database error."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QUIP.titleId,QUIP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryUpdateId Invalid: invalid attributes")]
			class Query_UpdateId_Invalid_Attrib_Invalid : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateIdParams QUIP = new QueryUpdateIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				GetEntityId(ref QUIP);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QUIP.titleId,QUIP.datasetId);

				foreach (QueryAttribute QA in QUIP.attributes)
				{
					// lowest 16 bits of ID represent the actual attrib ID
					// in LiveService\Comps\CompDefs, nothing more than 0x20 defined
					QA.Id += 0x100;		// this will make all IDs invalid
				}

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdateId(QUIP.titleId,QUIP.webId,QUIP.gamerTag,QUIP.teamName,QUIP.datasetId,QUIP.procIndex,QUIP.entityId,QUIP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("An unexpected attribute passed to the method caused a database error."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QUIP.titleId,QUIP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryUpdateId Invalid: entityId/titleId/datasetId mismatch")]
			class Query_UpdateId_Invalid_EntityId_Not_In_Table : TestBase
		{
			protected override void Execute()
			{
				QueryUpdateIdParams QUIP = new QueryUpdateIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QUIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				GetEntityId(ref QUIP);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QUIP.titleId,QUIP.datasetId);

				QUIP.datasetId = 5;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetUpdateId(QUIP.titleId,QUIP.webId,QUIP.gamerTag,QUIP.teamName,QUIP.datasetId,QUIP.procIndex,QUIP.entityId,QUIP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The requested entity does not exist in the dataset specified."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QUIP.titleId,QUIP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Query\test\FuncQueryRemoveId.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Threading;
using System.IO;
using System.Xml;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web;
using ServerTestFramework.Web.Query;
using xonline.common.config;

namespace QueryWidget
{
	[TestGroup]
	public class FuncQueryRemoveId : TestNode
	{
		// struct to hold input values to the RemoveId method
		struct QueryRemoveIdParams
		{
			public System.UInt32 titleId;
			public System.Byte[] webId;
			public string gamerTag;
			public string teamName;
			public System.UInt32 datasetId;
			public System.UInt64 entityId;
		}

		/// <summary>
		/// function that uses XML file to return valid parameters
		/// </summary>
		/// <param name="QRIP">struct to fill with parameters for call to RemoveId</param>
		/// <returns>false if any errors parsing XML file, else true</returns>
		static bool GetValidParams(ref QueryRemoveIdParams QRIP)
		{
			return GetValidParams(ref QRIP,false);
		}

		static bool GetValidParams(ref QueryRemoveIdParams QRIP, bool compsTest)
		{
			if (compsTest)
			{
				QRIP.titleId = QueryWidgetCommon.COMPS_TITLE_ID;
				QRIP.datasetId = QueryWidgetCommon.COMPS_DATASET_ID;
				QRIP.gamerTag = QueryWidgetCommon.COMPS_GAMERTAG;
				QRIP.webId = QueryWidgetCommon.COMPS_WEBID;
				QRIP.teamName = QueryWidgetCommon.COMPS_TEAMNAME;
			}
			else
			{
				QRIP.titleId = QueryWidgetCommon.QUERY_TITLE_ID;
				QRIP.datasetId = QueryWidgetCommon.QUERY_DATASET_ID;
				QRIP.gamerTag = QueryWidgetCommon.QUERY_GAMERTAG;
				QRIP.webId = QueryWidgetCommon.QUERY_WEBID;
				QRIP.teamName = QueryWidgetCommon.QUERY_TEAMNAME;
			}

			return true;
		}

		static bool GetEntityId(ref QueryRemoveIdParams QRIP)
		{
			// REM "SELECT [bi_entity_id], [bi_owner_id], [dt_change_datetime], [att_00000001], [att_00100003], [att_00200005] FROM [QueryDB].[dbo].[t_query_dataset_0000b2d2_1]"

			QueryWidgetCommon.FillDBBasedOnAPI(4,0);
			bool bRet = true;

			WCQuery wc = null;
			if (QRIP.gamerTag != null)
				wc = new WCQuery();
			else
			{
				RequestInfo rInfo = new RequestInfo("DebugAdmin");
				wc = new WCQuery(Global.XEnv.GetVirtualInterface(VirtualInterface.wcquery),rInfo);
			}
			try
			{
				// get entityId for QRIP
				QueryAttribute [] attribs;
				if (QRIP.titleId == QueryWidgetCommon.COMPS_TITLE_ID)
				{
					string sql="SELECT bi_entity_id FROM [QueryDB].[dbo].[t_query_dataset_"+Hexer.tohex(QRIP.titleId)+"_"+QRIP.datasetId.ToString("x")+"] WHERE bi_owner_id = "+Convert.ToString(2814749767106559 - 20);
					SqlCommand mySqlCommand = null;
					SqlDataReader myDataReader = null;

					for (int iSql=0; iSql<QueryWidgetCommon.qrySqlConn.Length; iSql++)
					{
						try
						{
							mySqlCommand = new SqlCommand(sql,QueryWidgetCommon.qrySqlConn[iSql]);
							myDataReader = mySqlCommand.ExecuteReader();

							if (!myDataReader.HasRows && iSql < QueryWidgetCommon.qrySqlConn.Length+1)
								continue;

							// get entityId for RemoveId
							if (myDataReader.Read() != false)
								QRIP.entityId = Convert.ToUInt64(myDataReader.GetInt64(0));

							if (myDataReader != null && !myDataReader.IsClosed)
								myDataReader.Close();

							if (0 == QRIP.entityId)
								throw new Exception("entityId = 0");
						}
						catch (Exception e)
						{
							if (QueryWidgetCommon.qrySqlConn[iSql].State != ConnectionState.Open)
								QueryWidgetCommon.qrySqlConn[iSql].Open();
							throw e;
						}
						finally
						{
							if (myDataReader != null && !myDataReader.IsClosed)
								myDataReader.Close();
						}
					}
				}
				else
				{
					attribs = new QueryAttribute[3];
					for (int i=0; i<3; i++)
						attribs[i] = new QueryAttribute();
					attribs[0].Id = 1;
					attribs[0].Value = (long)99999999;
					attribs[1].Id = 1048579;
					attribs[1].Value = (string)"RemoveId will remove this entry in this dataset";
					attribs[2].Id = 2097157;
					attribs[2].Value = Hexer.unhex("2357028490124729572784073042123053709");
					QRIP.entityId = wc.WidgetAdd(QRIP.titleId,QRIP.webId,QRIP.gamerTag,QRIP.teamName,QRIP.datasetId,attribs);
				}

				if (0 == QRIP.entityId)
					throw new Exception("Error: entityId = 0");
			}
			catch (Exception e)
			{
				ConsoleX.WriteLine("SQL error in GetEntityId(): " + e.Message);
				bRet = false;
			}
			System.Threading.Thread.Sleep(2000);
			return bRet;
		}

		/// <summary>
		/// function to ensure RemoveId method worked as expected
		/// </summary>
		/// <param name="QRIP"></param>
		/// <returns></returns>
		static bool VerifyRemoveId(QueryRemoveIdParams QRIP, uint nPrevRecords, DateTime dtTestStart)
		{
			bool bRet = true;

			string sql="SELECT Count(*) FROM [QueryDB].[dbo].[t_query_dataset_"+Hexer.tohex(QRIP.titleId)+"_"+QRIP.datasetId.ToString("x")+"] WHERE bi_entity_id = '"+QRIP.entityId+"'";
			SqlCommand mySqlCommand = null;
			SqlDataReader myDataReader = null;

			for (int iSql=0; iSql<QueryWidgetCommon.qrySqlConn.Length; iSql++)
			{
				try
				{
					// verify entityId removed from dataset
					mySqlCommand = new SqlCommand(sql,QueryWidgetCommon.qrySqlConn[iSql]);
					myDataReader = mySqlCommand.ExecuteReader();

					if (!myDataReader.HasRows && iSql < QueryWidgetCommon.qrySqlConn.Length+1)
						continue;

					// look for matching entry
					if (myDataReader.Read() == false || myDataReader.GetInt32(0) != 0)
						throw new Exception("Found entityId in verification.");

					if (myDataReader != null && !myDataReader.IsClosed)
						myDataReader.Close();

					// verify expected # entries in dataset
					bRet = (nPrevRecords - 1 == QueryWidgetCommon.GetNumRecords(QRIP.titleId,QRIP.datasetId));
				}
				catch (Exception e)
				{
					ConsoleX.WriteLine("Error in VerifyRemoveId: "+e.Message);
					bRet = false;
					if (QueryWidgetCommon.qrySqlConn[iSql].State != ConnectionState.Open)
						QueryWidgetCommon.qrySqlConn[iSql].Open();
				}
				finally
				{
					// Always call Close when done reading.
					if (myDataReader != null && !myDataReader.IsClosed)
						myDataReader.Close();
				}
			}

			// verify no other changes to dataset
			return bRet && QueryWidgetCommon.VerifyNoChange(QRIP.titleId,QRIP.datasetId,dtTestStart);
		}

		// Positive test cases

		[TestCase, Description("QueryRemoveId Valid: basic verify")]
			class Query_RemoveId_Valid_Basic : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveIdParams QRIP = new QueryRemoveIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRIP) || !GetEntityId(ref QRIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				uint nRecords = QueryWidgetCommon.GetNumRecords(QRIP.titleId,QRIP.datasetId);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemoveId(QRIP.titleId,QRIP.webId,QRIP.gamerTag,QRIP.teamName,QRIP.datasetId,QRIP.entityId);

					if (!VerifyRemoveId(QRIP,nRecords,dtTestStart))
						throw new Exception("Verification failed.");
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		[TestCase, Description("QueryRemoveId Valid: basic verify - Partner Query")]
			class Query_RemoveId_Valid_Basic_Partner_Query : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveIdParams QRIP = new QueryRemoveIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRIP))
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				QRIP.gamerTag = null;
				QRIP.teamName = null;
				QRIP.webId = BitConverter.GetBytes(QRIP.titleId);

				if (!GetEntityId(ref QRIP))
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				uint nRecords = QueryWidgetCommon.GetNumRecords(QRIP.titleId,QRIP.datasetId);
				RequestInfo rInfo = new RequestInfo("DebugAdmin");
				WCQuery wc = new WCQuery(Global.XEnv.GetVirtualInterface(VirtualInterface.wcquery),rInfo);
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemoveId(QRIP.titleId,QRIP.webId,QRIP.gamerTag,QRIP.teamName,QRIP.datasetId,QRIP.entityId);

					if (!VerifyRemoveId(QRIP,nRecords,dtTestStart))
						throw new Exception("Verification failed.");
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		[TestCase, Description("QueryRemoveId Valid: teamName null")]
			class Query_RemoveId_Valid_teamName_Null : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveIdParams QRIP = new QueryRemoveIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set teamName
				QRIP.teamName = null;

				if (!GetEntityId(ref QRIP))
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				uint nRecords = QueryWidgetCommon.GetNumRecords(QRIP.titleId,QRIP.datasetId);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemoveId(QRIP.titleId,QRIP.webId,QRIP.gamerTag,QRIP.teamName,QRIP.datasetId,QRIP.entityId);

					if (!VerifyRemoveId(QRIP,nRecords,dtTestStart))
						throw new Exception("Verification failed.");
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		[TestCase, Description("QueryRemoveId Valid: teamName empty")]
			class Query_RemoveId_Valid_teamName_Empty : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveIdParams QRIP = new QueryRemoveIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set teamName
				QRIP.teamName = "";

				if (!GetEntityId(ref QRIP))
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				uint nRecords = QueryWidgetCommon.GetNumRecords(QRIP.titleId,QRIP.datasetId);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemoveId(QRIP.titleId,QRIP.webId,QRIP.gamerTag,QRIP.teamName,QRIP.datasetId,QRIP.entityId);

					if (!VerifyRemoveId(QRIP,nRecords,dtTestStart))
						throw new Exception("Verification failed.");
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		[TestCase, Description("QueryRemoveId Valid: teamName padded with spaces")]
			class Query_RemoveId_Valid_TeamName_Padded : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveIdParams QRIP = new QueryRemoveIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				if (!GetEntityId(ref QRIP))
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				QRIP.teamName += " ";

				uint nRecords = QueryWidgetCommon.GetNumRecords(QRIP.titleId,QRIP.datasetId);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					// try teamName padded at end
					wc.WidgetRemoveId(QRIP.titleId,QRIP.webId,QRIP.gamerTag,QRIP.teamName,QRIP.datasetId,QRIP.entityId);
					if (!VerifyRemoveId(QRIP,nRecords,dtTestStart))
						throw new Exception("Verification failed.");

					// try teamName padded at beginning
					if (!GetEntityId(ref QRIP))
					{
						ResultCode = TEST_RESULTS.FAILED;
						return;
					}
					nRecords = QueryWidgetCommon.GetNumRecords(QRIP.titleId,QRIP.datasetId);
					QRIP.teamName = " " + QRIP.teamName.Trim();
					dtTestStart = QueryWidgetCommon.GetSqlServerTime();

					wc.WidgetRemoveId(QRIP.titleId,QRIP.webId,QRIP.gamerTag,QRIP.teamName,QRIP.datasetId,QRIP.entityId);
					if (!VerifyRemoveId(QRIP,nRecords,dtTestStart))
						throw new Exception("Verification failed.");
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		// Negative test cases

		[TestCase, Description("QueryRemoveId Invalid: try to remove same entityId twice")]
			class Query_RemoveId_Invalid_Remove_Twice : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveIdParams QRIP = new QueryRemoveIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRIP) || !GetEntityId(ref QRIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				uint nRecords = QueryWidgetCommon.GetNumRecords(QRIP.titleId,QRIP.datasetId);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemoveId(QRIP.titleId,QRIP.webId,QRIP.gamerTag,QRIP.teamName,QRIP.datasetId,QRIP.entityId);

					// make second call to RemoveId with same parameters
					wc.WidgetRemoveId(QRIP.titleId,QRIP.webId,QRIP.gamerTag,QRIP.teamName,QRIP.datasetId,QRIP.entityId);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The requested entity does not exist in the dataset specified."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QRIP.titleId,QRIP.datasetId,dtTestStart) ||
						nRecords - 1 != QueryWidgetCommon.GetNumRecords(QRIP.titleId,QRIP.datasetId))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryRemoveId Invalid: partner with read-only access")]
			class Query_RemoveId_Invalid_ReadOnly_Partner : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveIdParams QRIP = new QueryRemoveIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRIP) || !GetEntityId(ref QRIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				WCQuery wc = new WCQuery(Global.XEnv.GetVirtualInterface(VirtualInterface.wcquery), new RequestInfo("asschw"));
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemoveId(QRIP.titleId,QRIP.webId,QRIP.gamerTag,QRIP.teamName,QRIP.datasetId,QRIP.entityId);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Partner:asschw not allowed to access TitleID:"+Hexer.tohex(QRIP.titleId)))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryRemoveId Invalid: unknown titleId")]
			class Query_RemoveId_Invalid_Unknown_Title : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveIdParams QRIP = new QueryRemoveIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRIP) || !GetEntityId(ref QRIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set titleId
				QRIP.titleId = QueryWidgetCommon.TITLEID_NOT_EXIST;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemoveId(QRIP.titleId,QRIP.webId,QRIP.gamerTag,QRIP.teamName,QRIP.datasetId,QRIP.entityId);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Partner:DebugPartner not allowed to access TitleID:"+Hexer.tohex(QRIP.titleId)))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryRemoveId Invalid: titleId MAX_UINT32")]
			class Query_RemoveId_Invalid_Title_Max : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveIdParams QRIP = new QueryRemoveIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRIP) || !GetEntityId(ref QRIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set titleId
				QRIP.titleId = UInt32.MaxValue;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemoveId(QRIP.titleId,QRIP.webId,QRIP.gamerTag,QRIP.teamName,QRIP.datasetId,QRIP.entityId);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Partner:DebugPartner not allowed to access TitleID:"+Hexer.tohex(QRIP.titleId)))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryRemoveId Invalid: titleId doesn't support Query Service")]
			class Query_RemoveId_Invalid_Title_Unsupported : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveIdParams QRIP = new QueryRemoveIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRIP) || !GetEntityId(ref QRIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set titleId
				QRIP.titleId = QueryWidgetCommon.TITLEID_NO_QUERY;
				QRIP.teamName = "";

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemoveId(QRIP.titleId,QRIP.webId,QRIP.gamerTag,QRIP.teamName,QRIP.datasetId,QRIP.entityId);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryRemoveId Invalid: webId null")]
			class Query_RemoveId_Invalid_WebId_Null : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveIdParams QRIP = new QueryRemoveIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRIP) || !GetEntityId(ref QRIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set webId
				QRIP.webId = null;

				uint nRecords = QueryWidgetCommon.GetNumRecords(QRIP.titleId,QRIP.datasetId);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemoveId(QRIP.titleId,QRIP.webId,QRIP.gamerTag,QRIP.teamName,QRIP.datasetId,QRIP.entityId);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Bad Passport web ID, null not allowed"))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QRIP.titleId,QRIP.datasetId,dtTestStart) ||
						nRecords != QueryWidgetCommon.GetNumRecords(QRIP.titleId,QRIP.datasetId))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryRemoveId Invalid: webId doesn't exist")]
			class Query_RemoveId_Invalid_WebId_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveIdParams QRIP = new QueryRemoveIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRIP) || !GetEntityId(ref QRIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set webId
				QRIP.webId = QueryWidgetCommon.WEBID_NOT_EXIST;

				uint nRecords = QueryWidgetCommon.GetNumRecords(QRIP.titleId,QRIP.datasetId);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemoveId(QRIP.titleId,QRIP.webId,QRIP.gamerTag,QRIP.teamName,QRIP.datasetId,QRIP.entityId);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("(webID,GamerTag) pair ("+Hexer.tohex(QRIP.webId,true)+","+QRIP.gamerTag+") is not linked in our system"))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QRIP.titleId,QRIP.datasetId,dtTestStart) ||
						nRecords != QueryWidgetCommon.GetNumRecords(QRIP.titleId,QRIP.datasetId))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryRemoveId Invalid: webId/gamerTag mismatch")]
			class Query_RemoveId_Invalid_WebId_GamerTag_Mismatch : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveIdParams QRIP = new QueryRemoveIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRIP) || !GetEntityId(ref QRIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set webId
				QRIP.webId = QueryWidgetCommon.WEBID_NO_MATCH;

				uint nRecords = QueryWidgetCommon.GetNumRecords(QRIP.titleId,QRIP.datasetId);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemoveId(QRIP.titleId,QRIP.webId,QRIP.gamerTag,QRIP.teamName,QRIP.datasetId,QRIP.entityId);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("(webID,GamerTag) pair ("+Hexer.tohex(QRIP.webId,true)+","+QRIP.gamerTag+") is not linked in our system"))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QRIP.titleId,QRIP.datasetId,dtTestStart) ||
						nRecords != QueryWidgetCommon.GetNumRecords(QRIP.titleId,QRIP.datasetId))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryRemoveId Invalid: webId too short")]
			class Query_RemoveId_Invalid_WebId_Too_Short : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveIdParams QRIP = new QueryRemoveIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRIP) || !GetEntityId(ref QRIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set webId
				QRIP.webId = QueryWidgetCommon.WEBID_TOO_SHORT;

				uint nRecords = QueryWidgetCommon.GetNumRecords(QRIP.titleId,QRIP.datasetId);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemoveId(QRIP.titleId,QRIP.webId,QRIP.gamerTag,QRIP.teamName,QRIP.datasetId,QRIP.entityId);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Bad Passport web ID, length is "+QRIP.webId.Length.ToString()))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QRIP.titleId,QRIP.datasetId,dtTestStart) ||
						nRecords != QueryWidgetCommon.GetNumRecords(QRIP.titleId,QRIP.datasetId))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryRemoveId Invalid: webId too long")]
			class Query_RemoveId_Invalid_WebId_Too_Long : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveIdParams QRIP = new QueryRemoveIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRIP) || !GetEntityId(ref QRIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set webId
				QRIP.webId = QueryWidgetCommon.WEBID_TOO_LONG;

				uint nRecords = QueryWidgetCommon.GetNumRecords(QRIP.titleId,QRIP.datasetId);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemoveId(QRIP.titleId,QRIP.webId,QRIP.gamerTag,QRIP.teamName,QRIP.datasetId,QRIP.entityId);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Bad Passport web ID, length is "+QRIP.webId.Length.ToString()))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QRIP.titleId,QRIP.datasetId,dtTestStart) ||
						nRecords != QueryWidgetCommon.GetNumRecords(QRIP.titleId,QRIP.datasetId))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryRemoveId Invalid: VERY long webId")]
			class Query_RemoveId_Invalid_WebId_VERY_long : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveIdParams QRIP = new QueryRemoveIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRIP) || !GetEntityId(ref QRIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				QRIP.webId = new byte[999999];
				for (int i=0; i<999999; i++)
				{
					QRIP.webId[i] = (byte)(i%16);
				}

				uint nRecords = QueryWidgetCommon.GetNumRecords(QRIP.titleId,QRIP.datasetId);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemoveId(QRIP.titleId,QRIP.webId,QRIP.gamerTag,QRIP.teamName,QRIP.datasetId,QRIP.entityId);
				}
				catch (Exception e)
				{
                    if (!e.Message.EndsWith("Bad Passport web ID, length is 999999"))
                    {
                        Global.RO.Info("expected bad passport exception, got: " + e.Message);
                        ResultCode = TEST_RESULTS.FAILED;
                    }

					if (!QueryWidgetCommon.VerifyNoChange(QRIP.titleId,QRIP.datasetId,dtTestStart) ||
						nRecords != QueryWidgetCommon.GetNumRecords(QRIP.titleId,QRIP.datasetId))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryRemoveId Invalid: gamerTag null")]
			class Query_RemoveId_Invalid_GamerTag_Null : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveIdParams QRIP = new QueryRemoveIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRIP) || !GetEntityId(ref QRIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set gamerTag
				QRIP.gamerTag = null;

				uint nRecords = QueryWidgetCommon.GetNumRecords(QRIP.titleId,QRIP.datasetId);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemoveId(QRIP.titleId,QRIP.webId,QRIP.gamerTag,QRIP.teamName,QRIP.datasetId,QRIP.entityId);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Bad GamerTag provided, null not allowed"))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QRIP.titleId,QRIP.datasetId,dtTestStart) ||
						nRecords != QueryWidgetCommon.GetNumRecords(QRIP.titleId,QRIP.datasetId))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryRemoveId Invalid: gamerTag empty string")]
			class Query_RemoveId_Invalid_GamerTag_Empty : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveIdParams QRIP = new QueryRemoveIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRIP) || !GetEntityId(ref QRIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set gamerTag
				QRIP.gamerTag = "";

				uint nRecords = QueryWidgetCommon.GetNumRecords(QRIP.titleId,QRIP.datasetId);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemoveId(QRIP.titleId,QRIP.webId,QRIP.gamerTag,QRIP.teamName,QRIP.datasetId,QRIP.entityId);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("(webID,GamerTag) pair ("+Hexer.tohex(QRIP.webId,true)+","+QRIP.gamerTag+") is not linked in our system"))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QRIP.titleId,QRIP.datasetId,dtTestStart) ||
						nRecords != QueryWidgetCommon.GetNumRecords(QRIP.titleId,QRIP.datasetId))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryRemoveId Invalid: gamerTag padded with spaces")]
			class Query_RemoveId_Invalid_GamerTag_Padded : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveIdParams QRIP = new QueryRemoveIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRIP) || !GetEntityId(ref QRIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// pad gamerTag with space at end
				QRIP.gamerTag += " ";

				uint nRecords = QueryWidgetCommon.GetNumRecords(QRIP.titleId,QRIP.datasetId);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					// try gamerTag padded at end
					wc.WidgetRemoveId(QRIP.titleId,QRIP.webId,QRIP.gamerTag,QRIP.teamName,QRIP.datasetId,QRIP.entityId);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("(webID,GamerTag) pair ("+Hexer.tohex(QRIP.webId,true)+","+QRIP.gamerTag+") is not linked in our system"))
					{
						ResultCode = TEST_RESULTS.FAILED;
						return;
					}

					if (!QueryWidgetCommon.VerifyNoChange(QRIP.titleId,QRIP.datasetId,dtTestStart) ||
						nRecords != QueryWidgetCommon.GetNumRecords(QRIP.titleId,QRIP.datasetId))
					{
						ResultCode = TEST_RESULTS.FAILED;
						return;
					}

					try
					{
						// try gamerTag padded at beginning
						QRIP.gamerTag = " " + QRIP.gamerTag.Trim();
						wc.WidgetRemoveId(QRIP.titleId,QRIP.webId,QRIP.gamerTag,QRIP.teamName,QRIP.datasetId,QRIP.entityId);
					}
					catch (Exception ex)
					{
						if (!ex.Message.EndsWith("(webID,GamerTag) pair ("+Hexer.tohex(QRIP.webId,true)+","+QRIP.gamerTag+") is not linked in our system"))
							ResultCode = TEST_RESULTS.FAILED;

						if (!QueryWidgetCommon.VerifyNoChange(QRIP.titleId,QRIP.datasetId,dtTestStart) ||
							nRecords != QueryWidgetCommon.GetNumRecords(QRIP.titleId,QRIP.datasetId))
							ResultCode = TEST_RESULTS.FAILED;
						return;
					}
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryRemoveId Invalid: gamerTag too long")]
			class Query_RemoveId_Invalid_GamerTag_Too_Long : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveIdParams QRIP = new QueryRemoveIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRIP) || !GetEntityId(ref QRIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set gamerTag
				QRIP.gamerTag = QueryWidgetCommon.GAMERTAG_TOO_LONG;

				uint nRecords = QueryWidgetCommon.GetNumRecords(QRIP.titleId,QRIP.datasetId);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemoveId(QRIP.titleId,QRIP.webId,QRIP.gamerTag,QRIP.teamName,QRIP.datasetId,QRIP.entityId);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("(webID,GamerTag) pair ("+Hexer.tohex(QRIP.webId,true)+","+QRIP.gamerTag+") is not linked in our system"))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QRIP.titleId,QRIP.datasetId,dtTestStart) ||
						nRecords != QueryWidgetCommon.GetNumRecords(QRIP.titleId,QRIP.datasetId))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryRemoveId Invalid: user/team mismatch")]
			class Query_RemoveId_Invalid_User_Team_Mismatch : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveIdParams QRIP = new QueryRemoveIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRIP) || !GetEntityId(ref QRIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set teamName
				QRIP.teamName = QueryWidgetCommon.TEAMNAME_NO_MATCH;

				uint nRecords = QueryWidgetCommon.GetNumRecords(QRIP.titleId,QRIP.datasetId);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemoveId(QRIP.titleId,QRIP.webId,QRIP.gamerTag,QRIP.teamName,QRIP.datasetId,QRIP.entityId);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("User "+QRIP.gamerTag+" could not be validated as a member of team "+QRIP.teamName+" in title "+Hexer.tohex(QRIP.titleId).ToLower()))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QRIP.titleId,QRIP.datasetId,dtTestStart) ||
						nRecords != QueryWidgetCommon.GetNumRecords(QRIP.titleId,QRIP.datasetId))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryRemoveId Invalid: teamName doesn't exist")]
			class Query_RemoveId_Invalid_teamName_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveIdParams QRIP = new QueryRemoveIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRIP) || !GetEntityId(ref QRIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set teamName
				QRIP.teamName = QueryWidgetCommon.TEAMNAME_NOT_EXIST;

				uint nRecords = QueryWidgetCommon.GetNumRecords(QRIP.titleId,QRIP.datasetId);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemoveId(QRIP.titleId,QRIP.webId,QRIP.gamerTag,QRIP.teamName,QRIP.datasetId,QRIP.entityId);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Team "+QRIP.teamName+" could not be found in the team cache for titleId "+Hexer.tohex(QRIP.titleId).ToLower()+" aborting."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QRIP.titleId,QRIP.datasetId,dtTestStart) ||
						nRecords != QueryWidgetCommon.GetNumRecords(QRIP.titleId,QRIP.datasetId))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryRemoveId Invalid: teamName too long")]
			class Query_RemoveId_Invalid_TeamName_Too_Long : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveIdParams QRIP = new QueryRemoveIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRIP) || !GetEntityId(ref QRIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set teamName
				QRIP.teamName = QueryWidgetCommon.TEAMNAME_TOO_LONG;

				uint nRecords = QueryWidgetCommon.GetNumRecords(QRIP.titleId,QRIP.datasetId);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemoveId(QRIP.titleId,QRIP.webId,QRIP.gamerTag,QRIP.teamName,QRIP.datasetId,QRIP.entityId);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Team "+QRIP.teamName+" could not be found in the team cache for titleId "+Hexer.tohex(QRIP.titleId).ToLower()+" aborting."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QRIP.titleId,QRIP.datasetId,dtTestStart) ||
						nRecords != QueryWidgetCommon.GetNumRecords(QRIP.titleId,QRIP.datasetId))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryRemoveId Invalid: datasetId 0")]
			class Query_RemoveId_Invalid_DatasetId_0 : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveIdParams QRIP = new QueryRemoveIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRIP) || !GetEntityId(ref QRIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set datasetId
				QRIP.datasetId = 0;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemoveId(QRIP.titleId,QRIP.webId,QRIP.gamerTag,QRIP.teamName,QRIP.datasetId,QRIP.entityId);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryRemoveId Invalid: datasetId 3")]
			class Query_RemoveId_Invalid_DatasetId_3 : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveIdParams QRIP = new QueryRemoveIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRIP) || !GetEntityId(ref QRIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set datasetId
				QRIP.datasetId = 3;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemoveId(QRIP.titleId,QRIP.webId,QRIP.gamerTag,QRIP.teamName,QRIP.datasetId,QRIP.entityId);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;

					if (QRIP.titleId != QueryWidgetCommon.QUERY_TITLE_ID && !QueryWidgetCommon.VerifyNoChange(QRIP.titleId,QRIP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryRemoveId Invalid: datasetId MAX_UINT32")]
			class Query_RemoveId_Invalid_DatasetId_Max : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveIdParams QRIP = new QueryRemoveIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRIP) || !GetEntityId(ref QRIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set datasetId
				QRIP.datasetId = UInt32.MaxValue;

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemoveId(QRIP.titleId,QRIP.webId,QRIP.gamerTag,QRIP.teamName,QRIP.datasetId,QRIP.entityId);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryRemoveId Invalid: entityId doesn't match owner")]
			class Query_RemoveId_Invalid_Owner_EntityId_Mismatch : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveIdParams QRIP = new QueryRemoveIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRIP) || !GetEntityId(ref QRIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// change owner
				QRIP.gamerTag = "webuser0";
				QRIP.webId = BitConverter.GetBytes(562949953420287);
				QRIP.teamName = "";

				uint nRecords = QueryWidgetCommon.GetNumRecords(QRIP.titleId,QRIP.datasetId);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemoveId(QRIP.titleId,QRIP.webId,QRIP.gamerTag,QRIP.teamName,QRIP.datasetId,QRIP.entityId);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The user tried to update or delete an entity that he does not own."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QRIP.titleId,QRIP.datasetId,dtTestStart) ||
						nRecords != QueryWidgetCommon.GetNumRecords(QRIP.titleId,QRIP.datasetId))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryRemoveId Invalid: entityId doesn't exist")]
			class Query_RemoveId_Invalid_EntityId_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveIdParams QRIP = new QueryRemoveIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				QRIP.entityId = 100;

				uint nRecords = QueryWidgetCommon.GetNumRecords(QRIP.titleId,QRIP.datasetId);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemoveId(QRIP.titleId,QRIP.webId,QRIP.gamerTag,QRIP.teamName,QRIP.datasetId,QRIP.entityId);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The requested entity does not exist in the dataset specified."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QRIP.titleId,QRIP.datasetId,dtTestStart) ||
						nRecords != QueryWidgetCommon.GetNumRecords(QRIP.titleId,QRIP.datasetId))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryRemoveId Invalid: entityId 0")]
			class Query_RemoveId_Invalid_EntityId_0 : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveIdParams QRIP = new QueryRemoveIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set entityId
				QRIP.entityId = 0;

				uint nRecords = QueryWidgetCommon.GetNumRecords(QRIP.titleId,QRIP.datasetId);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemoveId(QRIP.titleId,QRIP.webId,QRIP.gamerTag,QRIP.teamName,QRIP.datasetId,QRIP.entityId);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The requested entity does not exist in the dataset specified."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QRIP.titleId,QRIP.datasetId,dtTestStart) ||
						nRecords != QueryWidgetCommon.GetNumRecords(QRIP.titleId,QRIP.datasetId))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryRemoveId Invalid: entityId MAX_UINT64")]
			class Query_RemoveId_Invalid_EntityId_Max : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveIdParams QRIP = new QueryRemoveIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// set datasetId
				QRIP.entityId = UInt64.MaxValue;

				uint nRecords = QueryWidgetCommon.GetNumRecords(QRIP.titleId,QRIP.datasetId);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemoveId(QRIP.titleId,QRIP.webId,QRIP.gamerTag,QRIP.teamName,QRIP.datasetId,QRIP.entityId);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The requested entity does not exist in the dataset specified."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QRIP.titleId,QRIP.datasetId,dtTestStart) ||
						nRecords != QueryWidgetCommon.GetNumRecords(QRIP.titleId,QRIP.datasetId))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryRemoveId Invalid: entityId/titleId/datasetId mismatch")]
			class Query_RemoveId_Invalid_EntityId_Not_In_Table : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveIdParams QRIP = new QueryRemoveIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRIP) || !GetEntityId(ref QRIP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				QRIP.datasetId = 5;

				uint nRecords = QueryWidgetCommon.GetNumRecords(QRIP.titleId,QRIP.datasetId);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemoveId(QRIP.titleId,QRIP.webId,QRIP.gamerTag,QRIP.teamName,QRIP.datasetId,QRIP.entityId);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The requested entity does not exist in the dataset specified."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QRIP.titleId,QRIP.datasetId,dtTestStart) ||
						nRecords != QueryWidgetCommon.GetNumRecords(QRIP.titleId,QRIP.datasetId))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryRemoveId Invalid: try to remove a competition")]
			class Query_RemoveId_Invalid_Remove_Comp : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveIdParams QRIP = new QueryRemoveIdParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRIP,true))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				// get entityID
				if (!GetEntityId(ref QRIP))
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				uint nRecords = QueryWidgetCommon.GetNumRecords(QRIP.titleId,QRIP.datasetId);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemoveId(QRIP.titleId,QRIP.webId,QRIP.gamerTag,QRIP.teamName,QRIP.datasetId,QRIP.entityId);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The specified source (client) is not permitted to execute this method."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QRIP.titleId,QRIP.datasetId,dtTestStart) ||
						nRecords != QueryWidgetCommon.GetNumRecords(QRIP.titleId,QRIP.datasetId))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Query\test\dvt\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Query\test\FuncQueryRemove.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Threading;
using System.IO;
using System.Xml;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web;
using ServerTestFramework.Web.Query;
using xonline.common.config;

namespace QueryWidget
{
	[TestGroup]
	public class FuncQueryRemove : TestNode
	{
		// struct to hold input values to the Remove method
		struct QueryRemoveParams
		{
			public System.UInt32 titleId;
			public System.Byte[] webId;
			public string gamerTag;
			public string teamName;
			public System.UInt32 datasetId;
			public System.UInt32 procIndex;
			public QueryAttribute[] attributes;
		}

		/// <summary>
		/// function that uses XML file to return valid parameters
		/// </summary>
		/// <param name="QRP">struct to fill with parameters for call to Remove</param>
		/// <param name="procSel">zero-based short to identify which procIndex to use in the xml.</param>
		/// <returns>false if any errors parsing XML file, else true</returns>
		static bool GetValidParams(ref QueryRemoveParams QRP)
		{
			return GetValidParams(ref QRP,0,false);
		}

		static bool GetValidParams(ref QueryRemoveParams QRP, short procSel)
		{
			return GetValidParams(ref QRP,procSel,false);
		}

		static bool GetValidParams(ref QueryRemoveParams QRP, short procSel, bool compsTest)
		{
			if (compsTest)
			{
				QRP.titleId = QueryWidgetCommon.COMPS_TITLE_ID;
				QRP.datasetId = QueryWidgetCommon.COMPS_DATASET_ID;
				QRP.gamerTag = QueryWidgetCommon.COMPS_GAMERTAG;
				QRP.webId = QueryWidgetCommon.COMPS_WEBID;
				QRP.teamName = QueryWidgetCommon.COMPS_TEAMNAME;
			}
			else
			{
				QRP.titleId = QueryWidgetCommon.QUERY_TITLE_ID;
				QRP.datasetId = QueryWidgetCommon.QUERY_DATASET_ID;
				QRP.gamerTag = QueryWidgetCommon.QUERY_GAMERTAG;
				QRP.webId = QueryWidgetCommon.QUERY_WEBID;
				QRP.teamName = QueryWidgetCommon.QUERY_TEAMNAME;
			}

			XmlDocument parameters = new XmlDocument();
			parameters.Load("QueryWidget.xml");

			try
			{
				XmlNodeList paramNodes = parameters.SelectNodes("/stf/parameters/remove/procIndex");
				if (paramNodes.Count <= procSel)
					throw new Exception();
				QRP.procIndex = Convert.ToUInt32(paramNodes[procSel].InnerText);

				paramNodes = parameters.SelectNodes("/stf/parameters/remove/attributes");
				if (paramNodes.Count <= procSel)
					throw new Exception();
				QRP.attributes = new QueryAttribute[paramNodes[procSel].ChildNodes.Count];
				for (int i=0; i<paramNodes[procSel].ChildNodes.Count; i++)
				{
					if (paramNodes[procSel].ChildNodes[i].Name != "attrib")
						throw new Exception();

					QRP.attributes[i] = new QueryAttribute();

					QRP.attributes[i].Id = System.UInt32.Parse(paramNodes[procSel].ChildNodes[i].Attributes["a_id"].Value,System.Globalization.NumberStyles.AllowHexSpecifier);
					switch (QRP.attributes[i].Id)
					{
						case 1:
							QRP.attributes[i].Value = (long)Convert.ToInt32(paramNodes[procSel].ChildNodes[i].Attributes["a_value"].Value);
							break;
						case 1048579:
							QRP.attributes[i].Value = paramNodes[procSel].ChildNodes[i].Attributes["a_value"].Value;
							break;
						case 2097157:
							QRP.attributes[i].Value = Hexer.unhex(paramNodes[procSel].ChildNodes[i].Attributes["a_value"].Value);
							break;
					}
				}
			}
			catch (Exception)
			{
				ConsoleX.WriteLine("Invalid parameter element found in xml.");
				return false;
			}
			return true;
		}

		/// <summary>
		/// function to determine how many records should be affected by a call to Remove through the Query Widget
		/// </summary>
		/// <param name="QRP"></param>
		/// <returns></returns>
		static uint GetMatchingRecords(QueryRemoveParams QRP)
		{
			System.Int64 ownerId = (long)QueryWidgetCommon.QUERY_TEAMID;
			if (QRP.gamerTag == null)
				ownerId = QRP.titleId;
			else if (QRP.teamName == null || QRP.teamName == "")
				ownerId = 2814749767106559 - Convert.ToInt64(QRP.gamerTag.Substring(7));	// gamerTags are of format webuserX (X = 0 thru 1023) and PUID starts at 2814749767106559 going down

			// set up database query
			uint nRecordsAffected = 0;
			string sql = "";
			switch (QRP.procIndex)
			{
				case 5:
					sql="SELECT Count(*) FROM [QueryDB].[dbo].[t_query_dataset_"+Hexer.tohex(QRP.titleId)+"_"+QRP.datasetId.ToString("x")+"] WHERE att_00000001 = "+(long)QRP.attributes[0].Value+" AND att_00200005 = 0x"+Hexer.tohex((byte[])QRP.attributes[1].Value)+" AND bi_owner_id = "+ownerId;
					break;
				case 10:
					sql="SELECT Count(*) FROM [QueryDB].[dbo].[t_query_dataset_"+Hexer.tohex(QRP.titleId)+"_"+QRP.datasetId.ToString("x")+"] WHERE att_00000001 = "+(long)QRP.attributes[0].Value+" AND att_00100003 = '"+QRP.attributes[1].Value+"' AND att_00200005 = 0x"+Hexer.tohex((byte[])QRP.attributes[2].Value)+" AND bi_owner_id = "+ownerId;
					break;
				case 15:
					sql="SELECT Count(*) FROM [QueryDB].[dbo].[t_query_dataset_"+Hexer.tohex(QRP.titleId)+"_"+QRP.datasetId.ToString("x")+"] WHERE att_00000001 = "+(long)QRP.attributes[0].Value+" AND bi_owner_id = "+ownerId;
					break;
			}
			SqlCommand mySqlCommand = null;
			SqlDataReader myDataReader = null;

			for (int iSql=0; iSql<QueryWidgetCommon.qrySqlConn.Length; iSql++)
			{
				try
				{
					mySqlCommand = new SqlCommand(sql,QueryWidgetCommon.qrySqlConn[iSql]);
					myDataReader = mySqlCommand.ExecuteReader();

					if (!myDataReader.HasRows && iSql < QueryWidgetCommon.qrySqlConn.Length+1)
						continue;

					// get # matching records
					if (myDataReader.Read() != false)
						nRecordsAffected += (uint)myDataReader.GetInt32(0);

					if (myDataReader != null && !myDataReader.IsClosed)
						myDataReader.Close();
				}
				catch (Exception e)
				{
					ConsoleX.WriteLine("SQL error in GetMatchingRecords(): " + e.Message);
					if (QueryWidgetCommon.qrySqlConn[iSql].State != ConnectionState.Open)
						QueryWidgetCommon.qrySqlConn[iSql].Open();
				}
				finally
				{
					// Always call Close when done reading.
					if (myDataReader != null && !myDataReader.IsClosed)
						myDataReader.Close();
				}
			}

			return nRecordsAffected;
		}

		/// <summary>
		/// function to ensure Remove method worked as expected
		/// </summary>
		/// <param name="QRP"></param>
		/// <returns></returns>
		static bool VerifyRemove(QueryRemoveParams QRP, uint nPrevRecords, uint nExpectedRecords, DateTime dtTestStart)
		{
			// verify correct entities were removed
			if (0 != GetMatchingRecords(QRP) ||
				nPrevRecords - nExpectedRecords != QueryWidgetCommon.GetNumRecords(QRP.titleId,QRP.datasetId))
				return false;

			// verify no other changes to dataset
			return QueryWidgetCommon.VerifyNoChange(QRP.titleId,QRP.datasetId,dtTestStart);
		}

		// Positive test cases

		[TestCase, Description("QueryRemove Valid: basic verify")]
			class Query_Remove_Valid_Basic : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveParams QRP = new QueryRemoveParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				QueryWidgetCommon.FillDBBasedOnAPI(3,0);

				uint nRecords = QueryWidgetCommon.GetNumRecords(QRP.titleId,QRP.datasetId);
				uint nExpectedRecords = GetMatchingRecords(QRP);
				if (0 == nRecords || 0 == nExpectedRecords)
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemove(QRP.titleId,QRP.webId,QRP.gamerTag,QRP.teamName,QRP.datasetId,QRP.procIndex,QRP.attributes);

					if (!VerifyRemove(QRP,nRecords,nExpectedRecords,dtTestStart))
						throw new Exception("Verification failed.");

//					if (!RestoreRecords(QRP,nExpectedRecords))
//						ConsoleX.WriteLine("Warning: Could not restore records after Remove testing.");
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		[TestCase, Description("QueryRemove Valid: basic verify - Partner Query")]
			class Query_Remove_Valid_Basic_Partner_Query : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveParams QRP = new QueryRemoveParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				QRP.gamerTag = null;
				QRP.teamName = null;
				QRP.webId = BitConverter.GetBytes(QRP.titleId);
				QRP.attributes[0].Value = (long)8;
				QRP.attributes[1].Value = Hexer.unhex("DEF");
				QueryWidgetCommon.FillDBBasedOnAPI(3,3);

				uint nRecords = QueryWidgetCommon.GetNumRecords(QRP.titleId,QRP.datasetId);
				uint nExpectedRecords = GetMatchingRecords(QRP);
				if (0 == nRecords || 0 == nExpectedRecords)
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				RequestInfo rInfo = new RequestInfo("DebugAdmin");
				WCQuery wc = new WCQuery(Global.XEnv.GetVirtualInterface(VirtualInterface.wcquery),rInfo);
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemove(QRP.titleId,QRP.webId,QRP.gamerTag,QRP.teamName,QRP.datasetId,QRP.procIndex,QRP.attributes);

					if (!VerifyRemove(QRP,nRecords,nExpectedRecords,dtTestStart))
						throw new Exception("Verification failed.");

//					if (!RestoreRecords(QRP,nExpectedRecords))
//						ConsoleX.WriteLine("Warning: Could not restore records after Remove testing.");
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		[TestCase, Description("QueryRemove Valid: teamName null")]
			class Query_Remove_Valid_TeamName_Null : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveParams QRP = new QueryRemoveParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				// set teamName
				QRP.teamName = null;

				QueryWidgetCommon.FillDBBasedOnAPI(3,0);

				uint nRecords = QueryWidgetCommon.GetNumRecords(QRP.titleId,QRP.datasetId);
				uint nExpectedRecords = GetMatchingRecords(QRP);
				if (0 == nRecords || 0 == nExpectedRecords)
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemove(QRP.titleId,QRP.webId,QRP.gamerTag,QRP.teamName,QRP.datasetId,QRP.procIndex,QRP.attributes);

					if (!VerifyRemove(QRP,nRecords,nExpectedRecords,dtTestStart))
						throw new Exception("Verification failed.");
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		[TestCase, Description("QueryRemove Valid: teamName empty")]
			class Query_Remove_Valid_TeamName_Empty : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveParams QRP = new QueryRemoveParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				// set teamName
				QRP.teamName = "";

				QueryWidgetCommon.FillDBBasedOnAPI(3,0);

				uint nRecords = QueryWidgetCommon.GetNumRecords(QRP.titleId,QRP.datasetId);
				uint nExpectedRecords = GetMatchingRecords(QRP);
				if (0 == nRecords || 0 == nExpectedRecords)
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemove(QRP.titleId,QRP.webId,QRP.gamerTag,QRP.teamName,QRP.datasetId,QRP.procIndex,QRP.attributes);

					if (!VerifyRemove(QRP,nRecords,nExpectedRecords,dtTestStart))
						throw new Exception("Verification failed.");
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		[TestCase, Description("QueryRemove Valid: teamName padded with spaces")]
			class Query_Remove_Valid_TeamName_Padded : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveParams QRP = new QueryRemoveParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				QueryWidgetCommon.FillDBBasedOnAPI(3,0);

				uint nRecords = QueryWidgetCommon.GetNumRecords(QRP.titleId,QRP.datasetId);
				uint nExpectedRecords = GetMatchingRecords(QRP);
				if (0 == nRecords || 0 == nExpectedRecords)
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				QRP.teamName += " ";
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					// try teamName padded at end
					wc.WidgetRemove(QRP.titleId,QRP.webId,QRP.gamerTag,QRP.teamName,QRP.datasetId,QRP.procIndex,QRP.attributes);
					if (!VerifyRemove(QRP,nRecords,nExpectedRecords,dtTestStart))
						throw new Exception("Verification failed.");

					// try teamName padded at beginning
					QueryWidgetCommon.FillDBBasedOnAPI(3,0);
					nRecords = QueryWidgetCommon.GetNumRecords(QRP.titleId,QRP.datasetId);
					nExpectedRecords = GetMatchingRecords(QRP);
					if (0 == nRecords || 0 == nExpectedRecords)
					{
						ResultCode = TEST_RESULTS.NOT_EXECUTED;
						return;
					}
					QRP.teamName = " " + QRP.teamName.Trim();
					dtTestStart = QueryWidgetCommon.GetSqlServerTime();

					wc.WidgetRemove(QRP.titleId,QRP.webId,QRP.gamerTag,QRP.teamName,QRP.datasetId,QRP.procIndex,QRP.attributes);
					if (!VerifyRemove(QRP,nRecords,nExpectedRecords,dtTestStart))
						throw new Exception("Verification failed.");
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		[TestCase, Description("QueryRemove Valid: procIndex match Remove proc 1")]
			class Query_Remove_Valid_ProcIndex_Match_1 : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveParams QRP = new QueryRemoveParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRP,1))		// get all valid params
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				QueryWidgetCommon.FillDBBasedOnAPI(3,1);

				uint nRecords = QueryWidgetCommon.GetNumRecords(QRP.titleId,QRP.datasetId);
				uint nExpectedRecords = GetMatchingRecords(QRP);
				if (0 == nRecords || 0 == nExpectedRecords)
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemove(QRP.titleId,QRP.webId,QRP.gamerTag,QRP.teamName,QRP.datasetId,QRP.procIndex,QRP.attributes);

					if (!VerifyRemove(QRP,nRecords,nExpectedRecords,dtTestStart))
						throw new Exception("Verification failed.");
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		[TestCase, Description("QueryRemove Valid: procIndex match Remove proc 2")]
			class Query_Remove_Valid_ProcIndex_Match_2 : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveParams QRP = new QueryRemoveParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRP,2))		// get all valid params
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				QueryWidgetCommon.FillDBBasedOnAPI(3,2);

				uint nRecords = QueryWidgetCommon.GetNumRecords(QRP.titleId,QRP.datasetId);
				uint nExpectedRecords = GetMatchingRecords(QRP);
				if (0 == nRecords || 0 == nExpectedRecords)
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemove(QRP.titleId,QRP.webId,QRP.gamerTag,QRP.teamName,QRP.datasetId,QRP.procIndex,QRP.attributes);

					if (!VerifyRemove(QRP,nRecords,nExpectedRecords,dtTestStart))
						throw new Exception("Verification failed.");
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}

		[TestCase, Description("QueryRemove Valid: match single entry")]
			class Query_Remove_Valid_Match_One : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveParams QRP = new QueryRemoveParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				// webuser20 has only one entry that matches parameters of the remove proc
				QRP.gamerTag = "webuser20";
				QRP.webId = BitConverter.GetBytes(562949953420307);
				QRP.teamName = null;

				QueryWidgetCommon.FillDBBasedOnAPI(3,0);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QRP.titleId,QRP.datasetId);
				uint nExpectedRecords = GetMatchingRecords(QRP);
				if (0 == nRecords || 1 != nExpectedRecords)
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemove(QRP.titleId,QRP.webId,QRP.gamerTag,QRP.teamName,QRP.datasetId,QRP.procIndex,QRP.attributes);

					if (!VerifyRemove(QRP,nRecords,nExpectedRecords,dtTestStart))
						throw new Exception("Verification failed.");
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}

			}
		}

/*		[TestCase, Description("QueryRemove Valid: match multiple entries")]
			class Query_Remove_Valid_Match_Multiple : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveParams QRP = new QueryRemoveParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				QueryWidgetCommon.FillDBBasedOnAPI(3,0);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QRP.titleId,QRP.datasetId);
				uint nExpectedRecords = GetMatchingRecords(QRP);
				if (0 == nRecords || 0 == nExpectedRecords)
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemove(QRP.titleId,QRP.webId,QRP.gamerTag,QRP.teamName,QRP.datasetId,QRP.procIndex,QRP.attributes);

					if (!VerifyRemove(QRP,nRecords,nExpectedRecords,dtTestStart))
						throw new Exception("Verification failed.");
				}
				catch (Exception)
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}
*/
		// Negative test cases

		[TestCase, Description("QueryRemove Invalid: remove twice with same parameters")]
			class Query_Remove_Invalid_Remove_Twice : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveParams QRP = new QueryRemoveParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				QueryWidgetCommon.FillDBBasedOnAPI(3,0);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QRP.titleId,QRP.datasetId);
				uint nExpectedRecords = GetMatchingRecords(QRP);
				if (0 == nRecords || 0 == nExpectedRecords)
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemove(QRP.titleId,QRP.webId,QRP.gamerTag,QRP.teamName,QRP.datasetId,QRP.procIndex,QRP.attributes);

					if (!VerifyRemove(QRP,nRecords,nExpectedRecords,dtTestStart))
						throw new Exception("Verification failed.");

					wc.WidgetRemove(QRP.titleId,QRP.webId,QRP.gamerTag,QRP.teamName,QRP.datasetId,QRP.procIndex,QRP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The user tried to update or delete an entity that he does not own."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QRP.titleId,QRP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryRemove Invalid: partner with read-only access")]
			class Query_Remove_Invalid_ReadOnly_Partner : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveParams QRP = new QueryRemoveParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				QueryWidgetCommon.FillDBBasedOnAPI(3,0);
				WCQuery wc = new WCQuery(Global.XEnv.GetVirtualInterface(VirtualInterface.wcquery), new RequestInfo("asschw"));
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemove(QRP.titleId,QRP.webId,QRP.gamerTag,QRP.teamName,QRP.datasetId,QRP.procIndex,QRP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Partner:asschw not allowed to access TitleID:"+Hexer.tohex(QRP.titleId)))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryRemove Invalid: unknown titleId")]
			class Query_Remove_Invalid_Unknown_Title : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveParams QRP = new QueryRemoveParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				// set titleId to unknown value
				QRP.titleId = QueryWidgetCommon.TITLEID_NOT_EXIST;

				QueryWidgetCommon.FillDBBasedOnAPI(3,0);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemove(QRP.titleId,QRP.webId,QRP.gamerTag,QRP.teamName,QRP.datasetId,QRP.procIndex,QRP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Partner:DebugPartner not allowed to access TitleID:"+Hexer.tohex(QRP.titleId)))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryRemove Invalid: titleId MAX_UINT32")]
			class Query_Remove_Invalid_Title_Max : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveParams QRP = new QueryRemoveParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				// set titleId to max value
				QRP.titleId = UInt32.MaxValue;

				QueryWidgetCommon.FillDBBasedOnAPI(3,0);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemove(QRP.titleId,QRP.webId,QRP.gamerTag,QRP.teamName,QRP.datasetId,QRP.procIndex,QRP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Partner:DebugPartner not allowed to access TitleID:"+Hexer.tohex(QRP.titleId)))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryRemove Invalid: titleId doesn't support Query Service")]
			class Query_Remove_Invalid_Title_Unsupported : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveParams QRP = new QueryRemoveParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				// set titleId
				QRP.titleId = QueryWidgetCommon.TITLEID_NO_QUERY;
				QRP.teamName = "";

				QueryWidgetCommon.FillDBBasedOnAPI(3,0);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemove(QRP.titleId,QRP.webId,QRP.gamerTag,QRP.teamName,QRP.datasetId,QRP.procIndex,QRP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryRemove Invalid: titleId doesn't support Remove")]
			class Query_Remove_Invalid_Remove_Unsupported : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveParams QRP = new QueryRemoveParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				// set datasetId
				QRP.datasetId = 2;

				QueryWidgetCommon.FillDBBasedOnAPI(3,0);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QRP.titleId,QRP.datasetId);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemove(QRP.titleId,QRP.webId,QRP.gamerTag,QRP.teamName,QRP.datasetId,QRP.procIndex,QRP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QRP.titleId,QRP.datasetId,dtTestStart) ||
						nRecords != QueryWidgetCommon.GetNumRecords(QRP.titleId,QRP.datasetId))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryRemove Invalid: webId null")]
			class Query_Remove_Invalid_WebId_Null : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveParams QRP = new QueryRemoveParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				// set webId
				QRP.webId = null;

				QueryWidgetCommon.FillDBBasedOnAPI(3,0);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QRP.titleId,QRP.datasetId);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemove(QRP.titleId,QRP.webId,QRP.gamerTag,QRP.teamName,QRP.datasetId,QRP.procIndex,QRP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Bad Passport web ID, null not allowed"))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QRP.titleId,QRP.datasetId,dtTestStart) ||
						nRecords != QueryWidgetCommon.GetNumRecords(QRP.titleId,QRP.datasetId))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryRemove Invalid: webId doesn't exist")]
			class Query_Remove_Invalid_WebId_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveParams QRP = new QueryRemoveParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				// set webId
				QRP.webId = QueryWidgetCommon.WEBID_NOT_EXIST;

				QueryWidgetCommon.FillDBBasedOnAPI(3,0);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QRP.titleId,QRP.datasetId);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemove(QRP.titleId,QRP.webId,QRP.gamerTag,QRP.teamName,QRP.datasetId,QRP.procIndex,QRP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("(webID,GamerTag) pair ("+Hexer.tohex(QRP.webId,true)+","+QRP.gamerTag+") is not linked in our system"))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QRP.titleId,QRP.datasetId,dtTestStart) ||
						nRecords != QueryWidgetCommon.GetNumRecords(QRP.titleId,QRP.datasetId))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryRemove Invalid: webId/gamerTag mismatch")]
			class Query_Remove_Invalid_WebId_GamerTag_Mismatch : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveParams QRP = new QueryRemoveParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				// set webId
				QRP.webId = QueryWidgetCommon.WEBID_NO_MATCH;

				QueryWidgetCommon.FillDBBasedOnAPI(3,0);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QRP.titleId,QRP.datasetId);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemove(QRP.titleId,QRP.webId,QRP.gamerTag,QRP.teamName,QRP.datasetId,QRP.procIndex,QRP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("(webID,GamerTag) pair ("+Hexer.tohex(QRP.webId,true)+","+QRP.gamerTag+") is not linked in our system"))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QRP.titleId,QRP.datasetId,dtTestStart) ||
						nRecords != QueryWidgetCommon.GetNumRecords(QRP.titleId,QRP.datasetId))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryRemove Invalid: webId too short")]
			class Query_Remove_Invalid_WebId_Too_Short : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveParams QRP = new QueryRemoveParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				// set webId
				QRP.webId = QueryWidgetCommon.WEBID_TOO_SHORT;

				QueryWidgetCommon.FillDBBasedOnAPI(3,0);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QRP.titleId,QRP.datasetId);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemove(QRP.titleId,QRP.webId,QRP.gamerTag,QRP.teamName,QRP.datasetId,QRP.procIndex,QRP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Bad Passport web ID, length is "+QRP.webId.Length.ToString()))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QRP.titleId,QRP.datasetId,dtTestStart) ||
						nRecords != QueryWidgetCommon.GetNumRecords(QRP.titleId,QRP.datasetId))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryRemove Invalid: webId too long")]
			class Query_Remove_Invalid_WebId_Too_Long : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveParams QRP = new QueryRemoveParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				// set webId
				QRP.webId = QueryWidgetCommon.WEBID_TOO_LONG;

				QueryWidgetCommon.FillDBBasedOnAPI(3,0);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QRP.titleId,QRP.datasetId);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemove(QRP.titleId,QRP.webId,QRP.gamerTag,QRP.teamName,QRP.datasetId,QRP.procIndex,QRP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Bad Passport web ID, length is "+QRP.webId.Length.ToString()))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QRP.titleId,QRP.datasetId,dtTestStart) ||
						nRecords != QueryWidgetCommon.GetNumRecords(QRP.titleId,QRP.datasetId))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryRemove Invalid: VERY long webId")]
			class Query_Remove_Invalid_WebId_VERY_long : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveParams QRP = new QueryRemoveParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				QRP.webId = new byte[999999];
				for (int i=0; i<999999; i++)
				{
					QRP.webId[i] = (byte)(i%16);
				}

				QueryWidgetCommon.FillDBBasedOnAPI(3,0);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QRP.titleId,QRP.datasetId);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemove(QRP.titleId,QRP.webId,QRP.gamerTag,QRP.teamName,QRP.datasetId,QRP.procIndex,QRP.attributes);
				}
				catch (Exception e)
				{
                    if (!e.Message.EndsWith("Bad Passport web ID, length is 999999"))
                    {
                        Global.RO.Info("expected bad passport exception, got: " + e.Message);
                        ResultCode = TEST_RESULTS.FAILED;
                    }

					if (!QueryWidgetCommon.VerifyNoChange(QRP.titleId,QRP.datasetId,dtTestStart) ||
						nRecords != QueryWidgetCommon.GetNumRecords(QRP.titleId,QRP.datasetId))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryRemove Invalid: gamerTag null")]
			class Query_Remove_Invalid_GamerTag_Null : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveParams QRP = new QueryRemoveParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				// set gamerTag
				QRP.gamerTag = null;

				QueryWidgetCommon.FillDBBasedOnAPI(3,0);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QRP.titleId,QRP.datasetId);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemove(QRP.titleId,QRP.webId,QRP.gamerTag,QRP.teamName,QRP.datasetId,QRP.procIndex,QRP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Bad GamerTag provided, null not allowed"))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QRP.titleId,QRP.datasetId,dtTestStart) ||
						nRecords != QueryWidgetCommon.GetNumRecords(QRP.titleId,QRP.datasetId))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryRemove Invalid: gamerTag empty string")]
			class Query_Remove_Invalid_GamerTag_Empty : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveParams QRP = new QueryRemoveParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				// set gamerTag
				QRP.gamerTag = "";

				QueryWidgetCommon.FillDBBasedOnAPI(3,0);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QRP.titleId,QRP.datasetId);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemove(QRP.titleId,QRP.webId,QRP.gamerTag,QRP.teamName,QRP.datasetId,QRP.procIndex,QRP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("(webID,GamerTag) pair ("+Hexer.tohex(QRP.webId,true)+","+QRP.gamerTag+") is not linked in our system"))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QRP.titleId,QRP.datasetId,dtTestStart) ||
						nRecords != QueryWidgetCommon.GetNumRecords(QRP.titleId,QRP.datasetId))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryRemove Invalid: gamerTag padded with spaces")]
			class Query_Remove_Invalid_GamerTag_Padded : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveParams QRP = new QueryRemoveParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				// pad gamerTag with space at end
				QRP.gamerTag += " ";

				QueryWidgetCommon.FillDBBasedOnAPI(3,0);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QRP.titleId,QRP.datasetId);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					// try gamerTag padded at end
					wc.WidgetRemove(QRP.titleId,QRP.webId,QRP.gamerTag,QRP.teamName,QRP.datasetId,QRP.procIndex,QRP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("(webID,GamerTag) pair ("+Hexer.tohex(QRP.webId,true)+","+QRP.gamerTag+") is not linked in our system"))
					{
						ResultCode = TEST_RESULTS.FAILED;
						return;
					}

					if (!QueryWidgetCommon.VerifyNoChange(QRP.titleId,QRP.datasetId,dtTestStart) ||
						nRecords != QueryWidgetCommon.GetNumRecords(QRP.titleId,QRP.datasetId))
					{
						ResultCode = TEST_RESULTS.FAILED;
						return;
					}

					try
					{
						// try gamerTag padded at beginning
						QRP.gamerTag = " " + QRP.gamerTag.Trim();
						wc.WidgetRemove(QRP.titleId,QRP.webId,QRP.gamerTag,QRP.teamName,QRP.datasetId,QRP.procIndex,QRP.attributes);
					}
					catch (Exception ex)
					{
						if (!ex.Message.EndsWith("(webID,GamerTag) pair ("+Hexer.tohex(QRP.webId,true)+","+QRP.gamerTag+") is not linked in our system"))
							ResultCode = TEST_RESULTS.FAILED;

						if (!QueryWidgetCommon.VerifyNoChange(QRP.titleId,QRP.datasetId,dtTestStart) ||
							nRecords != QueryWidgetCommon.GetNumRecords(QRP.titleId,QRP.datasetId))
							ResultCode = TEST_RESULTS.FAILED;
						return;
					}
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryRemove Invalid: gamerTag too long")]
			class Query_Remove_Invalid_GamerTag_Too_Long : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveParams QRP = new QueryRemoveParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				// set gamerTag
				QRP.gamerTag = QueryWidgetCommon.GAMERTAG_TOO_LONG;

				QueryWidgetCommon.FillDBBasedOnAPI(3,0);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QRP.titleId,QRP.datasetId);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemove(QRP.titleId,QRP.webId,QRP.gamerTag,QRP.teamName,QRP.datasetId,QRP.procIndex,QRP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("(webID,GamerTag) pair ("+Hexer.tohex(QRP.webId,true)+","+QRP.gamerTag+") is not linked in our system"))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QRP.titleId,QRP.datasetId,dtTestStart) ||
						nRecords != QueryWidgetCommon.GetNumRecords(QRP.titleId,QRP.datasetId))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryRemove Invalid: teamName too long")]
			class Query_Remove_Invalid_teamName_Too_Long : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveParams QRP = new QueryRemoveParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				// set teamName
				QRP.teamName = QueryWidgetCommon.TEAMNAME_TOO_LONG;

				QueryWidgetCommon.FillDBBasedOnAPI(3,0);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QRP.titleId,QRP.datasetId);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemove(QRP.titleId,QRP.webId,QRP.gamerTag,QRP.teamName,QRP.datasetId,QRP.procIndex,QRP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Team "+QRP.teamName+" could not be found in the team cache for titleId "+Hexer.tohex(QRP.titleId).ToLower()+" aborting."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QRP.titleId,QRP.datasetId,dtTestStart) ||
						nRecords != QueryWidgetCommon.GetNumRecords(QRP.titleId,QRP.datasetId))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryRemove Invalid: user/team mismatch")]
			class Query_Remove_Invalid_User_Team_Mismatch : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveParams QRP = new QueryRemoveParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				// set teamName
				QRP.teamName = QueryWidgetCommon.TEAMNAME_NO_MATCH;

				QueryWidgetCommon.FillDBBasedOnAPI(3,0);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QRP.titleId,QRP.datasetId);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemove(QRP.titleId,QRP.webId,QRP.gamerTag,QRP.teamName,QRP.datasetId,QRP.procIndex,QRP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("User "+QRP.gamerTag+" could not be validated as a member of team "+QRP.teamName+" in title "+Hexer.tohex(QRP.titleId).ToLower()))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QRP.titleId,QRP.datasetId,dtTestStart) ||
						nRecords != QueryWidgetCommon.GetNumRecords(QRP.titleId,QRP.datasetId))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryRemove Invalid: teamName doesn't exist")]
			class Query_Remove_Invalid_teamName_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveParams QRP = new QueryRemoveParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				// set teamName
				QRP.teamName = QueryWidgetCommon.TEAMNAME_NOT_EXIST;

				QueryWidgetCommon.FillDBBasedOnAPI(3,0);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QRP.titleId,QRP.datasetId);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemove(QRP.titleId,QRP.webId,QRP.gamerTag,QRP.teamName,QRP.datasetId,QRP.procIndex,QRP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Team "+QRP.teamName+" could not be found in the team cache for titleId "+Hexer.tohex(QRP.titleId).ToLower()+" aborting."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QRP.titleId,QRP.datasetId,dtTestStart) ||
						nRecords != QueryWidgetCommon.GetNumRecords(QRP.titleId,QRP.datasetId))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryRemove Invalid: datasetId 0")]
			class Query_Remove_Invalid_DatasetId_0 : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveParams QRP = new QueryRemoveParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				// set datasetId
				QRP.datasetId = 0;

				QueryWidgetCommon.FillDBBasedOnAPI(3,0);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemove(QRP.titleId,QRP.webId,QRP.gamerTag,QRP.teamName,QRP.datasetId,QRP.procIndex,QRP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryRemove Invalid: datasetId 2")]
			class Query_Remove_Invalid_DatasetId_2 : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveParams QRP = new QueryRemoveParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				// set datasetId
				QRP.datasetId = 2;

				QueryWidgetCommon.FillDBBasedOnAPI(3,0);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemove(QRP.titleId,QRP.webId,QRP.gamerTag,QRP.teamName,QRP.datasetId,QRP.procIndex,QRP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QRP.titleId,QRP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryRemove Invalid: datasetId 3")]
			class Query_Remove_Invalid_DatasetId_3 : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveParams QRP = new QueryRemoveParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				// set datasetId
				QRP.datasetId = 3;

				QueryWidgetCommon.FillDBBasedOnAPI(3,0);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemove(QRP.titleId,QRP.webId,QRP.gamerTag,QRP.teamName,QRP.datasetId,QRP.procIndex,QRP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;

					if (QRP.titleId != QueryWidgetCommon.QUERY_TITLE_ID && !QueryWidgetCommon.VerifyNoChange(QRP.titleId,QRP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryRemove Invalid: datasetId MAX_UINT32")]
			class Query_Remove_Invalid_DatasetId_Max : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveParams QRP = new QueryRemoveParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				// set datasetId
				QRP.datasetId = UInt32.MaxValue;

				QueryWidgetCommon.FillDBBasedOnAPI(3,0);
				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemove(QRP.titleId,QRP.webId,QRP.gamerTag,QRP.teamName,QRP.datasetId,QRP.procIndex,QRP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryRemove Invalid: procIndex MAX_UINT32")]
			class Query_Remove_Invalid_ProcIndex_Max : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveParams QRP = new QueryRemoveParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				// set procIndex
				QRP.procIndex = UInt32.MaxValue;

				QueryWidgetCommon.FillDBBasedOnAPI(3,0);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QRP.titleId,QRP.datasetId);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemove(QRP.titleId,QRP.webId,QRP.gamerTag,QRP.teamName,QRP.datasetId,QRP.procIndex,QRP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QRP.titleId,QRP.datasetId,dtTestStart) ||
						nRecords != QueryWidgetCommon.GetNumRecords(QRP.titleId,QRP.datasetId))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryRemove Invalid: procIndex off by 1")]
			class Query_Remove_Invalid_ProcIndex_Off_By_One : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveParams QRP = new QueryRemoveParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				// set procIndex
				QRP.procIndex++;

				QueryWidgetCommon.FillDBBasedOnAPI(3,0);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QRP.titleId,QRP.datasetId);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemove(QRP.titleId,QRP.webId,QRP.gamerTag,QRP.teamName,QRP.datasetId,QRP.procIndex,QRP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QRP.titleId,QRP.datasetId,dtTestStart) ||
						nRecords != QueryWidgetCommon.GetNumRecords(QRP.titleId,QRP.datasetId))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

/*		[TestCase, Description("QueryRemove Invalid: procIndex doesn't exist")]
			class Query_Remove_Invalid_ProcIndex_Not_Exist : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveParams QRP = new QueryRemoveParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				// set procIndex
				QRP.procIndex = QueryWidgetCommon.PROCINDEX_NOT_EXIST;

				QueryWidgetCommon.FillDBBasedOnAPI(3,0);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QRP.titleId,QRP.datasetId);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemove(QRP.titleId,QRP.webId,QRP.gamerTag,QRP.teamName,QRP.datasetId,QRP.procIndex,QRP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QRP.titleId,QRP.datasetId,dtTestStart) ||
						nRecords != QueryWidgetCommon.GetNumRecords(QRP.titleId,QRP.datasetId))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}
*/
		[TestCase, Description("QueryRemove Invalid: attributes null")]
			class Query_Remove_Invalid_Attrib_Null : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveParams QRP = new QueryRemoveParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				// set attributes
				QRP.attributes = null;

				QueryWidgetCommon.FillDBBasedOnAPI(3,0);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QRP.titleId,QRP.datasetId);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemove(QRP.titleId,QRP.webId,QRP.gamerTag,QRP.teamName,QRP.datasetId,QRP.procIndex,QRP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("Object reference not set to an instance of an object."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QRP.titleId,QRP.datasetId,dtTestStart) ||
						nRecords != QueryWidgetCommon.GetNumRecords(QRP.titleId,QRP.datasetId))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryRemove Invalid: too few attributes")]
			class Query_Remove_Invalid_Attrib_Too_Short : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveParams QRP = new QueryRemoveParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				// remove attribute from end of array
				QueryAttribute [] QAtooshort = new QueryAttribute[QRP.attributes.Length-1];
				Array.Copy(QRP.attributes,QAtooshort,QAtooshort.Length);
				QRP.attributes = QAtooshort;

				QueryWidgetCommon.FillDBBasedOnAPI(3,0);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QRP.titleId,QRP.datasetId);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemove(QRP.titleId,QRP.webId,QRP.gamerTag,QRP.teamName,QRP.datasetId,QRP.procIndex,QRP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("An unexpected attribute passed to the method caused a database error."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QRP.titleId,QRP.datasetId,dtTestStart) ||
						nRecords != QueryWidgetCommon.GetNumRecords(QRP.titleId,QRP.datasetId))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryRemove Invalid: too many attributes")]
			class Query_Remove_Invalid_Attrib_Too_Long : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveParams QRP = new QueryRemoveParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				// add valid attribute at end of array
				QueryAttribute [] QAtoolong = new QueryAttribute[QRP.attributes.Length+1];
				QRP.attributes.CopyTo(QAtoolong,0);
				QAtoolong[QAtoolong.Length-1] = new QueryAttribute();
				QAtoolong[QAtoolong.Length-1].Id = 1048579;
				QAtoolong[QAtoolong.Length-1].Value = "REMOVE will get rid of this entry with procIndex 1";
				QRP.attributes = QAtoolong;

				QueryWidgetCommon.FillDBBasedOnAPI(3,0);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QRP.titleId,QRP.datasetId);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemove(QRP.titleId,QRP.webId,QRP.gamerTag,QRP.teamName,QRP.datasetId,QRP.procIndex,QRP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("An unexpected attribute passed to the method caused a database error."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QRP.titleId,QRP.datasetId,dtTestStart) ||
						nRecords != QueryWidgetCommon.GetNumRecords(QRP.titleId,QRP.datasetId))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryRemove Invalid: invalid attributes")]
			class Query_Remove_Invalid_Attrib_Invalid : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveParams QRP = new QueryRemoveParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				foreach (QueryAttribute QA in QRP.attributes)
				{
					// lowest 16 bits of ID represent the actual attrib ID
					// in LiveService\Comps\CompDefs, nothing more than 0x20 defined
					QA.Id += 0x100;		// this will make all IDs invalid
				}

				QueryWidgetCommon.FillDBBasedOnAPI(3,0);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QRP.titleId,QRP.datasetId);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemove(QRP.titleId,QRP.webId,QRP.gamerTag,QRP.teamName,QRP.datasetId,QRP.procIndex,QRP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("An unexpected attribute passed to the method caused a database error."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QRP.titleId,QRP.datasetId,dtTestStart) ||
						nRecords != QueryWidgetCommon.GetNumRecords(QRP.titleId,QRP.datasetId))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryRemove Invalid: match attributes but not user/team")]
			class Query_Remove_Invalid_Owner_Not_Match : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveParams QRP = new QueryRemoveParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				// choose owner that doesn't have matching attributes
				QRP.gamerTag = "webuser0";
				QRP.webId = BitConverter.GetBytes(Convert.ToUInt64(562949953420287));
				QRP.teamName = "";

				QueryWidgetCommon.FillDBBasedOnAPI(3,0);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QRP.titleId,QRP.datasetId);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemove(QRP.titleId,QRP.webId,QRP.gamerTag,QRP.teamName,QRP.datasetId,QRP.procIndex,QRP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The user tried to update or delete an entity that he does not own."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QRP.titleId,QRP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryRemove Invalid: match empty set")]
			class Query_Remove_Invalid_Match_Nothing : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveParams QRP = new QueryRemoveParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRP))		// get all valid params
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				QueryWidgetCommon.FillDBBasedOnAPI(3,0);
				QRP.attributes[0].Value = (long)1000;	// no record should have int = 1000

				uint nRecords = QueryWidgetCommon.GetNumRecords(QRP.titleId,QRP.datasetId);
				uint nExpectedRecords = GetMatchingRecords(QRP);
				if (0 == nRecords || 0 != nExpectedRecords)
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemove(QRP.titleId,QRP.webId,QRP.gamerTag,QRP.teamName,QRP.datasetId,QRP.procIndex,QRP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The requested entity does not exist in the dataset specified."))
						ResultCode = TEST_RESULTS.FAILED;

					if (!QueryWidgetCommon.VerifyNoChange(QRP.titleId,QRP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}
				ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("QueryRemove Invalid: try to remove competitions")]
			class Query_Remove_Invalid_Competition_Remove : TestBase
		{
			protected override void Execute()
			{
				QueryRemoveParams QRP = new QueryRemoveParams();
				ResultCode = TEST_RESULTS.PASSED;

				if (!GetValidParams(ref QRP,0,true))		// get all valid params
				{
					ResultCode = TEST_RESULTS.NOT_EXECUTED;
					return;
				}

				// choose titleID of competition dataset
				QRP.attributes = new QueryAttribute[3];
				for (int i=0; i<QRP.attributes.Length; i++)
					QRP.attributes[i] = new QueryAttribute();
				QRP.attributes[0].Id = 0x00010001;
				QRP.attributes[0].Value = (long)07734;
				QRP.attributes[1].Id = 0x00110002;
				QRP.attributes[1].Value = "matching string for Remove test";
				QRP.attributes[2].Id = 0x00210003;
				QRP.attributes[2].Value = Hexer.unhex("987654321");

				// add entries to comps dataset if necessary
				QueryWidgetCommon.FillDBBasedOnAPI(16,0);
				uint nRecords = QueryWidgetCommon.GetNumRecords(QRP.titleId,QRP.datasetId);

				WCQuery wc = new WCQuery();
				DateTime dtTestStart = QueryWidgetCommon.GetSqlServerTime();
				try
				{
					wc.WidgetRemove(QRP.titleId,QRP.webId,QRP.gamerTag,QRP.teamName,QRP.datasetId,QRP.procIndex,QRP.attributes);
				}
				catch (Exception e)
				{
					if (!e.Message.EndsWith("The web service encountered an internal error."))
						ResultCode = TEST_RESULTS.FAILED;

					if (nRecords != QueryWidgetCommon.GetNumRecords(QRP.titleId,QRP.datasetId) ||
						!QueryWidgetCommon.VerifyNoChange(QRP.titleId,QRP.datasetId,dtTestStart))
						ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.FAILED;
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Query\test\StressTests.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web;
using ServerTestFramework.Web.Query;
using xonline.common.config;

namespace QueryWidget
{
	public struct AddedEntryInfo
	{
		public ulong entityId;
		public int nUser;
		public int nTeam;
		public DateTime dtCreated;
	}

	public enum QAChoices
	{
		AddUserTeam = 0,
		AddLarge = 1,
		Update = 2,
		NumChoices = 3,
		AddImmRemove = 4,
		AddImmRemoveId = 5
	}

	public class StressHelpers
	{
		/* logging */
		public static bool logging = false;
		public static System.IO.StreamWriter strInfo = null;

		/* comps helpers */

		public static Stack openComps = new Stack();				// comps available for manageentrant
		public static Stack startedComps = new Stack();				// comps available for topology
		public static AddedEntryInfo topId = new AddedEntryInfo();	// comp currently used for topology calls
		public static AddedEntryInfo ai = new AddedEntryInfo();		// comp that we're currently using to test ManageEntrant/Select
		public static int joinedUsers = 0;							// index of next user to join to the comp
		public static QueryAttributeSpec [] topSpecs = new QueryAttributeSpec[15];
		public static QueryAttributeSpec [] CSearchSpecs = new QueryAttributeSpec[17];

		public static ulong CompCreate(WCQuery query, System.Random rnd, bool teamBased, int nUser)
		{
			ulong result = 0;

			string teamName = null;
			if (teamBased)
				teamName = "webteam" + Convert.ToString(nUser/8);

			QueryAttribute [] attribs = new QueryAttribute[18];
			for (int i=0; i<18; i++)
				attribs[i] = new QueryAttribute();
			attribs[0].Id = 0x80010001;		// reg open
			attribs[1].Id = 0x80010002;		// reg close
			attribs[2].Id = 0x80010003;		// comp start
			attribs[3].Id = 0x80010004;		// comp cleanup
			attribs[4].Id = 0x80010005;		// round frequency
			attribs[5].Id = 0x80010006;		// round interval
			attribs[6].Id = 0x80010007;		// round day mask
			attribs[7].Id = 0x8001000C;		// round one start
			attribs[8].Id = 0x8001000D;		// round one end
			attribs[9].Id = 0x80010010;		// is team comp
			attribs[10].Id = 0x80010011;	// team size
			attribs[11].Id = 0x80010012;	// max public slots
			attribs[12].Id = 0x80010013;	// max private slots
			attribs[13].Id = 0x80010014;	// min slots
			attribs[14].Id = 0x8001001A;	// reminder minutes
			attribs[15].Id = 0x00010001;	// map (int)
			attribs[16].Id = 0x00110002;	// name (string)
			attribs[17].Id = 0x00210003;	// icon (blob)

			// set values
			attribs[0].Value = DateTime.UtcNow.ToFileTimeUtc();
			attribs[1].Value = DateTime.UtcNow.AddMinutes(5).ToFileTimeUtc();
			attribs[2].Value = DateTime.UtcNow.AddMinutes(6).ToFileTimeUtc();
			attribs[7].Value = DateTime.UtcNow.AddMinutes(7).ToFileTimeUtc();
			attribs[8].Value = DateTime.UtcNow.AddMinutes(12).ToFileTimeUtc();

			attribs[3].Value = (long)0;
			attribs[4].Value = (long)6;
			attribs[5].Value = (long)2;
			attribs[6].Value = (long)0;
			attribs[9].Value = (long)0;
			attribs[10].Value = (long)0;
			if (teamBased)
			{
				attribs[9].Value = (long)1;
				attribs[10].Value = (long)8;
			}
			attribs[11].Value = (long)200;
			attribs[12].Value = (long)200;
			attribs[13].Value = (long)10;
			attribs[14].Value = (long)0;
			attribs[15].Value = (long)rnd.Next(50,60);
			attribs[16].Value = "testing stress thru query widget with competitions";
			attribs[17].Value = Hexer.unhex("ACEC0DE");

			try
			{
				result = query.WidgetCompetitionCreate(QueryWidgetCommon.COMPS_TITLE_ID,BitConverter.GetBytes(Convert.ToUInt64(562949953420287+nUser)),"webuser"+nUser,teamName,1,attribs);
			}
			catch (Exception e)
			{
				System.IO.StreamWriter strWriter = System.IO.File.AppendText(@"C:\xonline\private\test\StfTests\QueryWidget\stressErrors.txt");
				strWriter.WriteLine(DateTime.Now.GetDateTimeFormats()[71]+"  CompCreate fail: "+e.Message+" user: "+nUser+" team: "+teamName);
				strWriter.Close();
				return 0;
			}

			return result;
		}

		public static ulong CompCreateSE(WCQuery query, System.Random rnd, bool teamBased, int nUser)
		{
			ulong result = 0;

			string teamName = null;
			if (teamBased)
				teamName = "webteam" + Convert.ToString(nUser/8);

			QueryAttribute [] attribs = new QueryAttribute[3];
			for (int i=0; i<3; i++)
				attribs[i] = new QueryAttribute();
			attribs[0].Id = 0x00010001;	// map (int)
			attribs[1].Id = 0x00110002;	// name (string)
			attribs[2].Id = 0x00210003;	// icon (blob)
			attribs[0].Value = (long)rnd.Next(50,60);
			attribs[1].Value = "testing stress thru query widget with competitions";
			attribs[2].Value = Hexer.unhex("ACEC0DE");

			try
			{
				result = query.WidgetCompetitionCreateSingleElimination(QueryWidgetCommon.COMPS_TITLE_ID,BitConverter.GetBytes(Convert.ToUInt64(562949953420287+nUser)),"webuser"+nUser,teamName,1,
					200,200,10,DateTime.Now,DateTime.Now.AddMinutes(5),DateTime.Now.AddMinutes(6),
					DateTime.Now.AddMinutes(7),DateTime.Now.AddMinutes(12),0,6,2,teamBased,8,attribs);
			}
			catch (Exception e)
			{
				System.IO.StreamWriter strWriter = System.IO.File.AppendText(@"C:\xonline\private\test\StfTests\QueryWidget\stressErrors.txt");
				strWriter.WriteLine(DateTime.Now.GetDateTimeFormats()[71]+"  CompCreateSE fail: "+e.Message+" user: "+nUser+" team: "+teamName);
				strWriter.Close();
				return 0;
			}

			return result;
		}

		/* query helpers */

		public static ArrayList QueryEntries = new ArrayList();

		public static object [] GetQueryAttribs(int selection)
		{
			object [] rVal = new object[3];

			switch (selection)
			{
				case (int)QAChoices.AddUserTeam:
					rVal[0] = (long)4321;
					rVal[1] = "stress testing with user add"+DateTime.Now.Day.ToString()+DateTime.Now.Hour.ToString();
					rVal[2] = Hexer.unhex("98765432100123456789");
					break;
				case (int)QAChoices.AddLarge:
					rVal[0] = long.MaxValue;
					rVal[1] = "larger (max = 400) string for stress with user aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc dddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd"+DateTime.Now.Day.ToString()+DateTime.Now.Hour.ToString();
					rVal[2] = Hexer.unhex("98765432100123456789987654321001234567899876543210012345678998765432100123456789987654321001234567899876543210012345678998765432100123456789987654321001234567899876543210012345678998765432100123456789987654321001234567899876543210012345678998765432100123456789987654321001234567899876543210012345678998765432100123456789987654321001234567899876543210012345678998765432100123456789987654321001234567899876543210012345678998765432100123456789987654321001234567899876543210012345678998765432100123456789987654321001234567899876543210012345678998765432100123456789987654321001234567899876543210012345678998765432100123456789987654321001234567899876543210012345678998765432100123456789987654321001234567899876543210012345678998765432100123456789987654321001234567899876543210012345678998765432100123456789");
					break;
				case (int)QAChoices.Update:
					rVal[0] = (long)20;
					rVal[1] = "something or other"+DateTime.Now.Day.ToString()+DateTime.Now.Hour.ToString();
					rVal[2] = Hexer.unhex("56784321");
					break;
				case (int)QAChoices.AddImmRemoveId:
					rVal[0] = (long)14;
					rVal[1] = "add with immediate removal using ID"+DateTime.Now.Day.ToString()+DateTime.Now.Hour.ToString();
					rVal[2] = Hexer.unhex("AC0DE");
					break;
				case (int)QAChoices.AddImmRemove:
					rVal[0] = (long)2;
					rVal[1] = "add with immediate removal using attributes"+DateTime.Now.Day.ToString()+DateTime.Now.Hour.ToString();
					rVal[2] = Hexer.unhex("A2C0DE");
					break;
			}

			return rVal;
		}
	}

	[StressInstantiate, StressTest(Priority=1)]
	public class StressQueryAdd : TestBase
	{
		override protected void Execute()
		{
			QueryAttribute [] QA = new QueryAttribute[3];
			WCQuery query = new WCQuery();
			System.Random rnd = new Random(DateTime.Now.Millisecond + DateTime.Now.Second);

			ResultCode=TEST_RESULTS.PASSED;

			// choose user/team
			int nUser = rnd.Next(0,1024);
			string teamName = "";
			if (rnd.Next(0,2) == 0)
				teamName = "webteam"+Convert.ToString(nUser/4);

			// choose attributes to store
			for (int i=0; i<QA.Length; i++)
				QA[i] = new QueryAttribute();
			QA[0].Id = 0x00000001;
			QA[1].Id = 0x00100003;
			QA[2].Id = 0x00200005;
			int shortOrLong = (int)QAChoices.AddUserTeam;
			if (rnd.Next(0,2) == 0)
				shortOrLong = (int)QAChoices.AddLarge;
			object [] atts = StressHelpers.GetQueryAttribs(shortOrLong);
			QA[0].Value = (long)atts[0];
			QA[1].Value = (string)atts[1];
			QA[2].Value = (byte[])atts[2];

			try
			{
				ulong result = query.WidgetAdd(QueryWidgetCommon.QUERY_TITLE_ID,BitConverter.GetBytes(Convert.ToUInt64(562949953420287+nUser)),"webuser"+nUser,teamName,10,QA);

				if (StressHelpers.logging)
				{
					StressHelpers.strInfo.WriteLine(DateTime.Now.GetDateTimeFormats()[71]+"  A: "+result);
					StressHelpers.strInfo.Flush();
				}

				lock (StressHelpers.QueryEntries)
				{
					if (StressHelpers.QueryEntries.Count < 500)
					{
						AddedEntryInfo ai = new AddedEntryInfo();
						ai.entityId = result;
						ai.nUser = nUser;
						ai.nTeam = -1;
						if (teamName != "")
							ai.nTeam = nUser/4;
						StressHelpers.QueryEntries.Add(ai);
					}
				}
			}
			catch (Exception e)
			{
				ResultCode=TEST_RESULTS.FAILED;
				System.IO.StreamWriter strWriter = System.IO.File.AppendText(@"C:\xonline\private\test\StfTests\QueryWidget\stressErrors.txt");
				strWriter.WriteLine(DateTime.Now.GetDateTimeFormats()[71]+"  QueryAdd fail: "+e.Message+" user: "+nUser+" team: "+teamName);
				strWriter.Close();
			}
		}
	}

	[StressInstantiate, StressTest(Priority=.5F)]
	public class StressQuerySearch : TestBase
	{
		override protected void Execute()
		{
			WCQuery query = new WCQuery();
			System.Random rnd = new Random(DateTime.Now.Millisecond + DateTime.Now.Second);

			ResultCode=TEST_RESULTS.PASSED;

			// choose parameters
			uint procIndex = (uint)rnd.Next(0,4);			// want 0 - 3
			uint page = 0;
			uint resultsPerPage = (uint)rnd.Next(1,50);
			QueryAttributeSpec [] specs = null;
			QueryAttribute [] attribs = null;

			switch (procIndex)
			{
				case 0:
					procIndex = 514;

					specs = new QueryAttributeSpec[3];
					for (int j=0; j<specs.Length; j++)
						specs[j] = new QueryAttributeSpec();
					specs[0].len = 8;
					specs[0].type = 0x80000000;
					specs[1].len = 8;
					specs[1].type = 0x00000001;
					specs[2].len = 800;
					specs[2].type = 0x00200005;

					attribs = new QueryAttribute[2];
					for (int j=0; j<attribs.Length; j++)
						attribs[j] = new QueryAttribute();
					attribs[0].Id = 0x00100003;
					attribs[1].Id = 0x00200005;
					object [] atts = StressHelpers.GetQueryAttribs(rnd.Next(0,(int)QAChoices.NumChoices));
					attribs[0].Value = (string)atts[1];
					attribs[1].Value = (byte[])atts[2];
					break;
				case 1:
					procIndex = 518;

					specs = new QueryAttributeSpec[4];
					for (int j=0; j<specs.Length; j++)
						specs[j] = new QueryAttributeSpec();
					specs[0].len = 8;
					specs[0].type = 0x80000000;
					specs[1].len = 8;
					specs[1].type = 0x00000001;
					specs[2].len = 400;
					specs[2].type = 0x00100003;
					specs[3].len = 800;
					specs[3].type = 0x00200005;

					attribs = new QueryAttribute[3];
					for (int j=0; j<attribs.Length; j++)
						attribs[j] = new QueryAttribute();
					attribs[0].Id = 0x00000001;
					attribs[1].Id = 0x00100003;
					attribs[2].Id = 0x00200005;
					atts = StressHelpers.GetQueryAttribs(rnd.Next(0,(int)QAChoices.NumChoices));
					attribs[0].Value = (long)atts[0];
					attribs[1].Value = (string)atts[1];
					attribs[2].Value = (byte[])atts[2];
					break;
				case 2:
					procIndex = 256;

					specs = new QueryAttributeSpec[3];
					for (int j=0; j<specs.Length; j++)
						specs[j] = new QueryAttributeSpec();
					specs[0].len = 8;
					specs[0].type = 0x80000000;
					specs[1].len = 8;
					specs[1].type = 0x00000001;
					specs[2].len = 400;
					specs[2].type = 0x00100003;

					attribs = new QueryAttribute[1];
					attribs[0] = new QueryAttribute();
					attribs[0].Id = 0x00200005;
					atts = StressHelpers.GetQueryAttribs(rnd.Next(0,(int)QAChoices.NumChoices));
					attribs[0].Value = (byte[])atts[2];
					break;
				case 3:
					procIndex = 4;

					specs = new QueryAttributeSpec[4];
					for (int j=0; j<specs.Length; j++)
						specs[j] = new QueryAttributeSpec();
					specs[0].len = 8;
					specs[0].type = 0x80000000;
					specs[1].len = 8;
					specs[1].type = 0x00000001;
					specs[2].len = 400;
					specs[2].type = 0x00100003;
					specs[3].len = 800;
					specs[3].type = 0x00200005;

					attribs = new QueryAttribute[2];
					for (int j=0; j<attribs.Length; j++)
						attribs[j] = new QueryAttribute();
					attribs[0].Id = 0x00000001;
					attribs[1].Id = 0x00100003;
					atts = StressHelpers.GetQueryAttribs(rnd.Next(0,(int)QAChoices.NumChoices));
					attribs[0].Value = (long)atts[0];
					attribs[1].Value = (string)atts[1];
					break;
			}

			try
			{
				SearchResponse result = query.WidgetSearch(QueryWidgetCommon.QUERY_TITLE_ID,10,procIndex,page,resultsPerPage,specs,attribs);
			}
			catch (Exception e)
			{
				ResultCode=TEST_RESULTS.FAILED;
				System.IO.StreamWriter strWriter = System.IO.File.AppendText(@"C:\xonline\private\test\StfTests\QueryWidget\stressErrors.txt");
				strWriter.WriteLine(DateTime.Now.GetDateTimeFormats()[71]+"  QuerySearch fail: "+e.Message+" page: "+page+" procIndex: "+procIndex+" resultsPerPage: "+resultsPerPage);
				strWriter.Close();
			}
		}
	}

	[StressInstantiate, StressTest(Priority=.2F)]
	public class StressQuerySearchConsecutivePages : TestBase
	{
		override protected void Execute()
		{
			WCQuery query = new WCQuery();
			System.Random rnd = new Random(DateTime.Now.Millisecond + DateTime.Now.Second);

			ResultCode=TEST_RESULTS.PASSED;

			// choose parameters
			uint procIndex = (uint)rnd.Next(0,4);			// want 0 - 3
			uint resultsPerPage = 5;
			QueryAttributeSpec [] specs = null;
			QueryAttribute [] attribs = null;

			switch (procIndex)
			{
				case 0:
					procIndex = 514;

					specs = new QueryAttributeSpec[3];
					for (int j=0; j<specs.Length; j++)
						specs[j] = new QueryAttributeSpec();
					specs[0].len = 8;
					specs[0].type = 0x80000000;
					specs[1].len = 8;
					specs[1].type = 0x00000001;
					specs[2].len = 800;
					specs[2].type = 0x00200005;

					attribs = new QueryAttribute[2];
					for (int j=0; j<attribs.Length; j++)
						attribs[j] = new QueryAttribute();
					attribs[0].Id = 0x00100003;
					attribs[1].Id = 0x00200005;
					object [] atts = StressHelpers.GetQueryAttribs(rnd.Next(0,(int)QAChoices.NumChoices));
					attribs[0].Value = (string)atts[1];
					attribs[1].Value = (byte[])atts[2];
					break;
				case 1:
					procIndex = 518;

					specs = new QueryAttributeSpec[4];
					for (int j=0; j<specs.Length; j++)
						specs[j] = new QueryAttributeSpec();
					specs[0].len = 8;
					specs[0].type = 0x80000000;
					specs[1].len = 8;
					specs[1].type = 0x00000001;
					specs[2].len = 400;
					specs[2].type = 0x00100003;
					specs[3].len = 800;
					specs[3].type = 0x00200005;

					attribs = new QueryAttribute[3];
					for (int j=0; j<attribs.Length; j++)
						attribs[j] = new QueryAttribute();
					attribs[0].Id = 0x00000001;
					attribs[1].Id = 0x00100003;
					attribs[2].Id = 0x00200005;
					atts = StressHelpers.GetQueryAttribs(rnd.Next(0,(int)QAChoices.NumChoices));
					attribs[0].Value = (long)atts[0];
					attribs[1].Value = (string)atts[1];
					attribs[2].Value = (byte[])atts[2];
					break;
				case 2:
					procIndex = 256;

					specs = new QueryAttributeSpec[3];
					for (int j=0; j<specs.Length; j++)
						specs[j] = new QueryAttributeSpec();
					specs[0].len = 8;
					specs[0].type = 0x80000000;
					specs[1].len = 8;
					specs[1].type = 0x00000001;
					specs[2].len = 400;
					specs[2].type = 0x00100003;

					attribs = new QueryAttribute[1];
					attribs[0] = new QueryAttribute();
					attribs[0].Id = 0x00200005;
					atts = StressHelpers.GetQueryAttribs(rnd.Next(0,(int)QAChoices.NumChoices));
					attribs[0].Value = (byte[])atts[2];
					break;
				case 3:
					procIndex = 4;

					specs = new QueryAttributeSpec[4];
					for (int j=0; j<specs.Length; j++)
						specs[j] = new QueryAttributeSpec();
					specs[0].len = 8;
					specs[0].type = 0x80000000;
					specs[1].len = 8;
					specs[1].type = 0x00000001;
					specs[2].len = 400;
					specs[2].type = 0x00100003;
					specs[3].len = 800;
					specs[3].type = 0x00200005;

					attribs = new QueryAttribute[2];
					for (int j=0; j<attribs.Length; j++)
						attribs[j] = new QueryAttribute();
					attribs[0].Id = 0x00000001;
					attribs[1].Id = 0x00100003;
					atts = StressHelpers.GetQueryAttribs(rnd.Next(0,(int)QAChoices.NumChoices));
					attribs[0].Value = (long)atts[0];
					attribs[1].Value = (string)atts[1];
					break;
			}

			try
			{
				uint nReps = (uint)rnd.Next(3,8);
				for (uint page=0; page<nReps; page++)
					query.WidgetSearch(QueryWidgetCommon.QUERY_TITLE_ID,10,procIndex,page,resultsPerPage,specs,attribs);
			}
			catch (Exception e)
			{
				ResultCode=TEST_RESULTS.FAILED;
				System.IO.StreamWriter strWriter = System.IO.File.AppendText(@"C:\xonline\private\test\StfTests\QueryWidget\stressErrors.txt");
				strWriter.WriteLine(DateTime.Now.GetDateTimeFormats()[71]+"  QuerySearchConsec fail: "+e.Message+" procIndex: "+procIndex+" resultsPerPage: "+resultsPerPage);
				strWriter.Close();
			}
		}
	}

	[StressInstantiate, StressTest(Priority=1)]
	public class StressQueryFindFromIds : TestBase
	{
		override protected void Execute()
		{
			WCQuery query = new WCQuery();
			System.Random rnd = new Random(DateTime.Now.Millisecond + DateTime.Now.Second);

			ResultCode=TEST_RESULTS.PASSED;

			uint procIndex = (uint)rnd.Next(1,4);		// want value 1 - 3
			QueryAttributeSpec [] specs = null;

			switch (procIndex)
			{
				case 1:
					specs = new QueryAttributeSpec[3];
					for (int j=0; j<specs.Length; j++)
						specs[j] = new QueryAttributeSpec();
					specs[0].len = 8;
					specs[0].type = 0x80000000;
					specs[1].len = 8;
					specs[1].type = 0x00000001;
					specs[2].len = 800;
					specs[2].type = 0x00200005;
					break;
				case 2:
					specs = new QueryAttributeSpec[2];
					for (int j=0; j<specs.Length; j++)
						specs[j] = new QueryAttributeSpec();
					specs[0].len = 8;
					specs[0].type = 0x80000000;
					specs[1].len = 400;
					specs[1].type = 0x00100003;
					break;
				case 3:
					specs = new QueryAttributeSpec[4];
					for (int j=0; j<specs.Length; j++)
						specs[j] = new QueryAttributeSpec();
					specs[0].len = 8;
					specs[0].type = 0x80000000;
					specs[1].len = 8;
					specs[1].type = 0x00000001;
					specs[2].len = 400;
					specs[2].type = 0x00100003;
					specs[3].len = 800;
					specs[3].type = 0x00200005;
					break;
			}

			// get subset of entityIds
			ulong [] entityIds = null;
			ArrayList indices = new ArrayList();
			lock (StressHelpers.QueryEntries)
			{
				if (StressHelpers.QueryEntries.Count > 0)
				{
					if (StressHelpers.QueryEntries.Count > 3)
					{
						entityIds = new ulong[3];
						if (StressHelpers.QueryEntries.Count < 10)
						{
							// just take first 3
							for (int i=0; i<entityIds.Length; i++)
							{
								entityIds[i] = ((AddedEntryInfo)StressHelpers.QueryEntries[i]).entityId;
								indices.Add(i);
							}
						}
						else
						{
							// randomize it
							for (int i=0; i<entityIds.Length; i++)
							{
								bool duplicate = true;
								while (duplicate)
								{
									indices.Add(rnd.Next(0,StressHelpers.QueryEntries.Count-1));
									entityIds[i] = ((AddedEntryInfo)StressHelpers.QueryEntries[(int)indices[i]]).entityId;
									duplicate = false;
									for (int j=0; j<i; j++)
									{
										if (entityIds[j] == entityIds[i])
										{
											duplicate = true;
											indices.RemoveAt(indices.Count-1);
											break;
										}
									}
								}
							}
						}
					}
					else
					{
						entityIds = new ulong[StressHelpers.QueryEntries.Count];
						for (int i=0; i<entityIds.Length; i++)
						{
							entityIds[i] = ((AddedEntryInfo)StressHelpers.QueryEntries[i]).entityId;
							indices.Add(i);
						}
					}
				}
			}
			if (entityIds == null)
			{
				ResultCode=TEST_RESULTS.NOT_EXECUTED;
				return;
			}

			try
			{
				FindFromIdsResponse result = query.WidgetFindFromIds(QueryWidgetCommon.QUERY_TITLE_ID,10,procIndex,specs,entityIds);
			}
			catch (Exception e)
			{
				ResultCode=TEST_RESULTS.FAILED;
				System.IO.StreamWriter strWriter = System.IO.File.AppendText(@"C:\xonline\private\test\StfTests\QueryWidget\stressErrors.txt");
				string errorStr = DateTime.Now.GetDateTimeFormats()[71]+"  QueryFind fail: "+e.Message+" procIndex: "+procIndex;
				for (int i=0; i<entityIds.Length; i++)
					errorStr += " Id: "+entityIds[i];
				strWriter.WriteLine(errorStr);
				strWriter.Close();
				if (e.Message.EndsWith("The requested entity does not exist in the dataset specified."))
				{
					indices.Sort();
					indices.Reverse();
					lock(StressHelpers.QueryEntries)
					{
						foreach (int index in indices)
						{
							StressHelpers.QueryEntries.RemoveAt(index);
						}
					}
				}
			}
		}
	}

	[StressInstantiate, StressTest(Priority=.01F)]
	public class StressQueryUpdateId : TestBase
	{
		override protected void Execute()
		{
			WCQuery query = new WCQuery();
			System.Random rnd = new Random(DateTime.Now.Millisecond + DateTime.Now.Second);

			ResultCode=TEST_RESULTS.PASSED;

			uint procIndex = (uint)rnd.Next(1,5);		// want value 1 - 4
			QueryAttribute [] attribs = null;

			int choice = rnd.Next(0,3);
			if (choice == 0)
				choice = (int)QAChoices.AddLarge;
			else if (choice == 1)
				choice = (int)QAChoices.AddUserTeam;
			else
				choice = (int)QAChoices.Update;
			object [] atts = StressHelpers.GetQueryAttribs(choice);
			switch (procIndex)
			{
				case 1:
					procIndex = 1;
					attribs = new QueryAttribute[2];
					for (int j=0; j<attribs.Length; j++)
						attribs[j] = new QueryAttribute();
					attribs[0].Id = 0x00000001;
					attribs[1].Id = 0x00100003;
					attribs[0].Value = (long)atts[0];
					attribs[1].Value = (string)atts[1];
					break;
				case 2:
					procIndex = 16;
					attribs = new QueryAttribute[1];
					for (int j=0; j<attribs.Length; j++)
						attribs[j] = new QueryAttribute();
					attribs[0].Id = 0x00200005;
					attribs[0].Value = (byte[])atts[2];
					break;
				case 3:
					procIndex = 256;
					attribs = new QueryAttribute[3];
					for (int j=0; j<attribs.Length; j++)
						attribs[j] = new QueryAttribute();
					attribs[0].Id = 0x00000001;
					attribs[1].Id = 0x00100003;
					attribs[2].Id = 0x00200005;
					attribs[0].Value = (long)atts[0];
					attribs[1].Value = (string)atts[1];
					attribs[2].Value = (byte[])atts[2];
					break;
				case 4:
					procIndex = 4096;
					attribs = new QueryAttribute[2];
					for (int j=0; j<attribs.Length; j++)
						attribs[j] = new QueryAttribute();
					attribs[0].Id = 0x00100003;
					attribs[1].Id = 0x00200005;
					attribs[0].Value = (string)atts[1];
					attribs[1].Value = (byte[])atts[2];
					break;
			}

			// get entityId & user/team
			int nUser = 0;
			string teamName = "";
			ulong entityToUpdate = 0;
			lock (StressHelpers.QueryEntries)
			{
				if (StressHelpers.QueryEntries.Count > 0)
				{
					int index = rnd.Next(0,StressHelpers.QueryEntries.Count);
					AddedEntryInfo ai = (AddedEntryInfo)StressHelpers.QueryEntries[index];
					entityToUpdate = ai.entityId;
					nUser = ai.nUser;
					if (ai.nTeam >= 0)
						teamName = "webteam"+ai.nTeam;
				}
			}
			if (0 == entityToUpdate)
			{
				ResultCode=TEST_RESULTS.NOT_EXECUTED;
				return;
			}

			try
			{
				query.WidgetUpdateId(QueryWidgetCommon.QUERY_TITLE_ID,BitConverter.GetBytes(Convert.ToUInt64(562949953420287+nUser)),"webuser"+nUser,teamName,10,procIndex,entityToUpdate,attribs);

				if (StressHelpers.logging)
				{
					StressHelpers.strInfo.WriteLine(DateTime.Now.GetDateTimeFormats()[71]+"  U: "+entityToUpdate);
					StressHelpers.strInfo.Flush();
				}
			}
			catch (Exception e)
			{
				ResultCode=TEST_RESULTS.FAILED;
				System.IO.StreamWriter strWriter = System.IO.File.AppendText(@"C:\xonline\private\test\StfTests\QueryWidget\stressErrors.txt");
				strWriter.WriteLine(DateTime.Now.GetDateTimeFormats()[71]+"  QueryUpdateId fail: "+e.Message+" procIndex: "+procIndex+" user: "+nUser+" team: "+teamName);
				strWriter.Close();
			}
		}
	}

	[StressInstantiate, StressTest(Priority=.01F)]
	public class StressQueryAddImmUpdate : TestBase
	{
		override protected void Execute()
		{
			WCQuery query = new WCQuery();
			System.Random rnd = new Random(DateTime.Now.Millisecond + DateTime.Now.Second);

			ResultCode=TEST_RESULTS.PASSED;

			// choose a user
			int nUser = rnd.Next(0,1024);
			string teamName = "";
			if (rnd.Next(0,2) == 0)
				teamName = "webteam"+Convert.ToString(nUser/4);

			uint procIndex = (uint)rnd.Next(2);		// want value 0 or 1
			QueryAttribute [] attribs = null;

			// set up attributes for Add
			QueryAttribute [] QA = new QueryAttribute[3];
			for (int j=0; j<QA.Length; j++)
				QA[j] = new QueryAttribute();
			QA[0].Id = 0x00000001;
			QA[1].Id = 0x00100003;
			QA[2].Id = 0x00200005;
			int searchAttrib = (int)QAChoices.Update;
			object [] atts1 = StressHelpers.GetQueryAttribs(searchAttrib);
			QA[0].Value = (long)atts1[0];
			QA[1].Value = (string)atts1[1];
			QA[2].Value = (byte[])atts1[2];

			// set up attributes for Update
			int updateAttrib = rnd.Next(2);
			if (updateAttrib == 0)
				updateAttrib = (int)QAChoices.AddLarge;
			else if (updateAttrib == 1)
				updateAttrib = (int)QAChoices.AddUserTeam;
			object [] atts2 = StressHelpers.GetQueryAttribs(updateAttrib);
			switch (procIndex)
			{
				case 0:
					procIndex = 0;
					attribs = new QueryAttribute[2];
					for (int j=0; j<attribs.Length; j++)
						attribs[j] = new QueryAttribute();
					attribs[0].Id = 0x00000001;
					attribs[1].Id = 0x00100003;
					attribs[0].Value = (long)atts1[0];
					attribs[1].Value = (string)atts2[1];
					break;
				case 1:
					procIndex = 32;
					attribs = new QueryAttribute[3];
					for (int j=0; j<attribs.Length; j++)
						attribs[j] = new QueryAttribute();
					attribs[0].Id = 0x00000001;
					attribs[1].Id = 0x00100003;
					attribs[2].Id = 0x00200005;
					object [] atts = StressHelpers.GetQueryAttribs((int)QAChoices.Update);
					attribs[0].Value = (long)atts2[0];
					attribs[1].Value = (string)atts2[1];
					attribs[2].Value = (byte[])atts1[2];
					break;
			}

			try
			{
				query.WidgetAdd(QueryWidgetCommon.QUERY_TITLE_ID,BitConverter.GetBytes(Convert.ToUInt64(562949953420287+nUser)),"webuser"+nUser,teamName,10,QA);
				query.WidgetUpdate(QueryWidgetCommon.QUERY_TITLE_ID,BitConverter.GetBytes(Convert.ToUInt64(562949953420287+nUser)),"webuser"+nUser,teamName,10,procIndex,attribs);
			}
			catch (Exception e)
			{
				ResultCode=TEST_RESULTS.FAILED;
				System.IO.StreamWriter strWriter = System.IO.File.AppendText(@"C:\xonline\private\test\StfTests\QueryWidget\stressErrors.txt");
				strWriter.WriteLine(DateTime.Now.GetDateTimeFormats()[71]+"  QueryUpdate fail: "+e.Message+" procIndex: "+procIndex+" user: "+nUser+" team: "+teamName);
				strWriter.Close();
			}
		}
	}

	[StressInstantiate, StressTest(Priority=.01F)]
	public class StressQueryAddWithImmediateRemoveId : TestBase
	{
		override protected void Execute()
		{
			WCQuery query = new WCQuery();
			System.Random rnd = new Random(DateTime.Now.Millisecond + DateTime.Now.Second);

			ResultCode=TEST_RESULTS.PASSED;

			// choose user
			int nUser = rnd.Next(0,1024);
			string teamName = "";
			if (rnd.Next(0,2) == 0)
				teamName = "webteam"+Convert.ToString(nUser/4);

			// choose attributes to store
			QueryAttribute [] QA = new QueryAttribute[3];
			for (int j=0; j<QA.Length; j++)
				QA[j] = new QueryAttribute();
			QA[0].Id = 0x00000001;
			QA[1].Id = 0x00100003;
			QA[2].Id = 0x00200005;
			object [] atts = StressHelpers.GetQueryAttribs((int)QAChoices.AddImmRemoveId);
			QA[0].Value = (long)atts[0];
			QA[1].Value = (string)atts[1];
			QA[2].Value = (byte[])atts[2];

			try
			{
				ulong entityId = query.WidgetAdd(QueryWidgetCommon.QUERY_TITLE_ID,BitConverter.GetBytes(Convert.ToUInt64(562949953420287+nUser)),"webuser"+nUser,teamName,10,QA);
				query.WidgetRemoveId(QueryWidgetCommon.QUERY_TITLE_ID,BitConverter.GetBytes(Convert.ToUInt64(562949953420287+nUser)),"webuser"+nUser,teamName,10,entityId);
			}
			catch (Exception e)
			{
				ResultCode=TEST_RESULTS.FAILED;
				System.IO.StreamWriter strWriter = System.IO.File.AppendText(@"C:\xonline\private\test\StfTests\QueryWidget\stressErrors.txt");
				strWriter.WriteLine(DateTime.Now.GetDateTimeFormats()[71]+"  QueryAddRemoveId fail: "+e.Message+" user: "+nUser+" team: "+teamName);
				strWriter.Close();
			}
		}
	}

	[StressInstantiate, StressTest(Priority=.01F)]
	public class StressQueryAddWithImmediateRemove : TestBase
	{
		override protected void Execute()
		{
			WCQuery query = new WCQuery();
			System.Random rnd = new Random(DateTime.Now.Millisecond + DateTime.Now.Second);

			ResultCode=TEST_RESULTS.PASSED;

			// choose user/team
			int nUser = rnd.Next(0,1024);
			string teamName = "";
			if (rnd.Next(0,2) == 0)
				teamName = "webteam"+Convert.ToString(nUser/4);

			// choose attributes to store
			QueryAttribute [] QA = new QueryAttribute[3];
			for (int j=0; j<QA.Length; j++)
				QA[j] = new QueryAttribute();
			QA[0].Id = 0x00000001;
			QA[1].Id = 0x00100003;
			QA[2].Id = 0x00200005;
			object [] atts = StressHelpers.GetQueryAttribs((int)QAChoices.AddImmRemove);
			QA[0].Value = (long)atts[0];
			QA[1].Value = (string)atts[1];
			QA[2].Value = (byte[])atts[2];

			// choose procIndex
			uint procIndex = (uint)(5*rnd.Next(1,4));	// want 5, 10, or 15
			QueryAttribute [] attribs = null;
			switch (procIndex)
			{
				case 5:
					attribs = new QueryAttribute[2];
					for (int i=0; i<attribs.Length; i++)
						attribs[i] = new QueryAttribute();
					attribs[0].Id = 0x00000001;
					attribs[1].Id = 0x00200005;
					attribs[0].Value = (long)atts[0];
					attribs[1].Value = (byte[])atts[2];
					break;
				case 10:
					attribs = new QueryAttribute[3];
					for (int i=0; i<attribs.Length; i++)
						attribs[i] = new QueryAttribute();
					attribs[0].Id = 0x00000001;
					attribs[1].Id = 0x00100003;
					attribs[2].Id = 0x00200005;
					attribs[0].Value = (long)atts[0];
					attribs[1].Value = (string)atts[1];
					attribs[2].Value = (byte[])atts[2];
					break;
				case 15:
					attribs = new QueryAttribute[1];
					attribs[0] = new QueryAttribute();
					attribs[0].Id = 0x00000001;
					attribs[0].Value = (long)atts[0];
					break;
			}

			try
			{
				query.WidgetAdd(QueryWidgetCommon.QUERY_TITLE_ID,BitConverter.GetBytes(Convert.ToUInt64(562949953420287+nUser)),"webuser"+nUser,teamName,10,QA);
				query.WidgetRemove(QueryWidgetCommon.QUERY_TITLE_ID,BitConverter.GetBytes(Convert.ToUInt64(562949953420287+nUser)),"webuser"+nUser,teamName,10,procIndex,attribs);
			}
			catch (Exception e)
			{
				ResultCode=TEST_RESULTS.FAILED;
				System.IO.StreamWriter strWriter = System.IO.File.AppendText(@"C:\xonline\private\test\StfTests\QueryWidget\stressErrors.txt");
				strWriter.WriteLine(DateTime.Now.GetDateTimeFormats()[71]+"  QueryAddRemove fail: "+e.Message+" user: "+nUser+" team: "+teamName);
				strWriter.Close();
			}
		}
	}

	[StressInstantiate, StressTest(Priority=.5F)]
	public class StressQueryGetXQS : TestBase
	{
		override protected void Execute()
		{
			WCQuery query = new WCQuery(Global.XEnv.GetVirtualInterface(VirtualInterface.wcquery),new RequestInfo("DebugAdmin"));
			System.Random rnd = new Random(DateTime.Now.Millisecond + DateTime.Now.Second);

			ResultCode=TEST_RESULTS.PASSED;

			ulong webId = (ulong)rnd.Next();
			ulong haveVersion = (ulong)rnd.Next(0,50);

			try
			{
				string result = query.WidgetGetXQSConfig(QueryWidgetCommon.QUERY_TITLE_ID,BitConverter.GetBytes(webId),haveVersion);

				if (!result.ToLower().StartsWith("<?xml version=\"1.0\" encoding=\"utf-8\"?>"))
					ResultCode=TEST_RESULTS.FAILED;
			}
			catch (Exception e)
			{
				ResultCode=TEST_RESULTS.FAILED;
				System.IO.StreamWriter strWriter = System.IO.File.AppendText(@"C:\xonline\private\test\StfTests\QueryWidget\stressErrors.txt");
				strWriter.WriteLine(DateTime.Now.GetDateTimeFormats()[71]+"  GetXQS fail: "+e.Message);
				strWriter.Close();
			}
		}
	}

	[StressInstantiate, StressTest(Priority=.5F)]
	public class StressQueryGetXQSHaveLatest : TestBase
	{
		override protected void Execute()
		{
			WCQuery query = new WCQuery(Global.XEnv.GetVirtualInterface(VirtualInterface.wcquery),new RequestInfo("DebugAdmin"));
			System.Random rnd = new Random(DateTime.Now.Millisecond + DateTime.Now.Second);

			ResultCode=TEST_RESULTS.PASSED;

			ulong webId = (ulong)rnd.Next();
			ulong haveVersion = 0x1000000000000;

			try
			{
				string result = query.WidgetGetXQSConfig(QueryWidgetCommon.QUERY_TITLE_ID,BitConverter.GetBytes(webId),haveVersion);

				if (0 != result.CompareTo("You have the latest version"))
					ResultCode=TEST_RESULTS.FAILED;
			}
			catch (Exception e)
			{
				ResultCode=TEST_RESULTS.FAILED;
				System.IO.StreamWriter strWriter = System.IO.File.AppendText(@"C:\xonline\private\test\StfTests\QueryWidget\stressErrors.txt");
				strWriter.WriteLine(DateTime.Now.GetDateTimeFormats()[71]+"  GetXQSHaveLatest fail: "+e.Message);
				strWriter.Close();
			}
		}
	}

	/*************************** begin COMPS ****************************/

	[StressInstantiate, StressTest(Priority=.1F)]
	public class StressCompsCreation : TestBase
	{
		public static WCQuery query = new WCQuery();
		public static System.Random rnd = new Random(DateTime.Now.Millisecond + DateTime.Now.Second);

		override protected void Execute()
		{
			ResultCode=TEST_RESULTS.PASSED;

			bool teamBased = true;
			ulong result = 0;
			int userId = rnd.Next(0,1024);

			if (0 == rnd.Next(0,2))
				teamBased = false;

			DateTime dtCreated = DateTime.Now;
			if (0 == rnd.Next(0,2))
				// create tournament with regular CompetitionCreate
			{
				result = StressHelpers.CompCreate(query, rnd, teamBased, userId);
			}
			else
				// create tournament with CompetitionCreateSingleElimination
			{
				result = StressHelpers.CompCreateSE(query, rnd, teamBased, userId);
			}

			if (0 == result)
				ResultCode=TEST_RESULTS.FAILED;
			else
			{
				AddedEntryInfo ai = new AddedEntryInfo();
				ai.dtCreated = dtCreated;
				ai.entityId = result;
				ai.nUser = userId;
				ai.nTeam = -1;
				if (teamBased)
					ai.nTeam = userId/8;

				lock(StressHelpers.openComps)
				{
					StressHelpers.openComps.Push(ai);
				}
			}
		}
	}

	[StressInstantiate, StressTest(Priority=.01F)]
	public class StressCompsCancel : TestBase
	{
		public static WCQuery query = new WCQuery();
		public static System.Random rnd = new Random(DateTime.Now.Millisecond + DateTime.Now.Second);

		override protected void Execute()
		{

			ResultCode=TEST_RESULTS.PASSED;

			AddedEntryInfo ai = new AddedEntryInfo();
			ai.entityId = 0;

			lock(StressHelpers.openComps)
			{
				while (StressHelpers.openComps.Count > 0)
				{
					ai = ((AddedEntryInfo)StressHelpers.openComps.Pop());
					if (ai.dtCreated.AddMinutes(4) >= DateTime.Now)
						break;
					ai.entityId = 0;
				}

				if (ai.entityId == 0)
					ResultCode=TEST_RESULTS.NOT_EXECUTED;
			}
			if (0 == ai.entityId)
				return;

			string teamName = "";
			if (ai.nTeam >= 0)
				teamName = "webteam"+ai.nTeam;

			try
			{
				query.WidgetCompetitionCancel(QueryWidgetCommon.COMPS_TITLE_ID,BitConverter.GetBytes(Convert.ToUInt64(562949953420287+ai.nUser)),"webuser"+ai.nUser,teamName,1,ai.entityId);
			}
			catch (Exception e)
			{
				ResultCode = TEST_RESULTS.FAILED;
				System.IO.StreamWriter strWriter = System.IO.File.AppendText(@"C:\xonline\private\test\StfTests\QueryWidget\stressErrors.txt");
				strWriter.WriteLine(DateTime.Now.GetDateTimeFormats()[71]+"  CompsCancel fail: "+e.Message+" entityId: "+ai.entityId+" user: "+ai.nUser+" team: "+teamName);
				strWriter.Close();
			}
		}
	}

	[StressInstantiate, StressTest(Priority=.5F)]
	public class StressCompsSearch : TestBase
	{
		public static WCQuery query = new WCQuery();
		public static System.Random rnd = new Random(DateTime.Now.Millisecond + DateTime.Now.Second);

		override protected void Execute()
		{
			QueryAttribute [] QA = null;

			// create ownerID to search for
			long ownerId = 0;
			if (rnd.Next(0,2) == 0)
				ownerId = 2814749767106559 - (long)rnd.Next(0,1024);		// user
			else
				ownerId = (long)(0xFEFE0000C3B0FFFF - (ulong)rnd.Next(0,128));		// team

			uint procIndex = (uint)rnd.Next(1,4);
			QueryAttributeSpec [] specs = StressHelpers.CSearchSpecs;
			switch (procIndex)
			{
				case 1:
					// search with time & map
					QA = new QueryAttribute[2];
					for (int i=0; i<QA.Length; i++)
						QA[i] = new QueryAttribute();
					QA[0].Id = 0x82000003;
					QA[1].Id = 0x02010001;
					QA[0].Value = (long)DateTime.UtcNow.ToFileTimeUtc();
					QA[1].Value = (long)rnd.Next(50,60);
					break;
				case 2:
					// search with ownerId, status, Name
					QA = new QueryAttribute[3];
					for (int i=0; i<QA.Length; i++)
						QA[i] = new QueryAttribute();
					QA[0].Id = 0x82000001;
					QA[1].Id = 0x8201001D;
					QA[2].Id = 0x02110002;
					QA[0].Value = (long)ownerId;
					QA[1].Value = (long)1;
					QA[2].Value = "testing stress thru query widget with competitions";
					break;
				case 3:
					// search with ownerID & Name
					specs = new QueryAttributeSpec[17];
					Array.Copy(StressHelpers.CSearchSpecs,0,specs,0,16);
					specs[16] = new QueryAttributeSpec();
					specs[16].type = 0x8001001A;
					specs[16].len = 8;
					QA = new QueryAttribute[2];
					for (int i=0; i<QA.Length; i++)
						QA[i] = new QueryAttribute();
					QA[0].Id = 0x82000001;
					QA[1].Id = 0x02110002;
					QA[0].Value = (long)ownerId;
					QA[1].Value = "testing stress thru query widget with competitions";
					break;
			}

			try
			{
				uint resultsPerPage = (uint)rnd.Next(1,10);
				for (uint page = 0; page<5; page++)
					query.WidgetCompetitionSearch(QueryWidgetCommon.COMPS_TITLE_ID,1,procIndex,0,resultsPerPage,specs,QA);
				ResultCode=TEST_RESULTS.PASSED;
			}
			catch (Exception e)
			{
				ResultCode = TEST_RESULTS.FAILED;
				System.IO.StreamWriter strWriter = System.IO.File.AppendText(@"C:\xonline\private\test\StfTests\QueryWidget\stressErrors.txt");
				strWriter.WriteLine(DateTime.Now.GetDateTimeFormats()[71]+"  CompsSearch fail: "+e.Message+" procIndex: "+procIndex);
				strWriter.Close();
			}
		}
	}

	[StressInstantiate, StressTest(Priority=.5F)]
	public class StressCompsTopology : TestBase
	{
		public static WCQuery query = new WCQuery();
		public static System.Random rnd = new Random(DateTime.Now.Millisecond + DateTime.Now.Second);

		override protected void Execute()
		{
			ulong entityId = 0;

			lock(StressHelpers.startedComps)
			{
				if (StressHelpers.topId.dtCreated.AddMinutes(10) < DateTime.Now && StressHelpers.startedComps.Count > 25)
					StressHelpers.topId = (AddedEntryInfo)StressHelpers.startedComps.Pop();
				else if (0 == StressHelpers.topId.entityId && StressHelpers.startedComps.Count > 0)
					StressHelpers.topId = (AddedEntryInfo)StressHelpers.startedComps.Peek();

				entityId = StressHelpers.topId.entityId;
				if (StressHelpers.topId.dtCreated.AddMinutes(7) > DateTime.Now)
					entityId = 0;
			}

			if (0 == entityId)
			{
				ResultCode=TEST_RESULTS.NOT_EXECUTED;
				return;
			}

			try
			{
				uint resultsPerPage = (uint)rnd.Next(3,10);
				for (uint page=0; page<5; page++)
				{
					query.WidgetCompetitionTopology(QueryWidgetCommon.COMPS_TITLE_ID,3,entityId,page,resultsPerPage,0x00001,0x50001,StressHelpers.topSpecs);
				}
				ResultCode=TEST_RESULTS.PASSED;
			}
			catch (Exception e)
			{
				ResultCode = TEST_RESULTS.FAILED;
				System.IO.StreamWriter strWriter = System.IO.File.AppendText(@"C:\xonline\private\test\StfTests\QueryWidget\stressErrors.txt");
				strWriter.WriteLine(DateTime.Now.GetDateTimeFormats()[71]+"  CompsTopology fail: "+e.Message+" entityId: "+entityId);
				strWriter.Close();
			}
		}
	}

	[StressInstantiate, StressTest(Priority=2)]
	public class StressCompsTopologySE : TestBase
	{
		public static WCQuery query = new WCQuery();
		public static System.Random rnd = new Random(DateTime.Now.Millisecond + DateTime.Now.Second);

		override protected void Execute()
		{
			ulong entityId = 0;

			lock(StressHelpers.startedComps)
			{
				if (StressHelpers.topId.dtCreated.AddMinutes(10) < DateTime.Now && StressHelpers.startedComps.Count > 25)
					StressHelpers.topId = (AddedEntryInfo)StressHelpers.startedComps.Pop();
				else if (0 == StressHelpers.topId.entityId && StressHelpers.startedComps.Count > 0)
					StressHelpers.topId = (AddedEntryInfo)StressHelpers.startedComps.Peek();

				entityId = StressHelpers.topId.entityId;
				if (StressHelpers.topId.dtCreated.AddMinutes(7) > DateTime.Now)
					entityId = 0;
			}

			if (0 == entityId)
			{
				ResultCode=TEST_RESULTS.NOT_EXECUTED;
				return;
			}

			try
			{
				query.WidgetCompetitionTopologySingleElimination(QueryWidgetCommon.COMPS_TITLE_ID,3,entityId,0x20003,(uint)rnd.Next(0,3),(uint)rnd.Next(0,3),(uint)rnd.Next(0,4),StressHelpers.topSpecs);
				ResultCode=TEST_RESULTS.PASSED;
			}
			catch (Exception e)
			{
				ResultCode = TEST_RESULTS.FAILED;
				System.IO.StreamWriter strWriter = System.IO.File.AppendText(@"C:\xonline\private\test\StfTests\QueryWidget\stressErrors.txt");
				strWriter.WriteLine(DateTime.Now.GetDateTimeFormats()[71]+"  CompsTopology fail: "+e.Message+" entityId: "+entityId);
				strWriter.Close();
			}
		}
	}

	[StressInstantiate, StressTest(Priority=6)]
	public class StressCompsManage_QuerySelect : TestBase
	{
		public static WCQuery query = new WCQuery();
		public static System.Random rnd = new Random(DateTime.Now.Millisecond + DateTime.Now.Second);

		override protected void Execute()
		{
			ResultCode=TEST_RESULTS.PASSED;
			int nUser = 0;
			string teamName = "";
			AddedEntryInfo ai = new AddedEntryInfo();

			lock(StressHelpers.openComps)
			{
				if (0 == StressHelpers.joinedUsers)
				{
					StressHelpers.ai.entityId = 0;

					// get a new comp to work with
					while (StressHelpers.openComps.Count > 0 && StressHelpers.ai.entityId == 0)
					{
						StressHelpers.ai = ((AddedEntryInfo)StressHelpers.openComps.Pop());
						if (StressHelpers.ai.dtCreated.AddMinutes(3) < DateTime.Now)
							StressHelpers.ai.entityId = 0;
					}
				}

				ai.entityId = StressHelpers.ai.entityId;
				ai.dtCreated = StressHelpers.ai.dtCreated;

				if (ai.entityId != 0)
				{
					nUser = StressHelpers.joinedUsers++;
					if (StressHelpers.ai.nTeam >= 0)
					{
						teamName = "webteam"+nUser;
						nUser = nUser*8;
					}

					// add comp to list of available for topology
					if (StressHelpers.joinedUsers == 120)
					{
						lock (StressHelpers.startedComps)
						{
							if (StressHelpers.startedComps.Count == 0 ||
								(StressHelpers.startedComps.Count < 1000 && rnd.Next(20) == 0))
							{
								StressHelpers.startedComps.Push(ai);
							}
						}

						StressHelpers.joinedUsers = 0;
					}
				}
			}

			if (0 == ai.entityId)
			{
				// no comp yet
				ResultCode=TEST_RESULTS.NOT_EXECUTED;
				return;
			}

			byte [] webId = BitConverter.GetBytes(Convert.ToUInt64(562949953420287+nUser));
			uint action = 1;	// join
			if (rnd.Next(0,5) == 0)
				action = 2;		// join private

			try
			{
				// choose between Select or ManageEntrant
				if (rnd.Next(0,2) == 0)
					query.WidgetCompetitionManageEntrant(QueryWidgetCommon.COMPS_TITLE_ID,webId,"webuser"+nUser,action,teamName,1,ai.entityId,null);
				else
					query.WidgetSelect(QueryWidgetCommon.COMPS_TITLE_ID,webId,"webuser"+nUser,teamName,1,ai.entityId,action,null);
			}
			catch (Exception e)
			{
				if (e.Message.EndsWith("The competition is closed to registration."))
					return;	// leave test results as passed - not really a failure.
				ResultCode = TEST_RESULTS.FAILED;
				System.IO.StreamWriter strWriter = System.IO.File.AppendText(@"C:\xonline\private\test\StfTests\QueryWidget\stressErrors.txt");
				strWriter.WriteLine(DateTime.Now.GetDateTimeFormats()[71]+"  Select/Manage fail: "+e.Message+" user: "+nUser+" team: "+teamName+" compId: "+ai.entityId);
				strWriter.Close();
				return;
			}
		}
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Query\test\dvt\querytest.cs ===
using System;
using System.Text;
using System.IO;
using System.Net;
using System.Web;
using System.Web.Services;
using System.Web.Services.Protocols;
using System.Xml;
using System.Threading;

using ServerTestFramework;
using xonline.common.config;
using xonline.common.diagnostics;
using xonline.common.nUnit;
using xonline.common.service;


namespace xonline.server.webcache.query.test.dvt 
{
    [TestGroup, DVT]
    public class QueryTests : TestNode
    {            
        public const uint    c_titleId = 0x00004d2;
        public byte[]        c_publisherWebId1 = new byte[8] { 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8 };

        // Test Datasets
        public const uint c_dsTest = 0x1;
        
        public const uint XONLINE_QUERY_ENTITY_ID                 = 0x80000000;
        public const uint XONLINE_QUERY_OWNER_PUID                = 0x80000001;
        
        public const uint XONLINE_QUERY_ATTR_INT1                 = 0x00000001;
        public const uint XONLINE_QUERY_ATTR_INT2                 = 0x00000002;
        public const uint XONLINE_QUERY_ATTR_STRING1              = 0x00100003;
        public const uint XONLINE_QUERY_ATTR_STRING2              = 0x00100004;
        public const uint XONLINE_QUERY_ATTR_BLOB1                = 0x00200005;

        
        [TestCase]
        public void TestQueryConfig()
        {
            QueryWidget qService = new QueryWidget(ConfigUtil.QueryWebServiceURL);
             
            qService.requestInfo = new RequestInfo("DebugAdmin");    // Credential type 2 partner
            
            try
            {
                Console.WriteLine("Calling GetXQSConfig");
                Console.WriteLine();

                string result = qService.GetXQSConfig(c_titleId, c_publisherWebId1, 0);

                Console.WriteLine(result);
                Console.WriteLine();
            }
            catch (Exception e)
            {
                Console.WriteLine("GetXQSConfig failed with message: " + e.Message);                

                // Should not get here!
                Assert.IsTrue(false);
            }

            try
            {
                Console.WriteLine("Calling GetXQSConfig with null webid");
                Console.WriteLine();
                
                string result = qService.GetXQSConfig(c_titleId, null, 0);

                // Should not get here!
                Assert.IsTrue(false);
            }
            catch (Exception e)
            {
                Console.WriteLine("GetXQSConfig failed with message: " + e.Message);                
            }
        }

        public ulong Add(GamerTagAndWebID c)
        {
            QueryWidget qService = new QueryWidget(ConfigUtil.QueryWebServiceURL);
            
            int                 i;
            ulong               entityId;
            QueryAttribute[]    attribs;
            
            Console.WriteLine("Calling Query.Add");
            Console.WriteLine();

            attribs = new QueryAttribute[5];
            for (i = 0; i < attribs.Length; i++)    { attribs[i] = new QueryAttribute(); }


            //
            // Setup attributes
            //
            attribs[0].Id = XONLINE_QUERY_ATTR_INT1;
            attribs[0].Value = (long)1234;            
            attribs[1].Id = XONLINE_QUERY_ATTR_INT2;    
            attribs[1].Value = (long)1;            
            attribs[2].Id = XONLINE_QUERY_ATTR_STRING1;    
            attribs[2].Value = "Query WebService TestQueryAdd";
            attribs[3].Id = XONLINE_QUERY_ATTR_STRING2;    
            attribs[3].Value = "Query WebService TestQueryAdd2";            
            attribs[4].Id = XONLINE_QUERY_ATTR_BLOB1;    
            attribs[4].Value = new byte[] { 0x1, 0x2, 0x3, 0x4, 0x3, 0x2, 0x1 };

            entityId = qService.Add(c_titleId, c.webID, c.gamerTag, null, c_dsTest, attribs);

            Console.WriteLine("entity " + entityId + " added." );
            Console.WriteLine();

            return entityId;
        }


        public void RemoveId(ulong entityId, GamerTagAndWebID c)
        {
            QueryWidget qService = new QueryWidget(ConfigUtil.QueryWebServiceURL);
            
            Console.WriteLine("Calling Query.RemoveId");
            Console.WriteLine();

            qService.RemoveId(c_titleId, c.webID, c.gamerTag, "", c_dsTest, entityId);

            Console.WriteLine("entity " + entityId + " removed." );
            Console.WriteLine();
        }

        
        public void UpdateId(ulong entityId, GamerTagAndWebID c)
        {
            QueryWidget qService = new QueryWidget(ConfigUtil.QueryWebServiceURL);
            
            int                 i;
            QueryAttribute[]    attribs;

            Console.WriteLine("Calling Query.UpdateId");
            Console.WriteLine();

            attribs = new QueryAttribute[5];
            for (i = 0; i < attribs.Length; i++)    { attribs[i] = new QueryAttribute(); }


            //
            // Setup attributes
            //
            attribs[0].Id = XONLINE_QUERY_ATTR_INT1;
            attribs[0].Value = (long)2;            
            attribs[1].Id = XONLINE_QUERY_ATTR_INT2;    
            attribs[1].Value = (long)6;            
            attribs[2].Id = XONLINE_QUERY_ATTR_STRING1;    
            attribs[2].Value = "A short update string";
            attribs[3].Id = XONLINE_QUERY_ATTR_STRING2;    
            attribs[3].Value = "A really loooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooong string";            
            attribs[4].Id = XONLINE_QUERY_ATTR_BLOB1;    
            attribs[4].Value = new byte[] { 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7 };

            qService.UpdateId(c_titleId, c.webID, c.gamerTag, "", c_dsTest, 1, entityId, attribs);

            Console.WriteLine("entity " + entityId + " updated." );
            Console.WriteLine();

        }

        
        [TestCase]
        public void TestQueryAdd()
        {
            GamerTagAndWebID c = User.GetRandomWebCredential();
            
            Add(c);
        }
        

        [TestCase]
        public void TestQueryRemoveId()
        {
            GamerTagAndWebID c = User.GetRandomWebCredential();

            ulong    entityId = Add(c);
            
            RemoveId(entityId, c);
        }

        
        [TestCase]
        public void TestQueryUpdate()
        {
            QueryWidget qService = new QueryWidget(ConfigUtil.QueryWebServiceURL);
            GamerTagAndWebID c = User.GetRandomWebCredential();
            
            int                 i;
            QueryAttribute[]    attribs;

            // Ensure there is something to update
            ulong               entityId = Add(c);
            
            Console.WriteLine("Calling Query.Update");
            Console.WriteLine();

            attribs = new QueryAttribute[5];
            for (i = 0; i < attribs.Length; i++)    { attribs[i] = new QueryAttribute(); }


            //
            // Setup attributes
            //
            attribs[0].Id = XONLINE_QUERY_ATTR_INT1;
            attribs[0].Value = (long)2;            
            attribs[1].Id = XONLINE_QUERY_ATTR_INT2;    
            attribs[1].Value = (long)0x7FFFFFFF00000000;            
            attribs[2].Id = XONLINE_QUERY_ATTR_STRING1;    
            attribs[2].Value = "Update updates everything by this owner";
            attribs[3].Id = XONLINE_QUERY_ATTR_STRING2;    
            attribs[3].Value = "See, we are all the same";            
            attribs[4].Id = XONLINE_QUERY_ATTR_BLOB1;    
            attribs[4].Value = new byte[] { 0x1 };

            qService.Update(c_titleId, c.webID, c.gamerTag, "", c_dsTest, 1, attribs);

            Console.WriteLine("entities for owner " + c.gamerTag + " updated." );
            Console.WriteLine();

            //
            // Cleanup
            //
            RemoveId(entityId, c);
        }


        [TestCase]
        public void TestQueryUpdateId()
        {
            GamerTagAndWebID c = User.GetRandomWebCredential();

            ulong               entityId = Add(c);
            
            UpdateId(entityId, c);

            //
            // Cleanup
            //
            RemoveId(entityId, c);
        }


        [TestCase]
        public void TestQueryRemove()
        {
            QueryWidget qService = new QueryWidget(ConfigUtil.QueryWebServiceURL);
            GamerTagAndWebID c = User.GetRandomWebCredential();
            
            int                 i;
            QueryAttribute[]    attribs;
            ulong               entityId = Add(c);

            // Need to update the object in order to make it eligible for the remove query
            UpdateId(entityId, c);

            
            Console.WriteLine("Calling Query.Remove");
            Console.WriteLine();

            attribs = new QueryAttribute[4];
            for (i = 0; i < attribs.Length; i++)    { attribs[i] = new QueryAttribute(); }

            //
            // Setup attributes
            //
            attribs[0].Id = XONLINE_QUERY_ATTR_INT2;    
            attribs[0].Value = (long)6;            
            attribs[1].Id = XONLINE_QUERY_ATTR_STRING1;    
            attribs[1].Value = "A short update string";
            attribs[2].Id = XONLINE_QUERY_ATTR_STRING2;    
            attribs[2].Value = "A really loooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooong string";            
            attribs[3].Id = XONLINE_QUERY_ATTR_BLOB1;    
            attribs[3].Value = new byte[] { 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7 };

            qService.Remove(c_titleId, c.webID, c.gamerTag, "", c_dsTest, 1, attribs);

            Console.WriteLine("entities with int2 > 5 removed." );
            Console.WriteLine();
        }


        [TestCase]
        public void TestQuerySearch()
        {
            QueryWidget qService = new QueryWidget(ConfigUtil.QueryWebServiceURL);
            GamerTagAndWebID c = User.GetRandomWebCredential();
            
            int                     i;
            QueryAttribute[]        attribs;
            QueryAttributeSpec[]    specs;
            SearchResponse          response;

            // Add something so we have something to find. 
            ulong                   entityId = Add(c);
            
            Console.WriteLine("Calling Query.Search");
            Console.WriteLine();

            attribs = new QueryAttribute[4];
            for (i = 0; i < attribs.Length; i++)  { attribs[i] = new QueryAttribute(); }

            attribs[0].Id = XONLINE_QUERY_ATTR_INT2;    
            attribs[0].Value = (long)1;            
            attribs[1].Id = XONLINE_QUERY_ATTR_STRING1;    
            attribs[1].Value = "Query WebService TestQueryAdd";
            attribs[2].Id = XONLINE_QUERY_ATTR_STRING2;    
            attribs[2].Value = "Query WebService TestQueryAdd2";            
            attribs[3].Id = XONLINE_QUERY_ATTR_BLOB1;    
            attribs[3].Value = new byte[] { 0x1, 0x2, 0x3, 0x4, 0x3, 0x2, 0x1 };
            
            specs = new QueryAttributeSpec[6];
            for (i = 0; i < specs.Length; i++)    { specs[i] = new QueryAttributeSpec(); }

            specs[0].type = XONLINE_QUERY_ENTITY_ID;
            specs[0].len = 8;            
            specs[1].type = XONLINE_QUERY_ATTR_INT1;
            specs[1].len = 8;            
            specs[2].type = XONLINE_QUERY_ATTR_INT2;    
            specs[2].len = 8;            
            specs[3].type = XONLINE_QUERY_ATTR_STRING1;    
            specs[3].len = 400;
            specs[4].type = XONLINE_QUERY_ATTR_STRING2;  
            specs[4].len = 400;            
            specs[5].type = XONLINE_QUERY_ATTR_BLOB1;   
            specs[5].len = 800;

            response = qService.Search(c_titleId, c_dsTest, 1, 0, 20, specs, attribs);

            Console.WriteLine("Searched and found " + response.totalResults + " entities." );
            Console.WriteLine();

            //
            // Cleanup
            //
            RemoveId(entityId, c);
        }
        

        [TestCase]
        public void TestQueryFind()
        {
            QueryWidget qService = new QueryWidget(ConfigUtil.QueryWebServiceURL);
            GamerTagAndWebID c = User.GetRandomWebCredential();
            
            int                     i;
            ulong                   entityId1 = Add(c);
            ulong                   entityId2 = Add(c);
            ulong[]                 entityIds;
            QueryAttributeSpec[]    specs;
            FindFromIdsResponse     response;
            
            Console.WriteLine("Calling Query.FindFromIds");
            Console.WriteLine();

            entityIds = new ulong[2];
            entityIds[0] = entityId1;
            entityIds[1] = entityId2;
          
            specs = new QueryAttributeSpec[6];
            for (i = 0; i < specs.Length; i++)    { specs[i] = new QueryAttributeSpec(); }

            specs[0].type = XONLINE_QUERY_ENTITY_ID;
            specs[0].len = 8;            
            specs[1].type = XONLINE_QUERY_ATTR_INT1;
            specs[1].len = 8;            
            specs[2].type = XONLINE_QUERY_ATTR_INT2;    
            specs[2].len = 8;            
            specs[3].type = XONLINE_QUERY_ATTR_STRING1;    
            specs[3].len = 400;
            specs[4].type = XONLINE_QUERY_ATTR_STRING2;  
            specs[4].len = 400;            
            specs[5].type = XONLINE_QUERY_ATTR_BLOB1;   
            specs[5].len = 800;

            response = qService.FindFromIds(c_titleId, c_dsTest, 1, specs, entityIds);

            Console.WriteLine("FindFromIds found " + response.returnedResults + " entities. (Expected 2)" );
            Console.WriteLine();

            //
            // Cleanup
            //
            RemoveId(entityId1, c);
            RemoveId(entityId2, c);
        }

        [TestCase]
        public void TestBadGamertag()
        {
            QueryWidget qService = new QueryWidget(ConfigUtil.QueryWebServiceURL);
            GamerTagAndWebID c;
            ulong             entityId;
            
            try
            {
                //
                // Try to add with bad user
                //
                c = User.GetRandomWebCredential();
                c.gamerTag += "000"; // max 15 chars

                entityId = Add(c);

                //
                // Cleanup
                //
                RemoveId(entityId, c);
            }
            catch(Exception e)
            {
                Console.WriteLine("TestBadGamertag excepted with message " + e.Message );
                Console.WriteLine();                
            }
            
        }

        [TestCase]
        public void TestPaddedGamertag()
        {
            QueryWidget qService = new QueryWidget(ConfigUtil.QueryWebServiceURL);
            GamerTagAndWebID c;
            ulong             entityId;

            try
            {
                //
                // Second case
                //
                c = User.GetRandomWebCredential();
                c.gamerTag += "  "; // max 15 chars
                
                entityId = Add(c);
                
                //
                // Cleanup
                //
                RemoveId(entityId, c);
            }
            catch(Exception e)
            {
                Console.WriteLine("TestBadGamertag excepted with message " + e.Message );
                Console.WriteLine();                
            }
        }

        [TestCase]
        [Ignore]
        public void TestTeamAdd()
        {
            GamerTagAndWebID c = User.GetRandomWebCredential();
            QueryWidget qService = new QueryWidget(ConfigUtil.QueryWebServiceURL);
            
            int                 i;
            ulong               entityId;
            QueryAttribute[]    attribs;
            
            Console.WriteLine("Calling Query.Add for Team");
            Console.WriteLine();

            attribs = new QueryAttribute[5];
            for (i = 0; i < attribs.Length; i++)    { attribs[i] = new QueryAttribute(); }


            //
            // Setup attributes
            //
            attribs[0].Id = XONLINE_QUERY_ATTR_INT1;
            attribs[0].Value = (long)1234;            
            attribs[1].Id = XONLINE_QUERY_ATTR_INT2;    
            attribs[1].Value = (long)1;            
            attribs[2].Id = XONLINE_QUERY_ATTR_STRING1;    
            attribs[2].Value = "Query WebService TestQueryAdd";
            attribs[3].Id = XONLINE_QUERY_ATTR_STRING2;    
            attribs[3].Value = "Query WebService TestQueryAdd2";            
            attribs[4].Id = XONLINE_QUERY_ATTR_BLOB1;    
            attribs[4].Value = new byte[] { 0x1, 0x2, 0x3, 0x4, 0x3, 0x2, 0x1 };

            entityId = qService.Add(c_titleId, c.webID, c.gamerTag, c.teamName, c_dsTest, attribs);

            Console.WriteLine("entity " + entityId + " added." );
            Console.WriteLine();
        }

        [TestCase]
        public void TestBadAttributes()
        {
            QueryWidget qService = new QueryWidget(ConfigUtil.QueryWebServiceURL);
            GamerTagAndWebID c = User.GetRandomWebCredential();
            
            int                     i;
            QueryAttribute[]        attribs;
            QueryAttributeSpec[]    specs;
            SearchResponse          response;

            // Add something so we have something to find. 
            ulong                   entityId = Add(c);
            
            Console.WriteLine("Calling Query.Search");
            Console.WriteLine();

            attribs = new QueryAttribute[6];
            for (i = 0; i < attribs.Length; i++)  { attribs[i] = new QueryAttribute(); }

            attribs[0].Id = XONLINE_QUERY_ATTR_INT1;
            attribs[0].Value = (long)1234;            
            attribs[1].Id = XONLINE_QUERY_ATTR_INT2;    
            attribs[1].Value = (long)1;            
            attribs[2].Id = XONLINE_QUERY_ATTR_STRING1;    
            attribs[2].Value = "Query WebService TestQueryAdd";
            attribs[3].Id = XONLINE_QUERY_ATTR_STRING2;    
            attribs[3].Value = "Query WebService TestQueryAdd2";            
            attribs[4].Id = XONLINE_QUERY_ATTR_BLOB1;    
            attribs[4].Value = new byte[] { 0x1, 0x2, 0x3, 0x4, 0x3, 0x2, 0x1 };

            // Bad attribute. This should cause an exception because '0' is not convertible to long in the widget
            attribs[5].Id = XONLINE_QUERY_OWNER_PUID;    
            attribs[5].Value = 0;
            
            specs = new QueryAttributeSpec[6];
            for (i = 0; i < specs.Length; i++)    { specs[i] = new QueryAttributeSpec(); }

            specs[0].type = XONLINE_QUERY_ENTITY_ID;
            specs[0].len = 8;            
            specs[1].type = XONLINE_QUERY_ATTR_INT1;
            specs[1].len = 8;            
            specs[2].type = XONLINE_QUERY_ATTR_INT2;    
            specs[2].len = 8;            
            specs[3].type = XONLINE_QUERY_ATTR_STRING1;    
            specs[3].len = 400;
            specs[4].type = XONLINE_QUERY_ATTR_STRING2;  
            specs[4].len = 400;            
            specs[5].type = XONLINE_QUERY_ATTR_BLOB1;   
            specs[5].len = 800;

            try
            {
                response = qService.Search(c_titleId, c_dsTest, 1, 0, 20, specs, attribs);

                Console.WriteLine("Error! Search returned and found " + response.totalResults + " entities when we expected an exception" );
                Console.WriteLine();

                Assert.IsTrue(false);
            }
            catch (SoapException se)
            {
                Assert.IsTrue(-1 != se.Message.IndexOf("Error: 80070057: One or more QueryAttributes objects had values that do not match the specified attribute type."));

                Console.WriteLine("Search excepted with the correct error code: ");
                Console.WriteLine(se.Message);
                Console.WriteLine();
            }

            //
            // Cleanup
            //
            RemoveId(entityId, c);
        }
        
        
    }        
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Query\test\dvt\elimtest.cs ===
using System;
using System.Text;
using System.IO;
using System.Net;
using System.Web;
using System.Xml;
using System.Threading;
using System.Web.Services;
using System.Web.Services.Protocols;

using ServerTestFramework;
using xonline.common.config;
using xonline.common.diagnostics;
using xonline.common.nUnit;
using xonline.common.service;
using xonline.server.comps.common;


namespace xonline.server.webcache.query.test.dvt 
{
    [TestGroup, DVT]
    public class CompetitionTests : TestNode
    {            
        public const uint    c_titleId = 0x0000673;

        public byte[]        c_publisherWebId1 = new byte[8] { 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8 };
        public byte[]        c_publisherWebId2 = new byte[8] { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2 };

        // Single Elimination Datasets
        public const uint c_dsComps = 0x1;
        public const uint c_dsEntrants = 0x2;
        public const uint c_dsEvents = 0x3;

        // Query constants
        public const uint XONLINE_QUERY_ENTITY_ID                 = 0x80000000;
        public const uint XONLINE_QUERY_OWNER_PUID                = 0x80000001;
        
        // Topology constants
        public const long c_compTopology = 7090991005719;

        public ulong CreateCompetition(GamerTagAndWebID c)
        {
            QueryWidget qService = new QueryWidget(ConfigUtil.QueryWebServiceURL);
            
            int                 i;
            ulong               entityId;
            QueryAttribute[]    attribs;
            
            Console.WriteLine("Calling Query.CompetitionCreate");
            Console.WriteLine();

            attribs = new QueryAttribute[18];
            for (i = 0; i < attribs.Length; i++)    { attribs[i] = new QueryAttribute(); }

            //
            // Setup attributes
            //
            attribs[0].Id = Comp.XONLINE_COMP_ATTR_REG_OPEN;
            attribs[0].Value = DateTime.UtcNow.ToFileTimeUtc();
            attribs[1].Id = Comp.XONLINE_COMP_ATTR_REG_CLOSE;
            attribs[1].Value = DateTime.UtcNow.AddMinutes(4).ToFileTimeUtc();
            attribs[2].Id = Comp.XONLINE_COMP_ATTR_COMP_START;
            attribs[2].Value = DateTime.UtcNow.AddMinutes(5).ToFileTimeUtc();
            attribs[3].Id = Comp.XONLINE_COMP_ATTR_COMP_CLEANUP;
            attribs[3].Value = (long)1;

            attribs[4].Id = Comp.XONLINE_COMP_ATTR_ROUND_FREQUENCY;
            attribs[4].Value = (long)1;
            attribs[5].Id = Comp.XONLINE_COMP_ATTR_ROUND_INTERVAL;
            attribs[5].Value = (long)Comp.XONLINE_COMP_INTERVAL_HOUR;
            attribs[6].Id = Comp.XONLINE_COMP_ATTR_ROUND_DAY_MASK;
            attribs[6].Value = (long)0;
            
            attribs[7].Id = Comp.XONLINE_COMP_ATTR_ROUND_ONE_START;
            attribs[7].Value = DateTime.UtcNow.AddMinutes(15).ToFileTimeUtc();             
            attribs[8].Id = Comp.XONLINE_COMP_ATTR_ROUND_ONE_END;
            attribs[8].Value = DateTime.UtcNow.AddMinutes(20).ToFileTimeUtc();
            attribs[9].Id = Comp.XONLINE_COMP_ATTR_REMINDER_MIN;
            attribs[9].Value = (long)5;

            attribs[10].Id = Comp.XONLINE_COMP_ATTR_MAX_PUBLIC_SLOTS;
            attribs[10].Value = (long)10;
            attribs[11].Id = Comp.XONLINE_COMP_ATTR_MAX_PRIVATE_SLOTS;
            attribs[11].Value = (long)6; 
            attribs[12].Id = Comp.XONLINE_COMP_ATTR_MIN_SLOTS;
            attribs[12].Value = (long)4; 
            attribs[13].Id = Comp.XONLINE_COMP_ATTR_IS_TEAM_COMP;
            attribs[13].Value = (long)0;
            attribs[14].Id = Comp.XONLINE_COMP_ATTR_TEAM_SIZE;
            attribs[14].Value = (long)0;
            
            attribs[15].Id = 0x00010001;    // nMapId
            attribs[15].Value = (long)1234;
            
            attribs[16].Id = 0x00110002;    // name
            attribs[16].Value = "Query WebService Test CompetitionCreate";
            
            attribs[17].Id = 0x00210003;    // icon
            attribs[17].Value = new byte[] { 0x1, 0x2, 0x3, 0x4, 0x3, 0x2, 0x1 };


            entityId = qService.Add(c_titleId, c.webID, c.gamerTag, "", c_dsComps, attribs);

            Console.WriteLine("Competition " + entityId + " added." );
            Console.WriteLine();

            return entityId;
        }


        [TestCase]
        public void TestRawBasics()
        {
            QueryWidget qService = new QueryWidget(ConfigUtil.QueryWebServiceURL);
            GamerTagAndWebID c = User.GetRandomWebCredential();
            
            ulong               entityId = CreateCompetition(c);

            //
            // Cancel the competition
            //            
            Console.WriteLine("Calling Query.CompetitionCancel");            
            Console.WriteLine();
            
            qService.CompetitionCancel(c_titleId, c.webID, c.gamerTag, "", c_dsComps, entityId);

            Console.WriteLine("Competition " + entityId + " cancelled." );
            Console.WriteLine();
        }

        [TestCase]
        public void TestBasics()
        {
            QueryWidget qService = new QueryWidget(ConfigUtil.QueryWebServiceURL);
            GamerTagAndWebID c = User.GetRandomWebCredential();
            
            int                 i;
            ulong               entityId;
            QueryAttribute[]    attribs;


            //
            // Create a competition
            //            
            Console.WriteLine("Calling Query.CompetitionCreateSingleElimination");
            Console.WriteLine();
            
            attribs = new QueryAttribute[3];
            for (i = 0; i < attribs.Length; i++)    { attribs[i] = new QueryAttribute(); }

            attribs[0].Id = 0x00010001;    // nMapId
            attribs[0].Value = (long)1234;            
            attribs[1].Id = 0x00110002;    // name
            attribs[1].Value = "Query WebService Test CompetitionCreateSingleElimination";            
            attribs[2].Id = 0x00210003;    // icon
            attribs[2].Value = new byte[] { 0x1, 0x2, 0x3, 0x4, 0x3, 0x2, 0x1 };

            entityId = qService.CompetitionCreateSingleElimination(c_titleId, c.webID, c.gamerTag, "", c_dsComps, 
                    4                                /* cPrivateSlots */,
                    4                               /* cPublicSlots */,
                    4                               /* cMinimumPlayers */,
                    DateTime.UtcNow                 /* dtRegistrationOpen */,
                    DateTime.UtcNow.AddMinutes(10)  /* dtRegistrationClose */,
                    DateTime.UtcNow.AddMinutes(20)  /* dtCompetitionStart */,
                    DateTime.UtcNow.AddMinutes(30)  /* dtRoundOneStart */,
                    DateTime.UtcNow.AddMinutes(35)  /* dtRoundOneEnd */,
                    5                               /* dwMatchReminderAdvanceMinutes */,
                    10                              /* UnitOrMask */,
                    Comp.XONLINE_COMP_INTERVAL_MINUTE /* Interval */,
                    false                           /* fTeamCompetition */,
                    0                               /* dwTeamSize */,
                    attribs);

            Console.WriteLine("Competition " + entityId + " added." );
            Console.WriteLine();


            //
            // Cancel the competition
            //            
            Console.WriteLine("Calling Query.CompetitionCancel");            
            Console.WriteLine();
            
            qService.CompetitionCancel(c_titleId, c.webID, c.gamerTag, "", c_dsComps, entityId);

            Console.WriteLine("Competition " + entityId + " cancelled." );
            Console.WriteLine();
            
        }


        [TestCase]
        public void TestCreateCases()
        {
            QueryWidget qService = new QueryWidget(ConfigUtil.QueryWebServiceURL);
            GamerTagAndWebID c = User.GetRandomWebCredential();
            
            int                 i;
            ulong               entityId;
            QueryAttribute[]    attribs;


            try
            {
                //
                // Create a competition using duplicate attribute
                //            
                Console.WriteLine("Calling Query.CompetitionCreateSingleElimination");
                Console.WriteLine();
                
                attribs = new QueryAttribute[4];
                for (i = 0; i < attribs.Length; i++)    { attribs[i] = new QueryAttribute(); }

                attribs[0].Id = 0x00010001;    // nMapId
                attribs[0].Value = (long)1234;            
                attribs[1].Id = 0x00110002;    // name
                attribs[1].Value = "Query WebService Test CompetitionCreateSingleElimination";            
                attribs[2].Id = 0x00210003;    // icon
                attribs[2].Value = new byte[] { 0x1, 0x2, 0x3, 0x4, 0x3, 0x2, 0x1 };
                attribs[3].Id = 0x80010051;    // invalid
                attribs[3].Value = (long)1234;            
                attribs[3].Id = 0x00010001;    // nMapId
                attribs[3].Value = (long)1234;            

                entityId = qService.CompetitionCreateSingleElimination(c_titleId, c.webID, c.gamerTag, "", c_dsComps, 
                        4                                /* cPrivateSlots */,
                        4                               /* cPublicSlots */,
                        4                               /* cMinimumPlayers */,
                        DateTime.UtcNow                 /* dtRegistrationOpen */,
                        DateTime.UtcNow.AddMinutes(10)  /* dtRegistrationClose */,
                        DateTime.UtcNow.AddMinutes(20)  /* dtCompetitionStart */,
                        DateTime.UtcNow.AddMinutes(30)  /* dtRoundOneStart */,
                        DateTime.UtcNow.AddMinutes(35)  /* dtRoundOneEnd */,
                        5                               /* dwMatchReminderAdvanceMinutes */,
                        10                              /* UnitOrMask */,
                        Comp.XONLINE_COMP_INTERVAL_MINUTE /* Interval */,
                        false                           /* fTeamCompetition */,
                        0                               /* dwTeamSize */,
                        attribs);

                Console.WriteLine("Competition " + entityId + " added." );
                Console.WriteLine();
            }
            catch(SoapException se)
            {
                Assert.IsTrue(-1 != se.Message.IndexOf("Error: 80156105: An unexpected attribute passed to the method caused a database error."));

                Console.WriteLine("Create with duplicate attribute excepted with the correct error code: ");
                Console.WriteLine(se.Message);
                Console.WriteLine();                
            }

            try
            {
                Console.WriteLine("Calling Query.CompetitionCreate");
                Console.WriteLine();

                attribs = new QueryAttribute[18];
                for (i = 0; i < attribs.Length; i++)    { attribs[i] = new QueryAttribute(); }

                //
                // Setup attributes
                //
                attribs[0].Id = Comp.XONLINE_COMP_ATTR_REG_OPEN;
                attribs[0].Value = DateTime.UtcNow.ToFileTimeUtc();
                attribs[1].Id = Comp.XONLINE_COMP_ATTR_REG_CLOSE;
                attribs[1].Value = DateTime.UtcNow.AddMinutes(4).ToFileTimeUtc();
                attribs[2].Id = Comp.XONLINE_COMP_ATTR_COMP_START;
                attribs[2].Value = DateTime.UtcNow.AddMinutes(5).ToFileTimeUtc();
                attribs[3].Id = Comp.XONLINE_COMP_ATTR_COMP_CLEANUP;
                attribs[3].Value = (long)1;

                attribs[4].Id = Comp.XONLINE_COMP_ATTR_ROUND_FREQUENCY;
                attribs[4].Value = (long)1;
                attribs[5].Id = Comp.XONLINE_COMP_ATTR_ROUND_INTERVAL;
                attribs[5].Value = (long)Comp.XONLINE_COMP_INTERVAL_HOUR;
                attribs[6].Id = Comp.XONLINE_COMP_ATTR_ROUND_DAY_MASK;
                attribs[6].Value = (long)0;
                
                attribs[7].Id = Comp.XONLINE_COMP_ATTR_ROUND_ONE_START;
                attribs[7].Value = DateTime.UtcNow.AddMinutes(15).ToFileTimeUtc();             
                attribs[8].Id = Comp.XONLINE_COMP_ATTR_ROUND_ONE_END;
                attribs[8].Value = DateTime.UtcNow.AddMinutes(20).ToFileTimeUtc();
                attribs[9].Id = Comp.XONLINE_COMP_ATTR_REMINDER_MIN;
                attribs[9].Value = (long)5;

                attribs[10].Id = Comp.XONLINE_COMP_ATTR_MAX_PUBLIC_SLOTS;
                attribs[10].Value = (long)10;
                attribs[11].Id = Comp.XONLINE_COMP_ATTR_MAX_PRIVATE_SLOTS;
                attribs[11].Value = (long)6; 
                attribs[12].Id = Comp.XONLINE_COMP_ATTR_MIN_SLOTS;
                attribs[12].Value = (long)4; 
                attribs[13].Id = Comp.XONLINE_COMP_ATTR_IS_TEAM_COMP;
                attribs[13].Value = (long)0;
                attribs[14].Id = Comp.XONLINE_COMP_ATTR_TEAM_SIZE;
                attribs[14].Value = (long)0;
                
                attribs[15].Id = 0x00010001;    // nMapId
                attribs[15].Value = (long)1234;
                
                attribs[16].Id = 0x00110002;    // name
                attribs[16].Value = "Query WebService Test CompetitionCreate";
                
                attribs[17].Id = 0x00210003;    // icon
                attribs[17].Value = new byte[] { 0x1, 0x2, 0x3, 0x4, 0x3, 0x2, 0x1 };

                // Mess up the attributes per bug 35118
                foreach (QueryAttribute qa in attribs)
                {
                    qa.Id += 0x100;
                }
                
                entityId = qService.Add(c_titleId, c.webID, c.gamerTag, "", c_dsComps, attribs);

                Console.WriteLine("Competition " + entityId + " added." );
                Console.WriteLine();             
            }
            catch(SoapException se)
            {
                Assert.IsTrue(-1 != se.Message.IndexOf("Error: 80070057: The method was called with some invalid arguments or attributes and could not be completed."));

                Console.WriteLine("Create with duplicate attribute excepted with the correct error code: ");
                Console.WriteLine(se.Message);
                Console.WriteLine();                
            }
            
        }

        [TestCase]
        public void TestSearch()
        {
            QueryWidget qService = new QueryWidget(ConfigUtil.QueryWebServiceURL);
            GamerTagAndWebID c = User.GetRandomWebCredential();
            
            int                 i;
            ulong               entityId;
            QueryAttribute[]    attribs;
            QueryAttribute[]    attribsSearch;
            QueryAttributeSpec[]  specs;
            SearchResponse      response;


            //
            // Create a competition
            //            
            Console.WriteLine("Calling Query.CompetitionCreateSingleElimination");
            Console.WriteLine();
            
            attribs = new QueryAttribute[3];
            for (i = 0; i < attribs.Length; i++)    { attribs[i] = new QueryAttribute(); }

            attribs[0].Id = 0x00010001;    // nMapId
            attribs[0].Value = (long)1234;            
            attribs[1].Id = 0x00110002;    // name
            attribs[1].Value = "Query WebService Test CompetitionCreateSingleElimination";            
            attribs[2].Id = 0x00210003;    // icon
            attribs[2].Value = new byte[] { 0x1, 0x2, 0x3, 0x4, 0x3, 0x2, 0x1 };

            entityId = qService.CompetitionCreateSingleElimination(c_titleId, c.webID, c.gamerTag, "", c_dsComps, 
                    4                                /* cPrivateSlots */,
                    4                               /* cPublicSlots */,
                    4                               /* cMinimumPlayers */,
                    DateTime.UtcNow                 /* dtRegistrationOpen */,
                    DateTime.UtcNow.AddMinutes(10)  /* dtRegistrationClose */,
                    DateTime.UtcNow.AddMinutes(20)  /* dtCompetitionStart */,
                    DateTime.UtcNow.AddMinutes(30)  /* dtRoundOneStart */,
                    DateTime.UtcNow.AddMinutes(35)  /* dtRoundOneEnd */,
                    5                               /* dwMatchReminderAdvanceMinutes */,
                    10                              /* UnitOrMask */,
                    Comp.XONLINE_COMP_INTERVAL_MINUTE /* Interval */,
                    false                           /* fTeamCompetition */,
                    0                               /* dwTeamSize */,
                    attribs);

            Console.WriteLine();
            Console.WriteLine("Competition " + entityId + " added." );

            //
            // Search for competitions
            //            
            Console.WriteLine("Calling Query.CompetitionSearch");
            Console.WriteLine();
            
            attribsSearch = new QueryAttribute[1];
            for (i = 0; i < attribsSearch.Length; i++)  { attribsSearch[i] = new QueryAttribute(); }
            
            attribsSearch[0].Id = Comp.XONLINE_QUERY_CURRENT_TIME;
            attribsSearch[0].Value = DateTime.UtcNow.ToFileTimeUtc();
            
            specs = new QueryAttributeSpec[17];
            for (i = 0; i < specs.Length; i++)      { specs[i] = new QueryAttributeSpec(); }
            
            specs[0].type = XONLINE_QUERY_ENTITY_ID;
            specs[1].type = Comp.XONLINE_COMP_ATTR_COMP_START;
            specs[2].type = Comp.XONLINE_COMP_ATTR_ROUND_FREQUENCY;
            specs[3].type = Comp.XONLINE_COMP_ATTR_ROUND_INTERVAL;
            specs[4].type = Comp.XONLINE_COMP_ATTR_ROUND_DAY_MASK;
            specs[5].type = Comp.XONLINE_COMP_ATTR_ROUND_ONE_START;
            specs[6].type = Comp.XONLINE_COMP_ATTR_ROUND_ONE_END;
            specs[7].type = Comp.XONLINE_COMP_ATTR_IS_TEAM_COMP;
            specs[8].type = Comp.XONLINE_COMP_ATTR_TEAM_SIZE;
            specs[9].type = Comp.XONLINE_COMP_ATTR_MAX_PUBLIC_SLOTS;
            specs[10].type = Comp.XONLINE_COMP_ATTR_MAX_PRIVATE_SLOTS;
            specs[11].type = Comp.XONLINE_COMP_ATTR_PUBLIC_ENTRANTS;
            specs[12].type = Comp.XONLINE_COMP_ATTR_PRIVATE_ENTRANTS;
            specs[13].type = Comp.XONLINE_COMP_ATTR_STATUS;
            
            specs[14].type = 0x00010001;    // map
            specs[14].len = 8;
            specs[15].type = 0x00110002;    // name
            specs[15].len = XOn.XONLINE_QUERY_MAX_STRING_ATTRIBUTE_LEN;            
            specs[16].type = 0x00210003;    // icon
            specs[16].len = XOn.XONLINE_QUERY_MAX_BLOB_ATTRIBUTE_LEN;
            
            response = qService.CompetitionSearch(c_titleId, c_dsComps, 1, 0, 20, specs, attribsSearch);
            
            Console.WriteLine("Searched and found " + response.totalResults + " competitions." );
            Console.WriteLine();


            //
            // Cancel the competition
            //            
            Console.WriteLine("Calling Query.CompetitionCancel");            
            Console.WriteLine();
            
            qService.CompetitionCancel(c_titleId, c.webID, c.gamerTag, "", c_dsComps, entityId);

            Console.WriteLine("Competition " + entityId + " cancelled." );
            Console.WriteLine();
        }


        [TestCase]
        public void TestManageEntrant()
        {
            QueryWidget qService = new QueryWidget(ConfigUtil.QueryWebServiceURL);
            GamerTagAndWebID c = User.GetRandomWebCredential();
            
            int                 i;
            ulong               entityId;
            QueryAttribute[]    attribs;
            

            //
            // Create a competition
            //            
            Console.WriteLine("Calling Query.CompetitionCreateSingleElimination");
            Console.WriteLine();
            
            attribs = new QueryAttribute[3];
            for (i = 0; i < attribs.Length; i++)    { attribs[i] = new QueryAttribute(); }

            attribs[0].Id = 0x00010001;    // nMapId
            attribs[0].Value = (long)1234;            
            attribs[1].Id = 0x00110002;    // name
            attribs[1].Value = "Query WebService Test CompetitionCreateSingleElimination";            
            attribs[2].Id = 0x00210003;    // icon
            attribs[2].Value = new byte[] { 0x1, 0x2, 0x3, 0x4, 0x3, 0x2, 0x1 };

            entityId = qService.CompetitionCreateSingleElimination(c_titleId, c.webID, c.gamerTag, "", c_dsComps, 
                    4                                /* cPrivateSlots */,
                    4                               /* cPublicSlots */,
                    4                               /* cMinimumPlayers */,
                    DateTime.UtcNow                 /* dtRegistrationOpen */,
                    DateTime.UtcNow.AddMinutes(10)  /* dtRegistrationClose */,
                    DateTime.UtcNow.AddMinutes(20)  /* dtCompetitionStart */,
                    DateTime.UtcNow.AddMinutes(30)  /* dtRoundOneStart */,
                    DateTime.UtcNow.AddMinutes(35)  /* dtRoundOneEnd */,
                    5                               /* dwMatchReminderAdvanceMinutes */,
                    10                              /* UnitOrMask */,
                    Comp.XONLINE_COMP_INTERVAL_MINUTE /* Interval */,
                    false                           /* fTeamCompetition */,
                    0                               /* dwTeamSize */,
                    attribs);

            Console.WriteLine("Competition " + entityId + " added." );
            Console.WriteLine();


            //
            // Join the competition
            //            
            Console.WriteLine("Calling Query.CompetitionManageEntrant to Join");
            Console.WriteLine();

            qService.CompetitionManageEntrant(c_titleId, c.webID, c.gamerTag, Comp.XONLINE_COMP_ACTION_JOIN, "", c_dsComps, entityId, null);            

            Console.WriteLine("Joined a user to competition " + entityId);
            Console.WriteLine();

        
            //
            // Try some illegal operations - Checkin
            //            
            try
            {
                Console.WriteLine("Calling Query.CompetitionManageEntrant to Checkin");
                Console.WriteLine();

                qService.CompetitionManageEntrant(c_titleId, c.webID, c.gamerTag, Comp.XONLINE_COMP_ACTION_CHECKIN, "", c_dsComps, entityId, null);            

                Console.WriteLine("Checked in user to competition " + entityId);
                Console.WriteLine();

                // Shouldn't get here!
                Assert.IsTrue(false);
            }
            catch (Exception e)
            {
                Console.WriteLine("Competition " + entityId + " failed to allow checkin with error: " + e.Message );
            }


            //
            // Try some illegal operations - Submit Results
            //            
            try
            {
                Console.WriteLine("Calling Query.CompetitionManageEntrant to Submit Results");
                Console.WriteLine();

                qService.CompetitionManageEntrant(c_titleId, c.webID, c.gamerTag, Comp.XONLINE_COMP_ACTION_SUBMIT_RESULTS, "", c_dsComps, entityId, null);            

                Console.WriteLine("Submitted results for competition " + entityId);
                Console.WriteLine();

                // Shouldn't get here!
                Assert.IsTrue(false);
            }
            catch (Exception e)
            {
                Console.WriteLine("Competition " + entityId + " failed to allow results submission with error: " + e.Message );
            }


            //
            // Cancel the competition
            //            
            Console.WriteLine("Calling Query.CompetitionCancel");            
            Console.WriteLine();
            
            qService.CompetitionCancel(c_titleId, c.webID, c.gamerTag, "", c_dsComps, entityId);

            Console.WriteLine("Competition " + entityId + " cancelled." );
            Console.WriteLine();
            
        }        


        public void FormatTopologyResponse(SearchResponse response, int eventsPerRow, int topleftEventIndex)
        {
            int         index = topleftEventIndex * eventsPerRow;
            
            if (response.attribCount >= index)
            {
                int         i; 
                
                Console.WriteLine("Formatting Topology Results");
                Console.WriteLine();            

                // Always output 7 events over 3 rounds, if they exist. 

                for (i = 0; i < response.attribCount; i+=eventsPerRow)
                {
                    Console.Write("entity = " + response.attribs[i].Value);
                    Console.Write(", round = " + response.attribs[i + 2].Value);
                    Console.Write(", eventId = " + response.attribs[i + 1].Value);
                    Console.Write(", Player 1 = " + response.attribs[i + 6].Value);
                    Console.Write(", Player 2 = " +response.attribs[i + 8].Value);
                    Console.Write(", Winner = " +response.attribs[i + 10].Value);
                    Console.Write(", Next entity = " + response.attribs[i + 4].Value);                        
                    Console.WriteLine();            
                }
                
                Console.WriteLine();            

                
            }
        }


        public void FindCompetition(QueryWidget qService, ulong compId, out QueryAttribute[] results)
        {
            FindFromIdsResponse     response;            
            QueryAttributeSpec[]    specs = new QueryAttributeSpec[24];
            
            for (int i = 0; i < specs.Length; i++)
            {
                specs[i] = new QueryAttributeSpec();            
            }
            
            specs[0].type = Comp.XONLINE_QUERY_ENTITY_ID;   
            specs[1].type = Comp.XONLINE_QUERY_OWNER_PUID;
            specs[2].type = Comp.XONLINE_QUERY_OWNER_GAMERTAG;
            specs[2].len = 16;
            specs[3].type = Comp.XONLINE_COMP_ATTR_COMP_START;
            specs[4].type = Comp.XONLINE_COMP_ATTR_COMP_CLEANUP;
            specs[5].type = Comp.XONLINE_COMP_ATTR_ROUND_FREQUENCY;
            specs[6].type = Comp.XONLINE_COMP_ATTR_ROUND_INTERVAL;
            specs[7].type = Comp.XONLINE_COMP_ATTR_ROUND_DAY_MASK;
            specs[8].type = Comp.XONLINE_COMP_ATTR_IS_TEAM_COMP;
            specs[9].type = Comp.XONLINE_COMP_ATTR_TEAM_SIZE;
            specs[10].type = Comp.XONLINE_COMP_ATTR_REMINDER_MIN;
            specs[11].type = Comp.XONLINE_COMP_ATTR_ROUNDS;
            specs[12].type = Comp.XONLINE_COMP_ATTR_CURRENT_ROUND;
            specs[13].type = Comp.XONLINE_COMP_ATTR_CURRENT_ROUND_START;
            specs[14].type = Comp.XONLINE_COMP_ATTR_CURRENT_ROUND_END;
            specs[15].type = Comp.XONLINE_COMP_ATTR_PUBLIC_ENTRANTS;
            specs[16].type = Comp.XONLINE_COMP_ATTR_PRIVATE_ENTRANTS;
            specs[17].type = Comp.XONLINE_COMP_ATTR_STATUS;
            specs[18].type = Comp.XONLINE_COMP_ATTR_LEADERBOARD_ID0;
            specs[19].type = Comp.XONLINE_COMP_ATTR_LEADERBOARD_ID1;
            specs[20].type = Comp.XONLINE_COMP_ATTR_LEADERBOARD_ID2;

            specs[21].type =  0x00010001; // map
            specs[22].type =  0x00110002; //name
            specs[23].type =  0x00210003; // icon
                
            response = qService.FindFromIds(c_titleId, c_dsComps, 1, specs, new ulong[] { compId });

            results = response.attribs;
        }
        
        
        [TestCase]
        public void TestTopology()
        {
            QueryWidget qService = new QueryWidget(ConfigUtil.QueryWebServiceURL);
            
            int                     i;
            QueryAttribute[]        attribsSearch;
            QueryAttributeSpec[]    specs;
            SearchResponse          response;
            bool                    foundTopologyComp = false;
            

            //
            // Search for competitions
            //            
            Console.WriteLine("Calling Query.CompetitionSearch");
            Console.WriteLine();
            
            attribsSearch = new QueryAttribute[2];
            for (i = 0; i < attribsSearch.Length; i++)  { attribsSearch[i] = new QueryAttribute(); }
            
            attribsSearch[0].Id = Comp.XONLINE_QUERY_OWNER_PUID;
            attribsSearch[0].Value = (long)5765819860425263851;
            attribsSearch[1].Id = Comp.XONLINE_COMP_ATTR_STATUS;
            attribsSearch[1].Value = (long)Comp.XONLINE_COMP_STATUS_ACTIVE;
            
            specs = new QueryAttributeSpec[17];
            for (i = 0; i < specs.Length; i++)      { specs[i] = new QueryAttributeSpec(); }
            
            specs[0].type = XONLINE_QUERY_ENTITY_ID;
            specs[1].type = Comp.XONLINE_COMP_ATTR_COMP_START;
            specs[2].type = Comp.XONLINE_COMP_ATTR_ROUND_FREQUENCY;
            specs[3].type = Comp.XONLINE_COMP_ATTR_ROUND_INTERVAL;
            specs[4].type = Comp.XONLINE_COMP_ATTR_ROUND_DAY_MASK;
            specs[5].type = Comp.XONLINE_COMP_ATTR_ROUND_ONE_START;
            specs[6].type = Comp.XONLINE_COMP_ATTR_ROUND_ONE_END;
            specs[7].type = Comp.XONLINE_COMP_ATTR_IS_TEAM_COMP;
            specs[8].type = Comp.XONLINE_COMP_ATTR_TEAM_SIZE;
            specs[9].type = Comp.XONLINE_COMP_ATTR_MAX_PUBLIC_SLOTS;
            specs[10].type = Comp.XONLINE_COMP_ATTR_MAX_PRIVATE_SLOTS;
            specs[11].type = Comp.XONLINE_COMP_ATTR_PUBLIC_ENTRANTS;
            specs[12].type = Comp.XONLINE_COMP_ATTR_PRIVATE_ENTRANTS;
            specs[13].type = Comp.XONLINE_COMP_ATTR_STATUS;
            
            specs[14].type = 0x00010001;    // map
            specs[14].len = 8;
            specs[15].type = 0x00110002;    // name
            specs[15].len = XOn.XONLINE_QUERY_MAX_STRING_ATTRIBUTE_LEN;            
            specs[16].type = 0x00210003;    // icon
            specs[16].len = XOn.XONLINE_QUERY_MAX_BLOB_ATTRIBUTE_LEN;
            
            response = qService.CompetitionSearch(c_titleId, c_dsComps, 2, 0, 20, specs, attribsSearch);
            
            Console.WriteLine("Searched and found " + response.totalResults + " competitions." );
            Console.WriteLine();
            
            for (i = 0; i < response.returnedResults; i++)
            {
                object o = response.attribs[17 * i].Value;
                
                if ((long)o == c_compTopology)
                {
                    foundTopologyComp = true;
                    Console.WriteLine("Found the topology test competition " + c_compTopology + " at index " + i );
                }
            }

            if (foundTopologyComp)
            {
                specs = new QueryAttributeSpec[15];
                for (i = 0; i < specs.Length; i++)      { specs[i] = new QueryAttributeSpec(); }
                
                specs[0].type = XONLINE_QUERY_ENTITY_ID;
                specs[1].type = Comp.XONLINE_COMP_ATTR_EVENT_TOPOLOGY_ID;
                specs[2].type = Comp.XONLINE_COMP_ATTR_EVENT_ROUND;
                specs[3].type = Comp.XONLINE_COMP_ATTR_EVENT_START;
                specs[4].type = Comp.XONLINE_COMP_ATTR_EVENT_NEXT_ENTITY;
                specs[5].type = Comp.XONLINE_COMP_ATTR_EVENT_NEXT_START;
                specs[6].type = Comp.XONLINE_COMP_ATTR_EVENT_P1;
                specs[7].type = Comp.XONLINE_COMP_ATTR_EVENT_P1_GAMERTAG;
                specs[7].len = XOn.XONLINE_QUERY_MAX_STRING_ATTRIBUTE_LEN;
                specs[8].type = Comp.XONLINE_COMP_ATTR_EVENT_P2;
                specs[9].type = Comp.XONLINE_COMP_ATTR_EVENT_P2_GAMERTAG;
                specs[9].len = XOn.XONLINE_QUERY_MAX_STRING_ATTRIBUTE_LEN;
                specs[10].type = Comp.XONLINE_COMP_ATTR_EVENT_WINNER;
                specs[11].type = Comp.XONLINE_COMP_ATTR_EVENT_LOSER;

                specs[12].type = 0x00010001;    // map
                specs[12].len = 8;
                specs[13].type = 0x00110002;    // name
                specs[13].len = XOn.XONLINE_QUERY_MAX_STRING_ATTRIBUTE_LEN;            
                specs[14].type = 0x00210003;    // icon
                specs[14].len = XOn.XONLINE_QUERY_MAX_BLOB_ATTRIBUTE_LEN;
                
                Console.WriteLine("Calling Query.CompetitionTopology");
                Console.WriteLine();
                
                response = qService.CompetitionTopology(c_titleId, c_dsEvents, c_compTopology, 0, 20, 0x10000, 0x40000, specs);

                Console.WriteLine("Topology returned " + response.returnedResults + " events." );
                FormatTopologyResponse(response, specs.Length, 0);
            }       
            else
            {
                Console.WriteLine("Topology test competition " + c_compTopology + " was not found! Silent failure - go run the script to insert the test data in the QueryDB.");                
            }
        }        


        [TestCase]
        public void TestSingleEliminationTopology()
        {
            QueryWidget qService = new QueryWidget(ConfigUtil.QueryWebServiceURL);
            
            int                     i;
            QueryAttribute[]        attribsSearch;
            QueryAttributeSpec[]    specs;
            SearchResponse          response;
            bool                    foundTopologyComp = false;
            

            //
            // Search for competitions
            //            
            Console.WriteLine("Calling Query.CompetitionSearch");
            Console.WriteLine();
            
            attribsSearch = new QueryAttribute[2];
            for (i = 0; i < attribsSearch.Length; i++)  { attribsSearch[i] = new QueryAttribute(); }
            
            attribsSearch[0].Id = Comp.XONLINE_QUERY_OWNER_PUID;
            attribsSearch[0].Value = (long)5765819860425263851;
            attribsSearch[1].Id = Comp.XONLINE_COMP_ATTR_STATUS;
            attribsSearch[1].Value = (long)Comp.XONLINE_COMP_STATUS_ACTIVE;
            
            specs = new QueryAttributeSpec[17];
            for (i = 0; i < specs.Length; i++)      { specs[i] = new QueryAttributeSpec(); }
            
            specs[0].type = XONLINE_QUERY_ENTITY_ID;
            specs[1].type = Comp.XONLINE_COMP_ATTR_COMP_START;
            specs[2].type = Comp.XONLINE_COMP_ATTR_ROUND_FREQUENCY;
            specs[3].type = Comp.XONLINE_COMP_ATTR_ROUND_INTERVAL;
            specs[4].type = Comp.XONLINE_COMP_ATTR_ROUND_DAY_MASK;
            specs[5].type = Comp.XONLINE_COMP_ATTR_ROUND_ONE_START;
            specs[6].type = Comp.XONLINE_COMP_ATTR_ROUND_ONE_END;
            specs[7].type = Comp.XONLINE_COMP_ATTR_IS_TEAM_COMP;
            specs[8].type = Comp.XONLINE_COMP_ATTR_TEAM_SIZE;
            specs[9].type = Comp.XONLINE_COMP_ATTR_MAX_PUBLIC_SLOTS;
            specs[10].type = Comp.XONLINE_COMP_ATTR_MAX_PRIVATE_SLOTS;
            specs[11].type = Comp.XONLINE_COMP_ATTR_PUBLIC_ENTRANTS;
            specs[12].type = Comp.XONLINE_COMP_ATTR_PRIVATE_ENTRANTS;
            specs[13].type = Comp.XONLINE_COMP_ATTR_STATUS;
            
            specs[14].type = 0x00010001;    // map
            specs[14].len = 8;
            specs[15].type = 0x00110002;    // name
            specs[15].len = XOn.XONLINE_QUERY_MAX_STRING_ATTRIBUTE_LEN;            
            specs[16].type = 0x00210003;    // icon
            specs[16].len = XOn.XONLINE_QUERY_MAX_BLOB_ATTRIBUTE_LEN;
            
            response = qService.CompetitionSearch(c_titleId, c_dsComps, 2, 0, 20, specs, attribsSearch);
            
            Console.WriteLine("Searched and found " + response.totalResults + " competitions." );
            Console.WriteLine();
            
            for (i = 0; i < response.returnedResults; i++)
            {
                object o = response.attribs[17 * i].Value;
                
                if ((long)o == c_compTopology)
                {
                    foundTopologyComp = true;
                    Console.WriteLine("Found the topology test competition " + c_compTopology + " at index " + i );
                }
            }

            if (foundTopologyComp)
            {
                specs = new QueryAttributeSpec[15];
                for (i = 0; i < specs.Length; i++)      { specs[i] = new QueryAttributeSpec(); }
                
                //
                // Setup specs for Topology
                //            
                specs[0].type = XONLINE_QUERY_ENTITY_ID;
                specs[1].type = Comp.XONLINE_COMP_ATTR_EVENT_TOPOLOGY_ID;
                specs[2].type = Comp.XONLINE_COMP_ATTR_EVENT_ROUND;
                specs[3].type = Comp.XONLINE_COMP_ATTR_EVENT_START;
                specs[4].type = Comp.XONLINE_COMP_ATTR_EVENT_NEXT_ENTITY;
                specs[5].type = Comp.XONLINE_COMP_ATTR_EVENT_NEXT_START;
                specs[6].type = Comp.XONLINE_COMP_ATTR_EVENT_P1;
                specs[7].type = Comp.XONLINE_COMP_ATTR_EVENT_P1_GAMERTAG;
                specs[7].len = XOn.XONLINE_QUERY_MAX_STRING_ATTRIBUTE_LEN;
                specs[8].type = Comp.XONLINE_COMP_ATTR_EVENT_P2;
                specs[9].type = Comp.XONLINE_COMP_ATTR_EVENT_P2_GAMERTAG;
                specs[9].len = XOn.XONLINE_QUERY_MAX_STRING_ATTRIBUTE_LEN;
                specs[10].type = Comp.XONLINE_COMP_ATTR_EVENT_WINNER;
                specs[11].type = Comp.XONLINE_COMP_ATTR_EVENT_LOSER;

                specs[12].type = 0x00010001;    // map
                specs[12].len = 8;
                specs[13].type = 0x00110002;    // name
                specs[13].len = XOn.XONLINE_QUERY_MAX_STRING_ATTRIBUTE_LEN;            
                specs[14].type = 0x00210003;    // icon
                specs[14].len = XOn.XONLINE_QUERY_MAX_BLOB_ATTRIBUTE_LEN;

                
                //
                // Topology: Origin=0x00000, Forward=2, Backward=0, Width=0
                //            
                Console.WriteLine("Calling Query.CompetitionTopologySingleElimination: Origin=0x00000, Forward=2, Backward=0, Width=0");
                Console.WriteLine();
                
                response = qService.CompetitionTopologySingleElimination(c_titleId, c_dsEvents, c_compTopology, 0x00000, 2, 0, 0, specs);

                Console.WriteLine("Topology returned " + response.returnedResults + " events." );
                FormatTopologyResponse(response, specs.Length, 0);


                //
                // Topology: Origin=0x20000, Forward=0, Backward=2, Width=0
                //            
                Console.WriteLine("Calling Query.CompetitionTopologySingleElimination: Origin=0x20000, Forward=0, Backward=2, Width=0");
                Console.WriteLine();
                
                response = qService.CompetitionTopologySingleElimination(c_titleId, c_dsEvents, c_compTopology, 0x20000, 0, 2, 0, specs);                

                Console.WriteLine("Topology returned " + response.returnedResults + " events." );
                FormatTopologyResponse(response, specs.Length, 0);


                //
                // Topology: Origin=0x10000, Forward=1, Backward=1, Width=0
                //            
                Console.WriteLine("Calling Query.CompetitionTopologySingleElimination: Origin=0x10000, Forward=1, Backward=1, Width=0");
                Console.WriteLine();
                
                response = qService.CompetitionTopologySingleElimination(c_titleId, c_dsEvents, c_compTopology, 0x10000, 1, 1, 0, specs);

                Console.WriteLine("Topology returned " + response.returnedResults + " events." );
                FormatTopologyResponse(response, specs.Length, 0);


                //
                // Topology: Origin=0x00002, Forward=0, Backward=0, Width=1
                //            
                Console.WriteLine("Calling Query.CompetitionTopologySingleElimination: Origin=0x00002, Forward=0, Backward=0, Width=1");
                Console.WriteLine();
                
                response = qService.CompetitionTopologySingleElimination(c_titleId, c_dsEvents, c_compTopology, 0x00002, 0, 0, 1, specs);

                Console.WriteLine("Topology returned " + response.returnedResults + " events." );
                FormatTopologyResponse(response, specs.Length, 0);


                //
                // Topology: Origin=0x10001, Forward=0, Backward=1, Width=0
                //            
                Console.WriteLine("Calling Query.CompetitionTopologySingleElimination: Origin=0x10001, Forward=0, Backward=1, Width=0");
                Console.WriteLine();
                
                response = qService.CompetitionTopologySingleElimination(c_titleId, c_dsEvents, c_compTopology, 0x10001, 0, 1, 0, specs);

                Console.WriteLine("Topology returned " + response.returnedResults + " events." );
                FormatTopologyResponse(response, specs.Length, 0);
            }       
            else
            {
                Console.WriteLine("Topology test competition " + c_compTopology + " was not found! Silent failure - go run the script to insert the test data in the QueryDB.");                
            }
        }        


        [TestCase]
        public void TestSingleEliminationTopology2()
        {
            const int c_users = 16;  // If you change this, be sure to adjust the checks on the returned results values below
            
            QueryWidget             qService = new QueryWidget(ConfigUtil.QueryWebServiceURL);
            ulong []                puids = User.GetRandomPuids(c_users);
            GamerTagAndWebID []     c = new GamerTagAndWebID[c_users];
            ulong                   compId;
            int i;
            QueryAttribute[]        attribs;
            QueryAttribute[]        attribsResults;
            QueryAttributeSpec[]    specs;
            SearchResponse          response;


            //
            // Allocate users
            //            
            for (i=0; i< c_users; i++)
            {
                c[i] = User.GetWebCredentialFromPuid(puids[i]);
            }

            
            //
            // Create a competition
            //            
            Console.WriteLine("Calling Query.CompetitionCreateSingleElimination");
            Console.WriteLine();
            
            attribs = new QueryAttribute[3];
            for (i = 0; i < attribs.Length; i++)    { attribs[i] = new QueryAttribute(); }

            attribs[0].Id = 0x00010001;    // nMapId
            attribs[0].Value = (long)1234;            
            attribs[1].Id = 0x00110002;    // name
            attribs[1].Value = "Query WebService Test CompetitionTopology";            
            attribs[2].Id = 0x00210003;    // icon
            attribs[2].Value = new byte[] { 0x1, 0x2, 0x3, 0x4, 0x3, 0x2, 0x1 };

            compId = qService.CompetitionCreateSingleElimination(c_titleId, c[0].webID, c[0].gamerTag, "", c_dsComps, 
                    0                               /* cPrivateSlots */,
                    c_users                         /* cPublicSlots */,
                    2                               /* cMinimumPlayers */,
                    DateTime.UtcNow                 /* dtRegistrationOpen */,
                    DateTime.UtcNow.AddMinutes(10)  /* dtRegistrationClose */,
                    DateTime.UtcNow.AddMinutes(20)  /* dtCompetitionStart */,
                    DateTime.UtcNow.AddMinutes(30)  /* dtRoundOneStart */,
                    DateTime.UtcNow.AddMinutes(35)  /* dtRoundOneEnd */,
                    0                               /* dwMatchReminderAdvanceMinutes */,
                    10                              /* UnitOrMask */,
                    Comp.XONLINE_COMP_INTERVAL_MINUTE /* Interval */,
                    false                           /* fTeamCompetition */,
                    0                               /* dwTeamSize */,
                    attribs);

            Console.WriteLine("Competition " + compId + " added." );
            Console.WriteLine();


            //
            // Join the competition
            //            
            for (i=0; i< c_users; i++)
            {
                Console.WriteLine("Calling Query.CompetitionManageEntrant to Join");
                Console.WriteLine();

                qService.CompetitionManageEntrant(c_titleId, c[i].webID, c[i].gamerTag, Comp.XONLINE_COMP_ACTION_JOIN, "", c_dsComps, compId, null);            

                Console.WriteLine("Joined a user to competition " + compId);
                Console.WriteLine();
            }


            //
            // Advance to slotting
            //            
            Console.WriteLine("Advancing to slotting ");
            Console.WriteLine();

            attribs = new QueryAttribute[1];
            for (i = 0; i < attribs.Length; i++)    { attribs[i] = new QueryAttribute(); }

            attribs[0].Id = Comp.XONLINE_COMP_ATTR_DEBUG_ADVANCE_TIME;
            attribs[0].Value = (long)(20 * 60);            
            
            qService.CompetitionManageEntrant(c_titleId, c[0].webID, c[0].gamerTag, Comp.XONLINE_COMP_ACTION_DEBUG_ADVANCE_TIME, "", c_dsComps, compId, attribs);  


            // 
            // Wait for slotting to do it's thing
            //             
            attribsResults = null;
            for (i = 0; i < 12; i++)
            {
                Thread.Sleep(5 * 1000);
                
                FindCompetition(qService, compId, out attribsResults);
                Assert.IsTrue(attribsResults.Length > 17);
            
                if ((long)attribsResults[17].Value == Comp.XONLINE_COMP_STATUS_ACTIVE)
                {
                    break;
                }
            }             
           
            Assert.IsTrue((long)attribsResults[17].Value == Comp.XONLINE_COMP_STATUS_ACTIVE);
            
            Console.WriteLine("Competition " + compId + " is now slotted.");


            // 
            // Wait for slotting to do it's thing
            //             
            specs = new QueryAttributeSpec[15];
            for (i = 0; i < specs.Length; i++)      { specs[i] = new QueryAttributeSpec(); }
            
            //
            // Setup specs for Topology
            //            
            specs[0].type = XONLINE_QUERY_ENTITY_ID;
            specs[1].type = Comp.XONLINE_COMP_ATTR_EVENT_TOPOLOGY_ID;
            specs[2].type = Comp.XONLINE_COMP_ATTR_EVENT_ROUND;
            specs[3].type = Comp.XONLINE_COMP_ATTR_EVENT_START;
            specs[4].type = Comp.XONLINE_COMP_ATTR_EVENT_NEXT_ENTITY;
            specs[5].type = Comp.XONLINE_COMP_ATTR_EVENT_NEXT_START;
            specs[6].type = Comp.XONLINE_COMP_ATTR_EVENT_P1;
            specs[7].type = Comp.XONLINE_COMP_ATTR_EVENT_P1_GAMERTAG;
            specs[7].len = XOn.XONLINE_QUERY_MAX_STRING_ATTRIBUTE_LEN;
            specs[8].type = Comp.XONLINE_COMP_ATTR_EVENT_P2;
            specs[9].type = Comp.XONLINE_COMP_ATTR_EVENT_P2_GAMERTAG;
            specs[9].len = XOn.XONLINE_QUERY_MAX_STRING_ATTRIBUTE_LEN;
            specs[10].type = Comp.XONLINE_COMP_ATTR_EVENT_WINNER;
            specs[11].type = Comp.XONLINE_COMP_ATTR_EVENT_LOSER;

            specs[12].type = 0x00010001;    // map
            specs[12].len = 8;
            specs[13].type = 0x00110002;    // name
            specs[13].len = XOn.XONLINE_QUERY_MAX_STRING_ATTRIBUTE_LEN;            
            specs[14].type = 0x00210003;    // icon
            specs[14].len = XOn.XONLINE_QUERY_MAX_BLOB_ATTRIBUTE_LEN;

            
            //
            // Topology: Origin=0x10001, Forward=UInt32.MaxValue, Backward=1, Width=0
            //            
            Console.WriteLine("Calling Query.CompetitionTopologySingleElimination: Origin=0x10001, Forward=UInt32.MaxValue, Backward=1, Width=0");
            Console.WriteLine();
            
            response = qService.CompetitionTopologySingleElimination(c_titleId, c_dsEvents, compId, 0x10001, UInt32.MaxValue, 1, 0, specs);

            Console.WriteLine("Topology returned " + response.returnedResults + " events." );
            FormatTopologyResponse(response, specs.Length, 0);

            Assert.IsTrue(response.returnedResults == 15);


            //
            // Topology: Origin=0x00000, Forward=0, Backward=0, Width=UInt32.MaxValue
            //            
            Console.WriteLine("Calling Query.CompetitionTopologySingleElimination: Origin=0x00000, Forward=0, Backward=0, Width=UInt32.MaxValue");
            Console.WriteLine();
            
            response = qService.CompetitionTopologySingleElimination(c_titleId, c_dsEvents, compId, 0x0, 0, 0, UInt32.MaxValue, specs);

            Console.WriteLine("Topology returned " + response.returnedResults + " events." );
            FormatTopologyResponse(response, specs.Length, 0);

            Assert.IsTrue(response.returnedResults == 8);

            
            //
            // Topology: Page=1, Results=20, startingEventId=0x0, endingEventId=Int64.MaxValue
            //            
            Console.WriteLine("Calling Query.CompetitionTopology: Page=0, Results=20, startingEventId=0x0, endingEventId=Int64.MaxValue");
            Console.WriteLine();
            
            response = qService.CompetitionTopology(c_titleId, c_dsEvents, compId, 0, 20, 0, Int64.MaxValue, specs);

            Console.WriteLine("Topology returned " + response.returnedResults + " events." );
            FormatTopologyResponse(response, specs.Length, 0);

            Assert.IsTrue(response.returnedResults == 15);
            

            //
            // Topology: Origin=0x10001, Forward=1, Backward=1, Width=0
            //            
            Console.WriteLine("Calling Query.CompetitionTopologySingleElimination: Origin=0x10001, Forward=1, Backward=1, Width=0");
            Console.WriteLine();
            
            response = qService.CompetitionTopologySingleElimination(c_titleId, c_dsEvents, compId, 0x10001, 1, 1, 0, specs);

            Console.WriteLine("Topology returned " + response.returnedResults + " events." );
            FormatTopologyResponse(response, specs.Length, 0);

            Assert.IsTrue(response.returnedResults == 7);


            //
            // Topology: Origin=UInt64.MaxValue, Forward=0, Backward=0, Width=0
            //            
            Console.WriteLine("Calling Query.CompetitionTopologySingleElimination: Origin=UInt64.MaxValue, Forward=0, Backward=0, Width=0");
            Console.WriteLine();
            
            response = qService.CompetitionTopologySingleElimination(c_titleId, c_dsEvents, compId, UInt64.MaxValue, 0, 0, 0, specs);

            Console.WriteLine("Topology returned " + response.returnedResults + " events." );
            FormatTopologyResponse(response, specs.Length, 0);

            Assert.IsTrue(response.returnedResults == 0);
        }
            
        

        [TestCase]
        public void TestWebPermissions()
        {
            QueryWidget qService = new QueryWidget(ConfigUtil.QueryWebServiceURL);
            GamerTagAndWebID c = User.GetRandomWebCredential();
                        
            ulong               entityId = CreateCompetition(c);
            uint                hr = HResult.E_FAIL;

            //
            // Attempt to delete the competition. Should fail
            //            
            Console.WriteLine("Calling Query.RemoveId to delete my competition");            
            Console.WriteLine();

            try
            {
                qService.RemoveId(c_titleId, c.webID, c.gamerTag, "", c_dsComps, entityId);
            }
            catch(SoapException se)
            {
                Console.WriteLine("Attempt to delete competition " + entityId + " failed with the error " + se.Message );                
                hr = HResult.S_OK;
            }

            Assert.IsTrue(HResult.Succeeded(hr));

            Console.WriteLine();
        }

        [TestCase]
        [Ignore]
        public void TestTeamOps()
        {
            GamerTagAndWebID c = User.GetRandomWebCredential();
            QueryWidget qService = new QueryWidget(ConfigUtil.QueryWebServiceURL);
            
            int                 i;
            ulong               entityId;
            QueryAttribute[]    attribs;
            
            //
            // Create a competition
            //            
            Console.WriteLine("Calling Query.CompetitionCreateSingleElimination for Team " + c.teamName);
            Console.WriteLine();
            
            attribs = new QueryAttribute[3];
            for (i = 0; i < attribs.Length; i++)    { attribs[i] = new QueryAttribute(); }

            attribs[0].Id = 0x00010001;    // nMapId
            attribs[0].Value = (long)1234;            
            attribs[1].Id = 0x00110002;    // name
            attribs[1].Value = "Query WebService Test CompetitionCreateSingleElimination";            
            attribs[2].Id = 0x00210003;    // icon
            attribs[2].Value = new byte[] { 0x1, 0x2, 0x3, 0x4, 0x3, 0x2, 0x1 };

            entityId = qService.CompetitionCreateSingleElimination(c_titleId, c.webID, c.gamerTag, c.teamName, c_dsComps, 
                    4                                /* cPrivateSlots */,
                    4                               /* cPublicSlots */,
                    4                               /* cMinimumPlayers */,
                    DateTime.UtcNow                 /* dtRegistrationOpen */,
                    DateTime.UtcNow.AddMinutes(10)  /* dtRegistrationClose */,
                    DateTime.UtcNow.AddMinutes(20)  /* dtCompetitionStart */,
                    DateTime.UtcNow.AddMinutes(30)  /* dtRoundOneStart */,
                    DateTime.UtcNow.AddMinutes(35)  /* dtRoundOneEnd */,
                    5                               /* dwMatchReminderAdvanceMinutes */,
                    10                              /* UnitOrMask */,
                    Comp.XONLINE_COMP_INTERVAL_MINUTE /* Interval */,
                    true                            /* fTeamCompetition */,
                    6                               /* dwTeamSize */,
                    attribs);

            Console.WriteLine("Competition " + entityId + " added." );
            Console.WriteLine();


            //
            // Cancel the competition
            //            
            Console.WriteLine("Calling Query.CompetitionCancel");            
            Console.WriteLine();
            
            qService.CompetitionCancel(c_titleId, c.webID, c.gamerTag, c.teamName, c_dsComps, entityId);

            Console.WriteLine("Competition " + entityId + " cancelled." );
            Console.WriteLine();            
        }        

        [TestCase]
        public void TestPartnerOps()
        {        
            QueryWidget qService = new QueryWidget(ConfigUtil.QueryWebServiceURL);
                        
            int                 i;
            ulong               entityId = 0;
            QueryAttribute[]    attribs;

            qService.requestInfo = new RequestInfo("DebugAdmin");    // Credential type 2 partner

            //
            // Create a publisher competition
            //
            try
            {
                Console.WriteLine("Calling Query.CompetitionCreateSingleElimination");
                Console.WriteLine();
                
                attribs = new QueryAttribute[3];
                for (i = 0; i < attribs.Length; i++)    { attribs[i] = new QueryAttribute(); }

                attribs[0].Id = 0x00010001;    // nMapId
                attribs[0].Value = (long)1234;            
                attribs[1].Id = 0x00110002;    // name
                attribs[1].Value = "Query WebService Test Publisher Competition";            
                attribs[2].Id = 0x00210003;    // icon
                attribs[2].Value = new byte[] { 0x1, 0x2, 0x3, 0x4, 0x3, 0x2, 0x1 };

                entityId = qService.CompetitionCreateSingleElimination(c_titleId, c_publisherWebId1, null, null, c_dsComps, 
                        4                                /* cPrivateSlots */,
                        4                               /* cPublicSlots */,
                        4                               /* cMinimumPlayers */,
                        DateTime.UtcNow                 /* dtRegistrationOpen */,
                        DateTime.UtcNow.AddMinutes(10)  /* dtRegistrationClose */,
                        DateTime.UtcNow.AddMinutes(20)  /* dtCompetitionStart */,
                        DateTime.UtcNow.AddMinutes(30)  /* dtRoundOneStart */,
                        DateTime.UtcNow.AddMinutes(35)  /* dtRoundOneEnd */,
                        5                               /* dwMatchReminderAdvanceMinutes */,
                        10                              /* UnitOrMask */,
                        Comp.XONLINE_COMP_INTERVAL_MINUTE /* Interval */,
                        false                           /* fTeamCompetition */,
                        0                               /* dwTeamSize */,
                        attribs);

                Console.WriteLine("Competition " + entityId + " added." );
                Console.WriteLine();
            }
            catch(SoapException se)
            {
                Console.WriteLine(se.Message);
                Console.WriteLine();               

                // Should not get here!
                Assert.IsTrue(false);
            }                                

            try
            {
                //
                // Cancel the competition with a different admin
                //            
                Console.WriteLine("Calling Query.CompetitionCancel");            
                Console.WriteLine();
                
                qService.CompetitionCancel(c_titleId, c_publisherWebId2, null, null, c_dsComps, entityId);

                Console.WriteLine("Competition " + entityId + " cancelled." );
                Console.WriteLine();
            }
            catch(SoapException se)
            {
                Console.WriteLine(se.Message);
                Console.WriteLine();               

                // Should not get here!
                Assert.IsTrue(false);
            }                                            
         }        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Query\test\dvt\querywidget.cs ===
using System;
using System.Text;
using System.IO;
using System.Net;
using System.Web;
using System.Web.Services;
using System.Web.Services.Protocols;
using System.Xml;
using System.Threading;



namespace xonline.server.webcache.query.test.dvt 
{
	public class RequestInfo
	{
		public string SubjectName;
		public string ClientIPPort;
		public string RequestId;

		public RequestInfo()
		{
			SubjectName = "DebugPartner";
			ClientIPPort = "1.1.1.1:1000";
			RequestId = "CAFEBABEDEADBEEF";
		}

		public RequestInfo(string subjectName)
		{
			SubjectName = subjectName;
			ClientIPPort = "1.1.1.1:1000";
			RequestId = "CAFEBABEDEADBEEF";
		}

		public RequestInfo(string subjectName, string clientIPPort, string requestId)
		{
			SubjectName = subjectName;
			ClientIPPort = clientIPPort;
			RequestId = requestId;
		}
	}
	
    public class QueryWidget : Query
    {            
		public RequestInfo requestInfo = null;
		
        public QueryWidget(string url) {
            this.Url = url;
        }
        
		override protected WebRequest GetWebRequest(Uri url)
		{
			WebRequest wr = base.GetWebRequest(new Uri(Url));

			if (requestInfo != null)
			{
				wr.Headers.Add("Subject-Name", requestInfo.SubjectName);
				wr.Headers.Add("Client-IP-Port", requestInfo.ClientIPPort);
				wr.Headers.Add("RequestId", requestInfo.RequestId);		
			}

			return wr;
		}

        
    }        
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Signature\Dll\Signature.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Web;
using System.Web.Services;
using System.Web.Caching;
using System.Collections.Specialized;

using Microsoft.Webstore.WstClient;

using xonline.common.config;
using xonline.common.installer;
using xonline.common.machine;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.common.protocol;
using xonline.common.user;
using xonline.common.utilities;

using xonline.server.mgmt.soap;
using xonline.server.webcache.common;

[assembly: XomIisInstallerAttribute( Interface.wcsignature )]
[assembly: ConfigAttribute(xonline.common.config.Component.wcsignature )]

[assembly: XomAreaDefinition(XomAreaName.wcsignaturelog)]

namespace xonline.server.webcache.signature.dll 
{
    [WebService(Namespace="http://websvc.xboxlive.com/Signature/")]
    public class Signature : System.Web.Services.WebService
    {
        static Signature()
        {
            EventBuilder.ShowSGInfo = false;
        }

        public Signature()
        {
            try
            {     
                _util = Utilities.Instance;
                                
                //CODEGEN: This call is required by the ASP.NET Web Services Designer
                InitializeComponent();
            }
            catch (XboxWebException)
            {
                throw;
            }
            catch (Exception e)
            {
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_58, e);
            }
        }

        #region Component Designer generated code
        
        //Required by the Web Services Designer 
        private IContainer components = null;
                
        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
        }

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        protected override void Dispose( bool disposing )
        {
            if(disposing && components != null)
            {
                components.Dispose();
            }
            base.Dispose(disposing);        
        }
        
        #endregion

        public class XSigVerifySignatureRequest
        {
            public byte[] _digest;
            public byte[] _signature;
        }

        // Calls teh verify signature of the sig server on the given data.
        [WebMethod]
        public uint[] VerifySignature(
            XSigVerifySignatureRequest[] sigData
            )
        {
            int numOfEntries = 0;
            int nX = 0;
            uint[] result = null;
            bool successful = false;
            uint maxSignaturesToVerify;

            try
            {
                _util.CheckAPI("Signature.VerifySignature");
                
                // increment counters. 
                WebCacheSignatureCounter.Counters.VerifySignatureRequestsPerSecond.Increment();
                WebCacheSignatureCounter.Counters.VerifySignatureRequestsTotal.Increment();

                SoapFrontEndApp.AddErrorPerfCounter(WebCacheSignatureCounter.Counters.VerifySignatureFailedRequestsPerSecond);
                SoapFrontEndApp.AddErrorPerfCounter(WebCacheSignatureCounter.Counters.VerifySignatureFailedRequestsTotal);

                string partnerName = Utilities.GetSubjectName();
                if (partnerName != null)
                {
                    WebCacheSignatureCounter.Counters[partnerName].VerifySignatureRequestsPerSecond.Increment();
                    WebCacheSignatureCounter.Counters[partnerName].VerifySignatureRequestsTotal.Increment();

                    SoapFrontEndApp.AddErrorPerfCounter(WebCacheSignatureCounter.Counters[partnerName].VerifySignatureFailedRequestsPerSecond);
                    SoapFrontEndApp.AddErrorPerfCounter(WebCacheSignatureCounter.Counters[partnerName].VerifySignatureFailedRequestsTotal);
                }

                Utilities.RequestInfo requestInfo = Utilities.GetRequestInfo();
                
                byte[] response;
                MemoryStream postMS = new MemoryStream();
                BinaryWriter writer = new BinaryWriter(postMS);
                numOfEntries = sigData.Length;

                string strMaxSigsToVerify = Config.GetSetting( Setting.wcsignature_maximumVerifySignaturesPerRequest );
                if ( strMaxSigsToVerify == null )
                {
                    maxSignaturesToVerify = UInt32.Parse( c_DefaultNumberOfSignaturesPerSecond );
                }
                else
                {                    
                    maxSignaturesToVerify = UInt32.Parse( strMaxSigsToVerify );
                }

                if ( numOfEntries > maxSignaturesToVerify )
                {
                    throw new XboxWebInternalException(XEvent.Id.WEBCACHE_TOO_MANY_SIGNATURES, "Signature.VerifySignature:  The number of signatures to verify is greater than permitted amount of " + 
                                                                maxSignaturesToVerify.ToString() + 
                                                                ".");                
                }

                // put each entry into the stream
                for ( nX = 0; nX < numOfEntries; nX++ )
                {
                    if ( sigData[nX]._digest.Length != XSigSignOnBehalfRequest.XONLINE_XSIG_DIGEST_SIZE || 
                         sigData[nX]._signature.Length != XSigSignature.GetSizeInBytes() )
                    {
                        throw new XboxWebInternalException( XEvent.Id.WEBCACHE_INVALID_DIGEST_SIZE, "Signature.VerifySignature:  The given request does not contain the proper size array fields.  Digest: "
                                                            + sigData[nX]._digest.Length.ToString() + " Signature Blob: "
                                                            + sigData[nX]._signature.Length.ToString()
                                                            + ".");                
                    }
                    writer.Write( sigData[nX]._digest );
                    writer.Write( sigData[nX]._signature );
                }

                // close the stream.
                postMS.Close();
                byte[] request = postMS.ToArray();

                // send it to the appropriate front door.
                IVirtualInterfaceInfo vsigInfo = Config.GetVirtualInterface( VirtualInterface.xsig_int, Config.GetIntSetting( Setting.wcsignature_signatureSite ) );
                response = _util.FrontDoorRequest( 
                                            string.Format("http://{0}:{1}/{2}", vsigInfo.IPAddressString, vsigInfo.Port, Config.GetSetting( Setting.wcsignature_verifySignatureURL ) ), 
                                            0, 
                                            0, 
                                            (uint)XOService.Signature_Server, 
                                            0, 
                                            request );
                MemoryStream respMS = new MemoryStream( response );
                BinaryReader reader = new BinaryReader( respMS );
                result = new uint[numOfEntries];

                // read each entry from the response stream.
                for ( nX = 0; nX < numOfEntries; nX++ )
                {
                    result[nX] = reader.ReadUInt32();
                }

                // close the stream.
                respMS.Close();

                successful = true;
               
            }
            catch (XboxWebException)
            {
                result = null;
                throw;
            }
            catch (Exception e)
            {
                result = null;
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_59, e);
            }
            finally
            {
                string szLog = "VSIG|"
                                + Utilities.GetSubjectName()    + "|"
                                + Utilities.GetRequestID()      + "|"
                                + Utilities.GetClientIPPort()   + "|" 
                                + numOfEntries.ToString()       + "|"
                                + (successful?"1":"0");

                Xom.Log(XomAreaName.wcsignaturelog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );
            }
            
            return result;
        }


        public class XSigCreateSignatureRequest
        {            
            public byte[]      _digest;
        }

        public class XSigCreateSignatureResponse
        {
            public uint   _hresult;    
            public byte[] _signature;
        }
    
        // Calls SignOnBehalf of signature server.  Returns array of signatures.
        [WebMethod]
        public XSigCreateSignatureResponse[] CreateSignature(
            uint                            titleID,
            string                          adminId,
            XSigCreateSignatureRequest[]    sigData
            )
        {
            int numOfEntries = 0;
            int nX = 0;
            XSigCreateSignatureResponse[] result = null;
            bool successful = false;
            XSigSignOnBehalfRequest sigSignDataReq = null;
            uint maxSignaturesToVerify;
            uint maxAdminIdLength;

            try
            {
                _util.CheckAPIAndTitle("Signature.CreateSignature", titleID, TitlePrivilege.FullControl );
                
                // increment counters. 
                WebCacheSignatureCounter.Counters.CreateSignatureRequestsPerSecond.Increment();
                WebCacheSignatureCounter.Counters.CreateSignatureRequestsTotal.Increment();

                SoapFrontEndApp.AddErrorPerfCounter(WebCacheSignatureCounter.Counters.CreateSignatureFailedRequestsPerSecond);
                SoapFrontEndApp.AddErrorPerfCounter(WebCacheSignatureCounter.Counters.CreateSignatureFailedRequestsTotal);

                string partnerName = Utilities.GetSubjectName();
                if (partnerName != null)
                {
                    WebCacheSignatureCounter.Counters[partnerName].CreateSignatureRequestsPerSecond.Increment();
                    WebCacheSignatureCounter.Counters[partnerName].CreateSignatureRequestsTotal.Increment();

                    SoapFrontEndApp.AddErrorPerfCounter(WebCacheSignatureCounter.Counters[partnerName].CreateSignatureFailedRequestsPerSecond);
                    SoapFrontEndApp.AddErrorPerfCounter(WebCacheSignatureCounter.Counters[partnerName].CreateSignatureFailedRequestsTotal);
                }

                Utilities.RequestInfo requestInfo = Utilities.GetRequestInfo();
                
                byte[] response;
                MemoryStream postMS = new MemoryStream();
                BinaryWriter writer = new BinaryWriter(postMS);
                numOfEntries = sigData.Length;

                string strMaxSigsToVerify = Config.GetSetting( Setting.wcsignature_maximumVerifySignaturesPerRequest );
                if ( strMaxSigsToVerify == null )
                {
                    maxSignaturesToVerify = UInt32.Parse( c_DefaultNumberOfSignaturesPerSecond );
                }
                else
                {                    
                    maxSignaturesToVerify = UInt32.Parse( strMaxSigsToVerify );
                }
                
                // ensure we're not handling more signatures than we can.
                if ( numOfEntries > maxSignaturesToVerify )
                {
                    throw new XboxWebInternalException(XEvent.Id.WEBCACHE_TOO_MANY_SIGNATURES_1, "Signature.CreateSignature:  The number of signatures to create is greater than permitted amount of " + 
                                                                maxSignaturesToVerify.ToString() + 
                                                                ".");                
                }

                // ensure we have some value for the admin id.
                if ( adminId == null )
                {
                    adminId = "";
                }
                
                // get the length setting.
                string strMaxAdminIdLength = Config.GetSetting( Setting.wcsignature_maximumVerifySignaturesPerRequest );
                if ( strMaxAdminIdLength == null )
                {
                    maxAdminIdLength = UInt32.Parse( c_DefaultMaxAdminIdLength );
                }
                else
                {                    
                    maxAdminIdLength = UInt32.Parse( strMaxAdminIdLength );
                }

                //  check the admin id length... to ensure correctness.
                if ( adminId.Length > maxAdminIdLength )
                {
                    throw new XboxWebException( XEvent.Id.WEBCACHE_BAD_REQUEST_FROM_PARTNER_1, "Invalid Admin Id.");                
                }
                
                
                // since this data doesn't change... only get it once.
                ulong requestorMachinePUID = Utilities.GetRequestorMachinePUID();

                // calculate the users authdata from the given.                
                sigSignDataReq = new XSigSignOnBehalfRequest();
                sigSignDataReq._serviceId = titleID;         
                sigSignDataReq._authData = new XSigAuthData();
                sigSignDataReq._authData._titleID = titleID;  
                sigSignDataReq._authData._titleVersion = 0xFFFFFFFF;              

                sigSignDataReq._authData._XboxID  = requestorMachinePUID;
                // fake the user accounts.
                string adminIdFullSize = adminId.PadRight(32, '\0');
                sigSignDataReq._authData._userID1 = GetFakeUserPUID( adminIdFullSize.Substring(0, 7) );
                sigSignDataReq._authData._userID2 = GetFakeUserPUID( adminIdFullSize.Substring(7, 7) );
                sigSignDataReq._authData._userID3 = GetFakeUserPUID( adminIdFullSize.Substring(14, 7) );
                sigSignDataReq._authData._userID4 = GetFakeUserPUID( adminIdFullSize.Substring(21, 7) );
                
                // put each entry into the stream
                for ( nX = 0; nX < numOfEntries; nX++ )
                {
                    // ensure the digest size.
                    if ( sigData[nX]._digest.Length > XSigSignOnBehalfRequest.XONLINE_XSIG_DIGEST_SIZE )
                    {
                        throw new XboxWebInternalException(XEvent.Id.WEBCACHE_PARTNER_NOT_FOUND_ERROR_2, "Signature.CreateSignature:  No partner name was specified.  Create signature requires this information to continue. " );                        
                    }

                    sigSignDataReq._digest = sigData[nX]._digest;
                    sigSignDataReq.WriteStream( writer );
                }

                // close the stream.
                postMS.Close();
                byte[] request = postMS.ToArray();

                // send it to the appropriate front door.
                IVirtualInterfaceInfo vsigInfo = Config.GetVirtualInterface( VirtualInterface.xsig_int, Config.GetIntSetting( Setting.wcsignature_signatureSite ) );
                response = _util.FrontDoorRequest( 
                                            string.Format("http://{0}:{1}/{2}", vsigInfo.IPAddressString, vsigInfo.Port, Config.GetSetting( Setting.wcsignature_createSignatureURL ) ), 
                                            0, 
                                            0, 
                                            (uint)XOService.Signature_Server, 
                                            0, 
                                            request );
               
                MemoryStream respMS = new MemoryStream( response );
                BinaryReader reader = new BinaryReader( respMS );

                // create our result array.
                result = new XSigCreateSignatureResponse[numOfEntries];

                // read each entry from the response stream.
                for ( nX = 0; nX < numOfEntries; nX++ )
                {
                    XSigSignOnBehalfResponse signResp = new XSigSignOnBehalfResponse();

                    // create a new result object
                    result[nX] = new XSigCreateSignatureResponse();
                                        
                    signResp.ReadStream( reader );
                    result[nX]._hresult = signResp._hresult;
                    result[nX]._signature = (byte[])signResp._signature;

                }

                // close the stream.
                respMS.Close();
                successful = true;

            }
            catch (XboxWebException)
            {
                result = null;
                throw;
            }
            catch (Exception e)
            {
                result = null;
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_60, e);
            }
            finally
            {
                string szLog = "CSIG|"
                                + Utilities.GetSubjectName()    + "|"
                                + Utilities.GetRequestID()      + "|"
                                + Utilities.GetClientIPPort()   + "|"
                                + titleID                       + "|"
                                + adminId                       + "|"
                                + numOfEntries.ToString()       + "|"
                                + (successful?"1":"0");

                Xom.Log(XomAreaName.wcsignaturelog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );
            }

            return result;
        }


        [WebMethod]
        public void TransferUserLicenses(UInt64 xuid, String consoleId)
        {
            HResult hr = HResult.S_OK;
            try
            {
                _util.CheckAPI("Signature.TransferUserLicenses");

                WebCacheSignatureCounter.Counters.TransferUserLicensesRequestsPerSecond.Increment();
                WebCacheSignatureCounter.Counters.TransferUserLicensesRequestsTotal.Increment();

                SoapFrontEndApp.AddErrorPerfCounter(WebCacheSignatureCounter.Counters.TransferUserLicensesFailedRequestsPerSecond);
                SoapFrontEndApp.AddErrorPerfCounter(WebCacheSignatureCounter.Counters.TransferUserLicensesFailedRequestsTotal);

                string partnerName = Utilities.GetSubjectName();
                if (partnerName != null)
                {
                    WebCacheSignatureCounter.Counters[partnerName].TransferUserLicensesRequestsPerSecond.Increment();
                    WebCacheSignatureCounter.Counters[partnerName].TransferUserLicensesRequestsTotal.Increment();

                    SoapFrontEndApp.AddErrorPerfCounter(WebCacheSignatureCounter.Counters[partnerName].TransferUserLicensesFailedRequestsPerSecond);
                    SoapFrontEndApp.AddErrorPerfCounter(WebCacheSignatureCounter.Counters[partnerName].TransferUserLicensesFailedRequestsTotal);
                }

                // Confirm the xuid passed in is valid.
                string gamerTag = _util.LookupGamerTag(xuid);
                if (Utilities.IsInvalidGamertag(gamerTag))
                {
                    throw new PartnerBadRequestException(String.Format("Signature.TransferUserLicenses: Couldn't find user puid {0:X16}.", xuid));
                }

                if (ConsoleIdUtil.IsValidPrefix(consoleId) == false)
                {
                    consoleId = ConsoleIdUtil.AddConsoleIdPrefix( consoleId, XOn.XPLT_XBOX360 );
                }

                // Get the machine puid from the consoleId.
                Machine machine = new Machine();
                hr = machine.Load(MachinePuidUtil.GetXbox360MachineIdFromConsoleIdAndXuid(consoleId,xuid));

                if (hr != HResult.S_OK)
                {
                    throw new PartnerBadRequestException("Invalid consoleID: "+consoleId);
                }

                TransferUserLicensesImpl(xuid, machine.Puid);
            }
            catch (Exception e)
            {
                if (hr == HResult.S_OK)
                {
                    hr = XRLException.ToHResult(e, HResult.XONLINE_E_SIGNATURE_TRANSFER_USER_LICENSES_ERROR);
                }
                if (e is XboxWebException)
                {
                    throw;
                }
                else
                {
                    throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_59, e);
                }
            }
            finally
            {
                string logLine = String.Join("|", new string[]
                                             { 
                                             "WC_TRAN_LIC",
                                             Utilities.GetSubjectName(),
                                             Utilities.GetRequestID(),
                                             Utilities.GetClientIPPort(),
                                             hr.ToString()
                                             });

                Xom.Log(XomAreaName.wcsignaturelog, logLine );
            }
        }

        protected static void TransferUserLicensesImpl(UInt64 xuid, UInt64 machinePuid)
        {
            using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.StoredProc = "p_user_license_transfer_support";
                ws.SetHashVal(xuid);
                ws.AddParameter("@bi_xuid", xuid);
                ws.AddParameter("@bi_destination_machine_puid", machinePuid);
                ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
                ws.ExecuteNonQuery();

                HResult hr = (uint)ws.GetIntParameter("@RETVAL");
                if (HResult.Failed(hr))
                {
                    throw new XboxWebInternalException(
                        XEvent.Id.WEBCACHE_LICENSE_TRANSFER_COMMIT_FAILED,
                        String.Format("Signature.TransferUserLicenses: p_user_license_transfer_support failed. Xuid=0x{0:X16}; hr = {2}",
                                      xuid, hr));
                }
            }
        }

        private const Int32 DIGEST_LENGTH = 20;
        [WebMethod]
        public void BlacklistDigest(byte[] digest, byte deliveryType, string revocationReason)
        {
            BlacklistDigestImpl(digest, 1, deliveryType, revocationReason, "Signature.BlacklistDigest");
        }

        [WebMethod]
        public void UnBlacklistDigest(byte[] digest)
        {
            BlacklistDigestImpl(digest, 0, 0, String.Empty, "Signature.UnBlacklistDigest");
        }

        private void BlacklistDigestImpl(byte[] digest, byte status, byte deliveryType, string revocationReason, string api)
        {
            HResult hr = 0;
            try
            {
                if (digest.Length != DIGEST_LENGTH)
                {
                    throw new XboxWebInternalException(XEvent.Id.WEBCACHE_SIGNATURE_BLACKLIST_DIGEST_WRONG_SIZE,
                        String.Format("Digest has length of {0} but it must be {1}.", digest.Length, DIGEST_LENGTH));
                }

                _util.CheckAPI(api);

                WebCacheSignatureCounter.Counters.BlacklistDigestRequestsPerSecond.Increment();
                WebCacheSignatureCounter.Counters.BlacklistDigestRequestsTotal.Increment();

                SoapFrontEndApp.AddErrorPerfCounter(WebCacheSignatureCounter.Counters.BlacklistDigestFailedRequestsPerSecond);
                SoapFrontEndApp.AddErrorPerfCounter(WebCacheSignatureCounter.Counters.BlacklistDigestFailedRequestsTotal);

                string partnerName = Utilities.GetSubjectName();
                if (partnerName != null)
                {
                    WebCacheSignatureCounter.Counters[partnerName].BlacklistDigestRequestsPerSecond.Increment();
                    WebCacheSignatureCounter.Counters[partnerName].BlacklistDigestRequestsTotal.Increment();

                    SoapFrontEndApp.AddErrorPerfCounter(WebCacheSignatureCounter.Counters[partnerName].BlacklistDigestFailedRequestsPerSecond);
                    SoapFrontEndApp.AddErrorPerfCounter(WebCacheSignatureCounter.Counters[partnerName].BlacklistDigestFailedRequestsTotal);
                }

                XSigWeb xsigweb = new XSigWeb();
                IVirtualInterfaceInfo vsigInfo = Config.GetVirtualInterface( VirtualInterface.xsig_int, Config.GetIntSetting( Setting.wcsignature_signatureSite ) );
                xsigweb.Url = String.Format("http://{0}:{1}/xsig/xsigweb.asmx", vsigInfo.IPAddressString, vsigInfo.Port);
                xsigweb.SetBlacklistDigestState(digest, status, deliveryType, revocationReason);
            }
            catch (Exception e)
            {
                hr = XRLException.ToHResult(e, HResult.XONLINE_E_SIGNATURE_ERROR);
                if (e is XboxWebException)
                {
                    throw;
                }
                else
                {
                    throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_59, e);
                }
            }
            finally
            {
                string logLine = String.Join("|", new string[]
                                             { 
                                             "WC_BLACKLIST",
                                             Utilities.GetSubjectName(),
                                             Utilities.GetRequestID(),
                                             Utilities.GetClientIPPort(),
                                             hr.ToString()
                                             });

                Xom.Log(XomAreaName.wcsignaturelog, logLine );
                Xom.Log(XomAreaName.Reporting_v2, logLine );
            }
        }

        protected ulong GetFakeUserPUID( string identifier )
        {
            MemoryStream ms = new MemoryStream();
            BinaryWriter bw = new BinaryWriter( ms );

            if ( identifier == null )
            {
                identifier = "";
            }

            identifier = identifier.PadRight( 7, '\0' );
            
            // the other 7 bytes are the SHA1 hash of the subject name.
            bw.Write( System.Text.ASCIIEncoding.ASCII.GetBytes( identifier ), 0, 7 );

            // first byte is 0xFC
            bw.Write( (byte)(0xFC) );
            
            bw.Close();                
                        
            return System.BitConverter.ToUInt64( ms.ToArray(), 0 );
        }
        
        //----------------------------------------
        //  Constants
        //----------------------------------------
        protected const string c_DefaultNumberOfSignaturesPerSecond = "100";
        protected const string c_DefaultMaxAdminIdLength = "31";

        //----------------------------------------
        //  Attributes
        //----------------------------------------
        static protected Utilities _util;
        static protected uint      _CacheLifeTimeInSecs;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Signature\Dll\PerfCounters.cs ===
using System;
using System.Threading;
using System.Diagnostics;
using xonline.common.mgmt;
using xonline.common.service;

namespace xonline.server.webcache.signature.dll 
{

    [XomPerformanceCounterCategoryAttr( "WebCache: Signature Server", "Xbox Live: WebCache Signature Server Performance Counters" )]
    public class WebCacheSignatureCounter : XomPerformanceCounterCategory
    {
        [XomPerformanceCounterAttr(
             "VerifySignature requests per second", 
             "Number of VerifySignature requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter VerifySignatureRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "VerifySignature requests total", 
             "Total VerifySignature requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter VerifySignatureRequestsTotal;

        [XomPerformanceCounterAttr(
             "VerifySignature requests failed per second", 
             "Number of VerifySignature requests that failed execution per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter VerifySignatureFailedRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "VerifySignature requests failed total", 
             "Total VerifySignature requests that failed recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter VerifySignatureFailedRequestsTotal;

        [XomPerformanceCounterAttr(
             "CreateSignature requests per second", 
             "Number of CreateSignature requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter CreateSignatureRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "CreateSignature requests total", 
             "Total CreateSignature requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter CreateSignatureRequestsTotal;

        [XomPerformanceCounterAttr(
             "CreateSignature requests failed per second", 
             "Number of CreateSignature requests that failed execution per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter CreateSignatureFailedRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "CreateSignature requests failed total", 
             "Total CreateSignature requests that failed recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter CreateSignatureFailedRequestsTotal;

        [XomPerformanceCounterAttr(
             "TransferUserLicenses requests per second", 
             "Number of TransferUserLicenses requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter TransferUserLicensesRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "TransferUserLicenses requests total", 
             "Total TransferUserLicenses requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TransferUserLicensesRequestsTotal;

        [XomPerformanceCounterAttr(
             "TransferUserLicenses requests failed per second", 
             "Number of TransferUserLicenses requests that failed execution per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter TransferUserLicensesFailedRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "TransferUserLicenses requests failed total", 
             "Total TransferUserLicenses requests that failed recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TransferUserLicensesFailedRequestsTotal;


        [XomPerformanceCounterAttr(
             "BlacklistDigest requests per second", 
             "Number of BlacklistDigest requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter BlacklistDigestRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "BlacklistDigest requests total", 
             "Total BlacklistDigest requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter BlacklistDigestRequestsTotal;

        [XomPerformanceCounterAttr(
             "BlacklistDigest requests failed per second", 
             "Number of BlacklistDigest requests that failed execution per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter BlacklistDigestFailedRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "BlacklistDigest requests failed total", 
             "Total BlacklistDigest requests that failed recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter BlacklistDigestFailedRequestsTotal;

        public virtual WebCacheSignatureCounter this[string partnerName]
        {
            get
            {
                return (WebCacheSignatureCounter) GetInstance(partnerName);
            }
        }

        static public WebCacheSignatureCounter Counters = new WebCacheSignatureCounter();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Signature\Test\dvt\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Query\test\QueryWidget.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Threading;
using System.Xml;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.Web;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.Query;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Presence;
using xonline.common.config;

[assembly: RootNode(typeof(QueryWidget.QueryWidget))]

namespace QueryWidget
{
	/// <summary>
	/// Summary description for Class1.
	/// </summary>
    /// 
    [Owner("PaulLy"), TestFrequency("Regression"), TestCasePriority(3), ServerTestFramework.Description("Query Widget test case")]
	public class QueryWidget : TestNode
	{
        public override void PreRun(RUN_TYPE runType)
        {
            if (runType == RUN_TYPE.FUNCTIONAL)
            {
                InitializeFunctional();
            }
            else if (runType == RUN_TYPE.STRESS)
            {
                InitializeStress();
            }
        }

        public override void PostRun(RUN_TYPE runType)
        {
            if (runType == RUN_TYPE.FUNCTIONAL)
            {
                DeinitializeFunctional();
            }
            else if (runType == RUN_TYPE.STRESS)
            {
                DeinitializeStress();
            }
        }

        public void InitializeFunctional()
		{
			// connect to query sql servers	-- [09/22/2005] title prop only goes to first sql server in list so don't include all of them
			QueryWidgetCommon.qrySqlConn = new SqlConnection[1];
			for (int i=0; i<QueryWidgetCommon.qrySqlConn.Length; i++)
			{
				try
				{
					QueryWidgetCommon.qrySqlConn[i] = new SqlConnection("server="+Global.XEnv.GetServerListByInterface(Interface.querydb)[i]+";database=querydb;Integrated Security=SSPI");
					QueryWidgetCommon.qrySqlConn[i].Open();
				}
				catch (Exception e)
				{
					ConsoleX.WriteLine("Error connecting to query SQL: "+e.Message);
				}
			}

			// connect to npdb sql servers
			QueryWidgetCommon.npdbSqlConn = new SqlConnection[Global.XEnv.GetServerListByInterface(Interface.npdb).Length];
			for (int i=0; i<Global.XEnv.GetServerListByInterface(Interface.npdb).Length; i++)
			{
				try
				{
                    IInterfaceInfo npdbInfo = Config.GetInterface(Global.XEnv.GetServerListByInterface(Interface.npdb)[i], Interface.npdb);
					QueryWidgetCommon.npdbSqlConn[i] = new SqlConnection(npdbInfo.SqlConnectionString);
					QueryWidgetCommon.npdbSqlConn[i].Open();
				}
				catch (Exception e)
				{
					ConsoleX.WriteLine("Error connecting to npdb SQL: "+e.Message);
				}
			}

			// get comps and query user info from xml file
			XmlDocument parameters = new XmlDocument();
			parameters.Load("QueryWidget.xml");
			XmlNode paramNode;

			try
			{
				// query

				paramNode = parameters.SelectSingleNode("/stf/parameters/titleId");
				if (null == paramNode)
					throw new Exception();
				QueryWidgetCommon.QUERY_TITLE_ID = Convert.ToUInt32(paramNode.InnerText);

				paramNode = parameters.SelectSingleNode("/stf/parameters/datasetId");
				if (null == paramNode)
					throw new Exception();
				QueryWidgetCommon.QUERY_DATASET_ID = Convert.ToUInt32(paramNode.InnerText);

				paramNode = parameters.SelectSingleNode("/stf/parameters/webId");
				if (null == paramNode)
					throw new Exception();
				QueryWidgetCommon.QUERY_WEBID = BitConverter.GetBytes(Convert.ToUInt64(paramNode.InnerText));

				paramNode = parameters.SelectSingleNode("/stf/parameters/gamerTag");
				if (null == paramNode)
					throw new Exception();
				QueryWidgetCommon.QUERY_GAMERTAG = paramNode.InnerText;

				paramNode = parameters.SelectSingleNode("/stf/parameters/teamName");
				if (null == paramNode)
					throw new Exception();
				QueryWidgetCommon.QUERY_TEAMNAME = paramNode.InnerText;

				// comps

				paramNode = parameters.SelectSingleNode("/stf/competitions/titleId");
				if (null == paramNode)
					throw new Exception();
				QueryWidgetCommon.COMPS_TITLE_ID = Convert.ToUInt32(paramNode.InnerText);

				paramNode = parameters.SelectSingleNode("/stf/competitions/datasetId");
				if (null == paramNode)
					throw new Exception();
				QueryWidgetCommon.COMPS_DATASET_ID = Convert.ToUInt32(paramNode.InnerText);

				paramNode = parameters.SelectSingleNode("/stf/competitions/webId");
				if (null == paramNode)
					throw new Exception();
				QueryWidgetCommon.COMPS_WEBID = BitConverter.GetBytes(Convert.ToUInt64(paramNode.InnerText));

				paramNode = parameters.SelectSingleNode("/stf/competitions/gamerTag");
				if (null == paramNode)
					throw new Exception();
				QueryWidgetCommon.COMPS_GAMERTAG = paramNode.InnerText;

				paramNode = parameters.SelectSingleNode("/stf/competitions/teamName");
				if (null == paramNode)
					throw new Exception();
				QueryWidgetCommon.COMPS_TEAMNAME = paramNode.InnerText;
			}
			catch (Exception)
			{
				ConsoleX.WriteLine("Invalid parameter element found in xml.");
			}

		}

        public void DeinitializeFunctional()
		{
			for (int i=0; i<QueryWidgetCommon.qrySqlConn.Length; i++)
				if (QueryWidgetCommon.qrySqlConn[i] != null && QueryWidgetCommon.qrySqlConn[i].State != ConnectionState.Closed)
					QueryWidgetCommon.qrySqlConn[i].Close();

			for (int i=0; i<QueryWidgetCommon.npdbSqlConn.Length; i++)
				if (QueryWidgetCommon.npdbSqlConn[i] != null && QueryWidgetCommon.npdbSqlConn[i].State != ConnectionState.Closed)
					QueryWidgetCommon.npdbSqlConn[i].Close();
		}

		public void DeinitializeStress()
		{
			if (StressHelpers.strInfo != null)
				StressHelpers.strInfo.Close();
		}

        public void InitializeStress()
        {
			// set up log
			if (StressHelpers.logging)
				StressHelpers.strInfo = System.IO.File.CreateText(@"c:\xonline\private\test\stftests\querywidget\log_"+DateTime.UtcNow.ToString("MM_dd_HHmm")+".txt");

			// set up specs for topology
			for (int j=0; j<StressHelpers.topSpecs.Length; j++)
			{
				StressHelpers.topSpecs[j] = new QueryAttributeSpec();
				StressHelpers.topSpecs[j].len = 8;
			}
			StressHelpers.topSpecs[0].type = 0x80000000;
			StressHelpers.topSpecs[1].type = 0x80030001;
			StressHelpers.topSpecs[2].type = 0x80030002;
			StressHelpers.topSpecs[3].type = 0x80030003;
			StressHelpers.topSpecs[4].type = 0x80030006;
			StressHelpers.topSpecs[5].type = 0x80030007;
			StressHelpers.topSpecs[6].type = 0x80030008;
			StressHelpers.topSpecs[7].len = 200;
			StressHelpers.topSpecs[7].type = 0x81130008;
			StressHelpers.topSpecs[8].type = 0x8003000B;
			StressHelpers.topSpecs[9].len = 200;
			StressHelpers.topSpecs[9].type = 0x8113000B;
			StressHelpers.topSpecs[10].type = 0x8003000E;
			StressHelpers.topSpecs[11].type = 0x8003000F;
			StressHelpers.topSpecs[12].type = 0x00030001;
			StressHelpers.topSpecs[13].len = 200;
			StressHelpers.topSpecs[13].type = 0x00130002;
			StressHelpers.topSpecs[14].len = 400;
			StressHelpers.topSpecs[14].type = 0x00230003;

			// set up specs for Comp Search
			for (int j=0; j<StressHelpers.CSearchSpecs.Length; j++)
			{
				StressHelpers.CSearchSpecs[j] = new QueryAttributeSpec();
				StressHelpers.CSearchSpecs[j].len = 8;
			}
			StressHelpers.CSearchSpecs[0].type = 0x80000000;
			StressHelpers.CSearchSpecs[1].type = 0x80010003;
			StressHelpers.CSearchSpecs[2].type = 0x80010005;
			StressHelpers.CSearchSpecs[3].type = 0x80010006;
			StressHelpers.CSearchSpecs[4].type = 0x80010007;
			StressHelpers.CSearchSpecs[5].type = 0x8001000c;
			StressHelpers.CSearchSpecs[6].type = 0x8001000d;
			StressHelpers.CSearchSpecs[7].type = 0x80010010;
			StressHelpers.CSearchSpecs[8].type = 0x80010011;
			StressHelpers.CSearchSpecs[9].type = 0x80010012;
			StressHelpers.CSearchSpecs[10].type = 0x80010013;
			StressHelpers.CSearchSpecs[11].type = 0x80010018;
			StressHelpers.CSearchSpecs[12].type = 0x80010019;
			StressHelpers.CSearchSpecs[13].type = 0x8001001D;
			StressHelpers.CSearchSpecs[14].type = 0x00010001;
			StressHelpers.CSearchSpecs[15].len = 200;
			StressHelpers.CSearchSpecs[15].type = 0x00110002;
			StressHelpers.CSearchSpecs[16].len = 400;
			StressHelpers.CSearchSpecs[16].type = 0x00210003;

		}


	}

/*********************** objects common to multiple tests *************************/

	class QueryWidgetCommon
	{
		// members to define invalid parameters
		public static UInt32 TITLEID_NOT_EXIST = 0x000004d3;
		public static UInt32 TITLEID_NO_QUERY = 400001;
		public static Byte[] WEBID_NOT_EXIST = BitConverter.GetBytes((long)562949900000000);
		public static Byte[] WEBID_NO_MATCH = { 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1 };		// valid webId but doesn't match gamerTag in xml file
		public static Byte[] WEBID_TOO_SHORT = { 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };
		public static Byte[] WEBID_TOO_LONG = { 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1, 0x0 };
		public static string GAMERTAG_TOO_LONG = "webuser10230000";
		public static string TEAMNAME_NOT_EXIST = "widgetTeam";
		public static string TEAMNAME_NO_MATCH = "webteam126";
		public static string TEAMNAME_TOO_LONG = "webteam12700000";	// 15 chars is max
		public static UInt32 PROCINDEX_NOT_EXIST = 500;
		public static UInt64 HAVEVERSION_NOT_EXIST = 5;
		public static UInt32 ACTION_NOT_EXIST = 10000;

		public static short USER_QUOTA = 3;		// dataset has quota of 3 entries per user/team (see xqs file)
		public static short COMPS_QUOTA = 5;	// dataset for comps has quota of 5 entries per user/team (ONLY for datasetId = 10)
		public static long QUERY_TEAMID = 0;
		public static long COMPS_TEAMID = 0;

		public static uint QUERY_TITLE_ID = 0;
		public static uint QUERY_DATASET_ID = 0;
		public static string QUERY_GAMERTAG = "";
		public static string QUERY_TEAMNAME = "";
		public static byte [] QUERY_WEBID = null;
		public static uint COMPS_TITLE_ID = 0;
		public static uint COMPS_DATASET_ID = 0;
		public static string COMPS_GAMERTAG = "";
		public static string COMPS_TEAMNAME = "";
		public static byte [] COMPS_WEBID = null;

		public static SqlConnection [] qrySqlConn = null;
		public static SqlConnection [] npdbSqlConn = null;

		// following commented items for use with teams/xcache test in FuncQueryAdd.cs
/*		public static Team [] QueryTeams = new Team[3];
		public static Team [] CompsTeams = new Team[3];
		public static PNUser [] userQuery = new PNUser[2];
		public static PNUser [] userComps = new PNUser[2];
		public static PNXbox [] xboxQuery = new PNXbox[2];
		public static PNXbox [] xboxComps = new PNXbox[2];
		public static FriendsCommon fc = new FriendsCommon();
*/
		public static long GetTeamId(string team, uint titleId)
		{
			long lRet = 0;

			// set up database query to get team's PUID
			string sql;
			SqlConnection [] m_SqlConnection = new SqlConnection[Global.XEnv.GetServerListByInterface(Interface.uodb).Length];
			for (int i=0; i<m_SqlConnection.Length; i++)
				m_SqlConnection[i] = new SqlConnection("server="+Global.XEnv.GetServerListByInterface(Interface.uodb)[i]+";database=UODB;Integrated Security=SSPI");
			SqlCommand mySqlCommand = null;
			SqlDataReader [] myDataReader = new SqlDataReader[m_SqlConnection.Length];
			try
			{
				sql="SELECT [bi_team_puid] FROM [UODB].[dbo].[t_xprof_teams] WHERE vc_name='"+team+"' AND i_title_id="+titleId;
				for (int i=0; i<m_SqlConnection.Length; i++)
				{
					m_SqlConnection[i].Open();

					mySqlCommand = new SqlCommand(sql,m_SqlConnection[i]);
					myDataReader[i] = mySqlCommand.ExecuteReader();

					if (myDataReader[i].Read() != false)
					{
						lRet = myDataReader[i].GetInt64(0);
						break;
					}
				}
			}
			catch (System.Exception e)
			{
				ConsoleX.WriteLine("Unable to query for team: " + e.Message);
				lRet = 0;
			}
			finally
			{
				// Always call Close when done reading.
				for (int i=0; i<m_SqlConnection.Length; i++)
				{
					if (myDataReader[i] != null)
						myDataReader[i].Close();
					if (m_SqlConnection[i] != null && m_SqlConnection[i].State == ConnectionState.Open)
						m_SqlConnection[i].Close();
				}
			}

			return lRet;
		}

		// following commented method is for use with teams/xcache test in FuncQueryAdd.cs
/*		public static void CreateTeams(uint titleId, PNUser [] users, Team [] teams, PNXbox [] xbox)
		{
			try
			{
				// log in users
				users[0] = new PNUser(new ServerTestFramework.Database.PuidName(2814749767105536, "webuser1023", BitConverter.GetBytes(562949953421310)));
				users[1] = new PNUser(new ServerTestFramework.Database.PuidName(2814749767106059, "webuser500", BitConverter.GetBytes(562949953420787)));

				// create xbox with given titleId
				xbox[0] = new PNXbox();
				xbox[0].ChangeTitle(titleId,0,0);
				xbox[1] = new PNXbox();
				xbox[1].ChangeTitle(titleId,0,0);

				// log on users
				fc.LogonUser(users[0], xbox[0]);
				fc.LogonUser(users[1], xbox[1]);

				// create teams if not exist

				uint nAttempts = 0;

				// team for use in most test cases
				if (null == teams[0])
				{
					teams[0] = new Team(users[0],4);
					teams[0].Name = "QueryXCache1";
				}
				while (!teams[0].Created && nAttempts++ < 3)
				{
					try
					{
						teams[0].Create();
					}
					catch (Exception)
					{
					}
				}
				if (!teams[0].Created)
					teams[0] = null;
			}
			catch (System.Exception e)
			{
				ConsoleX.WriteLine("Unable to create teams: " + e.Message);
			}
		}
*/
		public static bool ClearDataSet(UInt32 titleId, UInt32 datasetId)
		{
			if (COMPS_TITLE_ID == titleId)		// don't allow comps delete
				return false;

			bool bRet = true;

			// set up database query
			string sql="DELETE FROM [QueryDB].[dbo].[t_query_dataset_"+Hexer.tohex(titleId)+"_"+datasetId.ToString("x")+"]";
			SqlCommand mySqlCommand = null;
			SqlDataReader myDataReader = null;

			for (int iSql=0; iSql<qrySqlConn.Length; iSql++)
			{
				try
				{
					mySqlCommand = new SqlCommand(sql,qrySqlConn[iSql]);
					myDataReader = mySqlCommand.ExecuteReader();

					if (myDataReader != null && !myDataReader.IsClosed)
						myDataReader.Close();
				}
				catch (Exception e)
				{
					ConsoleX.WriteLine("SQL error in ClearDataSet(): " + e.Message);
					bRet = false;
					if (qrySqlConn[iSql].State != ConnectionState.Open)
						qrySqlConn[iSql].Open();
				}
				finally
				{
					// Always call Close when done reading.
					if (myDataReader != null && !myDataReader.IsClosed)
						myDataReader.Close();
				}
			}

			return bRet;
		}

		public static bool ClearCompData(UInt32 titleId, UInt32 datasetId)
		{
			bool bRet = true;

			WCQuery wc = new WCQuery();

			// set up database query
			SqlCommand mySqlCommand = null;
			SqlDataReader myDataReader = null;
			int iNPSql=0;

			for (int iSql=0; iSql<qrySqlConn.Length; iSql++)
			{
				try
				{
					mySqlCommand = new SqlCommand("SELECT bi_entity_id FROM [QueryDB].[dbo].[t_query_dataset_"+Hexer.tohex(titleId)+"_"+datasetId.ToString("x")+"] WHERE att_8001001d <> 0x1",qrySqlConn[iSql]);
					myDataReader = mySqlCommand.ExecuteReader();

					ArrayList alCompIds = new ArrayList();

					while (myDataReader.Read() != false)
						alCompIds.Add((UInt64)myDataReader.GetInt64(0));

					if (myDataReader != null && !myDataReader.IsClosed)
						myDataReader.Close();

					foreach (UInt64 compId in alCompIds)
					{
						SqlCommand comm = null;
						for (iNPSql=0; iNPSql<npdbSqlConn.Length; iNPSql++)
						{
							// delete the competition from CRON JOBS
							comm = new SqlCommand("DELETE FROM t_cron_jobs where vc_name like '%0x"+compId.ToString("X")+"%'",npdbSqlConn[iNPSql]);
							comm.ExecuteNonQuery();
						}

						// delete the competition from querydb
						comm = new SqlCommand("DELETE FROM [QueryDB].[dbo].[t_query_dataset_"+Hexer.tohex(titleId)+"_"+datasetId.ToString("x")+"] WHERE bi_entity_id = "+compId,qrySqlConn[iSql]);
						comm.ExecuteNonQuery();
					}
				}
				catch (Exception e)
				{
					ConsoleX.WriteLine("SQL error in ClearCompData(): " + e.Message);
					bRet = false;
					if (qrySqlConn[iSql].State != ConnectionState.Open)
						qrySqlConn[iSql].Open();
					if (npdbSqlConn[iNPSql].State != ConnectionState.Open)
						npdbSqlConn[iNPSql].Open();
				}
				finally
				{
					// Always call Close when done reading.
					if (myDataReader != null && !myDataReader.IsClosed)
						myDataReader.Close();
				}
			}

			return bRet;
		}

		public static bool ClearCompDataOLD(UInt32 titleId, UInt32 datasetId)
		{
			bool bRet = true;

			WCQuery wc = new WCQuery();

			// set up database query
			string sql="SELECT bi_entity_id, bi_owner_id FROM [QueryDB].[dbo].[t_query_dataset_"+Hexer.tohex(titleId)+"_"+datasetId.ToString("x")+"] WHERE att_8001001d <> 0x1 AND att_8001001d <> 0xFFFFFFFF";
			SqlCommand mySqlCommand = null;
			SqlDataReader myDataReader = null;
			for (int iSql=0; iSql<qrySqlConn.Length; iSql++)
			{
				try
				{
					mySqlCommand = new SqlCommand(sql,qrySqlConn[iSql]);
					myDataReader = mySqlCommand.ExecuteReader();

					while (myDataReader.Read() != false)
					{
						UInt64 compId = (UInt64)myDataReader.GetInt64(0);
						UInt64 ownerId = (UInt64)myDataReader.GetInt64(1);
						UInt64 gamertagEnding = (UInt64)2814749767106559 - ownerId;
						if (gamertagEnding > 1023)
							continue;

						bool successful = false;
						uint nAttempts = 0;

						while (!successful && nAttempts++ < 3)
						{
							try
							{
								// cancel the competition
								wc.WidgetCompetitionCancel(titleId,BitConverter.GetBytes(Convert.ToUInt64(562949953420287+gamertagEnding)),"webuser"+Convert.ToString(gamertagEnding),null,1,compId);

								// warp past comp start
								QueryAttribute[] tmpAttribs = new QueryAttribute[1];
								tmpAttribs[0] = new QueryAttribute();
								tmpAttribs[0].Id = 0x80010023;
								tmpAttribs[0].Value = (long)60*60*24 + (long)60*6;	// advance 1 day + 6 minutes
								wc.WidgetSelect(titleId,BitConverter.GetBytes(Convert.ToUInt64(562949953420287+gamertagEnding)),"webuser"+Convert.ToString(gamertagEnding),null,1,compId,99,tmpAttribs);

								// wait for slotting
								Thread.Sleep(1000);

								// warp well beyond comp
								tmpAttribs[0].Value = (long)60*60*24*3;	// advance 3 days
								wc.WidgetSelect(titleId,BitConverter.GetBytes(Convert.ToUInt64(562949953420287+gamertagEnding)),"webuser"+Convert.ToString(gamertagEnding),null,1,compId,99,tmpAttribs);

								successful = true;
							}
							catch (Exception e)
							{
								if (!e.Message.EndsWith("does not exist in the dataset specified."))
								{
									successful = false;
									if (3 == nAttempts)
										throw;
								}
							}
						}
					}

					if (myDataReader != null && !myDataReader.IsClosed)
						myDataReader.Close();
				}
				catch (Exception e)
				{
					ConsoleX.WriteLine("SQL error in ClearCompData(): " + e.Message);
					bRet = false;
					if (qrySqlConn[iSql].State != ConnectionState.Open)
						qrySqlConn[iSql].Open();
				}
				finally
				{
					// Always call Close when done reading.
					if (myDataReader != null && !myDataReader.IsClosed)
						myDataReader.Close();
				}
			}

			return bRet;
		}

		public static uint GetNumRecords(UInt32 titleId, UInt32 datasetId)
		{
			SqlCommand mySqlCommand = null;
			SqlDataReader myDataReader = null;
			uint nRecords = 0;

			// get # records prior to Widget call
			string sql;
			if (titleId == QUERY_TITLE_ID || (datasetId != 1 && datasetId != 10))
				sql="SELECT Count(*) FROM [QueryDB].[dbo].[t_query_dataset_"+Hexer.tohex(titleId)+"_"+datasetId.ToString("x")+"]";
			else
				sql="SELECT Count(*) FROM [QueryDB].[dbo].[t_query_dataset_"+Hexer.tohex(titleId)+"_"+datasetId.ToString("x")+"] WHERE att_8001001d = 0";

			for (int iSql=0; iSql<qrySqlConn.Length; iSql++)
			{
				try
				{
					bool bSuccess = false;
					uint nAttempts = 0;
					while (!bSuccess && nAttempts++ < 3)
					{
						try
						{
							mySqlCommand = new SqlCommand(sql,qrySqlConn[iSql]);
							myDataReader = mySqlCommand.ExecuteReader();

							// get number of matching records
							if (myDataReader.Read() != false)
							{
								nRecords += (uint)myDataReader.GetInt32(0);
								bSuccess = true;
							}
						}
						catch (Exception)
						{
							bSuccess = false;
							if (3 == nAttempts)
								ConsoleX.WriteLine("Unable to determine number of records in dataset.");
						}
					}
				}
				catch
				{
					if (qrySqlConn[iSql].State != ConnectionState.Open)
						qrySqlConn[iSql].Open();
				}
				finally
				{
					// Always call Close when done reading.
					if (myDataReader != null && !myDataReader.IsClosed)
						myDataReader.Close();
				}
			}

			return nRecords;
		}

		public static bool VerifyNoChange(UInt32 titleId, UInt32 datasetId, DateTime dtTestStart)
		{
			// REM "SELECT [bi_entity_id], [bi_owner_id], [dt_change_datetime], [att_00000001], [att_00100003], [att_00200005] FROM [QueryDB].[dbo].[t_query_dataset_0000b2d2_1]"

			bool bRet=true;
			string strDate = dtTestStart.GetDateTimeFormats()[71];

			// set up database query
			string sql="SELECT Count(*) FROM [QueryDB].[dbo].[t_query_dataset_"+Hexer.tohex(titleId)+"_"+datasetId.ToString("x")+"] WHERE dt_change_datetime >= '"+strDate+"'";
			SqlCommand mySqlCommand = null;
			SqlDataReader myDataReader = null;
			int nMatchingRecords = 0;
			bool success = true;

			for (int iSql=0; iSql<qrySqlConn.Length; iSql++)
			{
				try
				{
					mySqlCommand = new SqlCommand(sql,qrySqlConn[iSql]);
					myDataReader = mySqlCommand.ExecuteReader();

					// get number of matching records
					if (myDataReader.Read() != false)
					{
						nMatchingRecords += myDataReader.GetInt32(0);
						success &= true;
					}
					else
						success = false;

					if (myDataReader != null && !myDataReader.IsClosed)
						myDataReader.Close();

					bRet = (success && nMatchingRecords == 0);
				}
				catch (Exception e)
				{
					ConsoleX.WriteLine("SQL error in VerifyNoChange(): " + e.Message);
					bRet = false;
					if (qrySqlConn[iSql].State != ConnectionState.Open)
						qrySqlConn[iSql].Open();
				}
				finally
				{
					// Always call Close when done reading.
					if (myDataReader != null && !myDataReader.IsClosed)
						myDataReader.Close();
				}
			}

			return bRet;
		}

		public static DateTime GetSqlServerTime()
		{
/*			DateTime dtRet = DateTime.UtcNow;

			RequestInfo rInfo = new RequestInfo("DebugAdmin");
			WCQuery wcPartner = new WCQuery(Global.XEnv.GetVirtualInterface(VirtualInterface.wcquery),rInfo);

			QueryAttribute [] attribs = new QueryAttribute[3];
			for (int i=0; i<3; i++)
				attribs[i] = new QueryAttribute();
			attribs[0].Id = 1;
			attribs[1].Id = 1048579;
			attribs[2].Id = 2097157;
			attribs[0].Value = (long)9099989796959;
			attribs[1].Value = (string)("entry to get server time");
			attribs[2].Value = Hexer.unhex("ABC123");

			SqlDataReader myDataReader = null;
			try
			{
				// add entry to dataset 5
				wcPartner.WidgetAdd(QUERY_TITLE_ID,BitConverter.GetBytes(QUERY_TITLE_ID),null,null,10,attribs);

				// read dt_change_datetime
				string sql="SELECT dt_change_datetime FROM [QueryDB].[dbo].[t_query_dataset_"+Hexer.tohex(QUERY_TITLE_ID)+"_a] WHERE bi_owner_id = "+QUERY_TITLE_ID+" ORDER BY dt_change_datetime DESC";
				SqlCommand mySqlCommand = new SqlCommand(sql,qrySqlConn[0]);
				myDataReader = mySqlCommand.ExecuteReader();

				if (myDataReader.Read())
					dtRet = myDataReader.GetDateTime(0);
			}
			catch (Exception e)
			{
				ConsoleX.WriteLine("Error adding line to get SQL time: "+e.Message);
				if (qrySqlConn[0].State != ConnectionState.Open)
					qrySqlConn[0].Open();
			}
			finally
			{
				if (myDataReader != null && !myDataReader.IsClosed)
					myDataReader.Close();
			}

			return dtRet;
*/
			return UodbWS.GetUTCDate();
		}

		public static void FillDBDataSet5()
		{
			if (GetNumRecords(QUERY_TITLE_ID,5) == 502)
				return;
			ClearDataSet(QUERY_TITLE_ID,5);

			// add entries to DB
			WCQuery wc = new WCQuery();
			QueryAttribute [] attribs = new QueryAttribute[3];
			for (int i=0; i<3; i++)
				attribs[i] = new QueryAttribute();
			attribs[0].Id = 1;
			attribs[1].Id = 1048579;
			attribs[2].Id = 2097157;
			System.Random rnd = new Random(DateTime.Now.Millisecond + DateTime.Now.Second);

			try
			{
				for (int i=500; i<550; i++)
				{
					if (rnd.Next(0,2) == 0)
					{
						attribs[0].Value = (long)5000;
						attribs[1].Value = (string)("my_string"+i.ToString());
						attribs[2].Value = Hexer.unhex("427379078");
						wc.WidgetAdd(QUERY_TITLE_ID,BitConverter.GetBytes(Convert.ToUInt64(562949953420287+i)),"webuser"+i.ToString(),"",5,attribs);
					}
					else
					{
						attribs[0].Value = (long)56;
						attribs[1].Value = (string)("my_string"+i.ToString());
						attribs[2].Value = Hexer.unhex("340124320573403750734989482037589473985734723");
						wc.WidgetAdd(QUERY_TITLE_ID,BitConverter.GetBytes(Convert.ToUInt64(562949953420287+i)),"webuser"+i.ToString(),null,5,attribs);
					}
					if (rnd.Next(0,2) == 0)
					{
						attribs[0].Value = (long)(75+i);
						attribs[1].Value = (string)("my_string"+i.ToString());
						attribs[2].Value = Hexer.unhex("123456789");
						wc.WidgetAdd(QUERY_TITLE_ID,BitConverter.GetBytes(Convert.ToUInt64(562949953420287+i)),"webuser"+i.ToString(),null,5,attribs);
					}
					else
					{
						attribs[0].Value = (long)27;
						attribs[1].Value = (string)"strings to be removed dude! are they still here?";
						attribs[2].Value = Hexer.unhex("90283454");
						wc.WidgetAdd(QUERY_TITLE_ID,BitConverter.GetBytes(Convert.ToUInt64(562949953420287+i)),"webuser"+i.ToString(),null,5,attribs);
					}
					if (rnd.Next(0,2) == 0)
					{
						attribs[0].Value = (long)8;
						attribs[1].Value = (string)"REMOVE will get rid of this entry with procIndex 1";
						attribs[2].Value = Hexer.unhex("453405255");
						wc.WidgetAdd(QUERY_TITLE_ID,BitConverter.GetBytes(Convert.ToUInt64(562949953420287+i)),"webuser"+i.ToString(),null,5,attribs);
					}
					else
					{
						attribs[0].Value = (long)666666;
						attribs[1].Value = (string)"some string";
						attribs[2].Value = Hexer.unhex("9898");
						wc.WidgetAdd(QUERY_TITLE_ID,BitConverter.GetBytes(Convert.ToUInt64(562949953420287+i)),"webuser"+i.ToString(),null,5,attribs);
					}
				}
				attribs[0].Value = (long)56;
				attribs[1].Value = (string)"entry for gamertag 20 with decently long blob and a pretty small string compared to the max imposed on the string length in the XQS file that defines the dataset constraints";
				attribs[2].Value = Hexer.unhex("743502930580937859753450234012432057340975983740820375073498734075028309482037589473985734840932840723985749");
				wc.WidgetAdd(QUERY_TITLE_ID,BitConverter.GetBytes(Convert.ToUInt64(562949953420287+20)),"webuser20",null,5,attribs);
				attribs[0].Value = (long)83597;
				attribs[1].Value = (string)"only one entry has this string";
				attribs[2].Value = Hexer.unhex("9898");
				wc.WidgetAdd(QUERY_TITLE_ID,BitConverter.GetBytes(Convert.ToUInt64(562949953420287+18)),"webuser18",null,5,attribs);
				for (int i=0; i<195; i++)
				{
					attribs[0].Value = (long)(9*i);
					attribs[1].Value = (string)"testing the Search API with this as the string";
					attribs[2].Value = Hexer.unhex("5551818");
					wc.WidgetAdd(QUERY_TITLE_ID,BitConverter.GetBytes(Convert.ToUInt64(562949953420287+i)),"webuser"+i.ToString(),null,5,attribs);
				}
				for (int i=195; i<200; i++)
				{
					attribs[0].Value = (long)1024;
					attribs[1].Value = (string)"testing the Search API with this as the string";
					attribs[2].Value = Hexer.unhex("5551818");
					wc.WidgetAdd(QUERY_TITLE_ID,BitConverter.GetBytes(Convert.ToUInt64(562949953420287+i)),"webuser"+i.ToString(),null,5,attribs);
				}
				for (int i=200; i<248; i++)
				{
					attribs[0].Value = (long)4201;
					attribs[1].Value = (string)"entry in query test dataset";
					attribs[2].Value = Hexer.unhex("43215678");
					wc.WidgetAdd(QUERY_TITLE_ID,BitConverter.GetBytes(Convert.ToUInt64(562949953420287+i)),"webuser"+i.ToString(),null,5,attribs);
				}
				for (int i=248; i<322; i++)
				{
					attribs[0].Value = (long)i;
					attribs[1].Value = (string)"some other entries in query test dataset";
					attribs[2].Value = Hexer.unhex("5394782610");
					wc.WidgetAdd(QUERY_TITLE_ID,BitConverter.GetBytes(Convert.ToUInt64(562949953420287+i)),"webuser"+i.ToString(),null,5,attribs);
				}
				for (int i=322; i<350; i++)
				{
					attribs[0].Value = (long)852;
					attribs[1].Value = (string)"this string is used in Search with procIndex 4";
					attribs[2].Value = Hexer.unhex("32079023"+Convert.ToString(i));
					wc.WidgetAdd(QUERY_TITLE_ID,BitConverter.GetBytes(Convert.ToUInt64(562949953420287+i)),"webuser"+i.ToString(),null,5,attribs);
				}
			}
			catch (Exception e)
			{
				ConsoleX.WriteLine("Failed to fill Query dataset: "+e.Message);
			}
			System.Threading.Thread.Sleep(1000);
		}

		public static void FillDBGeneral()
		{
			FillDBDataSet5();

			if (GetNumRecords(QUERY_TITLE_ID,1) == 502)
				return;
			ClearDataSet(QUERY_TITLE_ID,1);

			// add entries to DB
			WCQuery wc = new WCQuery();
			QueryAttribute [] attribs = new QueryAttribute[3];
			for (int i=0; i<3; i++)
				attribs[i] = new QueryAttribute();
			attribs[0].Id = 1;
			attribs[1].Id = 1048579;
			attribs[2].Id = 2097157;

			try
			{
				System.Random rnd = new Random(DateTime.Now.Millisecond + DateTime.Now.Second);
				for (int i=500; i<550; i++)
				{
					if (rnd.Next(0,2) == 0)
					{
						attribs[0].Value = (long)5000;
						attribs[1].Value = (string)("my_string"+i.ToString());
						attribs[2].Value = Hexer.unhex("427379078");
						wc.WidgetAdd(QUERY_TITLE_ID,BitConverter.GetBytes(Convert.ToUInt64(562949953420287+i)),"webuser"+i.ToString(),"",1,attribs);
					}
					else
					{
						attribs[0].Value = (long)56;
						attribs[1].Value = (string)("my_string"+i.ToString());
						attribs[2].Value = Hexer.unhex("340124320573403750734989482037589473985734723");
						wc.WidgetAdd(QUERY_TITLE_ID,BitConverter.GetBytes(Convert.ToUInt64(562949953420287+i)),"webuser"+i.ToString(),null,1,attribs);
					}
					if (rnd.Next(0,2) == 0)
					{
						attribs[0].Value = (long)(75+i);
						attribs[1].Value = (string)("my_string"+i.ToString());
						attribs[2].Value = Hexer.unhex("123456789");
						wc.WidgetAdd(QUERY_TITLE_ID,BitConverter.GetBytes(Convert.ToUInt64(562949953420287+i)),"webuser"+i.ToString(),null,1,attribs);
					}
					else
					{
						attribs[0].Value = (long)27;
						attribs[1].Value = (string)"strings to be removed dude! are they still here?";
						attribs[2].Value = Hexer.unhex("90283454");
						wc.WidgetAdd(QUERY_TITLE_ID,BitConverter.GetBytes(Convert.ToUInt64(562949953420287+i)),"webuser"+i.ToString(),null,1,attribs);
					}
					if (rnd.Next(0,2) == 0)
					{
						attribs[0].Value = (long)8;
						attribs[1].Value = (string)"REMOVE will get rid of this entry with procIndex 1";
						attribs[2].Value = Hexer.unhex("453405255");
						wc.WidgetAdd(QUERY_TITLE_ID,BitConverter.GetBytes(Convert.ToUInt64(562949953420287+i)),"webuser"+i.ToString(),null,1,attribs);
					}
					else
					{
						attribs[0].Value = (long)666666;
						attribs[1].Value = (string)"some string";
						attribs[2].Value = Hexer.unhex("9898");
						wc.WidgetAdd(QUERY_TITLE_ID,BitConverter.GetBytes(Convert.ToUInt64(562949953420287+i)),"webuser"+i.ToString(),null,1,attribs);
					}
				}
				attribs[0].Value = (long)56;
				attribs[1].Value = (string)"entry for gamertag 20 with decently long blob and a pretty small string compared to the max imposed on the string length in the XQS file that defines the dataset constraints";
				attribs[2].Value = Hexer.unhex("743502930580937859753450234012432057340975983740820375073498734075028309482037589473985734840932840723985749");
				wc.WidgetAdd(QUERY_TITLE_ID,BitConverter.GetBytes(Convert.ToUInt64(562949953420287+20)),"webuser20",null,1,attribs);
				attribs[0].Value = (long)83597;
				attribs[1].Value = (string)"only one entry has this string";
				attribs[2].Value = Hexer.unhex("9898");
				wc.WidgetAdd(QUERY_TITLE_ID,BitConverter.GetBytes(Convert.ToUInt64(562949953420287+18)),"webuser18",null,1,attribs);
				for (int i=0; i<195; i++)
				{
					attribs[0].Value = (long)(9*i);
					attribs[1].Value = (string)"testing the Search API with this as the string";
					attribs[2].Value = Hexer.unhex("5551818");
					wc.WidgetAdd(QUERY_TITLE_ID,BitConverter.GetBytes(Convert.ToUInt64(562949953420287+i)),"webuser"+i.ToString(),null,1,attribs);
				}
				for (int i=195; i<200; i++)
				{
					attribs[0].Value = (long)1024;
					attribs[1].Value = (string)"testing the Search API with this as the string";
					attribs[2].Value = Hexer.unhex("5551818");
					wc.WidgetAdd(QUERY_TITLE_ID,BitConverter.GetBytes(Convert.ToUInt64(562949953420287+i)),"webuser"+i.ToString(),null,1,attribs);
				}
				for (int i=200; i<248; i++)
				{
					attribs[0].Value = (long)4201;
					attribs[1].Value = (string)"entry in query test dataset";
					attribs[2].Value = Hexer.unhex("43215678");
					wc.WidgetAdd(QUERY_TITLE_ID,BitConverter.GetBytes(Convert.ToUInt64(562949953420287+i)),"webuser"+i.ToString(),null,1,attribs);
				}
				for (int i=248; i<322; i++)
				{
					attribs[0].Value = (long)i;
					attribs[1].Value = (string)"some other entries in query test dataset";
					attribs[2].Value = Hexer.unhex("5394782610");
					wc.WidgetAdd(QUERY_TITLE_ID,BitConverter.GetBytes(Convert.ToUInt64(562949953420287+i)),"webuser"+i.ToString(),null,1,attribs);
				}
				for (int i=322; i<350; i++)
				{
					attribs[0].Value = (long)852;
					attribs[1].Value = (string)"this string is used in Search with procIndex 4";
					attribs[2].Value = Hexer.unhex("32079023"+Convert.ToString(i));
					wc.WidgetAdd(QUERY_TITLE_ID,BitConverter.GetBytes(Convert.ToUInt64(562949953420287+i)),"webuser"+i.ToString(),null,1,attribs);
				}
			}
			catch (Exception e)
			{
				ConsoleX.WriteLine("Failed to fill Query dataset: "+e.Message);
			}

			System.Threading.Thread.Sleep(1000);
		}

		public static void FillDBComps()
		{
			ClearCompData(COMPS_TITLE_ID,10);
			if (GetNumRecords(COMPS_TITLE_ID,1) >= 311)
				return;
			ConsoleX.WriteLine("Clearing comps dataset...this may take several minutes.");
			ClearCompData(COMPS_TITLE_ID,1);
			ConsoleX.WriteLine("Filling comps dataset...");

			// add entries to DB
			WCQuery wc = new WCQuery();
			QueryAttribute [] attribs = new QueryAttribute[18];
			for (int i=0; i<18; i++)
				attribs[i] = new QueryAttribute();
			attribs[0].Id = 0x80010001;		// reg open
			attribs[1].Id = 0x80010002;		// reg close
			attribs[2].Id = 0x80010003;		// comp start
			attribs[3].Id = 0x80010004;		// comp cleanup
			attribs[4].Id = 0x80010005;		// round frequency
			attribs[5].Id = 0x80010006;		// round interval
			attribs[6].Id = 0x80010007;		// round day mask
			attribs[7].Id = 0x8001000C;		// round one start
			attribs[8].Id = 0x8001000D;		// round one end
			attribs[9].Id = 0x80010010;		// is team comp
			attribs[10].Id = 0x80010011;	// team size
			attribs[11].Id = 0x80010012;	// max public slots
			attribs[12].Id = 0x80010013;	// max private slots
			attribs[13].Id = 0x80010014;	// min slots
			attribs[14].Id = 0x8001001A;	// reminder minutes
			attribs[15].Id = 0x00010001;	// map (int)
			attribs[16].Id = 0x00110002;	// name (string)
			attribs[17].Id = 0x00210003;	// icon (blob)

			// set values
			attribs[0].Value = DateTime.UtcNow.AddDays(1).AddMinutes(1).ToFileTimeUtc();
			attribs[1].Value = DateTime.UtcNow.AddDays(1).AddMinutes(5).ToFileTimeUtc();
			attribs[2].Value = DateTime.UtcNow.AddDays(1).AddMinutes(6).ToFileTimeUtc();
			attribs[7].Value = DateTime.UtcNow.AddDays(1).AddMinutes(15).ToFileTimeUtc();
			attribs[8].Value = DateTime.UtcNow.AddDays(1).AddMinutes(20).ToFileTimeUtc();

			attribs[3].Value = (long)1;
			attribs[4].Value = (long)1;
			attribs[5].Value = (long)3;
			attribs[6].Value = (long)0;
			attribs[9].Value = (long)0;
			attribs[10].Value = (long)0;
			attribs[11].Value = (long)10;
			attribs[12].Value = (long)10;
			attribs[13].Value = (long)4;
			attribs[14].Value = (long)5;

			System.Random rnd = new Random(DateTime.Now.Millisecond + DateTime.Now.Second);

			try
			{
				for (int i=500; i<550; i++)
				{
					// random entries to fill DB
					attribs[15].Value = (long)(i*rnd.Next(0,50));
					attribs[16].Value = (string)"random string"+i.ToString();
					attribs[17].Value = Hexer.unhex("9089723985728935027");
					wc.WidgetCompetitionCreate(COMPS_TITLE_ID,BitConverter.GetBytes(Convert.ToUInt64(562949953420287+i)),"webuser"+i.ToString(),"",1,attribs);

					attribs[15].Value = (long)899;
					attribs[16].Value = (string)"random string again "+i.ToString();
					attribs[17].Value = Hexer.unhex("9089723985728935027");
					wc.WidgetCompetitionCreate(COMPS_TITLE_ID,BitConverter.GetBytes(Convert.ToUInt64(562949953420287+i)),"webuser"+i.ToString(),"",1,attribs);
				}
				for (int i=500; i<700; i++)
				{
					// set values
					attribs[0].Value = DateTime.UtcNow.AddDays(1).AddMinutes(i+1).ToFileTimeUtc();
					attribs[1].Value = DateTime.UtcNow.AddDays(1).AddMinutes(i+5).ToFileTimeUtc();
					attribs[2].Value = DateTime.UtcNow.AddDays(1).AddMinutes(i+6).ToFileTimeUtc();
					attribs[7].Value = DateTime.UtcNow.AddDays(1).AddMinutes(i+15).ToFileTimeUtc();
					attribs[8].Value = DateTime.UtcNow.AddDays(1).AddMinutes(i+20).ToFileTimeUtc();

					// 200 entries for SEARCH with map = 98765
					attribs[15].Value = (long)98765;
					attribs[16].Value = (string)("name attribute"+i.ToString());
					attribs[17].Value = Hexer.unhex("897923");
					wc.WidgetCompetitionCreate(COMPS_TITLE_ID,BitConverter.GetBytes(Convert.ToUInt64(562949953420287+i)),"webuser"+i.ToString(),null,1,attribs);
				}
				for (int i=0; i<10; i++)
				{
					// set values
					attribs[0].Value = DateTime.UtcNow.AddDays(1).AddMinutes(i+1).ToFileTimeUtc();
					attribs[1].Value = DateTime.UtcNow.AddDays(1).AddMinutes(i+5).ToFileTimeUtc();
					attribs[2].Value = DateTime.UtcNow.AddDays(1).AddMinutes(i+6).ToFileTimeUtc();
					attribs[7].Value = DateTime.UtcNow.AddDays(1).AddMinutes(i+15).ToFileTimeUtc();
					attribs[8].Value = DateTime.UtcNow.AddDays(1).AddMinutes(i+20).ToFileTimeUtc();

					// 10 entries for SEARCH with user20 & string "string for searching with alternate proc"
					attribs[15].Value = (long)(i+99);
					attribs[16].Value = (string)"string for searching with alternate proc";
					attribs[17].Value = Hexer.unhex("152305827947592348108909732523");
					wc.WidgetCompetitionCreate(COMPS_TITLE_ID,BitConverter.GetBytes(Convert.ToUInt64(562949953420287+20)),"webuser20",null,1,attribs);
				}
				// set values
				attribs[0].Value = DateTime.UtcNow.AddDays(1).AddMinutes(1).ToFileTimeUtc();
				attribs[1].Value = DateTime.UtcNow.AddDays(1).AddMinutes(5).ToFileTimeUtc();
				attribs[2].Value = DateTime.UtcNow.AddDays(1).AddMinutes(6).ToFileTimeUtc();
				attribs[7].Value = DateTime.UtcNow.AddDays(1).AddMinutes(15).ToFileTimeUtc();
				attribs[8].Value = DateTime.UtcNow.AddDays(1).AddMinutes(20).ToFileTimeUtc();

				// unique entry for SEARCH with map = 404
				attribs[15].Value = (long)404;
				attribs[16].Value = (string)"a fairly long string added to the dataset with unique map value of 404 to test SEARCH api";
				attribs[17].Value = Hexer.unhex("897923");
				wc.WidgetCompetitionCreate(COMPS_TITLE_ID,BitConverter.GetBytes(Convert.ToUInt64(562949953420287+7)),"webuser7",null,1,attribs);
			}
			catch (Exception e)
			{
				ConsoleX.WriteLine("Failed to fill Comps dataset: " + e.Message);
			}

			System.Threading.Thread.Sleep(2000);
			ConsoleX.WriteLine("Starting test.");
		}

		public static void FillDBBasedOnAPI(uint api, uint param)
		{
			// look up team ID if not already known
			if (0 == QUERY_TEAMID)
				QUERY_TEAMID = GetTeamId(QUERY_TEAMNAME,QUERY_TITLE_ID);
			if (0 == COMPS_TEAMID)
				COMPS_TEAMID = GetTeamId(COMPS_TEAMNAME,COMPS_TITLE_ID);

			WCQuery wc = new WCQuery();
			RequestInfo rInfo = new RequestInfo("DebugAdmin");
			WCQuery wcPartner = new WCQuery(Global.XEnv.GetVirtualInterface(VirtualInterface.wcquery),rInfo);
			QueryAttribute [] attribs;
			SqlCommand mySqlCommand = null;
			SqlDataReader myDataReader = null;
			string sql = null;
			int iNPSql = 0;

			for (int iSql=0; iSql<qrySqlConn.Length; iSql++)
			{
				try
				{
					try
					{
						// remove entries from dataset 10 (QUERY)
						sql="DELETE FROM [QueryDB].[dbo].[t_query_dataset_"+Hexer.tohex(QUERY_TITLE_ID)+"_a] WHERE bi_owner_id = "+QUERY_TITLE_ID;
						mySqlCommand = new SqlCommand(sql,qrySqlConn[iSql]);
						myDataReader = mySqlCommand.ExecuteReader();
					}
					catch (Exception e)
					{
						ConsoleX.WriteLine("Failed to remove entries from QUERY dataset 5: " + e.Message);
						if (qrySqlConn[iSql].State != ConnectionState.Open)
							qrySqlConn[iSql].Open();
					}

					if (myDataReader != null && !myDataReader.IsClosed)
						myDataReader.Close();
					try
					{
						// remove entries for team from QUERY dataset
						sql="DELETE FROM [QueryDB].[dbo].[t_query_dataset_"+Hexer.tohex(QUERY_TITLE_ID)+"_"+QUERY_DATASET_ID.ToString("x")+"] WHERE bi_owner_id = "+QUERY_TEAMID;
						mySqlCommand = new SqlCommand(sql,qrySqlConn[iSql]);
						myDataReader = mySqlCommand.ExecuteReader();
					}
					catch (Exception e)
					{
						ConsoleX.WriteLine("Failed to remove entries from QUERY for team: " + e.Message);
						if (qrySqlConn[iSql].State != ConnectionState.Open)
							qrySqlConn[iSql].Open();
					}

					if (myDataReader != null && !myDataReader.IsClosed)
						myDataReader.Close();
					try
					{
						// remove entries for webuser given by xml file from QUERY dataset
						sql="DELETE FROM [QueryDB].[dbo].[t_query_dataset_"+Hexer.tohex(QUERY_TITLE_ID)+"_"+QUERY_DATASET_ID.ToString("x")+"] WHERE bi_owner_id = "+Convert.ToString(2814749767106559 - Convert.ToInt32(QUERY_GAMERTAG.Substring(7)));
						mySqlCommand = new SqlCommand(sql,qrySqlConn[iSql]);
						myDataReader = mySqlCommand.ExecuteReader();
					}
					catch (Exception e)
					{
						ConsoleX.WriteLine("Failed to remove entries from QUERY for "+QUERY_GAMERTAG+": " + e.Message);
						if (qrySqlConn[iSql].State != ConnectionState.Open)
							qrySqlConn[iSql].Open();
					}

					if (myDataReader != null && !myDataReader.IsClosed)
						myDataReader.Close();
					try
					{
						// remove entry for user 20 from QUERY dataset
						sql="DELETE FROM [QueryDB].[dbo].[t_query_dataset_"+Hexer.tohex(QUERY_TITLE_ID)+"_"+QUERY_DATASET_ID.ToString("x")+"] WHERE bi_owner_id = "+Convert.ToString(2814749767106559 - 20)+" AND att_00000001=27";
						mySqlCommand = new SqlCommand(sql,qrySqlConn[iSql]);
						myDataReader = mySqlCommand.ExecuteReader();
					}
					catch (Exception e)
					{
						ConsoleX.WriteLine("Failed to remove entries from QUERY for webuser20: " + e.Message);
						if (qrySqlConn[iSql].State != ConnectionState.Open)
							qrySqlConn[iSql].Open();
					}

					if (myDataReader != null && !myDataReader.IsClosed)
						myDataReader.Close();
					try
					{
						// remove entry for partner from QUERY dataset
						sql="DELETE FROM [QueryDB].[dbo].[t_query_dataset_"+Hexer.tohex(QUERY_TITLE_ID)+"_"+QUERY_DATASET_ID.ToString("x")+"] WHERE bi_owner_id = "+QUERY_TITLE_ID;
						mySqlCommand = new SqlCommand(sql,qrySqlConn[iSql]);
						myDataReader = mySqlCommand.ExecuteReader();
					}
					catch (Exception e)
					{
						ConsoleX.WriteLine("Failed to remove entries from QUERY for partner: " + e.Message);
						if (qrySqlConn[iSql].State != ConnectionState.Open)
							qrySqlConn[iSql].Open();
					}

					// remove entries for partner from COMPS dataset
					if (myDataReader != null && !myDataReader.IsClosed)
						myDataReader.Close();
					try
					{
						sql="SELECT bi_entity_id FROM [QueryDB].[dbo].[t_query_dataset_"+Hexer.tohex(COMPS_TITLE_ID)+"_"+COMPS_DATASET_ID.ToString("x")+"] WHERE att_8001001d <> 1 AND att_8001001d <> 2 AND att_00110002 like '%partner%'";
						mySqlCommand = new SqlCommand(sql,qrySqlConn[iSql]);
						myDataReader = mySqlCommand.ExecuteReader();

						ArrayList alCompIds = new ArrayList();

						while (myDataReader.Read() != false)
							alCompIds.Add((UInt64)myDataReader.GetInt64(0));

						if (myDataReader != null && !myDataReader.IsClosed)
							myDataReader.Close();

						foreach (UInt64 compId in alCompIds)
						{
							SqlCommand comm = null;
							for (iNPSql=0; iNPSql<npdbSqlConn.Length; iNPSql++)
							{
								// delete the competition from CRON JOBS
								comm = new SqlCommand("DELETE FROM t_cron_jobs where vc_name like '%0x"+compId.ToString("X")+"%'",npdbSqlConn[iNPSql]);
								comm.ExecuteNonQuery();
							}

							// delete the competition from querydb
							comm = new SqlCommand("DELETE FROM [QueryDB].[dbo].[t_query_dataset_"+Hexer.tohex(COMPS_TITLE_ID)+"_"+COMPS_DATASET_ID.ToString("x")+"] WHERE bi_entity_id = "+compId,qrySqlConn[iSql]);
							comm.ExecuteNonQuery();
						}
					}
					catch (Exception e)
					{
						if (!e.Message.EndsWith("does not exist in the dataset specified."))
							ConsoleX.WriteLine("Failed to remove from COMPS for partner: " + e.Message);
						if (qrySqlConn[iSql].State != ConnectionState.Open)
							qrySqlConn[iSql].Open();
						if (npdbSqlConn[iNPSql].State != ConnectionState.Open)
							npdbSqlConn[iNPSql].Open();
					}

					// remove entries for team from COMPS dataset
					if (myDataReader != null && !myDataReader.IsClosed)
						myDataReader.Close();
					try
					{
						sql="SELECT bi_entity_id, att_80010003 FROM [QueryDB].[dbo].[t_query_dataset_"+Hexer.tohex(COMPS_TITLE_ID)+"_"+COMPS_DATASET_ID.ToString("x")+"] WHERE att_8001001d <> 1 AND att_8001001d <> 2 AND bi_owner_id = "+QueryWidgetCommon.COMPS_TEAMID;
						mySqlCommand = new SqlCommand(sql,qrySqlConn[iSql]);
						myDataReader = mySqlCommand.ExecuteReader();

						ArrayList alCompIds = new ArrayList();

						while (myDataReader.Read() != false)
							alCompIds.Add((UInt64)myDataReader.GetInt64(0));

						if (myDataReader != null && !myDataReader.IsClosed)
							myDataReader.Close();

						foreach (UInt64 compId in alCompIds)
						{
							SqlCommand comm = null;
							for (iNPSql=0; iNPSql<npdbSqlConn.Length; iNPSql++)
							{
								// delete the competition from CRON JOBS
								comm = new SqlCommand("DELETE FROM t_cron_jobs where vc_name like '%0x"+compId.ToString("X")+"%'",npdbSqlConn[iNPSql]);
								comm.ExecuteNonQuery();
							}

							// delete the competition from querydb
							comm = new SqlCommand("DELETE FROM [QueryDB].[dbo].[t_query_dataset_"+Hexer.tohex(COMPS_TITLE_ID)+"_"+COMPS_DATASET_ID.ToString("x")+"] WHERE bi_entity_id = "+compId,qrySqlConn[iSql]);
							comm.ExecuteNonQuery();
						}
					}
					catch (Exception e)
					{
						if (!e.Message.EndsWith("does not exist in the dataset specified."))
							ConsoleX.WriteLine("Failed to remove from COMPS for team: " + e.Message);
						if (qrySqlConn[iSql].State != ConnectionState.Open)
							qrySqlConn[iSql].Open();
						if (npdbSqlConn[iNPSql].State != ConnectionState.Open)
							npdbSqlConn[iNPSql].Open();
					}

					// remove entries for team from COMPS dataset with datasetId = 10
					if (myDataReader != null && !myDataReader.IsClosed)
						myDataReader.Close();
					try
					{
						sql="SELECT bi_entity_id, att_80010003 FROM [QueryDB].[dbo].[t_query_dataset_"+Hexer.tohex(COMPS_TITLE_ID)+"_a] WHERE att_8001001d <> 1 AND att_8001001d <> 2 AND bi_owner_id = "+QueryWidgetCommon.COMPS_TEAMID;
						mySqlCommand = new SqlCommand(sql,qrySqlConn[iSql]);
						myDataReader = mySqlCommand.ExecuteReader();

						ArrayList alCompIds = new ArrayList();

						while (myDataReader.Read() != false)
							alCompIds.Add((UInt64)myDataReader.GetInt64(0));

						if (myDataReader != null && !myDataReader.IsClosed)
							myDataReader.Close();

						foreach (UInt64 compId in alCompIds)
						{
							SqlCommand comm = null;
							for (iNPSql=0; iNPSql<npdbSqlConn.Length; iNPSql++)
							{
								// delete the competition from CRON JOBS
								comm = new SqlCommand("DELETE FROM t_cron_jobs where vc_name like '%0x"+compId.ToString("X")+"%'",npdbSqlConn[iNPSql]);
								comm.ExecuteNonQuery();
							}

							// delete the competition from querydb
							comm = new SqlCommand("DELETE FROM [QueryDB].[dbo].[t_query_dataset_"+Hexer.tohex(COMPS_TITLE_ID)+"_"+COMPS_DATASET_ID.ToString("x")+"] WHERE bi_entity_id = "+compId,qrySqlConn[iSql]);
							comm.ExecuteNonQuery();
						}
					}
					catch (Exception e)
					{
						if (!e.Message.EndsWith("does not exist in the dataset specified."))
							ConsoleX.WriteLine("Failed to remove from COMPS for team: " + e.Message);
						if (qrySqlConn[iSql].State != ConnectionState.Open)
							qrySqlConn[iSql].Open();
						if (npdbSqlConn[iNPSql].State != ConnectionState.Open)
							npdbSqlConn[iNPSql].Open();
					}

					// remove entries for webuser defined in xml file from COMPS dataset
					if (myDataReader != null && !myDataReader.IsClosed)
						myDataReader.Close();
					try
					{
						sql="SELECT bi_entity_id, att_80010003 FROM [QueryDB].[dbo].[t_query_dataset_"+Hexer.tohex(COMPS_TITLE_ID)+"_"+COMPS_DATASET_ID.ToString("x")+"] WHERE att_8001001d <> 1 AND att_8001001d <> 2 AND bi_owner_id = "+Convert.ToString(2814749767106559 - Convert.ToInt32(COMPS_GAMERTAG.Substring(7)));
						mySqlCommand = new SqlCommand(sql,qrySqlConn[iSql]);
						myDataReader = mySqlCommand.ExecuteReader();

						ArrayList alCompIds = new ArrayList();

						while (myDataReader.Read() != false)
							alCompIds.Add((UInt64)myDataReader.GetInt64(0));

						if (myDataReader != null && !myDataReader.IsClosed)
							myDataReader.Close();

						foreach (UInt64 compId in alCompIds)
						{
							SqlCommand comm = null;
							for (iNPSql=0; iNPSql<npdbSqlConn.Length; iNPSql++)
							{
								// delete the competition from CRON JOBS
								comm = new SqlCommand("DELETE FROM t_cron_jobs where vc_name like '%0x"+compId.ToString("X")+"%'",npdbSqlConn[iNPSql]);
								comm.ExecuteNonQuery();
							}

							// delete the competition from querydb
							comm = new SqlCommand("DELETE FROM [QueryDB].[dbo].[t_query_dataset_"+Hexer.tohex(COMPS_TITLE_ID)+"_"+COMPS_DATASET_ID.ToString("x")+"] WHERE bi_entity_id = "+compId,qrySqlConn[iSql]);
							comm.ExecuteNonQuery();
						}
					}
					catch (Exception e)
					{
						if (!e.Message.EndsWith("does not exist in the dataset specified."))
							ConsoleX.WriteLine("Failed to remove from COMPS for "+COMPS_GAMERTAG+": " + e.Message);
						if (qrySqlConn[iSql].State != ConnectionState.Open)
							qrySqlConn[iSql].Open();
						if (npdbSqlConn[iNPSql].State != ConnectionState.Open)
							npdbSqlConn[iNPSql].Open();
					}

					// remove entries for webuser defined by xml file from COMPS dataset where datasetId = 10
					if (myDataReader != null && !myDataReader.IsClosed)
						myDataReader.Close();
					try
					{
						sql="SELECT bi_entity_id, att_80010003 FROM [QueryDB].[dbo].[t_query_dataset_"+Hexer.tohex(COMPS_TITLE_ID)+"_a] WHERE att_8001001d <> 1 AND att_8001001d <> 2 AND bi_owner_id = "+Convert.ToString(2814749767106559 - Convert.ToInt32(COMPS_GAMERTAG.Substring(7)));
						mySqlCommand = new SqlCommand(sql,qrySqlConn[iSql]);
						myDataReader = mySqlCommand.ExecuteReader();

						ArrayList alCompIds = new ArrayList();

						while (myDataReader.Read() != false)
							alCompIds.Add((UInt64)myDataReader.GetInt64(0));

						if (myDataReader != null && !myDataReader.IsClosed)
							myDataReader.Close();

						foreach (UInt64 compId in alCompIds)
						{
							SqlCommand comm = null;
							for (iNPSql=0; iNPSql<npdbSqlConn.Length; iNPSql++)
							{
								// delete the competition from CRON JOBS
								comm = new SqlCommand("DELETE FROM t_cron_jobs where vc_name like '%0x"+compId.ToString("X")+"%'",npdbSqlConn[iNPSql]);
								comm.ExecuteNonQuery();
							}

							// delete the competition from querydb
							comm = new SqlCommand("DELETE FROM [QueryDB].[dbo].[t_query_dataset_"+Hexer.tohex(COMPS_TITLE_ID)+"_"+COMPS_DATASET_ID.ToString("x")+"] WHERE bi_entity_id = "+compId,qrySqlConn[iSql]);
							comm.ExecuteNonQuery();
						}
					}
					catch (Exception e)
					{
						if (!e.Message.EndsWith("does not exist in the dataset specified."))
							ConsoleX.WriteLine("Failed to remove from COMPS for "+COMPS_GAMERTAG+": " + e.Message);
						if (qrySqlConn[iSql].State != ConnectionState.Open)
							qrySqlConn[iSql].Open();
						if (npdbSqlConn[iNPSql].State != ConnectionState.Open)
							npdbSqlConn[iNPSql].Open();
					}
				}
				catch (Exception e)
				{
					ConsoleX.WriteLine("Failed to remove entries in FillDBBasedOnAPI: " + e.Message);
					if (qrySqlConn[iSql].State != ConnectionState.Open)
						qrySqlConn[iSql].Open();
					if (npdbSqlConn[iNPSql].State != ConnectionState.Open)
						npdbSqlConn[iNPSql].Open();
				}
				finally
				{
					// end SQL session
					if (myDataReader != null && !myDataReader.IsClosed)
						myDataReader.Close();
				}
			}

			if (api < 8)
			{
				// fill DB if not correct # entries remaining
				FillDBGeneral();		// not comps testing

				attribs = new QueryAttribute[3];
				for (int i=0; i<3; i++)
					attribs[i] = new QueryAttribute();
				attribs[0].Id = 0x00000001;
				attribs[1].Id = 0x00100003;
				attribs[2].Id = 0x00200005;
			}
			else
			{
				// fill DB if not correct # entries remaining
				FillDBComps();			// comps testing

				attribs = new QueryAttribute[18];
				for (int i=0; i<18; i++)
					attribs[i] = new QueryAttribute();
				attribs[0].Id = 0x80010001;		// reg open
				attribs[1].Id = 0x80010002;		// reg close
				attribs[2].Id = 0x80010003;		// comp start
				attribs[3].Id = 0x80010004;		// comp cleanup
				attribs[4].Id = 0x80010005;		// round frequency
				attribs[5].Id = 0x80010006;		// round interval
				attribs[6].Id = 0x80010007;		// round day mask
				attribs[7].Id = 0x8001000C;		// round one start
				attribs[8].Id = 0x8001000D;		// round one end
				attribs[9].Id = 0x80010010;		// is team comp
				attribs[10].Id = 0x80010011;	// team size
				attribs[11].Id = 0x80010012;	// max public slots
				attribs[12].Id = 0x80010013;	// max private slots
				attribs[13].Id = 0x80010014;	// min slots
				attribs[14].Id = 0x8001001A;	// reminder minutes
				attribs[15].Id = 0x00010001;	// map (int)
				attribs[16].Id = 0x00110002;	// name (string)
				attribs[17].Id = 0x00210003;	// icon (blob)

				// set values
				attribs[0].Value = DateTime.UtcNow.AddMinutes(1).ToFileTimeUtc();
				attribs[1].Value = DateTime.UtcNow.AddMinutes(5).ToFileTimeUtc();
				attribs[2].Value = DateTime.UtcNow.AddMinutes(6).ToFileTimeUtc();
				attribs[7].Value = DateTime.UtcNow.AddMinutes(7).ToFileTimeUtc();
				attribs[8].Value = DateTime.UtcNow.AddMinutes(8).ToFileTimeUtc();

				attribs[3].Value = (long)1;
				attribs[4].Value = (long)3;	// choose 3 for frequency
				attribs[5].Value = (long)2;	// choose minutes for interval
				attribs[6].Value = (long)0;
				attribs[9].Value = (long)0;
				attribs[10].Value = (long)0;
				attribs[11].Value = (long)20;
				attribs[12].Value = (long)20;
				attribs[13].Value = (long)4;
				attribs[14].Value = (long)0;
			}

			// add entries to DB based on api
			try
			{
				switch (api)
				{
					case 0:		// add
						break;
					case 1:		// update
						for (int i=0; i<2; i++)
						{
							if (param == 0)
							{
								attribs[0].Value = (long)56;
								attribs[1].Value = (string)("my_string"+i.ToString());
								attribs[2].Value = Hexer.unhex("340124320573403750734989482037589473985734723");
							}
							else if (param == 1)
							{
								attribs[0].Value = (long)(75+i);
								attribs[1].Value = (string)("my_string"+i.ToString());
								attribs[2].Value = Hexer.unhex("123456789");
							}
							else
							{
								attribs[0].Value = (long)99;
								attribs[1].Value = (string)("partner query"+i.ToString());
								attribs[2].Value = Hexer.unhex("4321");
								wcPartner.WidgetAdd(QUERY_TITLE_ID,BitConverter.GetBytes(QUERY_TITLE_ID),null,null,1,attribs);
								continue;
							}
							wc.WidgetAdd(QUERY_TITLE_ID,QUERY_WEBID,QUERY_GAMERTAG,null,1,attribs);
							wc.WidgetAdd(QUERY_TITLE_ID,QUERY_WEBID,QUERY_GAMERTAG,QUERY_TEAMNAME,1,attribs);
						}
						if (param == 1)
						{
							attribs[0].Value = (long)5000;
							attribs[1].Value = (string)("my_stringXX");
							attribs[2].Value = Hexer.unhex("496");
							wc.WidgetAdd(QUERY_TITLE_ID,QUERY_WEBID,QUERY_GAMERTAG,"",1,attribs);
							wc.WidgetAdd(QUERY_TITLE_ID,QUERY_WEBID,QUERY_GAMERTAG,QUERY_TEAMNAME,1,attribs);
						}
						else if (param == 0)
						{
							attribs[0].Value = (long)70;
							attribs[1].Value = (string)("my_string8");
							attribs[2].Value = Hexer.unhex("34012432057340375073498948");
							wc.WidgetAdd(QUERY_TITLE_ID,QUERY_WEBID,QUERY_GAMERTAG,"",1,attribs);
							wc.WidgetAdd(QUERY_TITLE_ID,QUERY_WEBID,QUERY_GAMERTAG,QUERY_TEAMNAME,1,attribs);
						}
						else
						{
							attribs[0].Value = (long)20;
							attribs[1].Value = (string)("partner another query");
							attribs[2].Value = Hexer.unhex("BAABAA");
							wcPartner.WidgetAdd(QUERY_TITLE_ID,BitConverter.GetBytes(QUERY_TITLE_ID),null,null,1,attribs);
						}
						System.Threading.Thread.Sleep(2000);
						break;
					case 2:		// updateid
						break;
					case 3:		// remove
						for (int i=0; i<2; i++)
						{
							if (param == 0)
							{
								attribs[0].Value = (long)27;
								attribs[1].Value = (string)"strings to be removed dude! are they still here?";
								attribs[2].Value = Hexer.unhex("90283454");
							}
							else if (param == 1)
							{
								attribs[0].Value = (long)8;
								attribs[1].Value = (string)"REMOVE will get rid of this entry with procIndex 1";
								attribs[2].Value = Hexer.unhex("453405255");
							}
							else if (param == 2)
							{
								attribs[0].Value = (long)666666;
								attribs[1].Value = (string)"more strings to remove";
								attribs[2].Value = Hexer.unhex("90283454"+i.ToString());
							}
							else
							{
								attribs[0].Value = (long)8;
								attribs[1].Value = (string)("partner query"+i.ToString());
								attribs[2].Value = Hexer.unhex("DEF");
								wcPartner.WidgetAdd(QUERY_TITLE_ID,BitConverter.GetBytes(QUERY_TITLE_ID),null,null,1,attribs);
								continue;
							}
							wc.WidgetAdd(QUERY_TITLE_ID,QUERY_WEBID,QUERY_GAMERTAG,null,1,attribs);
							wc.WidgetAdd(QUERY_TITLE_ID,QUERY_WEBID,QUERY_GAMERTAG,QUERY_TEAMNAME,1,attribs);
						}
						attribs[0].Value = (long)70;
						attribs[1].Value = (string)"this entry shouldn't be removed";
						attribs[2].Value = Hexer.unhex("90283454");
						wc.WidgetAdd(QUERY_TITLE_ID,QUERY_WEBID,QUERY_GAMERTAG,null,1,attribs);
						wc.WidgetAdd(QUERY_TITLE_ID,QUERY_WEBID,QUERY_GAMERTAG,QUERY_TEAMNAME,1,attribs);
						attribs[0].Value = (long)27;
						attribs[1].Value = (string)"entry for Remove that will match single because webuser20 has only one entry with correct attribs";
						attribs[2].Value = Hexer.unhex("90283454");
						wc.WidgetAdd(QUERY_TITLE_ID,BitConverter.GetBytes(Convert.ToUInt64(562949953420287+20)),"webuser20",null,1,attribs);
						System.Threading.Thread.Sleep(2000);
						break;
					case 4:		// removeid
						break;
					case 5:		// search
						break;
					case 6:		// findfromids
						break;
					case 7:		// getxqsconfig
						break;
					case 8:		// select
						attribs[0].Value = DateTime.UtcNow.ToFileTimeUtc();		// set reg open to now
						attribs[15].Value = (long)77000;
						attribs[16].Value = (string)"added string for Select API testing";
						attribs[17].Value = Hexer.unhex("987654321");
						wc.WidgetCompetitionCreate(COMPS_TITLE_ID,COMPS_WEBID,COMPS_GAMERTAG,null,1,attribs);
						attribs[9].Value = (long)1;
						attribs[10].Value = (long)4;
						wc.WidgetCompetitionCreate(COMPS_TITLE_ID,COMPS_WEBID,COMPS_GAMERTAG,COMPS_TEAMNAME,1,attribs);

						System.Threading.Thread.Sleep(2000);
						break;
					case 9:		// compcreate
						break;
					case 10:	// compcreatesingleelimination
						break;
					case 11:	// compcancel
						attribs[15].Value = (long)88888888;
						attribs[16].Value = (string)"added for CompCancel API testing";
						attribs[17].Value = Hexer.unhex("2436509345682385038905278352");
						wc.WidgetCompetitionCreate(COMPS_TITLE_ID,COMPS_WEBID,COMPS_GAMERTAG,null,1,attribs);
						attribs[9].Value = (long)1;
						attribs[10].Value = (long)4;
						wc.WidgetCompetitionCreate(COMPS_TITLE_ID,COMPS_WEBID,COMPS_GAMERTAG,COMPS_TEAMNAME,1,attribs);

						System.Threading.Thread.Sleep(2000);
						break;
					case 12:	// compsearch
						break;
					case 13:	// compmanage
						attribs[0].Value = DateTime.UtcNow.ToFileTimeUtc();		// set reg open to now
						attribs[15].Value = (long)77000;
						attribs[16].Value = (string)"added string for Select API testing";
						attribs[17].Value = Hexer.unhex("987654321");
						wc.WidgetCompetitionCreate(COMPS_TITLE_ID,COMPS_WEBID,COMPS_GAMERTAG,null,1,attribs);
						attribs[9].Value = (long)1;
						attribs[10].Value = (long)4;
						wc.WidgetCompetitionCreate(COMPS_TITLE_ID,COMPS_WEBID,COMPS_GAMERTAG,COMPS_TEAMNAME,1,attribs);

						System.Threading.Thread.Sleep(2000);
						break;
					case 14:	// comptopology
						if (0 != param)	// don't want topology created so just create comp for future date
						{
							attribs[0].Value = DateTime.UtcNow.ToFileTimeUtc();		// set reg open to now
							attribs[2].Value = DateTime.UtcNow.AddDays(1).AddMinutes(1).ToFileTimeUtc();
							attribs[7].Value = DateTime.UtcNow.AddDays(1).AddMinutes(2).ToFileTimeUtc();
							attribs[8].Value = DateTime.UtcNow.AddDays(1).AddMinutes(3).ToFileTimeUtc();
							attribs[15].Value = (long)77000;
							attribs[16].Value = (string)"added for CompTopology API testing";
							attribs[17].Value = Hexer.unhex("2436509305278331509743897293854020987979823732759872349732987524325");
							wc.WidgetCompetitionCreate(COMPS_TITLE_ID,COMPS_WEBID,COMPS_GAMERTAG,null,1,attribs);

							Thread.Sleep(2000);
							break;
						}

						QueryAttribute [] searchAttribs = new QueryAttribute[3];
						for (int i=0; i<3; i++)
							searchAttribs[i] = new QueryAttribute();
						searchAttribs[0].Id = 0x82000001;
						searchAttribs[0].Value = (long)2814749767105536;
						searchAttribs[1].Id = 0x8201001D;
						searchAttribs[1].Value = (long)1;	// want topology created
						searchAttribs[2].Id = 0x02110002;
						searchAttribs[2].Value = (string)"added for CompTopology API testing";

						XmlDocument parameters = new XmlDocument();
						parameters.Load("QueryWidget.xml");
						XmlNodeList paramNodes = parameters.SelectNodes("/stf/competitions/search/specs");
						if (paramNodes.Count == 0)
							throw new Exception();
						QueryAttributeSpec [] searchSpecs = new QueryAttributeSpec[paramNodes[0].ChildNodes.Count];
						for (int i=0; i<paramNodes[0].ChildNodes.Count; i++)
						{
							if (paramNodes[0].ChildNodes[i].Name != "attrib")
								throw new Exception();

							searchSpecs[i] = new QueryAttributeSpec();

							searchSpecs[i].len = Convert.ToUInt32(paramNodes[0].ChildNodes[i].Attributes["s_len"].Value);
							searchSpecs[i].type = System.UInt32.Parse(paramNodes[0].ChildNodes[i].Attributes["s_type"].Value,System.Globalization.NumberStyles.AllowHexSpecifier);
						}

						SearchResponse result = wc.WidgetCompetitionSearch(COMPS_TITLE_ID,1,0x2,0,1,searchSpecs,searchAttribs);
						if (0 == result.totalResults)
						{
							attribs[0].Value = DateTime.UtcNow.ToFileTimeUtc();		// set reg open to now
							attribs[15].Value = (long)77000;
							attribs[16].Value = (string)"added for CompTopology API testing";
							attribs[17].Value = Hexer.unhex("2436509305278331509743897293854020987979823732759872349732987524325");
							UInt64 compId = wc.WidgetCompetitionCreate(COMPS_TITLE_ID,COMPS_WEBID,COMPS_GAMERTAG,null,1,attribs);

							// join 16 entrants
							for (int i=0; i<16; i++)
								wc.WidgetCompetitionManageEntrant(COMPS_TITLE_ID,BitConverter.GetBytes(Convert.ToUInt64(562949953420287+i)),"webuser"+i.ToString(),1,null,1,compId,null);

							// advance to comp start
							QueryAttribute[] selAttribs = new QueryAttribute[1];
							selAttribs[0] = new QueryAttribute();
							selAttribs[0].Id = 0x80010023;
							selAttribs[0].Value = (long)60*6;	// advance 6 minutes
							wc.WidgetSelect(COMPS_TITLE_ID, BitConverter.GetBytes(Convert.ToUInt64(562949953420287)), "webuser0", null, 1, compId, 99, selAttribs);

							// wait for slotting and move past region where verify will realize new comp was added
							Thread.Sleep(2000);
						}
						break;
					case 15:	// comptopologysingleelimination
						if (0 != param)	// don't want topology created so just create comp for future date
						{
							attribs[0].Value = DateTime.UtcNow.ToFileTimeUtc();		// set reg open to now
							attribs[2].Value = DateTime.UtcNow.AddDays(1).AddMinutes(1).ToFileTimeUtc();
							attribs[7].Value = DateTime.UtcNow.AddDays(1).AddMinutes(2).ToFileTimeUtc();
							attribs[8].Value = DateTime.UtcNow.AddDays(1).AddMinutes(3).ToFileTimeUtc();
							attribs[15].Value = (long)77000;
							attribs[16].Value = (string)"added for CompTopology API testing";
							attribs[17].Value = Hexer.unhex("2436509305278331509743897293854020987979823732759872349732987524325");
							wc.WidgetCompetitionCreate(COMPS_TITLE_ID,COMPS_WEBID,COMPS_GAMERTAG,null,1,attribs);

							Thread.Sleep(2000);
							break;
						}

						searchAttribs = new QueryAttribute[3];
						for (int i=0; i<3; i++)
							searchAttribs[i] = new QueryAttribute();
						searchAttribs[0].Id = 0x82000001;
						searchAttribs[0].Value = (long)2814749767105536;
						searchAttribs[1].Id = 0x8201001D;
						searchAttribs[1].Value = (long)1;	// want topology created
						searchAttribs[2].Id = 0x02110002;
						searchAttribs[2].Value = (string)"added for CompTopology API testing";

						parameters = new XmlDocument();
						parameters.Load("QueryWidget.xml");
						paramNodes = parameters.SelectNodes("/stf/competitions/search/specs");
						if (paramNodes.Count == 0)
							throw new Exception();
						searchSpecs = new QueryAttributeSpec[paramNodes[0].ChildNodes.Count];
						for (int i=0; i<paramNodes[0].ChildNodes.Count; i++)
						{
							if (paramNodes[0].ChildNodes[i].Name != "attrib")
								throw new Exception();

							searchSpecs[i] = new QueryAttributeSpec();

							searchSpecs[i].len = Convert.ToUInt32(paramNodes[0].ChildNodes[i].Attributes["s_len"].Value);
							searchSpecs[i].type = System.UInt32.Parse(paramNodes[0].ChildNodes[i].Attributes["s_type"].Value,System.Globalization.NumberStyles.AllowHexSpecifier);
						}

						result = wc.WidgetCompetitionSearch(COMPS_TITLE_ID,1,0x2,0,1,searchSpecs,searchAttribs);
						if (0 == result.totalResults)
						{
							attribs[0].Value = DateTime.UtcNow.ToFileTimeUtc();		// set reg open to now
							attribs[15].Value = (long)77000;
							attribs[16].Value = (string)"added for CompTopology API testing";
							attribs[17].Value = Hexer.unhex("2436509305278331509743897293854020987979823732759872349732987524325");
							UInt64 compId = wc.WidgetCompetitionCreate(COMPS_TITLE_ID,COMPS_WEBID,COMPS_GAMERTAG,null,1,attribs);

							// join 16 entrants
							for (int i=0; i<16; i++)
								wc.WidgetCompetitionManageEntrant(COMPS_TITLE_ID,BitConverter.GetBytes(Convert.ToUInt64(562949953420287+i)),"webuser"+i.ToString(),1,null,1,compId,null);

							// advance to comp start
							QueryAttribute[] selAttribs = new QueryAttribute[1];
							selAttribs[0] = new QueryAttribute();
							selAttribs[0].Id = 0x80010023;
							selAttribs[0].Value = (long)60*6;	// advance 6 minutes
							wc.WidgetSelect(COMPS_TITLE_ID, BitConverter.GetBytes(Convert.ToUInt64(562949953420287)), "webuser0", null, 1, compId, 99, selAttribs);

							// wait for slotting and move past region where verify will realize new comp was added
							Thread.Sleep(2000);
						}
						break;
					case 16:	// remove for comps
						for (int i=0; i<4; i++)
						{
							// 4 entries for COMPS testing
							attribs[9].Value = (long)0;
							attribs[10].Value = (long)0;
							attribs[15].Value = (long)07734;
							attribs[16].Value = (string)"matching string for Remove test";
							attribs[17].Value = Hexer.unhex("987654321");
							wc.WidgetCompetitionCreate(COMPS_TITLE_ID,COMPS_WEBID,COMPS_GAMERTAG,null,1,attribs);
							attribs[9].Value = (long)1;
							attribs[10].Value = (long)4;
							wc.WidgetCompetitionCreate(COMPS_TITLE_ID,COMPS_WEBID,COMPS_GAMERTAG,COMPS_TEAMNAME,1,attribs);
						}
						System.Threading.Thread.Sleep(2000);
						break;
				}
			}
			catch (Exception)
			{
				ConsoleX.WriteLine("Failed to add entries in FillDBBasedOnAPI.");
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Signature\Test\dvt\main.cs ===
using System;
using System.Diagnostics;
using System.Security.Cryptography.X509Certificates;

using System.Net;
using System.IO;
using System.Text;
using System.Threading;
using System.Security.Cryptography;

using xonline.common.service;

class WebSvcTest
{
    /// <summary>
    /// The main entry point for the application.
    /// </summary>
    static void Main(string[] args)
    {
        try 
        {
            if (args.Length == 0 || args[0].CompareTo("/?") == 0 )
            {
                Console.WriteLine("Usage:\n\tWebSignatureTest.exe WebServiceMachine <command> ...");
                Console.WriteLine("\tCommands:");
                Console.WriteLine("\t\tSignDigests [<DER type Client Certificate to use with testnet web services>] <number of digests in request default=10>");
                Console.WriteLine("\t\tTransferLicenses <xuid>");
                return;
            }

            Signature vs = null;
            RNGCryptoServiceProvider randGen = new RNGCryptoServiceProvider();
        
            if (args.Length >= 2 && (args[1].EndsWith(".CER") || args[1].EndsWith(".cer")))
            {
                vs = new Signature( "https://" + args[0] + "/signature/signature.asmx" );
            
                X509Certificate x509 = X509Certificate.CreateFromCertFile(@args[1]);
                vs.ClientCertificates.Add(x509); 
                Console.WriteLine("Certificate:\"" + x509.Subject + "\" is being used\n"); 
            }
            else
            {
                vs = new Signature( "http://" + args[0] + "/signature/signature.asmx" );
            }

            int loopCount = 10;
            if (args.Length >= 3)
            {
                loopCount = Int32.Parse(args[2]);
            }

            TestSignatureCreation(vs, loopCount);

            // vs.TransferUserLicenses(0, "console");
        }
        catch ( Exception e )
        {
            Console.WriteLine( e.ToString() );
            
        }
    }

    private static void TestSignatureCreation(Signature vs, int loopCount)
    {
        int i;
        UInt32[] verifySigResult = null;
        byte[] digest = null;
        XSigCreateSignatureRequest[] csdata = new XSigCreateSignatureRequest[loopCount];
        XSigVerifySignatureRequest[] vsdata = new XSigVerifySignatureRequest[loopCount];
        
        // create a random number generator
        RNGCryptoServiceProvider randGen = new RNGCryptoServiceProvider();
        
        // generate all the desired
        for (i=0; i<loopCount; ++i)
        {
            digest = new byte[20]; 
    
            // get random bytes for information.
            randGen.GetBytes( digest );

            csdata[i] = new XSigCreateSignatureRequest();
            csdata[i]._digest = digest;
            
        }

        // run the create signature
        XSigCreateSignatureResponse[] csr = vs.CreateSignature( 101, "Larry", csdata );

        Console.WriteLine( "CreateSignature Results:" );
        // set up and verify the signatures.
        for (i=0; i<loopCount; ++i)
        {
            Console.WriteLine( i.ToString() + ".  hr = " + csr[i]._hresult + "\n");
            vsdata[i] = new XSigVerifySignatureRequest();
            vsdata[i]._digest       = csdata[i]._digest;
            vsdata[i]._signature    = csr[i]._signature;
        }
    
        verifySigResult = vs.VerifySignature( vsdata );

        // output results.
        Console.WriteLine( "\nVerifySignature Results:" );
        for (i=0; i<verifySigResult.Length; ++i)
        {
            Console.WriteLine( i.ToString() + ".  hr = " + verifySigResult[i] + "\n");
        }

        // run the blacklist digest
        for (i=0; i<loopCount; ++i)
        {
            digest = new byte[20]; 

            // get random bytes for information.
            randGen.GetBytes( digest );

            Console.WriteLine("Running blacklistdigest");
            vs.BlacklistDigest(digest, 1, "no reason");
            if (i % 2 == 0)
            {
                vs.UnBlacklistDigest(digest);
            }
        }
    }

/*
    //  Generates signed data using values from teh signature server.
    public static void GenerateData( ref byte[] digest, ref byte[] sig )
    {
        MemoryStream ms = new MemoryStream();
        BinaryWriter wr = new BinaryWriter( ms );

        WebRequest req = WebRequest.Create("http://10.10.7.212/xsig/GetSigningKey.ashx");
        WebResponse result = null;
        req.Method = "POST";
        req.ContentType = "xon/c";
        XSigSignature signature = null;
                
        req.ContentLength = 0;

        result = req.GetResponse();
            
        //ReadSignatureData( result, ref signature );
        digest = new byte[20]; 

        // create a random number generator
        RNGCryptoServiceProvider randGen = new RNGCryptoServiceProvider();

        // get random bytes for information.
        randGen.GetBytes( digest );
            
        HMACSHA1 hmacFinal = new HMACSHA1( signature.absignature );

        hmacFinal.ComputeHash( digest );

        signature.absignature = hmacFinal.Hash;  

        sig = signature.GetBytes();

        /*  Make array 0
        sig = new byte[100];
        for( int x = 0; x < 100 ; x++ )
        {
            sig[x] = 0;
        }
        
        digest = new byte[20]; 
        for( int x = 0; x < 20 ; x++ )
        {
            digest[x] = 0;
        }
        
            
    }
*/
/*    private static void ReadSignatureData( WebResponse result, ref XSigSignature signature )
    {
        Stream ReceiveStream = result.GetResponseStream();
        Encoding encode = System.Text.Encoding.GetEncoding("utf-8");
            
        BinaryReader br = new BinaryReader(ReceiveStream, encode);

        signature = new XSigSignature();
        signature.wsignatureVersion = br.ReadInt16();
        signature.wKeyVersion = br.ReadInt16(); 
        signature.dwDigestType = br.ReadUInt32();
        signature.qwTimeStamp = new DateTime(br.ReadInt64());
        signature.dwTitleID = br.ReadUInt32();  
        signature.dwTitleVersion = br.ReadUInt32();  
        signature.qwXboxID = br.ReadUInt64(); 
        signature.qwUserID1 = br.ReadUInt64(); 
        signature.qwUserID2 = br.ReadUInt64(); 
        signature.qwUserID3 = br.ReadUInt64(); 
        signature.qwUserID4 = br.ReadUInt64();
        signature.abReserved = br.ReadBytes(16); 
        signature.absignature = br.ReadBytes(20); 

    }
*/

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Signature\Dll\XSigWeb.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.1433
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 
namespace xonline.server.webcache.signature.dll {
    using System.Diagnostics;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Xml.Serialization;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="XSigWebSoap", Namespace="urn:schemas-xbox-com:xsigweb-data")]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(WireData))]
    public partial class XSigWeb : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback TestConnectionOperationCompleted;
        
        private System.Threading.SendOrPostCallback AcquireMediaLicensesOperationCompleted;
        
        private System.Threading.SendOrPostCallback AcknowledgeLicensesDeliveryOperationCompleted;
        
        private System.Threading.SendOrPostCallback CheckLicensesAvailabilityOperationCompleted;
        
        private System.Threading.SendOrPostCallback SetBlacklistDigestStateOperationCompleted;
        
        /// <remarks/>
        public XSigWeb() {
            this.Url = "http://tobiasb-xblobd:10120/xsig/xsigweb.asmx";
        }
        
        /// <remarks/>
        public event TestConnectionCompletedEventHandler TestConnectionCompleted;
        
        /// <remarks/>
        public event AcquireMediaLicensesCompletedEventHandler AcquireMediaLicensesCompleted;
        
        /// <remarks/>
        public event AcknowledgeLicensesDeliveryCompletedEventHandler AcknowledgeLicensesDeliveryCompleted;
        
        /// <remarks/>
        public event CheckLicensesAvailabilityCompletedEventHandler CheckLicensesAvailabilityCompleted;
        
        /// <remarks/>
        public event SetBlacklistDigestStateCompletedEventHandler SetBlacklistDigestStateCompleted;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:xsigweb-data/TestConnection", RequestNamespace="urn:schemas-xbox-com:xsigweb-data", ResponseNamespace="urn:schemas-xbox-com:xsigweb-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string TestConnection(string inputMessage) {
            object[] results = this.Invoke("TestConnection", new object[] {
                        inputMessage});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginTestConnection(string inputMessage, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("TestConnection", new object[] {
                        inputMessage}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndTestConnection(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void TestConnectionAsync(string inputMessage) {
            this.TestConnectionAsync(inputMessage, null);
        }
        
        /// <remarks/>
        public void TestConnectionAsync(string inputMessage, object userState) {
            if ((this.TestConnectionOperationCompleted == null)) {
                this.TestConnectionOperationCompleted = new System.Threading.SendOrPostCallback(this.OnTestConnectionOperationCompleted);
            }
            this.InvokeAsync("TestConnection", new object[] {
                        inputMessage}, this.TestConnectionOperationCompleted, userState);
        }
        
        private void OnTestConnectionOperationCompleted(object arg) {
            if ((this.TestConnectionCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.TestConnectionCompleted(this, new TestConnectionCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:xsigweb-data/AcquireMediaLicenses", RequestNamespace="urn:schemas-xbox-com:xsigweb-data", ResponseNamespace="urn:schemas-xbox-com:xsigweb-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public MediaLicense[] AcquireMediaLicenses(string[] miids, string[] oids, ulong xuid, string clientInfo) {
            object[] results = this.Invoke("AcquireMediaLicenses", new object[] {
                        miids,
                        oids,
                        xuid,
                        clientInfo});
            return ((MediaLicense[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAcquireMediaLicenses(string[] miids, string[] oids, ulong xuid, string clientInfo, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AcquireMediaLicenses", new object[] {
                        miids,
                        oids,
                        xuid,
                        clientInfo}, callback, asyncState);
        }
        
        /// <remarks/>
        public MediaLicense[] EndAcquireMediaLicenses(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((MediaLicense[])(results[0]));
        }
        
        /// <remarks/>
        public void AcquireMediaLicensesAsync(string[] miids, string[] oids, ulong xuid, string clientInfo) {
            this.AcquireMediaLicensesAsync(miids, oids, xuid, clientInfo, null);
        }
        
        /// <remarks/>
        public void AcquireMediaLicensesAsync(string[] miids, string[] oids, ulong xuid, string clientInfo, object userState) {
            if ((this.AcquireMediaLicensesOperationCompleted == null)) {
                this.AcquireMediaLicensesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnAcquireMediaLicensesOperationCompleted);
            }
            this.InvokeAsync("AcquireMediaLicenses", new object[] {
                        miids,
                        oids,
                        xuid,
                        clientInfo}, this.AcquireMediaLicensesOperationCompleted, userState);
        }
        
        private void OnAcquireMediaLicensesOperationCompleted(object arg) {
            if ((this.AcquireMediaLicensesCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.AcquireMediaLicensesCompleted(this, new AcquireMediaLicensesCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:xsigweb-data/AcknowledgeLicensesDelivery", RequestNamespace="urn:schemas-xbox-com:xsigweb-data", ResponseNamespace="urn:schemas-xbox-com:xsigweb-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public Acknowledgement[] AcknowledgeLicensesDelivery(string[] miids, string[] oids, ulong xuid) {
            object[] results = this.Invoke("AcknowledgeLicensesDelivery", new object[] {
                        miids,
                        oids,
                        xuid});
            return ((Acknowledgement[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAcknowledgeLicensesDelivery(string[] miids, string[] oids, ulong xuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AcknowledgeLicensesDelivery", new object[] {
                        miids,
                        oids,
                        xuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public Acknowledgement[] EndAcknowledgeLicensesDelivery(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((Acknowledgement[])(results[0]));
        }
        
        /// <remarks/>
        public void AcknowledgeLicensesDeliveryAsync(string[] miids, string[] oids, ulong xuid) {
            this.AcknowledgeLicensesDeliveryAsync(miids, oids, xuid, null);
        }
        
        /// <remarks/>
        public void AcknowledgeLicensesDeliveryAsync(string[] miids, string[] oids, ulong xuid, object userState) {
            if ((this.AcknowledgeLicensesDeliveryOperationCompleted == null)) {
                this.AcknowledgeLicensesDeliveryOperationCompleted = new System.Threading.SendOrPostCallback(this.OnAcknowledgeLicensesDeliveryOperationCompleted);
            }
            this.InvokeAsync("AcknowledgeLicensesDelivery", new object[] {
                        miids,
                        oids,
                        xuid}, this.AcknowledgeLicensesDeliveryOperationCompleted, userState);
        }
        
        private void OnAcknowledgeLicensesDeliveryOperationCompleted(object arg) {
            if ((this.AcknowledgeLicensesDeliveryCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.AcknowledgeLicensesDeliveryCompleted(this, new AcknowledgeLicensesDeliveryCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:xsigweb-data/CheckLicensesAvailability", RequestNamespace="urn:schemas-xbox-com:xsigweb-data", ResponseNamespace="urn:schemas-xbox-com:xsigweb-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public Availability[] CheckLicensesAvailability(string[] miids, string[] oids, ulong xuid) {
            object[] results = this.Invoke("CheckLicensesAvailability", new object[] {
                        miids,
                        oids,
                        xuid});
            return ((Availability[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCheckLicensesAvailability(string[] miids, string[] oids, ulong xuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CheckLicensesAvailability", new object[] {
                        miids,
                        oids,
                        xuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public Availability[] EndCheckLicensesAvailability(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((Availability[])(results[0]));
        }
        
        /// <remarks/>
        public void CheckLicensesAvailabilityAsync(string[] miids, string[] oids, ulong xuid) {
            this.CheckLicensesAvailabilityAsync(miids, oids, xuid, null);
        }
        
        /// <remarks/>
        public void CheckLicensesAvailabilityAsync(string[] miids, string[] oids, ulong xuid, object userState) {
            if ((this.CheckLicensesAvailabilityOperationCompleted == null)) {
                this.CheckLicensesAvailabilityOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCheckLicensesAvailabilityOperationCompleted);
            }
            this.InvokeAsync("CheckLicensesAvailability", new object[] {
                        miids,
                        oids,
                        xuid}, this.CheckLicensesAvailabilityOperationCompleted, userState);
        }
        
        private void OnCheckLicensesAvailabilityOperationCompleted(object arg) {
            if ((this.CheckLicensesAvailabilityCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CheckLicensesAvailabilityCompleted(this, new CheckLicensesAvailabilityCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:xsigweb-data/SetBlacklistDigestState", RequestNamespace="urn:schemas-xbox-com:xsigweb-data", ResponseNamespace="urn:schemas-xbox-com:xsigweb-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SetBlacklistDigestState([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] digest, byte status, byte deliveryType, string reason) {
            this.Invoke("SetBlacklistDigestState", new object[] {
                        digest,
                        status,
                        deliveryType,
                        reason});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSetBlacklistDigestState(byte[] digest, byte status, byte deliveryType, string reason, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SetBlacklistDigestState", new object[] {
                        digest,
                        status,
                        deliveryType,
                        reason}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSetBlacklistDigestState(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void SetBlacklistDigestStateAsync(byte[] digest, byte status, byte deliveryType, string reason) {
            this.SetBlacklistDigestStateAsync(digest, status, deliveryType, reason, null);
        }
        
        /// <remarks/>
        public void SetBlacklistDigestStateAsync(byte[] digest, byte status, byte deliveryType, string reason, object userState) {
            if ((this.SetBlacklistDigestStateOperationCompleted == null)) {
                this.SetBlacklistDigestStateOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSetBlacklistDigestStateOperationCompleted);
            }
            this.InvokeAsync("SetBlacklistDigestState", new object[] {
                        digest,
                        status,
                        deliveryType,
                        reason}, this.SetBlacklistDigestStateOperationCompleted, userState);
        }
        
        private void OnSetBlacklistDigestStateOperationCompleted(object arg) {
            if ((this.SetBlacklistDigestStateCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SetBlacklistDigestStateCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:xsigweb-data")]
    public partial class MediaLicense : WireData {
        
        private MediaInstanceIdOfferIdPair idPairField;
        
        private ushort licenseTypeField;
        
        private byte[] licenseField;
        
        private uint hrField;
        
        /// <remarks/>
        public MediaInstanceIdOfferIdPair idPair {
            get {
                return this.idPairField;
            }
            set {
                this.idPairField = value;
            }
        }
        
        /// <remarks/>
        public ushort licenseType {
            get {
                return this.licenseTypeField;
            }
            set {
                this.licenseTypeField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
        public byte[] license {
            get {
                return this.licenseField;
            }
            set {
                this.licenseField = value;
            }
        }
        
        /// <remarks/>
        public uint hr {
            get {
                return this.hrField;
            }
            set {
                this.hrField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:xsigweb-data")]
    public partial class MediaInstanceIdOfferIdPair : WireData {
        
        private System.Guid miidField;
        
        private System.Guid oidField;
        
        /// <remarks/>
        public System.Guid miid {
            get {
                return this.miidField;
            }
            set {
                this.miidField = value;
            }
        }
        
        /// <remarks/>
        public System.Guid oid {
            get {
                return this.oidField;
            }
            set {
                this.oidField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(Acknowledgement))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(MediaInstanceIdOfferIdPair))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(MediaLicense))]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:xsigweb-data")]
    public partial class WireData {
        
        private uint schemaVersionField;
        
        /// <remarks/>
        public uint SchemaVersion {
            get {
                return this.schemaVersionField;
            }
            set {
                this.schemaVersionField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:xsigweb-data")]
    public partial class Availability {
        
        private MediaInstanceIdOfferIdPair idPairField;
        
        private uint hrField;
        
        /// <remarks/>
        public MediaInstanceIdOfferIdPair idPair {
            get {
                return this.idPairField;
            }
            set {
                this.idPairField = value;
            }
        }
        
        /// <remarks/>
        public uint hr {
            get {
                return this.hrField;
            }
            set {
                this.hrField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:xsigweb-data")]
    public partial class Acknowledgement : WireData {
        
        private MediaInstanceIdOfferIdPair idPairField;
        
        private uint hrField;
        
        /// <remarks/>
        public MediaInstanceIdOfferIdPair idPair {
            get {
                return this.idPairField;
            }
            set {
                this.idPairField = value;
            }
        }
        
        /// <remarks/>
        public uint hr {
            get {
                return this.hrField;
            }
            set {
                this.hrField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void TestConnectionCompletedEventHandler(object sender, TestConnectionCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class TestConnectionCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal TestConnectionCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void AcquireMediaLicensesCompletedEventHandler(object sender, AcquireMediaLicensesCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class AcquireMediaLicensesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal AcquireMediaLicensesCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public MediaLicense[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((MediaLicense[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void AcknowledgeLicensesDeliveryCompletedEventHandler(object sender, AcknowledgeLicensesDeliveryCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class AcknowledgeLicensesDeliveryCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal AcknowledgeLicensesDeliveryCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public Acknowledgement[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Acknowledgement[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void CheckLicensesAvailabilityCompletedEventHandler(object sender, CheckLicensesAvailabilityCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class CheckLicensesAvailabilityCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal CheckLicensesAvailabilityCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public Availability[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Availability[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SetBlacklistDigestStateCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Signature\Test\test\MainClass.cs ===
using System;
using ServerTestFramework;

[assembly: RootNode(typeof(Webcache.Signature.Test.WebcacheSignatureTest))]

namespace Webcache.Signature.Test
{
    /// <summary>
    /// Root test group for Webcache Signature Tests
    /// </summary>
    [TestGroup, Owner("BenRan"), TestFrequency("Regression"), EnvRequirement("")]
    public class WebcacheSignatureTest : TestNode
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Query\test\dvt\query.cs ===
//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.0.3705.288
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=1.0.3705.288.
// 
using System.Diagnostics;
using System.Xml.Serialization;
using System;
using System.Web.Services.Protocols;
using System.ComponentModel;
using System.Web.Services;


/// <remarks/>
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Web.Services.WebServiceBindingAttribute(Name="QuerySoap", Namespace="http://websvc.xboxlive.com/Query/")]
[System.Xml.Serialization.XmlIncludeAttribute(typeof(WireData))]
public class Query : System.Web.Services.Protocols.SoapHttpClientProtocol {
    
    /// <remarks/>
    public Query() {
        this.Url = "http://phansen1:90/query/query.asmx";
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Query/Add", RequestNamespace="http://websvc.xboxlive.com/Query/", ResponseNamespace="http://websvc.xboxlive.com/Query/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public System.UInt64 Add(System.UInt32 titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] webId, string gamerTag, string teamName, System.UInt32 datasetId, QueryAttribute[] attributes) {
        object[] results = this.Invoke("Add", new object[] {
                    titleId,
                    webId,
                    gamerTag,
                    teamName,
                    datasetId,
                    attributes});
        return ((System.UInt64)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAdd(System.UInt32 titleId, System.Byte[] webId, string gamerTag, string teamName, System.UInt32 datasetId, QueryAttribute[] attributes, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("Add", new object[] {
                    titleId,
                    webId,
                    gamerTag,
                    teamName,
                    datasetId,
                    attributes}, callback, asyncState);
    }
    
    /// <remarks/>
    public System.UInt64 EndAdd(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((System.UInt64)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Query/Update", RequestNamespace="http://websvc.xboxlive.com/Query/", ResponseNamespace="http://websvc.xboxlive.com/Query/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public void Update(System.UInt32 titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] webId, string gamerTag, string teamName, System.UInt32 datasetId, System.UInt32 procIndex, QueryAttribute[] attributes) {
        this.Invoke("Update", new object[] {
                    titleId,
                    webId,
                    gamerTag,
                    teamName,
                    datasetId,
                    procIndex,
                    attributes});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUpdate(System.UInt32 titleId, System.Byte[] webId, string gamerTag, string teamName, System.UInt32 datasetId, System.UInt32 procIndex, QueryAttribute[] attributes, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("Update", new object[] {
                    titleId,
                    webId,
                    gamerTag,
                    teamName,
                    datasetId,
                    procIndex,
                    attributes}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUpdate(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Query/UpdateId", RequestNamespace="http://websvc.xboxlive.com/Query/", ResponseNamespace="http://websvc.xboxlive.com/Query/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public void UpdateId(System.UInt32 titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] webId, string gamerTag, string teamName, System.UInt32 datasetId, System.UInt32 procIndex, System.UInt64 entityId, QueryAttribute[] attributes) {
        this.Invoke("UpdateId", new object[] {
                    titleId,
                    webId,
                    gamerTag,
                    teamName,
                    datasetId,
                    procIndex,
                    entityId,
                    attributes});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUpdateId(System.UInt32 titleId, System.Byte[] webId, string gamerTag, string teamName, System.UInt32 datasetId, System.UInt32 procIndex, System.UInt64 entityId, QueryAttribute[] attributes, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UpdateId", new object[] {
                    titleId,
                    webId,
                    gamerTag,
                    teamName,
                    datasetId,
                    procIndex,
                    entityId,
                    attributes}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUpdateId(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Query/Search", RequestNamespace="http://websvc.xboxlive.com/Query/", ResponseNamespace="http://websvc.xboxlive.com/Query/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public SearchResponse Search(System.UInt32 titleId, System.UInt32 datasetId, System.UInt32 procIndex, System.UInt32 page, System.UInt32 resultsPerPage, QueryAttributeSpec[] specs, QueryAttribute[] attributes) {
        object[] results = this.Invoke("Search", new object[] {
                    titleId,
                    datasetId,
                    procIndex,
                    page,
                    resultsPerPage,
                    specs,
                    attributes});
        return ((SearchResponse)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSearch(System.UInt32 titleId, System.UInt32 datasetId, System.UInt32 procIndex, System.UInt32 page, System.UInt32 resultsPerPage, QueryAttributeSpec[] specs, QueryAttribute[] attributes, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("Search", new object[] {
                    titleId,
                    datasetId,
                    procIndex,
                    page,
                    resultsPerPage,
                    specs,
                    attributes}, callback, asyncState);
    }
    
    /// <remarks/>
    public SearchResponse EndSearch(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((SearchResponse)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Query/FindFromIds", RequestNamespace="http://websvc.xboxlive.com/Query/", ResponseNamespace="http://websvc.xboxlive.com/Query/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public FindFromIdsResponse FindFromIds(System.UInt32 titleId, System.UInt32 datasetId, System.UInt32 procIndex, QueryAttributeSpec[] specs, System.UInt64[] entityIds) {
        object[] results = this.Invoke("FindFromIds", new object[] {
                    titleId,
                    datasetId,
                    procIndex,
                    specs,
                    entityIds});
        return ((FindFromIdsResponse)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginFindFromIds(System.UInt32 titleId, System.UInt32 datasetId, System.UInt32 procIndex, QueryAttributeSpec[] specs, System.UInt64[] entityIds, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("FindFromIds", new object[] {
                    titleId,
                    datasetId,
                    procIndex,
                    specs,
                    entityIds}, callback, asyncState);
    }
    
    /// <remarks/>
    public FindFromIdsResponse EndFindFromIds(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((FindFromIdsResponse)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Query/Remove", RequestNamespace="http://websvc.xboxlive.com/Query/", ResponseNamespace="http://websvc.xboxlive.com/Query/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public void Remove(System.UInt32 titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] webId, string gamerTag, string teamName, System.UInt32 datasetId, System.UInt32 procIndex, QueryAttribute[] attributes) {
        this.Invoke("Remove", new object[] {
                    titleId,
                    webId,
                    gamerTag,
                    teamName,
                    datasetId,
                    procIndex,
                    attributes});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginRemove(System.UInt32 titleId, System.Byte[] webId, string gamerTag, string teamName, System.UInt32 datasetId, System.UInt32 procIndex, QueryAttribute[] attributes, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("Remove", new object[] {
                    titleId,
                    webId,
                    gamerTag,
                    teamName,
                    datasetId,
                    procIndex,
                    attributes}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndRemove(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Query/RemoveId", RequestNamespace="http://websvc.xboxlive.com/Query/", ResponseNamespace="http://websvc.xboxlive.com/Query/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public void RemoveId(System.UInt32 titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] webId, string gamerTag, string teamName, System.UInt32 datasetId, System.UInt64 entityId) {
        this.Invoke("RemoveId", new object[] {
                    titleId,
                    webId,
                    gamerTag,
                    teamName,
                    datasetId,
                    entityId});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginRemoveId(System.UInt32 titleId, System.Byte[] webId, string gamerTag, string teamName, System.UInt32 datasetId, System.UInt64 entityId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("RemoveId", new object[] {
                    titleId,
                    webId,
                    gamerTag,
                    teamName,
                    datasetId,
                    entityId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndRemoveId(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Query/Select", RequestNamespace="http://websvc.xboxlive.com/Query/", ResponseNamespace="http://websvc.xboxlive.com/Query/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public void Select(System.UInt32 titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] webId, string gamerTag, string teamName, System.UInt32 datasetId, System.UInt64 entityId, System.UInt32 action, QueryAttribute[] attributes) {
        this.Invoke("Select", new object[] {
                    titleId,
                    webId,
                    gamerTag,
                    teamName,
                    datasetId,
                    entityId,
                    action,
                    attributes});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSelect(System.UInt32 titleId, System.Byte[] webId, string gamerTag, string teamName, System.UInt32 datasetId, System.UInt64 entityId, System.UInt32 action, QueryAttribute[] attributes, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("Select", new object[] {
                    titleId,
                    webId,
                    gamerTag,
                    teamName,
                    datasetId,
                    entityId,
                    action,
                    attributes}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndSelect(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Query/GetXQSConfig", RequestNamespace="http://websvc.xboxlive.com/Query/", ResponseNamespace="http://websvc.xboxlive.com/Query/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public string GetXQSConfig(System.UInt32 titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] webId, System.UInt64 haveVersion) {
        object[] results = this.Invoke("GetXQSConfig", new object[] {
                    titleId,
                    webId,
                    haveVersion});
        return ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetXQSConfig(System.UInt32 titleId, System.Byte[] webId, System.UInt64 haveVersion, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetXQSConfig", new object[] {
                    titleId,
                    webId,
                    haveVersion}, callback, asyncState);
    }
    
    /// <remarks/>
    public string EndGetXQSConfig(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Query/CompetitionCreate", RequestNamespace="http://websvc.xboxlive.com/Query/", ResponseNamespace="http://websvc.xboxlive.com/Query/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public System.UInt64 CompetitionCreate(System.UInt32 titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] webId, string gamerTag, string teamName, System.UInt32 datasetId, QueryAttribute[] attributes) {
        object[] results = this.Invoke("CompetitionCreate", new object[] {
                    titleId,
                    webId,
                    gamerTag,
                    teamName,
                    datasetId,
                    attributes});
        return ((System.UInt64)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCompetitionCreate(System.UInt32 titleId, System.Byte[] webId, string gamerTag, string teamName, System.UInt32 datasetId, QueryAttribute[] attributes, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CompetitionCreate", new object[] {
                    titleId,
                    webId,
                    gamerTag,
                    teamName,
                    datasetId,
                    attributes}, callback, asyncState);
    }
    
    /// <remarks/>
    public System.UInt64 EndCompetitionCreate(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((System.UInt64)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Query/CompetitionCreateSingleElimination", RequestNamespace="http://websvc.xboxlive.com/Query/", ResponseNamespace="http://websvc.xboxlive.com/Query/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public System.UInt64 CompetitionCreateSingleElimination(
                System.UInt32 titleId, 
                [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] webId, 
                string gamerTag, 
                string teamName, 
                System.UInt32 datasetId, 
                System.UInt32 cPrivateSlots, 
                System.UInt32 cPublicSlots, 
                System.UInt32 cMinimumPlayers, 
                System.DateTime dtRegistrationOpen, 
                System.DateTime dtRegistrationClose, 
                System.DateTime dtCompetitionStart, 
                System.DateTime dtRoundOneStart, 
                System.DateTime dtRoundOneEnd, 
                System.UInt32 dwMatchReminderAdvanceMinutes, 
                System.UInt32 UnitOrMask, 
                System.UInt32 Interval, 
                bool fTeamCompetition, 
                System.UInt32 dwTeamSize, 
                QueryAttribute[] additionalAttributes) {
        object[] results = this.Invoke("CompetitionCreateSingleElimination", new object[] {
                    titleId,
                    webId,
                    gamerTag,
                    teamName,
                    datasetId,
                    cPrivateSlots,
                    cPublicSlots,
                    cMinimumPlayers,
                    dtRegistrationOpen,
                    dtRegistrationClose,
                    dtCompetitionStart,
                    dtRoundOneStart,
                    dtRoundOneEnd,
                    dwMatchReminderAdvanceMinutes,
                    UnitOrMask,
                    Interval,
                    fTeamCompetition,
                    dwTeamSize,
                    additionalAttributes});
        return ((System.UInt64)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCompetitionCreateSingleElimination(
                System.UInt32 titleId, 
                System.Byte[] webId, 
                string gamerTag, 
                string teamName, 
                System.UInt32 datasetId, 
                System.UInt32 cPrivateSlots, 
                System.UInt32 cPublicSlots, 
                System.UInt32 cMinimumPlayers, 
                System.DateTime dtRegistrationOpen, 
                System.DateTime dtRegistrationClose, 
                System.DateTime dtCompetitionStart, 
                System.DateTime dtRoundOneStart, 
                System.DateTime dtRoundOneEnd, 
                System.UInt32 dwMatchReminderAdvanceMinutes, 
                System.UInt32 UnitOrMask, 
                System.UInt32 Interval, 
                bool fTeamCompetition, 
                System.UInt32 dwTeamSize, 
                QueryAttribute[] additionalAttributes, 
                System.AsyncCallback callback, 
                object asyncState) {
        return this.BeginInvoke("CompetitionCreateSingleElimination", new object[] {
                    titleId,
                    webId,
                    gamerTag,
                    teamName,
                    datasetId,
                    cPrivateSlots,
                    cPublicSlots,
                    cMinimumPlayers,
                    dtRegistrationOpen,
                    dtRegistrationClose,
                    dtCompetitionStart,
                    dtRoundOneStart,
                    dtRoundOneEnd,
                    dwMatchReminderAdvanceMinutes,
                    UnitOrMask,
                    Interval,
                    fTeamCompetition,
                    dwTeamSize,
                    additionalAttributes}, callback, asyncState);
    }
    
    /// <remarks/>
    public System.UInt64 EndCompetitionCreateSingleElimination(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((System.UInt64)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Query/CompetitionSearch", RequestNamespace="http://websvc.xboxlive.com/Query/", ResponseNamespace="http://websvc.xboxlive.com/Query/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public SearchResponse CompetitionSearch(System.UInt32 titleId, System.UInt32 datasetId, System.UInt32 queryId, System.UInt32 page, System.UInt32 resultsPerPage, QueryAttributeSpec[] specs, QueryAttribute[] attributes) {
        object[] results = this.Invoke("CompetitionSearch", new object[] {
                    titleId,
                    datasetId,
                    queryId,
                    page,
                    resultsPerPage,
                    specs,
                    attributes});
        return ((SearchResponse)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCompetitionSearch(System.UInt32 titleId, System.UInt32 datasetId, System.UInt32 queryId, System.UInt32 page, System.UInt32 resultsPerPage, QueryAttributeSpec[] specs, QueryAttribute[] attributes, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CompetitionSearch", new object[] {
                    titleId,
                    datasetId,
                    queryId,
                    page,
                    resultsPerPage,
                    specs,
                    attributes}, callback, asyncState);
    }
    
    /// <remarks/>
    public SearchResponse EndCompetitionSearch(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((SearchResponse)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Query/CompetitionManageEntrant", RequestNamespace="http://websvc.xboxlive.com/Query/", ResponseNamespace="http://websvc.xboxlive.com/Query/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public void CompetitionManageEntrant(System.UInt32 titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] webId, string gamerTag, System.UInt32 action, string teamName, System.UInt32 datasetId, System.UInt64 competitionId, QueryAttribute[] attributes) {
        this.Invoke("CompetitionManageEntrant", new object[] {
                    titleId,
                    webId,
                    gamerTag,
                    action,
                    teamName,
                    datasetId,
                    competitionId,
                    attributes});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCompetitionManageEntrant(System.UInt32 titleId, System.Byte[] webId, string gamerTag, System.UInt32 action, string teamName, System.UInt32 datasetId, System.UInt64 competitionId, QueryAttribute[] attributes, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CompetitionManageEntrant", new object[] {
                    titleId,
                    webId,
                    gamerTag,
                    action,
                    teamName,
                    datasetId,
                    competitionId,
                    attributes}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCompetitionManageEntrant(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Query/CompetitionCancel", RequestNamespace="http://websvc.xboxlive.com/Query/", ResponseNamespace="http://websvc.xboxlive.com/Query/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public void CompetitionCancel(System.UInt32 titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] webId, string gamerTag, string teamName, System.UInt32 datasetId, System.UInt64 competitionId) {
        this.Invoke("CompetitionCancel", new object[] {
                    titleId,
                    webId,
                    gamerTag,
                    teamName,
                    datasetId,
                    competitionId});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCompetitionCancel(System.UInt32 titleId, System.Byte[] webId, string gamerTag, string teamName, System.UInt32 datasetId, System.UInt64 competitionId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CompetitionCancel", new object[] {
                    titleId,
                    webId,
                    gamerTag,
                    teamName,
                    datasetId,
                    competitionId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCompetitionCancel(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Query/CompetitionTopology", RequestNamespace="http://websvc.xboxlive.com/Query/", ResponseNamespace="http://websvc.xboxlive.com/Query/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public SearchResponse CompetitionTopology(System.UInt32 titleId, System.UInt32 datasetId, System.UInt64 competitionId, System.UInt32 page, System.UInt32 resultsPerPage, long startingEventId, long endingEventId, QueryAttributeSpec[] specs) {
        object[] results = this.Invoke("CompetitionTopology", new object[] {
                    titleId,
                    datasetId,
                    competitionId,
                    page,
                    resultsPerPage,
                    startingEventId,
                    endingEventId,
                    specs});
        return ((SearchResponse)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCompetitionTopology(System.UInt32 titleId, System.UInt32 datasetId, System.UInt64 competitionId, System.UInt32 page, System.UInt32 resultsPerPage, long startingEventId, long endingEventId, QueryAttributeSpec[] specs, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CompetitionTopology", new object[] {
                    titleId,
                    datasetId,
                    competitionId,
                    page,
                    resultsPerPage,
                    startingEventId,
                    endingEventId,
                    specs}, callback, asyncState);
    }
    
    /// <remarks/>
    public SearchResponse EndCompetitionTopology(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((SearchResponse)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Query/CompetitionTopologySingleElimination", RequestNamespace="http://websvc.xboxlive.com/Query/", ResponseNamespace="http://websvc.xboxlive.com/Query/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public SearchResponse CompetitionTopologySingleElimination(System.UInt32 titleId, System.UInt32 datasetId, System.UInt64 competitionId, System.UInt64 originEventId, System.UInt32 roundsForward, System.UInt32 roundsBackward, System.UInt32 topWidth, QueryAttributeSpec[] specs) {
        object[] results = this.Invoke("CompetitionTopologySingleElimination", new object[] {
                    titleId,
                    datasetId,
                    competitionId,
                    originEventId,
                    roundsForward,
                    roundsBackward,
                    topWidth,
                    specs});
        return ((SearchResponse)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCompetitionTopologySingleElimination(System.UInt32 titleId, System.UInt32 datasetId, System.UInt64 competitionId, System.UInt64 originEventId, System.UInt32 roundsForward, System.UInt32 roundsBackward, System.UInt32 topWidth, QueryAttributeSpec[] specs, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CompetitionTopologySingleElimination", new object[] {
                    titleId,
                    datasetId,
                    competitionId,
                    originEventId,
                    roundsForward,
                    roundsBackward,
                    topWidth,
                    specs}, callback, asyncState);
    }
    
    /// <remarks/>
    public SearchResponse EndCompetitionTopologySingleElimination(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((SearchResponse)(results[0]));
    }
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Query/")]
public class QueryAttribute : WireData {
    
    /// <remarks/>
    public object Value;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public System.UInt32 Id;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Query/")]
[System.Xml.Serialization.XmlIncludeAttribute(typeof(XRLObject2))]
[System.Xml.Serialization.XmlIncludeAttribute(typeof(FindFromIdsResponse))]
[System.Xml.Serialization.XmlIncludeAttribute(typeof(SearchResponse))]
[System.Xml.Serialization.XmlIncludeAttribute(typeof(QueryAttributeSpec))]
[System.Xml.Serialization.XmlIncludeAttribute(typeof(QueryAttribute))]
public class WireData {
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Query/")]
[System.Xml.Serialization.XmlIncludeAttribute(typeof(FindFromIdsResponse))]
[System.Xml.Serialization.XmlIncludeAttribute(typeof(SearchResponse))]
[System.Xml.Serialization.XmlIncludeAttribute(typeof(QueryAttributeSpec))]
public class XRLObject2 : WireData {
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Query/")]
public class FindFromIdsResponse : XRLObject2 {
    
    /// <remarks/>
    public System.UInt32 returnedResults;
    
    /// <remarks/>
    public System.UInt32 attribCount;
    
    /// <remarks/>
    public QueryAttribute[] attribs;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Query/")]
public class SearchResponse : XRLObject2 {
    
    /// <remarks/>
    public System.UInt32 totalResults;
    
    /// <remarks/>
    public System.UInt32 returnedResults;
    
    /// <remarks/>
    public System.UInt32 attribCount;
    
    /// <remarks/>
    public QueryAttribute[] attribs;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Query/")]
public class QueryAttributeSpec : XRLObject2 {
    
    /// <remarks/>
    public System.UInt32 type;
    
    /// <remarks/>
    public System.UInt32 len;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Signature\Test\dvt\Signature.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.1433
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Web.Services;
using System.Web.Services.Protocols;
using System.Xml.Serialization;

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 


/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Web.Services.WebServiceBindingAttribute(Name="SignatureSoap", Namespace="http://websvc.xboxlive.com/Signature/")]
public partial class Signature : System.Web.Services.Protocols.SoapHttpClientProtocol {
    
    private System.Threading.SendOrPostCallback VerifySignatureOperationCompleted;
    
    private System.Threading.SendOrPostCallback CreateSignatureOperationCompleted;
    
    private System.Threading.SendOrPostCallback TransferUserLicensesOperationCompleted;
    
    private System.Threading.SendOrPostCallback BlacklistDigestOperationCompleted;
    
    private System.Threading.SendOrPostCallback UnBlacklistDigestOperationCompleted;
    
    /// <remarks/>
    public Signature(string url) {
        this.Url = url;
    }
    
    /// <remarks/>
    public event VerifySignatureCompletedEventHandler VerifySignatureCompleted;
    
    /// <remarks/>
    public event CreateSignatureCompletedEventHandler CreateSignatureCompleted;
    
    /// <remarks/>
    public event TransferUserLicensesCompletedEventHandler TransferUserLicensesCompleted;
    
    /// <remarks/>
    public event BlacklistDigestCompletedEventHandler BlacklistDigestCompleted;
    
    /// <remarks/>
    public event UnBlacklistDigestCompletedEventHandler UnBlacklistDigestCompleted;
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Signature/VerifySignature", RequestNamespace="http://websvc.xboxlive.com/Signature/", ResponseNamespace="http://websvc.xboxlive.com/Signature/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public uint[] VerifySignature(XSigVerifySignatureRequest[] sigData) {
        object[] results = this.Invoke("VerifySignature", new object[] {
                    sigData});
        return ((uint[])(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginVerifySignature(XSigVerifySignatureRequest[] sigData, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("VerifySignature", new object[] {
                    sigData}, callback, asyncState);
    }
    
    /// <remarks/>
    public uint[] EndVerifySignature(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((uint[])(results[0]));
    }
    
    /// <remarks/>
    public void VerifySignatureAsync(XSigVerifySignatureRequest[] sigData) {
        this.VerifySignatureAsync(sigData, null);
    }
    
    /// <remarks/>
    public void VerifySignatureAsync(XSigVerifySignatureRequest[] sigData, object userState) {
        if ((this.VerifySignatureOperationCompleted == null)) {
            this.VerifySignatureOperationCompleted = new System.Threading.SendOrPostCallback(this.OnVerifySignatureOperationCompleted);
        }
        this.InvokeAsync("VerifySignature", new object[] {
                    sigData}, this.VerifySignatureOperationCompleted, userState);
    }
    
    private void OnVerifySignatureOperationCompleted(object arg) {
        if ((this.VerifySignatureCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.VerifySignatureCompleted(this, new VerifySignatureCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Signature/CreateSignature", RequestNamespace="http://websvc.xboxlive.com/Signature/", ResponseNamespace="http://websvc.xboxlive.com/Signature/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public XSigCreateSignatureResponse[] CreateSignature(uint titleID, string adminId, XSigCreateSignatureRequest[] sigData) {
        object[] results = this.Invoke("CreateSignature", new object[] {
                    titleID,
                    adminId,
                    sigData});
        return ((XSigCreateSignatureResponse[])(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCreateSignature(uint titleID, string adminId, XSigCreateSignatureRequest[] sigData, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CreateSignature", new object[] {
                    titleID,
                    adminId,
                    sigData}, callback, asyncState);
    }
    
    /// <remarks/>
    public XSigCreateSignatureResponse[] EndCreateSignature(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((XSigCreateSignatureResponse[])(results[0]));
    }
    
    /// <remarks/>
    public void CreateSignatureAsync(uint titleID, string adminId, XSigCreateSignatureRequest[] sigData) {
        this.CreateSignatureAsync(titleID, adminId, sigData, null);
    }
    
    /// <remarks/>
    public void CreateSignatureAsync(uint titleID, string adminId, XSigCreateSignatureRequest[] sigData, object userState) {
        if ((this.CreateSignatureOperationCompleted == null)) {
            this.CreateSignatureOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCreateSignatureOperationCompleted);
        }
        this.InvokeAsync("CreateSignature", new object[] {
                    titleID,
                    adminId,
                    sigData}, this.CreateSignatureOperationCompleted, userState);
    }
    
    private void OnCreateSignatureOperationCompleted(object arg) {
        if ((this.CreateSignatureCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.CreateSignatureCompleted(this, new CreateSignatureCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Signature/TransferUserLicenses", RequestNamespace="http://websvc.xboxlive.com/Signature/", ResponseNamespace="http://websvc.xboxlive.com/Signature/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public void TransferUserLicenses(ulong xuid, string consoleId) {
        this.Invoke("TransferUserLicenses", new object[] {
                    xuid,
                    consoleId});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginTransferUserLicenses(ulong xuid, string consoleId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("TransferUserLicenses", new object[] {
                    xuid,
                    consoleId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndTransferUserLicenses(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    public void TransferUserLicensesAsync(ulong xuid, string consoleId) {
        this.TransferUserLicensesAsync(xuid, consoleId, null);
    }
    
    /// <remarks/>
    public void TransferUserLicensesAsync(ulong xuid, string consoleId, object userState) {
        if ((this.TransferUserLicensesOperationCompleted == null)) {
            this.TransferUserLicensesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnTransferUserLicensesOperationCompleted);
        }
        this.InvokeAsync("TransferUserLicenses", new object[] {
                    xuid,
                    consoleId}, this.TransferUserLicensesOperationCompleted, userState);
    }
    
    private void OnTransferUserLicensesOperationCompleted(object arg) {
        if ((this.TransferUserLicensesCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.TransferUserLicensesCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Signature/BlacklistDigest", RequestNamespace="http://websvc.xboxlive.com/Signature/", ResponseNamespace="http://websvc.xboxlive.com/Signature/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public void BlacklistDigest([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] digest, byte deliveryType, string revocationReason) {
        this.Invoke("BlacklistDigest", new object[] {
                    digest,
                    deliveryType,
                    revocationReason});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginBlacklistDigest(byte[] digest, byte deliveryType, string revocationReason, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("BlacklistDigest", new object[] {
                    digest,
                    deliveryType,
                    revocationReason}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndBlacklistDigest(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    public void BlacklistDigestAsync(byte[] digest, byte deliveryType, string revocationReason) {
        this.BlacklistDigestAsync(digest, deliveryType, revocationReason, null);
    }
    
    /// <remarks/>
    public void BlacklistDigestAsync(byte[] digest, byte deliveryType, string revocationReason, object userState) {
        if ((this.BlacklistDigestOperationCompleted == null)) {
            this.BlacklistDigestOperationCompleted = new System.Threading.SendOrPostCallback(this.OnBlacklistDigestOperationCompleted);
        }
        this.InvokeAsync("BlacklistDigest", new object[] {
                    digest,
                    deliveryType,
                    revocationReason}, this.BlacklistDigestOperationCompleted, userState);
    }
    
    private void OnBlacklistDigestOperationCompleted(object arg) {
        if ((this.BlacklistDigestCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.BlacklistDigestCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Signature/UnBlacklistDigest", RequestNamespace="http://websvc.xboxlive.com/Signature/", ResponseNamespace="http://websvc.xboxlive.com/Signature/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public void UnBlacklistDigest([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] digest) {
        this.Invoke("UnBlacklistDigest", new object[] {
                    digest});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUnBlacklistDigest(byte[] digest, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UnBlacklistDigest", new object[] {
                    digest}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUnBlacklistDigest(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    public void UnBlacklistDigestAsync(byte[] digest) {
        this.UnBlacklistDigestAsync(digest, null);
    }
    
    /// <remarks/>
    public void UnBlacklistDigestAsync(byte[] digest, object userState) {
        if ((this.UnBlacklistDigestOperationCompleted == null)) {
            this.UnBlacklistDigestOperationCompleted = new System.Threading.SendOrPostCallback(this.OnUnBlacklistDigestOperationCompleted);
        }
        this.InvokeAsync("UnBlacklistDigest", new object[] {
                    digest}, this.UnBlacklistDigestOperationCompleted, userState);
    }
    
    private void OnUnBlacklistDigestOperationCompleted(object arg) {
        if ((this.UnBlacklistDigestCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.UnBlacklistDigestCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    public new void CancelAsync(object userState) {
        base.CancelAsync(userState);
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.SerializableAttribute()]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Signature/")]
public partial class XSigVerifySignatureRequest {
    
    private byte[] _digestField;
    
    private byte[] _signatureField;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
    public byte[] _digest {
        get {
            return this._digestField;
        }
        set {
            this._digestField = value;
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
    public byte[] _signature {
        get {
            return this._signatureField;
        }
        set {
            this._signatureField = value;
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.SerializableAttribute()]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Signature/")]
public partial class XSigCreateSignatureResponse {
    
    private uint _hresultField;
    
    private byte[] _signatureField;
    
    /// <remarks/>
    public uint _hresult {
        get {
            return this._hresultField;
        }
        set {
            this._hresultField = value;
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
    public byte[] _signature {
        get {
            return this._signatureField;
        }
        set {
            this._signatureField = value;
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.SerializableAttribute()]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Signature/")]
public partial class XSigCreateSignatureRequest {
    
    private byte[] _digestField;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
    public byte[] _digest {
        get {
            return this._digestField;
        }
        set {
            this._digestField = value;
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void VerifySignatureCompletedEventHandler(object sender, VerifySignatureCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class VerifySignatureCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal VerifySignatureCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public uint[] Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((uint[])(this.results[0]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void CreateSignatureCompletedEventHandler(object sender, CreateSignatureCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class CreateSignatureCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal CreateSignatureCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public XSigCreateSignatureResponse[] Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((XSigCreateSignatureResponse[])(this.results[0]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void TransferUserLicensesCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void BlacklistDigestCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void UnBlacklistDigestCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Signature\Test\test\BlacklistDigest.cs ===
using System;
using System.Data.SqlClient;
using System.Web.Services.Protocols;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;

using xonline.common.config;

namespace Webcache.Signature.Test
{
    /// <summary>
    /// These test that the blacklist blobs make it to the DB from the API.
    /// Other tests verify that the blob in the DB is used correctly.
    /// </summary>
    [TestGroup, Description("Signature webcache tests for BlacklistDigest")]
    public class BlacklistDigest : TestNode
    {
        public const int DIGEST_SIZE = 20;

        public bool AddDebugPartnerToWebDbForApi(params string[] apiNames)
        {
            bool didUpdate = false; 

            // Get all the WebDB servers
            string[] webDBServers = Global.XEnv.GetServerListByInterface(xonline.common.config.Interface.webdb);
            foreach (string server in webDBServers)
            {
                // Connect to each on
                SqlConnection c = new SqlConnection("Data Source=" + server + ";Initial Catalog=WebDB;Integrated Security=SSPI");
                c.Open();

                // Loop through each API
                foreach (string api in apiNames)
                {
                    Global.RO.Info("Checking DebugPartner permissions on {0}...", api);

                    // See if its already set
                    string query = "use WebDB; select count(*) from t_partner_allowed_apis where vc_api_name='" + api + "' and i_partner_id=(select i_partner_id from t_partners where vc_subject_name='DebugPartner')";
                    SqlCommand cmd = new SqlCommand(query, c);
                    object o = cmd.ExecuteScalar();
                    if ((int)o > 0)
                    {
                        continue;
                    }

                    // If not, update DB
                    Global.RO.Info("Setting DebugPartner permissions...");
                    query = "use WebDB; declare @grr int; set @grr=(select i_partner_id from t_partners where vc_subject_name='DebugPartner'); insert into t_partner_allowed_apis (i_partner_id,vc_api_name) values (@grr,'" + api + "');";
                    cmd = new SqlCommand(query, c);
                    cmd.ExecuteNonQuery();

                    didUpdate = true;
                }

                c.Close();
            }

            return didUpdate;
        }

        public override void PreRun()
        {
            if (AddDebugPartnerToWebDbForApi("Signature.BlacklistDigest", "Signature.UnBlacklistDigest"))
            {
                // Reload anything we need
                string[] widgetServers = Global.XEnv.GetServerListByInterface(Interface.wcsignature);
                foreach (string server in widgetServers)
                {
                    string result;
                    string xcmd = "e :wcsignature ReloadPartners";
                    bool worked = ManagementConsole.Execute(server, xcmd, out result);
                    if (worked)
                    {
                        Global.RO.Debug(server + " reloaded");
                    }
                    else
                    {
                        Global.RO.Error("Error executing \"" + xcmd + "\" on " + server + ": " + result);
                        Global.RO.Error("The DebugPartner may not be allowed to call the API as a result.");
                    }
                }
            }
        }

        public int CountOfBlacklistedBlobInDB(byte[] blob, int is_blacklisted)
        {
            Npdb npdb = new Npdb();
            npdb.ConnectToServer();
            int count = (int)npdb.ExecuteScalar("SELECT COUNT(*) FROM t_blacklisted_digests WHERE bin_digest=0x" + Hexer.tohex(blob) + " AND ti_is_blacklisted =" + is_blacklisted);
            npdb.Close();
            return count;
        }

        public void ValidateBlacklistDb(byte[] blob, bool isBlacklisted, int expectedCount)
        {
            int blacklistCount = CountOfBlacklistedBlobInDB(blob, isBlacklisted ? 1 : 0);
            if (blacklistCount != expectedCount)
            {
                String msg = String.Format("Digest 0x{0}\nBlacklist Count: {1}, Expected: {2}",
                    Hexer.tohex(blob), expectedCount, blacklistCount);
                throw new UnexpectedTestResultException(msg);
            }
        }

        [TestCase, TestCasePriority(0), Description("Call the API then check the DB")]
        public void SimpleMainline_Blacklist()
        {
            byte[] digest = new byte[DIGEST_SIZE];
            RandomEx.GlobalRandGen.NextBytes(digest);

            WCSignature wcSig = new WCSignature();
            Global.RO.Info("Blacklisting Digest: 0x{0}", Hexer.tohex(digest));
            wcSig.BlacklistDigest(digest, 1, "WebCacheTests");

            ValidateBlacklistDb(digest, true, 1);
        }

        [TestCase, TestCasePriority(0), Description("Call the API then check the DB")]
        public void SimpleMainline_Unblacklist()
        {
            byte[] digest = new byte[DIGEST_SIZE];
            RandomEx.GlobalRandGen.NextBytes(digest);

            WCSignature wcSig = new WCSignature();
            Global.RO.Info("Blacklisting Digest: 0x{0}", Hexer.tohex(digest));
            wcSig.BlacklistDigest(digest, 1, "WebCacheTests");

            ValidateBlacklistDb(digest, true, 1);

            Global.RO.Info("Unblacklisting");
            wcSig = new WCSignature();
            wcSig.UnBlacklistDigest(digest);

            // Should still be in DB, but marked as not blacklisted
            ValidateBlacklistDb(digest, false, 1);

        }

        [TestCase, TestCasePriority(1), Description("Call the API twice with the same blob then check the DB")]
        public void BlacklistTwice()
        {
            byte[] digest = new byte[DIGEST_SIZE];
            RandomEx.GlobalRandGen.NextBytes(digest);

            WCSignature wcSig = new WCSignature();
            wcSig.BlacklistDigest(digest, 1, "WebCacheTests");

            wcSig = new WCSignature();
            wcSig.BlacklistDigest(digest, 1, "WebCacheTests");

            ValidateBlacklistDb(digest, true, 1);
        }

        [TestCase, TestCasePriority(2), Description("Call the API with a 0 byte blob, it should fail")]
        public void ZeroBytes()
        {
            byte[] digest = new byte[0];

            try
            {
                WCSignature wcSig = new WCSignature();
                Global.RO.Info("Blacklisting Digest: 0x{0}", Hexer.tohex(digest));
                wcSig.BlacklistDigest(digest, 1, "WebCacheTests_0Bytes");
            }
            catch (SoapException se)
            {
                if (se.Message.Contains("The web service encountered an internal error"))
                {
                    Global.RO.Success("Blacklist request failed as expected.");
                    return;
                }
                else
                {
                    throw new UnexpectedTestResultException("Failed with unexpected exception: " + se, se);
                }
            }

            throw new UnexpectedTestResultException("Did not expect call to succeed.");
        }

        [TestCase, TestCasePriority(2), Description("Call the API with a 100k blob, it should fail")]
        public void TooManyBytes()
        {
            byte[] digest = new byte[100000];
            RandomEx.GlobalRandGen.NextBytes(digest);

            try
            {
                WCSignature wcSig = new WCSignature();
                Global.RO.Info("Blacklisting 100000 Byte Digest");
                wcSig.BlacklistDigest(digest, 1, "WebCacheTests_100kBytes");
            }
            catch (SoapException se)
            {
                if (se.Message.Contains("The web service encountered an internal error"))
                {
                    Global.RO.Success("Blacklist request failed as expected");
                    ValidateBlacklistDb(digest, true, 0);
                    return;
                }
                else
                    throw new UnexpectedTestResultException("Failed with unexpected exception: " + se);
            }

            throw new UnexpectedTestResultException("Did not expect call to succeed.");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Stats\Dll\wcStatCompactAttribute.cs ===
using System;
namespace xonline.server.webcache.stats.dll 
{
    struct StatsCompactAttribute
    {
        public int    id;
        public object value;

        public StatsCompactAttribute(int id, object value)
        {
            this.id    = id;
            this.value = value;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Signature\Test\test\FuncVerify.cs ===
using System;
using System.Xml;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.SignatureWidget;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Signature;
using XSigSignature = xonline.common.protocol.XSigSignature;

namespace Webcache.Signature.Test
{
    [TestGroup, Description("Signature webcache tests for VerifySignature")]
    public class FuncVerify : TestNode
    {
        static bool GetXMLSigData(XSigVerifySignatureRequest[] SigData)
        {
            // Load the signatures from the XML file
            XmlDocument signatures = new XmlDocument();
            signatures.Load("VerifyWidget.xml");
            XmlNodeList sigs = signatures.SelectNodes("/stf/signatures/sig");
            if (sigs != null)
            {
                uint i = 0;
                foreach (XmlNode sig in sigs)
                {
                    try
                    {
                        string name = sig.Attributes["name"].Value;
                        if (name.StartsWith("digest"))
                        {
                            SigData[i / 2]._digest = Hexer.unhex(sig.InnerText);
                        }
                        else if (name.StartsWith("signature"))
                        {
                            SigData[i / 2]._signature = Hexer.unhex(sig.InnerText);
                        }
                        else
                        {
                            ConsoleX.WriteLine("Invalid signature element found in xml.");
                            return false;
                        }
                    }
                    catch (Exception)
                    {
                        ConsoleX.WriteLine("Invalid signature element found in xml.");
                        return false;
                    }
                    i++;
                }
            }
            // Couldn't read any nodes in the XML file
            else
            {
                return false;
            }

            return true;
        }

        static bool VerifyHRArray(uint[] ResultArray, uint[] ExpectedArray, int count)
        {
            // The array's should match in size
            if (ResultArray.Length != ExpectedArray.Length)
                return false;

            // Check each service result,
            // return true only of all results are S_OK
            for (int i = 0; i < count; i++)
            {
                if (ResultArray[i] != ExpectedArray[i])
                    return false;
            }
            return true;
        }

        [TestCase, TestCasePriority(0), Description("Basic_Verify_Widget")]
        public class Basic_Verify_Widget : TestNode
        {
            public override void Run()
            {
                const int numSigs = 3;
                uint[] HRs = new uint[numSigs];
                uint[] ExpectedHRs = new uint[numSigs];

                // Our sig data structure
                XSigVerifySignatureRequest[] SigData = new XSigVerifySignatureRequest[numSigs];
                for (uint i = 0; i < SigData.Length; i++)
                {
                    SigData[i] = new XSigVerifySignatureRequest();
                }

                // This reads 3 pre-loaded signature/digest combinations that should 
                // all succeed from an XML file.
                if (!GetXMLSigData(SigData))
                    throw new UnexpectedTestResultException("Failed to load xml file.");

                // Create our widget reference
                WCSignature sw = new WCSignature();
                HRs = sw.VerifySignature(SigData);

                if (!VerifyHRArray(HRs, ExpectedHRs, SigData.Length))
                    throw new UnexpectedTestResultException("VerifyHRArray failed.");
            }
        }

        [TestCase, TestCasePriority(1), Description("Slightly_Off_Digest_Widget")]
        class Slightly_Off_Digest_Widget : TestNode
        {
            public override void Run()
            {
                const uint numSigs = 3;

                // Our sig data structure
                XSigVerifySignatureRequest[] SigData = new XSigVerifySignatureRequest[numSigs];
                for (uint i = 0; i < SigData.Length; i++)
                {
                    SigData[i] = new XSigVerifySignatureRequest();
                }

                // This reads 3 pre-loaded signature/digest combinations that should 
                // all succeed from an XML file.
                if (!GetXMLSigData(SigData))
                    throw new UnexpectedTestResultException("Failed to load xml file.");

                uint[] HRs = new uint[SigData.Length];
                uint[] ExpectedHRs = new uint[SigData.Length];

                // Now we twiddle one byte in each signature.  This should 
                // cause all of them to fail.
                for (uint i = 0; i < SigData.Length; i++)
                {
                    SigData[i]._digest[0]++;
                    ExpectedHRs[i] = HResult.XONLINE_E_SIGNATURE_VER_INVALID_SIGNATURE;
                }

                // Create our widget reference
                WCSignature sw = new WCSignature();
                HRs = sw.VerifySignature(SigData);

                if (!VerifyHRArray(HRs, ExpectedHRs, SigData.Length))
                    throw new UnexpectedTestResultException("VerifyHRArray failed.");
            }
        }

        [TestCase, TestCasePriority(1), Description("Signature_Invalid_N")]
        class Signature_Invalid_N : TestNode
        {
            public override void Run()
            {
                const uint numSigs = 8;

                // Some valid signatures
                byte[] someD = new byte[20];
                someD = Hexer.unhex("9bfdd64facb000ed405de78694df590bc3d2bf27");
                byte[] someS = new byte[100];
                someS = Hexer.unhex("01000100000000009ef0ec91fa5bc508559904a700e11b187c411dd4415d0900fcbabbbbbbfb0900fdbabbbbbbfb0900febabbbbbbfb0900ffbabbbbbbfb090000000000000000000000000000000000cf14e0946772333b6ac2ad5e2c583bbc26154a12");

                // Our sig data structure
                XSigVerifySignatureRequest[] SigData = new XSigVerifySignatureRequest[numSigs];
                for (uint i = 0; i < SigData.Length; i++)
                {
                    SigData[i] = new XSigVerifySignatureRequest();
                    SigData[i]._digest = someD;
                    SigData[i]._signature = someS;
                }

                uint[] HRs = new uint[SigData.Length];
                uint[] ExpectedHRs = new uint[SigData.Length];

                // Now set up a wire data signature so we can play with the attributes
                XSigSignature[] testSig = new XSigSignature[SigData.Length];

                // Now we have 8 wire data structures that we can appropriately mess with
                for (uint i = 0; i < SigData.Length; i++)
                {
                    testSig[i] = new XSigSignature();
                    testSig[i].ReadBytes(SigData[i]._signature);
                }

                // Set up each test signature to have the appropriate malfunction
                testSig[0]._signature[19]++;        // XONLINE_E_SIGNATURE_VER_INVALID_SIGNATURE
                ExpectedHRs[0] = HResult.XONLINE_E_SIGNATURE_VER_INVALID_SIGNATURE;

                testSig[1]._keyVersion = 0;        // XONLINE_E_SIGNATURE_VER_UNKNOWN_KEY_VER
                ExpectedHRs[1] = HResult.XONLINE_E_SIGNATURE_VER_UNKNOWN_KEY_VER;

                testSig[2]._signatureVersion++;    // XONLINE_E_SIGNATURE_VER_UNKNOWN_SIGNATURE_VER
                ExpectedHRs[2] = HResult.XONLINE_E_SIGNATURE_VER_UNKNOWN_SIGNATURE_VER;

                // XONLINE_E_SIGNATURE_BANNED_XBOX
                // ExpectedHRs[3] = HResult.XONLINE_E_SIGNATURE_BANNED_XBOX;

                // XONLINE_E_SIGNATURE_BANNED_USER
                // ExpectedHRs[4] = HResult.XONLINE_E_SIGNATURE_BANNED_USER;

                // XONLINE_E_SIGNATURE_BANNED_TITLE
                // ExpectedHRs[5] = HResult.XONLINE_E_SIGNATURE_BANNED_TITLE;

                // XONLINE_E_SIGNATURE_BANNED_DIGEST
                // ExpectedHRs[6] = HResult.XONLINE_E_SIGNATURE_BANNED_DIGEST;

                // testSig[7].machinePuid++;        // XONLINE_E_SIGNATURE_GET_BAD_AUTH_DATA
                // ExpectedHRs[7] = HResult.XONLINE_E_SIGNATURE_GET_BAD_AUTH_DATA;

                // Turn our signatures back into SigData
                // The WireData overloaded operator takes care of turning this
                // back into a byte[]
                for (uint i = 0; i < SigData.Length; i++)
                {
                    SigData[i]._signature = (byte[])testSig[i];
                }

                // Create our widget reference
                WCSignature sw = new WCSignature();
                HRs = sw.VerifySignature(SigData);

                if (!VerifyHRArray(HRs, ExpectedHRs, SigData.Length))
                    throw new UnexpectedTestResultException("VerifyHRArray failed.");
            }
        }

        [TestCase, TestCasePriority(1), Description("Verify_100_Valid_Signatures")]
        class Verify_100_Valid_Signatures : TestNode
        {
            public override void Run()
            {
                const uint numSigs = 100;
                uint[] HRs = new uint[numSigs];
                uint[] ExpectedHRs = new uint[numSigs];

                // A valid signature
                byte[] someD = new byte[20];
                someD = Hexer.unhex("9bfdd64facb000ed405de78694df590bc3d2bf27");
                byte[] someS = new byte[100];
                someS = Hexer.unhex("01000100000000009ef0ec91fa5bc508559904a700e11b187c411dd4415d0900fcbabbbbbbfb0900fdbabbbbbbfb0900febabbbbbbfb0900ffbabbbbbbfb090000000000000000000000000000000000cf14e0946772333b6ac2ad5e2c583bbc26154a12");

                // Our sig data structure
                XSigVerifySignatureRequest[] SigData = new XSigVerifySignatureRequest[numSigs];
                for (uint i = 0; i < SigData.Length; i++)
                {
                    SigData[i] = new XSigVerifySignatureRequest();
                    SigData[i]._digest = someD;
                    SigData[i]._signature = someS;
                }

                // Create our widget reference
                WCSignature sw = new WCSignature();
                HRs = sw.VerifySignature(SigData);

                if (!VerifyHRArray(HRs, ExpectedHRs, SigData.Length))
                    throw new UnexpectedTestResultException("VerifyHRArray failed.");
            }
        }

        // This test passes the limit imposed by URL scan and should fail.
        [TestCase, TestCasePriority(2), Description("Verify_101_Valid_Signatures")]
        class Verify_101_Valid_Signatures : TestNode
        {
            public override void Run()
            {
                const uint numSigs = 101;
                uint[] HRs = new uint[numSigs];
                uint[] ExpectedHRs = new uint[numSigs];

                // Some valid signatures
                byte[] someD = new byte[20];
                someD = Hexer.unhex("9bfdd64facb000ed405de78694df590bc3d2bf27");
                byte[] someS = new byte[100];
                someS = Hexer.unhex("01000100000000009ef0ec91fa5bc508559904a700e11b187c411dd4415d0900fcbabbbbbbfb0900fdbabbbbbbfb0900febabbbbbbfb0900ffbabbbbbbfb090000000000000000000000000000000000cf14e0946772333b6ac2ad5e2c583bbc26154a12");

                // Our sig data structure
                XSigVerifySignatureRequest[] SigData = new XSigVerifySignatureRequest[numSigs];
                for (uint i = 0; i < SigData.Length; i++)
                {
                    SigData[i] = new XSigVerifySignatureRequest();
                    SigData[i]._digest = someD;
                    SigData[i]._signature = someS;
                }

                // Create our widget reference
                WCSignature sw = new WCSignature();
                try
                {
                    HRs = sw.VerifySignature(SigData);
                    Global.RO.Error("Request seems to have succeeded, but it should not have.");
                }
                catch (Exception e)
                {
                    if (e.Message.Contains("Server was unable to process request.") && e.Message.Contains("The web service encountered an internal error."))
                    {
                        Global.RO.Debug("Got the expected exception: " + e.Message);
                        return;
                    }
                    else
                    {
                        throw new UnexpectedTestResultException("Expected a different exception than: " + e.Message);
                    }
                }

                throw new UnexpectedTestResultException("Did not expect request to succeed");
            }
        }

        [TestCase, TestCasePriority(1), Description("Verify_100_Invalid_Signatures")]
        class Verify_100_Invalid_Signatures : TestNode
        {
            public override void Run()
            {
                const uint numSigs = 100;
                uint[] HRs = new uint[numSigs];
                uint[] ExpectedHRs = new uint[numSigs];

                // Our sig data structure
                XSigVerifySignatureRequest[] SigData = new XSigVerifySignatureRequest[numSigs];
                for (uint i = 0; i < SigData.Length; i++)
                {
                    SigData[i] = new XSigVerifySignatureRequest();
                    SigData[i]._digest = new byte[20];
                    SigData[i]._signature = new byte[100];
                    ExpectedHRs[i] = HResult.XONLINE_E_SIGNATURE_VER_UNKNOWN_SIGNATURE_VER;
                }

                // Create our widget reference
                WCSignature sw = new WCSignature();
                HRs = sw.VerifySignature(SigData);

                if (!VerifyHRArray(HRs, ExpectedHRs, SigData.Length))
                    throw new UnexpectedTestResultException("VerifyHRArray failed.");
            }
        }

        [TestCase, TestCasePriority(2), Description("All_Zeros_Signature")]
        class All_Zeros_Signature : TestNode
        {
            public override void Run()
            {
                uint[] HRs = new uint[1];
                uint[] ExpectedHRs = new uint[1];
                ExpectedHRs[0] = HResult.XONLINE_E_SIGNATURE_VER_UNKNOWN_SIGNATURE_VER; // All 0's signature

                // Our sig data structure, just one, all zeros
                XSigVerifySignatureRequest[] SigData = new XSigVerifySignatureRequest[1];
                SigData[0] = new XSigVerifySignatureRequest();
                SigData[0]._digest = new byte[20];
                SigData[0]._signature = new byte[100];

                WCSignature sw = new WCSignature();
                HRs = sw.VerifySignature(SigData);

                if (!VerifyHRArray(HRs, ExpectedHRs, SigData.Length))
                    throw new UnexpectedTestResultException("VerifyHRArray failed.");
            }
        }

        // Basic_Create_Signature
        // TitleID = 0xB2D2
        [TestCase, TestCasePriority(1), Description("Basic_Create_Signature")]
        class Basic_Create_Signature : TestNode
        {
            public override void Run()
            {
                const int numSigs = 3;
                XSigCreateSignatureResponse[] SigResponse = new XSigCreateSignatureResponse[numSigs];
                uint[] ExpectedHRs = new uint[numSigs];
                uint[] HRs = new uint[numSigs];
                uint uiLocalTitleID = 0xB2D2;
                string adminId = "TestAdmin";

                // Our sig data structure
                XSigCreateSignatureRequest[] SigData = new XSigCreateSignatureRequest[numSigs];
                for (uint i = 0; i < SigData.Length; i++)
                {
                    SigData[i] = new XSigCreateSignatureRequest();
                    SigData[i]._digest = new byte[20];
                    RandomEx.GlobalRandGen.NextBytes(SigData[i]._digest);
                }

                // Create our widget reference
                WCSignature sw = new WCSignature();
                SigResponse = sw.CreateSignature(uiLocalTitleID, adminId, SigData);

                // Check for success
                for (uint i = 0; i < SigData.Length; i++)
                {
                    if (SigResponse[i]._hresult != ExpectedHRs[i])
                        throw new UnexpectedTestResultException("At index "+i+" hr was wrong: "+SigResponse[i]._hresult);
                }

                // Now lets verify what we just created
                XSigVerifySignatureRequest[] SigCheck = new XSigVerifySignatureRequest[numSigs];
                for (uint i = 0; i < SigCheck.Length; i++)
                {
                    SigCheck[i] = new XSigVerifySignatureRequest();
                    SigCheck[i]._signature = SigResponse[i]._signature;
                    SigCheck[i]._digest = SigData[i]._digest;
                }

                HRs = sw.VerifySignature(SigCheck);
                if (!VerifyHRArray(HRs, ExpectedHRs, SigCheck.Length))
                    throw new UnexpectedTestResultException("VerifyHRArray failed.");
            }
        }

        // Basic_Create_0Digest
        // TitleID = 0xB2D2
        // Digest = 0x0
        [TestCase, TestCasePriority(1), Description("Basic_Create_0Digest")]
        class Basic_Create_0Digest : TestNode
        {
            public override void Run()
            {
                const int numSigs = 3;
                XSigCreateSignatureResponse[] SigResponse = new XSigCreateSignatureResponse[numSigs];
                uint[] ExpectedHRs = new uint[numSigs];
                uint[] HRs = new uint[numSigs];
                uint uiLocalTitleID = 0xB2D2;
                string adminId = "TestAdmin";

                // Our sig data structure
                // The digest is empty
                XSigCreateSignatureRequest[] SigData = new XSigCreateSignatureRequest[numSigs];
                for (uint i = 0; i < SigData.Length; i++)
                {
                    SigData[i] = new XSigCreateSignatureRequest();
                    SigData[i]._digest = new byte[20];
                }

                // Create our widget reference
                WCSignature sw = new WCSignature();
                SigResponse = sw.CreateSignature(uiLocalTitleID, adminId, SigData);

                // Check for success
                for (uint i = 0; i < SigData.Length; i++)
                {
                    if (SigResponse[i]._hresult != ExpectedHRs[i])
                        throw new UnexpectedTestResultException("At index "+i+" hr was wrong: "+SigResponse[i]._hresult);
                }

                // Now lets verify what we just created
                XSigVerifySignatureRequest[] SigCheck = new XSigVerifySignatureRequest[numSigs];
                for (uint i = 0; i < SigCheck.Length; i++)
                {
                    SigCheck[i] = new XSigVerifySignatureRequest();
                    SigCheck[i]._signature = SigResponse[i]._signature;
                    SigCheck[i]._digest = SigData[i]._digest;
                }

                // Verify the signature exists
                HRs = sw.VerifySignature(SigCheck);
                if (!VerifyHRArray(HRs, ExpectedHRs, SigCheck.Length))
                    throw new UnexpectedTestResultException("VerifyHRArray failed.");
            }
        }

        // Basic_Create_MaxDigest
        // TitleID = 0xB2D2
        // Digest = 20 Bytes of FF
        [TestCase, TestCasePriority(1), Description("Basic_Create_MaxDigest")]
        class Basic_Create_MaxDigest : TestNode
        {
            public override void Run()
            {
                const int numSigs = 3;
                XSigCreateSignatureResponse[] SigResponse = new XSigCreateSignatureResponse[numSigs];
                uint[] ExpectedHRs = new uint[numSigs];
                uint[] HRs = new uint[numSigs];
                uint uiLocalTitleID = 0xB2D2;
                string adminId = "TestAdmin";

                // Our sig data structure
                // The digest is maxed out
                XSigCreateSignatureRequest[] SigData = new XSigCreateSignatureRequest[numSigs];
                for (uint i = 0; i < SigData.Length; i++)
                {
                    SigData[i] = new XSigCreateSignatureRequest();
                    SigData[i]._digest = new byte[20];
                    for (uint j = 0; j < SigData[i]._digest.Length; j++)
                    {
                        SigData[i]._digest[j] = 0xFF;
                    }
                }

                // Create our widget reference
                WCSignature sw = new WCSignature();
                SigResponse = sw.CreateSignature(uiLocalTitleID, adminId, SigData);

                // Check for success
                for (uint i = 0; i < SigData.Length; i++)
                {
                    if (SigResponse[i]._hresult != ExpectedHRs[i])
                        throw new UnexpectedTestResultException("At index "+i+" hr was wrong: "+SigResponse[i]._hresult);
                }

                // Now lets verify what we just created
                XSigVerifySignatureRequest[] SigCheck = new XSigVerifySignatureRequest[numSigs];
                for (uint i = 0; i < SigCheck.Length; i++)
                {
                    SigCheck[i] = new XSigVerifySignatureRequest();
                    SigCheck[i]._signature = SigResponse[i]._signature;
                    SigCheck[i]._digest = SigData[i]._digest;
                }

                HRs = sw.VerifySignature(SigCheck);
                if (!VerifyHRArray(HRs, ExpectedHRs, SigCheck.Length))
                    throw new UnexpectedTestResultException("VerifyHRArray failed.");
            }
        }

        // Create_Signature_BadAdmins
        // adminId = null, empty, weird characters
        [TestCase, TestCasePriority(2), Description("Create_Signature_BadAdmins")]
        class Create_Signature_BadAdmins : TestNode
        {
            public override void Run()
            {
                const int numSigs = 3;
                XSigCreateSignatureResponse[] SigResponse = new XSigCreateSignatureResponse[numSigs];
                uint[] ExpectedHRs = new uint[numSigs];
                uint[] HRs = new uint[numSigs];
                uint uiLocalTitleID = 0xB2D2;
                string[] adminId = new string[3] { null, "", "~!@#$%^&*()_+-={}[];':\",.<>/?\\|" };

                // Our sig data structure
                XSigCreateSignatureRequest[] SigData = new XSigCreateSignatureRequest[numSigs];
                for (uint i = 0; i < SigData.Length; i++)
                {
                    SigData[i] = new XSigCreateSignatureRequest();
                    SigData[i]._digest = new byte[20];
                    RandomEx.GlobalRandGen.NextBytes(SigData[i]._digest);
                }

                // Create our widget reference for each adminId
                WCSignature sw = new WCSignature();
                for (uint j = 0; j < adminId.Length; j++)
                {
                    SigResponse = sw.CreateSignature(uiLocalTitleID, adminId[j], SigData);

                    // Check for success
                    for (uint i = 0; i < SigData.Length; i++)
                    {
                        if (SigResponse[i]._hresult != ExpectedHRs[i])
                            throw new UnexpectedTestResultException("At index "+i+" hr was wrong: "+SigResponse[i]._hresult);
                    }

                    // Now lets verify what we just created
                    XSigVerifySignatureRequest[] SigCheck = new XSigVerifySignatureRequest[numSigs];
                    for (uint i = 0; i < SigCheck.Length; i++)
                    {
                        SigCheck[i] = new XSigVerifySignatureRequest();
                        SigCheck[i]._signature = SigResponse[i]._signature;
                        SigCheck[i]._digest = SigData[i]._digest;
                    }

                    HRs = sw.VerifySignature(SigCheck);
                    if (!VerifyHRArray(HRs, ExpectedHRs, SigCheck.Length))
                        throw new UnexpectedTestResultException("VerifyHRArray failed.");
                }
            }
        }

        // Create_Signature_InvalidTitleID
        // TitleID = 0, 0xFFFFFFFF, 666
        // (Max, Min, Doesn't exist or have permissions)
        [TestCase, TestCasePriority(2), Description("Create_Signature_InvalidTitleID")]
        class Create_Signature_InvalidTitleID : TestNode
        {
            public override void Run()
            {
                const int numSigs = 3;
                XSigCreateSignatureResponse[] SigResponse = new XSigCreateSignatureResponse[numSigs];
                uint[] ExpectedHRs = new uint[numSigs];
                uint[] HRs = new uint[numSigs];
                uint[] uiLocalTitleID = new uint[3] { uint.MinValue, uint.MaxValue, 666 };
                string adminId = "TestAdmin";

                // Our sig data structure
                XSigCreateSignatureRequest[] SigData = new XSigCreateSignatureRequest[numSigs];
                for (uint i = 0; i < SigData.Length; i++)
                {
                    SigData[i] = new XSigCreateSignatureRequest();
                    SigData[i]._digest = new byte[20];
                    RandomEx.GlobalRandGen.NextBytes(SigData[i]._digest);
                }

                // Create our widget reference
                WCSignature sw = new WCSignature();

                // We shouldn't have permission to these TitleIDs
                for (uint i = 0; i < uiLocalTitleID.Length; i++)
                {
                    try
                    {
                        SigResponse = sw.CreateSignature(uiLocalTitleID[i], adminId, SigData);
                        throw new UnexpectedTestResultException("Did not expect reques to succeed.");
                    }
                    catch (UnexpectedTestResultException)
                    {
                        throw; //pass this one on
                    }
                    catch (Exception e)
                    {
                        if (e.ToString().IndexOf("not allowed to access TitleID:") == -1)
                            throw new UnexpectedTestResultException("Wrong exception text thrown.");
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Signature\Test\test\StressVerify.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.Web.SignatureWidget;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;

namespace Webcache.Signature.Stress
{
    [StressTest(Priority = 15)]
    class StressVerifyValid : TestNode
    {
        public override void Run()
        {
            uint[] HRs = new uint[1];

            // Some valid signatures
            byte[] someD = new byte[20];
            someD = Hexer.unhex("9bfdd64facb000ed405de78694df590bc3d2bf27");
            byte[] someS = new byte[100];
            someS = Hexer.unhex("01000100000000009ef0ec91fa5bc508559904a700e11b187c411dd4415d0900fcbabbbbbbfb0900fdbabbbbbbfb0900febabbbbbbfb0900ffbabbbbbbfb090000000000000000000000000000000000cf14e0946772333b6ac2ad5e2c583bbc26154a12");

            // Our sig data structure
            XSigVerifySignatureRequest[] SigData = new XSigVerifySignatureRequest[1];
            for (uint i = 0; i < SigData.Length; i++)
            {
                SigData[i] = new XSigVerifySignatureRequest();
                SigData[i]._digest = someD;
                SigData[i]._signature = someS;
            }

            WCSignature sw = new WCSignature();
            HRs = sw.VerifySignature(SigData);
        }
    }

    [StressTest(Priority = 1)]
    class StressVerifyInValid : TestNode
    {
        public override void Run()
        {
            uint[] HRs = new uint[1];

            // Our sig data structure, just one, all zeros
            XSigVerifySignatureRequest[] SigData = new XSigVerifySignatureRequest[1];
            SigData[0] = new XSigVerifySignatureRequest();
            SigData[0]._digest = new byte[20];
            SigData[0]._signature = new byte[100];

            WCSignature sw = new WCSignature();
            HRs = sw.VerifySignature(SigData);
        }
    }

    [StressTest(Priority = 1)]
    class StressVerifyMax : TestNode
    {
        public override void Run()
        {
            uint[] HRs = new uint[1];

            // Some valid signatures
            byte[] someD = new byte[20];
            someD = Hexer.unhex("9bfdd64facb000ed405de78694df590bc3d2bf27");
            byte[] someS = new byte[100];
            someS = Hexer.unhex("01000100000000009ef0ec91fa5bc508559904a700e11b187c411dd4415d0900fcbabbbbbbfb0900fdbabbbbbbfb0900febabbbbbbfb0900ffbabbbbbbfb090000000000000000000000000000000000cf14e0946772333b6ac2ad5e2c583bbc26154a12");

            // 100 valid signatures - w/ URLScan this is the maximum request
            XSigVerifySignatureRequest[] SigData = new XSigVerifySignatureRequest[100];
            for (uint i = 0; i < SigData.Length; i++)
            {
                SigData[i] = new XSigVerifySignatureRequest();
                SigData[i]._digest = someD;
                SigData[i]._signature = someS;
            }

            WCSignature sw = new WCSignature();
            HRs = sw.VerifySignature(SigData);
        }
    }

    [StressTest(Priority = 150)]
    class StressCreate1Sig : TestNode
    {
        public static uint numSigs = 1;
        public static uint uiLocalTitleID = 0xB2D2;
        public static WCSignature sw = new WCSignature();
        public static string adminId = "StressAdmin";
        public static XSigCreateSignatureRequest[] SigData = new XSigCreateSignatureRequest[numSigs];
        public static XSigCreateSignatureResponse[] SigResponse = new XSigCreateSignatureResponse[numSigs];

        public StressCreate1Sig()
        {
            // Allocate all of our data structures.
            for (uint i = 0; i < SigData.Length; i++)
            {
                SigData[i] = new XSigCreateSignatureRequest();
                SigResponse[i] = new XSigCreateSignatureResponse();
                SigData[i]._digest = new byte[20];
                RandomEx.GlobalRandGen.NextBytes(SigData[i]._digest);
            }
        }

        public override void Run()
        {
            uint[] ExpectedHRs = new uint[numSigs];

            SigResponse = sw.CreateSignature(uiLocalTitleID, adminId, SigData);

            // Check for success
            for (uint i = 0; i < SigData.Length; i++)
            {
                if (SigResponse[i]._hresult != ExpectedHRs[i])
                    throw new UnexpectedTestResultException("At index "+i+" hr was wrong: "+SigResponse[i]._hresult);
            }
        }
    }

    [StressTest(Priority = 10)]
    class StressCreate100Sig : TestNode
    {
        public static uint numSigs = 100;
        public static uint uiLocalTitleID = 0xB2D2;
        public static WCSignature sw = new WCSignature();
        public static string adminId = "StressAdmin";
        public static XSigCreateSignatureRequest[] SigData = new XSigCreateSignatureRequest[numSigs];
        public static XSigCreateSignatureResponse[] SigResponse = new XSigCreateSignatureResponse[numSigs];

        public StressCreate100Sig()
        {
            // Allocate all of our data structures.
            for (uint i = 0; i < SigData.Length; i++)
            {
                SigData[i] = new XSigCreateSignatureRequest();
                SigResponse[i] = new XSigCreateSignatureResponse();
                SigData[i]._digest = new byte[20];
                RandomEx.GlobalRandGen.NextBytes(SigData[i]._digest);
            }
        }

        public override void Run()
        {
            uint[] ExpectedHRs = new uint[numSigs];

            SigResponse = sw.CreateSignature(uiLocalTitleID, adminId, SigData);

            // Check for success
            for (uint i = 0; i < SigData.Length; i++)
            {
                if (SigResponse[i]._hresult != ExpectedHRs[i])
                    throw new UnexpectedTestResultException("At index "+i+" hr was wrong: "+SigResponse[i]._hresult);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Stats\Dll\wcStats.cs ===
//
// Stats.cs
//
// Copyright (C) Microsoft Corporation.  All Rights Reserved.
//

#if DEBUG
    #define TEST_HOOKS
    #define TEST_MGMT_COMMANDS
#else
    #define TEST_MGMT_COMMANDS
#endif

using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Web;
using System.Web.Services;
using System.Web.Caching;
using System.Threading;
using System.IO;
using System.Text;
using System.Xml.Serialization;

using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.protocol;
using xonline.server.webcache.common;
using xonline.common.config;
using xonline.common.installer;
using xonline.stats.admin;

using perf = xonline.server.webcache.stats.dll.WebCacheStatsCounter;

[assembly: XomIisInstallerAttribute( Interface.wcstats )]
[assembly: ConfigAttribute(xonline.common.config.Component.wcstats)]

[assembly: XomAreaDefinition(XomAreaName.wcstatstrace)]
[assembly: XomAreaDefinition(XomAreaName.wcstatslog)]
[assembly: XomAreaDefinition(XomAreaName.wcstatscache)]
[assembly: XomAreaDefinition(XomAreaName.wcstatsdomain)]

namespace xonline.server.webcache.stats.dll
{
    //
    // The Stats class implements the statistics web service.
    //
    [WebService(Namespace="http://websvc.xboxlive.com/Stats/")]
    public class Stats : System.Web.Services.WebService
    {
        public const ushort MAX_READ_LEADERBOARDS                 = 10;

        public Stats()
            : this(true)
        {
        }
        
        //Only been added to fail healthcheck if the global object is not Inited yet
        public bool IsGlobalInitComplete() { return glob.IsInited(); }

        public Stats(bool verifyCallSource)
        {
            try
            {
                //CODEGEN: This call is required by the ASP.NET Web Services Designer
                InitializeComponent();

                if (verifyCallSource)
                {
                    CallSource.Check(VirtualInterface.wcstats);
                }

                glob = StatsGlobal.Instance;
            }
            catch (XboxWebException)
            {
                throw;
            }
            catch (Exception e)
            {
                XEvent.Id eventId = (e is ExceptionWithEvent) ? ((ExceptionWithEvent) e).EventId : XEvent.Id.WEBCACHE_CODE_71;
                throw new XboxWebInternalException(eventId, e);
            }
        }

        #region Component Designer generated code

        //Required by the Web Services Designer
        private IContainer components = null;

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
        }

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        protected override void Dispose( bool disposing )
        {
            if(disposing && components != null)
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #endregion

        //
        // WebMethods
        //
        [WebMethod]
        public DeleteXUIDStatus DeleteXUIDFromLB(
            uint  uiTitleID,
            uint  uiLbId,
            ulong xuid
            )
        {
            DeleteXUIDStatus ret = DeleteXUIDStatus.Success;

            do
            {
                try
                {
                    glob.CheckAPIAndTitle("Stats.DeleteXUIDFromLB", uiTitleID, TitlePrivilege.ReadWrite);
                    string partnerName = Utilities.GetSubjectName();

                    IncrementGlobalRequestCounter(partnerName);

                    perf.ctr.DeleteXUIDFromLBPerSecond.Increment();
                    perf.ctr.DeleteXUIDFromLBTotal    .Increment();

                    if (partnerName != null)
                    {
                        perf.ctr[partnerName].DeleteXUIDFromLBPerSecond.Increment();
                        perf.ctr[partnerName].DeleteXUIDFromLBTotal    .Increment();
                    }

                    ArrayList arrLBInfo = glob.GetTitleInfo(uiTitleID);
                    if (arrLBInfo == null || arrLBInfo.Count == 0)
                    {
                        ret = DeleteXUIDStatus.Error_Invalid_Title;
                        break;
                    }

                    StatsLBInfo lbInfo = null;
                    try
                    {
                        lbInfo = glob.GetLBInfo(uiTitleID, uiLbId);
                    }
                    catch (LBIDNotFoundException)
                    {
                        ret = DeleteXUIDStatus.Error_Invalid_Lb_ID;
                        break;
                    }

                    string szGamerTag = glob.LookupGamerTag(xuid);
                    if (szGamerTag == "??????")
                    {
                        ret = DeleteXUIDStatus.Error_Invalid_Xuid;
                        break;
                    }

                    //now check if the user exists in this leaderboard
                    uint uiValidSeconds = 0;
                    LBResults result = InternalGetLBForGamerTags(false, uiTitleID, uiLbId, new string[]{szGamerTag}, out uiValidSeconds);
                    if (result.Entries.Length == 0) //entries is never null
                    {
                        ret = DeleteXUIDStatus.Warning_No_OP;
                        break;
                    }

                    DbLeaderboard.RemoveUsersStats((int)uiTitleID, (int)uiLbId, (long)xuid);
                }
                catch (XboxWebException)
                {
                    throw;
                }
                catch (Exception e)
                {
                    throw new XboxWebInternalException(XEvent.Id.WEBCACHE_GENERIC_INTERNAL_ERROR_WHILE_DELETE_XUID, e);
                }
                finally
                {

                }
            }
            while (false);

            return ret;
        }


        [WebMethod]
        public DeleteXUIDStatus DeleteXUIDFromAllLBs(
            uint  uiTitleID,
            ulong xuid
            )
        {
            DeleteXUIDStatus ret = DeleteXUIDStatus.Success;

            do
            {
                try
                {
                    glob.CheckAPIAndTitle("Stats.DeleteXUIDFromAllLBs", uiTitleID, TitlePrivilege.ReadWrite);
                    string partnerName = Utilities.GetSubjectName();

                    IncrementGlobalRequestCounter(partnerName);

                    perf.ctr.DeleteXUIDFromAllLBsPerSecond.Increment();
                    perf.ctr.DeleteXUIDFromAllLBsTotal    .Increment();

                    if (partnerName != null)
                    {
                        perf.ctr[partnerName].DeleteXUIDFromAllLBsPerSecond.Increment();
                        perf.ctr[partnerName].DeleteXUIDFromAllLBsTotal    .Increment();
                    }

                    ArrayList arrLBInfo = glob.GetTitleInfo(uiTitleID);
                    if (arrLBInfo == null || arrLBInfo.Count == 0)
                    {
                        ret = DeleteXUIDStatus.Error_Invalid_Title;
                        break;
                    }

                    string szGamerTag = glob.LookupGamerTag(xuid);
                    if (szGamerTag == "??????")
                    {
                        ret = DeleteXUIDStatus.Error_Invalid_Xuid;
                        break;
                    }

                    ret = DeleteXUIDStatus.Warning_No_OP; //assume nothing is done
                    //now iterate through all leaderboards
                    foreach (StatsLBInfo statslbInfo in arrLBInfo)
                    {
                        //now check if the user exists in this leaderboard
                        uint uiValidSeconds = 0;
                        LBResults result = InternalGetLBForGamerTags(false, uiTitleID, statslbInfo.LBID, new string[]{szGamerTag}, out uiValidSeconds);
                        if (result.Entries.Length == 0)
                        {
                            continue;
                        }

                        DbLeaderboard.RemoveUsersStats((int)uiTitleID, (int)statslbInfo.LBID, (long)xuid);
                        ret = DeleteXUIDStatus.Success;
                    }

                }
                catch (XboxWebException)
                {
                    throw;
                }
                catch (Exception e)
                {
                    throw new XboxWebInternalException(XEvent.Id.WEBCACHE_GENERIC_INTERNAL_ERROR_WHILE_DELETE_XUID_FOR_ALL_LB, e);
                }
                finally
                {

                }
            }
            while (false);

            return ret;
        }

        private LBInfo[] InternalGetLBList(uint TitleID)
        {
                ArrayList lbs        = glob.GetTitleInfo(TitleID);
                ArrayList     lbInfoList = new ArrayList(lbs.Count);

                for (int i = 0; i < lbs.Count; i++)
                {
                    if(((StatsLBInfo)lbs[i]).LeaderboardType == LBType.Regular // Return only regular leaderboards.
                       && !((StatsLBInfo)lbs[i]).DontList)                     // Do not include lbs with the DontList flag.
                        lbInfoList.Add(((StatsLBInfo)lbs[i]).GetLBInfo());
                }

                return (LBInfo[]) lbInfoList.ToArray(typeof(LBInfo));
        }

        [WebMethod]
        public LBInfo[] GetLBList(
            uint TitleID,
            out uint ValidSeconds
            )
        {
            uint ok = 0;

            try
            {
                glob.CheckAPIAndTitle( "Stats.GetLBList", TitleID, TitlePrivilege.ReadOnly );

                perf.ctr.RequestsPerSecond .Increment();
                perf.ctr.RequestsTotal     .Increment();
                perf.ctr.GetLBListPerSecond.Increment();
                perf.ctr.GetLBListTotal    .Increment();

                string partnerName = Utilities.GetSubjectName();
                if (partnerName != null)
                {
                    perf.ctr[partnerName].RequestsPerSecond .Increment();
                    perf.ctr[partnerName].RequestsTotal     .Increment();
                    perf.ctr[partnerName].GetLBListPerSecond.Increment();
                    perf.ctr[partnerName].GetLBListTotal    .Increment();
                }
                LBInfo[] lbInfo = InternalGetLBList(TitleID);
                ValidSeconds    = glob.LbListRefreshRate;

                ok = 1;
                return lbInfo;
            }
            catch (XboxWebException)
            {
                throw;
            }
            catch (Exception e)
            {
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_CODE_72, e);
            }
            finally
            {
                string szLog = glob.BuildLogLine("GetLBList", ok, TitleID.ToString("X"));

                Xom.Log(XomAreaName.wcstatslog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );
            }
        }

        [WebMethod]
        public LBInfo[] GetLBListByType(
            uint     TitleID,
            LBType   LeaderboardType,
            out uint ValidSeconds
            )
        {
            uint ok = 0;

            try
            {
                glob.CheckAPIAndTitle( "Stats.GetLBListByType", TitleID, TitlePrivilege.ReadOnly );

                perf.ctr.RequestsPerSecond       .Increment();
                perf.ctr.RequestsTotal           .Increment();
                perf.ctr.GetLBListByTypePerSecond.Increment();
                perf.ctr.GetLBListByTypeTotal    .Increment();

                string partnerName = Utilities.GetSubjectName();
                if (partnerName != null)
                {
                    perf.ctr[partnerName].RequestsPerSecond       .Increment();
                    perf.ctr[partnerName].RequestsTotal           .Increment();
                    perf.ctr[partnerName].GetLBListByTypePerSecond.Increment();
                    perf.ctr[partnerName].GetLBListByTypeTotal    .Increment();
                }

                ArrayList lbs        = glob.GetTitleInfo(TitleID);
                ArrayList     lbInfoList = new ArrayList(lbs.Count);

                for (int i = 0; i < lbs.Count; i++)
                {
                    if(((StatsLBInfo)lbs[i]).LeaderboardType == LeaderboardType // Return only leaderboards with the request type
                       && !((StatsLBInfo)lbs[i]).DontList)                      // Do not include lbs with the DontList flag.
                    {
                        lbInfoList.Add(((StatsLBInfo)lbs[i]).GetLBInfo());
                    }
                }

                LBInfo[] lbInfo = (LBInfo[]) lbInfoList.ToArray(typeof(LBInfo));
                ValidSeconds     = glob.LbListRefreshRate;

                ok = 1;
                return lbInfo;
            }
            catch (XboxWebException)
            {
                throw;
            }
            catch (Exception e)
            {
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_CODE_73, e);
            }
            finally
            {
                string szLog = glob.BuildLogLine("GetLBListByType", ok, TitleID.ToString("X"));

                Xom.Log(XomAreaName.wcstatslog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );
            }
        }

        [WebMethod]
        public DetailedLBResults EnumerateLB(
            uint TitleID,
            uint LBID,
            uint StartIndex,
            uint MaxEntries,
            out uint ValidSeconds )
        {
            return InternalEnumerateLB(false, TitleID, LBID, StartIndex, MaxEntries, out ValidSeconds);
        }

        [WebMethod]
        public DetailedLBResults GetLBNearGamerTag(
            uint TitleID,
            uint LBID,
            string GamerTag,
            uint NumAbove,
            uint NumBelow,
            out uint ValidSeconds )
        {
            return InternalGetLBNearGamerTag(false, TitleID, LBID, GamerTag, NumAbove, NumBelow, out ValidSeconds);
        }

        [WebMethod]
        public LBResults GetLBForGamerTags(
            uint TitleID,
            uint LBID,
            string[] GamerTagList,
            out uint ValidSeconds )
        {
            return InternalGetLBForGamerTags(false, TitleID, LBID, GamerTagList, out ValidSeconds);
        }

        [WebMethod]
        public DetailedLBResults GetLBDetailsForGamerTags(
            uint TitleID,
            uint LBID,
            string[] GamerTagList,
            out uint ValidSeconds )
        {
            return InternalGetLBDetailsForGamerTags(false, TitleID, LBID, GamerTagList, out ValidSeconds);
        }

        [WebMethod]
        public DetailedMLBResults GetMLBByXUID(uint TitleID, ulong puid, uint[] LBIDs) {
            DetailedMLBResults res = new DetailedMLBResults();
            res.G = glob.LookupGamerTag(puid);

        // TODO - We are passing EventIds as HRs?

            if (LBIDs == null)
            {
                throw new XboxWebClientException((uint) XEvent.Id.WEBCACHE_CODE_63, "The leaderboard id array is null");
            }
            if (LBIDs.Length > MAX_READ_LEADERBOARDS)
            {
                throw new XboxWebClientException((uint) XEvent.Id.WEBCACHE_CODE_64, "The leaderboard array is too long");
            }
            if (res.G == "??????")
            {
                throw new XboxWebClientException((uint) XEvent.Id.WEBCACHE_CODE_65, "Invalid xuid");
            }
            try {
                glob.CheckAPIAndTitle("Stats.GetMLBByXUID", TitleID, TitlePrivilege.ReadOnly);

                perf.ctr.RequestsPerSecond       .Increment();
                perf.ctr.RequestsTotal           .Increment();
                perf.ctr.GetMLBByXUIDPerSecond.Increment();
                perf.ctr.GetMLBByXUIDTotal    .Increment();

                string partnerName = Utilities.GetSubjectName();
                if (partnerName != null)
                {
                    perf.ctr[partnerName].RequestsPerSecond       .Increment();
                    perf.ctr[partnerName].RequestsTotal           .Increment();
                    perf.ctr[partnerName].GetMLBByXUIDPerSecond.Increment();
                    perf.ctr[partnerName].GetMLBByXUIDTotal    .Increment();
                }

                StatsReadRequest req  = new StatsReadRequest();
                List<StatsSpec> list = new List<StatsSpec>();
                List<bool> bList = new List<bool>();
                LBInfo[] lbInfo = InternalGetLBList(TitleID);
                uint[] ids = new uint[lbInfo.Length];
                for (int i = 0; i < ids.Length; i ++)
                {
                    ids[i] = lbInfo[i].LBID;
                }
                Array.Sort(ids, lbInfo);

                foreach (uint LBID in LBIDs)
                {
                    int i = Array.BinarySearch(ids, LBID);
                    if (i < 0) continue;
                    bool hasRating = false;
                    StatsSpec ss = new StatsSpec();
                    ss.ViewId = LBID;
                    LBAttributeInfo[] attribs = lbInfo[i].AttributeInfo;
                    List<ushort> cols = new List <ushort>();
                    for (int j = 0; j < attribs.Length; j++)
                    {
                        ushort cid = ushort.Parse(attribs[j].ID);
                        if (cid == SpecialAttrib.Rating)
                            hasRating = true;

                        //note: doesnt support getting Nickname right now.
                        if (cid != SpecialAttrib.Rank && cid != SpecialAttrib.Rating && cid != SpecialAttrib.LeaderboardSize && cid != SpecialAttrib.Nickname)
                            cols.Add(cid);
                    }
                    ss.ColumnIds = cols.ToArray();
                    list.Add(ss);
                    bList.Add(hasRating);
                }

                req.TitleId = TitleID;
                req.UserCount = 1;
                req.Users = new ulong[] {puid};
                req.SpecCount = (uint) list.Count;
                req.Specs = list.ToArray();

                MemoryStream memStream    = new MemoryStream();
                BinaryWriter writer = new BinaryWriter(memStream);
                req.WriteToResponse(writer, (UTF8Encoding) Encoding.UTF8);

                IVirtualInterfaceInfo vii = xonline.common.config.Config.GetVirtualInterface(VirtualInterface.xstatsfd_int, xonline.common.config.Site.same);
                string url = string.Format("http://{0}:{1}{2}", vii.IPAddressString, vii.Port, req.GetXRL());
                byte[] repBytes = Utilities.Instance.StatsFrontDoorRequest(XOService.Stats, url, puid, req.TitleId, memStream.ToArray());
                BinaryReader br = new BinaryReader(new MemoryStream(repBytes));

                StatsReadResponse rep = new StatsReadResponse();
                rep.ReadStream(br);

                StatsResultSet[] ret = rep.Results;
                List<DetailedMLBEntry> lbList = new List<DetailedMLBEntry>();

                for (int i = 0; i < ret.Length; i++)
                {
                    DetailedMLBEntry dme = new DetailedMLBEntry();
                    dme.LBID = (uint) ret[i].ViewId;
                    dme.R = ret[i].Rows[0].Rank;
                    int n = ret[i].Rows[0].Columns.Length;
                    if (bList[i])
                    {
                        dme.F = new LBEntryAttribute[n + 1];
                        dme.F[n].ID = "" + SpecialAttrib.Rating;
                        dme.F[n].V = "" + ret[i].Rows[0].Rating;
                    }
                    else
                    {
                        dme.F = new LBEntryAttribute[n];
                    }
                    bool nullData = true;
                    for (int j = 0; j < n; j++)
                    {
                        if (ret[i].Rows[0].Columns[j].Type != StatParam.Null)
                            nullData = false;
                        dme.F[j].ID = "" + ret[i].Rows[0].Columns[j].ColumnId;
                        dme.F[j].V = "" + ret[i].Rows[0].Columns[j].Data;
                    }
                    if (nullData && dme.R == 0) continue;
                    dme.TotalLBEntries = ret[i].ViewSize;
                    lbList.Add(dme);
                }
                res.Entries = lbList.ToArray();
                return res;
            }
            catch (XboxWebException)
            {
                throw;
            }
            catch (Exception e)
            {
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_CODE_73, e);
            }
        }

        [WebMethod]
        public DetailedLBResults EnumerateTeamLB(
            uint TitleID,
            uint LBID,
            uint StartIndex,
            uint MaxEntries,
            out uint ValidSeconds )
        {
            return InternalEnumerateLB(true, TitleID, LBID, StartIndex, MaxEntries, out ValidSeconds);
        }

        [WebMethod]
        public DetailedLBResults GetTeamLBNearTeamName(
            uint TitleID,
            uint LBID,
            string TeamName,
            uint NumAbove,
            uint NumBelow,
            out uint ValidSeconds )
        {
            return InternalGetLBNearGamerTag(true, TitleID, LBID, TeamName, NumAbove, NumBelow, out ValidSeconds);
        }

        [WebMethod]
        public LBResults GetTeamLBForTeamNames(
            uint TitleID,
            uint LBID,
            string[] TeamNameList,
            out uint ValidSeconds )
        {
            return InternalGetLBForGamerTags(true, TitleID, LBID, TeamNameList, out ValidSeconds);
        }

        [WebMethod]
        public DetailedLBResults GetTeamLBDetailsForTeamNames(
            uint TitleID,
            uint LBID,
            string[] TeamNameList,
            out uint ValidSeconds )
        {
            return InternalGetLBDetailsForGamerTags(true, TitleID, LBID, TeamNameList, out ValidSeconds);
        }

        [WebMethod]
        public RawLBResults EnumerateLBRaw(
            uint TitleID,
            uint LBID,
            uint StartIndex,
            uint MaxEntries,
            out uint ValidSeconds )
        {
            int  entries = 0;
            uint valSec  = 0;
            uint ok      = 0;

            try
            {
                glob.CheckAPIAndTitle( "Stats.EnumerateLBRaw", TitleID, TitlePrivilege.ReadOnly );
                glob.CheckRawEnumerationRange(StartIndex, MaxEntries);

                perf.ctr.RequestsPerSecond      .Increment();
                perf.ctr.RequestsTotal          .Increment();
                perf.ctr.EnumerateLBRawPerSecond.Increment();
                perf.ctr.EnumerateLBRawTotal    .Increment();

                string partnerName = Utilities.GetSubjectName();
                if (partnerName != null)
                {
                    perf.ctr[partnerName].RequestsPerSecond      .Increment();
                    perf.ctr[partnerName].RequestsTotal          .Increment();
                    perf.ctr[partnerName].EnumerateLBRawPerSecond.Increment();
                    perf.ctr[partnerName].EnumerateLBRawTotal    .Increment();
                }

                RawLBResults rlbr = GetLBRangeRaw(glob.GetLBInfo(TitleID, LBID),
                                                  StartIndex, StartIndex + MaxEntries - 1, out ValidSeconds);

                ok      = 1;
                valSec  = ValidSeconds;
                entries = rlbr.Entries.Length;

                return rlbr;
            }
            catch (XboxWebException)
            {
                throw;
            }
            catch (Exception e)
            {
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_CODE_74, e);
            }
            finally
            {
                string szLog = glob.BuildLogLineLB("EnumerateLBRaw",
                                                    ok, TitleID, LBID, entries, valSec,
                                                    StartIndex.ToString("X"),
                                                    MaxEntries.ToString("X"));

                Xom.Log(XomAreaName.wcstatslog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );
            }
        }

        protected DetailedLBResults InternalEnumerateLB(
            bool isTeamReq,
            uint TitleID,
            uint LBID,
            uint StartIndex,
            uint MaxEntries,
            out uint ValidSeconds)
        {
            int  entries = 0;
            uint valSec  = 0;
            uint ok      = 0;

            try
            {
                glob.CheckAPIAndTitle((isTeamReq ? "Stats.EnumerateTeamLB" : "Stats.EnumerateLB"), TitleID,
                                      TitlePrivilege.ReadOnly );
                glob.CheckEnumerationRange(StartIndex, MaxEntries);

                perf.ctr.RequestsPerSecond   .Increment();
                perf.ctr.RequestsTotal       .Increment();
                if(isTeamReq)
                {
                    perf.ctr.EnumerateTeamLBPerSecond.Increment();
                    perf.ctr.EnumerateTeamLBTotal    .Increment();
                }
                else
                {
                    perf.ctr.EnumerateLBPerSecond.Increment();
                    perf.ctr.EnumerateLBTotal    .Increment();
                }

                string partnerName = Utilities.GetSubjectName();
                if (partnerName != null)
                {
                    perf.ctr[partnerName].RequestsPerSecond   .Increment();
                    perf.ctr[partnerName].RequestsTotal       .Increment();
                    if(isTeamReq)
                    {
                        perf.ctr[partnerName].EnumerateTeamLBPerSecond.Increment();
                        perf.ctr[partnerName].EnumerateTeamLBTotal    .Increment();
                    }
                    else
                    {
                        perf.ctr[partnerName].EnumerateLBPerSecond.Increment();
                        perf.ctr[partnerName].EnumerateLBTotal    .Increment();
                    }
                }

                StatsLBInfo lb = glob.GetLBInfoAndCheckType(TitleID, LBID, isTeamReq);

                if(lb.LeaderboardType == LBType.CompetitionTemplate
                   || lb.LeaderboardType == LBType.CompetitionTemplateTeam)
                {
                    lb = lb.CreateStatsLBInfoForCompetitionLeaderboard(LBID);
                }

                DetailedLBResults lbr = GetLBRangeFormatted(lb, StartIndex, StartIndex + MaxEntries - 1, out ValidSeconds);

                ok      = 1;
                valSec  = ValidSeconds;
                entries = lbr.Entries.Length;

                return lbr;
            }
            catch (XboxWebException)
            {
                throw;
            }
            catch (Exception e)
            {
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_CODE_75, e);
            }
            finally
            {
                string szLog = glob.BuildLogLineLB((isTeamReq ? "EnumerateTeamLB" : "EnumerateLB"),
                                                    ok, TitleID, LBID, entries, valSec,
                                                    StartIndex.ToString("X"),
                                                    MaxEntries.ToString("X"));

                Xom.Log(XomAreaName.wcstatslog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );
            }
        }

        // returns empty array in LBResults.Entries if GamerTag not found
        protected DetailedLBResults InternalGetLBNearGamerTag(
            bool isTeamReq,
            uint TitleID,
            uint LBID,
            string GamerTag,
            uint NumAbove,
            uint NumBelow,
            out uint ValidSeconds )
        {
            int  entries = 0;
            uint valSec  = 0;
            uint ok      = 0;

            try
            {
                glob.CheckAPIAndTitle((isTeamReq ? "Stats.GetTeamLBNearTeamName" : "Stats.GetLBNearGamerTag"), TitleID,
                                      TitlePrivilege.ReadOnly );
                glob.CheckGetNearRange(NumAbove, NumBelow);

                if(GamerTag == null || GamerTag == String.Empty)
                    throw new InvalidParameterException(isTeamReq ? "TeamName" : "GamerTag", "Parameter cannot be empty or null");

                perf.ctr.RequestsPerSecond         .Increment();
                perf.ctr.RequestsTotal             .Increment();
                if(isTeamReq)
                {
                    perf.ctr.GetTeamLBNearTeamNamePerSecond.Increment();
                    perf.ctr.GetTeamLBNearTeamNameTotal    .Increment();
                }
                else
                {
                    perf.ctr.GetLBNearGamerTagPerSecond.Increment();
                    perf.ctr.GetLBNearGamerTagTotal    .Increment();
                }

                string partnerName = Utilities.GetSubjectName();
                if (partnerName != null)
                {
                    perf.ctr[partnerName].RequestsPerSecond         .Increment();
                    perf.ctr[partnerName].RequestsTotal             .Increment();
                    if(isTeamReq)
                    {
                        perf.ctr[partnerName].GetTeamLBNearTeamNamePerSecond.Increment();
                        perf.ctr[partnerName].GetTeamLBNearTeamNameTotal    .Increment();
                    }
                    else
                    {
                        perf.ctr[partnerName].GetLBNearGamerTagPerSecond.Increment();
                        perf.ctr[partnerName].GetLBNearGamerTagTotal    .Increment();
                    }
                }

                StatsLBInfo lb = glob.GetLBInfoAndCheckType(TitleID, LBID, isTeamReq);

                if(lb.LeaderboardType == LBType.CompetitionTemplate
                   || lb.LeaderboardType == LBType.CompetitionTemplateTeam)
                {
                    lb = lb.CreateStatsLBInfoForCompetitionLeaderboard(LBID);
                }

                uint rank = glob.GetRankForGamerTag(lb, GamerTag);
                DetailedLBResults res;

                if (rank > 0)
                {
                    uint start = (rank > NumAbove) ? (rank - NumAbove) : 1;
                    uint end   = rank + NumBelow;

                    res = GetLBRangeFormatted(lb, start, end, out ValidSeconds);
                }
                else
                {
                    // GamerTag not found in leaderboard
                    res.LBLastResetDate = lb.LastResetTime;
                    res.TotalLBEntries  = lb.TotalEntries;
                    res.Entries         = new DetailedLBEntry[0];
                    ValidSeconds        = lb.ValidSeconds(DateTime.Now);
                }

                entries = res.Entries.Length;
                valSec  = ValidSeconds;
                ok      = 1;

                return res;
            }
            catch (XboxWebException)
            {
                throw;
            }
            catch (Exception e)
            {
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_CODE_76, e);
            }
            finally
            {
                string szLog = glob.BuildLogLineLB((isTeamReq ? "GetTeamLBNearTeamName" : "GetLBNearGamerTag"),
                                                    ok, TitleID, LBID, entries, valSec,
                                                    GamerTag,
                                                    NumAbove.ToString("X"),
                                                    NumBelow.ToString("X"));

                Xom.Log(XomAreaName.wcstatslog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );
            }
        }

        // returns empty list in LBResults.Entries if GamerTag not found
        protected LBResults InternalGetLBForGamerTags(
            bool isTeamReq,
            uint TitleID,
            uint LBID,
            string[] GamerTagList,
            out uint ValidSeconds )
        {
            int  entries = 0;
            uint valSec  = 0;
            uint ok      = 0;

            try
            {
                glob.CheckAPIAndTitle((isTeamReq ? "Stats.GetLBForTeamNames" : "Stats.GetLBForGamerTags"), TitleID,
                                      TitlePrivilege.ReadOnly );
                glob.CheckTagListLength(GamerTagList.Length);

                perf.ctr.RequestsPerSecond         .Increment();
                perf.ctr.RequestsTotal             .Increment();
                if(isTeamReq)
                {
                    perf.ctr.GetTeamLBForTeamNamesPerSecond.Increment();
                    perf.ctr.GetTeamLBForTeamNamesTotal    .Increment();
                }
                else
                {
                    perf.ctr.GetLBForGamerTagsPerSecond.Increment();
                    perf.ctr.GetLBForGamerTagsTotal    .Increment();
                }

                string partnerName = Utilities.GetSubjectName();
                if (partnerName != null)
                {
                    perf.ctr[partnerName].RequestsPerSecond         .Increment();
                    perf.ctr[partnerName].RequestsTotal             .Increment();
                    if(isTeamReq)
                    {
                        perf.ctr[partnerName].GetTeamLBForTeamNamesPerSecond.Increment();
                        perf.ctr[partnerName].GetTeamLBForTeamNamesTotal    .Increment();
                    }
                    else
                    {
                        perf.ctr[partnerName].GetLBForGamerTagsPerSecond.Increment();
                        perf.ctr[partnerName].GetLBForGamerTagsTotal    .Increment();
                    }
                }

                StatsLBInfo lb = glob.GetLBInfoAndCheckType(TitleID, LBID, isTeamReq);

                if(lb.LeaderboardType == LBType.CompetitionTemplate
                   || lb.LeaderboardType == LBType.CompetitionTemplateTeam)
                {
                    lb = lb.CreateStatsLBInfoForCompetitionLeaderboard(LBID);
                }

                StatsUserPage[] ups = GetStatsPagesForGamerTags(lb, GamerTagList, out ValidSeconds);

                LBResults results;
                LBEntry[] lines = new LBEntry[ups.Length];
                results.LBLastResetDate = lb.LastResetTime;
                results.TotalLBEntries  = lb.TotalEntries;
                results.Entries         = lines;

                // Resolve puids to tags. Build array with puids to send to
                // batching function.
                ulong[] puids = new ulong[ups.Length];
                for(int i = 0; i < puids.Length; i++)
                {
                    puids[i] = ups[i].Puid;
                }
                string[] tags = StatsGlobal.Instance.LookupTags(lb.TitleID, lb.IsTeam, puids);

                for (uint j = 0; j < ups.Length; j++)
                {
                    lines[j].G = tags[j];
                    lines[j].R = ups[j].Rank;
                }

                entries = lines.Length;
                valSec  = ValidSeconds;
                ok      = 1;

                return results;
            }
            catch (XboxWebException)
            {
                throw;
            }
            catch (Exception e)
            {
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_CODE_77, e);
            }
            finally
            {
                string szLog = glob.BuildLogLineLB((isTeamReq ? "GetLBForTeamNames" : "GetLBForGamerTags"),
                                                    ok, TitleID, LBID, entries, valSec,
                                                    GamerTagList.Length.ToString("X"));

                Xom.Log(XomAreaName.wcstatslog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );
            }
        }

        protected DetailedLBResults InternalGetLBDetailsForGamerTags(
            bool isTeamReq,
            uint TitleID,
            uint LBID,
            string[] GamerTagList,
            out uint ValidSeconds )
        {
            int  entries = 0;
            uint valSec  = 0;
            uint ok      = 0;

            try
            {
                glob.CheckAPIAndTitle((isTeamReq ? "Stats.GetLBDetailsForTeamNames" : "Stats.GetLBDetailsForGamerTags"),
                                      TitleID, TitlePrivilege.ReadOnly );
                glob.CheckTagListLength(GamerTagList.Length);

                perf.ctr.RequestsPerSecond                .Increment();
                perf.ctr.RequestsTotal                    .Increment();
                if(isTeamReq)
                {
                    perf.ctr.GetTeamLBDetailsForTeamNamesPerSecond.Increment();
                    perf.ctr.GetTeamLBDetailsForTeamNamesTotal    .Increment();
                }
                else
                {
                    perf.ctr.GetLBDetailsForGamerTagsPerSecond.Increment();
                    perf.ctr.GetLBDetailsForGamerTagsTotal    .Increment();
                }

                string partnerName = Utilities.GetSubjectName();
                if (partnerName != null)
                {
                    perf.ctr[partnerName].RequestsPerSecond                .Increment();
                    perf.ctr[partnerName].RequestsTotal                    .Increment();
                    if(isTeamReq)
                    {
                        perf.ctr[partnerName].GetTeamLBDetailsForTeamNamesPerSecond.Increment();
                        perf.ctr[partnerName].GetTeamLBDetailsForTeamNamesTotal    .Increment();
                    }
                    else
                    {
                        perf.ctr[partnerName].GetLBDetailsForGamerTagsPerSecond.Increment();
                        perf.ctr[partnerName].GetLBDetailsForGamerTagsTotal    .Increment();
                    }
                }

                StatsLBInfo lb = glob.GetLBInfoAndCheckType(TitleID, LBID, isTeamReq);

                if(lb.LeaderboardType == LBType.CompetitionTemplate
                   || lb.LeaderboardType == LBType.CompetitionTemplateTeam)
                {
                    lb = lb.CreateStatsLBInfoForCompetitionLeaderboard(LBID);
                }

                StatsUserPage[] ups = GetStatsPagesForGamerTags(lb, GamerTagList, out ValidSeconds);

                DetailedLBResults results;
                results.LBLastResetDate = lb.LastResetTime;
                results.TotalLBEntries  = lb.TotalEntries;
                results.Entries         = lb.GetDetailLines(ups);

                entries = results.Entries.Length;
                valSec  = ValidSeconds;
                ok      = 1;

                return results;
            }
            catch (XboxWebException)
            {
                throw;
            }
            catch (Exception e)
            {
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_CODE_78, e);
            }
            finally
            {
                string szLog = glob.BuildLogLineLB((isTeamReq ? "GetLBDetailsForTeamNames" : "GetLBDetails"),
                                                    ok, TitleID, LBID, entries, valSec,
                                                    GamerTagList.Length.ToString("X"));

                Xom.Log(XomAreaName.wcstatslog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );
            }
        }

        //
        // Private member variables
        //

        StatsGlobal glob;

        //
        // Private methods
        //

        private void IncrementGlobalRequestCounter(string szPartnerName)
        {
            perf.ctr.RequestsPerSecond                .Increment();
            perf.ctr.RequestsTotal                    .Increment();

            if (szPartnerName != null)
            {
                perf.ctr[szPartnerName].RequestsPerSecond                .Increment();
                perf.ctr[szPartnerName].RequestsTotal                    .Increment();
            }
        }
        private StatsUserPage[] GetStatsPagesForGamerTags(StatsLBInfo lb, string[] tags, out uint ValidSeconds)
        {
            return (StatsUserPage[])GetStatsPageListForGamerTags(lb,tags,out ValidSeconds).ToArray(typeof(StatsUserPage));
        }

        private ArrayList GetStatsPageListForGamerTags(StatsLBInfo lb, string[] tags, out uint ValidSeconds)
        {
            ArrayList ups    = new ArrayList();
            DateTime  oldest = DateTime.Now;

            for (uint i = 0; i < tags.Length; i++)
            {
                StatsUserPage up = glob.GetStatsPageForGamerTag(lb, tags[i]);

                if (up.page == null)
                    continue;

                ups.Add(up);

                if (up.page.CreationTime < oldest)
                    oldest = up.page.CreationTime;
            }

            ValidSeconds = lb.ValidSeconds(oldest);

            return ups;
        }

        private DetailedLBResults GetLBRangeFormatted(StatsLBInfo lb, uint start, uint end, out uint ValidSeconds)
        {
            ArrayList pageList = GetLBRangePages(lb, start, end, out ValidSeconds);

            DetailedLBResults results;
            results.LBLastResetDate = lb.LastResetTime;
            results.TotalLBEntries  = lb.TotalEntries;
            results.Entries         = GetLBRangeFormattedFromPages(lb, pageList, start, end,
                                                                   glob.SortByRating, glob.RemoveDups);

            return results;
        }

        private DetailedLBResults DirectGetLBRangeFormatted(StatsLBInfo lb, uint uiLbId, uint uiStart, uint uiMaxEntries)
        {
            MsgWebEnumLB req = new MsgWebEnumLB();
            RepWebEnumLB rep;

            req._uiTitleId          = lb.TitleID;
            req._uiLb               = uiLbId;
            req._ulPivotOrPageStart = uiStart;
            req._bIsPivotUser       = 0;
            req._uiPageSize         = uiMaxEntries;

            rep = glob.StatsFrontDoorRequest(req);

            DetailedLBResults results = new DetailedLBResults();
            results.TotalLBEntries = rep._uiLbSize;
            results.LBLastResetDate = DateTime.FromFileTime((long)rep._ulLastResetTime);
            results.Entries = new DetailedLBEntry[rep._users.Length];

            for(int i=0; i < results.Entries.Length; i++)
            {
                if( lb.LeaderboardType != LBType.CompetitionTemplateTeam
                    && lb.LeaderboardType != LBType.RegularTeam )
                {
                    results.Entries[i].G = glob.LookupGamerTag(rep._users[i]._ulUser);
                }
                else
                {
                    results.Entries[i].G = glob.LookupTeamName(lb.TitleID, rep._users[i]._ulUser);
                }
                results.Entries[i].R = rep._users[i]._uiRank;
            }

            MsgAttribData[][] attribs = new MsgAttribData[rep._users.Length][];
            for(int i=0; i < attribs.Length; i++)
            {
                ArrayList row = new ArrayList(66);

                MsgAttribData arank = new MsgAttribData();
                arank._usAttrId     = SpecialAttrib.Rank;
                arank._bAttrType    = (byte) AttrType.Long;
                arank._value        = (int)rep._users[i]._uiRank;
                row.Add(arank);

                MsgAttribData arating = new MsgAttribData();
                arank._usAttrId       = SpecialAttrib.Rating;
                arank._bAttrType      = (byte) AttrType.LongLong;
                arank._value          = (int)rep._users[i]._lRating;
                row.Add(arating);

                for(int j=0; j < rep._users[i]._attribs.Length; j++)
                {
                    if(rep._users[i]._attribs[j]._bAttrType != (byte) AttrType.None)
                        row.Add(rep._users[i]._attribs[j]);
                }

                attribs[i]=(MsgAttribData[])row.ToArray(typeof(MsgAttribData));
            }

            lb.FormatDetailedLBEntries(results.Entries, new StatsCompactPage(attribs));

            return results;
        }

        private DetailedLBEntry[] GetLBRangeFormattedFromPages(StatsLBInfo lb, ArrayList pageList,
                                                               uint start, uint end,
                                                               bool sort, bool removeDups)
        {
            ArrayList   entryList  = new ArrayList();
            Hashtable   dupTable   = null;
            ArrayList[] eLists     = null;
            int         totalCount = 0;

#if DEBUG
            foreach (StatsPage page in pageList)
            {
                long low  = Math.Max(start, page.StartRank);
                long high = Math.Min(end,   page.StartRank + page.puids.Length - 1);
                totalCount += (int)(high - low + 1);
            }
#endif

            if (removeDups)
            {
                // for each puid, remember which entry is the newest
                dupTable = new Hashtable();

                foreach (StatsPage page in pageList)
                {
                    for (uint line = 0; line < page.puids.Length; line++)
                    {
                        uint r = line + page.StartRank;
                        if (r >= start && r <= end)
                        {
                            StatsPage pageDup = dupTable[page.puids[line]] as StatsPage;
                            if (pageDup == null || page.CreationTime > pageDup.CreationTime)
                                dupTable[page.puids[line]] = page;
                        }
                    }
                }
            }

            if (sort)
            {
                // keep a per-page list of entries

                eLists = new ArrayList[pageList.Count];
                for (int i = 0; i < pageList.Count; i++)
                    eLists[i] = new ArrayList();
            }

            int pageIndex  = 0;
            int entryCount = 0;
            int dupCount   = 0;

            foreach (StatsPage page in pageList)
            {
                for (uint line = 0; line < page.puids.Length; line++)
                {
                    uint r = line + page.StartRank;
                    if (r >= start && r <= end)
                    {
                        if (!removeDups || dupTable[page.puids[line]] == page)
                        {
                            StatsUserPage up = new StatsUserPage(page, line);
                            if (sort)
                            {
                                eLists[pageIndex].Add(up);
                            }
                            else
                            {
                                entryList.Add(up);
                            }

                            entryCount++;
                        }
                        else
                        {
                            dupCount++;
                        }
                    }
                }

                pageIndex++;
            }

            if (removeDups)
                Debug.Assert((entryCount + dupCount) == totalCount);
            else
                Debug.Assert(entryCount == totalCount);

            if (sort)
            {
                // merge the per-page lists

                while (entryCount > 0)
                {
                    long bestRating = long.MinValue;
                    int  bestIndex  = eLists.Length;

                    for (int i = eLists.Length - 1; i >= 0; i--)
                    {
                        if (eLists[i].Count == 0)
                            continue;

                        StatsUserPage up = (StatsUserPage)eLists[i][0];
                        if (up.Rating >= bestRating)
                        {
                            bestRating = up.Rating;
                            bestIndex  = i;
                        }
                    }

                    ArrayList bestList = eLists[bestIndex];

                    while (bestList.Count > 0)
                    {
                        StatsUserPage up = (StatsUserPage)bestList[0];
                        if (up.Rating == bestRating)
                        {
                            bestList.RemoveAt(0);
                            entryCount--;

                            entryList.Add(up);
                        }
                        else
                        {
                            break;
                        }
                    }

                }
            }

            Debug.Assert((entryList.Count + dupCount) == totalCount);

            StatsUserPage[] ups = (StatsUserPage[])entryList.ToArray(typeof(StatsUserPage));

            return lb.GetDetailLines(ups);
        }

        private RawLBResults GetLBRangeRaw(StatsLBInfo lb, uint start, uint end, out uint ValidSeconds)
        {
            ArrayList pageList  = GetLBRangePages(lb, start, end, out ValidSeconds);
            ArrayList entryList = new ArrayList();

            foreach (StatsPage page in pageList)
            {
                for (uint line = 0; line < page.puids.Length; line++)
                {
                    uint r = line + page.StartRank;
                    if (r >= start && r <= end)
                    {
                        RawLBEntry e = lb.GetDetailLineRaw(page, line);
                        entryList.Add(e);
                    }
                }
            }

            RawLBResults results;
            results.LBLastResetDate = lb.LastResetTime;
            results.TotalLBEntries  = lb.TotalEntries;
            results.Entries         = (RawLBEntry[])entryList.ToArray(typeof(RawLBEntry));

            return results;
        }

        private ArrayList GetLBRangePages(StatsLBInfo lb, uint start, uint end, out uint ValidSeconds)
        {
            ArrayList pageList = new ArrayList();
            DateTime  oldest   = DateTime.Now;

            for (uint r = (start - 1) / lb.PageSize * lb.PageSize + 1;
                 r <= end;
                 r += lb.PageSize)
            {
                StatsPage page = glob.GetStatsPageForRank(lb, r);

                if (page == null)
                    break;

                pageList.Add(page);

                if (page.CreationTime < oldest)
                    oldest = page.CreationTime;
            }

            ValidSeconds = lb.ValidSeconds(oldest);

            return pageList;
        }

#if TEST_HOOKS
        internal DetailedLBEntry[] TestGetLBRangeFormattedFromPages(StatsLBInfo lb, ArrayList pageList,
                                                                  uint start, uint end,
                                                                  bool sort, bool removeDups)
        {
            return GetLBRangeFormattedFromPages(lb, pageList, start, end, sort, removeDups);
        }
#endif

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Stats\Dll\wcStatsCompactPage.cs ===
using System;
using System.IO;
using xonline.server.webcache.common;
using System.Runtime.Serialization;
using System.Diagnostics;

using xonline.common.protocol;
using xonline.common.service;

namespace xonline.server.webcache.stats.dll 
{
    [Serializable]
    class StatsCompactPage : ISerializable
    {
        public uint                      totalEntries;
        public StatsCompactAttribute[][] rows;

        public StatsCompactPage(MsgAttribData[][] attribs)
        {
            totalEntries = 0;
            rows         = new StatsCompactAttribute[attribs.Length][];
            
            for(int i=0; i < attribs.GetLength(0); i++)
            {
                rows[i] = new StatsCompactAttribute[attribs[i].Length];
                for(int j=0; j < rows[i].Length; j++)
                {
                    rows[i][j].id    = attribs[i][j]._usAttrId;
                    rows[i][j].value = attribs[i][j]._value;  
                }
            }
        }
        
        public StatsCompactPage(StatsUserPage[] ups, uint totalEntries)
        {
            this.totalEntries = totalEntries;
            this.rows         = new StatsCompactAttribute[ups.Length][];

            for (int j = 0; j < ups.Length; j++)
            {            
                MsgAttribData[] attrs = ups[j].Attrs;
                int             len   = (attrs == null) ? 0 : attrs.Length;
                
                rows[j] = new StatsCompactAttribute[len + 2];
                rows[j][0].id    = SpecialAttrib.Rank;
                rows[j][0].value = ups[j].Rank;
                rows[j][1].id    = SpecialAttrib.Rating;
                rows[j][1].value = ups[j].Rating;

                for (int i = 0; i < len; i++)
                {
                    rows[j][i + 2].id    = attrs[i]._usAttrId;
                    rows[j][i + 2].value = attrs[i]._value;
                }
            }
        }    
        
        protected StatsCompactPage(SerializationInfo info, StreamingContext context) 
        {
            byte[]       bs = (byte[])info.GetValue("mystream", typeof(byte[]));
            MemoryStream ms = new MemoryStream(bs);
            BinaryReader br = new BinaryReader(ms);
            int          rowcount;

            totalEntries = br.ReadUInt32();
            rowcount     = br.ReadInt32();

            rows = new StatsCompactAttribute[rowcount][];

            for (int j = 0; j < rowcount; j++)
            {
                int acount = br.ReadInt32();
                rows[j]    = new StatsCompactAttribute[acount];

                //rows[j][0].id    = SpecialAttrib.Rank;
                //rows[j][0].value = br.ReadUInt32();
                //rows[j][1].id    = SpecialAttrib.Rating;
                //rows[j][1].value = br.ReadInt64();

                for (int i = 0; i < acount; i++)
                {
                    rows[j][i].id = br.ReadInt32();
                    int atype     = br.ReadByte();

                    if (atype == 1)
                    {
                        rows[j][i].value = br.ReadInt32();
                    }
                    else if (atype == 2)
                    {
                        rows[j][i].value = br.ReadInt64();
                    }
                    else if (atype == 3)
                    {
                        rows[j][i].value = br.ReadDouble();
                    }
                    else if (atype == 4)
                    {
                        rows[j][i].value = br.ReadUInt32();
                    }
                }
            }
            
        }
        
        public void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            MemoryStream ms = new MemoryStream();
            BinaryWriter bw = new BinaryWriter(ms);

            bw.Write(totalEntries);
            bw.Write(rows.Length);

            for (int j = 0; j < rows.Length; j++)
            {
                if (rows[j] == null)
                {
                    bw.Write((int)0);
                }
                else
                {
                    Debug.Assert(rows[j].Length >= 2);
                    bw.Write(rows[j].Length);

                    //bw.Write((uint)rows[j][0].value); // rank
                    //bw.Write((long)rows[j][1].value); // rating

                    for (int i = 0; i < rows[j].Length; i++)
                    {
                        bw.Write(rows[j][i].id);

                        Type t = rows[j][i].value.GetType();

                        if (t == typeof(int))
                        {
                            bw.Write((byte)1);
                            bw.Write((int)rows[j][i].value);
                        }
                        else if (t == typeof(long))
                        {
                            bw.Write((byte)2);
                            bw.Write((long)rows[j][i].value); 
                        }
                        else if (t == typeof(double))
                        {
                            bw.Write((byte)3);
                            bw.Write((double)rows[j][i].value);
                        }
                        else if(t == typeof(uint))
                        {
                            bw.Write((byte)4);
                            bw.Write((uint)rows[j][i].value);
                        }
                        else
                        {
                            throw new XboxWebInternalException(XEvent.Id.WEBCACHE_COMM_12);
                        }
                    }
                }
            }
            
            info.AddValue("mystream", ms.ToArray());
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\Stats\Dll\wcStatsCommonType.cs ===
using System;

namespace xonline.server.webcache.stats.dll 
{
    public enum AttributeUnit { Integer, Float, Percent, GamerTag, TimeStamp,
                                MilliSeconds, TenMilliSeconds, HundredMilliSeconds,
                                Seconds, Minutes, Hours, Days, String, Team,
                                MaxAttributeUnit = Team }

    public struct StatsLocalizedName
    {
        public string Locale;
        public string DisplayName;

        public StatsLocalizedName(string Locale, string DisplayName)
        {
            this.Locale      = Locale;
            this.DisplayName = DisplayName;
        }
    }

    public enum LBResetType
    {
        Never        = 0,
        Weekly       = 1,
        Monthly      = 2,
        Bimonthly    = 3,
        Quarterly    = 4,
        Semiannually = 5,
        Annually     = 6
    }

    public enum LBType
    {
        Regular                 = 0,
        RegularTeam             = 1,
        CompetitionTemplate     = 4,
        CompetitionTemplateTeam = 5
    }

    public struct LBAttributeInfo
    {
        public string               ID;
        public AttributeUnit        Unit;
        public StatsLocalizedName[] LocalizedAttrName;
    }

    public struct LBInfo
    {
        public uint                 LBID;
        public LBResetType          ResetType;
        public StatsLocalizedName[] LocalizedLBName;
        public LBAttributeInfo[]    AttributeInfo;
    }

    public struct LBEntry
    {
        public string G;                // GamerTag
        public uint   R;                // Rank
    }

    public struct LBResults
    {
        public LBEntry[] Entries;
        public DateTime  LBLastResetDate;
        public uint      TotalLBEntries;
    }

    public struct LBEntryAttribute
    {
        public LBEntryAttribute(string id, string val)
        {
            ID = id;
            V  = val;
        }
        public string ID;
        public string V;                // Val
    }

    public struct DetailedLBEntry
    {
        public string             G;    // GamerTag
        public uint               R;    // Rank
        public LBE