d
SIS_Reference_Data	dd	?		; Data to be passed to device
SIS_Instance_Data_Ptr	dd	0		; Ptr to instance data list
Win386_Startup_Info_Struc ENDS

;
;   Structure for instance data list.  (List terminated with 0 dword).
;
Instance_Item_Struc STRUC
IIS_Ptr 		dd	?		; Seg:Off of instance item
IIS_Size		dw	?		; Size of instance item in bytes
Instance_Item_Struc ENDS

;
;   Flags passed to the Win_Kernel_Idle call to indicate state of Windows
;   in the BX register.
;
Win_Idle_Mouse_Busy	EQU	00000001b
Win_Idle_Mouse_Busy_Bit EQU	0

;
; Structure for TSR <-> Windows communication
; (W386_TSR_Identify call, AL=0Bh)
;
TSR_Info_Struc	STRUC
    TSR_Next		    dd	?
    TSR_PSP_Segment	    dw	?
    TSR_API_Ver_ID	    dw	100h
    TSR_Exec_Flags	    dw	0
    TSR_Exec_Cmd_Show	    dw	0
    TSR_Exec_Cmd	    dd	0
    TSR_Reserved	    db	4 dup (0)
    TSR_ID_Block	    dd	0
    TSR_Data_Block	    dd	0
TSR_Info_Struc ENDS

;
; TSR_Exec_Flags equates
;
TSR_WINEXEC	EQU	1
TSR_LOADLIBRARY EQU	2
TSR_OPENDRIVER	EQU	4
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\MTRR.INC ===
ifndef  _MTRR_H_
_MTRR_H_        EQU     1
MTRR_Ver_Major  EQU     01H
MTRR_Ver_Minor  EQU     00H
MTRR_DEVICE_ID  EQU     <DDS_DEVICE_ID>
MmNonCached     EQU     0
MmCached        EQU     1
MmFrameBufferCached     EQU     2
MmHardwareCoherentCached        EQU     3
MmMaximumCacheType      EQU     4
Begin_Service_Table MTRR, VxD
MTRR_Service             _MTRR_Get_Version, LOCAL
MTRR_StdCall_Service     MTRRSetPhysicalCacheTypeRange, 4
End_Service_Table MTRR, VxD
endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\PAGESWAP.INC ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1988-1990
;
;   Title:	PageSwap.Inc - Demand Paging Swap Device Services
;
;   Version:	1.00
;
;   Date:	18-Oct-1988
;
;   Author:	RAL
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   18-Oct-1988 RAL Original
;   19-Oct-1990 JEM Added Buffer Descriptor structure
;
;==============================================================================


Begin_Service_Table PageSwap

PageSwap_Service PageSwap_Get_Version, LOCAL
PageSwap_Service PageSwap_Test_Create, LOCAL
PageSwap_Service PageSwap_Create, LOCAL
PageSwap_Service PageSwap_Destroy, LOCAL
PageSwap_Service PageSwap_In, LOCAL
PageSwap_Service PageSwap_Out, LOCAL
PageSwap_Service PageSwap_Test_IO_Valid, LOCAL

End_Service_Table PageSwap

PS_Zero_Init_Mask	EQU	0001h
PS_Zero_Init_Bit	EQU	00h
PS_Fixed_Page_Mask	EQU	0008h
PS_Fixed_Page_Bit	EQU	03h
PS_First_Page_In_Mask	EQU	0020h
PS_First_Page_In_Bit	EQU	05h
PS_Dirty_Mask		EQU	0040h
PS_Dirty_Bit		EQU	06h
PS_Ever_Dirty_Mask	EQU	8000h
PS_Ever_Dirty_Bit	EQU	0Fh

PS_NoXchg_Mask		EQU	80000000h
PS_NoXchg_Bit		EQU	1Fh	; DO NOT xchg phys addrs on PageSwap_Out


; Buffer descriptor for asynchronous I/O

SIZE_PS_BD_RESERVED EQU 44

PageSwapBufferDesc	STRUC
PS_BD_Next		dd	?
PS_BD_List		dw	?
PS_BD_Cmd		db	?
PS_BD_Priority		db	?
PS_BD_Page_Number	dd	?
PS_BD_Buffer_Ptr	dd	?
PS_BD_File_Page 	dd	?
PS_BD_Call_Back 	dd	?
PS_BD_Reserved		db SIZE_PS_BD_RESERVED dup (?)
PageSwapBufferDesc	ENDS

; List values for PS_BD_List

PS_BDL_Free		EQU	1
PS_BDL_Pending_WB	EQU	2
PS_BDL_Submitted_RA	EQU	3
PS_BDL_Locked		EQU	4

PS_BDP_Invalid_Data	EQU	-1
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\SHELLFSC.INC ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1988-1990
;
;   Title:	SHELLFSC.Inc - EQUATES related to the File Sys Change stuff
;
;   Version:	1.00
;
;   Date:	19-Sep-1988
;
;   Author:	ARR
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   19-Sep-1988 ARR Original
;
;==============================================================================

VDA_FileSysChange	EQU	0400H+20+11

;
; On VDA_FileSysChange, wParam is not used
;   Particular VMDOSAPP instance which gets the message is the VM that has
;   changed the file system
;
; NOTE THERE MUST BE A CALL BACK ON THIS EVENT.
;
; The reference data MUST BE A pointer to a structure of the following type:
;
; It is the responsibility of the caller to "FREE" this structure (if needed)
;   on the call back.
;
; Caller can extend this structure if needed by tacking extra info on the end.
;
MAXFSCINFOSIZE		EQU	256

VMDA_FileSysChng  STRUC
VMDA_FSC_Func		dw	?
VMDA_FSC_Buffer 	db	MAXFSCINFOSIZE DUP(?)
VMDA_FileSysChng  ENDS

;
; equates for VMDA_FSC_Func
;
VMDA_FSC_CREATE 	EQU	0
VMDA_FSC_DELETE 	EQU	1
VMDA_FSC_RENAME 	EQU	2
VMDA_FSC_ATTRIBUTES	EQU	3
VMDA_FSC_NETCONNECT	EQU	4
VMDA_FSC_NETDISCONNECT	EQU	5
VMDA_FSC_REFRESH	EQU	6
VMDA_FSC_MKDIR		EQU	7
VMDA_FSC_RMDIR		EQU	8
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\SHELL.INC ===
ifndef _SHELL_H
_SHELL_H	EQU	1
ifndef Not_VxD
Begin_Service_Table SHELL
SHELL_Service    SHELL_Get_Version, LOCAL
SHELL_Service    SHELL_Resolve_Contention, LOCAL
SHELL_Service    SHELL_Event, LOCAL
SHELL_Service    SHELL_SYSMODAL_Message, LOCAL
SHELL_Service    SHELL_Message, LOCAL
ifndef WIN30COMPAT
SHELL_Service    SHELL_GetVMInfo, LOCAL
endif
ifndef WIN31COMPAT
SHELL_Service    _SHELL_PostMessage, LOCAL
SHELL_Service    _SHELL_ShellExecute
SHELL_Service    _SHELL_PostShellMessage
SHELL_Service    SHELL_DispatchRing0AppyEvents, LOCAL
SHELL_Service    SHELL_Hook_Properties, LOCAL
SHELL_Service    SHELL_Unhook_Properties, LOCAL
SHELL_Service    SHELL_Update_User_Activity, LOCAL
SHELL_Service    _SHELL_QueryAppyTimeAvailable, LOCAL
SHELL_Service    _SHELL_CallAtAppyTime, LOCAL
SHELL_Service    _SHELL_CancelAppyTimeEvent
SHELL_Service    _SHELL_BroadcastSystemMessage, LOCAL
SHELL_Service    _SHELL_HookSystemBroadcast, LOCAL
SHELL_Service    _SHELL_UnhookSystemBroadcast, LOCAL
SHELL_Service    _SHELL_LocalAllocEx, LOCAL
SHELL_Service    _SHELL_LocalFree, LOCAL
SHELL_Service    _SHELL_LoadLibrary, LOCAL
SHELL_Service    _SHELL_FreeLibrary, LOCAL
SHELL_Service    _SHELL_GetProcAddress, LOCAL
SHELL_Service    _SHELL_CallDll, LOCAL
SHELL_Service	 _SHELL_SuggestSingleMSDOSMode
SHELL_Service	 SHELL_CheckHotkeyAllowed
SHELL_Service	 _SHELL_GetDOSAppInfo
ifdef WIN41SERVICES
SHELL_Service    _SHELL_Update_User_Activity_Ex, LOCAL
endif
endif
End_Service_Table SHELL
ifndef WIN31COMPAT
SBH_CALL_ORDER_DEFAULT	EQU	0
SBH_CALL_ORDER_REGISTRY	EQU	30000000H
SBH_CALL_ORDER_CONFIGMG	EQU	40000000H
SBH_CALL_ORDER_NTKERN	EQU	50000000H
SUUAE_SYSTEM_REQUIRED_BIT	EQU	00000000H
SUUAE_SYSTEM_REQUIRED	EQU	(1 SHL SUUAE_SYSTEM_REQUIRED_BIT)
SUUAE_DISPLAY_REQUIRED_BIT	EQU	00000001H
SUUAE_DISPLAY_REQUIRED	EQU	(1 SHL SUUAE_DISPLAY_REQUIRED_BIT)
SUUAE_LOW_LATENCY_BIT	EQU	00000003H
SUUAE_LOW_LATENCY	EQU	(1 SHL SUUAE_LOW_LATENCY_BIT)
SUUAE_CONTINUOUS_CHECK_BIT	EQU	29
SUUAE_CONTINUOUS_CHECK	EQU	(1 SHL SUUAE_CONTINUOUS_CHECK_BIT)
SUUAE_CONTINUOUS_ADD_BIT	EQU	30
SUUAE_CONTINUOUS_ADD	EQU	(1 SHL SUUAE_CONTINUOUS_ADD_BIT)
SUUAE_CONTINUOUS_REMOVE	EQU	0
SUUAE_CONTINUOUS_BIT	EQU	31
SUUAE_CONTINUOUS	EQU	(1 SHL SUUAE_CONTINUOUS_BIT)
endif

_SHELL_SUUAE_INFO	STRUC
ssiTimeLastActiveDisplay	DD	?
ssiTimeLastActiveSystem	DD	?
ssiHoldDisplay	DB	?
ssiHoldSystem	DB	?
ssiLowLatency	DB	?
_SHELL_SUUAE_INFO	ENDS
MB_OK	EQU	00H
MB_OKCANCEL	EQU	01H
MB_ABORTRETRYIGNORE	EQU	02H
MB_YESNOCANCEL	EQU	03H
MB_YESNO	EQU	04H
MB_RETRYCANCEL	EQU	05H
MB_ICONHAND	EQU	10H
MB_ICONEXCLAMATION	EQU	30H
MB_ICONASTERISK	EQU	40H
MB_DEFBUTTON1	EQU	00H
MB_DEFBUTTON2	EQU	100H
MB_DEFBUTTON3	EQU	200H
MB_APPLMODAL	EQU	00H
MB_SYSTEMMODAL	EQU	1000H
MB_NOFOCUS	EQU	8000H
MB_ASAP	EQU	80000000H
MB_NOWINDOW	EQU	40000000H
MB_HANGSYS	EQU	20000000H
ifndef WIN31COMPAT
MB_APPYTIME	EQU	10000000H
endif
IDOK	EQU	1
IDCANCEL	EQU	2
IDABORT	EQU	3
IDRETRY	EQU	4
IDIGNORE	EQU	5
IDYES	EQU	6
IDNO	EQU	7
SE_WP_PrtScBoost	EQU	00100000H
SE_WP_PrtScBoostBit	EQU	20
SE_WP_DispUpdBoost	EQU	00200000H
SE_WP_DispUpdBoostBit	EQU	21
ifndef WIN31COMPAT
SPM_UM_DoNotWaitForCrit	EQU	00020000H
SPM_UM_DoNotWaitForCritBit	EQU	17
SPM_UM_AlwaysSchedule	EQU	00080000H
SPM_UM_AlwaysScheduleBit	EQU	19
endif
SGVMI_Windowed	EQU	00000004H
SGVMI_ALTTABdis	EQU	00000020H
SGVMI_ALTESCdis	EQU	00000040H
SGVMI_ALTSPACEdis	EQU	00000080H
SGVMI_ALTENTERdis	EQU	00000100H
SGVMI_ALTPRTSCdis	EQU	00000200H
SGVMI_PRTSCdis	EQU	00000400H
SGVMI_CTRLESCdis	EQU	00000800H
SGVMI_HasHotKey	EQU	00004000H
SGVMI_Polling	EQU	00001000H
SGVMI_FastPaste	EQU	00020000H
SGVMI_NoHMA	EQU	00002000H
SGVMI_XMS_Lock	EQU	00010000H
SGVMI_EMS_Lock	EQU	00008000H
SGVMI_V86_Lock	EQU	00040000H
SGVMI_ClsExit	EQU	40000000H
endif
ifndef WIN31COMPAT
ifndef Not_VxD
LMEM_FIXED	EQU	0000H
LMEM_ZEROINIT	EQU	0040H
LPTR	EQU	(LMEM_FIXED OR LMEM_ZEROINIT)
LMEM_STRING	EQU	00010000H
LMEM_OEM2ANSI	EQU	00020000H
QAAFL_APPYAVAIL	EQU	00000001H
QAAFL_APPYNOW	EQU	00000002H
CAAFL_RING0	EQU	00000001H
CAAFL_TIMEOUT	EQU	00000002H
endif

SHEXPACKET	STRUC
shex_dwTotalSize	DD	?
shex_dwSize	DD	?
shex_ibOp	DD	?
shex_ibFile	DD	?
shex_ibParams	DD	?
shex_ibDir	DD	?
shex_dwReserved	DD	?
shex_nCmdShow	DD	?
SHEXPACKET	ENDS
SGDAIF_COMPARENAME	EQU	0
SGDAIF_TESTAPPBIT	EQU	1
SGDAIF_LASTVALID	EQU	1
SGDAIR_SUCCESS	EQU	0
SGDAIR_NOMATCH	EQU	1
SGDAIR_BADFUNCTION	EQU	2
endif
endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\V86MMGR.INC ===
;****************************************************************************
;                                                                           *
; THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
; KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
; IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
; PURPOSE.                                                                  *
;                                                                           *
; Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
;                                                                           *
;****************************************************************************

;******************************************************************************
;
;   Title:	V86MMGR.Inc - Public services for V86MMGR
;
;   Version:	2.00
;
;==============================================================================

Begin_Service_Table V86MMGR

V86MMGR_Service 	V86MMGR_Get_Version,		LOCAL
V86MMGR_Service 	V86MMGR_Allocate_V86_Pages,	LOCAL
V86MMGR_Service 	V86MMGR_Set_EMS_XMS_Limits,	LOCAL
V86MMGR_Service 	V86MMGR_Get_EMS_XMS_Limits,	LOCAL
;
;   Services used for API mapping.
;
V86MMGR_Service 	V86MMGR_Set_Mapping_Info, VxD_ICODE
V86MMGR_Service 	V86MMGR_Get_Mapping_Info
V86MMGR_Service 	V86MMGR_Xlat_API
V86MMGR_Service 	V86MMGR_Load_Client_Ptr
V86MMGR_Service 	V86MMGR_Allocate_Buffer
V86MMGR_Service 	V86MMGR_Free_Buffer
V86MMGR_Service 	V86MMGR_Get_Xlat_Buff_State
V86MMGR_Service 	V86MMGR_Set_Xlat_Buff_State
V86MMGR_Service 	V86MMGR_Get_VM_Flat_Sel
V86MMGR_Service 	V86MMGR_Map_Pages
V86MMGR_Service 	V86MMGR_Free_Page_Map_Region
;***********************************************************
;  END OF 3.00 level services
;
V86MMGR_Service 	V86MMGR_LocalGlobalReg
V86MMGR_Service 	V86MMGR_GetPgStatus,		LOCAL
V86MMGR_Service 	V86MMGR_SetLocalA20,		VxD_ICODE
V86MMGR_Service 	V86MMGR_ResetBasePages, 	LOCAL
V86MMGR_Service 	V86MMGR_SetAvailMapPgs, 	VxD_ICODE
V86MMGR_Service 	V86MMGR_NoUMBInitCalls, 	VxD_ICODE

IFNDEF	WIN31COMPAT

;   Services added post Win 3.1
V86MMGR_Service         V86MMGR_Get_EMS_XMS_Avail,      LOCAL
V86MMGR_Service         V86MMGR_Toggle_HMA
V86MMGR_Service 	V86MMGR_Dev_Init,		LOCAL
V86MMGR_Service 	V86MMGR_Alloc_UM_Page,		LOCAL

ENDIF ;	WIN31COMPAT


End_Service_Table V86MMGR

;
; BITS of returned EAX flags for V86MMGR_GetPgStatus
;
V86PS_ROM       equ     0000000000000001b       ; Page contains global ROM
V86PS_RAM       equ     0000000000000010b       ; Page contains global RAM
V86PS_EMM	equ	0000000010000000b	; Page belongs to EMM driver
V86PS_XMS	equ	0000000100000000b	; Page belongs to XMS driver
V86PS_MAP	equ	0000001000000000b	; Page belongs to mapper
V86PS_UMB       equ     0001000000000000b       ; Page contains imported UMB
                                                ;  (Note that V86PS_XMS is not
                                                ;   necessarily set)

;
; BITS of ECX flags for V86MMGR_Allocate_V86_Pages
;
AV86PLocked			EQU	00000000000000000000000000000001B
AV86PLockedBit			EQU	0	; VM memory is to be
						;   ALWAYS LOCKED regardless of
						;   pager type or whether VM
						;   is suspended.
;
; BITS of ECX flags for V86MMGR_Set_EMS_XMS_Limits
;
; NOTE: If neither Limit_DisableHMA or Limit_EnableHMA is set, the HMA
;	state is not altered.
;
EMS_XMS_Limit_DisableHMA	EQU	00000000000000000000000000000001B
EMS_XMS_Limit_DisableHMABit	EQU	0
EMS_XMS_Limit_EnableHMA 	EQU	00000000000000000000000000000010B
EMS_XMS_Limit_EnableHMABit	EQU	1
EMS_XMS_Limit_XMS_Is_Locked	EQU	00000000000000000000000000000100B
EMS_XMS_Limit_XMS_Is_LockedBit	EQU	2
EMS_XMS_Limit_EMS_Is_Locked	EQU	00000000000000000000000000001000B
EMS_XMS_Limit_EMS_Is_LockedBit	EQU	3



;
;   API mapper equates and macros
;

Xlat_Exec_Int	    EQU     000h
Xlat_Fixed_Len	    EQU     001h
Xlat_Var_Len	    EQU     002h
Xlat_Calc_Len	    EQU     003h
Xlat_ASCIIZ	    EQU     004h
Xlat_Jmp_To_Proc    EQU     005h
Xlat_Return_Ptr     EQU     006h
Xlat_Return_Seg     EQU     007h
Xlat_ASCIIZ_InOut   EQU     008h


Xlat_API_Exec_Int MACRO Int_Number
	db	Xlat_Exec_Int
	db	Int_Number
	ENDM

Xlat_API_Fixed_Len MACRO Ptr_Seg, Ptr_Off, Length
	db	Xlat_Fixed_Len
	dw	Length
	dw	(Client_&Ptr_Seg*100h)+Client_&Ptr_Off
	ENDM

Xlat_API_Var_Len MACRO Ptr_Seg, Ptr_Off, Len_Reg
	db	Xlat_Var_Len
	db	Client_&Len_Reg
	dw	(Client_&Ptr_Seg*100h)+Client_&Ptr_Off
	ENDM

Xlat_API_Calc_Len MACRO Ptr_Seg, Ptr_Off, Calc_Proc_Addr
	db	Xlat_Calc_Len
	dd	OFFSET32 Calc_Proc_Addr
	dw	(Client_&Ptr_Seg*100h)+Client_&Ptr_Off
	ENDM

Xlat_API_ASCIIZ  MACRO Ptr_Seg, Ptr_Off
	db	Xlat_ASCIIZ
	dw	(Client_&Ptr_Seg*100h)+Client_&Ptr_Off
	ENDM

Xlat_API_ASCIIZ_InOut  MACRO Ptr_Seg, Ptr_Off
	db	Xlat_ASCIIZ_InOut
	dw	(Client_&Ptr_Seg*100h)+Client_&Ptr_Off
	ENDM

Xlat_API_Jmp_To_Proc MACRO Proc_Name
	db	Xlat_Jmp_To_Proc
	dd	OFFSET32 Proc_Name
	ENDM


Xlat_API_Return_Ptr MACRO Ptr_Seg, Ptr_Off
	db	Xlat_Return_Ptr
	dw	(Client_&Ptr_Seg*100h)+Client_&Ptr_Off
	ENDM

Xlat_API_Return_Seg MACRO Ptr_Seg
	db	Xlat_Return_Seg
	db	Client_&Ptr_Seg
	ENDM

;
; The V86MMGR does W386_Device_Broadcast call outs. The 'subfunction' number
; for these call outs is contained in the CX register. These are the equates
; for the subfunction numbers.
;
V86CallOut_LclA20forGlblHMA	equ	0	; Should A20 state be local
						;   even if HMA is GLOBAL?
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\OPTTEST.INC ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1990
;
;   Title:	OPTTEST.INC - Macros to optimize test instructions
;
;   Version:	1.00
;
;   Date:	28-Jun-1990
;
;   Author:	RAL
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   28-Jun-1990 RAL
;
;==============================================================================


TestMem MACRO MemPtr, M
IFE (M) AND 0FFFFFF00h
	test	BYTE PTR [MemPtr], M
ELSE
IFE (M) AND 0FFFF00FFh
	test	BYTE PTR [MemPtr+1], ((M) SHR 8)
ELSE
IFE (M) AND 0FF00FFFFh
	test	BYTE PTR [MemPtr+2], ((M) SHR 16)
ELSE
IFE (M) AND 000FFFFFFh
	test	BYTE PTR [MemPtr+3], ((M) SHR 24)
ELSE
IFE (M) AND 0FFFF0000h
	test	WORD PTR [MemPtr], M
ELSE
IFE (M) AND 0FF0000FFh
	test	WORD PTR [MemPtr+1], ((M) SHR 8)
ELSE
IFE (M) AND 00000FFFFh
	test	WORD PTR [MemPtr+2], ((M) SHR 16)
ELSE
	test	DWORD PTR [MemPtr], M
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
	ENDM





TestReg MACRO R, Mask

_@TR MACRO Ltr
IFE (Mask) AND 0FFFFFF00h
	test	Ltr&&l, Mask
ELSE
IFE (Mask) AND 0FFFF00FFh
	test	Ltr&&h, ((Mask) SHR 8)
ELSE
IFE (Mask) AND 0FFFF0000h
	test	Ltr&&x, Mask
ELSE
	test	e&&Ltr&&x, Mask
ENDIF
ENDIF
ENDIF
	ENDM


IFIDNI <R>, <EAX>
	_@TR a, Mask
ELSE
IFIDNI <R>, <EBX>
	_@TR b, Mask
ELSE
IFIDNI <R>, <ECX>
	_@TR c, Mask
ELSE
IFIDNI <R>, <EDX>
	_@TR d, Mask
ELSE
IFIDNI <R>, <ESI>
IFE (Mask) AND 0FFFF0000h
	test	si, Mask
ELSE
	test	esi, Mask
ENDIF
ELSE
IFIDNI <R>, <EDI>
IFE (Mask) AND 0FFFF0000h
	test	di, Mask
ELSE
	test	edi, Mask
ENDIF
ELSE
%OUT ERROR:  Bad param to TestReg macro
.ERR
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
	ENDM




SetFlag MACRO MemPtr, M
IFE (M) AND 0FFFFFF00h
	or	BYTE PTR [MemPtr], M
ELSE
IFE (M) AND 0FFFF00FFh
	or	BYTE PTR [MemPtr+1], ((M) SHR 8)
ELSE
IFE (M) AND 0FF00FFFFh
	or	BYTE PTR [MemPtr+2], ((M) SHR 16)
ELSE
IFE (M) AND 000FFFFFFh
	or	BYTE PTR [MemPtr+3], ((M) SHR 24)
ELSE
IFE (M) AND 0FFFF0000h
	or	WORD PTR [MemPtr], M
ELSE
IFE (M) AND 0FF0000FFh
	or	WORD PTR [MemPtr+1], ((M) SHR 8)
ELSE
IFE (M) AND 00000FFFFh
	or	WORD PTR [MemPtr+2], ((M) SHR 16)
ELSE
	or	DWORD PTR [MemPtr], M
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
	ENDM



ClrFlag MACRO MemPtr, M
IFE (M) AND 0FFFFFF00h
	and	BYTE PTR [MemPtr], NOT (M)
ELSE
IFE (M) AND 0FFFF00FFh
	and	BYTE PTR [MemPtr+1], NOT ((M) SHR 8)
ELSE
IFE (M) AND 0FF00FFFFh
	and	BYTE PTR [MemPtr+2], NOT ((M) SHR 16)
ELSE
IFE (M) AND 000FFFFFFh
	and	BYTE PTR [MemPtr+3], NOT ((M) SHR 24)
ELSE
IFE (M) AND 0FFFF0000h
	and	WORD PTR [MemPtr], NOT (M)
ELSE
IFE (M) AND 0FF0000FFh
	and	WORD PTR [MemPtr+1], NOT ((M) SHR 8)
ELSE
IFE (M) AND 00000FFFFh
	and	WORD PTR [MemPtr+2], NOT ((M) SHR 16)
ELSE
	and	DWORD PTR [MemPtr], NOT (M)
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
	ENDM
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\VCOMM.H ===
/****************************************************************************
*                                                                           *
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
* KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
* IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
* PURPOSE.                                                                  *
*                                                                           *
* Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
*                                                                           *
****************************************************************************/

/*;***************************************************************************
;
; VCOMM.H
;
; Version:	1.00
;
;============================================================================*/

/* H2INCSWITCHES -d */

#ifndef _VCOMM_H
#define _VCOMM_H

/*XLATOFF*/
#pragma	pack(1)
/*XLATON*/

#ifndef Not_VxD

/*XLATOFF*/
#define	VCOMM_Service	Declare_Service
/*XLATON*/

/*MACROS*/
Begin_Service_Table(VCOMM, VxD)

VCOMM_Service	(VCOMM_Get_Version, LOCAL)
VCOMM_Service	(_VCOMM_Register_Port_Driver,LOCAL)
VCOMM_Service	(_VCOMM_Acquire_Port,LOCAL)
VCOMM_Service	(_VCOMM_Release_Port,LOCAL)
VCOMM_Service	(_VCOMM_OpenComm, VxD_CODE)
VCOMM_Service	(_VCOMM_SetCommState, VxD_CODE)
VCOMM_Service	(_VCOMM_GetCommState, VxD_CODE)
VCOMM_Service	(_VCOMM_SetupComm, VxD_CODE)
VCOMM_Service	(_VCOMM_TransmitCommChar, VxD_CODE)
VCOMM_Service	(_VCOMM_CloseComm, VxD_CODE)
VCOMM_Service	(_VCOMM_GetCommQueueStatus, VxD_CODE)
VCOMM_Service	(_VCOMM_ClearCommError, VxD_CODE)
VCOMM_Service	(_VCOMM_GetModemStatus, VxD_CODE)
VCOMM_Service	(_VCOMM_GetCommProperties, VxD_CODE)
VCOMM_Service	(_VCOMM_EscapeCommFunction, VxD_CODE)
VCOMM_Service	(_VCOMM_PurgeComm, VxD_CODE)
VCOMM_Service	(_VCOMM_SetCommEventMask, VxD_CODE)
VCOMM_Service	(_VCOMM_GetCommEventMask, VxD_CODE)
VCOMM_Service	(_VCOMM_WriteComm, VxD_CODE)
VCOMM_Service	(_VCOMM_ReadComm, VxD_CODE)
VCOMM_Service	(_VCOMM_EnableCommNotification, VxD_CODE)
VCOMM_Service	(_VCOMM_GetLastError, VxD_CODE)

VCOMM_Service	(_VCOMM_Steal_Port,LOCAL)

VCOMM_Service	(_VCOMM_SetReadCallBack, VxD_CODE)
VCOMM_Service	(_VCOMM_SetWriteCallBack, VxD_CODE)

VCOMM_Service	(_VCOMM_Add_Port, LOCAL)

/*ENDMACROS*/
#ifndef		WIN31COMPAT
/*MACROS*/

VCOMM_Service	(_VCOMM_GetSetCommTimeouts, VxD_CODE)
VCOMM_Service	(_VCOMM_SetWriteRequest, VxD_CODE)
VCOMM_Service	(_VCOMM_SetReadRequest, VxD_CODE)
VCOMM_Service	(_VCOMM_Dequeue_Request, VxD_CODE)

VCOMM_Service	(_VCOMM_Enumerate_DevNodes, VxD_CODE)

VCOMM_Service	(VCOMM_Map_Win32DCB_To_Ring0, VxD_CODE)
VCOMM_Service	(VCOMM_Map_Ring0DCB_To_Win32, VxD_CODE)

VCOMM_Service	(_VCOMM_Get_Contention_Handler, VxD_CODE)
VCOMM_Service	(_VCOMM_Map_Name_To_Resource, VxD_CODE)
/*ENDMACROS*/
#endif
/*MACROS*/

End_Service_Table(VCOMM, VxD)
/*ENDMACROS*/

#endif

typedef struct _PortFunctions {
	BOOL (*pPortSetCommState)();	/* ptr to PortSetState */
	BOOL (*pPortGetCommState)();	/* ptr to PortGetState */
	BOOL (*pPortSetup)();		/* ptr to PortSetup */
	BOOL (*pPortTransmitChar)();	/* ptr to PortTransmitChar */
	BOOL (*pPortClose)();		/* ptr to PortClose */
	BOOL (*pPortGetQueueStatus)();	/* ptr to PortGetQueueStatus */
	BOOL (*pPortClearError)();	/* ptr to PortClearError */
	BOOL (*pPortSetModemStatusShadow)(); /* ptr to
					        PortSetModemStatusShadow */
	BOOL (*pPortGetProperties)();	/* ptr to PortGetProperties */
	BOOL (*pPortEscapeFunction)();	/* ptr to PortEscapeFunction */
	BOOL (*pPortPurge)();		/* ptr to PortPurge */
	BOOL (*pPortSetEventMask)();	/* ptr to PortSetEventMask */
	BOOL (*pPortGetEventMask)();	/* ptr to PortGetEventMask */
	BOOL (*pPortWrite)();		/* ptr to PortWrite */
	BOOL (*pPortRead)();		/* ptr to PortRead */
	BOOL (*pPortEnableNotification)(); /* ptr to PortEnableNotification */
	BOOL (*pPortSetReadCallBack)(); /* ptr to PortSetReadCallBack */
	BOOL (*pPortSetWriteCallBack)(); /* ptr to PortSetWriteCallBack */
	BOOL (*pPortGetModemStatus)();	/* ptr to PortGetModemStatus */

#ifndef	WIN31COMPAT
	
	BOOL (*pPortGetCommConfig)();	/* ptr to PortGetCommConfig */
	BOOL (*pPortSetCommConfig)();	/* ptr to PortSetCommConfig */
	BOOL (*pPortGetError)();	/* ptr to PortGetError (win32 style)*/
	BOOL (*pPortDeviceIOCtl)();	/* ptr to PortDeviceIOCtl */
		
#endif
	
} PortFunctions;

typedef struct COMMTIMEOUTS {
	DWORD ReadIntervalTimeout;
	DWORD ReadTotalTimeoutMultiplier;
	DWORD ReadTotalTimeoutConstant;
	DWORD WriteTotalTimeoutMultiplier;
	DWORD WriteTotalTimeoutConstant;
} COMMTIMEOUTS, *LPCOMMTIMEOUTS;

typedef struct _PortData {
	WORD PDLength;			/* sizeof (PortData) */
        WORD PDVersion;			/* version of struct */
        PortFunctions *PDfunctions;	/* Points to a list of functions
					   supported by	the port driver */
        DWORD PDNumFunctions;		/* Highest ordinal of supported
					   function */
        DWORD dwLastError;		/* what was the error
					   for the last operation */
        DWORD dwClientEventMask;	/* event mask set by client */
        DWORD lpClientEventNotify;	/* address set by client for
					   event notification */
	DWORD lpClientReadNotify;	/* adress set by client for
					   read threshold notification */
	DWORD lpClientWriteNotify;	/* address set by client for
					   write threshold notification */
	DWORD dwClientRefData;		/* Client's reference data */
	DWORD dwWin31Req;		/* Used for WIN3.1 specific reasons */
	DWORD dwClientEvent;		/* Event to send to client */
	DWORD dwCallerVMId;		/* Used for supporting all VMs */

	DWORD dwDetectedEvents;		/* mask of detected and
					   enabled events */
        DWORD dwCommError;		/* non-zero if I/O error. */
	BYTE bMSRShadow;		/* the shadow of Modem Status
					   Register */
	WORD wFlags;			/* flags for the port */
	BYTE LossByte;			/* For COMM ports 1-4 VCD flags this
					   byte telling port driver that it
					   has lost the port */

	DWORD QInAddr;			/* Address of the queue */
	DWORD QInSize;			/* Length of queue in bytes */
	DWORD QOutAddr;			/* Address of the queue */
	DWORD QOutSize;			/* Length of queue in bytes */
	DWORD QInCount;			/* # of bytes currently in queue */
	DWORD QInGet;			/* Offset into q to get bytes from */
	DWORD QInPut;			/* Offset into q to put bytes in */
	DWORD QOutCount;		/* Number of bytes currently in q */
	DWORD QOutGet;			/* Offset into q to get bytes from */
	DWORD QOutPut;			/* Offset into q to put bytes in */

	DWORD ValidPortData;		/* For checking validity etc. */

	DWORD lpLoadHandle;		/* load handle of the owner VxD */
	COMMTIMEOUTS cmto;		/* Commtimeouts struct */

	DWORD lpReadRequestQueue;	/* Pointer to pending Read requests */
	DWORD lpWriteRequestQueue;	/* Pointer to pending Write requests */

	DWORD dwLastReceiveTime;	/* Time of last reception of data */
		
	DWORD dwReserved1;		/* Reserved */
	DWORD dwReserved2;		/* Reserved */
} PortData;

#ifndef	Not_VxD

/* Standard error codes set in dwLastError. */

#define	IE_BADID	-1	 /* invalid or unsupported device */
#define	IE_OPEN		-2	 /* Device already open */
#define	IE_NOPEN	-3	 /* Device not open */
#define	IE_MEMORY	-4	 /* unable to allocate queues */
#define	IE_DEFAULT	-5	 /* error in default params */
#define	IE_INVALIDSERVICE -6	 /* port driver doesn't support this service*/
#define	IE_HARDWARE	-10	 /* hardware not present */
#define	IE_BYTESIZE	-11	 /* illegal byte size */
#define	IE_BAUDRATE	-12	 /* unsupported baud rate */
#define	IE_EXTINVALID	-20	 /* unsupported extended function */
#define	IE_INVALIDPARAM	-21	 /* Parameters are wrong */
#define	IE_TRANSMITCHARFAILED 0x4000 /* TransmitChar failed */

/* Events that can be set in dwClientEventMask */

#define	EV_RXCHAR	0x00000001	 /* Any Character received */
#define	EV_RXFLAG	0x00000002	 /* Received certain character */
#define	EV_TXEMPTY	0x00000004	 /* Transmitt Queue Empty */
#define	EV_CTS		0x00000008	 /* CTS changed state */
#define	EV_DSR		0x00000010	 /* DSR changed state */
#define	EV_RLSD		0x00000020	 /* RLSD changed state */
#define	EV_BREAK	0x00000040	 /* BREAK received */
#define	EV_ERR		0x00000080	 /* Line status error occurred */
#define	EV_RING		0x00000100	 /* Ring signal detected */
#define	EV_PERR		0x00000200	 /* Printer error occured */
#define	EV_CTSS		0x00000400	 /* CTS state */
#define	EV_DSRS		0x00000800	 /* DSR state */
#define	EV_RLSDS	0x00001000	 /* RLSD state */
#define	EV_RingTe	0x00002000	 /* Ring Trailing Edge Indicator */
#define	EV_TXCHAR	0x00004000	 /* Any character transmitted */
#define	EV_DRIVER	0x00008000	 /* Driver specific event */
#define	EV_UNAVAIL	0x00010000	 /* Acquired port has been stolen */
#define	EV_AVAIL	0x00020000	 /* stolen port has been released */


/* Error Flags for dwCommError */

#define	CE_RXOVER	0x00000001		/* Receive Queue overflow */
#define	CE_OVERRUN	0x00000002		/* Receive Overrun Error */
#define	CE_RXPARITY	0x00000004		/* Receive Parity Error */
#define	CE_FRAME	0x00000008		/* Receive Framing error */
#define	CE_BREAK	0x00000010		/* Break Detected */
#define	CE_CTSTO	0x00000020		/* CTS Timeout */
#define	CE_DSRTO	0x00000040		/* DSR Timeout */
#define	CE_RLSDTO	0x00000080		/* RLSD Timeout */
#define	CE_TXFULL	0x00000100		/* TX Queue is full */
#define	CE_PTO		0x00000200		/* LPTx Timeout */
#define	CE_IOE		0x00000400		/* LPTx I/O Error */
#define	CE_DNS		0x00000800		/* LPTx Device not selected */
#define	CE_OOP		0x00001000		/* LPTx Out-Of-Paper */
#define	CE_Unused1	0x00002000		/* unused */
#define	CE_Unused2	0x00004000		/* unused */
#define	CE_MODE		0x00008000		/* Requested mode unsupported*/

#endif

//
// Modem status flags
//

#define	MS_CTS_ON	0x0010
#define	MS_DSR_ON	0x0020
#define	MS_RING_ON	0x0040
#define	MS_RLSD_ON	0x0080
#define	MS_Modem_Status	0x00F0


/* flags for wFlags of PortData */

#define	Event_Sent	0x0001	/* has an event been set for COMM.DRV ? */
#define	Event_Sent_Bit	0x0000	/* bit in the flag word */
#define	TimeOut_Error	0x0002	/* Operation was abandoned due to timeout */
#define	TimeOut_Error_Bit 0x0001 /* its bit field */
#define	Flush_In_Progress 0x0004 /* FlushFileBuffers is in progress */
#define	Flush_In_Progress_Bit 0x0002 /* its bit */
#define	TxQueuesSet	0x0008	/* Non-zero xmit queue exists */
#define	TxQueuesSetBit	0x0003	/* its bit */
#define	CloseComm_In_Progress	0x0010	/* CloseComm is in progress */
#define	CloseComm_In_Progress_Bit 0x0004 /* its bit */
#define Spec_Timeouts_Set	0x0020	/* Special timeouts have been set */
#define	Spec_Timeouts_Set_Bit	0x0005	/* its bit */

typedef struct _DCB {
	DWORD DCBLength;		/* sizeof (DCB) */
	DWORD BaudRate ;		/* Baudrate at which running */
        DWORD BitMask;			/* flag DWORD */
        DWORD XonLim;			/* Transmit X-ON threshold */
        DWORD XoffLim;			/* Transmit X-OFF threshold */
        WORD wReserved;			/* reserved */
        BYTE ByteSize;			/* Number of bits/byte, 4-8 */
	BYTE Parity;			/* 0-4=None,Odd,Even,Mark,Space */
	BYTE StopBits;			/* 0,1,2 = 1, 1.5, 2 */
	char XonChar;			/* Tx and Rx X-ON character */
	char XoffChar;			/* Tx and Rx X-OFF character */
	char ErrorChar;			/* Parity error replacement char */
	char EofChar;			/* End of Input character */
	char EvtChar1;			/* special event character */
	char EvtChar2;			/* Another special event character */
	BYTE bReserved;			/* reserved */
	DWORD RlsTimeout;		/* Timeout for RLSD to be set */
	DWORD CtsTimeout;		/* Timeout for CTS to be set */
	DWORD DsrTimeout;		/* Timeout for DSR to be set */
	DWORD TxDelay;			/* Amount of time between chars */
} _DCB;

#ifndef	Not_VxD

/*  Comm Baud Rate indices : allowable values for BaudRate */

#define	CBR_110		0x0000FF10
#define	CBR_300		0x0000FF11
#define	CBR_600		0x0000FF12
#define	CBR_1200	0x0000FF13
#define	CBR_2400	0x0000FF14
#define	CBR_4800	0x0000FF15
#define	CBR_9600	0x0000FF16
#define	CBR_14400	0x0000FF17
#define	CBR_19200	0x0000FF18

/* 0x0000FF19,0x00000FF1A are reserved */

#define	CBR_38400	0x0000FF1B

/* 0x0000FF1C, 0x0000FF1D, 0x0000FF1E are reserved */

#define	CBR_56000	0x0000FF1F

/* 0x0000FF20, 0x0000FF21, 0x0000FF22 are reserved */

#define	CBR_128000	0x0000FF23

/* 0x0000FF24, 0x0000FF25, 0x0000FF26 are reserved */

#define	CBR_256000	0x0000FF27

#endif

/* Flags for Bitmask */

#define	fBinary		0x00000001	/* Binary mode */
#define	fRTSDisable	0x00000002	/* Disable RTS */
#define fParity		0x00000004	/* Perform parity checking */
#define	fOutXCTSFlow	0x00000008	/* Output handshaking using CTS */
#define	fOutXDSRFlow	0x00000010	/* Output handshaking using DSR */
#define	fEnqAck		0x00000020	/* ENQ/ACK software handshaking */
#define	fEtxAck		0x00000040	/* ETX/ACK software handshaking */
#define	fDTRDisable	0x00000080	/* Disable DTR */

#define	fOutX		0x00000100	/* Output X-ON/X-OFF */
#define	fInX		0x00000200	/* Input X-ON/X-OFF */
#define	fPErrChar	0x00000400	/* Parity error replacement active */
#define	fNullStrip	0x00000800	/* Null stripping */
#define	fCharEvent	0x00001000	/* Character event */
#define	fDTRFlow	0x00002000	/* Input handshaking using DTR */
#define	fRTSFlow	0x00004000	/* Output handshaking using RTS */
#define	fWin30Compat	0x00008000	/* Maintain Compatiblity */

#define	fDsrSensitivity	0x00010000	/* DSR sensitivity */
#define	fTxContinueOnXoff 0x00020000	/* Continue Tx when Xoff sent */
#define	fDtrEnable	0x00040000	/* Enable DTR on device open */
#define	fAbortOnError	0x00080000	/*abort all reads and writes on error*/
#define	fRTSEnable	0x00100000	/* enable RTS on device open */
#define	fRTSToggle	0x00200000	/* iff bytes in Q, set RTS high */

/* Allowable parity values */

#define	NOPARITY	0
#define	ODDPARITY	1
#define	EVENPARITY	2
#define	MARKPARITY	3
#define	SPACEPARITY	4

/* Allowable stopbits */

#define	ONESTOPBIT	0
#define	ONE5STOPBITS	1
#define	TWOSTOPBITS	2

typedef	unsigned short WCHAR;

typedef struct _COMMPROP {
	WORD   wPacketLength;		/* length of property structure
					   in bytes */
	WORD   wPacketVersion;		/* version of this structure */
	DWORD  dwServiceMask;		/* Bitmask indicating services
					   provided */
	DWORD  dwReserved1;		/* reserved */
	DWORD  dwMaxTxQueue;		/* Max transmit queue size.
					   0 => not used */
	DWORD  dwMaxRxQueue;		/* Max receive queue size.
					   0 => not used */
	DWORD  dwMaxBaud;		/* maximum baud supported */
	DWORD  dwProvSubType;		/* specific COMM provider type */
	DWORD  dwProvCapabilities;	/* flow control capabilities */
	DWORD  dwSettableParams;	/* Bitmask indicating params
					   that can be set. */
	DWORD  dwSettableBaud;		/* Bitmask indicating baud rates
					   that can be set*/
	WORD   wSettableData;		/* bitmask indicating # of data bits
					   that can be set*/
	WORD   wSettableStopParity;	/* bitmask indicating allowed
					   stopbits and parity checking */
	DWORD  dwCurrentTxQueue;	/* Current size of transmit queue
					   0 => unavailable */
	DWORD  dwCurrentRxQueue;	/* Current size of receive queue
					   0 => unavailable */
	DWORD  dwProvSpec1;		/* Used iff clients have
					   intimate knowledge of format */
	DWORD  dwProvSpec2;		/* Used iff clients have intimate
					   knowledge of format */
	WCHAR  wcProvChar[1];		/* Used iff clients have intimate \						   knowledge of format */
	WORD	filler;			/* To make it multiple of 4 */
	
} _COMMPROP;

//
// Serial provider type.
//

#define SP_SERIALCOMM    ((DWORD)0x00000001)

//
// Provider SubTypes
//

#define PST_UNSPECIFIED      ((DWORD)0x00000000)
#define PST_RS232            ((DWORD)0x00000001)
#define PST_PARALLELPORT     ((DWORD)0x00000002)
#define PST_RS422            ((DWORD)0x00000003)
#define PST_RS423            ((DWORD)0x00000004)
#define PST_RS449            ((DWORD)0x00000005)
#define PST_MODEM            ((DWORD)0x00000006)
#define PST_FAX              ((DWORD)0x00000021)
#define PST_SCANNER          ((DWORD)0x00000022)
#define PST_NETWORK_BRIDGE   ((DWORD)0x00000100)
#define PST_LAT              ((DWORD)0x00000101)
#define PST_TCPIP_TELNET     ((DWORD)0x00000102)
#define PST_X25              ((DWORD)0x00000103)

//
// Provider capabilities flags.
//

#define PCF_DTRDSR        ((DWORD)0x0001)
#define PCF_RTSCTS        ((DWORD)0x0002)
#define PCF_RLSD          ((DWORD)0x0004)
#define PCF_PARITY_CHECK  ((DWORD)0x0008)
#define PCF_XONXOFF       ((DWORD)0x0010)
#define PCF_SETXCHAR      ((DWORD)0x0020)
#define PCF_TOTALTIMEOUTS ((DWORD)0x0040)
#define PCF_INTTIMEOUTS   ((DWORD)0x0080)
#define PCF_SPECIALCHARS  ((DWORD)0x0100)
#define PCF_16BITMODE     ((DWORD)0x0200)

//
// Comm provider settable parameters.
//

#define SP_PARITY         ((DWORD)0x0001)
#define SP_BAUD           ((DWORD)0x0002)
#define SP_DATABITS       ((DWORD)0x0004)
#define SP_STOPBITS       ((DWORD)0x0008)
#define SP_HANDSHAKING    ((DWORD)0x0010)
#define SP_PARITY_CHECK   ((DWORD)0x0020)
#define SP_RLSD           ((DWORD)0x0040)

//
// Settable baud rates in the provider.
//

#define BAUD_075          ((DWORD)0x00000001)
#define BAUD_110          ((DWORD)0x00000002)
#define BAUD_134_5        ((DWORD)0x00000004)
#define BAUD_150          ((DWORD)0x00000008)
#define BAUD_300          ((DWORD)0x00000010)
#define BAUD_600          ((DWORD)0x00000020)
#define BAUD_1200         ((DWORD)0x00000040)
#define BAUD_1800         ((DWORD)0x00000080)
#define BAUD_2400         ((DWORD)0x00000100)
#define BAUD_4800         ((DWORD)0x00000200)
#define BAUD_7200         ((DWORD)0x00000400)
#define BAUD_9600         ((DWORD)0x00000800)
#define BAUD_14400        ((DWORD)0x00001000)
#define BAUD_19200        ((DWORD)0x00002000)
#define BAUD_38400        ((DWORD)0x00004000)
#define BAUD_56K          ((DWORD)0x00008000)
#define BAUD_128K         ((DWORD)0x00010000)
#define BAUD_USER         ((DWORD)0x10000000)

//
// Settable Data Bits
//

#define DATABITS_5        ((WORD)0x0001)
#define DATABITS_6        ((WORD)0x0002)
#define DATABITS_7        ((WORD)0x0004)
#define DATABITS_8        ((WORD)0x0008)
#define DATABITS_16       ((WORD)0x0010)
#define DATABITS_16X      ((WORD)0x0020)

//
// Settable Stop and Parity bits.
//

#define STOPBITS_10       ((WORD)0x0001)
#define STOPBITS_15       ((WORD)0x0002)
#define STOPBITS_20       ((WORD)0x0004)
#define PARITY_NONE       ((WORD)0x0100)
#define PARITY_ODD        ((WORD)0x0200)
#define PARITY_EVEN       ((WORD)0x0400)
#define PARITY_MARK       ((WORD)0x0800)
#define PARITY_SPACE      ((WORD)0x1000)

typedef struct  _COMSTAT {
	DWORD BitMask;		/* flags DWORD */
	DWORD cbInque;		/* Count of characters in receive queue */
	DWORD cbOutque;		/* Count of characters in transmit queue */
} _COMSTAT;

/* Flags of BitMask */

#define	fCtsHold	0x00000001	/* Transmit is on CTS hold */
#define	fDsrHold	0x00000002	/* Transmit is on DSR hold */
#define	fRlsdHold	0x00000004	/* Transmit is on RLSD hold */
#define	fXoffHold	0x00000008	/* Received handshake */
#define	fXoffSent	0x00000010	/* Issued handshake */
#define	fEof		0x00000020	/* EOF character found */
#define	fTximmed	0x00000040	/* Character being transmitted */

typedef struct _QSB {
	DWORD ReceiveQueueGetPtr; /* offset into queue to get bytes from */
	DWORD ReceiveQueueCount;  /* Number of bytes in receive queue */
} _QSB;


/* Following constants are used by COMM.DRV to access the PM apis supported
   by VCOMM.
*/

#define	VCOMM_PM_API_OpenCom	0
#define	VCOMM_PM_API_SetCom	1
#define	VCOMM_PM_API_Setup	2
#define	VCOMM_PM_API_ctx	3
#define	VCOMM_PM_API_TrmCom	4
#define	VCOMM_PM_API_StaCom	5
#define	VCOMM_PM_API_cextnfcn	6
#define	VCOMM_PM_API_cFlush	7
#define	VCOMM_PM_API_cevt	8
#define	VCOMM_PM_API_cevtget	9

#define	VCOMM_PM_API_SetMSRShadow	10
#define	VCOMM_PM_API_WriteString	11
#define	VCOMM_PM_API_ReadString		12
#define	VCOMM_PM_API_EnableNotify	13

#ifndef	Not_VxD

/* Escape Functions (extended functions). */

#define	Dummy	0		  /* Dummy */
#define	SETXOFF	1		  /* Simulate XOFF received */
#define	SETXON  2		  /* Simulate XON received */
#define	SETRTS	3		  /* Set RTS high */
#define	CLRRTS	4		  /* Set RTS low */
#define	SETDTR	5		  /* Set DTR high */
#define	CLRDTR	6		  /* Set DTR low */
#define	RESETDEV 7		  /* Reset device if possible */

#endif

#ifdef	Not_VxD

/* These numbers are reserved for compatibility reasons */

#define	GETLPTMAX 8		 /* Get maximum LPT supported */
#define	GETCOMMAX 9		 /* Get maximum COM supported */

#endif

#define	GETCOMBASEIRQ	10	 /* Get COM base and IRQ */
#define	GETCOMBASEIRQ1	11	 /* FOR COMPATIBILITY REASONS */

#define	SETBREAK	12	 /* Set break condition */
#define	CLEARBREAK	13	 /* Clear break condition */

#ifdef	Not_VxD

/* These too are not available to client VxDs and not implemented by
   port drivers. */

#define	GETPORTHANDLE	14	 /* Get handle for Port */
#define	GETEXTENDEDFNADDR 15	 /* Get the address of extended functions */

#endif

#define	CLRTIMERLOGIC	16	/* Clear the timer logic of the port driver */

#define GETDEVICEID	17	/* Get the device ID of the device */
#define SETECPADDRESS	18	/* Set ECP channel address */

#define SETUPDATETIMEADDR	19	/* Set address of update field for
					   last time a char was received */

#define IGNOREERRORONREADS	20	/* Ignore pending IO errors on reads*/

#define ENABLETIMERLOGIC	21	/* Re-enable timer logic code */
#define	IGNORESELECT		22	/* Ignore select bit */

#define STARTNONSTDESCAPES	200	/* non standard escapes */

#define	PEEKCHAR		200	/* peek the Rx Q */

/* END OF ESCAPES for ESCAPECOMMFUNCTION */

#ifndef	Not_VxD
/* notifications passed in Event of Notification function */

#define	CN_RECEIVE	1	 /* bytes are available in the input queue */
#define	CN_TRANSMIT	2	 /* fewer than wOutTrigger bytes still */
				 /* remain in the output queue waiting */
				 /* to be transmitted. */
#define	CN_EVENT	4	 /* an enabled event has occurred */

#endif
				
/* Other constants */

#ifndef	Not_VxD
				
#define	IGNORE		0		/* Ignore signal */

#endif
				
#define	INFINITE32	-1		/* Infinite timeout */

/* Defined ways of supporting a port (return value of PortInquire fn) */

#define	PD_UNSUPPORTED	0		/* Port is not supported */
#define	PD_DEFAULT	1		/* Port is supported by default */
#define	PD_BEST		-1		/* Best possible support */

/* Masks for relevant fields of DCB */
#define	fBaudRate	0x00000001
#define	fBitMask	0x00000002
#define	fXonLim		0x00000004
#define	fXoffLim	0x00000008
#define	fByteSize	0x00000010
#define	fbParity	0x00000020
#define	fStopBits	0x00000040
#define	fXonChar	0x00000080
#define	fXoffChar	0x00000100
#define	fErrorChar	0x00000200
#define	fEofChar	0x00000400
#define	fEvtChar1	0x00000800
#define	fEvtChar2	0x00001000
#define	fRlsTimeout	0x00002000
#define	fCtsTimeout	0x00004000
#define	fDsrTimeout	0x00008000
#define	fTxDelay	0x00010000
#define	fTimeout	(fRlsTimeout | fDsrTimeout | fCtsTimeout)
#define	fLCR		0x00000070

/*

 IORequest

 VCOMM allows a client to impose a "block" structure on a port
 driver in the following way. It can call VCOMM_SetWriteRequest
 with the buffer to write. When all the earlier write requests are satisfied
 by the port driver, VCOMM will call the port driver to satisfy this
 request. A client can also call VCOMM_SetReadRequest with the buffer
 to read data into. VCOMM will queue up this request and when all previous
 read requests are satisfied, call the port driver to satisfy this request.
 So now, clients can get a notification per read/write request. The buffers
 passed by client must be in locked memory during the duration of the whole
 operation and should not be touched by the client till it receives the
 notification.

 A client should not use a combination of VCOMM_WriteComm and
 VCOMM_SetWriteRequest. This will lead to strange results. VCOMM_WriteComm
 goes directly to the port driver without any processing by VCOMM. There
 is considerable work done by VCOMM for VCOMM_SetWriteRequest. Similarly,
 VCOMM_SetReadRequest and VCOMM_ReadComm should not be used together.

 When a client attempts to get the total queued count of characters to write,
 VCOMM calls the port driver to find the size of its xmit queue and then
 adds up all the pending write operations to return the count.

 VCOMM_PurgeComm leads to VCOMM calling each aborted IORequest if TXAbort
 parameter is set. For TxClear, it does not do so, it just calls down into
 the port driver to clear its transmit queue.
 
*/

typedef struct IORequest {

	DWORD IOBuffer;			//  address of IO buffer
	DWORD IOCount;			// the size of IO buffer
	DWORD IOCallCompletionRoutine;	// whom to call back when done
	DWORD NumBytes;			// How many bytes were written/read
	DWORD dwReserved[8];		// eight reserved words used by VCOMM
	DWORD dwSig;			// signature dword
	
} IORequest;

#define	WRITE_REQUEST	1
#define	READ_REQUEST	0


/* For supporting Plug and Play, a port driver must be dynamically
   loadable. It must exist in the system directory (where DOS386.exe
   is executed from).
   It will be loaded by VCOMM which will be its devloader. During
   Sys_Dynamic_Device_Init, it should register with VCOMM via
   _VCOMM_Register_Port_Driver. While registering, it should pass
   the address of its initialization function. VCOMM will call this
   function to initialize a port supported by the port driver. The
   port driver should check if such a port exists and call VCOMM to
   add this port to its list via _VCOMM_Add_Port. It MUST add the
   port in its initialization function before returning to VCOMM.
   When all the ports supported by the port driver are closed, VCOMM
   will unload the driver. It will call the initialization function of
   the driver once per open of each port. So the port driver can allocate
   the required data for the port at this time and deallocate it at
   the time of closing of the port.
   
   The procedure must be of the form:
   
   void InitFunction(DWORD hDevNode, DWORD AllocPortBase, DWORD AllocPortIrq,
		      char *PortName);

   where:
   hDevNode = devnode for the port
   AllocPortBase = allocated base port address of the port being initialized.
   AllocPortIrq = allocated base Irq of the port being initialized.
   PortName -> name of the port. The port driver, if it supports the port
	   should add the port by using a copy of this name.
	   It will be later be called to open the port with this name.
   
   */

/*

The DriverControl function of the port drivers is called by VCOMM to
perform various actions such as initialize all or one port etc.
Following function codes specify various actions.

*/

#define	DC_Initialize	0x00000000		/* initialize port. */

/* ASM

IFDEF	WIN31COMPAT

VxD_My_Pageable_Code_Seg MACRO
VxD_Locked_Code_Seg
ENDM

VxD_My_Pageable_Code_Ends MACRO
VxD_Locked_Code_Ends
ENDM

VxD_My_Pageable_Data_Seg MACRO
VxD_Locked_Data_Seg
ENDM

VxD_My_Pageable_Data_Ends MACRO
VxD_Locked_Data_Ends
ENDM


ELSE

VxD_My_Pageable_Code_Seg MACRO
VxD_Pageable_Code_Seg
ENDM

VxD_My_Pageable_Code_Ends MACRO
VxD_Pageable_Code_Ends
ENDM

VxD_My_Pageable_Data_Seg MACRO
VxD_Pageable_Data_Seg
ENDM

VxD_My_Pageable_Data_Ends MACRO
VxD_Pageable_Data_Ends
ENDM

ENDIF

*/

#define	ERROR_NOT_READY	21L
#define	ERROR_OUT_OF_PAPER	28L
#define	ERROR_COUNTER_TIMEOUT	1121L

/*XLATOFF*/
#pragma	pack()
/*XLATON*/

#endif                  // _VCOMM_H

typedef	struct IOCtlBlock {
	DWORD IO_lpOverlapped;
	DWORD IO_lpcbBytesReturned;
	DWORD IO_Event;
	DWORD IO_ThreadHandle;
	DWORD IO_NumBytesReturned;
} IOCtlBlock;

/*
 * Contention related equates
 */

#define	MAP_DEVICE_TO_RESOURCE	0
#define	ACQUIRE_RESOURCE	1
#define	STEAL_RESOURCE		2
#define	RELEASE_RESOURCE	3
#define	ADD_RESOURCE		4
#define	REMOVE_RESOURCE		5

#define	MAX_CONTEND_FUNCTIONS	5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\VERSION.H ===
/****************************************************************************
*                                                                           *
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
* KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
* IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
* PURPOSE.                                                                  *
*                                                                           *
* Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
*                                                                           *
****************************************************************************/

#define OFFICIAL   1 
#define FINAL      1 

/****************************************************************************
 *                                                                          *
 *      VERSION.H        -- Version information for internal builds         *
 *                                                                          *
 *      This file is only modified by the official builder to update the         *
 *      VERSION, VER_PRODUCTVERSION and VER_PRODUCTVERSION_STR values            *
 *                                                                          *
 ****************************************************************************/

#ifndef VS_FF_DEBUG 
/* ver.h defines constants needed by the VS_VERSION_INFO structure */
#include "ver.h"
#endif 

/*--------------------------------------------------------------*/
/* the following entry should be phased out in favor of         */
/* VER_PRODUCTVERSION_STR, but is used in the shell today.      */
/*--------------------------------------------------------------*/

#ifndef FROSTING
/*--------------------------------------------------------------*/
/* the following values should be modified by the official      */
/* builder for each build                                       */
/*--------------------------------------------------------------*/
/* NVidia's definitions for these live in nvver.h
#ifndef WIN32
#define VERSION                     "4.02.100"
#endif                            
#define VER_PRODUCTVERSION_STR      "4.02.100\0"
#define VER_PRODUCTVERSION          4,02,0,100
#define VER_PRODUCTVERSION_DW       (0x0402000 | 100)
*/
#else
/*--------------------------------------------------------------*/
/* FROSTING Builds will need a higher version # than Windows 95 */
/*--------------------------------------------------------------*/
#ifndef WIN32
#define VERSION                     "4.05"
#endif
#define VER_PRODUCTVERSION_STR      "4.05\0"
#define VER_PRODUCTVERSION          4,05,0,000
#define VER_PRODUCTVERSION_DW       (0x04050000 | 000)
#endif

/*--------------------------------------------------------------*/
/* the following section defines values used in the version     */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/

/* default is nodebug */
#ifndef DEBUG
#define VER_DEBUG                   0
#else
#define VER_DEBUG                   VS_FF_DEBUG
#endif

/* default is privatebuild */
#ifndef OFFICIAL
#define VER_PRIVATEBUILD            VS_FF_PRIVATEBUILD
#else
#define VER_PRIVATEBUILD            0
#endif

/* default is prerelease */
#ifndef FINAL
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#define VER_FILEOS                  VOS_DOS_WINDOWS16
#define VER_FILEFLAGS               (VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)

#define VER_COMPANYNAME_STR         "Microsoft Corporation\0"

#ifndef FROSTING
#define VER_PRODUCTNAME_STR         "Microsoft\256 Windows(TM) Operating System\0"
#else
#define VER_PRODUCTNAME_STR         "Microsoft\256  Plus!  for  Windows\256  95\0"
#endif

#define VER_LEGALTRADEMARKS_STR     \
"Microsoft\256 is a registered trademark of Microsoft Corporation. Windows(TM) is a trademark of Microsoft Corporation.\0"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\STDDEF.H ===
/***
*stddef.h - definitions/declarations for common constants, types, variables
*
*       Copyright (c) 1985-1997, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains definitions and declarations for some commonly
*       used constants, types, and variables.
*       [ANSI]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_STDDEF
#define _INC_STDDEF

#if     !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/* Define NULL pointer value and the offset() macro */

#ifndef NULL
#ifdef  __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif


#define offsetof(s,m)   (size_t)&(((s *)0)->m)


/* Declare reference to errno */

#if     (defined(_MT) || defined(_DLL)) && !defined(_MAC)
_CRTIMP extern int * __cdecl _errno(void);
#define errno   (*_errno())
#else   /* ndef _MT && ndef _DLL */
_CRTIMP extern int errno;
#endif  /* _MT || _DLL */


/* define the implementation dependent size types */

#ifndef _PTRDIFF_T_DEFINED
typedef int ptrdiff_t;
#define _PTRDIFF_T_DEFINED
#endif


#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif


#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif


#ifdef  _MT
_CRTIMP extern unsigned long  __cdecl __threadid(void);
#define _threadid       (__threadid())
_CRTIMP extern unsigned long  __cdecl __threadhandle(void);
#endif


#ifdef  __cplusplus
}
#endif

#endif  /* _INC_STDDEF */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\VDD.H ===
#ifndef _VDD_H_
#define _VDD_H_
/************ Operating System Interface for NVidia Hardware ***************\
*                                                                           *
* Module: VDD.H                                                             *
*       Header file for Virtual Display device.                             *
*                                                                           *
*---------------------------------------------------------------------------*
*                                                                           *
* History:                                                                  *
*        David Schmenk (dschmenk)      7/22/95 - wrote it                   *
*                                                                           *
\*********************** Copyright 1995 NVidia, Inc. ***********************/
//***************************************************************************
//
//   (C) Copyright MICROSOFT Corp., 1988-1993
//
//   Title: minivdd.inc - VDD definitions for other VxD's and multiple VDD's
//
//   Version:   4.00
//
//   Date:
//
//   Author: FredE for the Mini-VDD interface.  Adapted from VDD.INC in
//      the general include area.  Added services are ONLY for the
//      use of the Mini-VDD and should therefore not be documented.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Defines.
//
//---------------------------------------------------------------------------
//
// VDD services.
//
#define VDD_Get_Version                     0x0000  // Get version number and ID string ptr
#define VDD_PIF_State                       0x0001  // Pass video PIF bits to VDD
#define VDD_Get_GrabRtn                     0x0002  // Get routine addr for video grab
#define VDD_Hide_Cursor                     0x0003  // Hide cursor when display is windowed
#define VDD_Set_VMType                      0x0004  // Set VM type(windowed, bckgrnd, excl)
#define VDD_Get_ModTime                     0x0005  // Return system time of last mod
#define VDD_Set_HCurTrk                     0x0006  // Track horiz cursor movement in window
#define VDD_Msg_ClrScrn                     0x0007  // Clear screen for sysmodal message
#define VDD_Msg_ForColor                    0x0008  // Set Msg_TextOut forground color
#define VDD_Msg_BakColor                    0x0009  // Set Msg_TextOut background color
#define VDD_Msg_TextOut                     0x000A  // Output a string
#define VDD_Msg_SetCursPos                  0x000B  // Set cursor position
#define VDD_Query_Access                    0x000C  // Is it OK to access video now?
#define VDD_Check_Update_Soon               0x000D  // User action may update screen
#define VDD_Get_Mini_Dispatch_Table         0x000E  // Get addr of dispatch table to mini-VDD
#define VDD_Register_Virtual_Port           0x000F  // Mini-VDD asks us to setup I/O trap
#define VDD_Get_VM_Info                     0x0010  // Returns CRTC owner and MemC owners
                                                    // and other special VM handles
#define VDD_Get_Special_VM_IDs              0x0011  // returns planar & msg mode IDs
#define VDD_Register_Extra_Screen_Selector  0x0012  // allows display driver to use second
                                                    // screen selector for block moves
#define VDD_Takeover_VGA_Port               0x0013  //allows MiniVDD to takeover a port
                                                    // in range 3C0H through 3DFH
#define VDD_Get_DISPLAYINFO                 0x0014  //get DISPLAYINFO data structure
#define VDD_Do_Physical_IO                  0x0015  //perform physical I/O for trapped port
#define VDD_Set_Sleep_Flag_Addr             0x0016  //when display driver can't be interrupted
//
// Following are function codes that can be called via the VDD's
// API entry point. These are mainly for display driver --> VDD communication.
// Since Windows 3.0 and 3.1 VDD's may have used the sequential numbers
// (after the Grabber functions) for other VDD API services, we start our
// numbering at 80H so as to avoid ugly conflicts with old 3.1 stuff:
//
#define MINIVDD_SVC_BASE_OFFSET             0x80
#define VDD_DRIVER_REGISTER                 (0 | MINIVDD_SVC_BASE_OFFSET)
#define VDD_DRIVER_UNREGISTER               (1 | MINIVDD_SVC_BASE_OFFSET)
#define VDD_SAVE_DRIVER_STATE               (2 | MINIVDD_SVC_BASE_OFFSET)
#define VDD_REGISTER_DISPLAY_DRIVER_INFO    (3 | MINIVDD_SVC_BASE_OFFSET)
#define VDD_REGISTER_SSB_FLAGS              (4 | MINIVDD_SVC_BASE_OFFSET)
#define VDD_GET_DISPLAY_CONFIG              (5 | MINIVDD_SVC_BASE_OFFSET)
#define VDD_PRE_MODE_CHANGE                 (6 | MINIVDD_SVC_BASE_OFFSET)
#define VDD_POST_MODE_CHANGE                (7 | MINIVDD_SVC_BASE_OFFSET)
#define VDD_SET_USER_FLAGS                  (8 | MINIVDD_SVC_BASE_OFFSET)
#define VDD_SET_BUSY_FLAG_ADDR              (9 | MINIVDD_SVC_BASE_OFFSET)
typedef struct
{
    WORD  HdrSize;
    WORD  InfoFlags;
    DWORD DevNodeHandle;
    BYTE  DriverName[16];
    WORD  XRes;
    WORD  YRes;
    WORD  DPI;
    BYTE  Planes;
    BYTE  Bpp;
    WORD  RefreshRateMax;
    WORD  RefreshRateMin;
    WORD  LowHorz;
    WORD  HighHorz;
    WORD  LowVert;
    WORD  HighVert;
    DWORD MonitorDevNodeHandle;
    BYTE  HorzSyncPolarity;
    BYTE  VertSyncPolarity;
} DISPLAYINFO, * PDISPLAYINFO;
//
// Following are values and explanations for the diInfoFlags word in DISPLAYINFO:
//
// RETURNED_DATA_IS_STALE, if set, means that this call to VDD_GET_DISPLAY_CONFIG
// or VDD_GetDisplayInfo (which are the Ring 3 and Ring 0 methods by which a
// program would get the DISPLAYINFO structure returned to him) caused the VDD
// to return data that was read in a previous call to VDD_GET_DISPLAY_CONFIG
// insted of actually going out and reading "fresh" data from the Registry.
//
// This flag brings to light the fact that there are some circumstances when the
// VDD cannot go out and read the registry in response to the call to
// VDD_GET_DISPLAY_CONFIG or VDD_GetDisplayInfo (due to system multi-tasking
// considerations).  In this case, this flag will be set to a 1 to indicate that
// the information being returned isn't "fresh" -- that is -- it may be
// incorrect and obsolete.  The caller should respond accordingly if this flag
// is set.
//
#define RETURNED_DATA_IS_STALE          0x0001
//
// MINIVDD_FAILED_TO_LOAD if set, indicates that for some reason (typically
// that the MiniVDD didn't match the chipset installed in the machine), the
// MiniVDD didn't load.  Callers can examine this flag and act accordingly.
//
#define MINIVDD_FAILED_TO_LOAD          0x0002
//
// MINIVDD_CHIP_ID_DIDNT_MATCH means that although the MiniVDD did load
// successfully, when the ChipID that the MiniVDD calculated was compared
// against the value saved in the registry, they didn't match.  An example of
// when this would happen is when the user is happily using an S3-911 card
// and then decides to upgrade his display card to an S3-864.  Since both
// cards use S3.VXD, the MiniVDD will load, however, since the card model
// is different, the VDD will return a defect to configuration manager and
// set this flag.  Callers of the GET_DISPLAY_CONFIG functions can use this
// flag to take appropriate actions to make sure that the user gets his
// configuration correct.
//
#define MINIVDD_CHIP_ID_DIDNT_MATCH     0x0004
//
// REGISTRY_BPP_NOT_VALID if set, means that we failed to obtain the BPP value
// from the registry when the VDD tried to read it.
//
#define REGISTRY_BPP_NOT_VALID          0x0008
//
// REGISTRY_RESOLUTION_NOT_VALID if set, means that we failed to obtain the
// resolution value from the registry when the VDD tried to read it.
//
#define REGISTRY_RESOLUTION_NOT_VALID   0x0010
//
// REGISTRY_DPI_NOT_VALID if set, means that we failed to obtain the
// DPI value from the registry when the VDD tried to read it.
//
#define REGISTRY_DPI_NOT_VALID          0x0020
//
// MONITOR_DEVNODE_NOT_ACTIVE is set if someone tries to make a call to the
// GET_DISPLAY_CONFIG function before the monitor DevNode has been created.
// This is certainly not fatal by any means.  It simply means that the
// monitor refresh rate info in the DISPLAYINFO data structure is totally
// invalid!
//
#define MONITOR_DEVNODE_NOT_ACTIVE      0x0040
//
// MONITOR_INFO_NOT_VALID indicates that something within the code which
// retrieves and calculates the refresh rate data has failed.  This indicates
// that the values in diRefreshRateMax through diVertSyncPolarity are not
// valid and could contain random data.
//
#define MONITOR_INFO_NOT_VALID          0x0080
//
// MONITOR_INFO_DISABLED_BY_USER indicates that the either the RefreshRate=
// string in SYSTEM.INI had a negative number in it or that the string in
// the display's software key (HKEY_CURRENT_CONFIG\Display\Settings\RefreshRate)
// was 0 or a negative number.
//
#define MONITOR_INFO_DISABLED_BY_USER   0x0100
//
// REFRESH_RATE_MAX_ONLY indicates that there was no diLowHorz, diHighHorz,
// diLowVert, diHighVert, or sync polarity data in the registry.    The
// value returned in diRefreshRateMax is the only refresh rate data that
// we have available.  This was derived either from RefreshRate= in SYSTEM.INI
// or the HKEY_CURRENT_CONFIG\Display\Settings\RefreshRate = string in the
// registry.
//
#define REFRESH_RATE_MAX_ONLY           0x0200
//
// CARD_VDD_LOADED_OK indicates that a second MiniVDD (which is useful for
// display card manufacturers wishing to extend the capabilities of the chip level
// MiniVDD's ) has successfully been loaded and initialized.
//
#define CARD_VDD_LOADED_OK              0x0400

#endif // _VDD_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\VDD.INC ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1988-1990
;
;   Title:	vdd.inc - VDD definitions for other VxD's and multiple VDD's
;
;   Version:	1.00
;
;   Date:
;
;   Author: AR, MDW
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   24-Jan-1989 MDW Added service definitions
;==============================================================================


Begin_Service_Table VDD

;***************
;VDD protect mode services for other devices and VMM(Get_Version must be first)
;
VDD_Service	VDD_Get_Version 	; Get version number and ID string ptr
VDD_Service	VDD_PIF_State		; Pass video PIF bits to VDD
VDD_Service	VDD_Get_GrabRtn 	; Get routine addr for video grab
VDD_Service	VDD_Hide_Cursor 	; Hide cursor when display is windowed
VDD_Service	VDD_Set_VMType		; Set VM type(windowed, bckgrnd, excl)
VDD_Service	VDD_Get_ModTime 	; Return system time of last mod
VDD_Service	VDD_Set_HCurTrk 	; Track horiz cursor movement in window
VDD_Service	VDD_Msg_ClrScrn 	; Clear screen for sysmodal message
VDD_Service	VDD_Msg_ForColor	; Set Msg_TextOut forground color
VDD_Service	VDD_Msg_BakColor	; Set Msg_TextOut background color
VDD_Service	VDD_Msg_TextOut 	; Output a string
VDD_Service	VDD_Msg_SetCursPos	; Set cursor position
VDD_Service	VDD_Query_Access	; Is it OK to access video now?

; New services for 3.1	Not supported for 3.0 VDD's
;
VDD_Service	VDD_Check_Update_Soon,,VGA31 ; User action may update screen

End_Service_Table VDD

IFDEF VGA31
VDD_VerNum	EQU	030Ah		; version 3, 10
ELSE
VDD_VerNum	=	0300h

IFDEF DEBUG
IFNDEF VGA
IFNDEF EGA
VDD_VerNum = VDD_VerNum + 0FFh
ENDIF ;EGA
ENDIF ;VGA
ENDIF ;DEBUG

ENDIF	;VGA31

;***************
; PIF_State service definitions
;
; These definitions cannot change without changing the PIF editor!!!
;
fVidTxtEmulate	EQU	0001h		; Do INT 10h TTY and cursor emulation
fVidNoTrpTxt	EQU	0002h		; Do not trap text mode apps
fVidNoTrpLRGrfx EQU	0004h		; Do not trap lo res graphics mode apps
fVidNoTrpHRGrfx EQU	0008h		; Do not trap hi res graphics mode apps
fVidTextMd	EQU	0010h		; Allocate text mode mem
fVidLowRsGrfxMd EQU	0020h		; Allocate lo res graphics mode mem
fVidHghRsGrfxMd EQU	0040h		; Allocate hi res graphics mode mem
fVidRetainAllo	EQU	0080h		; Never deallocate once allocated
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\VDDGRB.INC ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1989-1990
;
;***************
; Shell_Event definitions for the VDD
;
;   DO NOT CHANGE THESE EVER WITHOUT REDOING THE SHELL AND THE GRABBER
;	AND THE VDD!!!
;
VDA_Type_Chng		EQU	((0400h+20)+2)

VDA_Display_Event	EQU	((0400h+20)+6)
; On VDA_Display_Event event,
;   VMDOSAPP instance which gets the message has display event
;   wParam is a "subfunction code" which identifies the event.
;
VDA_DE_DispChngMin	EQU	0
VDA_DE_DispChngMax	EQU	80
VDA_DE_ControlChngMin	EQU	VDA_DE_DispChngMax
VDA_DE_ControlChngMax	EQU	160
VDA_DE_ScreenGrabMin	EQU	VDA_DE_ControlChngMax
VDA_DE_ScreenGrabMax	EQU	240

VDA_DE_SpecialMin	EQU	0FFAFh
VDA_DE_SpecialMax	EQU	0FFFFh
;
; Subfunctions >= VDA_DE_DispChngMin, < VDA_DE_DispChngMax indicate
;   that the display has changed without a change to the video controller
;   state.
;
; Subfunctions >= VDA_DE_ControlChngMin, < VDA_DE_ControlChngMax indicate
;   that the video controller state has changed.
;
; Subfunctions >= VDA_DE_ScreenGrabMin, < VDA_DE_ScreenGrabMax indicate
;   that a screen grab event has occured.
;
; Subfunctions >= VDA_DE_SpecialMin, < VDA_DE_SpecialMax indicate
;   private GRABBER events which VMDOSAPP just passes through to the
;   GRABBER
;
; This parameter is passed through VMDOSAPP to the display specific GRABBER.
;   "ranges" on the parameter allow specific info to be passed to the GRABBER
;   while allowing VMDOSAPP to know about the general high level aspect of the
;   event.
;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\VDD2.INC ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1989-1990
;
;   Title:	vdd2.inc - VDD definitions for Secondary VDD
;
;   Version:	1.00
;
;   Author: MDW
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   02-Aug-1989 MDW Added service definitions
;==============================================================================


Begin_Service_Table VDD2

;***************
;VDD2 services for other devices and VMM(Get_Version must be first)
;
VDD2_Service	VDD2_Get_Version	; Get version number and ID string ptr
End_Service_Table VDD2
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\VKDPASTE.INC ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1989-1990
;
;   Title:	vkdpaste.inc -
;
;   Version:	1.00
;
;   Date:	20-Mar-1989
;
;   Author:	RAP
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   20-Mar-1989 RAP
;   23-Mar-1989 RAP added PM API equates
;
;==============================================================================

;
; structure of entries in paste buffer
;
Paste_Rec STRUC
Paste_Char	    db	?   ; OEM char value
Paste_ScanCode	    db	?   ; keyboard scan code
Paste_ShiftState    dw	?   ; shift state
Paste_Rec ENDS

Paste_Key   equ word ptr Paste_Char


;BeginDoc
;------------------------------------------------------------------------------
;
; API services:
;
VKD_API_Version     equ 0
	;   ENTER:  EAX = 0
	;   EXIT:   AH = major version #
	;	    AL = minor version #
	;	    Carry clear

VKD_Current_Version equ 200h

VKD_Force_Key	    equ 1
	;   ENTER:  EAX = 1
	;	    EBX = VM handle  (0 for current)
	;	    CH = scan code
	;	    CL = repeat count
	;	    EDX = shift state  (-1 means no change)
	;   EXIT:   Carry set, if failed

;
; shift state equates
;
FKSS_Insert_Down    equ 1000000000000000b
FKSS_CapLck_Down    equ 0100000000000000b
FKSS_NumLck_Down    equ 0010000000000000b
FKSS_ScrLck_Down    equ 0001000000000000b
FKSS_Insert_On	    equ 0000000010000000b
FKSS_CapLck_On	    equ 0000000001000000b
FKSS_NumLck_On	    equ 0000000000100000b
FKSS_ScrLck_On	    equ 0000000000010000b
FKSS_Alt_Down	    equ 0000000000001000b
FKSS_Ctrl_Down	    equ 0000000000000100b
FKSS_Shift_Down     equ 0000000000000010b

;EndDoc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\VER.H ===
/****************************************************************************
*                                                                           *
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
* KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
* IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
* PURPOSE.                                                                  *
*                                                                           *
* Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
*                                                                           *
****************************************************************************/

/*****************************************************************************\
*                                                                             *
* ver.h -       Version management functions, types, and definitions          *
*                                                                             *
*               Include file for VER.DLL and VER.LIB.  These libraries are    *
*               designed to allow version stamping of Windows executable files*
*               and of special .VER files for DOS executable files.           *
*                                                                             *
*               The API is unchanged for LIB and DLL versions.                *
*                                                                             *
*******************************************************************************
*
* #define LIB   - To be used with VER.LIB (default is for VER.DLL)
*
\*****************************************************************************/

#ifndef _INC_VER
#define _INC_VER

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/*
 * If .lib version is being used, declare types used in this file.
 */
#ifdef LIB

#ifndef WINAPI                      /* don't declare if they're already declared */
#define WINAPI      _far _pascal
#define NEAR        _near
#define FAR         _far
#define PASCAL      _pascal
typedef int             BOOL;
#define TRUE        1
#define FALSE       0
typedef unsigned char   BYTE;
typedef unsigned short  WORD;
typedef unsigned int    UINT;
typedef signed long     LONG;
typedef unsigned long   DWORD;
typedef char far*       LPSTR;
typedef const char far* LPCSTR;
typedef int             HFILE;
#define OFSTRUCT    void            /* Not used by the .lib version */
#define LOWORD(l)		((WORD)(l))
#define HIWORD(l)		((WORD)(((DWORD)(l) >> 16) & 0xFFFF))
#define MAKEINTRESOURCE(i)	(LPSTR)((DWORD)((WORD)(i)))
#endif  /* WINAPI */

#else   /* LIB */

/* If .dll version is being used and we're being included with
 * the 3.0 windows.h, #define compatible type aliases.
 * If included with the 3.0 windows.h, #define compatible aliases
 */
#ifndef _INC_WINDOWS
#define UINT        WORD
#define LPCSTR      LPSTR
#define HFILE       int
#endif  /* !_INC_WINDOWS */

#endif  /* !LIB */

/* ----- RC defines ----- */
#ifdef RC_INVOKED
#define ID(id)			id
#else
#define ID(id)			MAKEINTRESOURCE(id)
#endif

/* ----- Symbols ----- */
#define VS_FILE_INFO		ID(16)		/* Version stamp res type */
#define VS_VERSION_INFO		ID(1)  		/* Version stamp res ID */
#define VS_USER_DEFINED		ID(100)		/* User-defined res IDs */

/* ----- VS_VERSION.dwFileFlags ----- */
#define	VS_FFI_SIGNATURE	0xFEEF04BDL
#define	VS_FFI_STRUCVERSION	0x00010000L
#define	VS_FFI_FILEFLAGSMASK	0x0000003FL

/* ----- VS_VERSION.dwFileFlags ----- */
#define	VS_FF_DEBUG		0x00000001L
#define	VS_FF_PRERELEASE	0x00000002L
#define	VS_FF_PATCHED		0x00000004L
#define	VS_FF_PRIVATEBUILD	0x00000008L
#define	VS_FF_INFOINFERRED	0x00000010L
#define	VS_FF_SPECIALBUILD	0x00000020L

/* ----- VS_VERSION.dwFileOS ----- */
#define	VOS_UNKNOWN		0x00000000L
#define	VOS_DOS			0x00010000L
#define	VOS_OS216		0x00020000L
#define	VOS_OS232		0x00030000L
#define	VOS_NT			0x00040000L

#define	VOS__BASE		0x00000000L
#define	VOS__WINDOWS16		0x00000001L
#define	VOS__PM16		0x00000002L
#define	VOS__PM32		0x00000003L
#define	VOS__WINDOWS32		0x00000004L

#define	VOS_DOS_WINDOWS16	0x00010001L
#define	VOS_DOS_WINDOWS32	0x00010004L
#define	VOS_OS216_PM16		0x00020002L
#define	VOS_OS232_PM32		0x00030003L
#define	VOS_NT_WINDOWS32	0x00040004L

/* ----- VS_VERSION.dwFileType ----- */
#define	VFT_UNKNOWN		0x00000000L
#define	VFT_APP			0x00000001L
#define	VFT_DLL			0x00000002L
#define	VFT_DRV			0x00000003L
#define	VFT_FONT		0x00000004L
#define	VFT_VXD			0x00000005L
#define	VFT_STATIC_LIB		0x00000007L

/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_DRV ----- */
#define	VFT2_UNKNOWN		0x00000000L
#define VFT2_DRV_PRINTER	0x00000001L
#define	VFT2_DRV_KEYBOARD	0x00000002L
#define	VFT2_DRV_LANGUAGE	0x00000003L
#define	VFT2_DRV_DISPLAY	0x00000004L
#define	VFT2_DRV_MOUSE		0x00000005L
#define	VFT2_DRV_NETWORK	0x00000006L
#define	VFT2_DRV_SYSTEM		0x00000007L
#define	VFT2_DRV_INSTALLABLE	0x00000008L
#define	VFT2_DRV_SOUND		0x00000009L
#define	VFT2_DRV_COMM		0x0000000AL
#define VFT2_DRV_INPUTMETHOD    0x0000000BL

/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_FONT ----- */
#define VFT2_FONT_RASTER	0x00000001L
#define	VFT2_FONT_VECTOR	0x00000002L
#define	VFT2_FONT_TRUETYPE	0x00000003L

/* ----- VerFindFile() flags ----- */
#define VFFF_ISSHAREDFILE	0x0001

#define VFF_CURNEDEST		0x0001
#define VFF_FILEINUSE		0x0002
#define VFF_BUFFTOOSMALL	0x0004

/* ----- VerInstallFile() flags ----- */
#define VIFF_FORCEINSTALL	0x0001
#define VIFF_DONTDELETEOLD	0x0002

#define VIF_TEMPFILE		0x00000001L
#define VIF_MISMATCH		0x00000002L
#define VIF_SRCOLD		0x00000004L

#define VIF_DIFFLANG		0x00000008L
#define VIF_DIFFCODEPG		0x00000010L
#define VIF_DIFFTYPE		0x00000020L

#define VIF_WRITEPROT		0x00000040L
#define VIF_FILEINUSE		0x00000080L
#define VIF_OUTOFSPACE		0x00000100L
#define VIF_ACCESSVIOLATION	0x00000200L
#define VIF_SHARINGVIOLATION	0x00000400L
#define VIF_CANNOTCREATE	0x00000800L
#define VIF_CANNOTDELETE	0x00001000L
#define VIF_CANNOTRENAME	0x00002000L
#define VIF_CANNOTDELETECUR	0x00004000L
#define VIF_OUTOFMEMORY		0x00008000L

#define VIF_CANNOTREADSRC	0x00010000L
#define VIF_CANNOTREADDST	0x00020000L

#define VIF_BUFFTOOSMALL	0x00040000L

#ifndef RC_INVOKED              /* RC doesn't need to see the rest of this */

/* ----- Types and structures ----- */

typedef signed short int SHORT;

typedef struct tagVS_FIXEDFILEINFO
{
    DWORD   dwSignature;            /* e.g. 0xfeef04bd */
    DWORD   dwStrucVersion;         /* e.g. 0x00000042 = "0.42" */
    DWORD   dwFileVersionMS;        /* e.g. 0x00030075 = "3.75" */
    DWORD   dwFileVersionLS;        /* e.g. 0x00000031 = "0.31" */
    DWORD   dwProductVersionMS;     /* e.g. 0x00030010 = "3.10" */
    DWORD   dwProductVersionLS;     /* e.g. 0x00000031 = "0.31" */
    DWORD   dwFileFlagsMask;        /* = 0x3F for version "0.42" */
    DWORD   dwFileFlags;            /* e.g. VFF_DEBUG | VFF_PRERELEASE */
    DWORD   dwFileOS;               /* e.g. VOS_DOS_WINDOWS16 */
    DWORD   dwFileType;             /* e.g. VFT_DRIVER */
    DWORD   dwFileSubtype;          /* e.g. VFT2_DRV_KEYBOARD */
    DWORD   dwFileDateMS;           /* e.g. 0 */
    DWORD   dwFileDateLS;           /* e.g. 0 */
} VS_FIXEDFILEINFO;

/* ----- Function prototypes ----- */

UINT WINAPI VerFindFile(UINT uFlags, LPCSTR szFileName,
      LPCSTR szWinDir, LPCSTR szAppDir,
      LPSTR szCurDir, UINT FAR* lpuCurDirLen,
      LPSTR szDestDir, UINT FAR* lpuDestDirLen);

DWORD WINAPI VerInstallFile(UINT uFlags,
      LPCSTR szSrcFileName, LPCSTR szDestFileName, LPCSTR szSrcDir,
      LPCSTR szDestDir, LPCSTR szCurDir, LPSTR szTmpFile, UINT FAR* lpuTmpFileLen);

/* Returns size of version info in bytes */
DWORD WINAPI GetFileVersionInfoSize(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      DWORD FAR *lpdwHandle);   /* Information for use by GetFileVersionInfo */

/* Read version info into buffer */
BOOL WINAPI GetFileVersionInfo(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      DWORD dwHandle,           /* Information from GetFileVersionSize */
      DWORD dwLen,              /* Length of buffer for info */
      void FAR* lpData);        /* Buffer to place the data structure */

/* Returns size of resource in bytes */
DWORD WINAPI GetFileResourceSize(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      LPCSTR lpstrResType,      /* Type:  normally VS_FILE_INFO */
      LPCSTR lpstrResID,        /* ID:  normally VS_VERSION_INFO */
      DWORD FAR *lpdwFileOffset); /* Returns file offset of resource */

/* Reads file resource into buffer */
BOOL WINAPI GetFileResource(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      LPCSTR lpstrResType,      /* Type:  normally VS_FILE_INFO */
      LPCSTR lpstrResID,        /* ID:  normally VS_VERSION_INFO */
      DWORD dwFileOffset,       /* File offset or NULL */
      DWORD dwResLen,           /* Length of resource to read or NULL */
      void FAR* lpData);        /* Pointer to data buffer */

UINT WINAPI VerLanguageName(UINT wLang, LPSTR szLang, UINT nSize);

#ifdef LIB

UINT WINAPI GetWindowsDir(LPCSTR szAppDir, LPSTR lpBuffer, int nSize);

UINT WINAPI GetSystemDir(LPCSTR szAppDir, LPSTR lpBuffer, int nSize);

#endif /* LIB */

BOOL WINAPI VerQueryValue(const void FAR* pBlock, LPCSTR lpSubBlock,
      void FAR* FAR* lplpBuffer, UINT FAR* lpuLen);

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#pragma pack()

#endif  /* !RC_INVOKED */
#endif  /* !_INC_VER */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\VMDAVGA.INC ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1988-1990
;
;   Title:	VMDAVGA.INC
;
;   Version:	3.10
;
;   Date:	15-Aug-1990
;
;   Author: AR, MDW, RAP
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   24-Jan-1989 MDW Added service definitions(some from VDAMSG.INC)
;   15-Feb-1989 MDW Memory data structures
;   15-Aug-1990 RAP VGA version of VMDAEGA.INC
;
;==============================================================================



;******************************************************************************
;
;	VDD virtual mode services for the grabber
;
GRB_Get_Version     EQU 0
GRB_Get_Mem	    EQU GRB_Get_Version + 1
GRB_Get_State	    EQU GRB_Get_Mem + 1
GRB_Get_Mod	    EQU GRB_Get_State + 1
GRB_Clear_Mod	    EQU GRB_Get_Mod + 1
GRB_Free_Mem	    EQU GRB_Clear_Mod + 1
GRB_Get_GrbMem	    EQU GRB_Free_Mem + 1
GRB_Free_Grab	    EQU GRB_Get_GrbMem + 1
GRB_Get_GrbState    EQU GRB_Free_Grab + 1
GRB_Unlock_APP	    EQU GRB_Get_GrbState + 1

; New API's for 3.1 display drivers
Private_DspDrvr_1   EQU 0Ah
			    .errnz Private_DspDrvr_1 - GRB_Unlock_APP - 1
DspDrvr_Version     EQU 0Bh
DspDrvr_Addresses   EQU 0Ch


Grabber_VerNum	    EQU     030Ah	    ; version 3, 10


;*******************************************************************************
;
;	Controller state structure
;
VDA_EGA_State	STRUC
    VDA_EGA_Mode    DB	?		; Display mode(0-A)
    VDA_EGA_Colr    DB	?		; Border color
    VDA_EGA_Flags   DB	?		; Flags
    VDA_EGA_Rows    DB	?		; Height of display in lines (text mode)
    VDA_EGA_CurX    DW	?		; Cursor horizontal position
    VDA_EGA_CurY    DW	?		; Cursor vertical position
    VDA_EGA_CurBeg  DW	?		; Cursor start scan line
    VDA_EGA_CurEnd  DW	?		; Cursor end scan line
    VDA_EGA_Pal     DB	16 DUP (?)	; Palettes(6 bits of color mapping)
VDA_EGA_State	ENDS

;*******
;
;	Controller flags
;
fVDA_V_ScOff	    EQU 0001h		; Screen off
fVDA_V_ScOffBit     EQU 0
fVDA_V_HCurTrk	    EQU 0002h		; Horizontal cursor track - keep
fVDA_V_HCurTrkBit   EQU 1		;   cursor position in window
; GEM Ventura programs DAC 0 as white - set if DAC 0 is non-zero
fVDA_V_InvDAC	    EQU 0004h		
fVDA_V_InvDACBit    EQU 2


BeginDoc
;*******************************************************************************
;   EGA/VGA VDD modifications state structure ::= <flag>,<count>,<list>
;
;   <flag> indicates type, list valid and controller change and cursor change.
;   <count> is count of entries(not bytes or words) in list.
;   <list> is type dependent as follows:
;	Type 0 - list is modified pages bit map, 1 bit per displayed 4k page,
;	    count is page count. Bit map is one byte per 32k linear address
;	    space, where byte 0's bits are <page 0 bit>,<page 1 bit>,
;	    ...,<page 7 bit>. byte 1's bits are <page 8 bit>,<page 9 bit>.
;	    A set bit indicates a change in that page.
;
;	    This type is not used for text modes.
;
;	    Modes D and E display is less than two pages long and so the
;	    page count will be two. Mode 10 page count is 7. Modes
;	    11 and 12 page count is 10.
;
;	Type 1 - modified enclosing rectangles, count is rectangle count,
;	    (less than four) , rectangle is two points: <left>,<top> and
;	    <right>,<bottom>. Each point is relative to left, upper
;	    corner which is 0,0 and each value is stored in one word.
;
;	    This type may be used for all modes.
;
;	    For text modes, modes 0-3, there may be a special, scroll rectangle.
;	    If the high bit of R_Left is set in one of these RECTs, then it is
;	    not a rect but a scroll specification.
;		The structure then becomes: <scroll count>,<scroll flags>,
;		<right column>,<left column>,<bottom line>,<top line>,
;		<fill character>,<fill attribute>
;	    Note that all items are byte values and that the scroll event
;		specification takes the same space as an update rectangle.
;
ModListMax	EQU	64		    ; Max size of VDD_Mod_List field
EndDoc
VDD_Mod_State	STRUC

    VDD_Mod_Flag    DW	?		    ; Modified state flag
    VDD_Mod_Count   DW	?		    ; Count of entries in modification list
    VDD_Mod_List    DB	ModListMax dup(?)   ; The modification list(type dependent)

VDD_Mod_State	ENDS

;*******
;
; Masks and bit numbers for VDD_Mod_Flag
;
fVDD_M_Type	EQU 0000000000000111B	; Mask for value field
fVDD_M_TypeBit	EQU 0			; start bit for value field
fVDD_M_Ctlr	EQU 0000000000001000B	; flag indicating controller state chg
fVDD_M_CtlrBit	EQU 3			; bit for controller state change
fVDD_M_VRAM	EQU 0000000000010000B	; flag indicating Video RAM change
fVDD_M_VRAMBit	EQU 4			; bit for Video RAM change
fVDD_M_Curs	EQU 0000000000100000B	; flag indicating Cursor change
fVDD_M_CursBit	EQU 5			; bit for Cursor change
fVDD_M_ScOff	EQU 0000000001000000B	; flag indicating screen is off
fVDD_M_ScOffBit EQU 6			; bit for screen off
fVDD_M_Err	EQU 1000000000000000B	; flag indicating error, can't pass mods
fVDD_M_ErrBit	EQU 15			; bit for error
;
; Values for fVDD_M_TypeMsk field
;
fVDD_M_Type_Page	EQU    0	; Bit field of modified pages
fVDD_M_Type_Rect	EQU    1	; Array of RECT structures

;*******
;
; Structure for accessing RECTs
;
Rect	STRUC
    R_Left  DW	?
    R_Top   DW	?
    R_Right DW	?
    R_Botm  DW	?
Rect	ENDS

;********
;
;	Scroll rect definition
;
; If the high bit of R_Left is set in one of these RECTs, then it is
;  not a rect but a scroll event specification.
;  THIS APPLIES TO TEXT MODE ONLY (modes 0-3)!!
;  A scroll event spec looks like this:
;
ScrollRect STRUC
    ScrCnt  DB	?	    ; Count of lines to scroll in scroll region
    ScrFlgs DB	?	    ; Flags
    ScrRgt  DB	?	    ; Right Col of scroll (0 indexed)(ignore if full width bit set)
    ScrLft  DB	?	    ; Left Col of scroll (0 indexed)(ignore if full width bit set)
    ScrBot  DB	?	    ; Bottom line of scroll (0 indexed)
    ScrTop  DB	?	    ; Top line of scroll (0 indexed)
    ScrFch  DB	?	    ; Fill character for blank lines of scroll
    ScrFatt DB	?	    ; Fill attribute for blank lines of scroll
ScrollRect ENDS

; Masks for ScrFlgs
Scr_M_Scroll	    EQU 10000000B   ; High bit of flags indicates scroll
Scr_M_ScrollBit     EQU 7
Scr_M_FullWid	    EQU 00000001B   ; Set if scroll is full width (ignore Rgt Lft)
Scr_M_FullWidBit    EQU 0
Scr_M_Up	    EQU 00000010B   ; Set if scroll is UP, clear if DOWN
Scr_M_UpBit	    EQU 1

IF2
    IF (SIZE ScrollRect) NE (SIZE Rect)
	%out ERROR -- ScrollRect is wrong size!!!!!
    ENDIF
ENDIF


;*******************************************************************************
;
;	Memory state structure
;
VDA_Mem_State	STRUC
    VDA_Mem_Addr_P0	DD  ?		; Addr of plane 0 video memory
    VDA_Mem_Addr_P1	DD  ?		; Addr of plane 1 video memory
    VDA_Mem_Addr_P2	DD  ?		; Addr of plane 2 video memory
    VDA_Mem_Addr_P3	DD  ?		; Addr of plane 3 video memory
    VDA_Mem_DPagOff	DD  ?		; 32 bit offset to start of display
    VDA_Mem_Size_P0	DD  ?		; Size of plane 0 video memory
    VDA_Mem_Size_P1	DD  ?		; Size of plane 1 video memory
    VDA_Mem_Size_P2	DD  ?		; Size of plane 2 video memory
    VDA_Mem_Size_P3	DD  ?		; Size of plane 3 video memory
    VDA_Mem_DACOff	DD  ?		; address of DAC
VDA_Mem_State	ENDS

VDA_Mem_Addr_Win_State EQU VDA_Mem_Addr_P1  ; In text (0-3,7) modes
VDA_Mem_Size_Win_State EQU VDA_Mem_Size_P1

;*******
;
; ADDRESSING VIDEO DISPLAY
;
; Start of the display memory = VDA_Mem_Addr[plane] + VDA_Mem_DPagOffset
;
;   For modes 0-6, the <plane> is always 0
;
;   Displayed memory within a plane is always contiguous from the start
;	address as computed according to the formula above and the macro below.
;	Addressing the display memory from the computed start is as follows,
;	    where X is 0 based column and Y is 0 based row.
;
;	Mode 0-1: Even byte is char, odd byte is attr, 40 cols, 25 rows
;		   one plane.
;	    ChrByteOff=(X/2)+(Y*80); AttrByteOff=ChrByteOff+1
;
;	Mode 2-3,7: Even byte is char, odd byte is attr, 80 cols, 25 rows,
;		   one plane.
;	    ChrByteOff=(X/2)+(Y*160); AttrByteOff=ChrByteOff+1
;
;	Mode 3,"43": Even byte is char, odd byte is attr, 80 cols,
;		    43 rows on EGA or VGA, one plane.
;	    ChrByteOff=(X/2)+(Y*160); AttrByteOff=ChrByteOff+1
;
;	Mode 3,"50": Even byte is char, odd byte is attr, 80 cols,
;		    50 rows on VGA, one plane.
;	    ChrByteOff=(X/2)+(Y*160); AttrByteOff=ChrByteOff+1
;
;	Mode 4-5: 2 bits per PEL, packed into bytes: bits 7-6 is PEL 0,
;		    bits 5-4 is PEL 1, etc. Where PEL = X MOD 4. Odd rows
;		    offset by 8k from even rows. 320 cols, 200 rows, one plane.
;	    PELByteOff=(X/4)+((Y/2)*80)+((Y MOD 2)*8192)
;
;	Mode 6: 1 bit per PEL, packed into bytes: bit 7 is PEL 0,
;		    bit 6 is PEL 1, bit 5 is PEL 2, etc., where PEL = X MOD 8.
;		    Odd rows offset by 8k from even rows. 640 cols, 200 rows,
;		    one plane.
;	    PELByteOff=(X/8)+((Y/2)*160)+((Y MOD 2)*8192)
;
;	Mode D: 1 bit per PEL in each plane, packed into bytes: bit 7 is PEL 0,
;		    bit 6 is PEL 1, etc., where PEL = X MOD 8. 320 cols,
;		    200 rows, 4 planes. Note that the start of each plane
;		    must be calculated according to the GetStartDispAddr macro.
;	    PELByteOff=(X/8)+(Y*80)
;
;	Mode E: 1 bit per PEL in each plane, packed into bytes: bit 7 is PEL 0,
;		    bit 6 is PEL 1, etc., where PEL = X MOD 8. 640 cols,
;		    200 rows, 4 planes. Note that the start of each plane
;		    must be calculated according to the GetStartDispAddr macro.
;	    PELByteOff=(X/8)+(Y*160)
;
;	Mode 10: 1 bit per PEL in each plane, packed into bytes: bit 7 is PEL 0,
;		    bit 6 is PEL 1, etc., where PEL = X MOD 8. 640 cols,
;		    350 rows, 4 planes. Note that the start of each plane
;		    must be calculated according to the GetStartDispAddr macro.
;	    PELByteOff=(X/8)+(Y*160)
;
;	Mode 12: 1 bit per PEL in each plane, packed into bytes: bit 7 is PEL 0,
;		    bit 6 is PEL 1, etc., where PEL = X MOD 8. 640 cols,
;		    480 rows, 4 planes. Note that the start of each plane
;		    must be calculated according to the GetStartDispAddr macro.
;	    PELByteOff=(X/8)+(Y*160)
;
;	Mode 13: 8 bits or one byte per PEL.  320 cols, 200 rows, 1 plane.
;	    PELByteOff=(X)+(Y*160)
;
;
;	DestReg     = 32 bit register to place video memory address
;	MemStateReg = 32 bit register which -> VDA_Mem_State
;	MemStateSeg = SEGMENT REGISTER for MemStateReg
;	PlaneReg    = 32 bit register holding plane number desired
;
; ALL REGISTERS MUST BE SEPARATE!!!!!
;
;
GetStartDispAddr MACRO	 DestReg,MemStateReg,PlaneReg,MemStateSeg
	mov	DestReg,MemStateSeg:[MemStateReg.VDA_Mem_Addr_P0][PlaneReg*4]
	add	DestReg,MemStateSeg:[MemStateReg.VDA_Mem_DPagOff]
	ENDM
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\VMM.H ===
/****************************************************************************
*                                                                           *
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
* KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
* IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
* PURPOSE.                                                                  *
*                                                                           *
* Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
*                                                                           *
****************************************************************************/

/*****************************************************************************
 *
 *   Title: VMM.H - Include file for Virtual Machine Manager
 *
 *   Version:   1.00
 *
 */

#ifndef _VMM_
#define _VMM_


/*
 *  NON Windows/386 Virtual Device sources can include this file to get
 *  some useful equates by declaring the symbol "Not_VxD" If this symbol
 *  is defined, then everything that has to do with the specifics of the
 *  32 bit environment for virtual devices is removed.  Useful equates
 *  include: device ID's, pushad structure, BeginDoc, EndDoc, BeginMsg,
 *  EndMsg, page table equates, etc.
 */

#define FALSE       0       // False
#define VMM_TRUE    (~FALSE)    // The opposite of False!

#define DEBLEVELRETAIL  0
#define DEBLEVELNORMAL  1
#define DEBLEVELMAX 2

#ifndef DEBLEVEL
#ifdef DEBUG
#define DEBLEVEL DEBLEVELNORMAL
#else
#define DEBLEVEL DEBLEVELRETAIL
#endif
#endif

#ifndef WIN31COMPAT
#define WIN40SERVICES
#endif

/* ASM
ifdef MASM6
ifndef NO_MASM6_OPTIONS
;
;   option switches necessary to build VMM/VxD sources with MASM 6
;
    option oldmacros
ifndef  NEWSTRUCTS      ; define NEWSTRUCTS for MASM6 struct semantics
    option oldstructs
endif
    option noscoped
    option segment:flat
    option offset:flat
    option proc:private
endif
endif
;
;   These null macros are recognized by a utility program that produces
;   documentation files.
;
IFDEF MASM6
BeginDoc MACRO
     ENDM
EndDoc MACRO
       ENDM

BeginMsg MACRO
     ENDM
EndMsg MACRO
       ENDM
ELSE
BeginDoc EQU <>
EndDoc EQU <>

BeginMsg EQU <>
EndMsg EQU <>
ENDIF
*/


/******************************************************************************
 *
 *          EQUATES FOR REQUIRED DEVICES
 *
 *   Device ID formulation note:
 *
 *  The high bit of the device ID is reserved for future use.
 *  Microsoft reserves the device ID's 0-1FFh for standard devices.  If
 *  an OEM VxD is a replacement for a standard VxD, then it must use the
 *  standard VxD ID.
 *
 *  OEMS WHO WANT A VXD DEVICE ID ASSIGNED TO THEM,
 *  PLEASE CONTACT MICROSOFT PRODUCT SUPPORT.  ID's are only required for
 *  devices which provide services, V86 API's or PM API's.  Also, calling
 *  services or API's by VxD name is now supported in version 4.0, so an
 *  ID may not be necessary as long as a unique 8 character name is used.
 *
 *****************************************************************************/

#define UNDEFINED_DEVICE_ID 0x00000
#define VMM_DEVICE_ID       0x00001 /* Used for dynalink table */
#define DEBUG_DEVICE_ID     0x00002
#define VPICD_DEVICE_ID     0x00003
#define VDMAD_DEVICE_ID     0x00004
#define VTD_DEVICE_ID       0x00005
#define V86MMGR_DEVICE_ID   0x00006
#define PAGESWAP_DEVICE_ID  0x00007
#define PARITY_DEVICE_ID    0x00008
#define REBOOT_DEVICE_ID    0x00009
#define VDD_DEVICE_ID       0x0000A
#define VSD_DEVICE_ID       0x0000B
#define VMD_DEVICE_ID       0x0000C
#define VKD_DEVICE_ID       0x0000D
#define VCD_DEVICE_ID       0x0000E
#define VPD_DEVICE_ID       0x0000F
#define BLOCKDEV_DEVICE_ID  0x00010
#define VMCPD_DEVICE_ID     0x00011
#define EBIOS_DEVICE_ID     0x00012
#define BIOSXLAT_DEVICE_ID  0x00013
#define VNETBIOS_DEVICE_ID  0x00014
#define DOSMGR_DEVICE_ID    0x00015
#define WINLOAD_DEVICE_ID   0x00016
#define SHELL_DEVICE_ID     0x00017
#define VMPOLL_DEVICE_ID    0x00018
#define VPROD_DEVICE_ID     0x00019
#define DOSNET_DEVICE_ID    0x0001A
#define VFD_DEVICE_ID       0x0001B
#define VDD2_DEVICE_ID      0x0001C /* Secondary display adapter */
#define WINDEBUG_DEVICE_ID  0x0001D
#define TSRLOAD_DEVICE_ID   0x0001E /* TSR instance utility ID */
#define BIOSHOOK_DEVICE_ID  0x0001F /* Bios interrupt hooker VxD */
#define INT13_DEVICE_ID     0x00020
#define PAGEFILE_DEVICE_ID  0x00021 /* Paging File device */
#define SCSI_DEVICE_ID      0x00022 /* SCSI device */
#define MCA_POS_DEVICE_ID   0x00023 /* MCA_POS device */
#define SCSIFD_DEVICE_ID    0x00024 /* SCSI FastDisk device */
#define VPEND_DEVICE_ID     0x00025 /* Pen device */
#define APM_DEVICE_ID       0x00026 /* Power Management device */
#define VPOWERD_DEVICE_ID   APM_DEVICE_ID   /* We overload APM since we replace it */
#define VXDLDR_DEVICE_ID    0x00027 /* VxD Loader device */
#define NDIS_DEVICE_ID      0x00028 /* NDIS wrapper */
#define BIOS_EXT_DEVICE_ID   0x00029 /* Fix Broken BIOS device */
#define VWIN32_DEVICE_ID        0x0002A /* for new WIN32-VxD */
#define VCOMM_DEVICE_ID         0x0002B /* New COMM device driver */
#define SPOOLER_DEVICE_ID       0x0002C /* Local Spooler */
#define WIN32S_DEVICE_ID    0x0002D /* Win32S on Win 3.1 driver */
#define DEBUGCMD_DEVICE_ID      0x0002E /* Debug command extensions */
/* #define RESERVED_DEVICE_ID   0x0002F /* Not currently in use */
/* #define ATI_HELPER_DEVICE_ID    0x00030 /* grabbed by ATI */

/* 31-32 USED BY WFW NET COMPONENTS     */
/* #define VNB_DEVICE_ID           0x00031 /* Netbeui of snowball */
/* #define SERVER_DEVICE_ID        0x00032 /* Server of snowball */

#define CONFIGMG_DEVICE_ID  0x00033 /* Configuration manager (Plug&Play) */
#define DWCFGMG_DEVICE_ID   0x00034 /* Configuration manager for win31 and DOS */
#define SCSIPORT_DEVICE_ID  0x00035 /* Dragon miniport loader/driver */
#define VFBACKUP_DEVICE_ID  0x00036 /* allows backup apps to work with NEC */
#define ENABLE_DEVICE_ID    0x00037 /* for access VxD */
#define VCOND_DEVICE_ID     0x00038 /* Virtual Console Device - check vcond.inc */
/* 39 used by WFW VFat Helper device */

/* 3A used by WFW E-FAX */
/* #define EFAX_DEVICE_ID   0x0003A /* EFAX VxD ID      */

/* 3B used by MS-DOS 6.1 for the DblSpace VxD which has APIs */
/* #define DSVXD_DEVICE_ID  0x0003B /* Dbl Space VxD ID */

#define ISAPNP_DEVICE_ID    0x0003C /* ISA P&P Enumerator */
#define BIOS_DEVICE_ID      0x0003D /* BIOS P&P Enumerator */
/* #define WINSOCK_DEVICE_ID       0x0003E  /* WinSockets */
/* #define WSIPX_DEVICE_ID     0x0003F  /* WinSockets for IPX */

#define IFSMgr_Device_ID    0x00040 /* Installable File System Manager */
#define VCDFSD_DEVICE_ID    0x00041 /* Static CDFS ID */
#define MRCI2_DEVICE_ID     0x00042 /* DrvSpace compression engine */
#define PCI_DEVICE_ID       0x00043 /* PCI P&P Enumerator */
#define PELOADER_DEVICE_ID  0x00044 /* PE Image Loader */
#define EISA_DEVICE_ID      0x00045 /* EISA P&P Enumerator */
#define DRAGCLI_DEVICE_ID   0x00046 /* Dragon network client */
#define DRAGSRV_DEVICE_ID   0x00047 /* Dragon network server */
#define PERF_DEVICE_ID	    0x00048 /* Config/stat info */

#define AWREDIR_DEVICE_ID   0x00049 /* AtWork Network FSD */

/*
 *   Far East DOS support VxD ID
 */

#define ETEN_Device_ID      0x00060 /* ETEN DOS (Taiwan) driver */
#define CHBIOS_Device_ID    0x00061 /* CHBIOS DOS (Korean) driver */
#define VMSGD_Device_ID    0x00062 /* DBCS Message Mode driver */
#define VPPID_Device_ID     0x00063 /* PC-98 System Control PPI */
#define VIME_Device_ID      0x00064 /* Virtual DOS IME */
#define VHBIOSD_Device_ID   0x00065 /* HBIOS (Korean) for HWin31 driver */

#define BASEID_FOR_NAMEBASEDVXD        0xf000 /* Name based VxD IDs start here */
#define BASEID_FOR_NAMEBASEDVXD_MASK   0x0fff /* Mask to get the real vxd id */ 
/*
 *   Initialization order equates.  Devices are initialized in order from
 *   LOWEST to HIGHEST. If 2 or more devices have the same initialization
 *   order value, then they are initialized in order of occurance, so a
 *   specific order is not guaranteed.  Holes have been left to allow maximum
 *   flexibility in ordering devices.
 */

#define VMM_INIT_ORDER      0x000000000
#define DEBUG_INIT_ORDER    0x000000000 /* normally using 0 is bad */
#define DEBUGCMD_INIT_ORDER     0x000000000 /*  but debug must be first */
#define PERF_INIT_ORDER     0x000900000
#define APM_INIT_ORDER          0x001000000
#define VPOWERD_INIT_ORDER  APM_INIT_ORDER  /* We overload APM since we replace it */
#define BIOSHOOK_INIT_ORDER 0x006000000
#define VPROD_INIT_ORDER    0x008000000
#define VPICD_INIT_ORDER    0x00C000000
#define VTD_INIT_ORDER      0x014000000
#define VXDLDR_INIT_ORDER   0x016000000

#define ENUMERATOR_INIT_ORDER   0x016800000 /* Should be before IOS */
#define ISAPNP_INIT_ORDER   ENUMERATOR_INIT_ORDER
#define EISA_INIT_ORDER     ENUMERATOR_INIT_ORDER
#define PCI_INIT_ORDER      ENUMERATOR_INIT_ORDER
#define BIOS_INIT_ORDER     ENUMERATOR_INIT_ORDER+1 /* To simplify reenumeration */
#define CONFIGMG_INIT_ORDER ENUMERATOR_INIT_ORDER+0xFFFF    /* After all enumerators */

#define VCDFSD_INIT_ORDER   0x016F00000
#define IOS_INIT_ORDER      0x017000000
#define PAGEFILE_INIT_ORDER 0x018000000
#define PAGESWAP_INIT_ORDER 0x01C000000
#define PARITY_INIT_ORDER   0x020000000
#define REBOOT_INIT_ORDER   0x024000000
#define EBIOS_INIT_ORDER    0x026000000
#define VDD_INIT_ORDER      0x028000000
#define VSD_INIT_ORDER      0x02C000000

#define VCD_INIT_ORDER      0x030000000
#define COMMDRVR_INIT_ORDER (VCD_INIT_ORDER - 1)
#define PRTCL_INIT_ORDER    (COMMDRVR_INIT_ORDER - 2)
#define MODEM_INIT_ORDER    (COMMDRVR_INIT_ORDER - 3)
#define PORT_INIT_ORDER     (COMMDRVR_INIT_ORDER - 4)

#define VMD_INIT_ORDER      0x034000000
#define VKD_INIT_ORDER      0x038000000
#define VPD_INIT_ORDER      0x03C000000
#define BLOCKDEV_INIT_ORDER 0x040000000
#define MCA_POS_INIT_ORDER  0x041000000
#define SCSIFD_INIT_ORDER   0x041400000
#define SCSIMASTER_INIT_ORDER   0x041800000
#define INT13_INIT_ORDER    0x042000000
#define VMCPD_INIT_ORDER    0x048000000
#define BIOSXLAT_INIT_ORDER 0x050000000
#define VNETBIOS_INIT_ORDER 0x054000000
#define DOSMGR_INIT_ORDER   0x058000000
#define DOSNET_INIT_ORDER   0x05C000000
#define WINLOAD_INIT_ORDER  0x060000000
#define VMPOLL_INIT_ORDER   0x064000000

#define UNDEFINED_INIT_ORDER    0x080000000
#define WIN32_INIT_ORDER    UNDEFINED_INIT_ORDER
#define VCOND_INIT_ORDER    UNDEFINED_INIT_ORDER

#define WINDEBUG_INIT_ORDER 0x081000000
#define VDMAD_INIT_ORDER    0x090000000
#define V86MMGR_INIT_ORDER  0x0A0000000

#define IFSMgr_Init_Order   0x10000 + V86MMGR_Init_Order
#define FSD_Init_Order      0x00100 + IFSMgr_Init_Order
#define VFD_INIT_ORDER      0x50000 + IFSMgr_Init_Order

/* Device that must touch memory in 1st Mb at crit init (after V86mmgr) */
#define UNDEF_TOUCH_MEM_INIT_ORDER  0x0A8000000
#define SHELL_INIT_ORDER    0x0B0000000

/* ASM
;******************************************************************************
;
;   Macro to cause a delay in between I/O accesses to the same device.
;
;------------------------------------------------------------------------------

IO_Delay    macro
jmp $+2
ENDM
*/

#define VXD_FAILURE 0
#define VXD_SUCCESS 1

typedef ULONG HVM;          /* VM handle typedef */

/*
 *  Registers as they appear on the stack after a PUSHAD.
 */

struct Pushad_Struc {
    ULONG Pushad_EDI;           /* Client's EDI */
    ULONG Pushad_ESI;           /* Client's ESI */
    ULONG Pushad_EBP;           /* Client's EBP */
    ULONG Pushad_ESP;           /* ESP before pushad */
    ULONG Pushad_EBX;           /* Client's EBX */
    ULONG Pushad_EDX;           /* Client's EDX */
    ULONG Pushad_ECX;           /* Client's ECX */
    ULONG Pushad_EAX;           /* Client's EAX */
};

/* XLATOFF */

#ifdef RC_INVOKED
#define NOBASEDEFS
#endif

#ifndef NOBASEDEFS

#pragma warning (disable:4209)  // turn off redefinition warning

typedef unsigned char   UCHAR;
typedef unsigned short  USHORT;

#pragma warning (default:4209)  // turn off redefinition warning

#endif

#define GetVxDServiceOrdinal(service)   __##service

#define Begin_Service_Table(device, seg) \
    enum device##_SERVICES { \
    device##_dummy = (device##_DEVICE_ID << 16) - 1,

#define Declare_Service(service, local) \
    GetVxDServiceOrdinal(service),

#define End_Service_Table(device, seg) \
    Num_##device##_Services};

#define VXDINLINE static __inline
/* XLATON */

#ifndef Not_VxD

/* XLATOFF */
#define VxD_LOCKED_CODE_SEG code_seg("_LTEXT", "LCODE")
#define VxD_LOCKED_DATA_SEG data_seg("_LDATA", "LCODE")
#define VxD_INIT_CODE_SEG   code_seg("_ITEXT", "ICODE")
#define VxD_INIT_DATA_SEG   data_seg("_IDATA", "ICODE")
#define VxD_ICODE_SEG       code_seg("_ITEXT", "ICODE")
#define VxD_IDATA_SEG       data_seg("_IDATA", "ICODE")
#define VxD_PAGEABLE_CODE_SEG   code_seg("_PTEXT", "PCODE")
#define VxD_PAGEABLE_DATA_SEG   data_seg("_PDATA", "PDATA")
#define VxD_STATIC_CODE_SEG code_seg("_STEXT", "SCODE")
#define VxD_STATIC_DATA_SEG data_seg("_SDATA", "SCODE")
#define VxD_DEBUG_ONLY_CODE_SEG code_seg("_DBOCODE", "DBOCODE")
#define VxD_DEBUG_ONLY_DATA_SEG data_seg("_DBODATA", "DBOCODE")

#define VxD_SYSEXIT_CODE_SEG    code_seg("SYSEXIT", "SYSEXITCODE")
#define VxD_INT21_CODE_SEG  code_seg("INT21", "INT21CODE")
#define VxD_RARE_CODE_SEG   code_seg("RARE", "RARECODE")
#define VxD_W16_CODE_SEG    code_seg("W16", "W16CODE")
#define VxD_W32_CODE_SEG    code_seg("W32", "W32CODE")
#define VxD_VMCREATE_CODE_SEG   code_seg("VMCREATE", "VMCREATECODE")
#define VxD_VMDESTROY_CODE_SEG  code_seg("VMDESTROY", "VMDESTROYCODE")
#define VxD_THCREATE_CODE_SEG   code_seg("THCREATE", "THCREATECODE")
#define VxD_THDESTROY_CODE_SEG  code_seg("THDESTROY", "THDESTROYCODE")
#define VxD_VMSUSPEND_CODE_SEG  code_seg("VMSUSPEND", "VMSUSPENDCODE")
#define VxD_VMRESUME_CODE_SEG   code_seg("VMRESUME", "VMRESUMECODE")
#define VxD_PNP_CODE_SEG    code_seg("PNP", "PNPCODE")
#define VxD_DOSVM_CODE_SEG  code_seg("DOSVM", "DOSVMCODE")
#define VxD_LOCKABLE_CODE_SEG   code_seg("LOCKABLE", "LOCKABLECODE")
/* XLATON */

/* ASM
??_CUR_CODE_SEG = 0

??_LCODE    =   1
??_ICODE    =   2
??_PCODE    =   3
??_SCODE    =   4
??_DBOCODE  =   5
??_16ICODE  =   6
??_RCODE    =   7
??_LOCKABLECODE =   8

?_LCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_LCODE>
?_ICODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_ICODE>
?_PCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_PCODE>
?_SCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_SCODE>
?_DBOCODE   equ <(??_CUR_CODE_SEG MOD 16) - ??_DBOCODE>
?_16ICODE   equ <(??_CUR_CODE_SEG MOD 16) - ??_16ICODE>
?_RCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_RCODE>
?_LOCKABLECODE  equ <(??_CUR_CODE_SEG MOD 16) - ??_LOCKABLECODE>

ifndef NO_SEGMENTS

;
;  SEGMENT definitions and order
;

IFDEF   MASM6
_FLAT   EQU FLAT
ELSE
_FLAT   EQU USE32
ENDIF

;*  32 bit locked code
_LTEXT      SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_LTEXT      ENDS

_TEXT       SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_TEXT       ENDS

;*  32 bit pageable code
_PTEXT      SEGMENT DWORD PUBLIC _FLAT 'PCODE'
_PTEXT      ENDS



MakeCodeSeg MACRO seglist, classname, grpname, iseg

    IRP segname,<seglist>   ;; For each name in the list

IFNB    <classname>
    segname     SEGMENT DWORD PUBLIC _FLAT "&classname&CODE"
ELSE
    segname     SEGMENT DWORD PUBLIC _FLAT "&segname&CODE"
ENDIF

IFB <iseg>
VxD_&&segname&&_CODE_SEG MACRO
segname  SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_PCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

        ENDM
ELSE
VxD_&&segname&&_CODE_SEG MACRO
segname  SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + iseg
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

        ENDM
ENDIF

VxD_&&segname&&_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
segname ENDS
        ENDM

segname     ENDS

IFNDEF BLD_COFF
IFNB    <grpname>
    _&grpname GROUP segname
ELSE
    _&&segname GROUP segname
ENDIF
ENDIF

    ENDM                ;; End for each segment

    ENDM

MakeCodeSeg <LOCKABLE_BEGIN, LOCKABLE, LOCKABLE_END>, \
    LOCKABLE, LOCKABLE, ??_LOCKABLECODE
MakeCodeSeg INT21
MakeCodeSeg SYSEXIT
MakeCodeSeg RARE
MakeCodeSeg W16
MakeCodeSeg W32
MakeCodeSeg VMCREATE
MakeCodeSeg VMDESTROY
MakeCodeSeg THCREATE
MakeCodeSeg THDESTROY
MakeCodeSeg VMSUSPEND
MakeCodeSeg VMRESUME
MakeCodeSeg PNP
MakeCodeSeg DOSVM


;***    DefLockableCodeBegin - define beginning of lockable code
;
;   Defines a label with the given name to mark the beginning
;   of the lockable code area for this VxD.  In the debug version,
;   also defines a DWORD containing DFS_TEST_BLOCK so that
;   procedures in the lockable code segment defined with
;   BeginProc may call _Debug_Flags_Service with flags appropriate
;   to the code's current state.

DefLockableCodeBegin MACRO name, private
VxD_LOCKABLE_BEGIN_CODE_SEG
IFB <private>
    PUBLIC  name
ENDIF
name    LABEL   NEAR
VxD_LOCKABLE_BEGIN_CODE_ENDS
ifndef WIN31COMPAT
if DEBLEVEL
VxD_LOCKED_DATA_SEG
    PUBLIC name&_Debug_Flags
name&_Debug_Flags DD DFS_TEST_BLOCK
VxD_LOCKED_DATA_ENDS
??_debug_flags equ <name&_Debug_Flags>
endif
endif
    ENDM

;***    DefLockableCodeEnd - define end of lockable code
;
;   Defines a label with the given name to mark the end
;   of the lockable code area for this VxD.  By subtracting
;   the offset of the beginning label from the offset of
;   the ending label, the VxD may determine how many bytes
;   of memory to lock or unlock.

DefLockableCodeEnd MACRO name, private
VxD_LOCKABLE_END_CODE_SEG
IFB <private>
    PUBLIC  name
ENDIF
name    LABEL   NEAR
VxD_LOCKABLE_END_CODE_ENDS
    ENDM

;***    CodeLockFlags - declare locked code debug flags
;
;   This macro declares the locked code debug flags.

CodeLockFlags MACRO name
ifndef WIN31COMPAT
if DEBLEVEL
    ifndef name&_Debug_Flags
    VxD_LOCKED_DATA_SEG
        extrn   name&_Debug_Flags:dword
    VxD_LOCKED_DATA_ENDS
    ??_debug_flags equ <name&_Debug_Flags>
    endif
endif
endif
    ENDM

;***    MarkCodeLocked - signify that lockable code is locked
;
;   This macro clears DFS_TEST_BLOCK in the debug flags
;   DWORD.

MarkCodeLocked MACRO
ifndef WIN31COMPAT
if DEBLEVEL
ifdef ??_debug_flags
    pushfd
    and ??_debug_flags,NOT DFS_TEST_BLOCK
    popfd
endif
endif
endif
    ENDM

;***    MarkCodeUnlocked - signify that lockable code is unlocked
;
;   This macro sets DFS_TEST_BLOCK in the debug flags
;   DWORD.

MarkCodeUnlocked MACRO
ifndef WIN31COMPAT
if DEBLEVEL
ifdef ??_debug_flags
    pushfd
    or  ??_debug_flags,DFS_TEST_BLOCK
    popfd
endif
endif
endif
    ENDM


;*  32 bit initialization code
_ITEXT      SEGMENT DWORD PUBLIC _FLAT 'ICODE'
_ITEXT      ENDS

;*  32 bit locked data
_LDATA      SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_LDATA      ENDS

_DATA       SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_DATA       ENDS

;*  32 bit pageable data
_PDATA      SEGMENT DWORD PUBLIC _FLAT 'PDATA'
_PDATA      ENDS

;*  32 Bit initialization data
_IDATA      SEGMENT DWORD PUBLIC _FLAT 'ICODE'
_IDATA      ENDS

;*  Created by C8
_BSS        SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_BSS        ENDS

CONST       SEGMENT DWORD PUBLIC _FLAT 'LCODE'
CONST       ENDS

_TLS        SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_TLS        ENDS

;*  32 Bit static code for DL-VxDs
_STEXT      SEGMENT DWORD PUBLIC _FLAT 'SCODE'
_STEXT      ENDS

;*  32 Bit static data for DL-VxDs
_SDATA      SEGMENT DWORD PUBLIC _FLAT 'SCODE'
_SDATA      ENDS

;*      dummy segment for IsDebugOnlyLoaded
_DBOSTART   SEGMENT DWORD PUBLIC _FLAT 'DBOCODE'
_DBOSTART   ENDS

;*      32 bit debug only code; loaded only if debugger is present
_DBOCODE    SEGMENT DWORD PUBLIC _FLAT 'DBOCODE'
_DBOCODE    ENDS

;*      32 bit debug only data; loaded only if debugger is present
_DBODATA    SEGMENT DWORD PUBLIC _FLAT 'DBOCODE'
_DBODATA    ENDS

if DEBLEVEL
;*	Start of 32 bit path coverage data
_PATHSTART  SEGMENT DWORD PUBLIC  _FLAT 'LCODE'
_PATHSTART  ENDS

;*	32 bit path coverage data
_PATHDATA   SEGMENT DWORD PUBLIC  _FLAT 'LCODE'
_PATHDATA   ENDS

;*	End of 32 bit path coverage data
_PATHEND    SEGMENT DWORD PUBLIC  _FLAT 'LCODE'
_PATHEND    ENDS
endif

;*  16 bit code/data that is put into IGROUP automaticly
_16ICODE    SEGMENT WORD USE16 PUBLIC '16ICODE'
_16ICODE    ENDS

;*  Real Mode initialization code/data for devices
_RCODE      SEGMENT WORD USE16 PUBLIC 'RCODE'
_RCODE      ENDS

IFNDEF BLD_COFF
_LGROUP   GROUP _LTEXT, _TEXT, _LDATA, _DATA, _BSS, CONST, _TLS
_IGROUP   GROUP _ITEXT, _IDATA
_SGROUP   GROUP _STEXT, _SDATA
_DBOGROUP GROUP _DBOSTART, _DBOCODE, _DBODATA
IF DEBLEVEL
_PGROUP	  GROUP _PATHSTART, _PATHDATA, _PATHEND
ENDIF
ENDIF

endif ; NO_SEGMENTS

    ASSUME CS:FLAT, DS:FLAT, ES:FLAT, SS:FLAT

OFFSET32 EQU <OFFSET FLAT:>


BeginDoc
;==============================================================================
; The following macros are used in defining the routines
;   in a VxD which are going to be registered with VMM as callable entry
;   points. Once registered, the entry points can be called by any other
;   devices via the "VxDCall" macro, defined below. In the comments below,
;   replace "VxD" with the appropriate device name.
;
;*******
;   In the VxD.INC file, put the following lines, replacing <function_name>
;   with an appropriate name describing the function of the routine.
;
;   Begin_Service_Table VxD[,<segname>]
;   VxD_Service <function_name>[,<local segname>]
;   VxD_Service <function_name>[,<local segname>]
;       . . .
;   VxD_Service <function_name>[,<local segname>]
;   End_Service_Table   VxD[,<segname>]
;
;   Note that <segname> is an optional argument and, if specified, the
;   table is put in the segment defined by the macro "yyy_Data_Seg",
;   where yyy=segname. Otherwise the segment is defined by the
;   "VxD_Data_Seg" macro, defined below.
;   Note that <local segname> is an optional argument and, if specified,
;   the procedure's segment is defined by the macro "zzz_Code_Seg",
;   where zzz=segname. Otherwise the segment is defined by the
;   "VxD_Code_Seg" macro, defined below.
;
;*******
; One VxD module should have the following in order to define the entry points:
;Create_VxD_Service_Table = 1           ; Only in module where table is
;   INCLUDE     VxD.INC         ; Include the table definition
;
;*******
; All modules that want to call the services defined in the table should include
;   VxD.INC, but not define the label "Create_VxD_Service_Table". This
;   will define the service names to be used with the VxDCall macro.
;
EndDoc

Begin_Service_Table MACRO Device_Name, Def_Segment

IFDEF   Device_Name&_Name_Based
 IFNDEF @@NextInternalID
    @@NextInternalID    = 0
 ENDIF
 @@NextInternalID = (@@NextInternalID + 1)
 Device_Name&_Internal_ID   = @@NextInternalID + BASEID_FOR_NAMEBASEDVXD
 DefineVxDName  Device_Name, %Device_Name&_Internal_ID
ENDIF

IFB <Def_Segment>
    BST2 Device_Name, VxD
ELSE
    BST2 Device_Name, Def_Segment
ENDIF
    ENDM

DefineVxDName   MACRO Device_Name, InternalID
 @@VxDName&InternalID EQU   <___&Device_Name&STable>
ENDM


BST2 MACRO Device_Name, Def_Segment

Num_&Device_Name&_Services = 0

IFDEF Create_&Device_Name&_Service_Table

Def_Segment&_LOCKED_DATA_SEG

Device_Name&_Service_Table LABEL DWORD

Device_Name&_Service MACRO Procedure, Local_Seg, Condition
LOCAL $$&Procedure

  IFNB <Condition>
  $$&&Procedure MACRO extern
    IFDEF &Condition
      IFNB <extern>
    EXTRN   Procedure:NEAR
      ELSE
    dd  OFFSET32 Procedure
      ENDIF
    ELSE
      IFB <extern>
      dd      0
      ENDIF
    ENDIF
    ENDM
  ENDIF

  IFDIFI <Procedure>, <RESERVED>
    PUBLIC _&&Procedure
     IF1
    _&&Procedure LABEL DWORD
     ENDIF
     IFDIFI <Local_Seg>, <LOCAL>
        IFNB <Local_Seg>
Local_Seg&&_SEG
       ELSE
Def_Segment&_CODE_SEG
        ENDIF
        IFNB <Condition>
    $$&&Procedure extern
       ELSE
    EXTRN   Procedure:NEAR
        ENDIF
        IFNB <Local_Seg>
Local_Seg&&_ENDS
        ELSE
Def_Segment&_CODE_ENDS
        ENDIF
     ENDIF
      IFNB <Condition>
    $$&&Procedure
      ELSE
    dd  OFFSET32 Procedure
      ENDIF

          IFDEF Device_Name&_Name_Based
        @@&&Procedure = (Device_Name&_Internal_ID SHL 16) + Num_&Device_Name&_Services
          ELSE
        @@&&Procedure = (Device_Name&_Device_ID SHL 16) + Num_&Device_Name&_Services
          ENDIF
  ELSE
    dd  0
  ENDIF
    Num_&Device_Name&_Services = Num_&Device_Name&_Services + 1
  IFNB <Condition>
    Purge $$&&Procedure
  ENDIF
    ENDM

ELSE

; Local_Seg and Condition are placeholders only in this form

IFDEF   Device_Name&_Name_Based

Device_Name&_Service MACRO Procedure, Local_Seg, Condition


  IFDIFI <Procedure>, <RESERVED>
    @@&&Procedure = (Device_Name&_Internal_ID SHL 16) + Num_&Device_Name&_Services
  ENDIF
    Num_&Device_Name&_Services = Num_&Device_Name&_Services + 1

    ENDM
ELSE

Device_Name&_Service MACRO Procedure, Local_Seg, Condition

  IFDIFI <Procedure>, <RESERVED>
    @@&&Procedure = (Device_Name&_Device_ID SHL 16) + Num_&Device_Name&_Services
  ENDIF
    Num_&Device_Name&_Services = Num_&Device_Name&_Services + 1

    ENDM
ENDIF

ENDIF

    ENDM

;------------------------------------------------------------------------------

End_Service_Table MACRO Device_Name, Def_Segment

    PURGE   Device_Name&_Service

IFDEF Create_&Device_Name&_Service_Table

IFB <Def_Segment>
VxD_LOCKED_DATA_ENDS
ELSE
Def_Segment&_LOCKED_DATA_ENDS
ENDIF

ENDIF

    ENDM

GetVxDServiceOrdinal    macro   reg,service
    mov reg,@@&service
    endm

GetVxDServiceAddress    macro   reg,service
    mov reg,OFFSET32 service
    endm


;***    Begin_Win32_Services - begin defining Win32 Service Table
;
;   This macro is used to begin the definition of the Win32
;   Service table.  It is modelled after, but not identical
;   to, the Begin_Service_Table macro.  If the the special
;   symbol Create_Win32_Services is defined to be true, then
;   the actual table is emitted.  Otherwise, only the service
;   numbers are defined.
;
;   ENTRY   VxDName     - the name of the VxD; it is assumed
;                 that a corresponding Device_ID is
;                 also defined.
;   EXIT    The macro VxDName&_Win32_Sevice is defined; it
;       accepts a service name as its only parameter.
;       This macro is then used to define each service.

Begin_Win32_Services MACRO VxDName
ifndef Create_Win32_Services
    Create_Win32_Services = 0
endif
    .errb <VxDName>, <VxD name missing>
    ??w32svcno = 0
if Create_Win32_Services
VxDName&_Win32_Services label dword
    dd  csvc&VxDName, 0
endif
    ??inw32svc = 1

    VxDName&_Win32_Service MACRO Name
        .erre ??inw32svc, <Missing Begin_Win32_Services>
    if Create_Win32_Services
        dd  OFFSET32 Name,cparm&&Name
    endif
        @32&&Name equ   ((VxDName&_Device_ID SHL 16) + ??w32svcno)
        ??w32svcno = ??w32svcno + 1
        ENDM
    ENDM


;***    End_Win32_Services - mark end of Win32 Service Table
;
;   This macro completes initialization of the Win32
;   Service table.
;
;   ENTRY   VxDName     - the same name passed to
;                 Begin_Win32_services

End_Win32_Services MACRO VxDName
    .errb <VxDName>, <VxD name misssing>
if Create_Win32_Services
    csvc&VxDName    equ ($ - VxDName&_Win32_Services)/8 - 1
endif
    ??inw32svc = 0
    PURGE VxDName&_Win32_Service
    ENDM


;***    Declare_Win32_Service - declare an external Win32 Service
;
;   This macro is used to declare a Win32 service that
;   is defined elsewhere, perhaps in a C module.
;
;   ENTRY   Name        - the service name
;       cParms      - the number of DWORD parameters
;   EXIT    The name is defined as external

Declare_Win32_Service MACRO Name, cParms
ifndef Create_Win32_Services
    Create_Win32_Services = 0
endif
if Create_Win32_Services
    ?merge  <Name>,,,,<EQU>,<_>,<Name>,<@>,%(cParms*4 + 8)
    ?merge  <cparm>,<Name>,,,<EQU>,<cParms>
VxD_CODE_SEG
    ?merge  <EXTRN>,,,,,<_>,<Name>,<@>,%(cParms*4 + 8),<:NEAR>
VxD_CODE_ENDS
endif
    ENDM


;***    Win32call - call a Win32 service from a ring 3 thunk
;
;   This macro is used to call a Win32 service from
;   a ring 3 thunk.  Note that control will not return
;   to the instruction following the call, but to the
;   instruction following the call to the thunk.
;
;   ENTRY   Service     - the name of the service
;       CallBack    - the fword containing the callback

Win32call MACRO Service, CallBack
ifndef Create_Win32_Services
    Create_Win32_Services = 0
endif
ife Create_Win32_Services
    mov eax,@32&Service
ifdef IS_16
    movzx   esp,sp
endif
    call    fword ptr [CallBack]
ifdef DEBUG
    int 3
endif
endif
    ENDM
*/

/*XLATOFF*/
#define GetVxDServiceAddress(service)   service

#define VxDCall(service) \
    _asm _emit 0xcd \
    _asm _emit 0x20 \
    _asm _emit (GetVxDServiceOrdinal(service) & 0xff) \
    _asm _emit (GetVxDServiceOrdinal(service) >> 8) & 0xff \
    _asm _emit (GetVxDServiceOrdinal(service) >> 16) & 0xff \
    _asm _emit (GetVxDServiceOrdinal(service) >> 24) & 0xff \

#define VMMCall VxDCall

#define VxDJmp(service) \
    _asm _emit 0xcd \
    _asm _emit 0x20 \
    _asm _emit (GetVxDServiceOrdinal(service) & 0xff) \
    _asm _emit ((GetVxDServiceOrdinal(service) >> 8) & 0xff) | 0x80 \
    _asm _emit (GetVxDServiceOrdinal(service) >> 16) & 0xff \
    _asm _emit (GetVxDServiceOrdinal(service) >> 24) & 0xff \

#define VMMJmp  VxDJmp

#define SERVICE     __cdecl
#define ASYNC_SERVICE   __cdecl
#define WIN32_SERVICE   void __stdcall
/*XLATON*/

/* ASM
;******************************************************************************
;
;   Dword_Align -- Aligns code to dword boundry by inserting nops
;
;------------------------------------------------------------------------------

Dword_Align MACRO Seg_Name
    LOCAL segn
IFDEF MASM6
    align 4
ELSE
IFNB <Seg_Name>
    segn equ Seg_Name
ELSE
IFE ?_LCODE
    segn equ <_LTEXT>
ELSE
IFE ?_ICODE
    segn equ <_ITEXT>
ELSE
IFE ?_PCODE
    segn equ <_PTEXT>
ELSE
IFE ?_SCODE
    segn equ <_STEXT>
ELSE
.err <Dword_Align not supported>
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
IF (($-OFFSET segn:0) MOD 4)
db 4 - (($-OFFSET segn:0) MOD 4) DUP (90h)
ENDIF
ENDIF
        ENDM


BeginDoc
;******************************************************************************
;
;   Fatal_Error
;
;   DESCRIPTION:
;   This macro is used to crash Windows/386 when an unrecoverable error
;   is detected.  If Msg_Ptr is ommitted then no error message will be
;   displayed, otherwise Msg_Ptr is the address
;   when the
;
;   PARAMETERS:
;   Msg_Ptr (OPTIONAL) - Points to an ASCIIZ string to display.
;
;   EXIT:
;   To DOS (hopefully).  This macro never returns.
;
;==============================================================================
EndDoc

Fatal_Error MACRO Msg_Ptr, Exit_Flags
    pushad
IFB <Msg_Ptr>
    xor esi, esi
ELSE
    mov esi, Msg_Ptr
IFB <Exit_Flags>
    xor eax, eax
ELSE
    mov eax, Exit_Flags
ENDIF
ENDIF
    VMMCall Fatal_Error_Handler
    ENDM

EF_Hang_On_Exit     EQU     1h
*/


/******************************************************************************
 *
 *   The following are control block headers and flags of interest to VxDs.
 *
 *****************************************************************************/

struct cb_s {
    ULONG CB_VM_Status;         /* VM status flags */
    ULONG CB_High_Linear;       /* Address of VM mapped high */
    ULONG CB_Client_Pointer;
    ULONG CB_VMID;
    ULONG CB_Signature;
};

#define VMCB_ID 0x62634D56      /* VMcb */

/*
 *  VM status indicates globally interesting VM states
 */

#define VMSTAT_EXCLUSIVE_BIT    0x00    /* VM is exclusive mode */
#define VMSTAT_EXCLUSIVE        (1L << VMSTAT_EXCLUSIVE_BIT)
#define VMSTAT_BACKGROUND_BIT   0x01    /* VM runs in background */
#define VMSTAT_BACKGROUND       (1L << VMSTAT_BACKGROUND_BIT)
#define VMSTAT_CREATING_BIT 0x02    /* In process of creating */
#define VMSTAT_CREATING         (1L << VMSTAT_CREATING_BIT)
#define VMSTAT_SUSPENDED_BIT    0x03    /* VM not scheduled */
#define VMSTAT_SUSPENDED        (1L << VMSTAT_SUSPENDED_BIT)
#define VMSTAT_NOT_EXECUTEABLE_BIT 0x04 /* VM partially destroyed */
#define VMSTAT_NOT_EXECUTEABLE  (1L << VMSTAT_NOT_EXECUTEABLE_BIT)
#define VMSTAT_PM_EXEC_BIT  0x05    /* Currently in PM app */
#define VMSTAT_PM_EXEC          (1L << VMSTAT_PM_EXEC_BIT)
#define VMSTAT_PM_APP_BIT   0x06    /* PM app present in VM */
#define VMSTAT_PM_APP           (1L << VMSTAT_PM_APP_BIT)
#define VMSTAT_PM_USE32_BIT 0x07    /* PM app is 32-bit */
#define VMSTAT_PM_USE32         (1L << VMSTAT_PM_USE32_BIT)
#define VMSTAT_VXD_EXEC_BIT 0x08    /* Call from VxD */
#define VMSTAT_VXD_EXEC         (1L << VMSTAT_VXD_EXEC_BIT)
#define VMSTAT_HIGH_PRI_BACK_BIT 0x09   /* High pri background */
#define VMSTAT_HIGH_PRI_BACK    (1L << VMSTAT_HIGH_PRI_BACK_BIT)
#define VMSTAT_BLOCKED_BIT  0x0A    /* Blocked on semaphore */
#define VMSTAT_BLOCKED          (1L << VMSTAT_BLOCKED_BIT)
#define VMSTAT_AWAKENING_BIT    0x0B    /* Woke up after blocked */
#define VMSTAT_AWAKENING        (1L << VMSTAT_AWAKENING_BIT)
#define VMSTAT_PAGEABLEV86BIT   0x0C    /* part of V86 is pageable (PM app) */
#define VMSTAT_PAGEABLEV86_BIT  VMSTAT_PAGEABLEV86BIT
#define VMSTAT_PAGEABLEV86      (1L << VMSTAT_PAGEABLEV86BIT)
#define VMSTAT_V86INTSLOCKEDBIT 0x0D    /* Locked regardless of pager type */
#define VMSTAT_V86INTSLOCKED_BIT VMSTAT_V86INTSLOCKEDBIT
#define VMSTAT_V86INTSLOCKED    (1L << VMSTAT_V86INTSLOCKEDBIT)
#define VMSTAT_IDLE_TIMEOUT_BIT 0x0E    /* Scheduled by time-slicer */
#define VMSTAT_IDLE_TIMEOUT     (1L << VMSTAT_IDLE_TIMEOUT_BIT)
#define VMSTAT_IDLE_BIT         0x0F    /* VM has released time slice */
#define VMSTAT_IDLE             (1L << VMSTAT_IDLE_BIT)
#define VMSTAT_CLOSING_BIT  0x10    /* Close_VM called for VM */
#define VMSTAT_CLOSING          (1L << VMSTAT_CLOSING_BIT)
#define VMSTAT_TS_SUSPENDED_BIT 0x11    /* VM suspended by */
#define VMSTAT_TS_SUSPENDED     (1L << VMSTAT_TS_SUSPENDED_BIT)
#define VMSTAT_TS_MAXPRI_BIT    0x12    /* this is fgd_pri 10,000 internally*/
#define VMSTAT_TS_MAXPRI        (1L << VMSTAT_TS_MAXPRI_BIT)

#define VMSTAT_USE32_MASK   (VMSTAT_PM_USE32 | VMSTAT_VXD_EXEC)

struct tcb_s {
    ULONG   TCB_Flags;          /* Thread status flags */
    ULONG   TCB_Reserved1;      /* Used internally by VMM */
    ULONG   TCB_Reserved2;      /* Used internally by VMM */
    ULONG   TCB_Signature;
    ULONG   TCB_ClientPtr;      /* Client registers of thread */
    ULONG   TCB_VMHandle;       /* VM that thread is part of */
    USHORT  TCB_ThreadId;       /* Unique Thread ID */
    USHORT  TCB_PMLockOrigSS;       /* Original SS:ESP before lock stack */
    ULONG   TCB_PMLockOrigESP;
    ULONG   TCB_PMLockOrigEIP;      /* Original CS:EIP before lock stack */
    ULONG   TCB_PMLockStackCount;
    USHORT  TCB_PMLockOrigCS;
    USHORT  TCB_PMPSPSelector;
    ULONG   TCB_ThreadType;     /* dword passed to VMMCreateThread */
    USHORT  TCB_pad1;           /* reusable; for dword align */
    UCHAR   TCB_pad2;           /* reusable; for dword align */
    UCHAR   TCB_extErrLocus;        /* extended error Locus */
    USHORT  TCB_extErr;         /* extended error Code */
    UCHAR   TCB_extErrAction;       /*      "   "   Action */
    UCHAR   TCB_extErrClass;        /*      "   "   Class */
    ULONG   TCB_extErrPtr;      /*      "   pointer */

};

typedef struct tcb_s TCB;
typedef TCB *PTCB;

#define SCHED_OBJ_ID_THREAD         0x42434854    // THCB in ASCII

/*
 *  Thread status indicates globally interesting thread states.
 *  Flags are for information only and must not be modified.
 */

#define THFLAG_SUSPENDED_BIT        0x03   // Thread not scheduled
#define THFLAG_SUSPENDED                   (1L << THFLAG_SUSPENDED_BIT)
#define THFLAG_NOT_EXECUTEABLE_BIT  0x04   // Thread partially destroyed
#define THFLAG_NOT_EXECUTEABLE             (1L << THFLAG_NOT_EXECUTEABLE_BIT)
#define THFLAG_THREAD_CREATION_BIT  0x08   // Thread in status nascendi
#define THFLAG_THREAD_CREATION             (1L << THFLAG_THREAD_CREATION_BIT)
#define THFLAG_THREAD_BLOCKED_BIT   0x0A   // Blocked on semaphore
#define THFLAG_THREAD_BLOCKED              (1L << THFLAG_THREAD_BLOCKED_BIT)
#define THFLAG_RING0_THREAD_BIT     0x1C   // thread runs only at ring 0
#define THFLAG_RING0_THREAD	           (1L << THFLAG_RING0_THREAD_BIT)
#define THFLAG_CHARSET_BITS     0x10   // Default character set
#define THFLAG_CHARSET_MASK        (3L << THFLAG_CHARSET_BITS)
#define THFLAG_ANSI            (0L << THFLAG_CHARSET_BITS)
#define THFLAG_OEM             (1L << THFLAG_CHARSET_BITS)
#define THFLAG_UNICODE             (2L << THFLAG_CHARSET_BITS)
#define THFLAG_RESERVED            (3L << THFLAG_CHARSET_BITS)
#define THFLAG_EXTENDED_HANDLES_BIT 0x12   // Thread uses extended file handles
#define THFLAG_EXTENDED_HANDLES            (1L << THFLAG_EXTENDED_HANDLES_BIT)
/* the win32 loader opens win32 exes with this bit set to notify IFS
 * so a defragger won't move these files
 * the bit is turned off once the open completes.  
 * file open flags are overloaded which is why this is here
 */
#define THFLAG_OPEN_AS_IMMOVABLE_FILE_BIT 0x13   // File thus opened not moved
#define THFLAG_OPEN_AS_IMMOVABLE_FILE            (1L << THFLAG_OPEN_AS_IMMOVABLE_FILE_BIT)

/*
 *   Protected mode application control blocks
 */
struct pmcb_s {
    ULONG PMCB_Flags;
    ULONG PMCB_Parent;
};

/*
 *  The reference data for fault error codes 1-5 (GSDVME_PRIVINST through
 *  GSDVME_INVALFLT) is a pointer to the following fault information structure.
 */
struct VMFaultInfo {
    ULONG VMFI_EIP;             // faulting EIP
    WORD  VMFI_CS;              // faulting CS
    WORD  VMFI_Ints;            // interrupts in service, if any
};

typedef struct VMFaultInfo *PVMFaultInfo;

/******************************************************************************
 *              V M M   S E R V I C E S
 ******************************************************************************/

/*XLATOFF*/
#define VMM_Service Declare_Service
#pragma warning (disable:4003)      // turn off not enough params warning
/*XLATON*/

/*MACROS*/
Begin_Service_Table(VMM, VMM)

VMM_Service (Get_VMM_Version, LOCAL)    // MUST REMAIN SERVICE 0!

VMM_Service (Get_Cur_VM_Handle)
VMM_Service (Test_Cur_VM_Handle)
VMM_Service (Get_Sys_VM_Handle)
VMM_Service (Test_Sys_VM_Handle)
VMM_Service (Validate_VM_Handle)

VMM_Service (Get_VMM_Reenter_Count)
VMM_Service (Begin_Reentrant_Execution)
VMM_Service (End_Reentrant_Execution)

VMM_Service (Install_V86_Break_Point)
VMM_Service (Remove_V86_Break_Point)
VMM_Service (Allocate_V86_Call_Back)
VMM_Service (Allocate_PM_Call_Back)

VMM_Service (Call_When_VM_Returns)

VMM_Service (Schedule_Global_Event)
VMM_Service (Schedule_VM_Event)
VMM_Service (Call_Global_Event)
VMM_Service (Call_VM_Event)
VMM_Service (Cancel_Global_Event)
VMM_Service (Cancel_VM_Event)
VMM_Service (Call_Priority_VM_Event)
VMM_Service (Cancel_Priority_VM_Event)

VMM_Service (Get_NMI_Handler_Addr)
VMM_Service (Set_NMI_Handler_Addr)
VMM_Service (Hook_NMI_Event)

VMM_Service (Call_When_VM_Ints_Enabled)
VMM_Service (Enable_VM_Ints)
VMM_Service (Disable_VM_Ints)

VMM_Service (Map_Flat)
VMM_Service (Map_Lin_To_VM_Addr)

//   Scheduler services

VMM_Service (Adjust_Exec_Priority)
VMM_Service (Begin_Critical_Section)
VMM_Service (End_Critical_Section)
VMM_Service (End_Crit_And_Suspend)
VMM_Service (Claim_Critical_Section)
VMM_Service (Release_Critical_Section)
VMM_Service (Call_When_Not_Critical)
VMM_Service (Create_Semaphore)
VMM_Service (Destroy_Semaphore)
VMM_Service (Wait_Semaphore)
VMM_Service (Signal_Semaphore)
VMM_Service (Get_Crit_Section_Status)
VMM_Service (Call_When_Task_Switched)
VMM_Service (Suspend_VM)
VMM_Service (Resume_VM)
VMM_Service (No_Fail_Resume_VM)
VMM_Service (Nuke_VM)
VMM_Service (Crash_Cur_VM)

VMM_Service (Get_Execution_Focus)
VMM_Service (Set_Execution_Focus)
VMM_Service (Get_Time_Slice_Priority)
VMM_Service (Set_Time_Slice_Priority)
VMM_Service (Get_Time_Slice_Granularity)
VMM_Service (Set_Time_Slice_Granularity)
VMM_Service (Get_Time_Slice_Info)
VMM_Service (Adjust_Execution_Time)
VMM_Service (Release_Time_Slice)
VMM_Service (Wake_Up_VM)
VMM_Service (Call_When_Idle)

VMM_Service (Get_Next_VM_Handle)

//   Time-out and system timer services

VMM_Service (Set_Global_Time_Out)
VMM_Service (Set_VM_Time_Out)
VMM_Service (Cancel_Time_Out)
VMM_Service (Get_System_Time)
VMM_Service (Get_VM_Exec_Time)

VMM_Service (Hook_V86_Int_Chain)
VMM_Service (Get_V86_Int_Vector)
VMM_Service (Set_V86_Int_Vector)
VMM_Service (Get_PM_Int_Vector)
VMM_Service (Set_PM_Int_Vector)

VMM_Service (Simulate_Int)
VMM_Service (Simulate_Iret)
VMM_Service (Simulate_Far_Call)
VMM_Service (Simulate_Far_Jmp)
VMM_Service (Simulate_Far_Ret)
VMM_Service (Simulate_Far_Ret_N)
VMM_Service (Build_Int_Stack_Frame)

VMM_Service (Simulate_Push)
VMM_Service (Simulate_Pop)

// Heap Manager

VMM_Service (_HeapAllocate)
VMM_Service (_HeapReAllocate)
VMM_Service (_HeapFree)
VMM_Service (_HeapGetSize)

/*ENDMACROS*/

/****************************************************
 *
 *   Flags for heap allocator calls
 *
 *   NOTE: HIGH 8 BITS (bits 24-31) are reserved
 *
 ***************************************************/

#define HEAPZEROINIT    0x00000001
#define HEAPZEROREINIT  0x00000002
#define HEAPNOCOPY  0x00000004
#define HEAPLOCKEDIFDP  0x00000100
#define HEAPSWAP    0x00000200
#define HEAPINIT        0x00000400
#define HEAPCLEAN   0x00000800

// Page Manager

/*MACROS*/
VMM_Service (_PageAllocate)
VMM_Service (_PageReAllocate)
VMM_Service (_PageFree)
VMM_Service (_PageLock)
VMM_Service (_PageUnLock)
VMM_Service (_PageGetSizeAddr)
VMM_Service (_PageGetAllocInfo)
VMM_Service (_GetFreePageCount)
VMM_Service (_GetSysPageCount)
VMM_Service (_GetVMPgCount)
VMM_Service (_MapIntoV86)
VMM_Service (_PhysIntoV86)
VMM_Service (_TestGlobalV86Mem)
VMM_Service (_ModifyPageBits)
VMM_Service (_CopyPageTable)
VMM_Service (_LinMapIntoV86)
VMM_Service (_LinPageLock)
VMM_Service (_LinPageUnLock)
VMM_Service (_SetResetV86Pageable)
VMM_Service (_GetV86PageableArray)
VMM_Service (_PageCheckLinRange)
VMM_Service (_PageOutDirtyPages)
VMM_Service (_PageDiscardPages)
/*ENDMACROS*/

/****************************************************
 *
 *  Flags for other page allocator calls
 *
 *  NOTE: HIGH 8 BITS (bits 24-31) are reserved
 *
 ***************************************************/

#define PAGEZEROINIT        0x00000001
#define PAGEUSEALIGN        0x00000002
#define PAGECONTIG      0x00000004
#define PAGEFIXED       0x00000008
#define PAGEDEBUGNULFAULT   0x00000010
#define PAGEZEROREINIT      0x00000020
#define PAGENOCOPY      0x00000040
#define PAGELOCKED      0x00000080
#define PAGELOCKEDIFDP      0x00000100
#define PAGESETV86PAGEABLE  0x00000200
#define PAGECLEARV86PAGEABLE    0x00000400
#define PAGESETV86INTSLOCKED    0x00000800
#define PAGECLEARV86INTSLOCKED  0x00001000
#define PAGEMARKPAGEOUT     0x00002000
#define PAGEPDPSETBASE      0x00004000
#define PAGEPDPCLEARBASE    0x00008000
#define PAGEDISCARD     0x00010000
#define PAGEPDPQUERYDIRTY   0x00020000
#define PAGEMAPFREEPHYSREG  0x00040000
#define PAGENOMOVE      0x10000000
#define PAGEMAPGLOBAL       0x40000000
#define PAGEMARKDIRTY       0x80000000

/****************************************************
 *
 *      Flags for _PhysIntoV86,
 *      _MapIntoV86, and _LinMapIntoV86
 *
 ***************************************************/

#define MAPV86_IGNOREWRAP       0x00000001


// Informational services

/*MACROS*/
VMM_Service (_GetNulPageHandle)
VMM_Service (_GetFirstV86Page)
VMM_Service (_MapPhysToLinear)
VMM_Service (_GetAppFlatDSAlias)
VMM_Service (_SelectorMapFlat)
VMM_Service (_GetDemandPageInfo)
VMM_Service (_GetSetPageOutCount)
/*ENDMACROS*/

/*
 *  Flags bits for _GetSetPageOutCount
 */
#define GSPOC_F_GET 0x00000001

// Device VM page manager

/*MACROS*/
VMM_Service (Hook_V86_Page)
VMM_Service (_Assign_Device_V86_Pages)
VMM_Service (_DeAssign_Device_V86_Pages)
VMM_Service (_Get_Device_V86_Pages_Array)
VMM_Service (MMGR_SetNULPageAddr)

// GDT/LDT management

VMM_Service (_Allocate_GDT_Selector)
VMM_Service (_Free_GDT_Selector)
VMM_Service (_Allocate_LDT_Selector)
VMM_Service (_Free_LDT_Selector)
VMM_Service (_BuildDescriptorDWORDs)
VMM_Service (_GetDescriptor)
VMM_Service (_SetDescriptor)
/*ENDMACROS*/

/*
 *  Flag equates for _BuildDescriptorDWORDs
 */
#define BDDEXPLICITDPL  0x00000001

/*
 *  Flag equates for _Allocate_LDT_Selector
 */
#define ALDTSPECSEL 0x00000001

/*MACROS*/
VMM_Service (_MMGR_Toggle_HMA)
/*ENDMACROS*/

/*
 *  Flag equates for _MMGR_Toggle_HMA
 */
#define MMGRHMAPHYSICAL 0x00000001
#define MMGRHMAENABLE   0x00000002
#define MMGRHMADISABLE  0x00000004
#define MMGRHMAQUERY    0x00000008

/*MACROS*/
VMM_Service (Get_Fault_Hook_Addrs)
VMM_Service (Hook_V86_Fault)
VMM_Service (Hook_PM_Fault)
VMM_Service (Hook_VMM_Fault)
VMM_Service (Begin_Nest_V86_Exec)
VMM_Service (Begin_Nest_Exec)
VMM_Service (Exec_Int)
VMM_Service (Resume_Exec)
VMM_Service (End_Nest_Exec)

VMM_Service (Allocate_PM_App_CB_Area, VMM_ICODE)
VMM_Service (Get_Cur_PM_App_CB)

VMM_Service (Set_V86_Exec_Mode)
VMM_Service (Set_PM_Exec_Mode)

VMM_Service (Begin_Use_Locked_PM_Stack)
VMM_Service (End_Use_Locked_PM_Stack)

VMM_Service (Save_Client_State)
VMM_Service (Restore_Client_State)

VMM_Service (Exec_VxD_Int)

VMM_Service (Hook_Device_Service)

VMM_Service (Hook_Device_V86_API)
VMM_Service (Hook_Device_PM_API)

VMM_Service (System_Control)

//   I/O and software interrupt hooks

VMM_Service (Simulate_IO)
VMM_Service (Install_Mult_IO_Handlers)
VMM_Service (Install_IO_Handler)
VMM_Service (Enable_Global_Trapping)
VMM_Service (Enable_Local_Trapping)
VMM_Service (Disable_Global_Trapping)
VMM_Service (Disable_Local_Trapping)

//   Linked List Abstract Data Type Services

VMM_Service (List_Create)
VMM_Service (List_Destroy)
VMM_Service (List_Allocate)
VMM_Service (List_Attach)
VMM_Service (List_Attach_Tail)
VMM_Service (List_Insert)
VMM_Service (List_Remove)
VMM_Service (List_Deallocate)
VMM_Service (List_Get_First)
VMM_Service (List_Get_Next)
VMM_Service (List_Remove_First)
/*ENDMACROS*/

/*
 *   Flags used by List_Create
 */
#define LF_ASYNC_BIT        0
#define LF_ASYNC        (1 << LF_ASYNC_BIT)
#define LF_USE_HEAP_BIT     1
#define LF_USE_HEAP     (1 << LF_USE_HEAP_BIT)
#define LF_ALLOC_ERROR_BIT  2
#define LF_ALLOC_ERROR      (1 << LF_ALLOC_ERROR_BIT)
/*
 * Swappable lists must use the heap.
 */
#define LF_SWAP         (LF_USE_HEAP + (1 << 3))

/******************************************************************************
 *  I N I T I A L I Z A T I O N   P R O C E D U R E S
 ******************************************************************************/

// Instance data manager

/*MACROS*/
VMM_Service (_AddInstanceItem)

// System structure data manager

VMM_Service (_Allocate_Device_CB_Area)
VMM_Service (_Allocate_Global_V86_Data_Area, VMM_ICODE)
VMM_Service (_Allocate_Temp_V86_Data_Area, VMM_ICODE)
VMM_Service (_Free_Temp_V86_Data_Area, VMM_ICODE)
/*ENDMACROS*/

/*
 *  Flag bits for _Allocate_Global_V86_Data_Area
 */
#define GVDAWordAlign       0x00000001
#define GVDADWordAlign      0x00000002
#define GVDAParaAlign       0x00000004
#define GVDAPageAlign       0x00000008
#define GVDAInstance        0x00000100
#define GVDAZeroInit        0x00000200
#define GVDAReclaim	    0x00000400
#define GVDAInquire	    0x00000800
#define GVDAHighSysCritOK   0x00001000
#define GVDAOptInstance     0x00002000
#define GVDAForceLow	    0x00004000

/*
 *  Flag bits for _Allocate_Temp_V86_Data_Area
 */
#define TVDANeedTilInitComplete 0x00000001

// Initialization information calls (win.ini and environment parameters)

/*MACROS*/
VMM_Service (Get_Profile_Decimal_Int, VMM_ICODE)
VMM_Service (Convert_Decimal_String, VMM_ICODE)
VMM_Service (Get_Profile_Fixed_Point, VMM_ICODE)
VMM_Service (Convert_Fixed_Point_String, VMM_ICODE)
VMM_Service (Get_Profile_Hex_Int, VMM_ICODE)
VMM_Service (Convert_Hex_String, VMM_ICODE)
VMM_Service (Get_Profile_Boolean, VMM_ICODE)
VMM_Service (Convert_Boolean_String, VMM_ICODE)
VMM_Service (Get_Profile_String, VMM_ICODE)
VMM_Service (Get_Next_Profile_String, VMM_ICODE)
VMM_Service (Get_Environment_String, VMM_ICODE)
VMM_Service (Get_Exec_Path, VMM_ICODE)
VMM_Service (Get_Config_Directory, VMM_ICODE)
VMM_Service (OpenFile, VMM_ICODE)
/*ENDMACROS*/

// OpenFile, if called after init, must point EDI to a buffer of at least
// this size.

#define VMM_OPENFILE_BUF_SIZE       260

/*MACROS*/
VMM_Service (Get_PSP_Segment, VMM_ICODE)
VMM_Service (GetDOSVectors, VMM_ICODE)
VMM_Service (Get_Machine_Info)
/*ENDMACROS*/

#define GMIF_80486_BIT  0x10
#define GMIF_80486  (1 << GMIF_80486_BIT)
#define GMIF_PCXT_BIT   0x11
#define GMIF_PCXT   (1 << GMIF_PCXT_BIT)
#define GMIF_MCA_BIT    0x12
#define GMIF_MCA    (1 << GMIF_MCA_BIT)
#define GMIF_EISA_BIT   0x13
#define GMIF_EISA   (1 << GMIF_EISA_BIT)
#define GMIF_CPUID_BIT  0x14
#define GMIF_CPUID  (1 << GMIF_CPUID_BIT)

// Following service is not restricted to initialization

/*MACROS*/
VMM_Service (GetSet_HMA_Info)
VMM_Service (Set_System_Exit_Code)

VMM_Service (Fatal_Error_Handler)
VMM_Service (Fatal_Memory_Error)

//   Called by VTD only

VMM_Service (Update_System_Clock)

/******************************************************************************
 *          D E B U G G I N G   E X T E R N S
 ******************************************************************************/

VMM_Service (Test_Debug_Installed)      // Valid call in retail also

VMM_Service (Out_Debug_String)
VMM_Service (Out_Debug_Chr)
VMM_Service (In_Debug_Chr)
VMM_Service (Debug_Convert_Hex_Binary)
VMM_Service (Debug_Convert_Hex_Decimal)

VMM_Service (Debug_Test_Valid_Handle)
VMM_Service (Validate_Client_Ptr)
VMM_Service (Test_Reenter)
VMM_Service (Queue_Debug_String)
VMM_Service (Log_Proc_Call)
VMM_Service (Debug_Test_Cur_VM)

VMM_Service (Get_PM_Int_Type)
VMM_Service (Set_PM_Int_Type)

VMM_Service (Get_Last_Updated_System_Time)
VMM_Service (Get_Last_Updated_VM_Exec_Time)

VMM_Service (Test_DBCS_Lead_Byte)       // for DBCS Enabling
/*ENDMACROS*/

/* ASM
.errnz  @@Test_DBCS_Lead_Byte - 100D1h   ; VMM service table changed above this service
*/

/*************************************************************************
 *************************************************************************
 * END OF 3.00 SERVICE TABLE MUST NOT SHUFFLE SERVICES BEFORE THIS POINT
 *  FOR COMPATIBILITY.
 *************************************************************************
 *************************************************************************/

/*MACROS*/
VMM_Service (_AddFreePhysPage, VMM_ICODE)
VMM_Service (_PageResetHandlePAddr)
VMM_Service (_SetLastV86Page, VMM_ICODE)
VMM_Service (_GetLastV86Page)
VMM_Service (_MapFreePhysReg)
VMM_Service (_UnmapFreePhysReg)
VMM_Service (_XchgFreePhysReg)
VMM_Service (_SetFreePhysRegCalBk, VMM_ICODE)
VMM_Service (Get_Next_Arena, VMM_ICODE)
VMM_Service (Get_Name_Of_Ugly_TSR, VMM_ICODE)
VMM_Service (Get_Debug_Options, VMM_ICODE)
/*ENDMACROS*/

/*
 *  Flags for AddFreePhysPage
 */
#define AFPP_SWAPOUT     0x0001 // physical memory that must be swapped out
                                // and subsequently restored at system exit
/*
 *  Flags for PageChangePager
 */
#define PCP_CHANGEPAGER     0x1 // change the pager for the page range
#define PCP_CHANGEPAGERDATA 0x2 // change the pager data dword for the pages
#define PCP_VIRGINONLY      0x4 // make the above changes to virgin pages only


/*
 *  Bits for the ECX return of Get_Next_Arena
 */
#define GNA_HIDOSLINKED  0x0002 // High DOS arenas linked when WIN386 started
#define GNA_ISHIGHDOS    0x0004 // High DOS arenas do exist

/*MACROS*/
VMM_Service (Set_Physical_HMA_Alias, VMM_ICODE)
VMM_Service (_GetGlblRng0V86IntBase, VMM_ICODE)
VMM_Service (_Add_Global_V86_Data_Area, VMM_ICODE)

VMM_Service (GetSetDetailedVMError)
/*ENDMACROS*/

/*
 *  Error code values for the GetSetDetailedVMError service. PLEASE NOTE
 *  that all of these error code values need to have bits set in the high
 *  word. This is to prevent collisions with other VMDOSAPP standard errors.
 *  Also, the low word must be non-zero.
 *
 *  First set of errors (high word = 0001) are intended to be used
 *  when a VM is CRASHED (VNE_Crashed or VNE_Nuked bit set on
 *  VM_Not_Executeable).
 *
 *  PLEASE NOTE that each of these errors (high word == 0001) actually
 *  has two forms:
 *
 *  0001xxxxh
 *  8001xxxxh
 *
 *  The device which sets the error initially always sets the error with
 *  the high bit CLEAR. The system will then optionally set the high bit
 *  depending on the result of the attempt to "nicely" crash the VM. This
 *  bit allows the system to tell the user whether the crash is likely or
 *  unlikely to destabalize the system.
 */
#define GSDVME_PRIVINST     0x00010001  /* Privledged instruction */
#define GSDVME_INVALINST    0x00010002  /* Invalid instruction */
#define GSDVME_INVALPGFLT   0x00010003  /* Invalid page fault */
#define GSDVME_INVALGPFLT   0x00010004  /* Invalid GP fault */
#define GSDVME_INVALFLT     0x00010005  /* Unspecified invalid fault */
#define GSDVME_USERNUKE     0x00010006  /* User requested NUKE of VM */
#define GSDVME_DEVNUKE      0x00010007  /* Device specific problem */
#define GSDVME_DEVNUKEHDWR  0x00010008  /* Device specific problem:
                         *   invalid hardware fiddling
                         *   by VM (invalid I/O)
                         */
#define GSDVME_NUKENOMSG    0x00010009  /* Supress standard messages:
                         *   SHELL_Message used for
                         *   custom msg.
                         */
#define GSDVME_OKNUKEMASK   0x80000000  /* "Nice nuke" bit */

/*
 *  Second set of errors (high word = 0002) are intended to be used
 *  when a VM start up is failed (VNE_CreateFail, VNE_CrInitFail, or
 *  VNE_InitFail bit set on VM_Not_Executeable).
 */
#define GSDVME_INSMEMV86    0x00020001  /* base V86 mem    - V86MMGR */
#define GSDVME_INSV86SPACE  0x00020002  /* Kb Req too large - V86MMGR */
#define GSDVME_INSMEMXMS    0x00020003  /* XMS Kb Req      - V86MMGR */
#define GSDVME_INSMEMEMS    0x00020004  /* EMS Kb Req      - V86MMGR */
#define GSDVME_INSMEMV86HI  0x00020005  /* Hi DOS V86 mem   - DOSMGR
                         *           V86MMGR
                         */
#define GSDVME_INSMEMVID    0x00020006  /* Base Video mem   - VDD */
#define GSDVME_INSMEMVM     0x00020007  /* Base VM mem     - VMM
                         *   CB, Inst Buffer
                         */
#define GSDVME_INSMEMDEV    0x00020008  /* Couldn't alloc base VM
                         * memory for device.
                         */
#define GSDVME_CRTNOMSG     0x00020009  /* Supress standard messages:
                         *   SHELL_Message used for
                         *   custom msg.
                         */

/*MACROS*/
VMM_Service (Is_Debug_Chr)

//   Mono_Out services

VMM_Service (Clear_Mono_Screen)
VMM_Service (Out_Mono_Chr)
VMM_Service (Out_Mono_String)
VMM_Service (Set_Mono_Cur_Pos)
VMM_Service (Get_Mono_Cur_Pos)
VMM_Service (Get_Mono_Chr)

//   Service locates a byte in ROM

VMM_Service (Locate_Byte_In_ROM, VMM_ICODE)

VMM_Service (Hook_Invalid_Page_Fault)
VMM_Service (Unhook_Invalid_Page_Fault)
/*ENDMACROS*/

/*
 *  Flag bits of IPF_Flags
 */
#define IPF_PGDIR   0x00000001  /* Page directory entry not-present */
#define IPF_V86PG   0x00000002  /* Unexpected not present Page in V86 */
#define IPF_V86PGH  0x00000004  /* Like IPF_V86PG at high linear */
#define IPF_INVTYP  0x00000008  /* page has invalid not present type */
#define IPF_PGERR   0x00000010  /* pageswap device failure */
#define IPF_REFLT   0x00000020  /* re-entrant page fault */
#define IPF_VMM     0x00000040  /* Page fault caused by a VxD */
#define IPF_PM      0x00000080  /* Page fault by VM in Prot Mode */
#define IPF_V86     0x00000100  /* Page fault by VM in V86 Mode */

/*MACROS*/
VMM_Service (Set_Delete_On_Exit_File)

VMM_Service (Close_VM)
/*ENDMACROS*/

/*
 *   Flags for Close_VM service
 */

#define CVF_CONTINUE_EXEC_BIT   0
#define CVF_CONTINUE_EXEC   (1 << CVF_CONTINUE_EXEC_BIT)

/*MACROS*/
VMM_Service (Enable_Touch_1st_Meg)      // Debugging only
VMM_Service (Disable_Touch_1st_Meg)     // Debugging only

VMM_Service (Install_Exception_Handler)
VMM_Service (Remove_Exception_Handler)

VMM_Service (Get_Crit_Status_No_Block)
/*ENDMACROS*/

/* ASM
; Check if VMM service table has changed above this service
.errnz   @@Get_Crit_Status_No_Block - 100F1h
*/

#ifdef WIN40SERVICES

/*************************************************************************
 *************************************************************************
 *
 * END OF 3.10 SERVICE TABLE MUST NOT SHUFFLE SERVICES BEFORE THIS POINT
 *  FOR COMPATIBILITY.
 *************************************************************************
 *************************************************************************/

/*MACROS*/
VMM_Service (_GetLastUpdatedThreadExecTime)

VMM_Service (_Trace_Out_Service)
VMM_Service (_Debug_Out_Service)
VMM_Service (_Debug_Flags_Service)
/*ENDMACROS*/

#endif /* WIN40SERVICES */


/*
 *   Flags for _Debug_Flags_Service service.
 *
 *   Don't change these unless you really really know what you're doing.
 *   We need to define these even if we are in WIN31COMPAT mode.
 */

#define DFS_LOG_BIT         0
#define DFS_LOG             (1 << DFS_LOG_BIT)
#define DFS_PROFILE_BIT         1
#define DFS_PROFILE         (1 << DFS_PROFILE_BIT)
#define DFS_TEST_CLD_BIT        2
#define DFS_TEST_CLD            (1 << DFS_TEST_CLD_BIT)
#define DFS_NEVER_REENTER_BIT       3
#define DFS_NEVER_REENTER       (1 << DFS_NEVER_REENTER_BIT)
#define DFS_TEST_REENTER_BIT        4
#define DFS_TEST_REENTER        (1 << DFS_TEST_REENTER_BIT)
#define DFS_NOT_SWAPPING_BIT        5
#define DFS_NOT_SWAPPING        (1 << DFS_NOT_SWAPPING_BIT)
#define DFS_TEST_BLOCK_BIT      6
#define DFS_TEST_BLOCK          (1 << DFS_TEST_BLOCK_BIT)

#define DFS_RARE_SERVICES	0xFFFFFF80

#define DFS_EXIT_NOBLOCK        (DFS_RARE_SERVICES+0)
#define DFS_ENTER_NOBLOCK       (DFS_RARE_SERVICES+DFS_TEST_BLOCK)

#define DFS_TEST_NEST_EXEC	(DFS_RARE_SERVICES+1)

#ifdef WIN40SERVICES

/*MACROS*/
VMM_Service (VMMAddImportModuleName)

VMM_Service (VMM_Add_DDB)
VMM_Service (VMM_Remove_DDB)

VMM_Service (Test_VM_Ints_Enabled)
VMM_Service (_BlockOnID)

VMM_Service (Schedule_Thread_Event)
VMM_Service (Cancel_Thread_Event)
VMM_Service (Set_Thread_Time_Out)
VMM_Service (Set_Async_Time_Out)

VMM_Service (_AllocateThreadDataSlot)
VMM_Service (_FreeThreadDataSlot)
/*ENDMACROS*/

/*
 *  Flag equates for _CreateMutex
 */
#define	MUTEX_MUST_COMPLETE		1L
#define	MUTEX_NO_CLEANUP_THREAD_STATE	2L

/*MACROS*/
VMM_Service (_CreateMutex)

VMM_Service (_DestroyMutex)
VMM_Service (_GetMutexOwner)
VMM_Service (Call_When_Thread_Switched)

VMM_Service (VMMCreateThread)
VMM_Service (_GetThreadExecTime)
VMM_Service (VMMTerminateThread)

VMM_Service (Get_Cur_Thread_Handle)
VMM_Service (Test_Cur_Thread_Handle)
VMM_Service (Get_Sys_Thread_Handle)
VMM_Service (Test_Sys_Thread_Handle)
VMM_Service (Validate_Thread_Handle)
VMM_Service (Get_Initial_Thread_Handle)
VMM_Service (Test_Initial_Thread_Handle)
VMM_Service (Debug_Test_Valid_Thread_Handle)
VMM_Service (Debug_Test_Cur_Thread)

VMM_Service (VMM_GetSystemInitState)

VMM_Service (Cancel_Call_When_Thread_Switched)
VMM_Service (Get_Next_Thread_Handle)
VMM_Service (Adjust_Thread_Exec_Priority)

VMM_Service (_Deallocate_Device_CB_Area)
VMM_Service (Remove_IO_Handler)
VMM_Service (Remove_Mult_IO_Handlers)
VMM_Service (Unhook_V86_Int_Chain)
VMM_Service (Unhook_V86_Fault)
VMM_Service (Unhook_PM_Fault)
VMM_Service (Unhook_VMM_Fault)
VMM_Service (Unhook_Device_Service)

VMM_Service (_PageReserve)
VMM_Service (_PageCommit)
VMM_Service (_PageDecommit)
VMM_Service (_PagerRegister)
VMM_Service (_PagerQuery)
VMM_Service (_PagerDeregister)
VMM_Service (_ContextCreate)
VMM_Service (_ContextDestroy)
VMM_Service (_PageAttach)
VMM_Service (_PageFlush)
VMM_Service (_SignalID)
VMM_Service (_PageCommitPhys)

VMM_Service (_Register_Win32_Services)

VMM_Service (Cancel_Call_When_Not_Critical)
VMM_Service (Cancel_Call_When_Idle)
VMM_Service (Cancel_Call_When_Task_Switched)

VMM_Service (_Debug_Printf_Service)
VMM_Service (_EnterMutex)
VMM_Service (_LeaveMutex)
VMM_Service (Simulate_VM_IO)
VMM_Service (Signal_Semaphore_No_Switch)

VMM_Service (_ContextSwitch)
VMM_Service (_PageModifyPermissions)
VMM_Service (_PageQuery)

VMM_Service (_EnterMustComplete)
VMM_Service (_LeaveMustComplete)
VMM_Service (_ResumeExecMustComplete)
/*ENDMACROS*/

/*
 *  Flag equates for _GetThreadTerminationStatus
 */
#define THREAD_TERM_STATUS_CRASH_PEND       1L
#define THREAD_TERM_STATUS_NUKE_PEND        2L
#define THREAD_TERM_STATUS_SUSPEND_PEND     4L

/*MACROS*/
VMM_Service (_GetThreadTerminationStatus)
VMM_Service (_GetInstanceInfo)
/*ENDMACROS*/

/*
 *  Return values for _GetInstanceInfo
 */
#define INSTINFO_NONE   0       /* no data instanced in range */
#define INSTINFO_SOME   1       /* some data instanced in range */
#define INSTINFO_ALL    2       /* all data instanced in range */

/*MACROS*/
VMM_Service (_ExecIntMustComplete)
VMM_Service (_ExecVxDIntMustComplete)

VMM_Service (Begin_V86_Serialization)

VMM_Service (Unhook_V86_Page)
VMM_Service (VMM_GetVxDLocationList)
VMM_Service (VMM_GetDDBList)
VMM_Service (Unhook_NMI_Event)

VMM_Service (Get_Instanced_V86_Int_Vector)
VMM_Service (Get_Set_Real_DOS_PSP)
/*ENDMACROS*/

#define GSRDP_Set   0x0001

/*MACROS*/
VMM_Service (Call_Priority_Thread_Event)
VMM_Service (Get_System_Time_Address)
VMM_Service (Get_Crit_Status_Thread)

VMM_Service (Get_DDB)
VMM_Service (Directed_Sys_Control)
/*ENDMACROS*/

// Registry APIs for VxDs
/*MACROS*/
VMM_Service (_RegOpenKey)
VMM_Service (_RegCloseKey)
VMM_Service (_RegCreateKey)
VMM_Service (_RegDeleteKey)
VMM_Service (_RegEnumKey)
VMM_Service (_RegQueryValue)
VMM_Service (_RegSetValue)
VMM_Service (_RegDeleteValue)
VMM_Service (_RegEnumValue)
VMM_Service (_RegQueryValueEx)
VMM_Service (_RegSetValueEx)
/*ENDMACROS*/

#ifndef REG_SZ      // define only if not there already

#define REG_SZ      0x0001
#define REG_BINARY  0x0003

#endif

#ifndef HKEY_LOCAL_MACHINE  // define only if not there already

#define HKEY_CLASSES_ROOT       0x80000000
#define HKEY_CURRENT_USER       0x80000001
#define HKEY_LOCAL_MACHINE      0x80000002
#define HKEY_USERS          	0x80000003
#define HKEY_PERFORMANCE_DATA   0x80000004
#define HKEY_CURRENT_CONFIG     0x80000005
#define HKEY_DYN_DATA       	0x80000006

#endif

/*MACROS*/
VMM_Service (_CallRing3)
VMM_Service (Exec_PM_Int)
VMM_Service (_RegFlushKey)
VMM_Service (_PageCommitContig)
VMM_Service (_GetCurrentContext)

VMM_Service (_LocalizeSprintf)
VMM_Service (_LocalizeStackSprintf)

VMM_Service (Call_Restricted_Event)
VMM_Service (Cancel_Restricted_Event)

VMM_Service (Register_PEF_Provider, VMM_ICODE)

VMM_Service (_GetPhysPageInfo)

VMM_Service (_RegQueryInfoKey)
VMM_Service (MemArb_Reserve_Pages)
/*ENDMACROS*/

/*
 *  Return values for _GetPhysPageInfo
 */
#define PHYSINFO_NONE   0       /* no pages in the specified range exist */
#define PHYSINFO_SOME   1       /* some pages in the specified range exist */
#define PHYSINFO_ALL    2       /* all pages in the specified range exist */

// New timeslicer services
/*MACROS*/
VMM_Service (Time_Slice_Sys_VM_Idle)
VMM_Service (Time_Slice_Sleep)
VMM_Service (Boost_With_Decay)
VMM_Service (Set_Inversion_Pri)
VMM_Service (Reset_Inversion_Pri)
VMM_Service (Release_Inversion_Pri)
VMM_Service (Get_Thread_Win32_Pri)
VMM_Service (Set_Thread_Win32_Pri)
VMM_Service (Set_Thread_Static_Boost)
VMM_Service (Set_VM_Static_Boost)
VMM_Service (Release_Inversion_Pri_ID)
VMM_Service (Attach_Thread_To_Group)
VMM_Service (Detach_Thread_From_Group)
VMM_Service (Set_Group_Static_Boost)

VMM_Service (_GetRegistryPath, VMM_ICODE)
VMM_Service (_GetRegistryKey)
/*ENDMACROS*/

// TYPE definitions for _GetRegistryKey

#define REGTYPE_ENUM    0
#define REGTYPE_CLASS   1
#define REGTYPE_VXD     2

// Flag definitions for _GetRegistryKey
#define REGKEY_OPEN                 0
#define REGKEY_CREATE_IFNOTEXIST    1

// Flag definitions for _Assert_Range
#define ASSERT_RANGE_NULL_BAD   0x00000000
#define ASSERT_RANGE_NULL_OK    0x00000001
#define ASSERT_RANGE_NO_DEBUG   0x80000000
#define ASSERT_RANGE_BITS       0x80000001

/*MACROS*/
VMM_Service (Cleanup_Thread_State)
VMM_Service (_RegRemapPreDefKey)
VMM_Service (End_V86_Serialization)
VMM_Service (_Assert_Range)
VMM_Service (_Sprintf)
VMM_Service (_PageChangePager)
VMM_Service (_RegCreateDynKey)
VMM_Service (_RegQueryMultipleValues)

// Additional timeslicer services
VMM_Service (Boost_Thread_With_VM)
/*ENDMACROS*/

// Flag definitions for Get_Boot_Flags

#define BOOT_CLEAN              0x00000001
#define BOOT_DOSCLEAN           0x00000002
#define BOOT_NETCLEAN           0x00000004
#define BOOT_INTERACTIVE        0x00000008

/*MACROS*/
VMM_Service (Get_Boot_Flags)
VMM_Service (Set_Boot_Flags)

// String and memory services
VMM_Service (_lstrcpyn)
VMM_Service (_lstrlen)
VMM_Service (_lmemcpy)

VMM_Service (_GetVxDName)

// For vwin32 use only
VMM_Service (Force_Mutexes_Free)
VMM_Service (Restore_Forced_Mutexes)
/*ENDMACROS*/

// Reclaimable low memory services
/*MACROS*/
VMM_Service (_AddReclaimableItem)
VMM_Service (_SetReclaimableItem)
VMM_Service (_EnumReclaimableItem)
/*ENDMACROS*/

// completely wake sys VM from idle state
/*MACROS*/
VMM_Service (Time_Slice_Wake_Sys_VM)
VMM_Service (VMM_Replace_Global_Environment)
VMM_Service (Begin_Non_Serial_Nest_V86_Exec)
VMM_Service (Get_Nest_Exec_Status)
/*ENDMACROS*/

// Bootlogging services

/*MACROS*/
VMM_Service (Open_Boot_Log)
VMM_Service (Write_Boot_Log)
VMM_Service (Close_Boot_Log)
VMM_Service (EnableDisable_Boot_Log)
VMM_Service (_Call_On_My_Stack)
/*ENDMACROS*/

// Another instance data service

/*MACROS*/
VMM_Service (Get_Inst_V86_Int_Vec_Base)
/*ENDMACROS*/

// Case insensitive functions -- SEE WARNINGS IN DOCS BEFORE USING!
/*MACROS*/
VMM_Service (_lstrcmpi)
VMM_Service (_strupr)
/*ENDMACROS*/

/*MACROS*/
VMM_Service (Log_Fault_Call_Out)
VMM_Service (_AtEventTime)
/*ENDMACROS*/

#endif /* WIN40SERVICES */

/*MACROS*/
End_Service_Table(VMM, VMM)
/*ENDMACROS*/

/*XLATOFF*/
#pragma warning (default:4003)          // turn on not enough params warning
/*XLATON*/

// Flag definitions for _Add/_Set/_EnumReclaimableItem

#define RS_RECLAIM              0x00000001
#define RS_RESTORE              0x00000002
#define RS_DOSARENA             0x00000004

// Structure definition for _EnumReclaimableItem

struct ReclaimStruc {
    ULONG   RS_Linear;                  // low (< 1meg) address of item
    ULONG   RS_Bytes;                   // size of item in bytes
    ULONG   RS_CallBack;                // callback, if any (zero if none)
    ULONG   RS_RefData;                 // reference data for callback, if any
    ULONG   RS_HookTable;               // real-mode hook table (zero if none)
    ULONG   RS_Flags;                   // 0 or more of the RS_* equates
};

typedef struct ReclaimStruc *PReclaimStruc;

//
// Structures for Force_Mutexes_Free/Restore_Forced_Mutexes
//
typedef struct frmtx {
    struct frmtx *frmtx_pfrmtxNext;
    DWORD frmtx_hmutex;
    DWORD frmtx_cEnterCount;
    DWORD frmtx_pthcbOwner;
    DWORD frmtx_htimeout;
} FRMTX;

typedef struct vmmfrinfo {
    struct frmtx vmmfrinfo_frmtxDOS;
    struct frmtx vmmfrinfo_frmtxV86;
    struct frmtx vmmfrinfo_frmtxOther;
} VMMFRINFO;

/*
 *  Data structure for _GetDemandPageInfo
 */
struct DemandInfoStruc {
    ULONG DILin_Total_Count;    /* # pages in linear address space */
    ULONG DIPhys_Count;         /* Count of phys pages */
    ULONG DIFree_Count;         /* Count of free phys pages */
    ULONG DIUnlock_Count;       /* Count of unlocked Phys Pages */
    ULONG DILinear_Base_Addr;   /* Base of pageable address space */
    ULONG DILin_Total_Free;     /* Total Count of free linear pages */

    /*
     *  The following 5 fields are all running totals, kept from the time
     *  the system was started
     */
    ULONG DIPage_Faults;        /* total page faults */
    ULONG DIPage_Ins;           /* calls to pagers to page in a page */
    ULONG DIPage_Outs;          /* calls to pagers to page out a page*/
    ULONG DIPage_Discards;      /* pages discarded w/o calling pager */
    ULONG DIInstance_Faults;    /* instance page faults */

    ULONG DIPagingFileMax;      /* maximum # of pages that could be in paging file */
    ULONG DIPagingFileInUse;    /* # of pages of paging file currently in use */

    ULONG DICommit_Count;       /* Total committed memory, in pages */

    ULONG DIReserved[2];        /* Reserved for expansion */
};

/*
 *  Data structure for _AddInstanceItem
 */
struct InstDataStruc {
    ULONG InstLinkF;        /* INIT <0> RESERVED */
    ULONG InstLinkB;        /* INIT <0> RESERVED */
    ULONG InstLinAddr;      /* Linear address of start of block */
    ULONG InstSize;         /* Size of block in bytes */
    ULONG InstType;         /* Type of block */
};

/*
 *  Values for InstType
 */
#define INDOS_FIELD     0x100   /* Bit indicating INDOS switch requirements */
#define ALWAYS_FIELD    0x200   /* Bit indicating ALWAYS switch requirements */
#define OPTIONAL_FIELD  0x400   /* Bit indicating optional instancing requirements */

/*
 *  Data structure for Hook_Invalid_Page_Fault handlers.
 *
 *  This is the structure of the "invalid page fault information"
 *  which is pointed to by EDI when Invalid page fault hookers
 *  are called.
 *
 *  Page faults can occur on a VM which is not current by touching the VM at
 *  its high linear address.  In this case, IPF_FaultingVM may not be the
 *  current VM, it will be set to the VM whos high linear address was touched.
 */

struct IPF_Data {
    ULONG IPF_LinAddr;      /* CR2 address of fault */
    ULONG IPF_MapPageNum;   /* Possible converted page # of fault */
    ULONG IPF_PTEEntry;     /* Contents of PTE that faulted */
    ULONG IPF_FaultingVM;   /* May not = Current VM (IPF_V86PgH set) */
    ULONG IPF_Flags;        /* Flags */
};

/*
 *
 * Install_Exception_Handler data structure
 *
 */

struct Exception_Handler_Struc {
    ULONG EH_Reserved;
    ULONG EH_Start_EIP;
    ULONG EH_End_EIP;
    ULONG EH_Handler;
};

/*
 *  Flags passed in new memory manager functions
 */

/* PageReserve arena values */
#define PR_PRIVATE  0x80000400  /* anywhere in private arena */
#define PR_SHARED   0x80060000  /* anywhere in shared arena */
#define PR_SYSTEM   0x80080000  /* anywhere in system arena */

/* PageReserve flags */
#define PR_FIXED    0x00000008  /* don't move during PageReAllocate */
#define PR_4MEG     0x00000001  /* allocate on 4mb boundary */
#define PR_STATIC   0x00000010  /* see PageReserve documentation */

/* PageCommit default pager handle values */
#define PD_ZEROINIT 0x00000001  /* swappable zero-initialized pages */
#define PD_NOINIT   0x00000002  /* swappable uninitialized pages */
#define PD_FIXEDZERO    0x00000003  /* fixed zero-initialized pages */
#define PD_FIXED    0x00000004  /* fixed uninitialized pages */

/* PageCommit flags */
#define PC_FIXED    0x00000008  /* pages are permanently locked */
#define PC_LOCKED   0x00000080  /* pages are made present and locked*/
#define PC_LOCKEDIFDP   0x00000100  /* pages are locked if swap via DOS */
#define PC_WRITEABLE    0x00020000  /* make the pages writeable */
#define PC_USER     0x00040000  /* make the pages ring 3 accessible */
#define PC_INCR     0x40000000  /* increment "pagerdata" each page */
#define PC_PRESENT  0x80000000  /* make pages initially present */
#define PC_STATIC   0x20000000  /* allow commit in PR_STATIC object */
#define PC_DIRTY    0x08000000  /* make pages initially dirty */

/* PageCommitContig additional flags */
#define PCC_ZEROINIT    0x00000001  /* zero-initialize new pages */
#define PCC_NOLIN   0x10000000  /* don't map to any linear address */

/*
 *  Structure and flags for PageQuery
 */
#ifndef _WINNT_
typedef struct _MEMORY_BASIC_INFORMATION {
    ULONG mbi_BaseAddress;
    ULONG mbi_AllocationBase;
    ULONG mbi_AllocationProtect;
    ULONG mbi_RegionSize;
    ULONG mbi_State;
    ULONG mbi_Protect;
    ULONG mbi_Type;
} MEMORY_BASIC_INFORMATION, *PMEMORY_BASIC_INFORMATION;

#define PAGE_NOACCESS          0x01     
#define PAGE_READONLY          0x02     
#define PAGE_READWRITE         0x04     
#define MEM_COMMIT           0x1000     
#define MEM_RESERVE          0x2000     
#define MEM_FREE            0x10000     
#define MEM_PRIVATE         0x20000     
#endif


/***ET+ PD - Pager Descriptor
 *
 *  A PD describes a set of routines to call to bring a page into
 *  the system or to get it out.  Each committed page in the system
 *  has an associated PD, a handle to which is stored in the page's
 *  VP.
 *
 *  For any field that is 0, the pager will not be notified
 *  when that action takes place.
 *
 *  For the purpose of pagers, a page can be in one of the two states
 *  describing its current contents:
 *
 *      clean - page has not been written to since its last page out
 *      dirty - page has been written to since its last page out
 *
 *  A page also is in one of two persistent states:
 *
 *      virgin - page has never been written to since it was committed
 *      tainted - page has been written to since it was committed
 *
 *  Note that a tainted page may be either dirty or clean, but a
 *  virgin page is by definition clean.
 *
 *  Examples of PDs:
 *
 *      For 32-bit EXE code or read-only data:
 *
 *        pd_virginin = routine to load page from an exe file
 *        pd_taintedin = 0
 *        pd_cleanout = 0
 *        pd_dirtyout = 0
 *        pd_virginfree = 0
 *	  pd_taintedfree = 0
 *	  pd_dirty = 0
 *        pd_type = PD_PAGERONLY
 *
 *      For 32-bit EXE writeable data:
 *
 *        pd_virginin = routine to load page from an exe file
 *        pd_taintedin = routine to load page from swap file
 *        pd_cleanout = 0
 *        pd_dirtyout = routine to write a page out to the swap file
 *        pd_virginfree = 0
 *        pd_taintedfree = routine to free page from the swap file
 *        pd_dirty = routine to free page from the swap file
 *        pd_type = PD_SWAPPER
 *
 *      For zero-initialized swappable data:
 *
 *        pd_virginin = routine to zero-fill a page
 *        pd_taintedin = routine to load page from swap file
 *        pd_cleanout = 0
 *        pd_dirtyout = routine to write a page out to the swap file
 *        pd_virginfree = 0
 *        pd_taintedfree = routine to free page from the swap file
 *        pd_dirty = routine to free page from the swap file
 *        pd_type = PD_SWAPPER
 */
/* typedefs for various pager functions */

typedef ULONG _cdecl FUNPAGE(PULONG ppagerdata, PVOID ppage, ULONG faultpage);

typedef FUNPAGE * PFUNPAGE;

struct pd_s {
    /*
     *  The following four fields are entry points in the pager which
     *  we call to page in or page out a page.  The following parameters
     *  are passed to the pager during these calls:
     *
     *  ppagerdata - pointer to the pager-specific dword of data
     *           stored with the virtual page.  The pager is
     *           free to modify the contents of this dword
     *           DURING the page in or out, but not afterwards.
     *
     *  ppage - pointer to page going in or out (a ring 0 alias
     *      to the physical page).  The pager should use this
     *      address to access the contents of the page.
     *
     *  faultpage - faulting linear page number for page-ins, -1 for
     *          page-outs.  This address should not be accessed
     *          by the pager.  It is provided for information
     *          only.  Note that a single page can be mapped at
     *          more than one linear address because of the
     *          MapIntoV86 and LinMapIntoV86 services.
     *
     *  The pager should return non-0 if the page was successfully
     *  paged, or 0 if it failed.
     */
    PFUNPAGE pd_virginin;   /* in - while page has never been written to */
    PFUNPAGE pd_taintedin;  /* in - page written to at least once */
    PFUNPAGE pd_cleanout;   /* out - page not written to since last out */
    PFUNPAGE pd_dirtyout;   /* out - page was written to since last out */

    /*
     *  The pd_*free routines are used to inform the pager when the last
     *  reference to a virtual page controlled by the pager is
     *  decommitted.  A common use of this notification is to
     *  free space in a backing file, or write the page contents
     *  into the backing file.
     *
     *  These calls take the same parameters as the page-out and -in
     *  functions, but no return value is recognized.  The "ppage"
     *  and "faultpage" parameters will always be 0.
     */
    PFUNPAGE pd_virginfree;  /* decommit of never-written-to page */
    PFUNPAGE pd_taintedfree; /* decommit of page written to at least once*/

    /*
     *  The pd_dirty routine is used to inform the pager when the
     *  memory manager detects that a page has been written to.  The memory
     *  manager does not detect the write at the instant it occurs, so
     *  the pager should not depend upon prompt notification.  A common
     *  use of this notification might be to invalidate cached data.
     *  If the page was dirtied in more than one memory context,
     *  the pager's pd_dirty routine will be called once for each
     *  context.
     *
     *  These calls take the same parameters as the page-out and -in
     *  functions except that the "ppage" parameter isn't valid and
     *  no return value is recognized.
     */
    PFUNPAGE pd_dirty;

    /*
     *  The pd_type field gives the sytem information about the
     *  overcommit characteristics of pages controlled by this pager.
     *  The following are allowable values for the field:
     *
     *  PD_SWAPPER - under some conditions, pages of this type
     *		may be paged out into the swap file
     *  PD_PAGERONLY - pages controlled by this pager will never
     *		be paged out to the swap file
     *
     *	In addition, the following value may be or'ed in to the pd_type field:
     *
     *	PD_NESTEXEC - must be specified if either the pd_cleanout or pd_dirtyout
     *		functions perform nested excecution or block using the
     *		BLOCK_SVC_INTS flag.  To be safe, this flag should always be
     *		specified if the pager does any sort of file i/o to anything
     *		other than the default paging file.
     */
    ULONG pd_type;
};
typedef struct pd_s PD;
typedef PD * PPD;

/* values for pd_type */
#define PD_SWAPPER	0   /* pages need direct accounting in swap file */
#define PD_PAGERONLY    1   /* pages will never be swapped */
#define PD_NESTEXEC	2   /* page out funtion uses nested execution */

#endif // Not_VxD

/*
 *  The size of a page of memory
 */
#define PAGESHIFT   12
#define PAGESIZE    (1 << PAGESHIFT)
#define PAGEMASK    (PAGESIZE - 1)

#define PAGE(p) ((DWORD)(p) >> PAGESHIFT)
#define NPAGES(cb) (((DWORD)(cb) + PAGEMASK) >> PAGESHIFT)

/*
 *  Address space (arena) boundaries
 */
#define MAXSYSTEMLADDR      ((ULONG) 0xffbfffff)    /* 4 gig - 4meg */
#define MINSYSTEMLADDR      ((ULONG) 0xc0000000)    /* 3 gig */
#define MAXSHAREDLADDR      ((ULONG) 0xbfffffff)
#define MINSHAREDLADDR      ((ULONG) 0x80000000)    /* 2   gig */
#define MAXPRIVATELADDR     ((ULONG) 0x7fffffff)
#define MINPRIVATELADDR     ((ULONG) 0x00400000)    /* 4 meg */
#define MAXDOSLADDR     ((ULONG) 0x003fffff)
#define MINDOSLADDR     ((ULONG) 0x00000000)

#define MAXSYSTEMPAGE       (MAXSYSTEMLADDR >> PAGESHIFT)
#define MINSYSTEMPAGE       (MINSYSTEMLADDR >> PAGESHIFT)
#define MAXSHAREDPAGE       (MAXSHAREDLADDR >> PAGESHIFT)
#define MINSHAREDPAGE       (MINSHAREDLADDR >> PAGESHIFT)
#define MAXPRIVATEPAGE      (MAXPRIVATELADDR >> PAGESHIFT)
#define MINPRIVATEPAGE      (MINPRIVATELADDR >> PAGESHIFT)
#define MAXDOSPAGE      (MAXDOSLADDR >> PAGESHIFT)
#define MINDOSPAGE      (MINDOSLADDR >> PAGESHIFT)

#define CBPRIVATE       (1 + MAXPRIVATELADDR - MINPRIVATELADDR)
#define CBSHARED        (1 + MAXSHAREDLADDR - MINSHAREDLADDR)
#define CBSYSTEM        (1 + MAXSYSTEMLADDR - MINSYSTEMLADDR)
#define CBDOS           (1 + MAXDOSLADDR - MINDOSLADDR)

#define CPGPRIVATE      (1 + MAXPRIVATEPAGE - MINPRIVATEPAGE)
#define CPGSHARED       (1 + MAXSHAREDPAGE - MINSHAREDPAGE)
#define CPGSYSTEM       (1 + MAXSYSTEMPAGE - MINSYSTEMPAGE)
#define CPGDOS          (1 + MAXDOSPAGE - MINDOSPAGE)

/*XLATOFF*/
/*
 *  Largest object that could theoretically be allocated
 */
#define CBMAXALLOC      (max(CBSHARED,max(CBPRIVATE, CBSYSTEM)))
#define CPGMAXALLOC     (max(CPGSHARED,max(CPGPRIVATE, CPGSYSTEM)))

/*XLATON*/

/* ASM
IFDEF DEBUG
DebFar  EQU NEAR PTR
ELSE
DebFar  EQU SHORT
ENDIF
*/

#ifndef Not_VxD

/******************************************************************************
 *
 *           EQUATES FOR SYSTEM_CONTROL CALLS
 *
 *****************************************************************************/

/*
 *  SYS_CRITICAL_INIT is a device init call.  Devices that have a
 *  critical function that needs initializing before interrupts are
 *  enabled should do it at Sys_Critical_Init.  Devices which REQUIRE a
 *  certain range of V86 pages to operate (such as the VDD video memory)
 *  should claim them at Sys_Critical_Init.  SYS VM Simulate_Int,
 *  Exec_Int ACTIVITY IS NOT ALLOWED.  Returning carry aborts device
 *  load only.
 */
#define SYS_CRITICAL_INIT   0x0000      /* Devices req'd for virt mode */

/*
 *  DEVICE_INIT is where most devices do the bulk of their initialization.
 *  SYS VM Simulate_Int, Exec_Int activity is allowed. Returning carry
 *  aborts device load only.
 */
#define DEVICE_INIT     0x0001      /* All other devices init */

/*
 *  INIT_COMPLETE is the final phase of device init called just before the
 *  WIN386 INIT pages are released and the Instance snapshot is taken.
 *  Devices which wish to search for a region of V86 pages >= A0h to use
 *  should do it at INIT_COMPLETE.
 *  SYS VM Simulate_Int, Exec_Int activity is allowed.  Returning carry
 *  aborts device load only.
 */
#define INIT_COMPLETE       0x0002      /* All devices initialized */

/* --------------- INITIALIZATION CODE AND DATA DISCARDED ------------------ */

/*
 *  Same as VM_Init, except for SYS VM.
 */
#define SYS_VM_INIT     0x0003      /* Execute the system VM */

/*
 *  Same as VM_Terminate, except for SYS VM (Normal WIN386 exit ONLY, on a crash
 *  exit this call is not made).  SYS VM Simulate_Int, Exec_Int activity is
 *  allowed.  This and Sys_VM_Terminate2 are your last chances to access
 *  and/or lock pageable data.
 */   
#define SYS_VM_TERMINATE    0x0004      /* System VM terminated */

/*
 *  System_Exit call is made when WIN386 is exiting either normally or via
 *  a crash.  INTERRUPTS ARE ENABLED.  Instance snapshot has been restored.
 *  SYS VM Simulate_Int, Exec_Int ACTIVITY IS NOT ALLOWED.
 */
#define SYSTEM_EXIT     0x0005      /* Devices prepare to exit */

/*
 *  SYS_CRITICAL_EXIT call is made when WIN386 is exiting either normally or via
 *  a crash.  INTERRUPTS ARE DISABLED.  SYS VM Simulate_Int, Exec_Int ACTIVITY
 *   IS NOT ALLOWED.
 */
#define SYS_CRITICAL_EXIT   0x0006      /* System critical devices reset */


/*
 *  Create_VM creates a new VM.  EBX = VM handle of new VM.  Returning
 *  Carry will fail the Create_VM.
 */
#define CREATE_VM       0x0007

/*
 *  Second phase of Create_VM.  EBX = VM handle of new VM.  Returning
 *  Carry will cause the VM to go Not_Executeable, then be destroyed.
 *  VM Simulate_Int, Exec_Int activity is NOT allowed.
 */
#define VM_CRITICAL_INIT    0x0008

/*
 *  Third phase of Create_VM.  EBX = VM handle of new VM.  Returning
 *  Carry will cause the VM to go Not_Executeable, then be destroyed.
 *  VM Simulate_Int, Exec_Int activity is allowed.
 */
#define VM_INIT         0x0009

/*
 *  NORMAL (First phase) of Destroy_VM.  EBX = VM Hanlde.  This occurs
 *  on normal termination of the VM.  Call cannot be failed.  VM
 *  Simulate_Int, Exec_Int activity is allowed.
 */
#define VM_TERMINATE        0x000A      /* Still in VM -- About to die */

/*
 *  Second phase of Destroy_VM.  EBX = VM Handle, EDX = Flags (see
 *  below).  Note that in the case of destroying a running VM, this is
 *  the first call made (VM_Terminate call does not occur).  Call cannot
 *  be failed.  VM Simulate_Int, Exec_Int activity is NOT allowed.
 */
#define VM_NOT_EXECUTEABLE  0x000B      /* Most devices die (except VDD) */

/*
 *  Final phase of Destroy_VM.  EBX = VM Handle.  Note that considerable
 *  time can elaps between the VM_Not_Executeable call and this call.
 *  Call cannot be failed.  VM Simulate_Int, Exec_Int activity is NOT
 *  allowed.
 */
#define DESTROY_VM      0x000C      /* VM's control block about to go */


/*
 *  Flags for VM_Not_Executeable control call (passed in EDX)
 */
#define VNE_CRASHED_BIT     0x00        /* VM was crashed */
#define VNE_CRASHED     (1 << VNE_CRASHED_BIT)
#define VNE_NUKED_BIT       0x01        /* VM was destroyed while active */
#define VNE_NUKED       (1 << VNE_NUKED_BIT)
#define VNE_CREATEFAIL_BIT  0x02        /* Some device failed Create_VM */
#define VNE_CREATEFAIL      (1 << VNE_CREATEFAIL_BIT)
#define VNE_CRINITFAIL_BIT  0x03        /* Some device failed VM_Critical_Init */
#define VNE_CRINITFAIL      (1 << VNE_CRINITFAIL_BIT)
#define VNE_INITFAIL_BIT    0x04        /* Some device failed VM_Init */
#define VNE_INITFAIL        (1 << VNE_INITFAIL_BIT)
#define VNE_CLOSED_BIT      0x05
#define VNE_CLOSED      (1 << VNE_CLOSED_BIT)


/*
 *  EBX = VM Handle. Call cannot be failed.
 */
#define VM_SUSPEND      0x000D      /* VM not runnable until resume */

/*
 *  EBX = VM Handle. Returning carry fails and backs out the resume.
 */
#define VM_RESUME       0x000E      /* VM is leaving suspended state */


/*
 *  EBX = VM Handle to set device focus to.  EDX = Device ID if device
 *  specific setfocus, == 0 if device critical setfocus (all devices).
 *  THIS CALL CANNOT BE FAILED.
 *
 *  NOTE: In case where EDX == 0, ESI is a FLAG word that indicates
 *  special functions.  Currently Bit 0 being set indicates that this
 *  Device critical set focus is also "VM critical".  It means that we
 *  do not want some other VM to take the focus from this app now.  This
 *  is primarily used when doing a device critical set focus to Windows
 *  (the SYS VM) it is interpreted by the SHELL to mean "if an old app
 *  currently has the Windows activation, set the activation to the
 *  Windows Shell, not back to the old app".  ALSO in the case where Bit
 *  0 is set, EDI = The VM handle of the VM that is "having trouble".
 *  Set this to 0 if there is no specific VM associated with the
 *  problem.
 */
#define SET_DEVICE_FOCUS    0x000F


/*
 *  EBX = VM Handle going into message mode.  THIS CALL CANNOT BE FAILED.
 */
#define BEGIN_MESSAGE_MODE  0x0010

/*
 *  EBX = VM Handle leaving message mode.  THIS CALL CANNOT BE FAILED.
 */
#define END_MESSAGE_MODE    0x0011


/* ----------------------- SPECIAL CONTROL CALLS --------------------------- */

/*
 *  Request for reboot.  Call cannot be failed.
 */
#define REBOOT_PROCESSOR    0x0012      /* Request a machine reboot */

/*
 *  Query_Destroy is an information call made by the SHELL device before
 *  an attempt is made to initiate a destroy VM sequence on a running VM
 *  which has not exited normally.  EBX = VM Handle.  Returning carry
 *  indicates that a device "has a problem" with allowing this.  THE
 *  DESTROY SEQUENCE CANNOT BE ABORTED HOWEVER, this decision is up to
 *  the user.  All this does is indicate that there is a "problem" with
 *  allowing the destroy.  The device which returns carry should call
 *  the SHELL_Message service to post an informational dialog about the
 *  reason for the problem.
 */
#define QUERY_DESTROY       0x0013      /* OK to destroy running VM? */


/* ----------------------- DEBUGGING CONTROL CALL -------------------------- */

/*
 *  Special call for device specific DEBUG information display and activity.
 */
#define DEBUG_QUERY     0x0014


/* -------- CALLS FOR BEGIN/END OF PROTECTED MODE VM EXECUTION ------------- */

/*
 *   About to run a protected mode application.
 *   EBX = Current VM handle.
 *   EDX = Flags
 *   EDI -> Application Control Block
 *   Returning with carry set fails the call.
 */
#define BEGIN_PM_APP        0x0015

/*
 *  Flags for Begin_PM_App (passed in EDX)
 */
#define BPA_32_BIT      0x01
#define BPA_32_BIT_FLAG     1

/*
 *  Protected mode application is terminating.
 *  EBX = Current VM handle.  THIS CALL CAN NOT FAIL.
 *  EDI -> Application Control Block
 */
#define END_PM_APP      0x0016

/*
 *  Called whenever system is about to be rebooted.  Allows VxDs to clean
 *  up in preperation for reboot.
 */
#define DEVICE_REBOOT_NOTIFY    0x0017
#define CRIT_REBOOT_NOTIFY  0x0018

/*
 *  Called when VM is about to be terminated using the Close_VM service
 *  EBX = Current VM handle (Handle of VM to close)
 *  EDX = Flags
 *        CVNF_CRIT_CLOSE = 1 if VM is in critical section while closing
 */
#define CLOSE_VM_NOTIFY     0x0019

#define CVNF_CRIT_CLOSE_BIT 0
#define CVNF_CRIT_CLOSE     (1 << CVNF_CRIT_CLOSE_BIT)

/*
 *  Power management event notification.
 *  EBX = 0
 *  ESI = event notification message
 *  EDI -> DWORD return value; VxD's modify the DWORD to return info, not EDI
 *  EDX is reserved
 */
#define POWER_EVENT     0x001A

#define SYS_DYNAMIC_DEVICE_INIT 0x001B
#define SYS_DYNAMIC_DEVICE_EXIT 0x001C

/*
 *  Create_THREAD creates a new thread.  EDI = handle of new thread.
 *  Returning Carry will fail the Create_THREAD. Message is sent in the
 *  context of the creating thread.
 *
 */
#define  CREATE_THREAD  0x001D

/*
 *  Second phase of creating a thread.  EDI = handle of new thread.  Call cannot
 *  be failed. VM Simulate_Int, Exec_Int activity is not allowed (because
 *  never allowed in non-initial threads). Message is sent in the context
 *  of the newly created thread.
 *
 */
#define  THREAD_INIT    0x001E

/*
 *  Normal (first) phase of Destroy_THREAD. EDI = handle of thread.
 *  This occurs on normal termination of the thread.  Call cannot be failed.
 *  Simulate_Int, Exec_Int activity is allowed.
 */
#define  TERMINATE_THREAD  0x001F

/*
 *  Second phase of Destroy_THREAD.  EDI = Handle of thread,
 *  EDX = flags (see below).  Note that in the case of destroying a
 *  running thread, this is the first call made (THREAD_Terminate call
 *  does not occur).  Call cannot be failed.  VM Simulate_Int, Exec_Int
 *  activity is NOT allowed.
 *
 */
#define  THREAD_Not_Executeable  0x0020

/*
 *  Final phase of Destroy_THREAD.  EDI = Thread Handle.  Note that considerable
 *  time can elapse between the THREAD_Not_Executeable call and this call.
 *  Call cannot be failed.  VM Simulate_Int, Exec_Int activity is NOT
 *  allowed.
 *
 */
#define  DESTROY_THREAD    0x0021

/* -------------------- CALLS FOR PLUG&PLAY ------------------------- */

/*
 *  Configuration manager or a devloader is telling a DLVxD that a new devnode
 *  has been created. EBX is the handle of the new devnode and EDX is the load
 *  type (one of the DLVxD_LOAD_* defined in CONFIGMG.H). This is a 'C'
 *  system control call. Contrarily to the other calls, carry flags must be
 *  set if any error code other than CR_SUCCESS is to be return.
 *
 */
#define PNP_NEW_DEVNODE     0x0022


/* -------------------- CALLS FOR Win32  ------------------------- */

/* vWin32 communicates with Vxds on behalf of Win32 apps thru this mechanism.
 * BUGBUG: need more doc here, describing the interface
 */

#define W32_DEVICEIOCONTROL 0x0023

/* sub-functions */
#define DIOC_GETVERSION     0x0
#define DIOC_OPEN       DIOC_GETVERSION
#define DIOC_CLOSEHANDLE    -1

/* -------------------- MORE SYSTEM CALLS ------------------------- */

/*
 * All these messages are sent immediately following the corresponding
 * message of the same name, except that the "2" messages are sent
 * in *reverse* init order.
 */

#define SYS_VM_TERMINATE2   0x0024
#define SYSTEM_EXIT2        0x0025
#define SYS_CRITICAL_EXIT2  0x0026
#define VM_TERMINATE2       0x0027
#define VM_NOT_EXECUTEABLE2 0x0028
#define DESTROY_VM2     0x0029
#define VM_SUSPEND2     0x002A
#define END_MESSAGE_MODE2   0x002B
#define END_PM_APP2     0x002C
#define DEVICE_REBOOT_NOTIFY2   0x002D
#define CRIT_REBOOT_NOTIFY2 0x002E
#define CLOSE_VM_NOTIFY2    0x002F

/*
 * VCOMM gets Address of Contention handler from VxDs by sending this
 * control message
 */

#define GET_CONTENTION_HANDLER  0x0030

#define KERNEL32_INITIALIZED    0x0031

#define KERNEL32_SHUTDOWN       0x0032

#define MAX_SYSTEM_CONTROL  0x0032

/*
 * Dynamic VxD's can communicate with each other using Directed_Sys_Control
 * and a private control message in the following range:
 */

#define BEGIN_RESERVED_PRIVATE_SYSTEM_CONTROL	0x70000000
#define END_RESERVED_PRIVATE_SYSTEM_CONTROL	0x7FFFFFFF

#endif // Not_VxD

/*
 * Values returned from VMM_GetSystemInitState in EAX.
 *
 * Comments represent operations performed by VMM; #define's indicate
 * what VMM_GetSystemInitState will return if you call it between the
 * previous operation and the next.
 *
 * Future versions of Windows may have additional init states between the
 * ones defined here, so you should be careful to use range checks instead
 * of test for equality.
 */

                    /* Protected mode is entered */
#define SYSSTATE_PRESYSCRITINIT     0x00000000
                    /* SYS_CRITICAL_INIT is broadcast */
#define SYSSTATE_PREDEVICEINIT      0x10000000
                    /* DEVICE_INIT is broadcast */
#define SYSSTATE_PREINITCOMPLETE    0x20000000
                    /* INIT_COMPLETE is broadcast */
                    /* VxD initialization complete */
#define SYSSTATE_VXDINITCOMPLETED   0x40000000
                    /* KERNEL32_INITIALIZED is broadcast */
#define SYSSTATE_KERNEL32INITED     0x50000000
                    /* All initialization completed */
                    /* System running normally */
                    /* System shutdown initiated */
                    /* KERNEL32_SHUTDOWN is broadcast */
#define SYSSTATE_KERNEL32TERMINATED 0xA0000000
                    /* System shutdown continues */
#define SYSSTATE_PRESYSVMTERMINATE  0xB0000000
                    /* SYS_VM_TERMINATE is broadcast */
#define SYSSTATE_PRESYSTEMEXIT      0xE0000000
                    /* SYSTEM_EXIT is broadcast */
#define SYSSTATE_PRESYSTEMEXIT2     0xE4000000
                    /* SYSTEM_EXIT2 is broadcast */
#define SYSSTATE_PRESYSCRITEXIT     0xF0000000
                    /* SYS_CRITICAL_EXIT is broadcast */
#define SYSSTATE_PRESYSCRITEXIT2    0xF4000000
                    /* SYS_CRITICAL_EXIT2 is broadcast */
#define SYSSTATE_POSTSYSCRITEXIT2   0xFFF00000
                    /* Return to real mode */
                    /* Alternate path: CAD reboot */
#define SYSSTATE_PREDEVICEREBOOT    0xFFFF0000
                    /* DEVICE_REBOOT_NOTIFY is broadcast */
#define SYSSTATE_PRECRITREBOOT      0xFFFFF000
                    /* CRIT_REBOOT_NOTIFY is broadcast */
#define SYSSTATE_PREREBOOTCPU       0xFFFFFF00
                    /* REBOOT_PROCESSOR is broadcast */
                    /* Return to real mode */

/* ASM
BeginDoc
;******************************************************************************
; BeginProc is a macro for defining entry points to routines in VMM and in the
;   VxDs. It correctly defines the procedure name for VxD services, DWORD
;   aligns the procedure, takes care of public declaration and does some
;   calling verification for debug versions of the software. EndProc is a
;   macro which defines the end of the procedure.
;
; Valid parameters to the BeginProc macro are:
;   PUBLIC              ; Used outside this module (default)
;   LOCAL               ; Local to this module
;   HIGH_FREQ           ; DWORD align procedure
;   SERVICE             ; Routine is called via VxDCall
;   ASYNC_SERVICE           ; Same as "SERVICE" plus routine can
;                   ;   be called under interrupt.
;   HOOK_PROC           ; Proc is a handler installed with
;                   ;   with a call to Hook_xxx_Fault
;                   ;   or Hook_Device_Service.  The
;                   ;   following parameter must be
;                   ;   the label of a DWORD location
;                   ;   which will hold the ptr to next
;                   ;   hook proc. e.g.
;
;                  ;BeginProc foo, SERVICE, HOOK_PROC, foo_next_ptr
;
;   NO_LOG              ; Disable Queue_Out call logging
;   NO_PROFILE          ; Disable DynaLink profile counts
;   NO_TEST_CLD         ; Disable direction flag check
;
;   TEST_BLOCK          ; Trap if in NOBLOCK state
;                   ;  (default if in pageable code seg)
;   TEST_REENTER            ; Trap if Get_VMM_Reenter_Count != 0
;                   ;  (default for non-async services)
;   NEVER_REENTER           ; Trap if VMM has been reentered
;   NOT_SWAPPING            ; Trap if this thread is swapping
;
;   NO_PROLOG           ; Disable all prolog tests
;
;   ESP             ; Use ESP instead of EBP for stack
;                   ;  frame base
;   PCALL               ; pascal calling convention
;   SCALL               ; stdcall calling convention
;   CCALL               ; "C" calling convention
;   ICALL               ; default calling convention
;   W32SVC              ; Win32 service
;
;   segment type            ; Place function in specified segment
;
; The NO_PROFILE flag merely suppresses incrementing the profile count.
; The DWORD of profiling information will still be emitted to appease
; the debugger.  If you want to increment the profile count manually,
; use the IncProfileCount macro.
;
; TEST_REENTER and NEVER_REENTER differ in that the VMM reentry count
; returned by Get_VMM_Reenter_Count is artifically forced to zero by
; Begin_Reentrant_Execution, whereas the counter checked by NEVER_REENTER
; reflects the genuine count of VMM reentry.
;
; A segment type (such as LOCKED, PAGEABLE, STATIC, INIT, DEBUG_ONLY) can be
; provided, in which case the BeginProc and EndProc macros will
; automatically place the appropriate segment directives around the
; definition of the function.
;
;   segment type            ; Place function in specified segment
;
; After the routine header in which the routine entry conditions, exit
;   conditions, side affects and functionality are specified, the BeginProc
;   macro should be used to define the routine's entry point. It has up to
;   four parameters as specified below. For example:
;
;BeginProc  <Function_Name>,PUBLIC, HIGH_FREQ, SERVICE, ASYNC_SERVICE, ESP
;
;   <code>
;
;EndProc    <Function_Name>
;==============================================================================
EndDoc
;
; BeginProc handling takes place in the following phases:
;
;   Phase 1:  Parsing the arguments.
;   Phase 2:  Setting default flags.
;   Phase 3:  Combining the flags.
;   Phase 4:  Code emitted before the label
;   Phase 5:  Munge the name as exported to C/Pascal/whoever
;   Phase 6:  _Debug_Flags_Service prolog
;   Phase 7:  Code emitted after the label
;

??_pf_Check equ 1       ;; Do Enter/LeaveProc checking?
??_pf_ArgsUsed  equ 2       ;; ArgVars were used
??_pf_Entered   equ 4       ;; EnterProc performed
??_pf_Left  equ 8       ;; LeaveProc performed
??_pf_Returned  equ    16               ;; Return performed

??_pushed       =       0               ;; For WIN31COMPAT
??_align    =   0       ;; For WIN31COMPAT
??_ends     equ <>      ;; BeginProc segment

BeginProc macro Name, P1, P2, P3, P4, P5, P6, P7, LastArg
    local   Profile_Data, prelabeldata, ??_hookvar
    ??_frame = 0            ;; local frame base
    ??_aframe = 0           ;; argument frame base
    ??_initaframe = 0       ;; initial aframe value
    ??_numargs = 0          ;; number of argvars
    ??_numlocals = 0        ;; number of localvars
    ??_numlocalsymbols = 0      ;; number of local symbols
    ??_procflags = 0        ;; misc. Enter/LeaveProc flags
    ??_esp = 0          ;; if VMM_TRUE, use esp instead of ebp
    ??_pushed = 0           ;; number of bytes pushed
    ??_align = 0            ;; set if proc should be dword aligned
    ??_hook = 0         ;; set if proc is a Hook_Proc
    ??_hookarg = 0
    ??_service = 0
    ??_async_service = 0
IF DEBLEVEL GT DEBLEVELNORMAL
    ??_log = DFS_LOG        ;; logging on by default
    ??_profile = DFS_PROFILE    ;; service profiling on by default
    ??_test_cld = DFS_TEST_CLD  ;; test that direction is clear
ELSE
    ??_log = 0          ;; logging off
IFDEF DEBUG
IFDEF profileall
IF ?_ICODE
    ??_profile = DFS_PROFILE    ;; service profiling on by default
ELSE
    ??_profile = 0          ;; service profiling off
ENDIF
ELSE
    ??_profile = 0          ;; service profiling off
ENDIF
ELSE
    ??_profile = 0          ;; service profiling off
ENDIF
    ??_test_cld = 0         ;; test that direction is clear
ENDIF
    ??_might_block = 0      ;; entering fn might cause VM to block
    ??_test_reenter = 0     ;; don't test for VMM reentry
    ??_never_reenter = 0        ;; don't test for genuine VMM reentry
    ??_not_swapping = 0     ;; don't test that we're not swapping
    ??_prolog_disabled = 0      ;; use a prolog by default
    ??_public = 1           ;; everything's public by default
    ??_cleanoff = 0         ;; don't cleanoff parameters
    ??_ccall = 0
    ??_pcall = 0
    ??_scall = 0
    ??_w32svc = 0
    ??_fleave = FALSE
;   ??_dfs = 0          ;; parm for _Debug_Flags_Service
    ??_name equ <Name>

    .errnb ??_ends, <Cannot nest functions with named segments>
    .errnb <LastArg>, <Too many arguments to BeginProc>

    ;; Phase 1: Parsing the arguments
    irp arg, <P1, P2, P3, P4, P5, P6, P7>
        if ??_hookarg
        ??_hookarg = 0
        ??_hookvar equ <arg>
        elseifdef ?&&arg&&_BeginProc
            ?&&arg&&_BeginProc
        elseifdef VxD_&&arg&&_CODE_SEG
        ??_ends textequ <VxD_&&arg&&_CODE_ENDS>
        VxD_&&arg&&_CODE_SEG
        else
        .err <Bad param "&arg" to BeginProc>
        endif
    endm

    ;; Phase 2:  Setting default flags
    ifndef Not_VxD
	ife ??_service
	    ifndef profileall
	      ??_profile = 0      ;; only services can be profiled
	    endif
	    ifdef VMMSYS
		??_prolog_disabled = 1
	    endif
	else
	    ??_test_cld = DFS_TEST_CLD
	endif       ; ife ??_service

	ife ?_16ICODE
	    ??_prolog_disabled = 1
	else
	ife ?_RCODE             ;; if real-mode code segment
	    ??_prolog_disabled = 1  ;; don't do anything stupid
	else                ;; else protected mode code segment
	    ife ?_PCODE     ;; if swappable code
		??_might_block = DFS_TEST_BLOCK
	    endif
	    if ??_service
		ife ??_async_service
		    ??_test_reenter = DFS_TEST_REENTER
		endif
	    endif
    endif       ; ife ?_RCODE
    endif       ; ife ?_16ICODE
    endif	; Not_VxD

    if ??_esp
	;; just return address on stack
	??_basereg equ <esp+??_pushed>
	??_initaframe = 4
    else
	;; ret addr and EBP on stack
	??_basereg equ <ebp>
	??_initaframe = 8
    endif
    @Caller equ <dword ptr [??_basereg+??_initaframe-4]>

    ??_cleanoff = ??_pcall or ??_scall

    ;; Phase 3:  Combining the flags
    ??_dfs = ??_never_reenter + ??_test_reenter + ??_not_swapping + \
         ??_log + ??_profile + ??_test_cld + ??_might_block

    if ??_prolog_disabled
        ??_dfs = 0
    endif

    ;; Phase 4:  Pre-label code

    ifndef Not_VxD

	if ??_hook
	    if ??_align
	    Dword_Align
	    endif
	    prelabeldata:
	    ifndef ??_hookvar
	    .err <HOOK_PROC requires next arg to be name of dword location>
	    endif
	    jmp short Name
	    jmp [??_hookvar]
	    ifdef DEBUG
	    Profile_Data dd  0
	    endif
	    if ??_align
	    .errnz ($ - prelabeldata) mod 4
	    endif
	endif

	ifdef DEBUG
	    ?prolog_&Name label near
	    if (??_service OR ??_profile) AND (??_hook EQ 0)
	    jmp short Name
	    if ??_align
		Dword_Align     ; This also aligns the proc
	    endif           ;   since Profile_Data is a dd

	    IF ?_ICODE
	    ifdef profileall
	      ?ProfileHeader_BeginProc Profile_Data, %@filename
	    else
	      Profile_Data dd 0
	    endif
	    ELSE
	      Profile_Data dd 0
	    ENDIF

	    endif
	endif

	if ??_align
	    Dword_Align
	endif

    endif	; Not_VxD

    Name proc near		;; The label

    ;; Phase 5:  Munge the name as exported to C/Pascal/whoever
    ;;       Warning!  Phase 5 cannot emit code!
    ife ??_pcall or ??_ccall or ??_scall    ;; if no munging
        if ??_public
            public Name
        else
            ifdef DEBUG
                % ?merge @FileName,$,Name,:
                % ?merge public,,,,,@FileName,$,Name
            endif
        endif
    endif
    if ??_ccall
        if ??_public
            _&Name equ Name
	    ifdef Not_VxD
		 public C Name
	    else
                 public _&Name
	    endif
        endif
    endif
    if ??_pcall
        if ??_public
            ?toupper Name
            ?merge  public,,,,%?upper
        endif
    endif
    ;; Phase 6:  _Debug_Flags_Service prolog
    ;;       DO NOT CHANGE UNTIL YOU UNDERSTAND _Debug_Flags_Service
    ifndef Not_VxD
	ifdef DEBUG
	    if ??_dfs EQ DFS_LOG
		VMMCall Log_Proc_Call   ;; no test, just log
	    else
	    if ??_dfs EQ DFS_TEST_REENTER
		VMMCall Test_Reenter    ;; no log, just reenter
	    else
	    if ??_dfs or ?_LOCKABLECODE eq 0
		ifdef WIN31COMPAT
		    if ??_dfs AND DFS_LOG
			VMMCall Log_Proc_Call
		    endif
		    if ??_dfs AND DFS_TEST_REENTER
			VMMCall Test_Reenter
		    endif
		else
		    ife ?_LOCKABLECODE
		    ifdef ??_debug_flags
			push    ??_debug_flags
			if ??_dfs
			pushfd
			or  dword ptr [esp+4],??_dfs
			popfd
			endif
			VMMCall _Debug_Flags_Service
		    elseif ??_dfs
			push    ??_dfs
			VMMCall _Debug_Flags_Service
		    endif
		    else
		    push    ??_dfs
		    VMMCall _Debug_Flags_Service
		    endif
		endif
	    else
	      ifdef profileall
		IncProfileCount
	      endif
	    endif           ;if ??_dfs
	    endif           ; if ??_dfs EQ DFS_TEST_REENTER
	    endif           ; if ??_dfs EQ DFS_LOG
	endif ; DEBUG
    endif ; Not_VxD

    ;; Phase 7:  Post-label code
    ;;       <none>
endm

;
; For each BeginProc keyword, there is a corresponding macro ?XX_BeginProc.
;
; The macro ?_BeginProc is so that the null keyword is not an error.

?_BeginProc macro
endm

?PUBLIC_BeginProc macro
    ??_public = 1
endm

?LOCAL_BeginProc macro
    ??_public = 0
endm

?HIGH_FREQ_BeginProc macro
    ??_align = 1
endm

?HOOK_PROC_BeginProc macro
    ??_hook = 1
    ??_hookarg = 1  ; next arg is dword storage location
endm

?SERVICE_BeginProc macro
    ??_service = 1
    .erre ?_16ICODE, <SERVICEs must be in 32 bit code>
    .erre ?_RCODE, <SERVICEs must be in 32 bit code>
endm

?ASYNC_SERVICE_BeginProc macro
    ??_service = 1
    ??_async_service = 1
    .errnz ?_LCODE, <ASYNC_SERVICE's must be in LOCKED code>
endm

?NO_LOG_BeginProc macro
    ??_log = 0
endm

?NO_PROFILE_BeginProc macro
    ??_profile = 0
endm

?NO_TEST_CLD_BeginProc macro
    ??_test_cld = 0
endm

?TEST_BLOCK_BeginProc macro
    ??_might_block = DFS_TEST_BLOCK
endm

?TEST_REENTER_BeginProc macro
    ??_test_reenter = DFS_TEST_REENTER
endm

?NEVER_REENTER_BeginProc macro
    ??_never_reenter = DFS_NEVER_REENTER
endm

?NOT_SWAPPING_BeginProc macro
    ??_not_swapping = DFS_NOT_SWAPPING
endm

?NO_PROLOG_BeginProc macro
    ??_prolog_disabled = 1
endm

?ESP_BeginProc macro
    ??_esp = VMM_TRUE
    ifndef Not_VxD
	.erre ?_16ICODE, <Beginproc ESP attribute invalid in 16 bit seg.>
	.erre ?_RCODE, <Beginproc ESP attribute invalid in real-mode seg.>
    endif
endm

?CCALL_BeginProc macro
    ??_ccall = 1
endm

?PCALL_BeginProc macro
    ??_pcall = 1
endm

?SCALL_BeginProc macro
    ??_scall = 1
endm

?ICALL_BeginProc macro
    ??_scall = 1    ;; internal calling convention is StdCall
endm

?W32SVC_BeginProc macro
    ??_scall = 1
    ??_w32svc = 1
endm

ifdef DEBUG
ifdef profileall
?ProfileHeader_BeginProc macro PL, filename
ifndef _&filename&__proc_list
  _&filename&__proc_list = 0
  PUBLIC _&filename&__proc_list
endif
    dd OFFSET32 _&filename&__proc_list
PL  dd 0
_&filename&__proc_list = PL
endm
endif

IncProfileCount macro
    if ??_service OR ??_profile
        inc dword ptr [??_name-4]
    else
        ifndef profileall
        .err <IncProfileCount can be used only in services.>
        endif
    endif
endm
else
IncProfileCount macro
endm
endif

;***    ArgVar - declares stack arguments
;
; Usage:
;
;   name   = name of argument.
;   length = a numeric expression denoting the size (in bytes)
;        of the argument.  The symbols BYTE, WORD, and DWORD
;        are synonyms for 1, 2, and 4 respectively.
;        NB!  All arguments sizes are rounded up to the nearest
;        multiple of 4.
;   used   = usually blank, but can be the symbol NOTUSED
;        to indicate that the argument will not be used
;        by the procedure.
;

ArgVar  macro   name,length,used
    ??_numargs = ??_numargs + 1
    if ??_pcall
        ?mkarg  <name>, <length>, <used>, %??_numargs
    else
        ?argvar <name>, <length>, <used>
    endif
    ??_procflags = ??_procflags OR ??_pf_Check
    endm

?mkarg  macro   name, length, used, num
    .xcref  ?MKA&num
    ?deflocal <name>
    ?MKA&num &macro
        ?argvar <name>, <length>, <used>
        &endm
    ??_aframe = ??_aframe + 4
    endm
    .xcref  ?mkarg

?argvar macro   name,length,used
    local   a
    ifidni  <length>,<BYTE>
        a = ??_aframe
        ??_aframe =  ??_aframe + 4
        ?setname <name>, <byte ptr [??_basereg+??_initaframe+a]>, <used>
    elseifidni <length>,<WORD>
        a = ??_aframe
        ??_aframe =  ??_aframe + 4
        ?setname <name>, <word ptr [??_basereg+??_initaframe+a]>, <used>
    elseifidni <length>,<DWORD>
        a = ??_aframe
        ??_aframe =  ??_aframe + 4
        ?setname <name>,  <dword ptr [??_basereg+??_initaframe+a]>, <used>
        ?setname <name&l>,<word ptr [??_basereg+??_initaframe+a]>, <used>
        ?setname <name&ll>,<byte ptr [??_basereg+??_initaframe+a]>, <used>
        ?setname <name&lh>,<byte ptr [??_basereg+??_initaframe+a+1]>, <used>
        ?setname <name&h>,<word ptr [??_basereg+??_initaframe+a+2]>, <used>
        ?setname <name&hl>,<byte ptr [??_basereg+??_initaframe+a+2]>, <used>
        ?setname <name&hh>,<byte ptr [??_basereg+??_initaframe+a+3]>, <used>
    else
        a = ??_aframe
        ??_aframe =  ??_aframe + ((length + 3)/4)*4
        ?setname <name>, <[??_basereg+??_initaframe+a]>, <used>
    endif
endm

;***    ?setname - optionally creates the name of an ArgVar
;
;   If <used> is <NOTUSED>, then the name is defined to something
;   bogus.

?setname macro name, value, used
    ?deflocal <name>
    ifidni <used>, <NOTUSED>
        name equ _inaccessible_NOTUSED_
    else
        name equ value
        ??_procflags = ??_procflags OR ??_pf_ArgsUsed OR ??_pf_Check
    endif
endm


;***    LocalVar - declares local stack variables
;
; Usage:
;
;   name   = name of local variable
;   length = a numeric expression denoting the size (in bytes)
;        of the argument.  The symbols BYTE, WORD, and DWORD
;        are synonyms for 1, 2, and 4 respectively.
;        NB!  All arguments sizes are rounded up to the nearest
;        multiple of 4 (unless PACK is indicated)
;   flag   = usually blank, but can be the symbol PACK
;        to suppress the usual padding and aligning of variables
;        PACK is typically used when declaring a bunch of
;        byte or word variables.  Make sure that the total
;        size of PACKed variables is a multiple of 4.
;

LocalVar    macro   name,length,flag
    local   a
    ??_numlocals = ??_numlocals + 1
    ??_pad = 1
    ifidni <flag>, <PACK>
        ??_pad = 0
    endif
    ifidni  <length>,<BYTE>
        ??_frame = ??_frame + 1 + 3 * ??_pad
        a = ??_frame
        ?deflocal <name>
        name equ byte ptr [??_basereg-a]
    elseifidni <length>,<WORD>
        ??_frame =  ??_frame + 2 + 2 * ??_pad
        a = ??_frame
        ?deflocal <name>
        name equ word ptr [??_basereg-a]
    elseifidni <length>,<DWORD>
        ??_frame = ??_frame + 4
        a = ??_frame
        ?deflocal <name, name&l, name&ll, name&lh, name&h, name&hl, name&hh>
        name equ dword ptr [??_basereg-a]
        name&l equ word ptr [??_basereg-a]
        name&ll equ byte ptr [??_basereg-a]
        name&lh equ byte ptr [??_basereg-a+1]
        name&h equ word ptr [??_basereg-a+2]
        name&hl equ byte ptr [??_basereg-a+2]
        name&hh equ byte ptr [??_basereg-a+3]
    else
        ??_frame =  ??_frame + ((length + 3)/4)*4
        a = ??_frame
        ?deflocal <name>
        name equ [??_basereg-a]
    endif
    ??_procflags = ??_procflags OR ??_pf_Check
endm

?deflocal macro name
    irp nm, <name>
        ??_numlocalsymbols = ??_numlocalsymbols + 1
        ?dodeflocal <nm>, %(??_numlocalsymbols)
    endm
endm
    .xcref  ?deflocal

?dodeflocal macro name, num
    .xcref  ?LOC&num
    ?LOC&num &macro
        name    equ <__inaccessible__NOTINSCOPE__>
        &endm
    endm
    .xcref  ?dodeflocal

;***    EnterProc - generates stack frame on entry

EnterProc macro
    .errnz ??_frame and 3, <Total size of local variables not a multiple of 4.>
    if ??_scall
        if ??_public
	    ifdef Not_VxD
                ?merge  %??_name,@,%(??_aframe),,label,near
                ?merge  public,,,,C,%??_name,@,%(??_aframe)
	    else
                ?merge  _,%??_name,@,%(??_aframe),label,near
                ?merge  public,,,,,_,%??_name,@,%(??_aframe)
	    endif
        endif
    endif
    if ??_pcall
        ??_aframe = 0
        ?count = ??_numargs
        rept    ??_numargs
            ?invprg <?MKA>,%?count
            ?count = ?count - 1
        endm
    endif
    ??_fleave = FALSE
    if ??_esp
        if  ??_frame
            sub esp, ??_frame
            ??_pushed = ??_pushed + ??_frame
            ??_fleave = VMM_TRUE
        endif
    else
        if  ??_frame eq 0
            if (??_aframe eq 0) OR ((??_procflags AND ??_pf_ArgsUsed) EQ 0)
                ifdef DEBUG
                    push    ebp
                    mov ebp,esp
                    ??_fleave = VMM_TRUE
                endif
            else
                push    ebp
                mov ebp,esp
                ??_fleave = VMM_TRUE
            endif
        else
            enter   ??_frame, 0
            ??_fleave = VMM_TRUE
        endif
    endif
    ??_procflags = ??_procflags OR ??_pf_Entered
endm

;***    LeaveProc - removes stack frame on exit
;
;	NOTE:	If there are localvar and ESP kind of stack frame
;		LeaveProc will destroy flags unless the "PRESERVE_FLAGS"
;		flag is given.  PRESERVE_FLAGS generates bigger, slower
;		code, so use it only when necessary.
;
;   WARNING: For "ESP" type stack frames, this macro DOES NOT adjust
;        the internal stack depth for the local frame.  This is
;        to allow jumping around the LeaveProc/Return to code
;        after the LeaveProc/Return to use args/local variables,
;        but code that uses the stack frame executed after the
;        LeaveProc won't work.

LeaveProc macro flags
    if ??_fleave
        if ??_esp
            ifidni <flags>,<PRESERVE_FLAGS>
                lea esp,[esp + ??_frame]
            else
                add esp,??_frame
            endif
        else
            leave
        endif
    endif
    ??_procflags = ??_procflags OR ??_pf_Left
endm

;***    Return - return appropriately from a procedure
;
;   For "ccall" functions it's just a ret; for "pcall" and "scall"
;   it cleans the parameters off.
;

Return  macro
    if  ??_cleanoff OR ??_w32svc
        if  ??_w32svc AND (??_aframe LT 8)
            ret 8
        else
            ret ??_aframe
        endif
    else
        ret
    endif
    ??_procflags = ??_procflags OR ??_pf_Returned
    endm

;***    EndProc - end the procedure
;

EndProc macro Name, Flag
    Name endp           ;; Masm will provide error msg for us
if ??_w32svc
    if ??_aframe lt 8
        cparm&Name equ 0
    else
        cparm&Name equ (??_aframe/4 - 2)
    endif
endif
if ??_procflags AND ??_pf_Left
if ??_fleave
if ??_esp
    ??_pushed = ??_pushed - ??_frame
endif
endif
endif
ifdifi  <Flag>,<NOCHECK>
    if ??_pushed ne 0
        %out Warning: stack not balanced in Name
    endif
    if ??_procflags AND ??_pf_Check
        ife ??_procflags AND ??_pf_Entered
            %out Warning: ArgVar/LocalVar without EnterProc in Name
        endif
        ife ??_procflags AND ??_pf_Left
            %out Warning: ArgVar/LocalVar without LeaveProc in Name
        endif
        ife ??_procflags AND ??_pf_Returned
            %out Warning: ArgVar/LocalVar without Return in Name
        endif
    endif
endif
ifdifi  <Flag>,<KEEPFRAMEVARS>
    ?count = 0
    rept    ??_numlocalsymbols
        ?count = ?count + 1
        ?invprg <?LOC>,%?count
    endm
endif
    ??_ends
    ??_ends equ <>
    endm

;***    cCall - "C" call
;
;   Arguments pushed in "C" order, caller cleans stack
;
;   USES: Flags.

cCall   macro   name, arglst, flags
    ife .TYPE name
       CondExtern name, near
    endif
    PushCParams <arglst>, <flags>
    call    name
    ClearCParams
    endm
    .xcref  cCall

;***    pCall - pascal call
;
;   Arguments pushed in pascal order, callie cleans stack
;

pCall   macro   name, arglst
    local   ??saved
    ife .TYPE name
        ?toupper name
    else
        ?upper equ <name>
    endif
    CondExtern %?upper, near
    ??saved = ??_pushed
    irp x,<arglst>
        push    x
        ??_pushed = ??_pushed + 4
    endm
    call    ?upper
    ??_pushed = ??saved
    endm
    .xcref  pCall

;***    sCall - standard call
;
;   Arguments pushed in "C" order, callie cleans stack,
;   @argc appended to name
;

sCall   macro   name, arglst
    local   ??saved
    ??saved = ??_pushed
    PushCParams <arglst>
    ?scall  name, %(??_argc * 4)
    ??_pushed = ??saved
    endm
    .xcref  sCall

;***    iCall - internal routine call
;
;   Set to what every type we what to use as a default.

iCall   equ <sCall>

;***    PushCParams
;
;   Processes argument list
;
;   arglist = <arg1, arg2, arg3, ...>
;   flags = the word SMALL if we should prefer size over speed
;       the word FAST if we should prefer speed over size
;
;       The default flag is SMALL, unless the current procedure
;       is High_Freq, in which case we default to FAST.
;
;   To disable this optimization, define the symbol NONSTANDARD_CCALL.
;
IFNDEF  STANDARD_CCALL
NONSTANDARD_CCALL = 1           ;; disabled by default for now
ENDIF

PushCParams macro arglst, flags
    ??_argc = 0         ;; number of dwords on stack (global)
IFDEF   NONSTANDARD_CCALL
    ??_popargs = 0          ;; establish default
ELSE
    ??_popargs = ??_align EQ 0  ;; establish default
ENDIF
    ifidni  <flags>, <SMALL>
        ??_popargs = 1      ;; size, not speed
    elseifidni <flags>, <FAST>
        ??_popargs = 0      ;; speed, not size
    endif

    irp x,<arglst>
        ??_argc = ??_argc + 1
        ?marg   <x>,%??_argc
    endm
    ?count = ??_argc
    rept    ??_argc
        ?invprg <?AM>,%?count
        ?count = ?count - 1
    endm
    endm

;***    ClearCParams
;
;   Processes stack clean up
;
;   This routine will trade size for speed (if requested)
;   by using `pop ecx' to clean off one or two arguments.
;   This relies on the convention that C-call routines do
;   not return useful information in ECX.
;
;   To disable this optimization, define the symbol NONSTANDARD_CCALL.
;
;	If flags must be preserved, pass PRESERVE_FLAGS as an argument.
;	This will generate bigger, slower code, so use it only when
;	necessary.

ClearCParams macro fPreserveFlags
	if	??_argc ne 0
	    if (??_popargs) AND (??_argc LE 2)
	      rept ??_argc
		pop	ecx
	      endm
	    else
	      ifidni <fPreserveFlags>, <PRESERVE_FLAGS>
		lea	esp, [esp][??_argc * 4]
	      else
		add	esp,??_argc * 4
	      endif
	    endif
	endif
	??_pushed = ??_pushed - (??_argc * 4)
	endm

; Makes a macro that will push argment when invoke - used by cCall only

?marg   macro   name, num
    .xcref
    .xcref  ?AM&num
    .cref
    ?AM&num &macro
        push    name
        ??_pushed = ??_pushed + 4
        &endm
    endm
    .xcref  ?marg

; Concatenates, invokes and purges a macro name - used by PushCParams

?invprg macro   name1, name2
    name1&name2
    purge   name1&name2
    endm
    .xcref  ?invprg

; Calls a concatenated standard call name and makes it external

?scall  macro   name1, name2
    CondExtern _&name1&@&name2, near
    call    _&name1&@&name2
    endm
    .xcref  ?scall

; Equates name to a name

?merge  macro   l1, l2, l3, l4, op, r1, r2, r3, r4, r5, r6, r7, r8, r9
    l1&l2&l3&l4 op r1&r2&r3&r4&r5&r6&r7&r8&r9
    endm

; Converts string to upper-case, returned in ?upper

?toupper macro s
      ?upper equ <>
      irpc x,<s>
        if '&x' GE 'a'
          if '&x' LE 'z'
        ?t1 substr <ABCDEFGHIJKLMNOPQRSTUVWXYZ>,'&x'-'a'+1,1
        ?upper catstr ?upper,?t1
          else
        ?upper catstr ?upper,<&x>
          endif
        else
          ?upper catstr ?upper,<&x>
        endif
      endm
    endm
    .xcref

;***    CondExtern - Make name external if not already defined
;
;   This operation is quite different between MASM 5.1 and 6.0.
;

CondExtern macro name,dist
    ifdef MASM6
        ifndef name
        externdef name:dist
        endif
    else
        if2
        ifndef name
            extrn name:dist
        endif
        endif
    endif
endm

;***    SaveReg - Save register, "fd" pushes flags, "ad" pushes all

SaveReg macro   reglist         ;; push those registers
    irp reg,<reglist>
        ifidni <reg>, <fd>
            pushfd
            ??_pushed = ??_pushed + 4
        else
        ifidni <reg>, <ad>
            pushad
            ??_pushed = ??_pushed + SIZE Pushad_Struc
        else
            push    reg
            ??_pushed = ??_pushed + 4
        endif
        endif
    endm
endm

;***    RestoreReg - Restore register, "fd" pops flags, "ad" pops all
;
;   Note that registers must be restored in reverse order that they
;   were saved.
;

RestoreReg macro     reglist    ;; pop those registers
    irp reg,<reglist>
        ifidni <reg>, <fd>
            popfd
            ??_pushed = ??_pushed - 4
        else
        ifidni <reg>, <ad>
            popad
            ??_pushed = ??_pushed - SIZE Pushad_Struc
        else
            pop reg
            ??_pushed = ??_pushed - 4
        endif
        endif
    endm
endm
*/

#ifdef DEBUG
/******************************************************************************
*   The following macros are for enabling procedure call profile counting
*   of VxD's written in assembler.
*
*   Begin_Profile_List needs to be used in the file that declares the device
*   immediately after the Declare_Virtual_Device line.  Then one Profile_Link
*   line is required for each individual source file.  The list is ended with
*   the End_Profile_List macro.  Profiling only works for debug builds and
*   the sources must all be built with "-Dprofileall" masm switch.
******************************************************************************/

/* ASM
Begin_Profile_List macro devname
ifdef profileall
VxD_DATA_SEG
    db  'PROCLIST'
PUBLIC devname&_Proc_Profile_List
devname&_Proc_Profile_List label dword
endif
endm

Profile_Link macro modname
ifdef profileall
ifdifi <modname>,@filename
EXTRN _&modname&__proc_list:near
endif
    dd  OFFSET32 _&modname&__proc_list
endif
endm

End_Profile_List macro
ifdef profileall
    dd  0
VxD_DATA_ENDS
endif
endm

*/
#endif

#ifndef Not_VxD

/******************************************************************************
 *         S C H E D U L E R   B O O S T   V A L U E S
 *****************************************************************************/

#define RESERVED_LOW_BOOST  0x00000001
#define CUR_RUN_VM_BOOST    0x00000004
#define LOW_PRI_DEVICE_BOOST    0x00000010
#define HIGH_PRI_DEVICE_BOOST   0x00001000
#define CRITICAL_SECTION_BOOST  0x00100000
#define TIME_CRITICAL_BOOST 0x00400000
#define RESERVED_HIGH_BOOST 0x40000000


/******************************************************************************
 *   F L A G S   F O R   C A L L _ P R I O R I T Y _ V M _ E V E N T
 *****************************************************************************/

#define PEF_WAIT_FOR_STI_BIT        0
#define PEF_WAIT_FOR_STI        (1 << PEF_WAIT_FOR_STI_BIT)
#define PEF_WAIT_NOT_CRIT_BIT       1
#define PEF_WAIT_NOT_CRIT       (1 << PEF_WAIT_NOT_CRIT_BIT)

#define PEF_DONT_UNBOOST_BIT        2
#define PEF_DONT_UNBOOST        (1 << PEF_DONT_UNBOOST_BIT)
#define PEF_ALWAYS_SCHED_BIT        3
#define PEF_ALWAYS_SCHED        (1 << PEF_ALWAYS_SCHED_BIT)
#define PEF_TIME_OUT_BIT        4
#define PEF_TIME_OUT            (1 << PEF_TIME_OUT_BIT)

#define PEF_WAIT_NOT_HW_INT_BIT     5
#define PEF_WAIT_NOT_HW_INT     (1 << PEF_WAIT_NOT_HW_INT_BIT)
#define PEF_WAIT_NOT_NESTED_EXEC_BIT    6
#define PEF_WAIT_NOT_NESTED_EXEC    (1 << PEF_WAIT_NOT_NESTED_EXEC_BIT)
#define PEF_WAIT_IN_PM_BIT      7
#define PEF_WAIT_IN_PM          (1 << PEF_WAIT_IN_PM_BIT)

#define PEF_THREAD_EVENT_BIT        8
#define PEF_THREAD_EVENT        (1 << PEF_THREAD_EVENT_BIT)

#define PEF_WAIT_FOR_THREAD_STI_BIT 9
#define PEF_WAIT_FOR_THREAD_STI (1 << PEF_WAIT_FOR_THREAD_STI_BIT)

#define PEF_RING0_EVENT_BIT         10
#define PEF_RING0_EVENT         (1 << PEF_RING0_EVENT_BIT)

#define PEF_WAIT_CRIT_BIT	    11
#define PEF_WAIT_CRIT		(1 << PEF_WAIT_CRIT_BIT)

#define PEF_WAIT_CRIT_VM_BIT	    12
#define PEF_WAIT_CRIT_VM	(1 << PEF_WAIT_CRIT_VM_BIT)

#define PEF_PROCESS_LAST_BIT	    13
#define PEF_PROCESS_LAST	(1 << PEF_PROCESS_LAST_BIT)

// synonyms for event restrictions above

#define PEF_WAIT_NOT_TIME_CRIT_BIT   PEF_WAIT_NOT_HW_INT_BIT
#define PEF_WAIT_NOT_TIME_CRIT       PEF_WAIT_NOT_HW_INT
#define PEF_WAIT_NOT_PM_LOCKED_STACK_BIT PEF_WAIT_NOT_NESTED_EXEC_BIT
#define PEF_WAIT_NOT_PM_LOCKED_STACK     PEF_WAIT_NOT_NESTED_EXEC


/******************************************************************************
 *       F L A G S   F O R   B E G I N _ C R I T I C A L _ S E C T I O N,
 *                           E N T E R _ M U T E X
 *             A N D   W A I T _ S E M A P H O R E
 *****************************************************************************/

#define BLOCK_SVC_INTS_BIT      0
#define BLOCK_SVC_INTS          (1 << BLOCK_SVC_INTS_BIT)
#define BLOCK_SVC_IF_INTS_LOCKED_BIT    1
#define BLOCK_SVC_IF_INTS_LOCKED    (1 << BLOCK_SVC_IF_INTS_LOCKED_BIT)
#define BLOCK_ENABLE_INTS_BIT       2
#define BLOCK_ENABLE_INTS       (1 << BLOCK_ENABLE_INTS_BIT)
#define BLOCK_POLL_BIT          3
#define BLOCK_POLL          (1 << BLOCK_POLL_BIT)
#define BLOCK_THREAD_IDLE_BIT           4
#define BLOCK_THREAD_IDLE               (1 << BLOCK_THREAD_IDLE_BIT)
#define BLOCK_FORCE_SVC_INTS_BIT        5
#define BLOCK_FORCE_SVC_INTS		(1 << BLOCK_FORCE_SVC_INTS_BIT)

/******************************************************************************
 *  The following structures are pointed to by EBP when VxD routines are
 *  entered, both for VxD control calls and traps(I/O traps, software INT
 *  traps, etc.).  The first structure as DWORD values, the second WORD
 *  values and the last has BYTE values.
 *****************************************************************************/

struct Client_Reg_Struc {
    ULONG Client_EDI;           /* Client's EDI */
    ULONG Client_ESI;           /* Client's ESI */
    ULONG Client_EBP;           /* Client's EBP */
    ULONG Client_res0;          /* ESP at pushall */
    ULONG Client_EBX;           /* Client's EBX */
    ULONG Client_EDX;           /* Client's EDX */
    ULONG Client_ECX;           /* Client's ECX */
    ULONG Client_EAX;           /* Client's EAX */
    ULONG Client_Error;         /* Dword error code */
    ULONG Client_EIP;           /* EIP */
    USHORT Client_CS;           /* CS */
    USHORT Client_res1;         /*   (padding) */
    ULONG Client_EFlags;        /* EFLAGS */
    ULONG Client_ESP;           /* ESP */
    USHORT Client_SS;           /* SS */
    USHORT Client_res2;         /*   (padding) */
    USHORT Client_ES;           /* ES */
    USHORT Client_res3;         /*   (padding) */
    USHORT Client_DS;           /* DS */
    USHORT Client_res4;         /*   (padding) */
    USHORT Client_FS;           /* FS */
    USHORT Client_res5;         /*   (padding) */
    USHORT Client_GS;           /* GS */
    USHORT Client_res6;         /*   (padding) */
    ULONG Client_Alt_EIP;
    USHORT Client_Alt_CS;
    USHORT Client_res7;
    ULONG Client_Alt_EFlags;
    ULONG Client_Alt_ESP;
    USHORT Client_Alt_SS;
    USHORT Client_res8;
    USHORT Client_Alt_ES;
    USHORT Client_res9;
    USHORT Client_Alt_DS;
    USHORT Client_res10;
    USHORT Client_Alt_FS;
    USHORT Client_res11;
    USHORT Client_Alt_GS;
    USHORT Client_res12;
};


struct Client_Word_Reg_Struc {
    USHORT Client_DI;           /* Client's DI */
    USHORT Client_res13;        /*   (padding) */
    USHORT Client_SI;           /* Client's SI */
    USHORT Client_res14;        /*   (padding) */
    USHORT Client_BP;           /* Client's BP */
    USHORT Client_res15;        /*   (padding) */
    ULONG Client_res16;         /* ESP at pushall */
    USHORT Client_BX;           /* Client's BX */
    USHORT Client_res17;        /*   (padding) */
    USHORT Client_DX;           /* Client's DX */
    USHORT Client_res18;        /*   (padding) */
    USHORT Client_CX;           /* Client's CX */
    USHORT Client_res19;        /*   (padding) */
    USHORT Client_AX;           /* Client's AX */
    USHORT Client_res20;        /*   (padding) */
    ULONG Client_res21;         /* Dword error code */
    USHORT Client_IP;           /* Client's IP */
    USHORT Client_res22;        /*   (padding) */
    ULONG Client_res23;         /* CS */
    USHORT Client_Flags;        /* Client's flags (low) */
    USHORT Client_res24;        /*   (padding) */
    USHORT Client_SP;           /* SP */
    USHORT Client_res25;
    ULONG Client_res26[5];
    USHORT Client_Alt_IP;
    USHORT Client_res27;
    ULONG Client_res28;
    USHORT Client_Alt_Flags;
    USHORT Client_res29;
    USHORT Client_Alt_SP;
};



struct Client_Byte_Reg_Struc {
    ULONG Client_res30[4];      /* EDI, ESI, EBP, ESP at pushall */
    UCHAR Client_BL;            /* Client's BL */
    UCHAR Client_BH;            /* Client's BH */
    USHORT Client_res31;
    UCHAR Client_DL;            /* Client's DL */
    UCHAR Client_DH;            /* Client's DH */
    USHORT Client_res32;
    UCHAR Client_CL;            /* Client's CL */
    UCHAR Client_CH;            /* Client's CH */
    USHORT Client_res33;
    UCHAR Client_AL;            /* Client's AL */
    UCHAR Client_AH;            /* Client's AH */
};


typedef union tagCLIENT_STRUC { /* */
    struct Client_Reg_Struc       CRS;
    struct Client_Word_Reg_Struc  CWRS;
    struct Client_Byte_Reg_Struc  CBRS;
    } CLIENT_STRUCT;

typedef struct Client_Reg_Struc CRS;
typedef CRS *PCRS;

#if 0   /* causes problems with MASM 6 */
/* ASM
.ERRNZ Client_SP - Client_ESP
.ERRNZ Client_AL - Client_EAX
*/
#endif

#define DYNA_LINK_INT   0x20

/* ASM

;***	DeclareNonstandardCcallService
;
;	Declare services as conforming to the C calling convention
;	for parameter-passing, but *not* conforming to the C calling
;	convention for register usage.
;
;	Services which do not use the C calling convention for
;	parameter-passing need not be declared as nonstandard.
;
;	arglst - list of services to declare as nonstandard
;
DeclareNonstandardCcallService macro arglst
	irp	x,<arglst>
	    ??_nonstandardccall_&x = 1
	endm
endm

;
; The following VMM services are nonstandard:
;       _BlockOnID and _LocalizeSprintf modify no registers except flags.
;       _SetLastV86Page modifies no registers except EAX and flags.
;       _Assert_Range returns information in flags.
;
DeclareNonstandardCcallService <_BlockOnID, _LocalizeSprintf>
DeclareNonstandardCcallService <_SetLastV86Page, _Assert_Range>

BeginDoc
;******************************************************************************
; The VMMCall and VxDCall macros provide a dynamic link to the VMM and VxD
;   service routines. For example:
;
;   VMMCall Enable_VM_Ints      ; Equivalent to STI in VM code
;
;   mov     eax,[My_IRQ_Handle]
;   VxDCall VPICD_Set_Int_Request   ; Set IRQ for my device's interrupt
;
; Note that Enable_VM_Ints is defined in VMM.INC and VPICD_Set_Int_Request is
;   defined in VPICD.INC
;
;==============================================================================
EndDoc


BeginDoc
;******************************************************************************
; VxDCall
;==============================================================================
;
;   BlockOnID is always FAST because it doesn't
;   conform to the C calling convention.  (It preserves
;   all registers.)

EndDoc

DefTable MACRO vt, vn
    vt EQU <vn>
ENDM

GenDD2 MACRO vt, sn, jf
    dd  OFFSET32 vt[sn+jf]
ENDM

GenDD   MACRO   P, vid, snum, jflag
    LOCAL   vtable
IFDEF   @@VxDName&vid
    Deftable    vtable, %@@VxDName&vid
    EXTRN   vtable:DWORD
    GenDD2 %vtable, snum, jflag
ELSE
    dd  @@&P+jflag
ENDIF

ENDM


VxDCall MACRO P, Param, flags
    ??_vxdid = (@@&P SHR 16)
    ??_servicenum = (@@&P AND 0FFFFh)
    ifdef ??_nonstandardccall_&P
    PushCParams <Param>, <FAST>
    else
    PushCParams <Param>, <flags>
    endif
    int Dyna_Link_Int
    GenDD   P, %??_vxdid, %??_servicenum, 0
    ifdef ??_nonstandardccall_&P
	ClearCParams PRESERVE_FLAGS
    else
	ClearCParams
    endif
    ENDM

VxDJmp  MACRO P, Param
    ??_vxdid = (@@&P SHR 16)
    ??_servicenum = (@@&P AND 0FFFFh)
    .errnb <Param>, <Parameters may not be passed to VxDJmp or VMMJmp>
    int Dyna_Link_Int
    GenDD   P, %??_vxdid, %??_servicenum, DL_Jmp_Mask
    ENDM

DL_Jmp_Mask EQU 8000h
DL_Jmp_Bit  EQU 0Fh

VMMCall MACRO P, Param
    .ERRNZ (@@&P SHR 16) - VMM_DEVICE_ID
    VxDCall <P>, <Param>
    ENDM

VMMJmp MACRO P, Param
    .ERRNZ (@@&P SHR 16) - VMM_DEVICE_ID
    VxDJmp <P>, <Param>
    ENDM

BeginDoc
;******************************************************************************
; Segment definition macros
;
; The segment definition macros are a convenience used in defining the
;   segments used by the device driver. They are:
;VxD_INIT_CODE_SEG defines start of initialization code segment
;VxD_INIT_CODE_ENDS defines end of initialization code segment
;VxD_ICODE_SEG is an alias for VxD_INIT_CODE_SEG
;VxD_ICODE_ENDS is an alias for VxD_INIT_CODE_ENDS
;VxD_IDATA_SEG   defines start of initialization data segment
;VxD_IDATA_ENDS  defines end of initialization data segment
;VxD_CODE_SEG    defines start of always present code segment
;VxD_CODE_ENDS   defines end of always present code segment
;VxD_DATA_SEG    defines start of always present data segment
;VxD_DATA_ENDS   defines end of always present data segment
;VxD_LOCKED_CODE_SEG    defines start of always present code segment
;VxD_LOCKED_CODE_ENDS   defines end of always present code segment
;VxD_PAGEABLE_CODE_SEG  defines start of swappable code segment
;VxD_PAGEABLE_CODE_ENDS defines end of swappable code segment
;VxD_DEBUG_ONLY_CODE_SEG defines code only loaded if debugger is present
;VxD_DEBUG_ONLY_CODE_ENDS
;VxD_DEBUG_ONLY_DATA_SEG defines data only loaded if debugger is present
;VxD_DEBUG_ONLY_DATA_ENDS
;==============================================================================




EndDoc


;   Resident protected mode code

VxD_CODE_SEG    EQU <VxD_LOCKED_CODE_SEG>
VxD_CODE_ENDS   EQU <VxD_LOCKED_CODE_ENDS>


VxD_LOCKED_CODE_SEG MACRO
_LTEXT   SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_LCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

        ENDM

VxD_LOCKED_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_LTEXT   ENDS
        ENDM


;   Pageable protected mode code

VxD_PAGEABLE_CODE_SEG MACRO
_PTEXT   SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_PCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

        ENDM

VxD_PAGEABLE_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_PTEXT   ENDS
        ENDM


;   Debug only protected mode code

VxD_DEBUG_ONLY_CODE_SEG MACRO
_DBOCODE    SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_DBOCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT
        ENDM

VxD_DEBUG_ONLY_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_DBOCODE    ENDS
        ENDM


;   Protected mode initialization code

VxD_INIT_CODE_SEG   MACRO
_ITEXT  SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_ICODE
    ASSUME  cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT
    ENDM

VxD_INIT_CODE_ENDS  MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_ITEXT  ENDS
        ENDM

VxD_ICODE_SEG equ VxD_INIT_CODE_SEG
VxD_ICODE_ENDS equ VxD_INIT_CODE_ENDS


;   Resident protected mode data

VxD_DATA_SEG    EQU <VxD_LOCKED_DATA_SEG>
VxD_DATA_ENDS   EQU <VxD_LOCKED_DATA_ENDS>

VxD_LOCKED_DATA_SEG MACRO NO_ALIGN
_LDATA   SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
        ENDM

VxD_LOCKED_DATA_ENDS MACRO
_LDATA   ENDS
        ENDM


;   Protected mode initialization data

VxD_IDATA_SEG   MACRO
_IDATA  SEGMENT
        ENDM
VxD_IDATA_ENDS  MACRO
_IDATA  ENDS
        ENDM


;   Pageable protected mode data

VxD_PAGEABLE_DATA_SEG MACRO NO_ALIGN
_PDATA   SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
        ENDM

VxD_PAGEABLE_DATA_ENDS MACRO
_PDATA   ENDS
        ENDM


;   Static code segment for DL-VxDs

VxD_STATIC_CODE_SEG MACRO
_STEXT   SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_SCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

        ENDM

VxD_STATIC_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_STEXT   ENDS
        ENDM


;   Static data segment for DL-VxDs

VxD_STATIC_DATA_SEG MACRO NO_ALIGN
_SDATA   SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
        ENDM

VxD_STATIC_DATA_ENDS MACRO
_SDATA   ENDS
        ENDM

;   Debug only protected mode data

VxD_DEBUG_ONLY_DATA_SEG MACRO NO_ALIGN
_DBODATA    SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
        ENDM

VxD_DEBUG_ONLY_DATA_ENDS MACRO
_DBODATA    ENDS
        ENDM


;   16 bit code/data put in the init group (IGROUP)

VxD_16BIT_INIT_SEG  MACRO
_16ICODE SEGMENT
ASSUME CS:_16ICODE, DS:NOTHING, ES:NOTHING, SS:NOTHING
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_16ICODE
          ENDM

VxD_16BIT_INIT_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_16ICODE ENDS
           ENDM

;   Real mode segment (16 bit)

VxD_REAL_INIT_SEG  MACRO
_RCODE SEGMENT
ASSUME CS:_RCODE, DS:_RCODE, ES:_RCODE, SS:_RCODE
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_RCODE
          ENDM

VxD_REAL_INIT_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_RCODE ENDS
           ENDM
*/

#endif // Not_VxD

#ifndef DDK_VERSION

#ifdef WIN31COMPAT
#define DDK_VERSION 0x30A           /* 3.10 */
#else  /* WIN31COMPAT */
#define DDK_VERSION 0x400           /* 4.00 */
#endif

#endif

struct VxD_Desc_Block {
    ULONG DDB_Next;         /* VMM RESERVED FIELD */
    USHORT DDB_SDK_Version;     /* INIT <DDK_VERSION> RESERVED FIELD */
    USHORT DDB_Req_Device_Number;   /* INIT <UNDEFINED_DEVICE_ID> */
    UCHAR DDB_Dev_Major_Version;    /* INIT <0> Major device number */
    UCHAR DDB_Dev_Minor_Version;    /* INIT <0> Minor device number */
    USHORT DDB_Flags;           /* INIT <0> for init calls complete */
    UCHAR DDB_Name[8];          /* AINIT <"        "> Device name */
    ULONG DDB_Init_Order;       /* INIT <UNDEFINED_INIT_ORDER> */
    ULONG DDB_Control_Proc;     /* Offset of control procedure */
    ULONG DDB_V86_API_Proc;     /* INIT <0> Offset of API procedure */
    ULONG DDB_PM_API_Proc;      /* INIT <0> Offset of API procedure */
    ULONG DDB_V86_API_CSIP;     /* INIT <0> CS:IP of API entry point */
    ULONG DDB_PM_API_CSIP;      /* INIT <0> CS:IP of API entry point */
    ULONG DDB_Reference_Data;       /* Reference data from real mode */
    ULONG DDB_Service_Table_Ptr;    /* INIT <0> Pointer to service table */
    ULONG DDB_Service_Table_Size;   /* INIT <0> Number of services */
    ULONG DDB_Win32_Service_Table;  /* INIT <0> Pointer to Win32 services */
    ULONG DDB_Prev;         /* INIT <'Prev'> Ptr to prev 4.0 DDB */
    ULONG DDB_Size;		/* INIT <SIZE(VxD_Desc_Block)> Reserved */
    ULONG DDB_Reserved1;        /* INIT <'Rsv1'> Reserved */
    ULONG DDB_Reserved2;        /* INIT <'Rsv2'> Reserved */
    ULONG DDB_Reserved3;        /* INIT <'Rsv3'> Reserved */
};

typedef struct VxD_Desc_Block       *PVMMDDB;
typedef PVMMDDB             *PPVMMDDB;

#ifndef Not_VxD

/*
 *  Flag values for DDB_Flags
 */

#define DDB_SYS_CRIT_INIT_DONE_BIT  0
#define DDB_SYS_CRIT_INIT_DONE      (1 << DDB_SYS_CRIT_INIT_DONE_BIT)
#define DDB_DEVICE_INIT_DONE_BIT    1
#define DDB_DEVICE_INIT_DONE        (1 << DDB_DEVICE_INIT_DONE_BIT)

#define DDB_HAS_WIN32_SVCS_BIT      14
#define DDB_HAS_WIN32_SVCS      (1 << DDB_HAS_WIN32_SVCS_BIT)
#define DDB_DYNAMIC_VXD_BIT     15
#define DDB_DYNAMIC_VXD         (1 << DDB_DYNAMIC_VXD_BIT)

#define DDB_DEVICE_DYNALINKED_BIT   13
#define DDB_DEVICE_DYNALINKED       (1 << DDB_DEVICE_DYNALINKED_BIT)


/* ASM
BeginDoc
;******************************************************************************
;
;   Declare_Virtual_Device macro
;
; ???? Write something here ????
;
;==============================================================================
EndDoc
Declare_Virtual_Device MACRO Name, Major_Ver, Minor_Ver, Ctrl_Proc, Device_Num, Init_Order, V86_Proc, PM_Proc, Reference_Data
    LOCAL   V86_API_Offset, PM_API_Offset, Serv_Tab_Offset, Serv_Tab_Len, Ref_Data_Offset

dev_id_err MACRO

IFNDEF Name&_Name_Based
.err <Device ID required when providing services>
ENDIF
    ENDM

IFB <V86_Proc>
    V86_API_Offset EQU 0
ELSE
 IFB <Device_Num>
    dev_id_err
 ENDIF
    V86_API_Offset EQU <OFFSET32 V86_Proc>
ENDIF

IFB <PM_Proc>
    PM_API_Offset EQU 0
ELSE
 IFB <Device_Num>
    dev_id_err
 ENDIF
    PM_API_Offset EQU <OFFSET32 PM_Proc>
ENDIF

IFDEF Name&_Service_Table
 IFB <Device_Num>
    dev_id_err
 ELSE
  IFE Device_Num - UNDEFINED_DEVICE_ID
    dev_id_err
  ENDIF
 ENDIF
    Serv_Tab_Offset EQU <OFFSET32 Name&_Service_Table>
    Serv_Tab_Len    EQU Num_&Name&_Services
ELSE
    Serv_Tab_Offset EQU 0
    Serv_Tab_Len    EQU 0
ENDIF

IFNB    <Device_Num>
  .erre (Device_Num LT BASEID_FOR_NAMEBASEDVXD), <Device ID  must be less than BASEID_FOR_NAMEBASEDVXD>
ENDIF

IFB <Reference_Data>
        Ref_Data_Offset EQU 0
ELSE
        Ref_Data_Offset EQU   <OFFSET32 Reference_Data>
ENDIF

IFDEF DEBUG
VxD_IDATA_SEG
    db  0dh, 0ah, 'D_E_B_U_G===>'
        db      "&Name", '<===', 0dh, 0ah
VxD_IDATA_ENDS
ENDIF

VxD_LOCKED_DATA_SEG

PUBLIC Name&_DDB
Name&_DDB VxD_Desc_Block <,,Device_Num,Major_Ver,Minor_Ver,,"&Name",Init_Order,\
             OFFSET32 Ctrl_Proc, V86_API_Offset, PM_API_Offset, \
             ,,Ref_Data_Offset,Serv_Tab_Offset, Serv_Tab_Len>

VxD_LOCKED_DATA_ENDS

    ENDM

;BeginDoc   ; comment out to make masm work ???
;******************************************************************************
; The Begin_Control_Dispatch macro is used for building a table for dispatching
; messages passed to the VxD_Control procedure.  It is used with
; Control_Dispatch and End_Control_Dispatch.  The only parameter is used to
; contruct the procedure label by adding "_Control" to the end (normally the
; device name is used i.e. VKD results in creating the procedure VKD_Control,
; this created procedure label must be included in Declare_Virtual_Device)
;
; An example of building a complete dispatch table:
;
; Begin_Control_Dispatch MyDevice
; Control_Dispatch  Device_Init, MyDeviceInitProcedure
; Control_Dispatch  Sys_VM_Init, MyDeviceSysInitProcedure
; Control_Dispatch  Create_VM,   MyDeviceCreateVMProcedure
; End_Control_Dispatch MyDevice
;
; (NOTE: Control_Dispatch can be used without Begin_Control_Dispatch, but
;    then it is the programmer's responsibility for declaring a procedure
;    in locked code (VxD_LOCKED_CODE_SEG) and returning Carry clear for
;    any messages not processed.  The advantage in using
;    Begin_Control_Dispatch is when a large # of messages are processed by
;    a device, because a jump table is built which will usually require
;    less code space then the compares and jumps that are done when
;    Control_Dispatch is used alone.
;
;==============================================================================
;EndDoc
Begin_Control_Dispatch MACRO VxD_Name, p1, p2
??_cd_low = 0FFFFFFFFh
??_cd_high = 0

BeginProc VxD_Name&_Control, p1, p2, LOCKED
ENDM

End_Control_Dispatch   MACRO VxD_Name
    LOCAL ignore, table

procoff MACRO num
IFDEF ??_cd_&&num
    dd  OFFSET32 ??_cd_&&num
ELSE
    dd  OFFSET32 ignore
ENDIF
ENDM

IF ??_cd_low EQ ??_cd_high
    cmp eax, ??_cd_low
    ?merge  <jz>,,,,,<??_cd_>, %(??_cd_low)
    clc
    ret
ELSE
IF ??_cd_low GT 0
    sub eax, ??_cd_low
ENDIF ; ??cd_low GT 0
    cmp eax, ??_cd_high - ??_cd_low + 1
    jae short ignore
    jmp [eax*4+table]
ignore:
    clc             ;; this is not redundant
    ret

table label dword
    REPT   ??_cd_high - ??_cd_low + 1
    procoff %(??_cd_low)
    ??_cd_low = ??_cd_low + 1
    ENDM
ENDIF

EndProc VxD_Name&_Control

PURGE procoff
PURGE Begin_Control_Dispatch
PURGE Control_Dispatch
PURGE End_Control_Dispatch
ENDM

BeginDoc
;******************************************************************************
; The Control_Dispatch macro is used for dispatching based on message
;   passed to the VxD_Control procedure. E.G.:
;
; Control_Dispatch  Device_Init, MyDeviceInitProcedure
;
; For "C" control functions:
;
; Control_Dispatch  Device_Init, MyDeviceInitProcedure, sCall, <arglst>
;
; The "callc" can be sCall, cCall or pCall depending on the calling
; convention.  "arglst" is the list of registers to pass as parameters
; to "C" control procedure.  The "C" control procedure returns VXD_SUCCESS
; or VXD_FAILURE and the carry flag gets set appropriately.
;
; (NOTE: Control_Dispatch can be used with Begin_Control_Dispatch and
;    End_Control_Dispatch to create a jump table for dispatching messages,
;    when a large # of messages are processed.)
;
;==============================================================================
EndDoc
Control_Dispatch MACRO Service, Procedure, callc, arglst
    LOCAL Skip_Interseg_Jump

.errnz ?_LCODE, <Control_Dispatch must be in VxD_LOCKED_CODE_SEG.>

IFB <callc>

IFDEF ??_cd_low
Equate_Service MACRO Serv
??_cd_&&Serv equ Procedure
ENDM

Equate_Service %(Service)

IF Service LT ??_cd_low
??_cd_low = Service
ENDIF
IF Service GT ??_cd_high
??_cd_high = Service
ENDIF

PURGE Equate_Service

ELSE
    cmp eax, Service
    jz  Procedure
ENDIF

ELSE ; ifb callc

    cmp eax, Service
    jne SHORT Skip_Interseg_Jump
    callc   Procedure, <arglst>
IF Service EQ PNP_NEW_DEVNODE
    stc
ELSE
    cmp eax,1
ENDIF
    ret
Skip_Interseg_Jump:

ENDIF ; ifb callc

    ENDM
*/


/******************************************************************************
 *  The following are the definitions for the "type of I/O" parameter passed
 *  to a I/O trap routine.
 *****************************************************************************/

#define BYTE_INPUT  0x000
#define BYTE_OUTPUT 0x004
#define WORD_INPUT  0x008
#define WORD_OUTPUT 0x00C
#define DWORD_INPUT 0x010
#define DWORD_OUTPUT    0x014

#define OUTPUT_BIT  2
#define OUTPUT      (1 << OUTPUT_BIT)
#define WORD_IO_BIT 3
#define WORD_IO     (1 << WORD_IO_BIT)
#define DWORD_IO_BIT    4
#define DWORD_IO    (1 << DWORD_IO_BIT)

#define STRING_IO_BIT   5
#define STRING_IO   (1 << STRING_IO_BIT)
#define REP_IO_BIT  6
#define REP_IO      (1 << REP_IO_BIT)
#define ADDR_32_IO_BIT  7
#define ADDR_32_IO  (1 << ADDR_32_IO_BIT)
#define REVERSE_IO_BIT  8
#define REVERSE_IO  (1 << REVERSE_IO_BIT)

#define IO_SEG_MASK 0x0FFFF0000     /* Use this to get segment */
#define IO_SEG_SHIFT    0x10            /* Must shift right this many */


/* ASM
BeginDoc
;******************************************************************************
;
;   Dispatch_Byte_IO macro
;
; Dispatch_Byte_IO Byte_In_Proc, Byte_Out_Proc
;==============================================================================
EndDoc
Dispatch_Byte_IO MACRO In_Proc, Out_Proc
    LOCAL   Byte_IO
    cmp ecx, Byte_Output
    jbe SHORT Byte_IO
    VMMJmp  Simulate_IO
Byte_IO:
IFIDNI <In_Proc>, <Fall_Through>
    je  Out_Proc
ELSE
IFIDNI <Out_Proc>, <Fall_Through>
    jb  In_Proc
ELSE
    je  Out_Proc
    jmp In_Proc
ENDIF
ENDIF
    ENDM

BeginDoc
;******************************************************************************
;
;   Emulate_Non_Byte_IO
;
; Emulate_Non_Byte_IO
;
;==============================================================================
EndDoc
Emulate_Non_Byte_IO MACRO
    LOCAL   Byte_IO
    cmp ecx, Byte_Output
    jbe SHORT Byte_IO
    VMMJmp  Simulate_IO
Byte_IO:
    ENDM
*/


/* ASM
BeginDoc
;******************************************************************************
;
; Begin_VxD_IO_Table
;
;   Example:
; Begin_VxD_IO_Table MyTableName
;
;==============================================================================
EndDoc
*/


struct VxD_IOT_Hdr {
    USHORT VxD_IO_Ports;
};

struct VxD_IO_Struc {
    USHORT VxD_IO_Port;
    ULONG VxD_IO_Proc;
};


/* ASM
.ERRNZ SIZE VxD_IOT_Hdr - 2 ; Begin_VxD_IO_Table creates a 1 word count hdr
Begin_VxD_IO_Table MACRO Table_Name
PUBLIC Table_Name
Table_Name LABEL WORD

ifndef MASM6
IF2
IFNDEF Table_Name&_Entries
.err <No End_VxD_IO_Table for &Table_Name>
ENDIF
    dw  Table_Name&_Entries
ELSE
    dw  ?
ENDIF
ELSE  ; MASM6 - skip the warning message - we'll get it anyway
    dw  Table_Name&_Entries
ENDIF ; MASM6

    ENDM

.ERRNZ SIZE VxD_IO_Struc - 6    ; VxD_IO creates 6 byte I/O port entries
VxD_IO MACRO Port, Proc_Name
    dw  Port
    dd  OFFSET32 Proc_Name
    ENDM

End_VxD_IO_Table MACRO Table_Name

IFNDEF Table_Name
.err <No Begin_VxD_IO_Table for &Table_Name>
ELSE
    Table_Name&_Entries EQU (($-Table_Name)-2) / (SIZE VxD_IO_Struc)
IF Table_Name&_Entries LE 0
.err <Invalid number of port traps in &Table_Name>
ENDIF
ENDIF
        ENDM


;******************************************************************************
;
; Push_Client_State takes an optional argument which if equal to the symbol
; USES_EDI saves code size by suppressing the preservation of the EDI register.
;
; Similarly, Pop_Client_State takes an optional argument which if equal to
; the symbol USES_ESI saves code size by suppressing the preservation of
; the ESI register.
;
;******************************************************************************

Push_Client_State MACRO Can_Trash_EDI
    sub esp, SIZE Client_Reg_Struc
    ??_pushed = ??_pushed + SIZE Client_Reg_Struc
    ifidni <Can_Trash_EDI>, <USES_EDI>
    mov edi, esp
    VMMCall Save_Client_State
    else
    push    edi
    lea edi, [esp+4]
    VMMCall Save_Client_State
    pop edi
    endif
    ENDM

Pop_Client_State MACRO Can_Trash_ESI
    ifdifi <Can_Trash_ESI>, <USES_ESI>
    push    esi
    lea esi, [esp+4]
    VMMCall Restore_Client_State
    pop esi
    else
    mov esi, esp
    VMMCall Restore_Client_State
    endif
    add esp, SIZE Client_Reg_Struc
    ??_pushed = ??_pushed - SIZE Client_Reg_Struc
    ENDM

BeginDoc
;******************************************************************************
;
;   CallRet -- Call procedure and return.  For debugging purposes only.
;          If compiled with debugging then this will generate a call
;          followed by a return.  If non-debugging version then the
;          specified label will be jumped to.
;
;   PARAMETERS:
;   Label_Name = Procedure to be called
;
;   EXIT:
;   Return from current procedure
;
;------------------------------------------------------------------------------
EndDoc

CallRet MACRO P1, P2
IFDEF DEBUG
IFIDNI <P1>, <SHORT>
    call    P2
ELSE
    call    P1
ENDIF
    ret
ELSE
    jmp P1 P2
ENDIF
    ENDM

BeginDoc
;******************************************************************************
;
;   VxDCallRet
;   VMMCallRet -- CallRet for VxDCall and VMMCall.
;
;------------------------------------------------------------------------------
EndDoc

IFDEF   DEBUG

VxDCallRet macro p:req
    VxDCall p
    ret
endm

VMMCallRet macro p:req
    VMMCall p
    ret
endm

ELSE ; RETAIL

VxDCallRet equ <VxDJmp>
VMMCallRet equ <VMMJmp>

ENDIF


; ebp offsets to segments pushed by PMode_Fault in Fault_Dispatch
PClient_DS equ WORD PTR -4
PClient_ES equ WORD PTR -8
PClient_FS equ WORD PTR -12
PClient_GS equ WORD PTR -16


;******************************************************************************
;
; Client_Ptr_Flat takes an optional third argument which if equal to the
; symbol USES_EAX saves code size by supressing the preservation of the
; EAX register.  The USES_EAX flag is ignored if the destination register
; is itself EAX.
;
;******************************************************************************

Client_Ptr_Flat MACRO Reg_32, Cli_Seg, Cli_Off, Can_Trash_EAX

IFDIFI <Reg_32>, <EAX>
    IFDIFI <Can_Trash_EAX>, <USES_EAX>
    xchg    Reg_32, eax
    ENDIF
ENDIF
IFB <Cli_Off>
    mov ax, (Client_&Cli_Seg * 100h) + 0FFh
ELSE
    mov ax, (Client_&Cli_Seg * 100h) + Client_&Cli_Off
ENDIF
    VMMCall Map_Flat

IFDIFI <Reg_32>, <EAX>
    xchg    Reg_32, eax
ENDIF

    ENDM

;------------------------------------------------------------------------------

VxDint  MACRO   Int_Number
    if  (OPATTR Int_Number) AND 4
    push    Int_Number
    else
    push    DWORD PTR Int_Number
    endif
    VMMCall Exec_VxD_Int
    ENDM

VxDintMustComplete MACRO   Int_Number
    if  (OPATTR Int_Number) AND 4
    push    Int_Number
    else
    push    DWORD PTR Int_Number
    endif
        VMMCall _ExecVxDIntMustComplete
    ENDM


*/

#endif // Not_VxD


/******************************************************************************
 *
 *  The following equates are for flags sent to the real mode
 *  initialization portion of a device driver:
 *
 *****************************************************************************/
#define DUPLICATE_DEVICE_ID_BIT     0   /* loaded */
#define DUPLICATE_DEVICE_ID     (1 << DUPLICATE_DEVICE_ID_BIT)
#define DUPLICATE_FROM_INT2F_BIT    1   /* loaded from INT 2F list */
#define DUPLICATE_FROM_INT2F        (1 << DUPLICATE_FROM_INT2F_BIT)
#define LOADING_FROM_INT2F_BIT      2   /* in the INT 2F device list */
#define LOADING_FROM_INT2F      (1 << LOADING_FROM_INT2F_BIT)


/******************************************************************************
 *
 *  The following equates are used to indicate the result of the real mode
 *  initialization portion of a device driver:
 *
 *****************************************************************************/

#define DEVICE_LOAD_OK      0   /* load protected mode portion */
#define ABORT_DEVICE_LOAD   1   /* don't load protected mode portion */
#define ABORT_WIN386_LOAD   2   /* fatal-error: abort load of Win386 */



#define NO_FAIL_MESSAGE_BIT 15  /* set bit to suppress error message */
#define NO_FAIL_MESSAGE     (1 << NO_FAIL_MESSAGE_BIT)


/******************************************************************************
 *
 *  The following equates define the loader services available to the real-mode
 *  initialization portion of a device driver:
 *
 *****************************************************************************/

#define LDRSRV_GET_PROFILE_STRING   0   /* search SYSTEM.INI for string */
#define LDRSRV_GET_NEXT_PROFILE_STRING  1   /* search for next string */
#define LDRSRV_RESERVED         2   /* RESERVED */
#define LDRSRV_GET_PROFILE_BOOLEAN  3   /* search SYSTEM.INI for boolean */
#define LDRSRV_GET_PROFILE_DECIMAL_INT  4   /* search SYSTEM.INI for integer */
#define LDRSRV_GET_PROFILE_HEX_INT  5   /* search SYSTEM.INI for hex int */
#define LDRSRV_COPY_EXTENDED_MEMORY 6   /* allocate/init extended memory */
#define LDRSRV_GET_MEMORY_INFO      7   /* get info about machine memory */

/* Add the new loader services contiguously here */

/****** Registry services for Real mode init time *************
 * The parameters for these are as defined in Windows.h for the
 * corresponding Win Reg API and should be on Stack. These are
 * C Callable except that the function no has to be in AX
 * ************************************************************
*/

#define LDRSRV_RegOpenKey       0x100
#define LDRSRV_RegCreateKey     0x101
#define LDRSRV_RegCloseKey      0x102
#define LDRSRV_RegDeleteKey     0x103
#define LDRSRV_RegSetValue      0x104
#define LDRSRV_RegQueryValue        0x105
#define LDRSRV_RegEnumKey       0x106
#define LDRSRV_RegDeleteValue       0x107
#define LDRSRV_RegEnumValue     0x108
#define LDRSRV_RegQueryValueEx      0x109
#define LDRSRV_RegSetValueEx        0x10A
#define LDRSRV_RegFlushKey      0x10B


/*
 *  For the Copy_Extended_Memory service, the following types of memory can be
 *  requested:
 */

#define LDRSRV_COPY_INIT        1   /* memory discarded after init */
#define LDRSRV_COPY_LOCKED      2   /* locked memory */
#define LDRSRV_COPY_PAGEABLE        3   /* pageable memory */

/****************************************************************************
*
*   Object types supported by the vxd loader
*
*  Notes : Low bit of all CODE type objects should be set (VXDLDR uses this)
*           Also Init type objects should be added to the second part of the
*           list (which starts with ICODE_OBJ).
*
*****************************************************************************/

#define RCODE_OBJ       -1

#define LCODE_OBJ       0x01
#define LDATA_OBJ       0x02
#define PCODE_OBJ       0x03
#define PDATA_OBJ       0x04
#define SCODE_OBJ       0x05
#define SDATA_OBJ       0x06
#define CODE16_OBJ      0x07
#define LMSG_OBJ        0x08
#define PMSG_OBJ        0x09

#define	DBOC_OBJ	0x0B
#define	DBOD_OBJ	0x0C

#define ICODE_OBJ       0x11
#define IDATA_OBJ       0x12
#define ICODE16_OBJ     0x13
#define IMSG_OBJ        0x14


struct ObjectLocation {
    ULONG OL_LinearAddr ;
    ULONG OL_Size ;
    UCHAR  OL_ObjType ;
} ;

#define MAXOBJECTS  25

/*****************************************************************************
 *
 *      Device_Location structure
 *
 *****************************************************************************/

struct Device_Location_List {
    ULONG DLL_DDB ;
    UCHAR DLL_NumObjects ;
    struct ObjectLocation DLL_ObjLocation[1];
};


/* ========================================================================= */

/*
 *  CR0 bit assignments
 */
#define PE_BIT      0   /* 1 = Protected Mode */
#define PE_MASK     (1 << PE_BIT)
#define MP_BIT      1   /* 1 = Monitor Coprocessor */
#define MP_MASK     (1 << MP_BIT)
#define EM_BIT      2   /* 1 = Emulate Math Coprocessor */
#define EM_MASK     (1 << EM_BIT)
#define TS_BIT      3   /* 1 = Task Switch occured */
#define TS_MASK     (1 << TS_BIT)
#define ET_BIT      4   /* 1 = 387 present, 0 = 287 present */
#define ET_MASK     (1 << ET_BIT)
#define PG_BIT      31  /* 1 = paging enabled, 0 = paging disabled */
#define PG_MASK     (1 << PG_BIT)


/*
 *  EFLAGs bit assignments
 */
#define CF_BIT      0
#define CF_MASK     (1 << CF_BIT)
#define PF_BIT      2
#define PF_MASK     (1 << PF_BIT)
#define AF_BIT      4
#define AF_MASK     (1 << AF_BIT)
#define ZF_BIT      6
#define ZF_MASK     (1 << ZF_BIT)
#define SF_BIT      7
#define SF_MASK     (1 << SF_BIT)
#define TF_BIT      8
#define TF_MASK     (1 << TF_BIT)
#define IF_BIT      9
#define IF_MASK     (1 << IF_BIT)
#define DF_BIT      10
#define DF_MASK     (1 << DF_BIT)
#define OF_BIT      11  /* Overflow flag */
#define OF_MASK     (1 << OF_BIT)
#define IOPL_MASK   0x3000  /* IOPL flags */
#define IOPL_BIT0   12
#define IOPL_BIT1   13
#define NT_BIT      14  /* Nested task flag */
#define NT_MASK     (1 << NT_BIT)
#define RF_BIT      16  /* Resume flag */
#define RF_MASK     (1 << RF_BIT)
#define VM_BIT      17  /* Virtual Mode flag */
#define VM_MASK     (1 << VM_BIT)
#define AC_BIT      18  /* Alignment check */
#define AC_MASK     (1 << AC_BIT)
#define VIF_BIT     19  /* Virtual Interrupt flag */
#define VIF_MASK    (1 << VIF_BIT)
#define VIP_BIT     20  /* Virtual Interrupt pending */
#define VIP_MASK    (1 << VIP_BIT)



/* ASM
;------------------------------------------------------------------------------
;
;     Temporary MASM macros (to be removed when supported by MASM)
;
;------------------------------------------------------------------------------

IFDEF MASM6
loopde EQU <looped>
loopdne EQU <loopned>
loopdz EQU <loopzd>
loopdnz EQU <loopnzd>
ELSE
loopd EQU <loop>
loopde EQU <loope>
loopdne EQU <loopne>
loopdz EQU <loopz>
loopdnz EQU <loopnz>
ENDIF
*/


/******************************************************************************
 *              PAGE TABLE EQUATES
 *****************************************************************************/


#define P_SIZE      0x1000      /* page size */

/******************************************************************************
 *
 *              PAGE TABLE ENTRY BITS
 *
 *****************************************************************************/

#define P_PRESBIT   0
#define P_PRES      (1 << P_PRESBIT)
#define P_WRITEBIT  1
#define P_WRITE     (1 << P_WRITEBIT)
#define P_USERBIT   2
#define P_USER      (1 << P_USERBIT)
#define P_ACCBIT    5
#define P_ACC       (1 << P_ACCBIT)
#define P_DIRTYBIT  6
#define P_DIRTY     (1 << P_DIRTYBIT)

#define P_AVAIL     (P_PRES+P_WRITE+P_USER) /* avail to user & present */

/****************************************************
 *
 *  Page types for page allocator calls
 *
 ***************************************************/

#define PG_VM       0
#define PG_SYS      1
#define PG_RESERVED1    2
#define PG_PRIVATE  3
#define PG_RESERVED2    4
#define PG_RELOCK   5       /* PRIVATE to MMGR */
#define PG_INSTANCE 6
#define PG_HOOKED   7
#define PG_IGNORE   0xFFFFFFFF

/****************************************************
 *
 *  Definitions for the access byte in a descriptor
 *
 ***************************************************/

/*
 *  Following fields are common to segment and control descriptors
 */
#define D_PRES      0x080       /* present in memory */
#define D_NOTPRES   0       /* not present in memory */

#define D_DPL0      0       /* Ring 0 */
#define D_DPL1      0x020       /* Ring 1 */
#define D_DPL2      0x040       /* Ring 2 */
#define D_DPL3      0x060       /* Ring 3 */

#define D_SEG       0x010       /* Segment descriptor */
#define D_CTRL      0       /* Control descriptor */

#define D_GRAN_BYTE 0x000       /* Segment length is byte granular */
#define D_GRAN_PAGE 0x080       /* Segment length is page granular */
#define D_DEF16     0x000       /* Default operation size is 16 bits */
#define D_DEF32     0x040       /* Default operation size is 32 bits */


/*
 *  Following fields are specific to segment descriptors
 */
#define D_CODE      0x08        /* code */
#define D_DATA      0       /* data */

#define D_X     0       /* if code, exec only */
#define D_RX        0x02        /* if code, readable */
#define D_C     0x04        /* if code, conforming */

#define D_R     0       /* if data, read only */
#define D_W     0x02        /* if data, writable */
#define D_ED        0x04        /* if data, expand down */

#define D_ACCESSED  1       /* segment accessed bit */


/*
 *  Useful combination access rights bytes
 */
#define RW_DATA_TYPE    (D_PRES+D_SEG+D_DATA+D_W)
#define R_DATA_TYPE (D_PRES+D_SEG+D_DATA+D_R)
#define CODE_TYPE   (D_PRES+D_SEG+D_CODE+D_RX)

#define D_PAGE32    (D_GRAN_PAGE+D_DEF32)   /* 32 bit Page granular */

/*
 * Masks for selector fields
 */
#define SELECTOR_MASK   0xFFF8      /* selector index */
#define SEL_LOW_MASK    0xF8        /* mask for low byte of sel indx */
#define TABLE_MASK  0x04        /* table bit */
#define RPL_MASK    0x03        /* privilige bits */
#define RPL_CLR     (~RPL_MASK) /* clear ring bits */

#define IVT_ROM_DATA_SIZE   0x500

/*XLATOFF*/

#ifndef Not_VxD

#define ENABLE_INTERRUPTS() {__asm sti}
#define DISABLE_INTERRUPTS()    {__asm cli}

#define SAVE_FLAGS(flags) \
    __asm pushfd \
    __asm pop flags

#define RESTORE_FLAGS(flags) \
    __asm push flags \
    __asm popfd

#define IO_Delay() \
    __asm _emit 0xeb \
    __asm _emit 0x00

#define Touch_Register(Register) _asm xor Register, Register

typedef DWORD   HEVENT;

#define VMM_GET_DDB_NAMED 0

#pragma warning (disable:4209)  // turn off redefine warning (with basedef.h)

typedef ULONG HTIMEOUT;     // timeout handle
typedef ULONG CMS;      // count of milliseconds

#pragma warning (default:4209)  // turn on redefine warning (with basedef.h)

typedef DWORD   VMM_SEMAPHORE;

#ifndef WANTVXDWRAPS

WORD VXDINLINE
Get_VMM_Version()
{
    WORD w;
    VMMCall(Get_VMM_Version);
    _asm mov [w], ax
    return(w);
}

PVOID VXDINLINE
_HeapAllocate(ULONG Bytes, ULONG Flags)
{
    PVOID p;
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    _asm push [Flags]
    _asm push [Bytes]
    VMMCall(_HeapAllocate)
    _asm add esp, 8
    _asm mov [p], eax
    return(p);
}

ULONG VXDINLINE
_HeapFree(PVOID Address, ULONG Flags)
{
    ULONG ul;
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    _asm push [Flags]
    _asm push [Address]
    VMMCall(_HeapFree)
    _asm add esp, 8
    _asm mov [ul], eax
    return(ul);
}

HEVENT VXDINLINE
Call_Global_Event(void (__cdecl *pfnEvent)(), ULONG ulRefData)
{
    HEVENT hevent;
    _asm mov edx, [ulRefData]
    _asm mov esi, [pfnEvent]
    VMMCall(Call_Global_Event)
    _asm mov [hevent], esi
    return(hevent);
}

HEVENT VXDINLINE
Schedule_Global_Event(void (__cdecl *pfnEvent)(), ULONG ulRefData)
{
    HEVENT hevent;
    _asm mov edx, [ulRefData]
    _asm mov esi, [pfnEvent]
    VMMCall(Schedule_Global_Event)
    _asm mov [hevent], esi
    return(hevent);
}

void VXDINLINE
Cancel_Global_Event( HEVENT hevent )
{
    _asm mov esi, hevent
    VMMCall( Cancel_Global_Event );
}

HVM VXDINLINE
Get_Sys_VM_Handle(VOID)
{
    HVM hvm;
    Touch_Register(ebx)
    VxDCall(Get_Sys_VM_Handle);
    _asm mov [hvm], ebx
    return(hvm);
}

VOID VXDINLINE
Fatal_Error_Handler(PCHAR pszMessage, DWORD dwExitFlag)
{
    _asm mov esi, [pszMessage]
    _asm mov eax, [dwExitFlag]
    VMMCall(Fatal_Error_Handler);
}

VMM_SEMAPHORE VXDINLINE
Create_Semaphore(LONG lTokenCount)
{
    VMM_SEMAPHORE vmm_semaphore;
    _asm mov ecx, [lTokenCount]
    VMMCall(Create_Semaphore)
    _asm cmc
    _asm sbb ecx, ecx
    _asm and eax, ecx
    _asm mov [vmm_semaphore], eax
    return(vmm_semaphore);
}

void VXDINLINE
Destroy_Semaphore(VMM_SEMAPHORE vsSemaphore)
{
    _asm mov eax, [vsSemaphore]
    VMMCall(Destroy_Semaphore)
}

void VXDINLINE
Signal_Semaphore(VMM_SEMAPHORE vsSemaphore)
{
    _asm mov eax, [vsSemaphore]
    VMMCall(Signal_Semaphore)
}

void VXDINLINE
Wait_Semaphore(VMM_SEMAPHORE vsSemaphore, DWORD dwFlags)
{
    _asm mov eax, [vsSemaphore]
    _asm mov ecx, [dwFlags]
    VMMCall(Wait_Semaphore)
}

HVM VXDINLINE
Get_Execution_Focus(void)
{
    HVM hvm;
    Touch_Register(ebx)
    VMMCall(Get_Execution_Focus)
    _asm mov [hvm], ebx
    return(hvm);
}

void VXDINLINE
Begin_Critical_Section(ULONG Flags)
{
    _asm mov ecx, [Flags]
    VMMCall(Begin_Critical_Section)
}

void VXDINLINE
End_Critical_Section(void)
{
    VMMCall(End_Critical_Section)
}

void VXDINLINE
Fatal_Memory_Handler(void)
{
    VMMCall(Fatal_Memory_Error);
}

void VXDINLINE
Begin_Nest_Exec(void)
{
    VMMCall(Begin_Nest_Exec)
}

void VXDINLINE
End_Nest_Exec(void)
{
    VMMCall(End_Nest_Exec)
}

void VXDINLINE
Resume_Exec(void)
{
    VMMCall(Resume_Exec)
}

HTIMEOUT VXDINLINE
Set_VM_Time_Out(void (*pfnTimeout)(), CMS cms, ULONG ulRefData)
{
    HTIMEOUT htimeout;
    _asm mov eax, [cms]
    _asm mov edx, [ulRefData]
    _asm mov esi, [pfnTimeout]
    VMMCall(Set_VM_Time_Out)
    _asm mov [htimeout], esi
    return(htimeout);
}

HTIMEOUT VXDINLINE
Set_Global_Time_Out(void (__cdecl *pfnTimeout)(), CMS cms, ULONG ulRefData)
{
    HTIMEOUT htimeout;
    _asm mov eax, [cms]
    _asm mov edx, [ulRefData]
    _asm mov esi, [pfnTimeout]
    VMMCall(Set_Global_Time_Out)
    _asm mov [htimeout], esi
    return(htimeout);
}

void VXDINLINE
Cancel_Time_Out(HTIMEOUT htimeout)
{
    _asm mov esi, htimeout
    VMMCall(Cancel_Time_Out)
}


void VXDINLINE
Update_System_Clock(ULONG msElapsed)
{
    __asm mov ecx,[msElapsed]
    VMMCall(Update_System_Clock)
}

void VXDINLINE
Enable_Touch_1st_Meg(void)
{
    VMMCall(Enable_Touch_1st_Meg)
}

void VXDINLINE
Disable_Touch_1st_Meg(void)
{
    VMMCall(Disable_Touch_1st_Meg)
}

void VXDINLINE
Out_Debug_String(char *psz)
{
    __asm pushad
    __asm mov esi, [psz]
    VMMCall(Out_Debug_String)
    __asm popad
}

void VXDINLINE
Queue_Debug_String(char *psz, ULONG ulEAX, ULONG ulEBX)
{
    _asm push esi
    _asm push [ulEAX]
    _asm push [ulEBX]
    _asm mov esi, [psz]
    VMMCall(Queue_Debug_String)
    _asm pop esi
}

#ifdef WIN40SERVICES

HTIMEOUT VXDINLINE
Set_Async_Time_Out(void (*pfnTimeout)(), CMS cms, ULONG ulRefData)
{
    HTIMEOUT htimeout;
    _asm mov eax, [cms]
    _asm mov edx, [ulRefData]
    _asm mov esi, [pfnTimeout]
    VMMCall(Set_Async_Time_Out)
    _asm mov [htimeout], esi
    return(htimeout);
}

VXDINLINE struct VxD_Desc_Block *
VMM_Get_DDB(WORD DeviceID, PCHAR Name)
{
    struct VxD_Desc_Block *p;
    _asm movzx eax, [DeviceID]
    _asm mov edi, [Name]
    VMMCall(Get_DDB);
    _asm mov [p], ecx
    return(p);
}

DWORD VXDINLINE
VMM_Directed_Sys_Control(struct VxD_Desc_Block *DDB, DWORD SysControl, DWORD rEBX, DWORD rEDX, DWORD rESI, DWORD rEDI)
{
    DWORD dw;
    _asm mov eax, [SysControl]
    _asm mov ebx, [rEBX]
    _asm mov ecx, [DDB]
    _asm mov edx, [rEDX]
    _asm mov esi, [rESI]
    _asm mov edi, [rEDI]
    VMMCall(Directed_Sys_Control);
    _asm mov [dw], eax
    return(dw);
}

void VXDINLINE
_Trace_Out_Service(char *psz)
{
    __asm push psz
    VMMCall(_Trace_Out_Service)
}

void VXDINLINE
_Debug_Out_Service(char *psz)
{
    __asm push psz
    VMMCall(_Debug_Out_Service)
}

void VXDINLINE
_Debug_Flags_Service(ULONG flags)
{
    __asm push flags
    VMMCall(_Debug_Flags_Service)
}

void VXDINLINE _cdecl
_Debug_Printf_Service(char *pszfmt, ...)
{
    __asm lea  eax,(pszfmt + 4)
    __asm push eax
    __asm push pszfmt
    VMMCall(_Debug_Printf_Service)
    __asm add esp, 2*4
}

#endif // WIN40SERVICES

#endif // WANTVXDWRAPS

#endif // Not_VxD

/*XLATON*/

#endif /* _VMM_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\VKD.INC ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1988-1990
;
;   Title:	vkd.inc -
;
;   Version:	1.00
;
;   Date:	10-Aug-1988
;
;   Author:	RAP
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   10-Aug-1988 RAP started re-write of VKD
;   03-Nov-1988 RAP separated internal stuff out into VKDSYS.INC
;
;==============================================================================


Begin_Service_Table VKD

VKD_Service	VKD_Get_Version, LOCAL
VKD_Service	VKD_Define_Hot_Key, LOCAL
VKD_Service	VKD_Remove_Hot_Key, LOCAL
VKD_Service	VKD_Local_Enable_Hot_Key, LOCAL
VKD_Service	VKD_Local_Disable_Hot_Key, LOCAL
VKD_Service	VKD_Reflect_Hot_Key, LOCAL
VKD_Service	VKD_Cancel_Hot_Key_State, LOCAL
VKD_Service	VKD_Force_Keys, LOCAL
VKD_Service	VKD_Get_Kbd_Owner, LOCAL
VKD_Service	VKD_Define_Paste_Mode, LOCAL
VKD_Service	VKD_Start_Paste, LOCAL
VKD_Service	VKD_Cancel_Paste, LOCAL
VKD_Service	VKD_Get_Msg_Key, LOCAL
VKD_Service	VKD_Peek_Msg_Key, LOCAL
VKD_Service	VKD_Flush_Msg_Key_Queue, LOCAL

End_Service_Table VKD


VKD_Version	equ 200h


;******************************************************************************
;
; shift state bits for both global & local shift states
;
		      ;;5432109876543210
SS_Shift	equ	0000000000000001b   ; left or right
SS_LShift	equ	0000000000000010b
SS_RShift	equ	0000001000000000b
SS_Ctrl 	equ	0000000010000000b   ; left or right
SS_LCtrl	equ	0000000000000100b
SS_RCtrl	equ	0000010000000000b
SS_Alt		equ	0000000100000000b   ; left or right
SS_LAlt 	equ	0000000000001000b
SS_RAlt 	equ	0000100000000000b
SS_CapLock	equ	0000000001000000b
SS_NumLock	equ	0000000000100000b
SS_ScrlLock	equ	0000000000010000b
SS_CapLock_Dn	equ	0100000000000000b   ; SS_CapLock shl 8
SS_NumLock_Dn	equ	0010000000000000b   ; SS_NumLock shl 8
SS_ScrlLock_Dn	equ	0001000000000000b   ; SS_ScrlLock shl 8
SS_Unused	equ	1000000000000000b

SS_Toggle_mask	    equ     SS_CapLock + SS_NumLock + SS_ScrlLock
SS_Toggle_Dn_mask   equ     SS_CapLock_Dn + SS_NumLock_Dn + SS_ScrlLock_Dn
SS_LShift_mask	    equ     SS_LShift + SS_LCtrl + SS_LAlt
SS_Shift_mask	    equ     SS_LShift_mask + SS_RShift + SS_RCtrl + SS_RAlt

SS_Either_Shift     equ     SS_LShift + SS_RShift
SS_Either_Ctrl	    equ     SS_LCtrl + SS_RCtrl
SS_Either_Alt	    equ     SS_LAlt + SS_RAlt


; LED state bits
LED_ScLok	equ	1		    ; Scroll Lock
LED_NmLok	equ	2		    ; Num Lock
LED_CpLok	equ	4		    ; Caps Lock
Toggle_To_LED	equ	4		    ; "state shr Toggle_To_LED" converts
					    ; state bits into kybd LED bits


; VKD_Define_Hot_Key equates & macro

ExtendedKey_B	equ 1
ExtendedKey	equ 100h
AllowExtended_B equ 0FFh
AllowExtended	equ 0FF00h


;VKD_Define_Hot_Key flags:

CallOnPress	equ 1		; Call call-back when key press is detected
CallOnRelease	equ 2		; Call call-back when key release is detected
				; (keyboard may still be in hot-key hold state)
CallOnRepeat	equ 4		; Call call-back when repeated press is detected
CallOnComplete	equ 8		; Call call-back when the hot key state is
				; ended (all shift modifier keys are released)
				; or when a different hot key is entered
				; (i.e. pressing ALT 1 2, if both ALT-1
				;  and ALT-2 are defined hot keys, then ALT-1's
				;  call back will be called before ALT-2's to
				;  indicate that the ALT-1 is complete even
				;  though the ALT key is still down)
CallOnUpDwn	equ CallOnPress + CallOnRelease
				; Call call-back on both press and release
CallOnAll	equ 0		; Call call-back on press, release, auto-repeat
				; and complete
PriorityNotify	equ 10h 	; notification calls to the call-back can only
				; happen when interrupts are enabled and
				; the critical section is un-owned
Local_Key	equ 80h 	; key can be locally enabled/disabled

Hot_Key_Pressed     equ 0
Hot_Key_Released    equ 1
Hot_Key_Repeated    equ 2
Hot_Key_Completed   equ 3

Hot_Key_SysVM_Notify	 equ 80h
Hot_Key_SysVM_Notify_bit equ 7

BeginDoc
;******************************************************************************
;
;   ShiftState
;
;   DESCRIPTION:    Macro to aid in setting EBX with the shift state mask and
;		    shift state compare value for calling VKD_Define_Hot_Key.
;
;   USAGE:	    ShiftState mask, compare
;
;		    The mask specifies the shift state bits that should be
;		    excluded before the compare is done.
;
;==============================================================================
EndDoc
ShiftState MACRO mask, compare
	mov	ebx, ((NOT mask) SHL 16) + compare
	   ENDM

; common shift states

HKSS_Shift  equ (NOT (SS_Either_Shift + SS_Toggle_mask)) SHL 16 + SS_Shift
HKSS_Ctrl   equ (NOT (SS_Either_Ctrl + SS_Toggle_mask)) SHL 16 + SS_Ctrl
HKSS_Alt    equ (NOT (SS_Either_Alt + SS_Toggle_mask)) SHL 16 + SS_Alt


; include structure of entries in paste buffer

include VKDpaste.INC


; paste completion flags passed to the paste call-back

Paste_Complete	equ 0	; paste successful
Paste_Aborted	equ 1	; paste aborted by user
Paste_VM_Term	equ 2	; paste aborted because VM terminated

;
; Modifier byte for Message Keys, retrieved with services VKD_Get_Msg_Key and
; VKD_Peek_Msg_Key
;
MK_Shift	equ 00000010b
MK_Ctrl 	equ 00000100b
MK_Alt		equ 00001000b
MK_Extended	equ 10000000b
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\VMM.INC ===
;****************************************************************************
;                                                                           *
; THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
; KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
; IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
; PURPOSE.                                                                  *
;                                                                           *
; Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
;                                                                           *
;****************************************************************************

ifndef _VMM_
_VMM_	EQU	1
FALSE	EQU	0
VMM_TRUE	EQU	(NOT FALSE)
DEBLEVELRETAIL	EQU	0
DEBLEVELNORMAL	EQU	1
DEBLEVELMAX	EQU	2
ifndef DEBLEVEL
ifdef DEBUG
DEBLEVEL	EQU	DEBLEVELNORMAL
else
DEBLEVEL	EQU	DEBLEVELRETAIL
endif
endif
ifndef WIN31COMPAT
WIN40SERVICES	EQU	1
endif
ifdef MASM6
ifndef NO_MASM6_OPTIONS



    option oldmacros
ifndef  NEWSTRUCTS
    option oldstructs
endif
    option noscoped
    option segment:flat
    option offset:flat
    option proc:private
endif
endif




IFDEF MASM6
BeginDoc MACRO
     ENDM
EndDoc MACRO
       ENDM

BeginMsg MACRO
     ENDM
EndMsg MACRO
       ENDM
ELSE
BeginDoc EQU <>
EndDoc EQU <>

BeginMsg EQU <>
EndMsg EQU <>
ENDIF

UNDEFINED_DEVICE_ID	EQU	00000H
VMM_DEVICE_ID	EQU	00001H
DEBUG_DEVICE_ID	EQU	00002H
VPICD_DEVICE_ID	EQU	00003H
VDMAD_DEVICE_ID	EQU	00004H
VTD_DEVICE_ID	EQU	00005H
V86MMGR_DEVICE_ID	EQU	00006H
PAGESWAP_DEVICE_ID	EQU	00007H
PARITY_DEVICE_ID	EQU	00008H
REBOOT_DEVICE_ID	EQU	00009H
VDD_DEVICE_ID	EQU	0000AH
VSD_DEVICE_ID	EQU	0000BH
VMD_DEVICE_ID	EQU	0000CH
VKD_DEVICE_ID	EQU	0000DH
VCD_DEVICE_ID	EQU	0000EH
VPD_DEVICE_ID	EQU	0000FH
BLOCKDEV_DEVICE_ID	EQU	00010H
VMCPD_DEVICE_ID	EQU	00011H
EBIOS_DEVICE_ID	EQU	00012H
BIOSXLAT_DEVICE_ID	EQU	00013H
VNETBIOS_DEVICE_ID	EQU	00014H
DOSMGR_DEVICE_ID	EQU	00015H
WINLOAD_DEVICE_ID	EQU	00016H
SHELL_DEVICE_ID	EQU	00017H
VMPOLL_DEVICE_ID	EQU	00018H
VPROD_DEVICE_ID	EQU	00019H
DOSNET_DEVICE_ID	EQU	0001AH
VFD_DEVICE_ID	EQU	0001BH
VDD2_DEVICE_ID	EQU	0001CH
WINDEBUG_DEVICE_ID	EQU	0001DH
TSRLOAD_DEVICE_ID	EQU	0001EH
BIOSHOOK_DEVICE_ID	EQU	0001FH
INT13_DEVICE_ID	EQU	00020H
PAGEFILE_DEVICE_ID	EQU	00021H
SCSI_DEVICE_ID	EQU	00022H
MCA_POS_DEVICE_ID	EQU	00023H
SCSIFD_DEVICE_ID	EQU	00024H
VPEND_DEVICE_ID	EQU	00025H
APM_DEVICE_ID	EQU	00026H
VPOWERD_DEVICE_ID	EQU	APM_DEVICE_ID
VXDLDR_DEVICE_ID	EQU	00027H
NDIS_DEVICE_ID	EQU	00028H
BIOS_EXT_DEVICE_ID	EQU	00029H
VWIN32_DEVICE_ID	EQU	0002AH
VCOMM_DEVICE_ID	EQU	0002BH
SPOOLER_DEVICE_ID	EQU	0002CH
WIN32S_DEVICE_ID	EQU	0002DH
DEBUGCMD_DEVICE_ID	EQU	0002EH
CONFIGMG_DEVICE_ID	EQU	00033H
DWCFGMG_DEVICE_ID	EQU	00034H
SCSIPORT_DEVICE_ID	EQU	00035H
VFBACKUP_DEVICE_ID	EQU	00036H
ENABLE_DEVICE_ID	EQU	00037H
VCOND_DEVICE_ID	EQU	00038H
ISAPNP_DEVICE_ID	EQU	0003CH
BIOS_DEVICE_ID	EQU	0003DH
IFSMgr_Device_ID	EQU	00040H
VCDFSD_DEVICE_ID	EQU	00041H
MRCI2_DEVICE_ID	EQU	00042H
PCI_DEVICE_ID	EQU	00043H
PELOADER_DEVICE_ID	EQU	00044H
EISA_DEVICE_ID	EQU	00045H
DRAGCLI_DEVICE_ID	EQU	00046H
DRAGSRV_DEVICE_ID	EQU	00047H
PERF_DEVICE_ID	EQU	00048H
AWREDIR_DEVICE_ID	EQU	00049H
ETEN_Device_ID	EQU	00060H
CHBIOS_Device_ID	EQU	00061H
VMSGD_Device_ID	EQU	00062H
VPPID_Device_ID	EQU	00063H
VIME_Device_ID	EQU	00064H
VHBIOSD_Device_ID	EQU	00065H
BASEID_FOR_NAMEBASEDVXD	EQU	0f000H
BASEID_FOR_NAMEBASEDVXD_MASK	EQU	0fffH
VMM_INIT_ORDER	EQU	000000000H
DEBUG_INIT_ORDER	EQU	000000000H
DEBUGCMD_INIT_ORDER	EQU	000000000H
PERF_INIT_ORDER	EQU	000900000H
APM_INIT_ORDER	EQU	001000000H
VPOWERD_INIT_ORDER	EQU	APM_INIT_ORDER
BIOSHOOK_INIT_ORDER	EQU	006000000H
VPROD_INIT_ORDER	EQU	008000000H
VPICD_INIT_ORDER	EQU	00C000000H
VTD_INIT_ORDER	EQU	014000000H
VXDLDR_INIT_ORDER	EQU	016000000H
ENUMERATOR_INIT_ORDER	EQU	016800000H
ISAPNP_INIT_ORDER	EQU	ENUMERATOR_INIT_ORDER
EISA_INIT_ORDER	EQU	ENUMERATOR_INIT_ORDER
PCI_INIT_ORDER	EQU	ENUMERATOR_INIT_ORDER
BIOS_INIT_ORDER	EQU	ENUMERATOR_INIT_ORDER+1
CONFIGMG_INIT_ORDER	EQU	ENUMERATOR_INIT_ORDER+0FFFFH
VCDFSD_INIT_ORDER	EQU	016F00000H
IOS_INIT_ORDER	EQU	017000000H
PAGEFILE_INIT_ORDER	EQU	018000000H
PAGESWAP_INIT_ORDER	EQU	01C000000H
PARITY_INIT_ORDER	EQU	020000000H
REBOOT_INIT_ORDER	EQU	024000000H
EBIOS_INIT_ORDER	EQU	026000000H
VDD_INIT_ORDER	EQU	028000000H
VSD_INIT_ORDER	EQU	02C000000H
VCD_INIT_ORDER	EQU	030000000H
COMMDRVR_INIT_ORDER	EQU	(VCD_INIT_ORDER-1)
PRTCL_INIT_ORDER	EQU	(COMMDRVR_INIT_ORDER-2)
MODEM_INIT_ORDER	EQU	(COMMDRVR_INIT_ORDER-3)
PORT_INIT_ORDER	EQU	(COMMDRVR_INIT_ORDER-4)
VMD_INIT_ORDER	EQU	034000000H
VKD_INIT_ORDER	EQU	038000000H
VPD_INIT_ORDER	EQU	03C000000H
BLOCKDEV_INIT_ORDER	EQU	040000000H
MCA_POS_INIT_ORDER	EQU	041000000H
SCSIFD_INIT_ORDER	EQU	041400000H
SCSIMASTER_INIT_ORDER	EQU	041800000H
INT13_INIT_ORDER	EQU	042000000H
VMCPD_INIT_ORDER	EQU	048000000H
BIOSXLAT_INIT_ORDER	EQU	050000000H
VNETBIOS_INIT_ORDER	EQU	054000000H
DOSMGR_INIT_ORDER	EQU	058000000H
DOSNET_INIT_ORDER	EQU	05C000000H
WINLOAD_INIT_ORDER	EQU	060000000H
VMPOLL_INIT_ORDER	EQU	064000000H
UNDEFINED_INIT_ORDER	EQU	080000000H
WIN32_INIT_ORDER	EQU	UNDEFINED_INIT_ORDER
VCOND_INIT_ORDER	EQU	UNDEFINED_INIT_ORDER
WINDEBUG_INIT_ORDER	EQU	081000000H
VDMAD_INIT_ORDER	EQU	090000000H
V86MMGR_INIT_ORDER	EQU	0A0000000H
IFSMgr_Init_Order	EQU	10000H+V86MMGR_Init_Order
FSD_Init_Order	EQU	00100H+IFSMgr_Init_Order
VFD_INIT_ORDER	EQU	50000H+IFSMgr_Init_Order
UNDEF_TOUCH_MEM_INIT_ORDER	EQU	0A8000000H
SHELL_INIT_ORDER	EQU	0B0000000H






IO_Delay    macro
jmp $+2
ENDM

VXD_FAILURE	EQU	0
VXD_SUCCESS	EQU	1

Pushad_Struc	STRUC
Pushad_EDI	DD	?
Pushad_ESI	DD	?
Pushad_EBP	DD	?
Pushad_ESP	DD	?
Pushad_EBX	DD	?
Pushad_EDX	DD	?
Pushad_ECX	DD	?
Pushad_EAX	DD	?
Pushad_Struc	ENDS
ifndef Not_VxD
??_CUR_CODE_SEG = 0

??_LCODE    =   1
??_ICODE    =   2
??_PCODE    =   3
??_SCODE    =   4
??_DBOCODE  =   5
??_16ICODE  =   6
??_RCODE    =   7
??_LOCKABLECODE =   8

?_LCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_LCODE>
?_ICODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_ICODE>
?_PCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_PCODE>
?_SCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_SCODE>
?_DBOCODE   equ <(??_CUR_CODE_SEG MOD 16) - ??_DBOCODE>
?_16ICODE   equ <(??_CUR_CODE_SEG MOD 16) - ??_16ICODE>
?_RCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_RCODE>
?_LOCKABLECODE  equ <(??_CUR_CODE_SEG MOD 16) - ??_LOCKABLECODE>

ifndef NO_SEGMENTS





IFDEF   MASM6
_FLAT   EQU FLAT
ELSE
_FLAT   EQU USE32
ENDIF


_LTEXT      SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_LTEXT      ENDS

_TEXT       SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_TEXT       ENDS


_PTEXT      SEGMENT DWORD PUBLIC _FLAT 'PCODE'
_PTEXT      ENDS



MakeCodeSeg MACRO seglist, classname, grpname, iseg

    IRP segname,<seglist>

IFNB    <classname>
    segname     SEGMENT DWORD PUBLIC _FLAT "&classname&CODE"
ELSE
    segname     SEGMENT DWORD PUBLIC _FLAT "&segname&CODE"
ENDIF

IFB <iseg>
VxD_&&segname&&_CODE_SEG MACRO
segname  SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_PCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

        ENDM
ELSE
VxD_&&segname&&_CODE_SEG MACRO
segname  SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + iseg
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

        ENDM
ENDIF

VxD_&&segname&&_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
segname ENDS
        ENDM

segname     ENDS

IFNDEF BLD_COFF
IFNB    <grpname>
    _&grpname GROUP segname
ELSE
    _&&segname GROUP segname
ENDIF
ENDIF

    ENDM

    ENDM

MakeCodeSeg <LOCKABLE_BEGIN, LOCKABLE, LOCKABLE_END>, \
    LOCKABLE, LOCKABLE, ??_LOCKABLECODE
MakeCodeSeg INT21
MakeCodeSeg SYSEXIT
MakeCodeSeg RARE
MakeCodeSeg W16
MakeCodeSeg W32
MakeCodeSeg VMCREATE
MakeCodeSeg VMDESTROY
MakeCodeSeg THCREATE
MakeCodeSeg THDESTROY
MakeCodeSeg VMSUSPEND
MakeCodeSeg VMRESUME
MakeCodeSeg PNP
MakeCodeSeg DOSVM











DefLockableCodeBegin MACRO name, private
VxD_LOCKABLE_BEGIN_CODE_SEG
IFB <private>
    PUBLIC  name
ENDIF
name    LABEL   NEAR
VxD_LOCKABLE_BEGIN_CODE_ENDS
ifndef WIN31COMPAT
if DEBLEVEL
VxD_LOCKED_DATA_SEG
    PUBLIC name&_Debug_Flags
name&_Debug_Flags DD DFS_TEST_BLOCK
VxD_LOCKED_DATA_ENDS
??_debug_flags equ <name&_Debug_Flags>
endif
endif
    ENDM









DefLockableCodeEnd MACRO name, private
VxD_LOCKABLE_END_CODE_SEG
IFB <private>
    PUBLIC  name
ENDIF
name    LABEL   NEAR
VxD_LOCKABLE_END_CODE_ENDS
    ENDM





CodeLockFlags MACRO name
ifndef WIN31COMPAT
if DEBLEVEL
    ifndef name&_Debug_Flags
    VxD_LOCKED_DATA_SEG
        extrn   name&_Debug_Flags:dword
    VxD_LOCKED_DATA_ENDS
    ??_debug_flags equ <name&_Debug_Flags>
    endif
endif
endif
    ENDM






MarkCodeLocked MACRO
ifndef WIN31COMPAT
if DEBLEVEL
ifdef ??_debug_flags
    pushfd
    and ??_debug_flags,NOT DFS_TEST_BLOCK
    popfd
endif
endif
endif
    ENDM






MarkCodeUnlocked MACRO
ifndef WIN31COMPAT
if DEBLEVEL
ifdef ??_debug_flags
    pushfd
    or  ??_debug_flags,DFS_TEST_BLOCK
    popfd
endif
endif
endif
    ENDM



_ITEXT      SEGMENT DWORD PUBLIC _FLAT 'ICODE'
_ITEXT      ENDS


_LDATA      SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_LDATA      ENDS

_DATA       SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_DATA       ENDS


_PDATA      SEGMENT DWORD PUBLIC _FLAT 'PDATA'
_PDATA      ENDS


_IDATA      SEGMENT DWORD PUBLIC _FLAT 'ICODE'
_IDATA      ENDS


_BSS        SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_BSS        ENDS

CONST       SEGMENT DWORD PUBLIC _FLAT 'LCODE'
CONST       ENDS

_TLS        SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_TLS        ENDS


_STEXT      SEGMENT DWORD PUBLIC _FLAT 'SCODE'
_STEXT      ENDS


_SDATA      SEGMENT DWORD PUBLIC _FLAT 'SCODE'
_SDATA      ENDS


_DBOSTART   SEGMENT DWORD PUBLIC _FLAT 'DBOCODE'
_DBOSTART   ENDS


_DBOCODE    SEGMENT DWORD PUBLIC _FLAT 'DBOCODE'
_DBOCODE    ENDS


_DBODATA    SEGMENT DWORD PUBLIC _FLAT 'DBOCODE'
_DBODATA    ENDS

if DEBLEVEL

_PATHSTART  SEGMENT DWORD PUBLIC  _FLAT 'LCODE'
_PATHSTART  ENDS


_PATHDATA   SEGMENT DWORD PUBLIC  _FLAT 'LCODE'
_PATHDATA   ENDS


_PATHEND    SEGMENT DWORD PUBLIC  _FLAT 'LCODE'
_PATHEND    ENDS
endif


_16ICODE    SEGMENT WORD USE16 PUBLIC '16ICODE'
_16ICODE    ENDS


_RCODE      SEGMENT WORD USE16 PUBLIC 'RCODE'
_RCODE      ENDS

IFNDEF BLD_COFF
_LGROUP   GROUP _LTEXT, _TEXT, _LDATA, _DATA, _BSS, CONST, _TLS
_IGROUP   GROUP _ITEXT, _IDATA
_SGROUP   GROUP _STEXT, _SDATA
_DBOGROUP GROUP _DBOSTART, _DBOCODE, _DBODATA
IF DEBLEVEL
_PGROUP	  GROUP _PATHSTART, _PATHDATA, _PATHEND
ENDIF
ENDIF

endif

    ASSUME CS:FLAT, DS:FLAT, ES:FLAT, SS:FLAT

OFFSET32 EQU <OFFSET FLAT:>


BeginDoc





































EndDoc

Begin_Service_Table MACRO Device_Name, Def_Segment

IFDEF   Device_Name&_Name_Based
 IFNDEF @@NextInternalID
    @@NextInternalID    = 0
 ENDIF
 @@NextInternalID = (@@NextInternalID + 1)
 Device_Name&_Internal_ID   = @@NextInternalID + BASEID_FOR_NAMEBASEDVXD
 DefineVxDName  Device_Name, %Device_Name&_Internal_ID
ENDIF

IFB <Def_Segment>
    BST2 Device_Name, VxD
ELSE
    BST2 Device_Name, Def_Segment
ENDIF
    ENDM

DefineVxDName   MACRO Device_Name, InternalID
 @@VxDName&InternalID EQU   <___&Device_Name&STable>
ENDM


BST2 MACRO Device_Name, Def_Segment

Num_&Device_Name&_Services = 0

IFDEF Create_&Device_Name&_Service_Table

Def_Segment&_LOCKED_DATA_SEG

Device_Name&_Service_Table LABEL DWORD

Device_Name&_Service MACRO Procedure, Local_Seg, Condition
LOCAL $$&Procedure

  IFNB <Condition>
  $$&&Procedure MACRO extern
    IFDEF &Condition
      IFNB <extern>
    EXTRN   Procedure:NEAR
      ELSE
    dd  OFFSET32 Procedure
      ENDIF
    ELSE
      IFB <extern>
      dd      0
      ENDIF
    ENDIF
    ENDM
  ENDIF

  IFDIFI <Procedure>, <RESERVED>
    PUBLIC _&&Procedure
     IF1
    _&&Procedure LABEL DWORD
     ENDIF
     IFDIFI <Local_Seg>, <LOCAL>
        IFNB <Local_Seg>
Local_Seg&&_SEG
       ELSE
Def_Segment&_CODE_SEG
        ENDIF
        IFNB <Condition>
    $$&&Procedure extern
       ELSE
    EXTRN   Procedure:NEAR
        ENDIF
        IFNB <Local_Seg>
Local_Seg&&_ENDS
        ELSE
Def_Segment&_CODE_ENDS
        ENDIF
     ENDIF
      IFNB <Condition>
    $$&&Procedure
      ELSE
    dd  OFFSET32 Procedure
      ENDIF

          IFDEF Device_Name&_Name_Based
        @@&&Procedure = (Device_Name&_Internal_ID SHL 16) + Num_&Device_Name&_Services
          ELSE
        @@&&Procedure = (Device_Name&_Device_ID SHL 16) + Num_&Device_Name&_Services
          ENDIF
  ELSE
    dd  0
  ENDIF
    Num_&Device_Name&_Services = Num_&Device_Name&_Services + 1
  IFNB <Condition>
    Purge $$&&Procedure
  ENDIF
    ENDM

ELSE



IFDEF   Device_Name&_Name_Based

Device_Name&_Service MACRO Procedure, Local_Seg, Condition


  IFDIFI <Procedure>, <RESERVED>
    @@&&Procedure = (Device_Name&_Internal_ID SHL 16) + Num_&Device_Name&_Services
  ENDIF
    Num_&Device_Name&_Services = Num_&Device_Name&_Services + 1

    ENDM
ELSE

Device_Name&_Service MACRO Procedure, Local_Seg, Condition

  IFDIFI <Procedure>, <RESERVED>
    @@&&Procedure = (Device_Name&_Device_ID SHL 16) + Num_&Device_Name&_Services
  ENDIF
    Num_&Device_Name&_Services = Num_&Device_Name&_Services + 1

    ENDM
ENDIF

ENDIF

    ENDM



End_Service_Table MACRO Device_Name, Def_Segment

    PURGE   Device_Name&_Service

IFDEF Create_&Device_Name&_Service_Table

IFB <Def_Segment>
VxD_LOCKED_DATA_ENDS
ELSE
Def_Segment&_LOCKED_DATA_ENDS
ENDIF

ENDIF

    ENDM

GetVxDServiceOrdinal    macro   reg,service
    mov reg,@@&service
    endm

GetVxDServiceAddress    macro   reg,service
    mov reg,OFFSET32 service
    endm


















Begin_Win32_Services MACRO VxDName
ifndef Create_Win32_Services
    Create_Win32_Services = 0
endif
    .errb <VxDName>, <VxD name missing>
    ??w32svcno = 0
if Create_Win32_Services
VxDName&_Win32_Services label dword
    dd  csvc&VxDName, 0
endif
    ??inw32svc = 1

    VxDName&_Win32_Service MACRO Name
        .erre ??inw32svc, <Missing Begin_Win32_Services>
    if Create_Win32_Services
        dd  OFFSET32 Name,cparm&&Name
    endif
        @32&&Name equ   ((VxDName&_Device_ID SHL 16) + ??w32svcno)
        ??w32svcno = ??w32svcno + 1
        ENDM
    ENDM










End_Win32_Services MACRO VxDName
    .errb <VxDName>, <VxD name misssing>
if Create_Win32_Services
    csvc&VxDName    equ ($ - VxDName&_Win32_Services)/8 - 1
endif
    ??inw32svc = 0
    PURGE VxDName&_Win32_Service
    ENDM











Declare_Win32_Service MACRO Name, cParms
ifndef Create_Win32_Services
    Create_Win32_Services = 0
endif
if Create_Win32_Services
    ?merge  <Name>,,,,<EQU>,<_>,<Name>,<@>,%(cParms*4 + 8)
    ?merge  <cparm>,<Name>,,,<EQU>,<cParms>
VxD_CODE_SEG
    ?merge  <EXTRN>,,,,,<_>,<Name>,<@>,%(cParms*4 + 8),<:NEAR>
VxD_CODE_ENDS
endif
    ENDM












Win32call MACRO Service, CallBack
ifndef Create_Win32_Services
    Create_Win32_Services = 0
endif
ife Create_Win32_Services
    mov eax,@32&Service
ifdef IS_16
    movzx   esp,sp
endif
    call    fword ptr [CallBack]
ifdef DEBUG
    int 3
endif
endif
    ENDM







Dword_Align MACRO Seg_Name
    LOCAL segn
IFDEF MASM6
    align 4
ELSE
IFNB <Seg_Name>
    segn equ Seg_Name
ELSE
IFE ?_LCODE
    segn equ <_LTEXT>
ELSE
IFE ?_ICODE
    segn equ <_ITEXT>
ELSE
IFE ?_PCODE
    segn equ <_PTEXT>
ELSE
IFE ?_SCODE
    segn equ <_STEXT>
ELSE
.err <Dword_Align not supported>
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
IF (($-OFFSET segn:0) MOD 4)
db 4 - (($-OFFSET segn:0) MOD 4) DUP (90h)
ENDIF
ENDIF
        ENDM


BeginDoc

















EndDoc

Fatal_Error MACRO Msg_Ptr, Exit_Flags
    pushad
IFB <Msg_Ptr>
    xor esi, esi
ELSE
    mov esi, Msg_Ptr
IFB <Exit_Flags>
    xor eax, eax
ELSE
    mov eax, Exit_Flags
ENDIF
ENDIF
    VMMCall Fatal_Error_Handler
    ENDM

EF_Hang_On_Exit     EQU     1h


cb_s	STRUC
CB_VM_Status	DD	?
CB_High_Linear	DD	?
CB_Client_Pointer	DD	?
CB_VMID	DD	?
CB_Signature	DD	?
cb_s	ENDS
VMCB_ID	EQU	62634D56H
VMSTAT_EXCLUSIVE_BIT	EQU	00H
VMSTAT_EXCLUSIVE	EQU	(1 SHL VMSTAT_EXCLUSIVE_BIT)
VMSTAT_BACKGROUND_BIT	EQU	01H
VMSTAT_BACKGROUND	EQU	(1 SHL VMSTAT_BACKGROUND_BIT)
VMSTAT_CREATING_BIT	EQU	02H
VMSTAT_CREATING	EQU	(1 SHL VMSTAT_CREATING_BIT)
VMSTAT_SUSPENDED_BIT	EQU	03H
VMSTAT_SUSPENDED	EQU	(1 SHL VMSTAT_SUSPENDED_BIT)
VMSTAT_NOT_EXECUTEABLE_BIT	EQU	04H
VMSTAT_NOT_EXECUTEABLE	EQU	(1 SHL VMSTAT_NOT_EXECUTEABLE_BIT)
VMSTAT_PM_EXEC_BIT	EQU	05H
VMSTAT_PM_EXEC	EQU	(1 SHL VMSTAT_PM_EXEC_BIT)
VMSTAT_PM_APP_BIT	EQU	06H
VMSTAT_PM_APP	EQU	(1 SHL VMSTAT_PM_APP_BIT)
VMSTAT_PM_USE32_BIT	EQU	07H
VMSTAT_PM_USE32	EQU	(1 SHL VMSTAT_PM_USE32_BIT)
VMSTAT_VXD_EXEC_BIT	EQU	08H
VMSTAT_VXD_EXEC	EQU	(1 SHL VMSTAT_VXD_EXEC_BIT)
VMSTAT_HIGH_PRI_BACK_BIT	EQU	09H
VMSTAT_HIGH_PRI_BACK	EQU	(1 SHL VMSTAT_HIGH_PRI_BACK_BIT)
VMSTAT_BLOCKED_BIT	EQU	0AH
VMSTAT_BLOCKED	EQU	(1 SHL VMSTAT_BLOCKED_BIT)
VMSTAT_AWAKENING_BIT	EQU	0BH
VMSTAT_AWAKENING	EQU	(1 SHL VMSTAT_AWAKENING_BIT)
VMSTAT_PAGEABLEV86BIT	EQU	0CH
VMSTAT_PAGEABLEV86_BIT	EQU	VMSTAT_PAGEABLEV86BIT
VMSTAT_PAGEABLEV86	EQU	(1 SHL VMSTAT_PAGEABLEV86BIT)
VMSTAT_V86INTSLOCKEDBIT	EQU	0DH
VMSTAT_V86INTSLOCKED_BIT	EQU	VMSTAT_V86INTSLOCKEDBIT
VMSTAT_V86INTSLOCKED	EQU	(1 SHL VMSTAT_V86INTSLOCKEDBIT)
VMSTAT_IDLE_TIMEOUT_BIT	EQU	0EH
VMSTAT_IDLE_TIMEOUT	EQU	(1 SHL VMSTAT_IDLE_TIMEOUT_BIT)
VMSTAT_IDLE_BIT	EQU	0FH
VMSTAT_IDLE	EQU	(1 SHL VMSTAT_IDLE_BIT)
VMSTAT_CLOSING_BIT	EQU	10H
VMSTAT_CLOSING	EQU	(1 SHL VMSTAT_CLOSING_BIT)
VMSTAT_TS_SUSPENDED_BIT	EQU	11H
VMSTAT_TS_SUSPENDED	EQU	(1 SHL VMSTAT_TS_SUSPENDED_BIT)
VMSTAT_TS_MAXPRI_BIT	EQU	12H
VMSTAT_TS_MAXPRI	EQU	(1 SHL VMSTAT_TS_MAXPRI_BIT)
VMSTAT_USE32_MASK	EQU	(VMSTAT_PM_USE32 OR VMSTAT_VXD_EXEC)

tcb_s	STRUC
TCB_Flags	DD	?
TCB_Reserved1	DD	?
TCB_Reserved2	DD	?
TCB_Signature	DD	?
TCB_ClientPtr	DD	?
TCB_VMHandle	DD	?
TCB_ThreadId	DW	?
TCB_PMLockOrigSS	DW	?
TCB_PMLockOrigESP	DD	?
TCB_PMLockOrigEIP	DD	?
TCB_PMLockStackCount	DD	?
TCB_PMLockOrigCS	DW	?
TCB_PMPSPSelector	DW	?
TCB_ThreadType	DD	?
TCB_pad1	DW	?
TCB_pad2	DB	?
TCB_extErrLocus	DB	?
TCB_extErr	DW	?
TCB_extErrAction	DB	?
TCB_extErrClass	DB	?
TCB_extErrPtr	DD	?
tcb_s	ENDS
SCHED_OBJ_ID_THREAD	EQU	42434854H
THFLAG_SUSPENDED_BIT	EQU	03H
THFLAG_SUSPENDED	EQU	(1 SHL THFLAG_SUSPENDED_BIT)
THFLAG_NOT_EXECUTEABLE_BIT	EQU	04H
THFLAG_NOT_EXECUTEABLE	EQU	(1 SHL THFLAG_NOT_EXECUTEABLE_BIT)
THFLAG_THREAD_CREATION_BIT	EQU	08H
THFLAG_THREAD_CREATION	EQU	(1 SHL THFLAG_THREAD_CREATION_BIT)
THFLAG_THREAD_BLOCKED_BIT	EQU	0AH
THFLAG_THREAD_BLOCKED	EQU	(1 SHL THFLAG_THREAD_BLOCKED_BIT)
THFLAG_RING0_THREAD_BIT	EQU	1CH
THFLAG_RING0_THREAD	EQU	(1 SHL THFLAG_RING0_THREAD_BIT)
THFLAG_CHARSET_BITS	EQU	10H
THFLAG_CHARSET_MASK	EQU	(3 SHL THFLAG_CHARSET_BITS)
THFLAG_ANSI	EQU	(0 SHL THFLAG_CHARSET_BITS)
THFLAG_OEM	EQU	(1 SHL THFLAG_CHARSET_BITS)
THFLAG_UNICODE	EQU	(2 SHL THFLAG_CHARSET_BITS)
THFLAG_RESERVED	EQU	(3 SHL THFLAG_CHARSET_BITS)
THFLAG_EXTENDED_HANDLES_BIT	EQU	12H
THFLAG_EXTENDED_HANDLES	EQU	(1 SHL THFLAG_EXTENDED_HANDLES_BIT)
THFLAG_OPEN_AS_IMMOVABLE_FILE_BIT	EQU	13H
THFLAG_OPEN_AS_IMMOVABLE_FILE	EQU	(1 SHL THFLAG_OPEN_AS_IMMOVABLE_FILE_BIT)

pmcb_s	STRUC
PMCB_Flags	DD	?
PMCB_Parent	DD	?
pmcb_s	ENDS

VMFaultInfo	STRUC
VMFI_EIP	DD	?
VMFI_CS	DW	?
VMFI_Ints	DW	?
VMFaultInfo	ENDS
Begin_Service_Table VMM, VMM
VMM_Service  Get_VMM_Version, LOCAL
VMM_Service  Get_Cur_VM_Handle
VMM_Service  Test_Cur_VM_Handle
VMM_Service  Get_Sys_VM_Handle
VMM_Service  Test_Sys_VM_Handle
VMM_Service  Validate_VM_Handle
VMM_Service  Get_VMM_Reenter_Count
VMM_Service  Begin_Reentrant_Execution
VMM_Service  End_Reentrant_Execution
VMM_Service  Install_V86_Break_Point
VMM_Service  Remove_V86_Break_Point
VMM_Service  Allocate_V86_Call_Back
VMM_Service  Allocate_PM_Call_Back
VMM_Service  Call_When_VM_Returns
VMM_Service  Schedule_Global_Event
VMM_Service  Schedule_VM_Event
VMM_Service  Call_Global_Event
VMM_Service  Call_VM_Event
VMM_Service  Cancel_Global_Event
VMM_Service  Cancel_VM_Event
VMM_Service  Call_Priority_VM_Event
VMM_Service  Cancel_Priority_VM_Event
VMM_Service  Get_NMI_Handler_Addr
VMM_Service  Set_NMI_Handler_Addr
VMM_Service  Hook_NMI_Event
VMM_Service  Call_When_VM_Ints_Enabled
VMM_Service  Enable_VM_Ints
VMM_Service  Disable_VM_Ints
VMM_Service  Map_Flat
VMM_Service  Map_Lin_To_VM_Addr
VMM_Service  Adjust_Exec_Priority
VMM_Service  Begin_Critical_Section
VMM_Service  End_Critical_Section
VMM_Service  End_Crit_And_Suspend
VMM_Service  Claim_Critical_Section
VMM_Service  Release_Critical_Section
VMM_Service  Call_When_Not_Critical
VMM_Service  Create_Semaphore
VMM_Service  Destroy_Semaphore
VMM_Service  Wait_Semaphore
VMM_Service  Signal_Semaphore
VMM_Service  Get_Crit_Section_Status
VMM_Service  Call_When_Task_Switched
VMM_Service  Suspend_VM
VMM_Service  Resume_VM
VMM_Service  No_Fail_Resume_VM
VMM_Service  Nuke_VM
VMM_Service  Crash_Cur_VM
VMM_Service  Get_Execution_Focus
VMM_Service  Set_Execution_Focus
VMM_Service  Get_Time_Slice_Priority
VMM_Service  Set_Time_Slice_Priority
VMM_Service  Get_Time_Slice_Granularity
VMM_Service  Set_Time_Slice_Granularity
VMM_Service  Get_Time_Slice_Info
VMM_Service  Adjust_Execution_Time
VMM_Service  Release_Time_Slice
VMM_Service  Wake_Up_VM
VMM_Service  Call_When_Idle
VMM_Service  Get_Next_VM_Handle
VMM_Service  Set_Global_Time_Out
VMM_Service  Set_VM_Time_Out
VMM_Service  Cancel_Time_Out
VMM_Service  Get_System_Time
VMM_Service  Get_VM_Exec_Time
VMM_Service  Hook_V86_Int_Chain
VMM_Service  Get_V86_Int_Vector
VMM_Service  Set_V86_Int_Vector
VMM_Service  Get_PM_Int_Vector
VMM_Service  Set_PM_Int_Vector
VMM_Service  Simulate_Int
VMM_Service  Simulate_Iret
VMM_Service  Simulate_Far_Call
VMM_Service  Simulate_Far_Jmp
VMM_Service  Simulate_Far_Ret
VMM_Service  Simulate_Far_Ret_N
VMM_Service  Build_Int_Stack_Frame
VMM_Service  Simulate_Push
VMM_Service  Simulate_Pop
VMM_Service  _HeapAllocate
VMM_Service  _HeapReAllocate
VMM_Service  _HeapFree
VMM_Service  _HeapGetSize
HEAPZEROINIT	EQU	00000001H
HEAPZEROREINIT	EQU	00000002H
HEAPNOCOPY	EQU	00000004H
HEAPLOCKEDIFDP	EQU	00000100H
HEAPSWAP	EQU	00000200H
HEAPINIT	EQU	00000400H
HEAPCLEAN	EQU	00000800H
VMM_Service  _PageAllocate
VMM_Service  _PageReAllocate
VMM_Service  _PageFree
VMM_Service  _PageLock
VMM_Service  _PageUnLock
VMM_Service  _PageGetSizeAddr
VMM_Service  _PageGetAllocInfo
VMM_Service  _GetFreePageCount
VMM_Service  _GetSysPageCount
VMM_Service  _GetVMPgCount
VMM_Service  _MapIntoV86
VMM_Service  _PhysIntoV86
VMM_Service  _TestGlobalV86Mem
VMM_Service  _ModifyPageBits
VMM_Service  _CopyPageTable
VMM_Service  _LinMapIntoV86
VMM_Service  _LinPageLock
VMM_Service  _LinPageUnLock
VMM_Service  _SetResetV86Pageable
VMM_Service  _GetV86PageableArray
VMM_Service  _PageCheckLinRange
VMM_Service  _PageOutDirtyPages
VMM_Service  _PageDiscardPages
PAGEZEROINIT	EQU	00000001H
PAGEUSEALIGN	EQU	00000002H
PAGECONTIG	EQU	00000004H
PAGEFIXED	EQU	00000008H
PAGEDEBUGNULFAULT	EQU	00000010H
PAGEZEROREINIT	EQU	00000020H
PAGENOCOPY	EQU	00000040H
PAGELOCKED	EQU	00000080H
PAGELOCKEDIFDP	EQU	00000100H
PAGESETV86PAGEABLE	EQU	00000200H
PAGECLEARV86PAGEABLE	EQU	00000400H
PAGESETV86INTSLOCKED	EQU	00000800H
PAGECLEARV86INTSLOCKED	EQU	00001000H
PAGEMARKPAGEOUT	EQU	00002000H
PAGEPDPSETBASE	EQU	00004000H
PAGEPDPCLEARBASE	EQU	00008000H
PAGEDISCARD	EQU	00010000H
PAGEPDPQUERYDIRTY	EQU	00020000H
PAGEMAPFREEPHYSREG	EQU	00040000H
PAGENOMOVE	EQU	10000000H
PAGEMAPGLOBAL	EQU	40000000H
PAGEMARKDIRTY	EQU	80000000H
MAPV86_IGNOREWRAP	EQU	00000001H
VMM_Service  _GetNulPageHandle
VMM_Service  _GetFirstV86Page
VMM_Service  _MapPhysToLinear
VMM_Service  _GetAppFlatDSAlias
VMM_Service  _SelectorMapFlat
VMM_Service  _GetDemandPageInfo
VMM_Service  _GetSetPageOutCount
GSPOC_F_GET	EQU	00000001H
VMM_Service  Hook_V86_Page
VMM_Service  _Assign_Device_V86_Pages
VMM_Service  _DeAssign_Device_V86_Pages
VMM_Service  _Get_Device_V86_Pages_Array
VMM_Service  MMGR_SetNULPageAddr
VMM_Service  _Allocate_GDT_Selector
VMM_Service  _Free_GDT_Selector
VMM_Service  _Allocate_LDT_Selector
VMM_Service  _Free_LDT_Selector
VMM_Service  _BuildDescriptorDWORDs
VMM_Service  _GetDescriptor
VMM_Service  _SetDescriptor
BDDEXPLICITDPL	EQU	00000001H
ALDTSPECSEL	EQU	00000001H
VMM_Service  _MMGR_Toggle_HMA
MMGRHMAPHYSICAL	EQU	00000001H
MMGRHMAENABLE	EQU	00000002H
MMGRHMADISABLE	EQU	00000004H
MMGRHMAQUERY	EQU	00000008H
VMM_Service  Get_Fault_Hook_Addrs
VMM_Service  Hook_V86_Fault
VMM_Service  Hook_PM_Fault
VMM_Service  Hook_VMM_Fault
VMM_Service  Begin_Nest_V86_Exec
VMM_Service  Begin_Nest_Exec
VMM_Service  Exec_Int
VMM_Service  Resume_Exec
VMM_Service  End_Nest_Exec
VMM_Service  Allocate_PM_App_CB_Area, VMM_ICODE
VMM_Service  Get_Cur_PM_App_CB
VMM_Service  Set_V86_Exec_Mode
VMM_Service  Set_PM_Exec_Mode
VMM_Service  Begin_Use_Locked_PM_Stack
VMM_Service  End_Use_Locked_PM_Stack
VMM_Service  Save_Client_State
VMM_Service  Restore_Client_State
VMM_Service  Exec_VxD_Int
VMM_Service  Hook_Device_Service
VMM_Service  Hook_Device_V86_API
VMM_Service  Hook_Device_PM_API
VMM_Service  System_Control
VMM_Service  Simulate_IO
VMM_Service  Install_Mult_IO_Handlers
VMM_Service  Install_IO_Handler
VMM_Service  Enable_Global_Trapping
VMM_Service  Enable_Local_Trapping
VMM_Service  Disable_Global_Trapping
VMM_Service  Disable_Local_Trapping
VMM_Service  List_Create
VMM_Service  List_Destroy
VMM_Service  List_Allocate
VMM_Service  List_Attach
VMM_Service  List_Attach_Tail
VMM_Service  List_Insert
VMM_Service  List_Remove
VMM_Service  List_Deallocate
VMM_Service  List_Get_First
VMM_Service  List_Get_Next
VMM_Service  List_Remove_First
LF_ASYNC_BIT	EQU	0
LF_ASYNC	EQU	(1 SHL LF_ASYNC_BIT)
LF_USE_HEAP_BIT	EQU	1
LF_USE_HEAP	EQU	(1 SHL LF_USE_HEAP_BIT)
LF_ALLOC_ERROR_BIT	EQU	2
LF_ALLOC_ERROR	EQU	(1 SHL LF_ALLOC_ERROR_BIT)
LF_SWAP	EQU	(LF_USE_HEAP+(1 SHL 3))
VMM_Service  _AddInstanceItem
VMM_Service  _Allocate_Device_CB_Area
VMM_Service  _Allocate_Global_V86_Data_Area, VMM_ICODE
VMM_Service  _Allocate_Temp_V86_Data_Area, VMM_ICODE
VMM_Service  _Free_Temp_V86_Data_Area, VMM_ICODE
GVDAWordAlign	EQU	00000001H
GVDADWordAlign	EQU	00000002H
GVDAParaAlign	EQU	00000004H
GVDAPageAlign	EQU	00000008H
GVDAInstance	EQU	00000100H
GVDAZeroInit	EQU	00000200H
GVDAReclaim	EQU	00000400H
GVDAInquire	EQU	00000800H
GVDAHighSysCritOK	EQU	00001000H
GVDAOptInstance	EQU	00002000H
GVDAForceLow	EQU	00004000H
TVDANeedTilInitComplete	EQU	00000001H
VMM_Service  Get_Profile_Decimal_Int, VMM_ICODE
VMM_Service  Convert_Decimal_String, VMM_ICODE
VMM_Service  Get_Profile_Fixed_Point, VMM_ICODE
VMM_Service  Convert_Fixed_Point_String, VMM_ICODE
VMM_Service  Get_Profile_Hex_Int, VMM_ICODE
VMM_Service  Convert_Hex_String, VMM_ICODE
VMM_Service  Get_Profile_Boolean, VMM_ICODE
VMM_Service  Convert_Boolean_String, VMM_ICODE
VMM_Service  Get_Profile_String, VMM_ICODE
VMM_Service  Get_Next_Profile_String, VMM_ICODE
VMM_Service  Get_Environment_String, VMM_ICODE
VMM_Service  Get_Exec_Path, VMM_ICODE
VMM_Service  Get_Config_Directory, VMM_ICODE
VMM_Service  OpenFile, VMM_ICODE
VMM_OPENFILE_BUF_SIZE	EQU	260
VMM_Service  Get_PSP_Segment, VMM_ICODE
VMM_Service  GetDOSVectors, VMM_ICODE
VMM_Service  Get_Machine_Info
GMIF_80486_BIT	EQU	10H
GMIF_80486	EQU	(1 SHL GMIF_80486_BIT)
GMIF_PCXT_BIT	EQU	11H
GMIF_PCXT	EQU	(1 SHL GMIF_PCXT_BIT)
GMIF_MCA_BIT	EQU	12H
GMIF_MCA	EQU	(1 SHL GMIF_MCA_BIT)
GMIF_EISA_BIT	EQU	13H
GMIF_EISA	EQU	(1 SHL GMIF_EISA_BIT)
GMIF_CPUID_BIT	EQU	14H
GMIF_CPUID	EQU	(1 SHL GMIF_CPUID_BIT)
VMM_Service  GetSet_HMA_Info
VMM_Service  Set_System_Exit_Code
VMM_Service  Fatal_Error_Handler
VMM_Service  Fatal_Memory_Error
VMM_Service  Update_System_Clock
VMM_Service  Test_Debug_Installed
VMM_Service  Out_Debug_String
VMM_Service  Out_Debug_Chr
VMM_Service  In_Debug_Chr
VMM_Service  Debug_Convert_Hex_Binary
VMM_Service  Debug_Convert_Hex_Decimal
VMM_Service  Debug_Test_Valid_Handle
VMM_Service  Validate_Client_Ptr
VMM_Service  Test_Reenter
VMM_Service  Queue_Debug_String
VMM_Service  Log_Proc_Call
VMM_Service  Debug_Test_Cur_VM
VMM_Service  Get_PM_Int_Type
VMM_Service  Set_PM_Int_Type
VMM_Service  Get_Last_Updated_System_Time
VMM_Service  Get_Last_Updated_VM_Exec_Time
VMM_Service  Test_DBCS_Lead_Byte
.errnz  @@Test_DBCS_Lead_Byte - 100D1h

VMM_Service  _AddFreePhysPage, VMM_ICODE
VMM_Service  _PageResetHandlePAddr
VMM_Service  _SetLastV86Page, VMM_ICODE
VMM_Service  _GetLastV86Page
VMM_Service  _MapFreePhysReg
VMM_Service  _UnmapFreePhysReg
VMM_Service  _XchgFreePhysReg
VMM_Service  _SetFreePhysRegCalBk, VMM_ICODE
VMM_Service  Get_Next_Arena, VMM_ICODE
VMM_Service  Get_Name_Of_Ugly_TSR, VMM_ICODE
VMM_Service  Get_Debug_Options, VMM_ICODE
AFPP_SWAPOUT	EQU	0001H
PCP_CHANGEPAGER	EQU	1H
PCP_CHANGEPAGERDATA	EQU	2H
PCP_VIRGINONLY	EQU	4H
GNA_HIDOSLINKED	EQU	0002H
GNA_ISHIGHDOS	EQU	0004H
VMM_Service  Set_Physical_HMA_Alias, VMM_ICODE
VMM_Service  _GetGlblRng0V86IntBase, VMM_ICODE
VMM_Service  _Add_Global_V86_Data_Area, VMM_ICODE
VMM_Service  GetSetDetailedVMError
GSDVME_PRIVINST	EQU	00010001H
GSDVME_INVALINST	EQU	00010002H
GSDVME_INVALPGFLT	EQU	00010003H
GSDVME_INVALGPFLT	EQU	00010004H
GSDVME_INVALFLT	EQU	00010005H
GSDVME_USERNUKE	EQU	00010006H
GSDVME_DEVNUKE	EQU	00010007H
GSDVME_DEVNUKEHDWR	EQU	00010008H
GSDVME_NUKENOMSG	EQU	00010009H
GSDVME_OKNUKEMASK	EQU	80000000H
GSDVME_INSMEMV86	EQU	00020001H
GSDVME_INSV86SPACE	EQU	00020002H
GSDVME_INSMEMXMS	EQU	00020003H
GSDVME_INSMEMEMS	EQU	00020004H
GSDVME_INSMEMV86HI	EQU	00020005H
GSDVME_INSMEMVID	EQU	00020006H
GSDVME_INSMEMVM	EQU	00020007H
GSDVME_INSMEMDEV	EQU	00020008H
GSDVME_CRTNOMSG	EQU	00020009H
VMM_Service  Is_Debug_Chr
VMM_Service  Clear_Mono_Screen
VMM_Service  Out_Mono_Chr
VMM_Service  Out_Mono_String
VMM_Service  Set_Mono_Cur_Pos
VMM_Service  Get_Mono_Cur_Pos
VMM_Service  Get_Mono_Chr
VMM_Service  Locate_Byte_In_ROM, VMM_ICODE
VMM_Service  Hook_Invalid_Page_Fault
VMM_Service  Unhook_Invalid_Page_Fault
IPF_PGDIR	EQU	00000001H
IPF_V86PG	EQU	00000002H
IPF_V86PGH	EQU	00000004H
IPF_INVTYP	EQU	00000008H
IPF_PGERR	EQU	00000010H
IPF_REFLT	EQU	00000020H
IPF_VMM	EQU	00000040H
IPF_PM	EQU	00000080H
IPF_V86	EQU	00000100H
VMM_Service  Set_Delete_On_Exit_File
VMM_Service  Close_VM
CVF_CONTINUE_EXEC_BIT	EQU	0
CVF_CONTINUE_EXEC	EQU	(1 SHL CVF_CONTINUE_EXEC_BIT)
VMM_Service  Enable_Touch_1st_Meg
VMM_Service  Disable_Touch_1st_Meg
VMM_Service  Install_Exception_Handler
VMM_Service  Remove_Exception_Handler
VMM_Service  Get_Crit_Status_No_Block

.errnz   @@Get_Crit_Status_No_Block - 100F1h

ifdef WIN40SERVICES
VMM_Service  _GetLastUpdatedThreadExecTime
VMM_Service  _Trace_Out_Service
VMM_Service  _Debug_Out_Service
VMM_Service  _Debug_Flags_Service
endif
DFS_LOG_BIT	EQU	0
DFS_LOG	EQU	(1 SHL DFS_LOG_BIT)
DFS_PROFILE_BIT	EQU	1
DFS_PROFILE	EQU	(1 SHL DFS_PROFILE_BIT)
DFS_TEST_CLD_BIT	EQU	2
DFS_TEST_CLD	EQU	(1 SHL DFS_TEST_CLD_BIT)
DFS_NEVER_REENTER_BIT	EQU	3
DFS_NEVER_REENTER	EQU	(1 SHL DFS_NEVER_REENTER_BIT)
DFS_TEST_REENTER_BIT	EQU	4
DFS_TEST_REENTER	EQU	(1 SHL DFS_TEST_REENTER_BIT)
DFS_NOT_SWAPPING_BIT	EQU	5
DFS_NOT_SWAPPING	EQU	(1 SHL DFS_NOT_SWAPPING_BIT)
DFS_TEST_BLOCK_BIT	EQU	6
DFS_TEST_BLOCK	EQU	(1 SHL DFS_TEST_BLOCK_BIT)
DFS_RARE_SERVICES	EQU	0FFFFFF80H
DFS_EXIT_NOBLOCK	EQU	(DFS_RARE_SERVICES+0)
DFS_ENTER_NOBLOCK	EQU	(DFS_RARE_SERVICES+DFS_TEST_BLOCK)
DFS_TEST_NEST_EXEC	EQU	(DFS_RARE_SERVICES+1)
ifdef WIN40SERVICES
VMM_Service  VMMAddImportModuleName
VMM_Service  VMM_Add_DDB
VMM_Service  VMM_Remove_DDB
VMM_Service  Test_VM_Ints_Enabled
VMM_Service  _BlockOnID
VMM_Service  Schedule_Thread_Event
VMM_Service  Cancel_Thread_Event
VMM_Service  Set_Thread_Time_Out
VMM_Service  Set_Async_Time_Out
VMM_Service  _AllocateThreadDataSlot
VMM_Service  _FreeThreadDataSlot
MUTEX_MUST_COMPLETE	EQU	1
MUTEX_NO_CLEANUP_THREAD_STATE	EQU	2
VMM_Service  _CreateMutex
VMM_Service  _DestroyMutex
VMM_Service  _GetMutexOwner
VMM_Service  Call_When_Thread_Switched
VMM_Service  VMMCreateThread
VMM_Service  _GetThreadExecTime
VMM_Service  VMMTerminateThread
VMM_Service  Get_Cur_Thread_Handle
VMM_Service  Test_Cur_Thread_Handle
VMM_Service  Get_Sys_Thread_Handle
VMM_Service  Test_Sys_Thread_Handle
VMM_Service  Validate_Thread_Handle
VMM_Service  Get_Initial_Thread_Handle
VMM_Service  Test_Initial_Thread_Handle
VMM_Service  Debug_Test_Valid_Thread_Handle
VMM_Service  Debug_Test_Cur_Thread
VMM_Service  VMM_GetSystemInitState
VMM_Service  Cancel_Call_When_Thread_Switched
VMM_Service  Get_Next_Thread_Handle
VMM_Service  Adjust_Thread_Exec_Priority
VMM_Service  _Deallocate_Device_CB_Area
VMM_Service  Remove_IO_Handler
VMM_Service  Remove_Mult_IO_Handlers
VMM_Service  Unhook_V86_Int_Chain
VMM_Service  Unhook_V86_Fault
VMM_Service  Unhook_PM_Fault
VMM_Service  Unhook_VMM_Fault
VMM_Service  Unhook_Device_Service
VMM_Service  _PageReserve
VMM_Service  _PageCommit
VMM_Service  _PageDecommit
VMM_Service  _PagerRegister
VMM_Service  _PagerQuery
VMM_Service  _PagerDeregister
VMM_Service  _ContextCreate
VMM_Service  _ContextDestroy
VMM_Service  _PageAttach
VMM_Service  _PageFlush
VMM_Service  _SignalID
VMM_Service  _PageCommitPhys
VMM_Service  _Register_Win32_Services
VMM_Service  Cancel_Call_When_Not_Critical
VMM_Service  Cancel_Call_When_Idle
VMM_Service  Cancel_Call_When_Task_Switched
VMM_Service  _Debug_Printf_Service
VMM_Service  _EnterMutex
VMM_Service  _LeaveMutex
VMM_Service  Simulate_VM_IO
VMM_Service  Signal_Semaphore_No_Switch
VMM_Service  _ContextSwitch
VMM_Service  _PageModifyPermissions
VMM_Service  _PageQuery
VMM_Service  _EnterMustComplete
VMM_Service  _LeaveMustComplete
VMM_Service  _ResumeExecMustComplete
THREAD_TERM_STATUS_CRASH_PEND	EQU	1
THREAD_TERM_STATUS_NUKE_PEND	EQU	2
THREAD_TERM_STATUS_SUSPEND_PEND	EQU	4
VMM_Service  _GetThreadTerminationStatus
VMM_Service  _GetInstanceInfo
INSTINFO_NONE	EQU	0
INSTINFO_SOME	EQU	1
INSTINFO_ALL	EQU	2
VMM_Service  _ExecIntMustComplete
VMM_Service  _ExecVxDIntMustComplete
VMM_Service  Begin_V86_Serialization
VMM_Service  Unhook_V86_Page
VMM_Service  VMM_GetVxDLocationList
VMM_Service  VMM_GetDDBList
VMM_Service  Unhook_NMI_Event
VMM_Service  Get_Instanced_V86_Int_Vector
VMM_Service  Get_Set_Real_DOS_PSP
GSRDP_Set	EQU	0001H
VMM_Service  Call_Priority_Thread_Event
VMM_Service  Get_System_Time_Address
VMM_Service  Get_Crit_Status_Thread
VMM_Service  Get_DDB
VMM_Service  Directed_Sys_Control
VMM_Service  _RegOpenKey
VMM_Service  _RegCloseKey
VMM_Service  _RegCreateKey
VMM_Service  _RegDeleteKey
VMM_Service  _RegEnumKey
VMM_Service  _RegQueryValue
VMM_Service  _RegSetValue
VMM_Service  _RegDeleteValue
VMM_Service  _RegEnumValue
VMM_Service  _RegQueryValueEx
VMM_Service  _RegSetValueEx
ifndef REG_SZ
REG_SZ	EQU	0001H
REG_BINARY	EQU	0003H
endif
ifndef HKEY_LOCAL_MACHINE
HKEY_CLASSES_ROOT	EQU	80000000H
HKEY_CURRENT_USER	EQU	80000001H
HKEY_LOCAL_MACHINE	EQU	80000002H
HKEY_USERS	EQU	80000003H
HKEY_PERFORMANCE_DATA	EQU	80000004H
HKEY_CURRENT_CONFIG	EQU	80000005H
HKEY_DYN_DATA	EQU	80000006H
endif
VMM_Service  _CallRing3
VMM_Service  Exec_PM_Int
VMM_Service  _RegFlushKey
VMM_Service  _PageCommitContig
VMM_Service  _GetCurrentContext
VMM_Service  _LocalizeSprintf
VMM_Service  _LocalizeStackSprintf
VMM_Service  Call_Restricted_Event
VMM_Service  Cancel_Restricted_Event
VMM_Service  Register_PEF_Provider, VMM_ICODE
VMM_Service  _GetPhysPageInfo
VMM_Service  _RegQueryInfoKey
VMM_Service  MemArb_Reserve_Pages
PHYSINFO_NONE	EQU	0
PHYSINFO_SOME	EQU	1
PHYSINFO_ALL	EQU	2
VMM_Service  Time_Slice_Sys_VM_Idle
VMM_Service  Time_Slice_Sleep
VMM_Service  Boost_With_Decay
VMM_Service  Set_Inversion_Pri
VMM_Service  Reset_Inversion_Pri
VMM_Service  Release_Inversion_Pri
VMM_Service  Get_Thread_Win32_Pri
VMM_Service  Set_Thread_Win32_Pri
VMM_Service  Set_Thread_Static_Boost
VMM_Service  Set_VM_Static_Boost
VMM_Service  Release_Inversion_Pri_ID
VMM_Service  Attach_Thread_To_Group
VMM_Service  Detach_Thread_From_Group
VMM_Service  Set_Group_Static_Boost
VMM_Service  _GetRegistryPath, VMM_ICODE
VMM_Service  _GetRegistryKey
REGTYPE_ENUM	EQU	0
REGTYPE_CLASS	EQU	1
REGTYPE_VXD	EQU	2
REGKEY_OPEN	EQU	0
REGKEY_CREATE_IFNOTEXIST	EQU	1
ASSERT_RANGE_NULL_BAD	EQU	00000000H
ASSERT_RANGE_NULL_OK	EQU	00000001H
ASSERT_RANGE_NO_DEBUG	EQU	80000000H
ASSERT_RANGE_BITS	EQU	80000001H
VMM_Service  Cleanup_Thread_State
VMM_Service  _RegRemapPreDefKey
VMM_Service  End_V86_Serialization
VMM_Service  _Assert_Range
VMM_Service  _Sprintf
VMM_Service  _PageChangePager
VMM_Service  _RegCreateDynKey
VMM_Service  _RegQueryMultipleValues
VMM_Service  Boost_Thread_With_VM
BOOT_CLEAN	EQU	00000001H
BOOT_DOSCLEAN	EQU	00000002H
BOOT_NETCLEAN	EQU	00000004H
BOOT_INTERACTIVE	EQU	00000008H
VMM_Service  Get_Boot_Flags
VMM_Service  Set_Boot_Flags
VMM_Service  _lstrcpyn
VMM_Service  _lstrlen
VMM_Service  _lmemcpy
VMM_Service  _GetVxDName
VMM_Service  Force_Mutexes_Free
VMM_Service  Restore_Forced_Mutexes
VMM_Service  _AddReclaimableItem
VMM_Service  _SetReclaimableItem
VMM_Service  _EnumReclaimableItem
VMM_Service  Time_Slice_Wake_Sys_VM
VMM_Service  VMM_Replace_Global_Environment
VMM_Service  Begin_Non_Serial_Nest_V86_Exec
VMM_Service  Get_Nest_Exec_Status
VMM_Service  Open_Boot_Log
VMM_Service  Write_Boot_Log
VMM_Service  Close_Boot_Log
VMM_Service  EnableDisable_Boot_Log
VMM_Service  _Call_On_My_Stack
VMM_Service  Get_Inst_V86_Int_Vec_Base
VMM_Service  _lstrcmpi
VMM_Service  _strupr
VMM_Service  Log_Fault_Call_Out
VMM_Service  _AtEventTime
endif
End_Service_Table VMM, VMM
RS_RECLAIM	EQU	00000001H
RS_RESTORE	EQU	00000002H
RS_DOSARENA	EQU	00000004H

ReclaimStruc	STRUC
RS_Linear	DD	?
RS_Bytes	DD	?
RS_CallBack	DD	?
RS_RefData	DD	?
RS_HookTable	DD	?
RS_Flags	DD	?
ReclaimStruc	ENDS

frmtx	STRUC
frmtx_pfrmtxNext	DD	?
frmtx_hmutex	DD	?
frmtx_cEnterCount	DD	?
frmtx_pthcbOwner	DD	?
frmtx_htimeout	DD	?
frmtx	ENDS

vmmfrinfo	STRUC
vmmfrinfo_frmtxDOS	DB	SIZE frmtx DUP (?)
vmmfrinfo_frmtxV86	DB	SIZE frmtx DUP (?)
vmmfrinfo_frmtxOther	DB	SIZE frmtx DUP (?)
vmmfrinfo	ENDS

DemandInfoStruc	STRUC
DILin_Total_Count	DD	?
DIPhys_Count	DD	?
DIFree_Count	DD	?
DIUnlock_Count	DD	?
DILinear_Base_Addr	DD	?
DILin_Total_Free	DD	?
DIPage_Faults	DD	?
DIPage_Ins	DD	?
DIPage_Outs	DD	?
DIPage_Discards	DD	?
DIInstance_Faults	DD	?
DIPagingFileMax	DD	?
DIPagingFileInUse	DD	?
DICommit_Count	DD	?
DIReserved	DD	2 DUP (?)
DemandInfoStruc	ENDS

InstDataStruc	STRUC
InstLinkF	DD	0
InstLinkB	DD	0
InstLinAddr	DD	?
InstSize	DD	?
InstType	DD	?
InstDataStruc	ENDS
INDOS_FIELD	EQU	100H
ALWAYS_FIELD	EQU	200H
OPTIONAL_FIELD	EQU	400H

IPF_Data	STRUC
IPF_LinAddr	DD	?
IPF_MapPageNum	DD	?
IPF_PTEEntry	DD	?
IPF_FaultingVM	DD	?
IPF_Flags	DD	?
IPF_Data	ENDS

Exception_Handler_Struc	STRUC
EH_Reserved	DD	?
EH_Start_EIP	DD	?
EH_End_EIP	DD	?
EH_Handler	DD	?
Exception_Handler_Struc	ENDS
PR_PRIVATE	EQU	80000400H
PR_SHARED	EQU	80060000H
PR_SYSTEM	EQU	80080000H
PR_FIXED	EQU	00000008H
PR_4MEG	EQU	00000001H
PR_STATIC	EQU	00000010H
PD_ZEROINIT	EQU	00000001H
PD_NOINIT	EQU	00000002H
PD_FIXEDZERO	EQU	00000003H
PD_FIXED	EQU	00000004H
PC_FIXED	EQU	00000008H
PC_LOCKED	EQU	00000080H
PC_LOCKEDIFDP	EQU	00000100H
PC_WRITEABLE	EQU	00020000H
PC_USER	EQU	00040000H
PC_INCR	EQU	40000000H
PC_PRESENT	EQU	80000000H
PC_STATIC	EQU	20000000H
PC_DIRTY	EQU	08000000H
PCC_ZEROINIT	EQU	00000001H
PCC_NOLIN	EQU	10000000H
ifndef _WINNT_

_MEMORY_BASIC_INFORMATION	STRUC
mbi_BaseAddress	DD	?
mbi_AllocationBase	DD	?
mbi_AllocationProtect	DD	?
mbi_RegionSize	DD	?
mbi_State	DD	?
mbi_Protect	DD	?
mbi_Type	DD	?
_MEMORY_BASIC_INFORMATION	ENDS
PAGE_NOACCESS	EQU	01H
PAGE_READONLY	EQU	02H
PAGE_READWRITE	EQU	04H
MEM_COMMIT	EQU	1000H
MEM_RESERVE	EQU	2000H
MEM_FREE	EQU	10000H
MEM_PRIVATE	EQU	20000H
endif

pd_s	STRUC
pd_virginin	DD	?
pd_taintedin	DD	?
pd_cleanout	DD	?
pd_dirtyout	DD	?
pd_virginfree	DD	?
pd_taintedfree	DD	?
pd_dirty	DD	?
pd_type	DD	?
pd_s	ENDS
PD_SWAPPER	EQU	0
PD_PAGERONLY	EQU	1
PD_NESTEXEC	EQU	2
endif
PAGESHIFT	EQU	12
PAGESIZE	EQU	(1 SHL PAGESHIFT)
PAGEMASK	EQU	(PAGESIZE-1)
MAXSYSTEMLADDR	EQU	(0ffbfffffH)
MINSYSTEMLADDR	EQU	(0c0000000H)
MAXSHAREDLADDR	EQU	(0bfffffffH)
MINSHAREDLADDR	EQU	(80000000H)
MAXPRIVATELADDR	EQU	(7fffffffH)
MINPRIVATELADDR	EQU	(00400000H)
MAXDOSLADDR	EQU	(003fffffH)
MINDOSLADDR	EQU	(00000000H)
MAXSYSTEMPAGE	EQU	(MAXSYSTEMLADDR SHR PAGESHIFT)
MINSYSTEMPAGE	EQU	(MINSYSTEMLADDR SHR PAGESHIFT)
MAXSHAREDPAGE	EQU	(MAXSHAREDLADDR SHR PAGESHIFT)
MINSHAREDPAGE	EQU	(MINSHAREDLADDR SHR PAGESHIFT)
MAXPRIVATEPAGE	EQU	(MAXPRIVATELADDR SHR PAGESHIFT)
MINPRIVATEPAGE	EQU	(MINPRIVATELADDR SHR PAGESHIFT)
MAXDOSPAGE	EQU	(MAXDOSLADDR SHR PAGESHIFT)
MINDOSPAGE	EQU	(MINDOSLADDR SHR PAGESHIFT)
CBPRIVATE	EQU	(1+MAXPRIVATELADDR-MINPRIVATELADDR)
CBSHARED	EQU	(1+MAXSHAREDLADDR-MINSHAREDLADDR)
CBSYSTEM	EQU	(1+MAXSYSTEMLADDR-MINSYSTEMLADDR)
CBDOS	EQU	(1+MAXDOSLADDR-MINDOSLADDR)
CPGPRIVATE	EQU	(1+MAXPRIVATEPAGE-MINPRIVATEPAGE)
CPGSHARED	EQU	(1+MAXSHAREDPAGE-MINSHAREDPAGE)
CPGSYSTEM	EQU	(1+MAXSYSTEMPAGE-MINSYSTEMPAGE)
CPGDOS	EQU	(1+MAXDOSPAGE-MINDOSPAGE)
IFDEF DEBUG
DebFar  EQU NEAR PTR
ELSE
DebFar  EQU SHORT
ENDIF

ifndef Not_VxD
SYS_CRITICAL_INIT	EQU	0000H
DEVICE_INIT	EQU	0001H
INIT_COMPLETE	EQU	0002H
SYS_VM_INIT	EQU	0003H
SYS_VM_TERMINATE	EQU	0004H
SYSTEM_EXIT	EQU	0005H
SYS_CRITICAL_EXIT	EQU	0006H
CREATE_VM	EQU	0007H
VM_CRITICAL_INIT	EQU	0008H
VM_INIT	EQU	0009H
VM_TERMINATE	EQU	000AH
VM_NOT_EXECUTEABLE	EQU	000BH
DESTROY_VM	EQU	000CH
VNE_CRASHED_BIT	EQU	00H
VNE_CRASHED	EQU	(1 SHL VNE_CRASHED_BIT)
VNE_NUKED_BIT	EQU	01H
VNE_NUKED	EQU	(1 SHL VNE_NUKED_BIT)
VNE_CREATEFAIL_BIT	EQU	02H
VNE_CREATEFAIL	EQU	(1 SHL VNE_CREATEFAIL_BIT)
VNE_CRINITFAIL_BIT	EQU	03H
VNE_CRINITFAIL	EQU	(1 SHL VNE_CRINITFAIL_BIT)
VNE_INITFAIL_BIT	EQU	04H
VNE_INITFAIL	EQU	(1 SHL VNE_INITFAIL_BIT)
VNE_CLOSED_BIT	EQU	05H
VNE_CLOSED	EQU	(1 SHL VNE_CLOSED_BIT)
VM_SUSPEND	EQU	000DH
VM_RESUME	EQU	000EH
SET_DEVICE_FOCUS	EQU	000FH
BEGIN_MESSAGE_MODE	EQU	0010H
END_MESSAGE_MODE	EQU	0011H
REBOOT_PROCESSOR	EQU	0012H
QUERY_DESTROY	EQU	0013H
DEBUG_QUERY	EQU	0014H
BEGIN_PM_APP	EQU	0015H
BPA_32_BIT	EQU	01H
BPA_32_BIT_FLAG	EQU	1
END_PM_APP	EQU	0016H
DEVICE_REBOOT_NOTIFY	EQU	0017H
CRIT_REBOOT_NOTIFY	EQU	0018H
CLOSE_VM_NOTIFY	EQU	0019H
CVNF_CRIT_CLOSE_BIT	EQU	0
CVNF_CRIT_CLOSE	EQU	(1 SHL CVNF_CRIT_CLOSE_BIT)
POWER_EVENT	EQU	001AH
SYS_DYNAMIC_DEVICE_INIT	EQU	001BH
SYS_DYNAMIC_DEVICE_EXIT	EQU	001CH
CREATE_THREAD	EQU	001DH
THREAD_INIT	EQU	001EH
TERMINATE_THREAD	EQU	001FH
THREAD_Not_Executeable	EQU	0020H
DESTROY_THREAD	EQU	0021H
PNP_NEW_DEVNODE	EQU	0022H
W32_DEVICEIOCONTROL	EQU	0023H
DIOC_GETVERSION	EQU	0H
DIOC_OPEN	EQU	DIOC_GETVERSION
DIOC_CLOSEHANDLE	EQU	-1
SYS_VM_TERMINATE2	EQU	0024H
SYSTEM_EXIT2	EQU	0025H
SYS_CRITICAL_EXIT2	EQU	0026H
VM_TERMINATE2	EQU	0027H
VM_NOT_EXECUTEABLE2	EQU	0028H
DESTROY_VM2	EQU	0029H
VM_SUSPEND2	EQU	002AH
END_MESSAGE_MODE2	EQU	002BH
END_PM_APP2	EQU	002CH
DEVICE_REBOOT_NOTIFY2	EQU	002DH
CRIT_REBOOT_NOTIFY2	EQU	002EH
CLOSE_VM_NOTIFY2	EQU	002FH
GET_CONTENTION_HANDLER	EQU	0030H
KERNEL32_INITIALIZED	EQU	0031H
KERNEL32_SHUTDOWN	EQU	0032H
MAX_SYSTEM_CONTROL	EQU	0032H
BEGIN_RESERVED_PRIVATE_SYSTEM_CONTROL	EQU	70000000H
END_RESERVED_PRIVATE_SYSTEM_CONTROL	EQU	7FFFFFFFH
endif
SYSSTATE_PRESYSCRITINIT	EQU	00000000H
SYSSTATE_PREDEVICEINIT	EQU	10000000H
SYSSTATE_PREINITCOMPLETE	EQU	20000000H
SYSSTATE_VXDINITCOMPLETED	EQU	40000000H
SYSSTATE_KERNEL32INITED	EQU	50000000H
SYSSTATE_KERNEL32TERMINATED	EQU	0A0000000H
SYSSTATE_PRESYSVMTERMINATE	EQU	0B0000000H
SYSSTATE_PRESYSTEMEXIT	EQU	0E0000000H
SYSSTATE_PRESYSTEMEXIT2	EQU	0E4000000H
SYSSTATE_PRESYSCRITEXIT	EQU	0F0000000H
SYSSTATE_PRESYSCRITEXIT2	EQU	0F4000000H
SYSSTATE_POSTSYSCRITEXIT2	EQU	0FFF00000H
SYSSTATE_PREDEVICEREBOOT	EQU	0FFFF0000H
SYSSTATE_PRECRITREBOOT	EQU	0FFFFF000H
SYSSTATE_PREREBOOTCPU	EQU	0FFFFFF00H
BeginDoc











































































EndDoc












??_pf_Check equ 1
??_pf_ArgsUsed  equ 2
??_pf_Entered   equ 4
??_pf_Left  equ 8
??_pf_Returned  equ    16

??_pushed       =       0
??_align    =   0
??_ends     equ <>

BeginProc macro Name, P1, P2, P3, P4, P5, P6, P7, LastArg
    local   Profile_Data, prelabeldata, ??_hookvar
    ??_frame = 0
    ??_aframe = 0
    ??_initaframe = 0
    ??_numargs = 0
    ??_numlocals = 0
    ??_numlocalsymbols = 0
    ??_procflags = 0
    ??_esp = 0
    ??_pushed = 0
    ??_align = 0
    ??_hook = 0
    ??_hookarg = 0
    ??_service = 0
    ??_async_service = 0
IF DEBLEVEL GT DEBLEVELNORMAL
    ??_log = DFS_LOG
    ??_profile = DFS_PROFILE
    ??_test_cld = DFS_TEST_CLD
ELSE
    ??_log = 0
IFDEF DEBUG
IFDEF profileall
IF ?_ICODE
    ??_profile = DFS_PROFILE
ELSE
    ??_profile = 0
ENDIF
ELSE
    ??_profile = 0
ENDIF
ELSE
    ??_profile = 0
ENDIF
    ??_test_cld = 0
ENDIF
    ??_might_block = 0
    ??_test_reenter = 0
    ??_never_reenter = 0
    ??_not_swapping = 0
    ??_prolog_disabled = 0
    ??_public = 1
    ??_cleanoff = 0
    ??_ccall = 0
    ??_pcall = 0
    ??_scall = 0
    ??_w32svc = 0
    ??_fleave = FALSE

    ??_name equ <Name>

    .errnb ??_ends, <Cannot nest functions with named segments>
    .errnb <LastArg>, <Too many arguments to BeginProc>


    irp arg, <P1, P2, P3, P4, P5, P6, P7>
        if ??_hookarg
        ??_hookarg = 0
        ??_hookvar equ <arg>
        elseifdef ?&&arg&&_BeginProc
            ?&&arg&&_BeginProc
        elseifdef VxD_&&arg&&_CODE_SEG
        ??_ends textequ <VxD_&&arg&&_CODE_ENDS>
        VxD_&&arg&&_CODE_SEG
        else
        .err <Bad param "&arg" to BeginProc>
        endif
    endm


    ifndef Not_VxD
	ife ??_service
	    ifndef profileall
	      ??_profile = 0
	    endif
	    ifdef VMMSYS
		??_prolog_disabled = 1
	    endif
	else
	    ??_test_cld = DFS_TEST_CLD
	endif

	ife ?_16ICODE
	    ??_prolog_disabled = 1
	else
	ife ?_RCODE
	    ??_prolog_disabled = 1
	else
	    ife ?_PCODE
		??_might_block = DFS_TEST_BLOCK
	    endif
	    if ??_service
		ife ??_async_service
		    ??_test_reenter = DFS_TEST_REENTER
		endif
	    endif
    endif
    endif
    endif

    if ??_esp

	??_basereg equ <esp+??_pushed>
	??_initaframe = 4
    else

	??_basereg equ <ebp>
	??_initaframe = 8
    endif
    @Caller equ <dword ptr [??_basereg+??_initaframe-4]>

    ??_cleanoff = ??_pcall or ??_scall


    ??_dfs = ??_never_reenter + ??_test_reenter + ??_not_swapping + \
         ??_log + ??_profile + ??_test_cld + ??_might_block

    if ??_prolog_disabled
        ??_dfs = 0
    endif



    ifndef Not_VxD

	if ??_hook
	    if ??_align
	    Dword_Align
	    endif
	    prelabeldata:
	    ifndef ??_hookvar
	    .err <HOOK_PROC requires next arg to be name of dword location>
	    endif
	    jmp short Name
	    jmp [??_hookvar]
	    ifdef DEBUG
	    Profile_Data dd  0
	    endif
	    if ??_align
	    .errnz ($ - prelabeldata) mod 4
	    endif
	endif

	ifdef DEBUG
	    ?prolog_&Name label near
	    if (??_service OR ??_profile) AND (??_hook EQ 0)
	    jmp short Name
	    if ??_align
		Dword_Align
	    endif

	    IF ?_ICODE
	    ifdef profileall
	      ?ProfileHeader_BeginProc Profile_Data, %@filename
	    else
	      Profile_Data dd 0
	    endif
	    ELSE
	      Profile_Data dd 0
	    ENDIF

	    endif
	endif

	if ??_align
	    Dword_Align
	endif

    endif

    Name proc near



    ife ??_pcall or ??_ccall or ??_scall
        if ??_public
            public Name
        else
            ifdef DEBUG
                % ?merge @FileName,$,Name,:
                % ?merge public,,,,,@FileName,$,Name
            endif
        endif
    endif
    if ??_ccall
        if ??_public
            _&Name equ Name
	    ifdef Not_VxD
		 public C Name
	    else
                 public _&Name
	    endif
        endif
    endif
    if ??_pcall
        if ??_public
            ?toupper Name
            ?merge  public,,,,%?upper
        endif
    endif


    ifndef Not_VxD
	ifdef DEBUG
	    if ??_dfs EQ DFS_LOG
		VMMCall Log_Proc_Call
	    else
	    if ??_dfs EQ DFS_TEST_REENTER
		VMMCall Test_Reenter
	    else
	    if ??_dfs or ?_LOCKABLECODE eq 0
		ifdef WIN31COMPAT
		    if ??_dfs AND DFS_LOG
			VMMCall Log_Proc_Call
		    endif
		    if ??_dfs AND DFS_TEST_REENTER
			VMMCall Test_Reenter
		    endif
		else
		    ife ?_LOCKABLECODE
		    ifdef ??_debug_flags
			push    ??_debug_flags
			if ??_dfs
			pushfd
			or  dword ptr [esp+4],??_dfs
			popfd
			endif
			VMMCall _Debug_Flags_Service
		    elseif ??_dfs
			push    ??_dfs
			VMMCall _Debug_Flags_Service
		    endif
		    else
		    push    ??_dfs
		    VMMCall _Debug_Flags_Service
		    endif
		endif
	    else
	      ifdef profileall
		IncProfileCount
	      endif
	    endif
	    endif
	    endif
	endif
    endif



endm






?_BeginProc macro
endm

?PUBLIC_BeginProc macro
    ??_public = 1
endm

?LOCAL_BeginProc macro
    ??_public = 0
endm

?HIGH_FREQ_BeginProc macro
    ??_align = 1
endm

?HOOK_PROC_BeginProc macro
    ??_hook = 1
    ??_hookarg = 1
endm

?SERVICE_BeginProc macro
    ??_service = 1
    .erre ?_16ICODE, <SERVICEs must be in 32 bit code>
    .erre ?_RCODE, <SERVICEs must be in 32 bit code>
endm

?ASYNC_SERVICE_BeginProc macro
    ??_service = 1
    ??_async_service = 1
    .errnz ?_LCODE, <ASYNC_SERVICE's must be in LOCKED code>
endm

?NO_LOG_BeginProc macro
    ??_log = 0
endm

?NO_PROFILE_BeginProc macro
    ??_profile = 0
endm

?NO_TEST_CLD_BeginProc macro
    ??_test_cld = 0
endm

?TEST_BLOCK_BeginProc macro
    ??_might_block = DFS_TEST_BLOCK
endm

?TEST_REENTER_BeginProc macro
    ??_test_reenter = DFS_TEST_REENTER
endm

?NEVER_REENTER_BeginProc macro
    ??_never_reenter = DFS_NEVER_REENTER
endm

?NOT_SWAPPING_BeginProc macro
    ??_not_swapping = DFS_NOT_SWAPPING
endm

?NO_PROLOG_BeginProc macro
    ??_prolog_disabled = 1
endm

?ESP_BeginProc macro
    ??_esp = VMM_TRUE
    ifndef Not_VxD
	.erre ?_16ICODE, <Beginproc ESP attribute invalid in 16 bit seg.>
	.erre ?_RCODE, <Beginproc ESP attribute invalid in real-mode seg.>
    endif
endm

?CCALL_BeginProc macro
    ??_ccall = 1
endm

?PCALL_BeginProc macro
    ??_pcall = 1
endm

?SCALL_BeginProc macro
    ??_scall = 1
endm

?ICALL_BeginProc macro
    ??_scall = 1
endm

?W32SVC_BeginProc macro
    ??_scall = 1
    ??_w32svc = 1
endm

ifdef DEBUG
ifdef profileall
?ProfileHeader_BeginProc macro PL, filename
ifndef _&filename&__proc_list
  _&filename&__proc_list = 0
  PUBLIC _&filename&__proc_list
endif
    dd OFFSET32 _&filename&__proc_list
PL  dd 0
_&filename&__proc_list = PL
endm
endif

IncProfileCount macro
    if ??_service OR ??_profile
        inc dword ptr [??_name-4]
    else
        ifndef profileall
        .err <IncProfileCount can be used only in services.>
        endif
    endif
endm
else
IncProfileCount macro
endm
endif
















ArgVar  macro   name,length,used
    ??_numargs = ??_numargs + 1
    if ??_pcall
        ?mkarg  <name>, <length>, <used>, %??_numargs
    else
        ?argvar <name>, <length>, <used>
    endif
    ??_procflags = ??_procflags OR ??_pf_Check
    endm

?mkarg  macro   name, length, used, num
    .xcref  ?MKA&num
    ?deflocal <name>
    ?MKA&num &macro
        ?argvar <name>, <length>, <used>
        &endm
    ??_aframe = ??_aframe + 4
    endm
    .xcref  ?mkarg

?argvar macro   name,length,used
    local   a
    ifidni  <length>,<BYTE>
        a = ??_aframe
        ??_aframe =  ??_aframe + 4
        ?setname <name>, <byte ptr [??_basereg+??_initaframe+a]>, <used>
    elseifidni <length>,<WORD>
        a = ??_aframe
        ??_aframe =  ??_aframe + 4
        ?setname <name>, <word ptr [??_basereg+??_initaframe+a]>, <used>
    elseifidni <length>,<DWORD>
        a = ??_aframe
        ??_aframe =  ??_aframe + 4
        ?setname <name>,  <dword ptr [??_basereg+??_initaframe+a]>, <used>
        ?setname <name&l>,<word ptr [??_basereg+??_initaframe+a]>, <used>
        ?setname <name&ll>,<byte ptr [??_basereg+??_initaframe+a]>, <used>
        ?setname <name&lh>,<byte ptr [??_basereg+??_initaframe+a+1]>, <used>
        ?setname <name&h>,<word ptr [??_basereg+??_initaframe+a+2]>, <used>
        ?setname <name&hl>,<byte ptr [??_basereg+??_initaframe+a+2]>, <used>
        ?setname <name&hh>,<byte ptr [??_basereg+??_initaframe+a+3]>, <used>
    else
        a = ??_aframe
        ??_aframe =  ??_aframe + ((length + 3)/4)*4
        ?setname <name>, <[??_basereg+??_initaframe+a]>, <used>
    endif
endm






?setname macro name, value, used
    ?deflocal <name>
    ifidni <used>, <NOTUSED>
        name equ _inaccessible_NOTUSED_
    else
        name equ value
        ??_procflags = ??_procflags OR ??_pf_ArgsUsed OR ??_pf_Check
    endif
endm



















LocalVar    macro   name,length,flag
    local   a
    ??_numlocals = ??_numlocals + 1
    ??_pad = 1
    ifidni <flag>, <PACK>
        ??_pad = 0
    endif
    ifidni  <length>,<BYTE>
        ??_frame = ??_frame + 1 + 3 * ??_pad
        a = ??_frame
        ?deflocal <name>
        name equ byte ptr [??_basereg-a]
    elseifidni <length>,<WORD>
        ??_frame =  ??_frame + 2 + 2 * ??_pad
        a = ??_frame
        ?deflocal <name>
        name equ word ptr [??_basereg-a]
    elseifidni <length>,<DWORD>
        ??_frame = ??_frame + 4
        a = ??_frame
        ?deflocal <name, name&l, name&ll, name&lh, name&h, name&hl, name&hh>
        name equ dword ptr [??_basereg-a]
        name&l equ word ptr [??_basereg-a]
        name&ll equ byte ptr [??_basereg-a]
        name&lh equ byte ptr [??_basereg-a+1]
        name&h equ word ptr [??_basereg-a+2]
        name&hl equ byte ptr [??_basereg-a+2]
        name&hh equ byte ptr [??_basereg-a+3]
    else
        ??_frame =  ??_frame + ((length + 3)/4)*4
        a = ??_frame
        ?deflocal <name>
        name equ [??_basereg-a]
    endif
    ??_procflags = ??_procflags OR ??_pf_Check
endm

?deflocal macro name
    irp nm, <name>
        ??_numlocalsymbols = ??_numlocalsymbols + 1
        ?dodeflocal <nm>, %(??_numlocalsymbols)
    endm
endm
    .xcref  ?deflocal

?dodeflocal macro name, num
    .xcref  ?LOC&num
    ?LOC&num &macro
        name    equ <__inaccessible__NOTINSCOPE__>
        &endm
    endm
    .xcref  ?dodeflocal



EnterProc macro
    .errnz ??_frame and 3, <Total size of local variables not a multiple of 4.>
    if ??_scall
        if ??_public
	    ifdef Not_VxD
                ?merge  %??_name,@,%(??_aframe),,label,near
                ?merge  public,,,,C,%??_name,@,%(??_aframe)
	    else
                ?merge  _,%??_name,@,%(??_aframe),label,near
                ?merge  public,,,,,_,%??_name,@,%(??_aframe)
	    endif
        endif
    endif
    if ??_pcall
        ??_aframe = 0
        ?count = ??_numargs
        rept    ??_numargs
            ?invprg <?MKA>,%?count
            ?count = ?count - 1
        endm
    endif
    ??_fleave = FALSE
    if ??_esp
        if  ??_frame
            sub esp, ??_frame
            ??_pushed = ??_pushed + ??_frame
            ??_fleave = VMM_TRUE
        endif
    else
        if  ??_frame eq 0
            if (??_aframe eq 0) OR ((??_procflags AND ??_pf_ArgsUsed) EQ 0)
                ifdef DEBUG
                    push    ebp
                    mov ebp,esp
                    ??_fleave = VMM_TRUE
                endif
            else
                push    ebp
                mov ebp,esp
                ??_fleave = VMM_TRUE
            endif
        else
            enter   ??_frame, 0
            ??_fleave = VMM_TRUE
        endif
    endif
    ??_procflags = ??_procflags OR ??_pf_Entered
endm















LeaveProc macro flags
    if ??_fleave
        if ??_esp
            ifidni <flags>,<PRESERVE_FLAGS>
                lea esp,[esp + ??_frame]
            else
                add esp,??_frame
            endif
        else
            leave
        endif
    endif
    ??_procflags = ??_procflags OR ??_pf_Left
endm







Return  macro
    if  ??_cleanoff OR ??_w32svc
        if  ??_w32svc AND (??_aframe LT 8)
            ret 8
        else
            ret ??_aframe
        endif
    else
        ret
    endif
    ??_procflags = ??_procflags OR ??_pf_Returned
    endm




EndProc macro Name, Flag
    Name endp
if ??_w32svc
    if ??_aframe lt 8
        cparm&Name equ 0
    else
        cparm&Name equ (??_aframe/4 - 2)
    endif
endif
if ??_procflags AND ??_pf_Left
if ??_fleave
if ??_esp
    ??_pushed = ??_pushed - ??_frame
endif
endif
endif
ifdifi  <Flag>,<NOCHECK>
    if ??_pushed ne 0
        %out Warning: stack not balanced in Name
    endif
    if ??_procflags AND ??_pf_Check
        ife ??_procflags AND ??_pf_Entered
            %out Warning: ArgVar/LocalVar without EnterProc in Name
        endif
        ife ??_procflags AND ??_pf_Left
            %out Warning: ArgVar/LocalVar without LeaveProc in Name
        endif
        ife ??_procflags AND ??_pf_Returned
            %out Warning: ArgVar/LocalVar without Return in Name
        endif
    endif
endif
ifdifi  <Flag>,<KEEPFRAMEVARS>
    ?count = 0
    rept    ??_numlocalsymbols
        ?count = ?count + 1
        ?invprg <?LOC>,%?count
    endm
endif
    ??_ends
    ??_ends equ <>
    endm







cCall   macro   name, arglst, flags
    ife .TYPE name
       CondExtern name, near
    endif
    PushCParams <arglst>, <flags>
    call    name
    ClearCParams
    endm
    .xcref  cCall






pCall   macro   name, arglst
    local   ??saved
    ife .TYPE name
        ?toupper name
    else
        ?upper equ <name>
    endif
    CondExtern %?upper, near
    ??saved = ??_pushed
    irp x,<arglst>
        push    x
        ??_pushed = ??_pushed + 4
    endm
    call    ?upper
    ??_pushed = ??saved
    endm
    .xcref  pCall







sCall   macro   name, arglst
    local   ??saved
    ??saved = ??_pushed
    PushCParams <arglst>
    ?scall  name, %(??_argc * 4)
    ??_pushed = ??saved
    endm
    .xcref  sCall





iCall   equ <sCall>














IFNDEF  STANDARD_CCALL
NONSTANDARD_CCALL = 1
ENDIF

PushCParams macro arglst, flags
    ??_argc = 0
IFDEF   NONSTANDARD_CCALL
    ??_popargs = 0
ELSE
    ??_popargs = ??_align EQ 0
ENDIF
    ifidni  <flags>, <SMALL>
        ??_popargs = 1
    elseifidni <flags>, <FAST>
        ??_popargs = 0
    endif

    irp x,<arglst>
        ??_argc = ??_argc + 1
        ?marg   <x>,%??_argc
    endm
    ?count = ??_argc
    rept    ??_argc
        ?invprg <?AM>,%?count
        ?count = ?count - 1
    endm
    endm
















ClearCParams macro fPreserveFlags
	if	??_argc ne 0
	    if (??_popargs) AND (??_argc LE 2)
	      rept ??_argc
		pop	ecx
	      endm
	    else
	      ifidni <fPreserveFlags>, <PRESERVE_FLAGS>
		lea	esp, [esp][??_argc * 4]
	      else
		add	esp,??_argc * 4
	      endif
	    endif
	endif
	??_pushed = ??_pushed - (??_argc * 4)
	endm



?marg   macro   name, num
    .xcref
    .xcref  ?AM&num
    .cref
    ?AM&num &macro
        push    name
        ??_pushed = ??_pushed + 4
        &endm
    endm
    .xcref  ?marg



?invprg macro   name1, name2
    name1&name2
    purge   name1&name2
    endm
    .xcref  ?invprg



?scall  macro   name1, name2
    CondExtern _&name1&@&name2, near
    call    _&name1&@&name2
    endm
    .xcref  ?scall



?merge  macro   l1, l2, l3, l4, op, r1, r2, r3, r4, r5, r6, r7, r8, r9
    l1&l2&l3&l4 op r1&r2&r3&r4&r5&r6&r7&r8&r9
    endm



?toupper macro s
      ?upper equ <>
      irpc x,<s>
        if '&x' GE 'a'
          if '&x' LE 'z'
        ?t1 substr <ABCDEFGHIJKLMNOPQRSTUVWXYZ>,'&x'-'a'+1,1
        ?upper catstr ?upper,?t1
          else
        ?upper catstr ?upper,<&x>
          endif
        else
          ?upper catstr ?upper,<&x>
        endif
      endm
    endm
    .xcref






CondExtern macro name,dist
    ifdef MASM6
        ifndef name
        externdef name:dist
        endif
    else
        if2
        ifndef name
            extrn name:dist
        endif
        endif
    endif
endm



SaveReg macro   reglist
    irp reg,<reglist>
        ifidni <reg>, <fd>
            pushfd
            ??_pushed = ??_pushed + 4
        else
        ifidni <reg>, <ad>
            pushad
            ??_pushed = ??_pushed + SIZE Pushad_Struc
        else
            push    reg
            ??_pushed = ??_pushed + 4
        endif
        endif
    endm
endm







RestoreReg macro     reglist
    irp reg,<reglist>
        ifidni <reg>, <fd>
            popfd
            ??_pushed = ??_pushed - 4
        else
        ifidni <reg>, <ad>
            popad
            ??_pushed = ??_pushed - SIZE Pushad_Struc
        else
            pop reg
            ??_pushed = ??_pushed - 4
        endif
        endif
    endm
endm

ifdef DEBUG
Begin_Profile_List macro devname
ifdef profileall
VxD_DATA_SEG
    db  'PROCLIST'
PUBLIC devname&_Proc_Profile_List
devname&_Proc_Profile_List label dword
endif
endm

Profile_Link macro modname
ifdef profileall
ifdifi <modname>,@filename
EXTRN _&modname&__proc_list:near
endif
    dd  OFFSET32 _&modname&__proc_list
endif
endm

End_Profile_List macro
ifdef profileall
    dd  0
VxD_DATA_ENDS
endif
endm


endif
ifndef Not_VxD
RESERVED_LOW_BOOST	EQU	00000001H
CUR_RUN_VM_BOOST	EQU	00000004H
LOW_PRI_DEVICE_BOOST	EQU	00000010H
HIGH_PRI_DEVICE_BOOST	EQU	00001000H
CRITICAL_SECTION_BOOST	EQU	00100000H
TIME_CRITICAL_BOOST	EQU	00400000H
RESERVED_HIGH_BOOST	EQU	40000000H
PEF_WAIT_FOR_STI_BIT	EQU	0
PEF_WAIT_FOR_STI	EQU	(1 SHL PEF_WAIT_FOR_STI_BIT)
PEF_WAIT_NOT_CRIT_BIT	EQU	1
PEF_WAIT_NOT_CRIT	EQU	(1 SHL PEF_WAIT_NOT_CRIT_BIT)
PEF_DONT_UNBOOST_BIT	EQU	2
PEF_DONT_UNBOOST	EQU	(1 SHL PEF_DONT_UNBOOST_BIT)
PEF_ALWAYS_SCHED_BIT	EQU	3
PEF_ALWAYS_SCHED	EQU	(1 SHL PEF_ALWAYS_SCHED_BIT)
PEF_TIME_OUT_BIT	EQU	4
PEF_TIME_OUT	EQU	(1 SHL PEF_TIME_OUT_BIT)
PEF_WAIT_NOT_HW_INT_BIT	EQU	5
PEF_WAIT_NOT_HW_INT	EQU	(1 SHL PEF_WAIT_NOT_HW_INT_BIT)
PEF_WAIT_NOT_NESTED_EXEC_BIT	EQU	6
PEF_WAIT_NOT_NESTED_EXEC	EQU	(1 SHL PEF_WAIT_NOT_NESTED_EXEC_BIT)
PEF_WAIT_IN_PM_BIT	EQU	7
PEF_WAIT_IN_PM	EQU	(1 SHL PEF_WAIT_IN_PM_BIT)
PEF_THREAD_EVENT_BIT	EQU	8
PEF_THREAD_EVENT	EQU	(1 SHL PEF_THREAD_EVENT_BIT)
PEF_WAIT_FOR_THREAD_STI_BIT	EQU	9
PEF_WAIT_FOR_THREAD_STI	EQU	(1 SHL PEF_WAIT_FOR_THREAD_STI_BIT)
PEF_RING0_EVENT_BIT	EQU	10
PEF_RING0_EVENT	EQU	(1 SHL PEF_RING0_EVENT_BIT)
PEF_WAIT_CRIT_BIT	EQU	11
PEF_WAIT_CRIT	EQU	(1 SHL PEF_WAIT_CRIT_BIT)
PEF_WAIT_CRIT_VM_BIT	EQU	12
PEF_WAIT_CRIT_VM	EQU	(1 SHL PEF_WAIT_CRIT_VM_BIT)
PEF_PROCESS_LAST_BIT	EQU	13
PEF_PROCESS_LAST	EQU	(1 SHL PEF_PROCESS_LAST_BIT)
PEF_WAIT_NOT_TIME_CRIT_BIT	EQU	PEF_WAIT_NOT_HW_INT_BIT
PEF_WAIT_NOT_TIME_CRIT	EQU	PEF_WAIT_NOT_HW_INT
PEF_WAIT_NOT_PM_LOCKED_STACK_BIT	EQU	PEF_WAIT_NOT_NESTED_EXEC_BIT
PEF_WAIT_NOT_PM_LOCKED_STACK	EQU	PEF_WAIT_NOT_NESTED_EXEC
BLOCK_SVC_INTS_BIT	EQU	0
BLOCK_SVC_INTS	EQU	(1 SHL BLOCK_SVC_INTS_BIT)
BLOCK_SVC_IF_INTS_LOCKED_BIT	EQU	1
BLOCK_SVC_IF_INTS_LOCKED	EQU	(1 SHL BLOCK_SVC_IF_INTS_LOCKED_BIT)
BLOCK_ENABLE_INTS_BIT	EQU	2
BLOCK_ENABLE_INTS	EQU	(1 SHL BLOCK_ENABLE_INTS_BIT)
BLOCK_POLL_BIT	EQU	3
BLOCK_POLL	EQU	(1 SHL BLOCK_POLL_BIT)
BLOCK_THREAD_IDLE_BIT	EQU	4
BLOCK_THREAD_IDLE	EQU	(1 SHL BLOCK_THREAD_IDLE_BIT)
BLOCK_FORCE_SVC_INTS_BIT	EQU	5
BLOCK_FORCE_SVC_INTS	EQU	(1 SHL BLOCK_FORCE_SVC_INTS_BIT)

Client_Reg_Struc	STRUC
Client_EDI	DD	?
Client_ESI	DD	?
Client_EBP	DD	?
Client_res0	DD	?
Client_EBX	DD	?
Client_EDX	DD	?
Client_ECX	DD	?
Client_EAX	DD	?
Client_Error	DD	?
Client_EIP	DD	?
Client_CS	DW	?
Client_res1	DW	?
Client_EFlags	DD	?
Client_ESP	DD	?
Client_SS	DW	?
Client_res2	DW	?
Client_ES	DW	?
Client_res3	DW	?
Client_DS	DW	?
Client_res4	DW	?
Client_FS	DW	?
Client_res5	DW	?
Client_GS	DW	?
Client_res6	DW	?
Client_Alt_EIP	DD	?
Client_Alt_CS	DW	?
Client_res7	DW	?
Client_Alt_EFlags	DD	?
Client_Alt_ESP	DD	?
Client_Alt_SS	DW	?
Client_res8	DW	?
Client_Alt_ES	DW	?
Client_res9	DW	?
Client_Alt_DS	DW	?
Client_res10	DW	?
Client_Alt_FS	DW	?
Client_res11	DW	?
Client_Alt_GS	DW	?
Client_res12	DW	?
Client_Reg_Struc	ENDS

Client_Word_Reg_Struc	STRUC
Client_DI	DW	?
Client_res13	DW	?
Client_SI	DW	?
Client_res14	DW	?
Client_BP	DW	?
Client_res15	DW	?
Client_res16	DD	?
Client_BX	DW	?
Client_res17	DW	?
Client_DX	DW	?
Client_res18	DW	?
Client_CX	DW	?
Client_res19	DW	?
Client_AX	DW	?
Client_res20	DW	?
Client_res21	DD	?
Client_IP	DW	?
Client_res22	DW	?
Client_res23	DD	?
Client_Flags	DW	?
Client_res24	DW	?
Client_SP	DW	?
Client_res25	DW	?
Client_res26	DD	5 DUP (?)
Client_Alt_IP	DW	?
Client_res27	DW	?
Client_res28	DD	?
Client_Alt_Flags	DW	?
Client_res29	DW	?
Client_Alt_SP	DW	?
Client_Word_Reg_Struc	ENDS

Client_Byte_Reg_Struc	STRUC
Client_res30	DD	4 DUP (?)
Client_BL	DB	?
Client_BH	DB	?
Client_res31	DW	?
Client_DL	DB	?
Client_DH	DB	?
Client_res32	DW	?
Client_CL	DB	?
Client_CH	DB	?
Client_res33	DW	?
Client_AL	DB	?
Client_AH	DB	?
Client_Byte_Reg_Struc	ENDS
?UnionSize = 0
if size Client_Reg_Struc gt ?UnionSize
	?UnionSize = size Client_Reg_Struc
endif
CRS	equ	<(byte ptr 0)>

if size Client_Word_Reg_Struc gt ?UnionSize
	?UnionSize = size Client_Word_Reg_Struc
endif
CWRS	equ	<(byte ptr 0)>

if size Client_Byte_Reg_Struc gt ?UnionSize
	?UnionSize = size Client_Byte_Reg_Struc
endif
CBRS	equ	<(byte ptr 0)>


tagCLIENT_STRUC	STRUC
	DB	?UnionSize dup(?)
tagCLIENT_STRUC	ENDS

IF 0
.ERRNZ Client_SP - Client_ESP
.ERRNZ Client_AL - Client_EAX

endif
DYNA_LINK_INT	EQU	20H












DeclareNonstandardCcallService macro arglst
	irp	x,<arglst>
	    ??_nonstandardccall_&x = 1
	endm
endm







DeclareNonstandardCcallService <_BlockOnID, _LocalizeSprintf>
DeclareNonstandardCcallService <_SetLastV86Page, _Assert_Range>

BeginDoc













EndDoc


BeginDoc








EndDoc

DefTable MACRO vt, vn
    vt EQU <vn>
ENDM

GenDD2 MACRO vt, sn, jf
    dd  OFFSET32 vt[sn+jf]
ENDM

GenDD   MACRO   P, vid, snum, jflag
    LOCAL   vtable
IFDEF   @@VxDName&vid
    Deftable    vtable, %@@VxDName&vid
    EXTRN   vtable:DWORD
    GenDD2 %vtable, snum, jflag
ELSE
    dd  @@&P+jflag
ENDIF

ENDM


VxDCall MACRO P, Param, flags
    ??_vxdid = (@@&P SHR 16)
    ??_servicenum = (@@&P AND 0FFFFh)
    ifdef ??_nonstandardccall_&P
    PushCParams <Param>, <FAST>
    else
    PushCParams <Param>, <flags>
    endif
    int Dyna_Link_Int
    GenDD   P, %??_vxdid, %??_servicenum, 0
    ifdef ??_nonstandardccall_&P
	ClearCParams PRESERVE_FLAGS
    else
	ClearCParams
    endif
    ENDM

VxDJmp  MACRO P, Param
    ??_vxdid = (@@&P SHR 16)
    ??_servicenum = (@@&P AND 0FFFFh)
    .errnb <Param>, <Parameters may not be passed to VxDJmp or VMMJmp>
    int Dyna_Link_Int
    GenDD   P, %??_vxdid, %??_servicenum, DL_Jmp_Mask
    ENDM

DL_Jmp_Mask EQU 8000h
DL_Jmp_Bit  EQU 0Fh

VMMCall MACRO P, Param
    .ERRNZ (@@&P SHR 16) - VMM_DEVICE_ID
    VxDCall <P>, <Param>
    ENDM

VMMJmp MACRO P, Param
    .ERRNZ (@@&P SHR 16) - VMM_DEVICE_ID
    VxDJmp <P>, <Param>
    ENDM

BeginDoc




























EndDoc




VxD_CODE_SEG    EQU <VxD_LOCKED_CODE_SEG>
VxD_CODE_ENDS   EQU <VxD_LOCKED_CODE_ENDS>


VxD_LOCKED_CODE_SEG MACRO
_LTEXT   SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_LCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

        ENDM

VxD_LOCKED_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_LTEXT   ENDS
        ENDM




VxD_PAGEABLE_CODE_SEG MACRO
_PTEXT   SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_PCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

        ENDM

VxD_PAGEABLE_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_PTEXT   ENDS
        ENDM




VxD_DEBUG_ONLY_CODE_SEG MACRO
_DBOCODE    SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_DBOCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT
        ENDM

VxD_DEBUG_ONLY_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_DBOCODE    ENDS
        ENDM




VxD_INIT_CODE_SEG   MACRO
_ITEXT  SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_ICODE
    ASSUME  cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT
    ENDM

VxD_INIT_CODE_ENDS  MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_ITEXT  ENDS
        ENDM

VxD_ICODE_SEG equ VxD_INIT_CODE_SEG
VxD_ICODE_ENDS equ VxD_INIT_CODE_ENDS




VxD_DATA_SEG    EQU <VxD_LOCKED_DATA_SEG>
VxD_DATA_ENDS   EQU <VxD_LOCKED_DATA_ENDS>

VxD_LOCKED_DATA_SEG MACRO NO_ALIGN
_LDATA   SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
        ENDM

VxD_LOCKED_DATA_ENDS MACRO
_LDATA   ENDS
        ENDM




VxD_IDATA_SEG   MACRO
_IDATA  SEGMENT
        ENDM
VxD_IDATA_ENDS  MACRO
_IDATA  ENDS
        ENDM




VxD_PAGEABLE_DATA_SEG MACRO NO_ALIGN
_PDATA   SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
        ENDM

VxD_PAGEABLE_DATA_ENDS MACRO
_PDATA   ENDS
        ENDM




VxD_STATIC_CODE_SEG MACRO
_STEXT   SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_SCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

        ENDM

VxD_STATIC_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_STEXT   ENDS
        ENDM




VxD_STATIC_DATA_SEG MACRO NO_ALIGN
_SDATA   SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
        ENDM

VxD_STATIC_DATA_ENDS MACRO
_SDATA   ENDS
        ENDM



VxD_DEBUG_ONLY_DATA_SEG MACRO NO_ALIGN
_DBODATA    SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
        ENDM

VxD_DEBUG_ONLY_DATA_ENDS MACRO
_DBODATA    ENDS
        ENDM




VxD_16BIT_INIT_SEG  MACRO
_16ICODE SEGMENT
ASSUME CS:_16ICODE, DS:NOTHING, ES:NOTHING, SS:NOTHING
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_16ICODE
          ENDM

VxD_16BIT_INIT_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_16ICODE ENDS
           ENDM



VxD_REAL_INIT_SEG  MACRO
_RCODE SEGMENT
ASSUME CS:_RCODE, DS:_RCODE, ES:_RCODE, SS:_RCODE
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_RCODE
          ENDM

VxD_REAL_INIT_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_RCODE ENDS
           ENDM

endif
ifndef DDK_VERSION
ifdef WIN31COMPAT
DDK_VERSION	EQU	30AH
else
DDK_VERSION	EQU	400H
endif
endif

VxD_Desc_Block	STRUC
DDB_Next	DD	?
DDB_SDK_Version	DW	DDK_VERSION
DDB_Req_Device_Number	DW	UNDEFINED_DEVICE_ID
DDB_Dev_Major_Version	DB	0
DDB_Dev_Minor_Version	DB	0
DDB_Flags	DW	0
DDB_Name	DB	"        "
DDB_Init_Order	DD	UNDEFINED_INIT_ORDER
DDB_Control_Proc	DD	?
DDB_V86_API_Proc	DD	0
DDB_PM_API_Proc	DD	0
DDB_V86_API_CSIP	DD	0
DDB_PM_API_CSIP	DD	0
DDB_Reference_Data	DD	?
DDB_Service_Table_Ptr	DD	0
DDB_Service_Table_Size	DD	0
DDB_Win32_Service_Table	DD	0
DDB_Prev	DD	'Prev'
DDB_Size	DD	SIZE(VxD_Desc_Block)
DDB_Reserved1	DD	'Rsv1'
DDB_Reserved2	DD	'Rsv2'
DDB_Reserved3	DD	'Rsv3'
VxD_Desc_Block	ENDS
ifndef Not_VxD
DDB_SYS_CRIT_INIT_DONE_BIT	EQU	0
DDB_SYS_CRIT_INIT_DONE	EQU	(1 SHL DDB_SYS_CRIT_INIT_DONE_BIT)
DDB_DEVICE_INIT_DONE_BIT	EQU	1
DDB_DEVICE_INIT_DONE	EQU	(1 SHL DDB_DEVICE_INIT_DONE_BIT)
DDB_HAS_WIN32_SVCS_BIT	EQU	14
DDB_HAS_WIN32_SVCS	EQU	(1 SHL DDB_HAS_WIN32_SVCS_BIT)
DDB_DYNAMIC_VXD_BIT	EQU	15
DDB_DYNAMIC_VXD	EQU	(1 SHL DDB_DYNAMIC_VXD_BIT)
DDB_DEVICE_DYNALINKED_BIT	EQU	13
DDB_DEVICE_DYNALINKED	EQU	(1 SHL DDB_DEVICE_DYNALINKED_BIT)
BeginDoc







EndDoc
Declare_Virtual_Device MACRO Name, Major_Ver, Minor_Ver, Ctrl_Proc, Device_Num, Init_Order, V86_Proc, PM_Proc, Reference_Data
    LOCAL   V86_API_Offset, PM_API_Offset, Serv_Tab_Offset, Serv_Tab_Len, Ref_Data_Offset

dev_id_err MACRO

IFNDEF Name&_Name_Based
.err <Device ID required when providing services>
ENDIF
    ENDM

IFB <V86_Proc>
    V86_API_Offset EQU 0
ELSE
 IFB <Device_Num>
    dev_id_err
 ENDIF
    V86_API_Offset EQU <OFFSET32 V86_Proc>
ENDIF

IFB <PM_Proc>
    PM_API_Offset EQU 0
ELSE
 IFB <Device_Num>
    dev_id_err
 ENDIF
    PM_API_Offset EQU <OFFSET32 PM_Proc>
ENDIF

IFDEF Name&_Service_Table
 IFB <Device_Num>
    dev_id_err
 ELSE
  IFE Device_Num - UNDEFINED_DEVICE_ID
    dev_id_err
  ENDIF
 ENDIF
    Serv_Tab_Offset EQU <OFFSET32 Name&_Service_Table>
    Serv_Tab_Len    EQU Num_&Name&_Services
ELSE
    Serv_Tab_Offset EQU 0
    Serv_Tab_Len    EQU 0
ENDIF

IFNB    <Device_Num>
  .erre (Device_Num LT BASEID_FOR_NAMEBASEDVXD), <Device ID  must be less than BASEID_FOR_NAMEBASEDVXD>
ENDIF

IFB <Reference_Data>
        Ref_Data_Offset EQU 0
ELSE
        Ref_Data_Offset EQU   <OFFSET32 Reference_Data>
ENDIF

IFDEF DEBUG
VxD_IDATA_SEG
    db  0dh, 0ah, 'D_E_B_U_G===>'
        db      "&Name", '<===', 0dh, 0ah
VxD_IDATA_ENDS
ENDIF

VxD_LOCKED_DATA_SEG

PUBLIC Name&_DDB
Name&_DDB VxD_Desc_Block <,,Device_Num,Major_Ver,Minor_Ver,,"&Name",Init_Order,\
             OFFSET32 Ctrl_Proc, V86_API_Offset, PM_API_Offset, \
             ,,Ref_Data_Offset,Serv_Tab_Offset, Serv_Tab_Len>

VxD_LOCKED_DATA_ENDS

    ENDM





























Begin_Control_Dispatch MACRO VxD_Name, p1, p2
??_cd_low = 0FFFFFFFFh
??_cd_high = 0

BeginProc VxD_Name&_Control, p1, p2, LOCKED
ENDM

End_Control_Dispatch   MACRO VxD_Name
    LOCAL ignore, table

procoff MACRO num
IFDEF ??_cd_&&num
    dd  OFFSET32 ??_cd_&&num
ELSE
    dd  OFFSET32 ignore
ENDIF
ENDM

IF ??_cd_low EQ ??_cd_high
    cmp eax, ??_cd_low
    ?merge  <jz>,,,,,<??_cd_>, %(??_cd_low)
    clc
    ret
ELSE
IF ??_cd_low GT 0
    sub eax, ??_cd_low
ENDIF
    cmp eax, ??_cd_high - ??_cd_low + 1
    jae short ignore
    jmp [eax*4+table]
ignore:
    clc
    ret

table label dword
    REPT   ??_cd_high - ??_cd_low + 1
    procoff %(??_cd_low)
    ??_cd_low = ??_cd_low + 1
    ENDM
ENDIF

EndProc VxD_Name&_Control

PURGE procoff
PURGE Begin_Control_Dispatch
PURGE Control_Dispatch
PURGE End_Control_Dispatch
ENDM

BeginDoc




















EndDoc
Control_Dispatch MACRO Service, Procedure, callc, arglst
    LOCAL Skip_Interseg_Jump

.errnz ?_LCODE, <Control_Dispatch must be in VxD_LOCKED_CODE_SEG.>

IFB <callc>

IFDEF ??_cd_low
Equate_Service MACRO Serv
??_cd_&&Serv equ Procedure
ENDM

Equate_Service %(Service)

IF Service LT ??_cd_low
??_cd_low = Service
ENDIF
IF Service GT ??_cd_high
??_cd_high = Service
ENDIF

PURGE Equate_Service

ELSE
    cmp eax, Service
    jz  Procedure
ENDIF

ELSE

    cmp eax, Service
    jne SHORT Skip_Interseg_Jump
    callc   Procedure, <arglst>
IF Service EQ PNP_NEW_DEVNODE
    stc
ELSE
    cmp eax,1
ENDIF
    ret
Skip_Interseg_Jump:

ENDIF

    ENDM

BYTE_INPUT	EQU	000H
BYTE_OUTPUT	EQU	004H
WORD_INPUT	EQU	008H
WORD_OUTPUT	EQU	00CH
DWORD_INPUT	EQU	010H
DWORD_OUTPUT	EQU	014H
OUTPUT_BIT	EQU	2
OUTPUT	EQU	(1 SHL OUTPUT_BIT)
WORD_IO_BIT	EQU	3
WORD_IO	EQU	(1 SHL WORD_IO_BIT)
DWORD_IO_BIT	EQU	4
DWORD_IO	EQU	(1 SHL DWORD_IO_BIT)
STRING_IO_BIT	EQU	5
STRING_IO	EQU	(1 SHL STRING_IO_BIT)
REP_IO_BIT	EQU	6
REP_IO	EQU	(1 SHL REP_IO_BIT)
ADDR_32_IO_BIT	EQU	7
ADDR_32_IO	EQU	(1 SHL ADDR_32_IO_BIT)
REVERSE_IO_BIT	EQU	8
REVERSE_IO	EQU	(1 SHL REVERSE_IO_BIT)
IO_SEG_MASK	EQU	0FFFF0000H
IO_SEG_SHIFT	EQU	10H
BeginDoc






EndDoc
Dispatch_Byte_IO MACRO In_Proc, Out_Proc
    LOCAL   Byte_IO
    cmp ecx, Byte_Output
    jbe SHORT Byte_IO
    VMMJmp  Simulate_IO
Byte_IO:
IFIDNI <In_Proc>, <Fall_Through>
    je  Out_Proc
ELSE
IFIDNI <Out_Proc>, <Fall_Through>
    jb  In_Proc
ELSE
    je  Out_Proc
    jmp In_Proc
ENDIF
ENDIF
    ENDM

BeginDoc







EndDoc
Emulate_Non_Byte_IO MACRO
    LOCAL   Byte_IO
    cmp ecx, Byte_Output
    jbe SHORT Byte_IO
    VMMJmp  Simulate_IO
Byte_IO:
    ENDM

BeginDoc








EndDoc


VxD_IOT_Hdr	STRUC
VxD_IO_Ports	DW	?
VxD_IOT_Hdr	ENDS

VxD_IO_Struc	STRUC
VxD_IO_Port	DW	?
VxD_IO_Proc	DD	?
VxD_IO_Struc	ENDS
.ERRNZ SIZE VxD_IOT_Hdr - 2
Begin_VxD_IO_Table MACRO Table_Name
PUBLIC Table_Name
Table_Name LABEL WORD

ifndef MASM6
IF2
IFNDEF Table_Name&_Entries
.err <No End_VxD_IO_Table for &Table_Name>
ENDIF
    dw  Table_Name&_Entries
ELSE
    dw  ?
ENDIF
ELSE
    dw  Table_Name&_Entries
ENDIF

    ENDM

.ERRNZ SIZE VxD_IO_Struc - 6
VxD_IO MACRO Port, Proc_Name
    dw  Port
    dd  OFFSET32 Proc_Name
    ENDM

End_VxD_IO_Table MACRO Table_Name

IFNDEF Table_Name
.err <No Begin_VxD_IO_Table for &Table_Name>
ELSE
    Table_Name&_Entries EQU (($-Table_Name)-2) / (SIZE VxD_IO_Struc)
IF Table_Name&_Entries LE 0
.err <Invalid number of port traps in &Table_Name>
ENDIF
ENDIF
        ENDM













Push_Client_State MACRO Can_Trash_EDI
    sub esp, SIZE Client_Reg_Struc
    ??_pushed = ??_pushed + SIZE Client_Reg_Struc
    ifidni <Can_Trash_EDI>, <USES_EDI>
    mov edi, esp
    VMMCall Save_Client_State
    else
    push    edi
    lea edi, [esp+4]
    VMMCall Save_Client_State
    pop edi
    endif
    ENDM

Pop_Client_State MACRO Can_Trash_ESI
    ifdifi <Can_Trash_ESI>, <USES_ESI>
    push    esi
    lea esi, [esp+4]
    VMMCall Restore_Client_State
    pop esi
    else
    mov esi, esp
    VMMCall Restore_Client_State
    endif
    add esp, SIZE Client_Reg_Struc
    ??_pushed = ??_pushed - SIZE Client_Reg_Struc
    ENDM

BeginDoc














EndDoc

CallRet MACRO P1, P2
IFDEF DEBUG
IFIDNI <P1>, <SHORT>
    call    P2
ELSE
    call    P1
ENDIF
    ret
ELSE
    jmp P1 P2
ENDIF
    ENDM

BeginDoc






EndDoc

IFDEF   DEBUG

VxDCallRet macro p:req
    VxDCall p
    ret
endm

VMMCallRet macro p:req
    VMMCall p
    ret
endm

ELSE

VxDCallRet equ <VxDJmp>
VMMCallRet equ <VMMJmp>

ENDIF



PClient_DS equ WORD PTR -4
PClient_ES equ WORD PTR -8
PClient_FS equ WORD PTR -12
PClient_GS equ WORD PTR -16











Client_Ptr_Flat MACRO Reg_32, Cli_Seg, Cli_Off, Can_Trash_EAX

IFDIFI <Reg_32>, <EAX>
    IFDIFI <Can_Trash_EAX>, <USES_EAX>
    xchg    Reg_32, eax
    ENDIF
ENDIF
IFB <Cli_Off>
    mov ax, (Client_&Cli_Seg * 100h) + 0FFh
ELSE
    mov ax, (Client_&Cli_Seg * 100h) + Client_&Cli_Off
ENDIF
    VMMCall Map_Flat

IFDIFI <Reg_32>, <EAX>
    xchg    Reg_32, eax
ENDIF

    ENDM



VxDint  MACRO   Int_Number
    if  (OPATTR Int_Number) AND 4
    push    Int_Number
    else
    push    DWORD PTR Int_Number
    endif
    VMMCall Exec_VxD_Int
    ENDM

VxDintMustComplete MACRO   Int_Number
    if  (OPATTR Int_Number) AND 4
    push    Int_Number
    else
    push    DWORD PTR Int_Number
    endif
        VMMCall _ExecVxDIntMustComplete
    ENDM



endif
DUPLICATE_DEVICE_ID_BIT	EQU	0
DUPLICATE_DEVICE_ID	EQU	(1 SHL DUPLICATE_DEVICE_ID_BIT)
DUPLICATE_FROM_INT2F_BIT	EQU	1
DUPLICATE_FROM_INT2F	EQU	(1 SHL DUPLICATE_FROM_INT2F_BIT)
LOADING_FROM_INT2F_BIT	EQU	2
LOADING_FROM_INT2F	EQU	(1 SHL LOADING_FROM_INT2F_BIT)
DEVICE_LOAD_OK	EQU	0
ABORT_DEVICE_LOAD	EQU	1
ABORT_WIN386_LOAD	EQU	2
NO_FAIL_MESSAGE_BIT	EQU	15
NO_FAIL_MESSAGE	EQU	(1 SHL NO_FAIL_MESSAGE_BIT)
LDRSRV_GET_PROFILE_STRING	EQU	0
LDRSRV_GET_NEXT_PROFILE_STRING	EQU	1
LDRSRV_RESERVED	EQU	2
LDRSRV_GET_PROFILE_BOOLEAN	EQU	3
LDRSRV_GET_PROFILE_DECIMAL_INT	EQU	4
LDRSRV_GET_PROFILE_HEX_INT	EQU	5
LDRSRV_COPY_EXTENDED_MEMORY	EQU	6
LDRSRV_GET_MEMORY_INFO	EQU	7
LDRSRV_RegOpenKey	EQU	100H
LDRSRV_RegCreateKey	EQU	101H
LDRSRV_RegCloseKey	EQU	102H
LDRSRV_RegDeleteKey	EQU	103H
LDRSRV_RegSetValue	EQU	104H
LDRSRV_RegQueryValue	EQU	105H
LDRSRV_RegEnumKey	EQU	106H
LDRSRV_RegDeleteValue	EQU	107H
LDRSRV_RegEnumValue	EQU	108H
LDRSRV_RegQueryValueEx	EQU	109H
LDRSRV_RegSetValueEx	EQU	10AH
LDRSRV_RegFlushKey	EQU	10BH
LDRSRV_COPY_INIT	EQU	1
LDRSRV_COPY_LOCKED	EQU	2
LDRSRV_COPY_PAGEABLE	EQU	3
RCODE_OBJ	EQU	-1
LCODE_OBJ	EQU	01H
LDATA_OBJ	EQU	02H
PCODE_OBJ	EQU	03H
PDATA_OBJ	EQU	04H
SCODE_OBJ	EQU	05H
SDATA_OBJ	EQU	06H
CODE16_OBJ	EQU	07H
LMSG_OBJ	EQU	08H
PMSG_OBJ	EQU	09H
DBOC_OBJ	EQU	0BH
DBOD_OBJ	EQU	0CH
ICODE_OBJ	EQU	11H
IDATA_OBJ	EQU	12H
ICODE16_OBJ	EQU	13H
IMSG_OBJ	EQU	14H

ObjectLocation	STRUC
OL_LinearAddr	DD	?
OL_Size	DD	?
OL_ObjType	DB	?
ObjectLocation	ENDS
MAXOBJECTS	EQU	25

Device_Location_List	STRUC
DLL_DDB	DD	?
DLL_NumObjects	DB	?
DLL_ObjLocation	DB	SIZE ObjectLocation * 1 DUP (?)
Device_Location_List	ENDS
PE_BIT	EQU	0
PE_MASK	EQU	(1 SHL PE_BIT)
MP_BIT	EQU	1
MP_MASK	EQU	(1 SHL MP_BIT)
EM_BIT	EQU	2
EM_MASK	EQU	(1 SHL EM_BIT)
TS_BIT	EQU	3
TS_MASK	EQU	(1 SHL TS_BIT)
ET_BIT	EQU	4
ET_MASK	EQU	(1 SHL ET_BIT)
PG_BIT	EQU	31
PG_MASK	EQU	(1 SHL PG_BIT)
CF_BIT	EQU	0
CF_MASK	EQU	(1 SHL CF_BIT)
PF_BIT	EQU	2
PF_MASK	EQU	(1 SHL PF_BIT)
AF_BIT	EQU	4
AF_MASK	EQU	(1 SHL AF_BIT)
ZF_BIT	EQU	6
ZF_MASK	EQU	(1 SHL ZF_BIT)
SF_BIT	EQU	7
SF_MASK	EQU	(1 SHL SF_BIT)
TF_BIT	EQU	8
TF_MASK	EQU	(1 SHL TF_BIT)
IF_BIT	EQU	9
IF_MASK	EQU	(1 SHL IF_BIT)
DF_BIT	EQU	10
DF_MASK	EQU	(1 SHL DF_BIT)
OF_BIT	EQU	11
OF_MASK	EQU	(1 SHL OF_BIT)
IOPL_MASK	EQU	3000H
IOPL_BIT0	EQU	12
IOPL_BIT1	EQU	13
NT_BIT	EQU	14
NT_MASK	EQU	(1 SHL NT_BIT)
RF_BIT	EQU	16
RF_MASK	EQU	(1 SHL RF_BIT)
VM_BIT	EQU	17
VM_MASK	EQU	(1 SHL VM_BIT)
AC_BIT	EQU	18
AC_MASK	EQU	(1 SHL AC_BIT)
VIF_BIT	EQU	19
VIF_MASK	EQU	(1 SHL VIF_BIT)
VIP_BIT	EQU	20
VIP_MASK	EQU	(1 SHL VIP_BIT)






IFDEF MASM6
loopde EQU <looped>
loopdne EQU <loopned>
loopdz EQU <loopzd>
loopdnz EQU <loopnzd>
ELSE
loopd EQU <loop>
loopde EQU <loope>
loopdne EQU <loopne>
loopdz EQU <loopz>
loopdnz EQU <loopnz>
ENDIF

P_SIZE	EQU	1000H
P_PRESBIT	EQU	0
P_PRES	EQU	(1 SHL P_PRESBIT)
P_WRITEBIT	EQU	1
P_WRITE	EQU	(1 SHL P_WRITEBIT)
P_USERBIT	EQU	2
P_USER	EQU	(1 SHL P_USERBIT)
P_ACCBIT	EQU	5
P_ACC	EQU	(1 SHL P_ACCBIT)
P_DIRTYBIT	EQU	6
P_DIRTY	EQU	(1 SHL P_DIRTYBIT)
P_AVAIL	EQU	(P_PRES+P_WRITE+P_USER)
PG_VM	EQU	0
PG_SYS	EQU	1
PG_RESERVED1	EQU	2
PG_PRIVATE	EQU	3
PG_RESERVED2	EQU	4
PG_RELOCK	EQU	5
PG_INSTANCE	EQU	6
PG_HOOKED	EQU	7
PG_IGNORE	EQU	0FFFFFFFFH
D_PRES	EQU	080H
D_NOTPRES	EQU	0
D_DPL0	EQU	0
D_DPL1	EQU	020H
D_DPL2	EQU	040H
D_DPL3	EQU	060H
D_SEG	EQU	010H
D_CTRL	EQU	0
D_GRAN_BYTE	EQU	000H
D_GRAN_PAGE	EQU	080H
D_DEF16	EQU	000H
D_DEF32	EQU	040H
D_CODE	EQU	08H
D_DATA	EQU	0
D_X	EQU	0
D_RX	EQU	02H
D_C	EQU	04H
D_R	EQU	0
D_W	EQU	02H
D_ED	EQU	04H
D_ACCESSED	EQU	1
RW_DATA_TYPE	EQU	(D_PRES+D_SEG+D_DATA+D_W)
R_DATA_TYPE	EQU	(D_PRES+D_SEG+D_DATA+D_R)
CODE_TYPE	EQU	(D_PRES+D_SEG+D_CODE+D_RX)
D_PAGE32	EQU	(D_GRAN_PAGE+D_DEF32)
SELECTOR_MASK	EQU	0FFF8H
SEL_LOW_MASK	EQU	0F8H
TABLE_MASK	EQU	04H
RPL_MASK	EQU	03H
RPL_CLR	EQU	(NOT RPL_MASK)
IVT_ROM_DATA_SIZE	EQU	500H
endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\vmm2.h ===
//
// VMM2.H
// VMM Call Macros and function prototypes for functions not defined in VMM.H
// (C) Copyright NVIDIA Corporation Inc., 1995,1996. All rights reserved.


//
//	Function Prototypes
//
VOID vmmOutDebugString(char *);

VOID vmmOutDebugStringValue(char *, U032);	

VOID	dbgBreakPoint();

U032 vmmAllocateGDTSelector(U032, U032, U032);

U032 vmmAllocateLDTSelector(U032, U032, U032, U032, U032);

VOID vmmBuildDescriptorDWORDs(U032, U032, U032, U032, U032, QUADWORD*);

U032 vmmFreeLDTSelector(U032, U032, U032);

U032 vmmGetSystemTime();

U032 vmmCallPriorityVMEvent(U032, U032, U032, U032, U032, U032);

VOID vmmSimulatePush(U032);

VOID vmmSimulateFarCall(U032, U032);

VOID vmmGetDescriptor(U032, U032, U032, QUADWORD *);

U032 vmmPageCheckLinRange(U032, U032, U032);

U032 vmmLinPageLock(U032, U032, U032);    

U032 vmmLinPageUnLock(U032, U032, U032);

VOID vmmPageAllocate(U032, U032, U032, U032, U032, U032, U032, U032, QUADWORD *);

U032 vmmPageReserve(U032, U032, U032);

U032 vmmPageCommitPhys(U032, U032, U032, U032);

U032 vmmPageDecommit(U032, U032, U032);

VOID vmmPageGetSizeAddr(U032, U032, QUADWORD *);

U032 vmmPageLock(U032, U032, U032, U032);

U032 vmmPageUnLock(U032, U032, U032, U032);

U032 vmmPageFree(U032, U032);

U032 vmmSetDescriptor(U032, U032, U032, U032, U032);

U032 vmmSelectorMapFlat(U032, U032, U032);

U032 vmmGetSysVMHandle(VOID);

U032 vmmGetCritSectionStatus(VOID);

U032 vmmCopyPageTable(U032, U032, U032, U032);

U032 vmmMapPhysToLinear(U032, U032, U032);

U032 vmmGetCurrentContext(VOID);

U032 vmmContextSwitch(U032);

U032 vmmGetProfileHexInt(U032, char *, char *);

U032 vmmGetProfileDecimalInt(U032, char *, char *);

U032 vmmGetSysVMHandle(VOID);

VOID vmmFatalErrorHandler(U032, U032);

VOID vmmCallBackExit(U032);

VOID vmmCallBackEntry(VOID);

VOID vmmRestoreClientState(CRS *);

VOID vmmSaveClientState(CRS *);	

U032 vmmCreateSemaphore(U032);

U032 vmmWaitSemaphore(U032, U032);	

U032 vmmSignalSemaphore(U032);

U032 picGetIRQVirtualizedStatus(U032, U032);

U032 mtrrGetVersion(VOID);

U032 mtrrSetPhysicalCacheTypeRange(U032, U032, U032, U032);

U016 vddGetVersion(VOID);

U032 vddGetDisplayInfo(U032, PDISPLAYINFO, U032);


// This is just like the macro VMMCall in VMM.H, except it doesn't use the GetVxDServiceOrdinal macro, which gets the 
// service number from the service table, which is generated on the fly. We would have to alter the service table macro
// to add more services for that to work.
// the "service" upper word is the device, the lower word is the service
#define CALL_VMM(service) \
    _asm _emit 0xcd \
    _asm _emit 0x20 \
    _asm _emit (service & 0xff) \
    _asm _emit (service >> 8) & 0xff \
    _asm _emit (service >> 16) & 0xff \
    _asm _emit (service >> 24) & 0xff 

#define VDD_Device_ID          0x0000A
//	Macro for VDD services. Just like CALL_VMM above, except substitue the VDD device number
#define CALL_VDD(service) \
    _asm _emit 0xcd \
    _asm _emit 0x20 \
    _asm _emit (service & 0xff) \
    _asm _emit (service >> 8) & 0xff \
    _asm _emit (VDD_Device_ID) & 0xff \
    _asm _emit (VDD_Device_ID >> 8) & 0xff 


//	Defines for service numbers. These are services that Microsoft hasn't bothered to define a C-callable service table for.
#define Get_Sys_VM_Handle                   0x00010003
#define Call_Priority_VM_Event              0x00010014
#define Create_Semaphore                    0x00010025
#define Wait_Semaphore                      0x00010027
#define Signal_Semaphore                    0x00010028
#define Get_Crit_Section_Status             0x00010029
#define Get_System_Time                     0x0001003f
#define Simulate_Far_Call                   0x00010048
#define Simulate_Push                       0x0001004d
#define Simulate_Pop                        0x0001004e
#define _PageFree                           0x00010055
#define _PageLock                           0x00010056
#define _PageUnLock                         0x00010057
#define _PageGetSizeAddr                    0x00010058
#define _PageAllocate                       0x00010053
#define _CopyPageTable                      0x00010061
#define _LinPageLock                        0x00010063
#define _LinPageUnLock                      0x00010064
#define _PageCheckLinRange                  0x00010067
#define _MapPhysToLinear                    0x0001006c
#define _SelectorMapFlat                    0x0001006e
#define Allocate_GDT_Selector              0x00010076
#define Allocate_LDT_Selector              0x00010078
#define Free_LDT_Selector                  0x00010079
#define BuildDescriptorDWORDs              0x0001007a
#define _GetDescriptor                      0x0001007b
#define _SetDescriptor                      0x0001007c
#define End_Nest_Exec                       0x00010086
#define Save_Client_State                   0x0001008d
#define Restore_Client_State                0x0001008e
#define Fatal_Error_Handler                 0x000100be
#define Begin_Nest_Exec                     0x00010083
#define Resume_Exec                         0x00010085
#define Get_Profile_Decimal_Int             0x000100ab
#define Get_Profile_Hex_Int                 0x000100af
#define Test_Debug_Installed                0x000100c1
#define Out_Debug_String                    0x000100c2
#define _CreateMutex                        0x00010101
#define _DestroyMutex                       0x00010102
#define _PageReserve                        0x0001011d
#define _PageDecommit                       0x0001011f
#define _PageCommitPhys                     0x00010128
#define _EnterMutex                         0x0001012e
#define _LeaveMutex                         0x0001012f
#define _ContextSwitch                      0x00010132
#define _RegOpenKey                         0x00010148
#define _RegCloseKey                        0x00010149
#define _RegQueryValue                      0x0001014d
#define _GetCurrentContext                  0x00010157
#define _MTRR_Get_Version                   0x004A0000
#define _MTRRSetPhysicalCacheTypeRange      0x004A0001
#define Time_Slice_Sleep                    0x00010161
#define _GARTReserve                        0x000101AE
#define _GARTCommit                         0x000101AF
#define _GARTUncommit                       0x000101B0
#define _GARTFree                           0x000101B1
#define _GARTMemAttributes                  0x000101B2

// VDD services. (doesn't include device number)
#define VDD_Get_Version                     0x0000  // Get version number and ID string ptr
#define VDD_Get_DISPLAYINFO                 0x0014  //get DISPLAYINFO data structure


#define	PG_UNCACHED		    0x00000001		// Uncached memory
#define	PG_WRITECOMBINED	0x00000002		// Write combined memory
            
U032 vmmGARTReserve(U032, U032, U032, U032, U032);
U032 vmmGARTCommit(U032, U032, U032, U032, U032);
U032 vmmGARTUnCommit(U032, U032, U032);
U032 vmmGARTFree(U032);
U032 vmmGARTMemAttributes(U032, U032);

//	VMM Call Macros (inline functions)

#define vmmSimulatePop() CALL_VMM(Simulate_Pop)   

#define vmmBeginNestExecution() CALL_VMM(Begin_Nest_Exec);

#define vmmResumeExec() CALL_VMM(Resume_Exec);

#define vmmEndNestExecution() CALL_VMM(End_Nest_Exec);

#define osSwapStack(newStack, oldStack)	\
	_asm	mov		eax, newStack		\
	_asm	xchg	eax, esp			\
    _asm	mov		oldStack, eax
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\VMMTYPES.H ===
/*************************************************************************************
*
*	File: vmmtypes.h
*
*	Revision History:
*		Jeff Westerinen (jsw) - 05/97
*			- Changed QWORD to QUADWORD due to conflict with typedef in basedef.h
*
*************************************************************************************/

#ifndef _VMMTYPES_H_
#define _VMMTYPES_H_

#ifndef NULL
#define NULL               0
#endif
#ifndef VOID
#define VOID               void
#endif
#ifndef PASCAL
#define PASCAL             _pascal
#endif
#ifndef CDECL
#define CDECL              _cdecl
#endif

#ifndef BOOL
#define BOOL                unsigned long
#endif
#ifndef FALSE
#define FALSE              0
#endif
#ifndef TRUE
#define TRUE               (~FALSE)
#endif

#ifndef LONG
#define LONG               long
#endif
typedef unsigned char      BYTE;
typedef unsigned short     WORD;
typedef unsigned long      DWORD;
typedef double             QUADWORD;
typedef unsigned int       UINT;
typedef char *             PSTR;
typedef BYTE *             PBYTE;
typedef int *              PINT;
typedef UINT *             PUINT;
typedef WORD *             PWORD;
typedef DWORD *            PDWORD;
typedef QUADWORD *         PQWORD;

typedef union
{
    QUADWORD Desc64;
    DWORD Desc32[2];
    WORD  Desc16[4];
    BYTE  Desc8[8];
} DESCRIPTOR, *PDESCRIPTOR;

typedef union
{
    QUADWORD HandleAddress;
    struct
    {
        DWORD Handle;
        DWORD Address;
    } ha;
} PAGEALLOC, *PPAGEALLOC;

#ifndef LOBYTE
#define LOBYTE(w)          ((BYTE)(w))
#endif
#ifndef HIBYTE
#define HIBYTE(w)          ((BYTE)(((UINT)(w) >> 8) & 0xFF))
#endif
#ifndef LOWORD
#define LOWORD(l)          ((WORD)(DWORD)(l))
#endif
#ifndef HIWORD
#define HIWORD(l)          ((WORD)((((DWORD)(l)) >> 16) & 0xFFFF))
#endif
#ifndef MAKELONG
#define MAKELONG(low, high) ((LONG)(((WORD)(low)) | (((DWORD)((WORD)(high))) << 16)))
#endif

#endif // _VMMTYPES_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\VMMREG.INC ===
;****************************************************************************
;                                                                           *
; THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
; KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
; IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
; PURPOSE.                                                                  *
;                                                                           *
; Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
;                                                                           *
;****************************************************************************

ifndef	_VMMREG_H
_VMMREG_H	EQU	1
MAX_VMM_REG_KEY_LEN	EQU	256
ifndef REG_SZ
REG_SZ	EQU	0001H
REG_BINARY	EQU	0003H
endif
ifndef HKEY_LOCAL_MACHINE
HKEY_CLASSES_ROOT	EQU	80000000H
HKEY_CURRENT_USER	EQU	80000001H
HKEY_LOCAL_MACHINE	EQU	80000002H
HKEY_USERS	EQU	80000003H
HKEY_PERFORMANCE_DATA	EQU	80000004H
HKEY_CURRENT_CONFIG	EQU	80000005H
HKEY_DYN_DATA	EQU	80000006H
endif
ifndef ERROR_FILE_NOT_FOUND
ERROR_FILE_NOT_FOUND	EQU	2
endif
ifndef ERROR_BADDB
ERROR_BADDB	EQU	1009
endif
ifndef ERROR_MORE_DATA
ERROR_MORE_DATA	EQU	234
endif
ifndef ERROR_BADKEY
ERROR_BADKEY	EQU	1010
endif
ifndef ERROR_CANTOPEN
ERROR_CANTOPEN	EQU	1011
endif
ifndef ERROR_CANTREAD
ERROR_CANTREAD	EQU	1012
ERROR_CANTWRITE	EQU	1013
endif
ifndef ERROR_REGISTRY_CORRUPT
ERROR_REGISTRY_CORRUPT	EQU	1015
ERROR_REGISTRY_IO_FAILED	EQU	1016
endif
ifndef ERROR_KEY_DELETED
ERROR_KEY_DELETED	EQU	1018
endif
ifndef ERROR_OUTOFMEMORY
ERROR_OUTOFMEMORY	EQU	14
endif
ifndef ERROR_INVALID_PARAMETER
ERROR_INVALID_PARAMETER	EQU	87
endif
ifndef ERROR_LOCK_FAILED
ERROR_LOCK_FAILED	EQU	167
endif
ifndef ERROR_NO_MORE_ITEMS
ERROR_NO_MORE_ITEMS	EQU	259
endif
ifndef  ERROR_SUCCESS
ERROR_SUCCESS	EQU	0
endif




LDR_RegOpenKey	Macro	hKey,OffSubKey,SegSubKey,OffphKey,SegphKey
	push	SegphKey
	push	OffphKey
	push	SegSubKey
	push	OffSubKey
	push	dword ptr hKey
	mov	ax,LDRSRV_RegOpenKey
	call	dword ptr [_ServiceEntry]
	add	sp,3*4
ENDM

LDR_RegCloseKey	Macro	hKey
	push	dword ptr hKey
	mov	ax,LDRSRV_RegCloseKey
	call	dword ptr [_ServiceEntry]
	add	sp,1*4
ENDM

LDR_RegCreateKey	Macro	hKey,OffSubKey,SegSubKey,OffphKey,SegphKey
	push	SegphKey
	push	OffphKey
	push	SegSubKey
	push	OffSubKey
	push	dword ptr hKey
	mov	ax,LDRSRV_RegCreateKey
	call	dword ptr [_ServiceEntry]
	add	sp,3*4
ENDM

LDR_RegDeleteKey	Macro	hKey,OffSubKey,SegSubKey
	push	SegSubKey
	push	OffSubKey
	push	dword ptr hKey
	mov	ax,LDRSRV_RegDeleteKey
	call	dword ptr [_ServiceEntry]
	add	sp,2*4
ENDM

LDR_RegEnumKey	Macro	hKey,iSubKey,OffszName,SegszName,BufLen
	push	dword ptr BufLen
	push	SegszName
	push	OffszName
	push	dword ptr iSubKey
	push	dword ptr hKey
	mov	ax,LDRSRV_RegEnumKey
	call	dword ptr [_ServiceEntry]
	add	sp,4*4
ENDM

LDR_RegQueryValue	Macro	hKey,OffSubKey,SegSubKey,OffValue,SegValue,OffcbValue,SegcbValue
	push	SegcbValue
	push	OffcbValue
	push	SegValue
	push	OffValue
	push	SegSubKey
	push	OffSubKey
	push	dword ptr hKey
	mov	ax,LDRSRV_RegQueryValue
	call	dword ptr [_ServiceEntry]
	add	sp,4*4
ENDM

LDR_RegSetValue	Macro	hKey,OffSubKey,SegSubKey,dwType,OffData,SegData,cbData
	push	dword ptr cbData
	push	SegData
	push	OffData
	push	dword ptr dwType
	push	SegSubKey
	push	OffSubKey
	push	dword ptr hKey
	mov	ax,LDRSRV_RegSetValue
	call	dword ptr [_ServiceEntry]
	add	sp,5*4
ENDM

LDR_RegDeleteValue	Macro	hKey,OffValue,SegValue
	push	SegValue
	push	OffValue
	push	dword ptr hKey
	mov	ax,LDRSRV_RegDeleteValue
	call	dword ptr [_ServiceEntry]
	add	sp,2*4
ENDM

LDR_RegEnumValue	Macro hKey,iValue,OffValue,SegValue,OffcbValue,SegcbValue,RegReserved,OffdwType,SegdwType,OffData,SegData,Offc
bData,SegcbData
	push	SegcbData
	push	OffcbData
	push	SegData
	push	OffData
	push	SegdwType
	push	OffdwType
	push	dword ptr RegReserved
	push	SegcbValue
	push	OffcbValue
	push	SegValue
	push	OffValue
	push	dword ptr iValue
	push	dword ptr hKey
	mov	ax,LDRSRV_RegEnumValue
	call	dword ptr [_ServiceEntry]
	add	sp,8*4
ENDM

LDR_RegQueryValueEx	Macro	hKey,OffValue,SegValue,RegReserved,OffdwType,SegdwType,OffData,SegData,OffcbData,SegcbData
	push	SegcbData
	push	OffcbData
	push	SegData
	push	OffData
	push	SegdwType
	push	OffdwType
	push	dword ptr RegReserved
	push	SegValue
	push	OffValue
	push	dword ptr hKey
	mov	ax,LDRSRV_RegQueryValueEx
	call	dword ptr [_ServiceEntry]
	add	sp,6*4
ENDM

LDR_RegSetValueEx	Macro	hKey,OffValue,SegValue,RegReserved,dwType,OffData,SegData,cbData
	push	dword ptr cbData
	push	SegData
	push	OffData
	push	dword ptr dwType
	push	dword ptr RegReserved
	push	SegValue
	push	OffValue
	push	dword ptr hKey
	mov	ax,LDRSRV_RegSetValueEx
	call	dword ptr [_ServiceEntry]
	add	sp,6*4
ENDM

LDR_RegFlushKey		Macro	hKey
	push	dword ptr hKey
	mov	ax,LDRSRV_RegFlushKey
	call	dword ptr [_ServiceEntry]
	add	sp,1*4
ENDM


endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\VPAGED.H ===
#ifndef _VPAGED_H_
#define _VPAGED_H_
/******** Operating System Interface for NVidia Hardware Simulator  ********\
*                                                                           *
* Module: VPAGED.H                                                          *
*       Header file for Virtual Paging device.                              *
*                                                                           *
*---------------------------------------------------------------------------*
*                                                                           *
* History:                                                                  *
*        David Schmenk (dschmenk)     05/08/95 - wrote it                   *
*                                                                           *
\*********************** Copyright 1994 NVidia, Inc. ***********************/

//---------------------------------------------------------------------------
//
//  Defines.
//
//---------------------------------------------------------------------------

#define PageSwap_Get_Version    0x0000
#define PageSwap_Test_Create    0x0001
#define PageSwap_Create         0x0002
#define PageSwap_Destroy        0x0003
#define PageSwap_In             0x0004
#define PageSwap_Out            0x0005
#define PageSwap_Test_IO_Valid  0x0006
#define PS_Zero_Init_Mask       0x0001
#define PS_Zero_Init_Bit        0x0000
#define PS_Fixed_Page_Mask      0x0008
#define PS_Fixed_Page_Bit       0x0003
#define PS_First_Page_In_Mask   0x0020
#define PS_First_Page_In_Bit    0x0005
#define PS_Dirty_Mask           0x0040
#define PS_Dirty_Bit            0x0006
#define PS_Ever_Dirty_Mask      0x8000
#define PS_Ever_Dirty_Bit       0x000F
#define PS_NoXchg_Mask          0x80000000
#define PS_NoXchg_Bit           0x001F     // DO NOT xchg phys addrs on PageSwap_Out
#define PS_No_Pager             0x01
#define PS_MSDOS_Pager          0x02
#define PS_HW_Pager             0x03
//
// Buffer descriptor for asynchronous I/O
//
#define SIZE_PS_BD_RESERVED     44
struct PageSwapBufferDesc
{
    DWORD PS_BD_Next;
    WORD  PS_BD_List;
    BYTE  PS_BD_Cmd;
    BYTE  PS_BD_Priority;
    DWORD PS_BD_Page_Number;
    DWORD PS_BD_Buffer_Ptr;
    DWORD PS_BD_File_Page;
    DWORD PS_BD_Call_Back;
    BYTE PS_BD_Reserved[SIZE_PS_BD_RESERVED];
};
//
// List values for PS_BD_List
//
#define PS_BDL_Free         1
#define PS_BDL_Pending_WB   2
#define PS_BDL_Submitted_RA 3
#define PS_BDL_Locked       4
#define PS_BDP_Invalid_Data -1
//
// VPAGED callback routines.
//
#pragma aux VPAGED_INT  modify [EAX EBX ECX EDX];
//
// Make functions to these services.
//
DWORD pagerGetVersion(VOID);
BYTE  pagerGetAccessType(VOID);

#pragma aux pagerGetVersion =                                   \
            CALL_VXD(PageSwap_Device_ID, PageSwap_Get_Version)  \
            value [EAX];

#pragma aux pagerGetAccessType =                                \
            CALL_VXD(PageSwap_Device_ID, PageSwap_Get_Version)  \
            value [BL];
#endif // _VPAGED_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\VMMREG.H ===
/****************************************************************************
*                                                                           *
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
* KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
* IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
* PURPOSE.                                                                  *
*                                                                           *
* Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
*                                                                           *
****************************************************************************/

/*****************************************************************************
 *
 *   Title:	VMMREG.H - Include file for VMM/Loader Registry Services
 *
 *   Version:	1.00
 *
 ******************************************************************************
 */

#ifndef	_VMMREG_H
#define _VMMREG_H

typedef DWORD	VMMHKEY;
typedef	VMMHKEY	*PVMMHKEY;
typedef DWORD	VMMREGRET;			// return type for the REG Functions

#define	MAX_VMM_REG_KEY_LEN	256	// includes the \0 terminator

#ifndef REG_SZ		// define only if not there already

#define REG_SZ		0x0001
#define REG_BINARY	0x0003

#endif

#ifndef HKEY_LOCAL_MACHINE	// define only if not there already

#define HKEY_CLASSES_ROOT		0x80000000
#define HKEY_CURRENT_USER		0x80000001
#define HKEY_LOCAL_MACHINE		0x80000002
#define HKEY_USERS			0x80000003
#define HKEY_PERFORMANCE_DATA		0x80000004
#define HKEY_CURRENT_CONFIG		0x80000005
#define HKEY_DYN_DATA			0x80000006

#endif


// ERROR CODES returned by Registry
// NOTE THAT THESE ARE ALSO DEFINED IN WINERROR.H 
// and so VMMREG.H should be included after WINERROR.H

#ifndef ERROR_FILE_NOT_FOUND
#define ERROR_FILE_NOT_FOUND             2L
#endif

#ifndef ERROR_BADDB
#define ERROR_BADDB                      1009L
#endif

#ifndef ERROR_MORE_DATA
#define ERROR_MORE_DATA                  234L    
#endif

#ifndef ERROR_BADKEY
#define ERROR_BADKEY			 1010L
#endif

#ifndef ERROR_CANTOPEN
#define ERROR_CANTOPEN                   1011L
#endif

#ifndef ERROR_CANTREAD
#define ERROR_CANTREAD                   1012L
#define ERROR_CANTWRITE                  1013L
#endif

#ifndef ERROR_REGISTRY_CORRUPT
#define ERROR_REGISTRY_CORRUPT           1015L
#define ERROR_REGISTRY_IO_FAILED         1016L
#endif

#ifndef ERROR_KEY_DELETED
#define ERROR_KEY_DELETED                1018L
#endif

#ifndef ERROR_OUTOFMEMORY
#define ERROR_OUTOFMEMORY		   14L
#endif

#ifndef ERROR_INVALID_PARAMETER
#define ERROR_INVALID_PARAMETER		   87L
#endif

#ifndef ERROR_LOCK_FAILED
#define ERROR_LOCK_FAILED                167L
#endif

#ifndef ERROR_NO_MORE_ITEMS
#define ERROR_NO_MORE_ITEMS		  259L
#endif	


#ifndef  ERROR_SUCCESS           
#define ERROR_SUCCESS           0L
#endif

// END ERROR CODES

/*XLATOFF*/
#ifndef Not_VxD

/*NOINC*/
#ifndef _PROVIDER_STRUCTS_DEFINED
#define _PROVIDER_STRUCTS_DEFINED

struct val_context {
    int valuelen;		// the total length of this value
    PVOID value_context;	// provider's context
    PVOID val_buff_ptr;	// where in the ouput buffer the value is.
};

typedef struct val_context *PVALCONTEXT;

typedef struct pvalue {		      // Provider supplied value/context.
    PCHAR pv_valuename;          // The value name pointer
    DWORD pv_valuelen;
    PVOID pv_value_context;
    DWORD pv_type;
}PVALUE;

typedef struct pvalue *PPVALUE;

typedef VMMREGRET (_cdecl *PQUERYHANDLER)(PVOID pvKeyContext, PVALCONTEXT pvalcontextValues, DWORD cvalcontextValues, PVOID pbData, DWORD * pcbData, DWORD dwReserved);

#define PROVIDER_KEEPS_VALUE_LENGTH	0x1
typedef struct provider_info {
    PQUERYHANDLER pi_R0_1val;
    PQUERYHANDLER pi_R0_allvals;
    PQUERYHANDLER pi_R3_1val;
    PQUERYHANDLER pi_R3_allvals;
    DWORD pi_flags;		// Only PROVIDER_KEEPS_VALUE_LENGTH for now.
}PROVIDER;

typedef PROVIDER *PPROVIDER;

struct value_ent {
    PCHAR ve_valuename;
    DWORD ve_valuelen;
    DWORD ve_valueptr;
    DWORD ve_type;
};

typedef struct value_ent VALENT;
typedef VALENT *PVALENT;

#endif // not(_PROVIDER_STRUCTS_DEFINED)
/*INC*/

#ifndef WIN31COMPAT

#pragma warning (disable:4035)		// turn off no return code warning

#ifndef	WANTVXDWRAPS



VMMREGRET VXDINLINE
VMM_RegOpenKey(VMMHKEY hkey, PCHAR lpszSubKey, PVMMHKEY phkResult)
{
    _asm push phkResult
    _asm push lpszSubKey
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegOpenKey);
    _asm add  esp, 3*4
}

VMMREGRET VXDINLINE
VMM_RegCloseKey(VMMHKEY hkey)
{
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegCloseKey);
    _asm add  esp, 1*4 
}

VMMREGRET VXDINLINE
VMM_RegCreateKey(VMMHKEY hkey, PCHAR lpszSubKey, PVMMHKEY phkResult)
{
    _asm push phkResult
    _asm push lpszSubKey
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegCreateKey);
    _asm add  esp, 3*4
}


VMMREGRET VXDINLINE
VMM_RegCreateDynKey(PCHAR lpszSubKey, PVOID pvKeyContext, PVOID pprovHandlerInfo, PVOID ppvalueValueInfo, DWORD cpvalueValueInfo, PVMMHKEY phkResult)
{
    _asm push phkResult
    _asm push cpvalueValueInfo
    _asm push ppvalueValueInfo
    _asm push pprovHandlerInfo
    _asm push pvKeyContext
    _asm push lpszSubKey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegCreateDynKey);
    _asm add  esp, 6*4
}

VMMREGRET VXDINLINE
VMM_RegQueryMultipleValues (VMMHKEY hKey, PVOID val_list, DWORD num_vals, PCHAR lpValueBuf, DWORD *ldwTotsize)
{
    _asm push ldwTotsize
    _asm push lpValueBuf
    _asm push num_vals
    _asm push val_list
    _asm push hKey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegQueryMultipleValues);
    _asm add  esp, 5*4
}

VMMREGRET VXDINLINE
VMM_RegDeleteKey(VMMHKEY hkey, PCHAR lpszSubKey)
{
    _asm push lpszSubKey
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegDeleteKey);
    _asm add  esp, 2*4
}

VMMREGRET VXDINLINE
VMM_RegEnumKey(VMMHKEY hkey, DWORD iSubKey, PCHAR lpszName, DWORD cchName)
{
    _asm push cchName
    _asm push lpszName
    _asm push iSubKey
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegEnumKey);
    _asm add  esp, 4*4 
}

VMMREGRET VXDINLINE
VMM_RegQueryValue(VMMHKEY hkey, PCHAR lpszSubKey, PCHAR lpszValue, PDWORD lpcbValue)
{
    _asm push lpcbValue
    _asm push lpszValue
    _asm push lpszSubKey
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegQueryValue);
    _asm add  esp, 4*4 
}

VMMREGRET VXDINLINE
VMM_RegSetValue(VMMHKEY hkey, PCHAR lpszSubKey, DWORD fdwType, PCHAR lpszData, DWORD cbData)
{
    _asm push cbData
    _asm push lpszData
    _asm push fdwType
    _asm push lpszSubKey
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegSetValue);
    _asm add  esp, 5*4 
}

VMMREGRET VXDINLINE
VMM_RegDeleteValue(VMMHKEY hkey, PCHAR lpszValue)
{
    _asm push lpszValue
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegDeleteValue);
    _asm add  esp, 2*4 
}

VMMREGRET VXDINLINE
VMM_RegEnumValue(VMMHKEY hkey, DWORD iValue, PCHAR lpszValue, PDWORD lpcbValue, PDWORD lpdwReserved, PDWORD lpdwType, PBYTE lpbData, PDWORD lpcbData)
{
    _asm push lpcbData
    _asm push lpbData
    _asm push lpdwType
    _asm push lpdwReserved
    _asm push lpcbValue
    _asm push lpszValue
    _asm push iValue
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegEnumValue);
    _asm add  esp, 8*4 
}

VMMREGRET VXDINLINE
VMM_RegQueryValueEx(VMMHKEY hkey, PCHAR lpszValueName, PDWORD lpdwReserved, PDWORD lpdwType, PBYTE lpbData, PDWORD lpcbData)
{
    _asm push lpcbData
    _asm push lpbData
    _asm push lpdwType
    _asm push lpdwReserved
    _asm push lpszValueName
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegQueryValueEx);
    _asm add  esp, 6*4 
}

VMMREGRET VXDINLINE
VMM_RegSetValueEx(VMMHKEY hkey, PCHAR lpszValueName, DWORD dwReserved, DWORD fdwType, PBYTE lpbData, DWORD cbData)
{
    _asm push cbData
    _asm push lpbData
    _asm push fdwType
    _asm push dwReserved
    _asm push lpszValueName
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegSetValueEx);
    _asm add  esp, 6*4
}

VMMREGRET VXDINLINE
VMM_RegFlushKey(VMMHKEY hkey)
{
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegFlushKey);
    _asm add  esp, 1*4 
}

VMMREGRET VXDINLINE
VMM_RegQueryInfoKey(VMMHKEY hkey, PCHAR lpszClass, PDWORD lpcchClass,PDWORD lpdwReserved, PDWORD lpcSubKeys, PDWORD lpcchMaxSubKey, PDWORD lpcchMaxClass, 
PDWORD lpcValues, PDWORD lpcchMaxValueName, PDWORD lpcbMaxValueData,PDWORD lpcbSecurityDesc, PDWORD lpftLastWriteTime)
{
    _asm push lpftLastWriteTime
    _asm push lpcbSecurityDesc
    _asm push lpcbMaxValueData
    _asm push lpcchMaxValueName
    _asm push lpcValues
    _asm push lpcchMaxClass
    _asm push lpcchMaxSubKey
    _asm push lpcSubKeys
    _asm push lpdwReserved
    _asm push lpcchClass
    _asm push lpszClass
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegQueryInfoKey);
    _asm add  esp, 12*4 
}

#endif	// WANTVXDWRAPS

#pragma warning (default:4035)		// turn on no return code warning

#endif // WIN31COMPAT

#endif // Not_VxD

/*XLATON*/

/* ASM
;**************************************************************
; Macros for Realmode loader registry Services
;
;**************************************************************
LDR_RegOpenKey	Macro	hKey,OffSubKey,SegSubKey,OffphKey,SegphKey
	push	SegphKey
	push	OffphKey		; lphKey
	push	SegSubKey
	push	OffSubKey		; lpszSubKey
	push	dword ptr hKey		; hKey
	mov	ax,LDRSRV_RegOpenKey
	call	dword ptr [_ServiceEntry]
	add	sp,3*4		; for 3 parameters on stack
ENDM
;**************************************************************
LDR_RegCloseKey	Macro	hKey
	push	dword ptr hKey
	mov	ax,LDRSRV_RegCloseKey
	call	dword ptr [_ServiceEntry]
	add	sp,1*4		; for 1 parameter on stack
ENDM
;**************************************************************
LDR_RegCreateKey	Macro	hKey,OffSubKey,SegSubKey,OffphKey,SegphKey
	push	SegphKey
	push	OffphKey		; lphKey
	push	SegSubKey
	push	OffSubKey		; lpszSubKey
	push	dword ptr hKey		; hKey
	mov	ax,LDRSRV_RegCreateKey
	call	dword ptr [_ServiceEntry]
	add	sp,3*4		; for 3 parameters on stack
ENDM
;**************************************************************
LDR_RegDeleteKey	Macro	hKey,OffSubKey,SegSubKey
	push	SegSubKey
	push	OffSubKey		; lpszSubKey
	push	dword ptr hKey		; hKey
	mov	ax,LDRSRV_RegDeleteKey
	call	dword ptr [_ServiceEntry]
	add	sp,2*4		; for 2 parameters on stack
ENDM
;**************************************************************
LDR_RegEnumKey	Macro	hKey,iSubKey,OffszName,SegszName,BufLen
	push	dword ptr BufLen
	push	SegszName
	push	OffszName
	push	dword ptr iSubKey
	push	dword ptr hKey
	mov	ax,LDRSRV_RegEnumKey
	call	dword ptr [_ServiceEntry]
	add	sp,4*4		; for 4 parameters on stack
ENDM
;**************************************************************
LDR_RegQueryValue	Macro	hKey,OffSubKey,SegSubKey,OffValue,SegValue,OffcbValue,SegcbValue
	push	SegcbValue
	push	OffcbValue
	push	SegValue
	push	OffValue
	push	SegSubKey
	push	OffSubKey
	push	dword ptr hKey
	mov	ax,LDRSRV_RegQueryValue
	call	dword ptr [_ServiceEntry]
	add	sp,4*4		; for 4 parameters on stack
ENDM
;**************************************************************
LDR_RegSetValue	Macro	hKey,OffSubKey,SegSubKey,dwType,OffData,SegData,cbData
	push	dword ptr cbData
	push	SegData
	push	OffData
	push	dword ptr dwType
	push	SegSubKey
	push	OffSubKey
	push	dword ptr hKey
	mov	ax,LDRSRV_RegSetValue
	call	dword ptr [_ServiceEntry]
	add	sp,5*4		; for 4 parameters on stack
ENDM
;**************************************************************
LDR_RegDeleteValue	Macro	hKey,OffValue,SegValue
	push	SegValue
	push	OffValue		; lpszValue
	push	dword ptr hKey		; hKey
	mov	ax,LDRSRV_RegDeleteValue
	call	dword ptr [_ServiceEntry]
	add	sp,2*4		; for 2 parameters on stack
ENDM
;**************************************************************
LDR_RegEnumValue	Macro hKey,iValue,OffValue,SegValue,OffcbValue,SegcbValue,RegReserved,OffdwType,SegdwType,OffData,SegData,OffcbData,SegcbData
	push	SegcbData
	push	OffcbData
	push	SegData
	push	OffData
	push	SegdwType
	push	OffdwType
	push	dword ptr RegReserved
	push	SegcbValue
	push	OffcbValue
	push	SegValue
	push	OffValue
	push	dword ptr iValue
	push	dword ptr hKey		; hKey
	mov	ax,LDRSRV_RegEnumValue
	call	dword ptr [_ServiceEntry]
	add	sp,8*4		; for 8 parameters on stack
ENDM
;**************************************************************
LDR_RegQueryValueEx	Macro	hKey,OffValue,SegValue,RegReserved,OffdwType,SegdwType,OffData,SegData,OffcbData,SegcbData
	push	SegcbData
	push	OffcbData
	push	SegData
	push	OffData
	push	SegdwType
	push	OffdwType
	push	dword ptr RegReserved
	push	SegValue
	push	OffValue
	push	dword ptr hKey
	mov	ax,LDRSRV_RegQueryValueEx
	call	dword ptr [_ServiceEntry]
	add	sp,6*4		; for 6 parameters on stack
ENDM
;**************************************************************
LDR_RegSetValueEx	Macro	hKey,OffValue,SegValue,RegReserved,dwType,OffData,SegData,cbData
	push	dword ptr cbData
	push	SegData
	push	OffData
	push	dword ptr dwType
	push	dword ptr RegReserved
	push	SegValue
	push	OffValue
	push	dword ptr hKey
	mov	ax,LDRSRV_RegSetValueEx
	call	dword ptr [_ServiceEntry]
	add	sp,6*4		; for 6 parameters on stack
ENDM
;**************************************************************
LDR_RegFlushKey		Macro	hKey
	push	dword ptr hKey
	mov	ax,LDRSRV_RegFlushKey
	call	dword ptr [_ServiceEntry]
	add	sp,1*4		; for 1 parameter on stack
ENDM
;**************************************************************
*/
#endif		/* _VMMREG_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\VPICD.INC ===
;****************************************************************************
;                                                                           *
; THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
; KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
; IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
; PURPOSE.                                                                  *
;                                                                           *
; Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
;                                                                           *
;****************************************************************************

VPICD_STAT_IRET_PENDING	EQU	01H
VPICD_STAT_IRET_PENDING_BIT	EQU	0
VPICD_STAT_IN_SERVICE	EQU	02H
VPICD_STAT_IN_SERVICE_BIT	EQU	1
VPICD_STAT_PHYS_MASK	EQU	04H
VPICD_STAT_PHYS_MASK_BIT	EQU	2
VPICD_STAT_PHYS_IN_SERV	EQU	08H
VPICD_STAT_PHYS_IN_SERV_BIT	EQU	3
VPICD_STAT_VIRT_MASK	EQU	10H
VPICD_STAT_VIRT_MASK_BIT	EQU	4
VPICD_STAT_VIRT_REQ	EQU	20H
VPICD_STAT_VIRT_REQ_BIT	EQU	5
VPICD_STAT_PHYS_REQ	EQU	40H
VPICD_STAT_PHYS_REQ_BIT	EQU	6
VPICD_STAT_VIRT_DEV_REQ	EQU	80H
VPICD_STAT_VIRT_DEV_REQ_BIT	EQU	7
VPICD_STAT_GLOBAL	EQU	100H
VPICD_STAT_GLOBAL_BIT	EQU	8
VPICD_STAT_OWNED_BY_VM	EQU	200H
VPICD_STAT_OWNED_BY_VM_BIT	EQU	9
VPICD_OPT_READ_HW_IRR	EQU	01H
VPICD_OPT_READ_HW_IRR_BIT	EQU	0
VPICD_OPT_CAN_SHARE	EQU	02H
VPICD_OPT_CAN_SHARE_BIT	EQU	1
VPICD_OPT_REF_DATA	EQU	04H
VPICD_OPT_REF_DATA_BIT	EQU	2
VPICD_OPT_VIRT_INT_REJECT	EQU	10H
VPICD_OPT_VIRT_INT_REJECT_BIT	EQU	4
VPICD_OPT_SHARE_PMODE_ONLY	EQU	20H
VPICD_OPT_SHARE_PMODE_ONLY_BIT	EQU	5
VPICD_OPT_ALL	EQU	3FH
VPICD_FDO_NO_CONTENTION	EQU	10000H
VPICD_FDO_NO_CONTENTION_BIT	EQU	16
VPICD_FDO_FAVOR_FOCUS	EQU	20000H
VPICD_FDO_FAVOR_FOCUS_BIT	EQU	17

VPICD_IRQ_Descriptor	STRUC
VID_IRQ_Number	DW	?
VID_Options	DW	0
VID_Hw_Int_Proc	DD	?
VID_Virt_Int_Proc	DD	0
VID_EOI_Proc	DD	0
VID_Mask_Change_Proc	DD	0
VID_IRET_Proc	DD	0
VID_IRET_Time_Out	DD	500
VID_Hw_Int_Ref	DD	?
VPICD_IRQ_Descriptor	ENDS
Begin_Service_Table VPICD
VPICD_Service	 VPICD_Get_Version, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Virtualize_IRQ, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Set_Int_Request, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Clear_Int_Request, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Phys_EOI, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Get_Complete_Status, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Get_Status, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Test_Phys_Request, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Physically_Mask, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Physically_Unmask, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Set_Auto_Masking, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Get_IRQ_Complete_Status, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Convert_Handle_To_IRQ, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Convert_IRQ_To_Int, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Convert_Int_To_IRQ, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Call_When_Hw_Int, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Force_Default_Owner, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Force_Default_Behavior, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Auto_Mask_At_Inst_Swap
VPICD_Service	 VPICD_Begin_Inst_Page_Swap
VPICD_Service	 VPICD_End_Inst_Page_Swap
VPICD_Service	 VPICD_Virtual_EOI, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Get_Virtualization_Count
VPICD_Service	 VPICD_Post_Sys_Critical_Init, LOCAL
VPICD_Service	 VPICD_VM_SlavePIC_Mask_Change, VxD_LOCKED_CODE
End_Service_Table VPICD
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\VWIN32.H ===
/****************************************************************************
*                                                                           *
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
* KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
* IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
* PURPOSE.                                                                  *
*                                                                           *
* Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
*                                                                           *
****************************************************************************/

/******************************************************************************
 *
 *   Title:	vwin32.h
 *
 *   Version:	4.00
 *
 ******************************************************************************/

/*INT32*/

#ifndef Not_VxD

/*XLATOFF*/
#define VWIN32_Service	Declare_Service
#pragma warning (disable:4003)		// turn off not enough params warning
/*XLATON*/

/*MACROS*/
Begin_Service_Table(VWIN32)

VWIN32_Service	(VWIN32_Get_Version, LOCAL)
VWIN32_Service	(VWIN32_DIOCCompletionRoutine, LOCAL)
VWIN32_Service	(_VWIN32_QueueUserApc)
VWIN32_Service	(_VWIN32_Get_Thread_Context)
VWIN32_Service	(_VWIN32_Set_Thread_Context)
VWIN32_Service	(_VWIN32_CopyMem, LOCAL)
VWIN32_Service	(_VWIN32_Npx_Exception)
VWIN32_Service	(_VWIN32_Emulate_Npx)
VWIN32_Service	(_VWIN32_CheckDelayedNpxTrap)
VWIN32_Service	(VWIN32_EnterCrstR0)
VWIN32_Service	(VWIN32_LeaveCrstR0)
VWIN32_Service	(_VWIN32_FaultPopup)
VWIN32_Service	(VWIN32_GetContextHandle)
VWIN32_Service	(VWIN32_GetCurrentProcessHandle, LOCAL)
VWIN32_Service	(_VWIN32_SetWin32Event)
VWIN32_Service	(_VWIN32_PulseWin32Event)
VWIN32_Service	(_VWIN32_ResetWin32Event)
VWIN32_Service	(_VWIN32_WaitSingleObject)
VWIN32_Service	(_VWIN32_WaitMultipleObjects)
VWIN32_Service	(_VWIN32_CreateRing0Thread)
VWIN32_Service	(_VWIN32_CloseVxDHandle)
VWIN32_Service	(VWIN32_ActiveTimeBiasSet, LOCAL)
VWIN32_Service	(VWIN32_GetCurrentDirectory, LOCAL)
VWIN32_Service	(VWIN32_BlueScreenPopup)
VWIN32_Service	(VWIN32_TerminateApp)
VWIN32_Service	(_VWIN32_QueueKernelAPC)
VWIN32_Service	(VWIN32_SysErrorBox)
VWIN32_Service	(_VWIN32_IsClientWin32)
VWIN32_Service	(VWIN32_IFSRIPWhenLev2Taken, LOCAL)

End_Service_Table(VWIN32)
/*ENDMACROS*/

/*XLATOFF*/
#pragma warning (default:4003)		// turn on not enough params warning
/*XLATON*/

#endif // Not_VxD

//
// structure for VWIN32_SysErrorBox
//

typedef struct vseb_s {
    DWORD vseb_resp;
    WORD vseb_b3;
    WORD vseb_b2;
    WORD vseb_b1;
    DWORD vseb_pszCaption;
    DWORD vseb_pszText;
} VSEB;

typedef VSEB *PVSEB;

// VWIN32_QueueKernelAPC flags

#define KERNEL_APC_IGNORE_MC 		0x00000001
#define KERNEL_APC_STATIC 		0x00000002
#define	KERNEL_APC_WAKE			0x00000004

// for DeviceIOControl support
// On a DeviceIOControl call vWin32 will pass following parameters to
// the Vxd that is specified by hDevice. hDevice is obtained thru an
// earlier call to hDevice = CreateFile("\\.\vxdname", ...);
// ESI = DIOCParams STRUCT (defined below)
typedef struct DIOCParams	{
	DWORD	Internal1;		// ptr to client regs
	DWORD	VMHandle;		// VM handle
	DWORD	Internal2;		// DDB
	DWORD	dwIoControlCode;
	DWORD	lpvInBuffer;
	DWORD	cbInBuffer;
	DWORD	lpvOutBuffer;
	DWORD	cbOutBuffer;
	DWORD	lpcbBytesReturned;
	DWORD	lpoOverlapped;
	DWORD	hDevice;
	DWORD	tagProcess;
} DIOCPARAMETERS;

typedef DIOCPARAMETERS *PDIOCPARAMETERS;

// dwIoControlCode values for vwin32's DeviceIOControl Interface
// all VWIN32_DIOC_DOS_ calls require lpvInBuffer abd lpvOutBuffer to be
// struct * DIOCRegs
#define	VWIN32_DIOC_GETVERSION DIOC_GETVERSION
#define	VWIN32_DIOC_DOS_IOCTL	1
#define	VWIN32_DIOC_DOS_INT25	2
#define	VWIN32_DIOC_DOS_INT26	3
#define	VWIN32_DIOC_DOS_INT13	4
#define VWIN32_DIOC_SIMCTRLC	5
#define	VWIN32_DIOC_CLOSEHANDLE DIOC_CLOSEHANDLE

// DIOCRegs
// Structure with i386 registers for making DOS_IOCTLS
// vwin32 DIOC handler interprets lpvInBuffer , lpvOutBuffer to be this struc.
// and does the int 21
// reg_flags is valid only for lpvOutBuffer->reg_Flags
typedef struct DIOCRegs	{
	DWORD	reg_EBX;
	DWORD	reg_EDX;
	DWORD	reg_ECX;
	DWORD	reg_EAX;
	DWORD	reg_EDI;
	DWORD	reg_ESI;
	DWORD	reg_Flags;		
} DIOC_REGISTERS;

// if we are not included along with winbase.h
#ifndef FILE_FLAG_OVERLAPPED
  // OVERLAPPED structure for DeviceIOCtl VxDs
  typedef struct _OVERLAPPED {
          DWORD O_Internal;
          DWORD O_InternalHigh;
          DWORD O_Offset;
          DWORD O_OffsetHigh;
          HANDLE O_hEvent;
  } OVERLAPPED;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\VPICD.H ===
/****************************************************************************
*                                                                           *
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
* KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
* IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
* PURPOSE.                                                                  *
*                                                                           *
* Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
*                                                                           *
****************************************************************************/

/******************************************************************************
 *
 *   Title:	VPICD.H - Include file for Virtual PIC Device
 *
 *   Version:	3.10
 *
 ******************************************************************************/

/*INT32*/

// Equates for result from VPICD_Get_Status

#define	VPICD_STAT_IRET_PENDING     	0x01
#define	VPICD_STAT_IRET_PENDING_BIT 	0
#define	VPICD_STAT_IN_SERVICE	    	0x02
#define	VPICD_STAT_IN_SERVICE_BIT   	1
#define	VPICD_STAT_PHYS_MASK	    	0x04
#define	VPICD_STAT_PHYS_MASK_BIT    	2
#define	VPICD_STAT_PHYS_IN_SERV     	0x08
#define	VPICD_STAT_PHYS_IN_SERV_BIT 	3
#define	VPICD_STAT_VIRT_MASK	    	0x10
#define	VPICD_STAT_VIRT_MASK_BIT    	4
#define	VPICD_STAT_VIRT_REQ	    	0x20
#define	VPICD_STAT_VIRT_REQ_BIT     	5
#define	VPICD_STAT_PHYS_REQ	    	0x40
#define	VPICD_STAT_PHYS_REQ_BIT     	6
#define	VPICD_STAT_VIRT_DEV_REQ     	0x80
#define	VPICD_STAT_VIRT_DEV_REQ_BIT 	7
#define VPICD_STAT_GLOBAL		0x100
#define VPICD_STAT_GLOBAL_BIT		8
#define VPICD_STAT_OWNED_BY_VM		0x200
#define VPICD_STAT_OWNED_BY_VM_BIT	9

// Equates for options in IRQ Descriptor

#define	VPICD_OPT_READ_HW_IRR	    	0x01
#define	VPICD_OPT_READ_HW_IRR_BIT   	0
#define	VPICD_OPT_CAN_SHARE	    	0x02
#define	VPICD_OPT_CAN_SHARE_BIT		1
#define	VPICD_OPT_REF_DATA	    	0x04		// new for 4.0
#define	VPICD_OPT_REF_DATA_BIT		2
#define	VPICD_OPT_VIRT_INT_REJECT    	0x10		// new for 4.0
#define VPICD_OPT_VIRT_INT_REJECT_BIT	4
#define VPICD_OPT_SHARE_PMODE_ONLY	0x20		// new for 4.0
#define VPICD_OPT_SHARE_PMODE_ONLY_BIT	5
#define VPICD_OPT_ALL			0x3F		// Internal use

// Equates for VPICD_Force_Default_Owner service.  Flags passed in high word
// of IRQ number

#define VPICD_FDO_NO_CONTENTION 	0x10000 	// new for 4.0
#define VPICD_FDO_NO_CONTENTION_BIT	16
#define VPICD_FDO_FAVOR_FOCUS		0x20000 	// new for 4.0
#define VPICD_FDO_FAVOR_FOCUS_BIT	17

typedef struct VPICD_IRQ_Descriptor {
    USHORT VID_IRQ_Number;
    USHORT VID_Options;			// INIT<0>
    ULONG VID_Hw_Int_Proc;
    ULONG VID_Virt_Int_Proc;		// INIT<0>
    ULONG VID_EOI_Proc;			// INIT<0>
    ULONG VID_Mask_Change_Proc;		// INIT<0>
    ULONG VID_IRET_Proc;		// INIT<0>
    ULONG VID_IRET_Time_Out;		// INIT<500>
    ULONG VID_Hw_Int_Ref;		// new for 4.0
} VID;

typedef VID *PVID;
typedef ULONG HIRQ;			// IRQ Handle

/*XLATOFF*/
#define	VPICD_Service	Declare_Service
#pragma warning (disable:4003)		// turn off not enough params warning
/*XLATON*/

/*MACROS*/
Begin_Service_Table(VPICD)

VPICD_Service	(VPICD_Get_Version, VxD_LOCKED_CODE)
VPICD_Service	(VPICD_Virtualize_IRQ, VxD_LOCKED_CODE)
VPICD_Service	(VPICD_Set_Int_Request, VxD_LOCKED_CODE)
VPICD_Service	(VPICD_Clear_Int_Request, VxD_LOCKED_CODE)
VPICD_Service	(VPICD_Phys_EOI, VxD_LOCKED_CODE)
VPICD_Service	(VPICD_Get_Complete_Status, VxD_LOCKED_CODE)
VPICD_Service	(VPICD_Get_Status, VxD_LOCKED_CODE)
VPICD_Service	(VPICD_Test_Phys_Request, VxD_LOCKED_CODE)
VPICD_Service	(VPICD_Physically_Mask, VxD_LOCKED_CODE)
VPICD_Service	(VPICD_Physically_Unmask, VxD_LOCKED_CODE)
VPICD_Service	(VPICD_Set_Auto_Masking, VxD_LOCKED_CODE)
VPICD_Service	(VPICD_Get_IRQ_Complete_Status, VxD_LOCKED_CODE)
VPICD_Service	(VPICD_Convert_Handle_To_IRQ, VxD_LOCKED_CODE)
VPICD_Service	(VPICD_Convert_IRQ_To_Int, VxD_LOCKED_CODE)
VPICD_Service	(VPICD_Convert_Int_To_IRQ, VxD_LOCKED_CODE)
VPICD_Service	(VPICD_Call_When_Hw_Int, VxD_LOCKED_CODE)
VPICD_Service	(VPICD_Force_Default_Owner, VxD_LOCKED_CODE)
VPICD_Service	(VPICD_Force_Default_Behavior, VxD_LOCKED_CODE)

VPICD_Service	(VPICD_Auto_Mask_At_Inst_Swap)
VPICD_Service	(VPICD_Begin_Inst_Page_Swap)
VPICD_Service	(VPICD_End_Inst_Page_Swap)
VPICD_Service	(VPICD_Virtual_EOI, VxD_LOCKED_CODE)	// 4.0 service
VPICD_Service	(VPICD_Get_Virtualization_Count)
VPICD_Service	(VPICD_Post_Sys_Critical_Init, LOCAL)
VPICD_Service	(VPICD_VM_SlavePIC_Mask_Change, VxD_LOCKED_CODE)

End_Service_Table(VPICD)
/*ENDMACROS*/

/*XLATOFF*/
#pragma warning (default:4003)		// turn on not enough params warning
#pragma warning (disable:4035)		// turn off no return code warning

/*
 *  This function is a macro for efficiency.  The parameters passed are
 *  the variables the version (USHORT), flags (ULONG), and maximum IRQ
 *  number (ULONG) are put.
 *
 */

#define	VPICD_Get_Version(ver, fl, cMaxIRQ) \
{ \
    VxDCall(VPICD_Get_Version) \
    __asm xchg [ver],ax \
    __asm xchg [fl],ebx \
    __asm xchg [cMaxIRQ],ecx \
}

//HIRQ static __inline
HIRQ static
VPICD_Virtualize_IRQ(PVID pvid)
{
    __asm {
	mov edi,[pvid]
	VxDCall(VPICD_Virtualize_IRQ)
    	jnc short vvi10
    	xor eax,eax
    vvi10:
    }
}

void static __inline
VPICD_Set_Int_Request(HIRQ hirq, HVM hvm)
{
    __asm mov eax,[hirq]
    __asm mov ebx,[hvm]
    VxDCall(VPICD_Set_Int_Request)
}

void static __inline 
VPICD_Clear_Int_Request(HIRQ hirq, HVM hvm)
{
    __asm mov eax,[hirq]
    __asm mov ebx,[hvm]
    VxDCall(VPICD_Clear_Int_Request)
}

void static __inline
VPICD_Phys_EOI(HIRQ hirq)
{
    __asm mov eax,[hirq]
    VxDCall(VPICD_Phys_EOI)
}

ULONG static __inline
VPICD_Get_Complete_Status(HIRQ hirq, HVM hvm)
{
    __asm mov eax,[hirq]
    __asm mov ebx,[hvm]
    VxDCall(VPICD_Get_Complete_Status)
    __asm xchg eax,ecx			// trashed ECX for compiler
}

ULONG static __inline
VPICD_Get_Status(HIRQ hirq, HVM hvm)
{
    __asm mov eax,[hirq]
    __asm mov ebx,[hvm]
    VxDCall(VPICD_Get_Status)
    __asm xchg eax,ecx			// trashed ECX for compiler
}

ULONG static __inline
VPICD_Test_Phys_Request(HIRQ hirq)
{
    __asm mov eax,[hirq]
    VxDCall(VPICD_Test_Phys_Request)
    __asm sbb eax,eax			// EAX == 0, interrupt request clear
}

void static __inline
VPICD_Physically_Mask(HIRQ hirq)
{
    __asm mov eax,[hirq]
    VxDCall(VPICD_Physically_Mask)
}

void static __inline
VPICD_Physically_Unmask(HIRQ hirq)
{
    __asm mov eax,[hirq]
    VxDCall(VPICD_Physically_Unmask)
}

void static __inline
VPICD_Set_Auto_Masking(HIRQ hirq)
{
    __asm mov eax,[hirq]
    VxDCall(VPICD_Set_Auto_Masking)
}

ULONG static __inline
VPICD_Get_IRQ_Complete_Status(ULONG irqn)
{
    __asm xor ecx,ecx
    __asm mov eax,[irqn]
    VxDCall(VPICD_Get_IRQ_Complete_Status)
    __asm xchg eax,ecx			// trashed ECX for compiler
}

ULONG static __inline
VPICD_Convert_Handle_To_IRQ(HIRQ hirq)
{
    __asm mov eax,[hirq]
    VxDCall(VPICD_Convert_Handle_To_IRQ)
    __asm xchg eax,esi			// trashed ESI for compiler
}

ULONG static __inline
VPICD_Convert_IRQ_To_Int(ULONG irqn, HVM hvm)
{
    __asm {
	mov eax,[irqn]
	mov ebx,[hvm]
	VxDCall(VPICD_Convert_IRQ_To_Int)
	jnc short cii10
	xor eax,eax		// returns 0 if invalid IRQ number
    cii10:
    }
}

ULONG static __inline
VPICD_Convert_Int_To_IRQ(ULONG intn)
{
    __asm {
	mov eax,[intn]
        VxDCall(VPICD_Convert_Int_To_IRQ)
	jnc short cii10
	xor eax,eax
	dec eax			// returns -1 if vector not mapped to any IRQ
    cii10:
    }
}

PFN static __inline
VPICD_Call_When_Hw_Int(PFN pfn)
{
    __asm mov esi,[pfn]
    VxDCall(VPICD_Call_When_Hw_Int)
    __asm mov eax,esi
}

ULONG static __inline
VPICD_Force_Default_Owner(HIRQ hirq, HVM hvm)
{
    __asm mov eax,[hirq]
    __asm mov ebx,[hvm]
    VxDCall(VPICD_Force_Default_Owner)
    __asm cmc
    __asm sbb eax,eax		// EAX != 0 success, EAX == 0 failure
}

void static __inline
VPICD_Force_Default_Behavior(HIRQ hirq)
{
    __asm mov eax,[hirq]
    VxDCall(VPICD_Force_Default_Behavior)
}

ULONG static __inline
VPICD_Auto_Mask_At_Inst_Swap(HIRQ hirq)
{
    __asm mov eax,[hirq]
    VxDCall(VPICD_Auto_Mask_At_Inst_Swap)
    __asm cmc
    __asm sbb eax,eax		// EAX != 0 success, EAX == 0 failure
}

void static __inline
VPICD_Begin_Inst_Page_Swap(void)
{
    VxDCall(VPICD_Begin_Inst_Page_Swap)
}

void static __inline
VPICD_End_Inst_Page_Swap(void)
{
    VxDCall(VPICD_End_Inst_Page_Swap)
}

ULONG static __inline
VPICD_Get_Virtualization_Count(ULONG intn)
{
    _asm mov	eax,[intn]
    VxDCall(VPICD_Get_Virtualization_Count)
}

#pragma warning (default:4035)		// turn on no return code warning

/*XLATON*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\old\INT2FAPI.INC ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1989-1990
;
;   Title:	INT2FAPI.INC - Windows/386 V86 Application Program Interface
;
;   Version:	3.00
;
;   Date:	10-Mar-1989
;
;   Author:	RAL
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   10-Mar-1989 RAL Original for 3.0
;   07-Apr-1989 RAL Added device broadcast equate
;
;==============================================================================
;
;   For inforamtion on these APIs please refer to the Windows/386 DDK
;   appendix on the Int 2Fh Application Program Interface.
;
;------------------------------------------------------------------------------

;
;   Interrupt 2Fh is used for Windows/386 API calls.
;
W386_API_Int		EQU	2Fh

;
;   All Windows/386 API Int 2Fh calls must be issued with AH = 16h
;
W386_Int_Multiplex	EQU	16h

;
;   Values for AL for all Windows/386 API calls
;
W386_Get_Version	EQU	00h		; Install check/Get version
W386_Old_Get_VMID_API	EQU	02h		; Version 2.xx get VMID API call
W386_Startup		EQU	05h		; Broadcast when Win386 starting
W386_Exit		EQU	06h		; Broadcast when Win386 exited
W386_Device_Broadcast	EQU	07h		; Broadcast by virtual device
W386_Startup_Complete	EQU	08h		; Broadcast when Win386 start is complete
W386_Begin_Exit 	EQU	09h		; Broadcast when Win386 is starting
						;   a NORMAL exit sequence
W386_Windows_ID 	EQU	0Ah		; Identify windows ver/type
W386_TSR_Identify	EQU	0Bh		; Identify TSRs
W386_ROM_Detect 	EQU	0Ch		; Used by ROM win to detect ROMs

W386_Release_Time	EQU	80h		; Release cur VM's time-slice
W386_Begin_Critical	EQU	81h		; Begin critical section
W386_End_Critical	EQU	82h		; End critical section
W386_Get_Cur_VMID	EQU	83h		; Returns BX = ID of current VM
W386_Get_Device_API	EQU	84h		; Returns ES:DI -> Device API
W386_Switch_And_Call	EQU	85h		; Change VMs and call-back
W386_Test_Int31_Avail	EQU	86h		; Returns AX=0 if Int 31 avail
W386_Get_PM_Switch_Addr EQU	87h		; Get call-back addr for PM
W386_Get_LDT_Base_Sel	EQU	88h		; Get selector to LDT
W386_Win_Kernel_Idle	EQU	89h		; Windows kernel idle call
W386_DPMI_Extension	EQU	8Ah		; DPMI extension Int 2Fh
W386_Set_Focus		EQU	8Bh		; Set focus to specified VM
W386_Restart_Cmd	EQU	8Ch		; Win.Com execs specified app

;
;   Structure for real mode device initialization API.
;
Win386_Startup_Info_Struc STRUC
SIS_Version		db	3, 0		; Structure version
SIS_Next_Ptr		dd	?		; Seg:Off of next dev in list
SIS_Virt_Dev_File_Ptr	dd	0		; Ptr to ASCIZ file name to load
SIS_Reference_Data	dd	?		; Data to be passed to device
SIS_Instance_Data_Ptr	dd	0		; Ptr to instance data list
Win386_Startup_Info_Struc ENDS

;
;   Structure for instance data list.  (List terminated with 0 dword).
;
Instance_Item_Struc STRUC
IIS_Ptr 		dd	?		; Seg:Off of instance item
IIS_Size		dw	?		; Size of instance item in bytes
Instance_Item_Struc ENDS

;
;   Flags passed to the Win_Kernel_Idle call to indicate state of Windows
;   in the BX register.
;
Win_Idle_Mouse_Busy	EQU	00000001b
Win_Idle_Mouse_Busy_Bit EQU	0

;
; Structure for TSR <-> Windows communication
; (W386_TSR_Identify call, AL=0Bh)
;
TSR_Info_Struc	STRUC
    TSR_Next		    dd	?
    TSR_PSP_Segment	    dw	?
    TSR_API_Ver_ID	    dw	100h
    TSR_Exec_Flags	    dw	0
    TSR_Exec_Cmd_Show	    dw	0
    TSR_Exec_Cmd	    dd	0
    TSR_Reserved	    db	4 dup (0)
    TSR_ID_Block	    dd	0
    TSR_Data_Block	    dd	0
TSR_Info_Struc ENDS

;
; TSR_Exec_Flags equates
;
TSR_WINEXEC	EQU	1
TSR_LOADLIBRARY EQU	2
TSR_OPENDRIVER	EQU	4
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\vwin32.inc ===
;****************************************************************************
;                                                                           *
; THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
; KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
; IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
; PURPOSE.                                                                  *
;                                                                           *
; Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
;                                                                           *
;****************************************************************************

ifndef Not_VxD
Begin_Service_Table VWIN32
VWIN32_Service	 VWIN32_Get_Version, LOCAL
VWIN32_Service	 VWIN32_DIOCCompletionRoutine, LOCAL
VWIN32_Service	 _VWIN32_QueueUserApc
VWIN32_Service	 _VWIN32_Get_Thread_Context
VWIN32_Service	 _VWIN32_Set_Thread_Context
VWIN32_Service	 _VWIN32_CopyMem, LOCAL
VWIN32_Service	 _VWIN32_Npx_Exception
VWIN32_Service	 _VWIN32_Emulate_Npx
VWIN32_Service	 _VWIN32_CheckDelayedNpxTrap
VWIN32_Service	 VWIN32_EnterCrstR0
VWIN32_Service	 VWIN32_LeaveCrstR0
VWIN32_Service	 _VWIN32_FaultPopup
VWIN32_Service	 VWIN32_GetContextHandle
VWIN32_Service	 VWIN32_GetCurrentProcessHandle, LOCAL
VWIN32_Service	 _VWIN32_SetWin32Event
VWIN32_Service	 _VWIN32_PulseWin32Event
VWIN32_Service	 _VWIN32_ResetWin32Event
VWIN32_Service	 _VWIN32_WaitSingleObject
VWIN32_Service	 _VWIN32_WaitMultipleObjects
VWIN32_Service	 _VWIN32_CreateRing0Thread
VWIN32_Service	 _VWIN32_CloseVxDHandle
VWIN32_Service	 VWIN32_ActiveTimeBiasSet, LOCAL
VWIN32_Service	 VWIN32_GetCurrentDirectory, LOCAL
VWIN32_Service	 VWIN32_BlueScreenPopup
VWIN32_Service	 VWIN32_TerminateApp
VWIN32_Service	 _VWIN32_QueueKernelAPC
VWIN32_Service	 VWIN32_SysErrorBox
VWIN32_Service	 _VWIN32_IsClientWin32
VWIN32_Service	 VWIN32_IFSRIPWhenLev2Taken, LOCAL
End_Service_Table VWIN32
endif

vseb_s	STRUC
vseb_resp	DD	?
vseb_b3	DW	?
vseb_b2	DW	?
vseb_b1	DW	?
vseb_pszCaption	DD	?
vseb_pszText	DD	?
vseb_s	ENDS
KERNEL_APC_IGNORE_MC	EQU	00000001H
KERNEL_APC_STATIC	EQU	00000002H
KERNEL_APC_WAKE	EQU	00000004H

DIOCParams	STRUC
Internal1	DD	?
VMHandle	DD	?
Internal2	DD	?
dwIoControlCode	DD	?
lpvInBuffer	DD	?
cbInBuffer	DD	?
lpvOutBuffer	DD	?
cbOutBuffer	DD	?
lpcbBytesReturned	DD	?
lpoOverlapped	DD	?
hDevice	DD	?
tagProcess	DD	?
DIOCParams	ENDS
VWIN32_DIOC_GETVERSION	EQU	<DIOC_GETVERSION>
VWIN32_DIOC_DOS_IOCTL	EQU	1
VWIN32_DIOC_DOS_INT25	EQU	2
VWIN32_DIOC_DOS_INT26	EQU	3
VWIN32_DIOC_DOS_INT13	EQU	4
VWIN32_DIOC_SIMCTRLC	EQU	5
VWIN32_DIOC_CLOSEHANDLE	EQU	<DIOC_CLOSEHANDLE>

DIOCRegs	STRUC
reg_EBX	DD	?
reg_EDX	DD	?
reg_ECX	DD	?
reg_EAX	DD	?
reg_EDI	DD	?
reg_ESI	DD	?
reg_Flags	DD	?
DIOCRegs	ENDS
ifndef FILE_FLAG_OVERLAPPED

_OVERLAPPED	STRUC
O_Internal	DD	?
O_InternalHigh	DD	?
O_Offset	DD	?
O_OffsetHigh	DD	?
O_hEvent	DD	?
_OVERLAPPED	ENDS
endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\VXDLDR.INC ===
;****************************************************************************
;                                                                           *
; THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
; KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
; IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
; PURPOSE.                                                                  *
;                                                                           *
; Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
;                                                                           *
;****************************************************************************

ifndef	_VXDLDR_H
_VXDLDR_H	EQU	1
ifndef	Not_VxD
Begin_Service_Table	 VXDLDR, VxD
 VXDLDR_Service	 VXDLDR_GetVersion, LOCAL
 VXDLDR_Service	 VXDLDR_LoadDevice, LOCAL
 VXDLDR_Service	 VXDLDR_UnloadDevice, LOCAL
 VXDLDR_Service	 VXDLDR_DevInitSucceeded, LOCAL
 VXDLDR_Service	 VXDLDR_DevInitFailed, LOCAL
 VXDLDR_Service	 VXDLDR_GetDeviceList, LOCAL
 VXDLDR_Service    VXDLDR_UnloadMe, LOCAL
 VXDLDR_Service    _PELDR_LoadModule, VxD_PAGEABLE_CODE
 VXDLDR_Service    _PELDR_GetModuleHandle, VxD_PAGEABLE_CODE
 VXDLDR_Service    _PELDR_GetModuleUsage, VxD_PAGEABLE_CODE
 VXDLDR_Service    _PELDR_GetEntryPoint, VxD_PAGEABLE_CODE
 VXDLDR_Service    _PELDR_GetProcAddress, VxD_PAGEABLE_CODE
 VXDLDR_Service    _PELDR_AddExportTable, VxD_PAGEABLE_CODE
 VXDLDR_Service    _PELDR_RemoveExportTable, VxD_PAGEABLE_CODE
 VXDLDR_Service    _PELDR_FreeModule, VxD_PAGEABLE_CODE
 VXDLDR_Service    VXDLDR_Notify, LOCAL
 VXDLDR_Service    _PELDR_InitCompleted, VXD_PAGEABLE_CODE
 VXDLDR_Service    _PELDR_LoadModuleEx, VxD_PAGEABLE_CODE
End_Service_Table	 VXDLDR, VxD
endif
VXDLDR_INIT_DEVICE	EQU	000000001H
VXDLDR_ERR_OUT_OF_MEMORY	EQU	1
VXDLDR_ERR_IN_DOS	EQU	2
VXDLDR_ERR_FILE_OPEN_ERROR	EQU	3
VXDLDR_ERR_FILE_READ	EQU	4
VXDLDR_ERR_DUPLICATE_DEVICE	EQU	5
VXDLDR_ERR_BAD_DEVICE_FILE	EQU	6
VXDLDR_ERR_DEVICE_REFUSED	EQU	7
VXDLDR_ERR_NO_SUCH_DEVICE	EQU	8
VXDLDR_ERR_DEVICE_UNLOADABLE	EQU	9
VXDLDR_ERR_ALLOC_V86_AREA	EQU	10
VXDLDR_ERR_BAD_API_FUNCTION	EQU	11
VXDLDR_ERR_MAX	EQU	11
VXDLDR_NOTIFY_OBJECTUNLOAD	EQU	0
VXDLDR_NOTIFY_OBJECTLOAD	EQU	1
VXDLDR_APIFUNC_GETVERSION	EQU	0
VXDLDR_APIFUNC_LOADDEVICE	EQU	1
VXDLDR_APIFUNC_UNLOADDEVICE	EQU	2

ObjectInfo	STRUC
OI_LinearAddress	DD	?
OI_Size	DD	?
OI_ObjType	DD	?
OI_Resident	DD	?
ObjectInfo	ENDS

DeviceInfo	STRUC
DI_Next	DD	?
DI_LoadCount	DB	?
DI_DDB	DD	?
DI_DeviceID	DW	?
DI_ModuleName	DD	?
DI_Signature	DD	?
DI_ObjCount	DD	?
DI_ObjInfo	DD	?
DI_V86_API_CSIP	DD	?
DI_PM_API_CSIP	DD	?
DeviceInfo	ENDS
DI_Loaded	EQU	<DI_LoadCount>

_W32IoctlPkt	STRUC
W32IO_ErrorCode	DW	?
W32IO_DeviceID	DW	?
W32IO_ModuleName	DB	1 DUP (?)
_W32IoctlPkt	ENDS
ifndef	Not_VxD
endif
PELDR_ERR_NOERROR	EQU	0
PELDR_ERR_INVALIDHANDLE	EQU	-1
PELDR_ERR_MEM_NOMEMORY	EQU	-2
PELDR_ERR_FILE_UNABLETOOPEN	EQU	-3
PELDR_ERR_FILE_READERROR	EQU	-4
PELDR_ERR_IMAGE_INVALIDSIZE	EQU	-5
PELDR_ERR_IMAGE_INVALIDFORMAT	EQU	-6
PELDR_ERR_IMAGE_UNKNOWNFIXUP	EQU	-7
PELDR_ERR_IMAGE_INVALIDFIXUP	EQU	-8
PELDR_ERR_IMAGE_UNDEFINEDIMPORT	EQU	-9
PELDR_ERR_EXPORT_DUPLICATE	EQU	-10
PELDR_ERR_INIT_WASCOMPLETED	EQU	-11
PELDR_LOADFLAG_FREERESOURCES	EQU	00000001H
endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\old\OPTTEST.INC ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1990
;
;   Title:	OPTTEST.INC - Macros to optimize test instructions
;
;   Version:	1.00
;
;   Date:	28-Jun-1990
;
;   Author:	RAL
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   28-Jun-1990 RAL
;
;==============================================================================


TestMem MACRO MemPtr, M
IFE (M) AND 0FFFFFF00h
	test	BYTE PTR [MemPtr], M
ELSE
IFE (M) AND 0FFFF00FFh
	test	BYTE PTR [MemPtr+1], ((M) SHR 8)
ELSE
IFE (M) AND 0FF00FFFFh
	test	BYTE PTR [MemPtr+2], ((M) SHR 16)
ELSE
IFE (M) AND 000FFFFFFh
	test	BYTE PTR [MemPtr+3], ((M) SHR 24)
ELSE
IFE (M) AND 0FFFF0000h
	test	WORD PTR [MemPtr], M
ELSE
IFE (M) AND 0FF0000FFh
	test	WORD PTR [MemPtr+1], ((M) SHR 8)
ELSE
IFE (M) AND 00000FFFFh
	test	WORD PTR [MemPtr+2], ((M) SHR 16)
ELSE
	test	DWORD PTR [MemPtr], M
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
	ENDM





TestReg MACRO R, Mask

_@TR MACRO Ltr
IFE (Mask) AND 0FFFFFF00h
	test	Ltr&&l, Mask
ELSE
IFE (Mask) AND 0FFFF00FFh
	test	Ltr&&h, ((Mask) SHR 8)
ELSE
IFE (Mask) AND 0FFFF0000h
	test	Ltr&&x, Mask
ELSE
	test	e&&Ltr&&x, Mask
ENDIF
ENDIF
ENDIF
	ENDM


IFIDNI <R>, <EAX>
	_@TR a, Mask
ELSE
IFIDNI <R>, <EBX>
	_@TR b, Mask
ELSE
IFIDNI <R>, <ECX>
	_@TR c, Mask
ELSE
IFIDNI <R>, <EDX>
	_@TR d, Mask
ELSE
IFIDNI <R>, <ESI>
IFE (Mask) AND 0FFFF0000h
	test	si, Mask
ELSE
	test	esi, Mask
ENDIF
ELSE
IFIDNI <R>, <EDI>
IFE (Mask) AND 0FFFF0000h
	test	di, Mask
ELSE
	test	edi, Mask
ENDIF
ELSE
%OUT ERROR:  Bad param to TestReg macro
.ERR
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
	ENDM




SetFlag MACRO MemPtr, M
IFE (M) AND 0FFFFFF00h
	or	BYTE PTR [MemPtr], M
ELSE
IFE (M) AND 0FFFF00FFh
	or	BYTE PTR [MemPtr+1], ((M) SHR 8)
ELSE
IFE (M) AND 0FF00FFFFh
	or	BYTE PTR [MemPtr+2], ((M) SHR 16)
ELSE
IFE (M) AND 000FFFFFFh
	or	BYTE PTR [MemPtr+3], ((M) SHR 24)
ELSE
IFE (M) AND 0FFFF0000h
	or	WORD PTR [MemPtr], M
ELSE
IFE (M) AND 0FF0000FFh
	or	WORD PTR [MemPtr+1], ((M) SHR 8)
ELSE
IFE (M) AND 00000FFFFh
	or	WORD PTR [MemPtr+2], ((M) SHR 16)
ELSE
	or	DWORD PTR [MemPtr], M
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
	ENDM



ClrFlag MACRO MemPtr, M
IFE (M) AND 0FFFFFF00h
	and	BYTE PTR [MemPtr], NOT (M)
ELSE
IFE (M) AND 0FFFF00FFh
	and	BYTE PTR [MemPtr+1], NOT ((M) SHR 8)
ELSE
IFE (M) AND 0FF00FFFFh
	and	BYTE PTR [MemPtr+2], NOT ((M) SHR 16)
ELSE
IFE (M) AND 000FFFFFFh
	and	BYTE PTR [MemPtr+3], NOT ((M) SHR 24)
ELSE
IFE (M) AND 0FFFF0000h
	and	WORD PTR [MemPtr], NOT (M)
ELSE
IFE (M) AND 0FF0000FFh
	and	WORD PTR [MemPtr+1], NOT ((M) SHR 8)
ELSE
IFE (M) AND 00000FFFFh
	and	WORD PTR [MemPtr+2], NOT ((M) SHR 16)
ELSE
	and	DWORD PTR [MemPtr], NOT (M)
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
	ENDM
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\old\PAGESWAP.INC ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1988-1990
;
;   Title:	PageSwap.Inc - Demand Paging Swap Device Services
;
;   Version:	1.00
;
;   Date:	18-Oct-1988
;
;   Author:	RAL
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   18-Oct-1988 RAL Original
;   19-Oct-1990 JEM Added Buffer Descriptor structure
;
;==============================================================================


Begin_Service_Table PageSwap

PageSwap_Service PageSwap_Get_Version, LOCAL
PageSwap_Service PageSwap_Test_Create, LOCAL
PageSwap_Service PageSwap_Create, LOCAL
PageSwap_Service PageSwap_Destroy, LOCAL
PageSwap_Service PageSwap_In, LOCAL
PageSwap_Service PageSwap_Out, LOCAL
PageSwap_Service PageSwap_Test_IO_Valid, LOCAL

End_Service_Table PageSwap

PS_Zero_Init_Mask	EQU	0001h
PS_Zero_Init_Bit	EQU	00h
PS_Fixed_Page_Mask	EQU	0008h
PS_Fixed_Page_Bit	EQU	03h
PS_First_Page_In_Mask	EQU	0020h
PS_First_Page_In_Bit	EQU	05h
PS_Dirty_Mask		EQU	0040h
PS_Dirty_Bit		EQU	06h
PS_Ever_Dirty_Mask	EQU	8000h
PS_Ever_Dirty_Bit	EQU	0Fh

PS_NoXchg_Mask		EQU	80000000h
PS_NoXchg_Bit		EQU	1Fh	; DO NOT xchg phys addrs on PageSwap_Out


; Buffer descriptor for asynchronous I/O

SIZE_PS_BD_RESERVED EQU 44

PageSwapBufferDesc	STRUC
PS_BD_Next		dd	?
PS_BD_List		dw	?
PS_BD_Cmd		db	?
PS_BD_Priority		db	?
PS_BD_Page_Number	dd	?
PS_BD_Buffer_Ptr	dd	?
PS_BD_File_Page 	dd	?
PS_BD_Call_Back 	dd	?
PS_BD_Reserved		db SIZE_PS_BD_RESERVED dup (?)
PageSwapBufferDesc	ENDS

; List values for PS_BD_List

PS_BDL_Free		EQU	1
PS_BDL_Pending_WB	EQU	2
PS_BDL_Submitted_RA	EQU	3
PS_BDL_Locked		EQU	4

PS_BDP_Invalid_Data	EQU	-1
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\VXDWRAPS.H ===
/****************************************************************************
*                                                                           *
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
* KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
* IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
* PURPOSE.                                                                  *
*                                                                           *
* Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
*                                                                           *
****************************************************************************/

/****************************************************************************
 *
 *   Title: VXDWRAPS.H - Include file for using VXDWRAPS.LIB
 *
 *   Version:   1.00
 *
 ***************************************************************************/

#ifndef _VXDWRAPS_H
#define _VXDWRAPS_H

#ifdef  _VMM_

#define VMM_MAP_PHYS_TO_LINEAR_INVALID  0xFFFFFFFF

typedef VOID                (_cdecl *VMM_TIMEOUT_HANDLER)();
typedef VOID                (_cdecl *VMM_EVENT_HANDLER)();
typedef ULONG               (_cdecl *VMMSWP)(ULONG frame, ULONG npages);
typedef VOID                (_cdecl *VMMCOMS)(DWORD dwParam);
typedef struct Exception_Handler_Struc  *PVMMEXCEPTION;
//typedef   QWORD               DESCDWORDS;
typedef DWORD               VMMLIST;
typedef PVOID               VMMLISTNODE;
typedef DWORD               SIGNATURE;
typedef SIGNATURE           *PSIGNATURE;    // Pointer to a signature.
typedef struct _vmmmtx {int unused;}    *PVMMMUTEX;
typedef	struct cb_s			*PVMMCB;

#endif  // _VMM_

#define CAT_HELPER(x, y)    x##y
#define CAT(x, y)       CAT_HELPER(x, y)

#ifndef CURSEG
#define CURSEG()        LCODE
#endif

/****************************************************************************
 *
 * There are two types of VxD 'C' wrappers. The ones that are VXDINLINE and
 * the one that have little stubs.
 *
 ***************************************************************************/

/****************************************************************************
 *
 * The following are VxD wrappers done with VXDINLINE. They must return void
 * (to avoid a problem with C++), must take VOID (so that no parameter are
 * used as temporary stack) and all registers are preserved. The two
 * *_Debug_String also fall in that category since they need esp and ebp
 * not to be in a nested stack frame.
 *
 ***************************************************************************/

#ifdef  _VMM_

VOID VXDINLINE
End_Critical_Section(VOID)
{
    VMMCall(End_Critical_Section)
}

VOID VXDINLINE
Fatal_Memory_Handler(VOID)
{
    VMMJmp(Fatal_Memory_Error);
}

VOID VXDINLINE
Begin_Nest_Exec(VOID)
{
    VMMCall(Begin_Nest_Exec)
}

VOID VXDINLINE
End_Nest_Exec(VOID)
{
    VMMCall(End_Nest_Exec)
}

VOID VXDINLINE
Resume_Exec(VOID)
{
    VMMCall(Resume_Exec)
}

VOID VXDINLINE
Enable_Touch_1st_Meg(VOID)
{
    VMMCall(Enable_Touch_1st_Meg)
}

VOID VXDINLINE
Disable_Touch_1st_Meg(VOID)
{
    VMMCall(Disable_Touch_1st_Meg)
}

VOID VXDINLINE
Out_Debug_String(PCHAR psz)
{
    __asm pushad
    __asm mov esi, [psz]
    VMMCall(Out_Debug_String)
    __asm popad
}

VOID VXDINLINE
Queue_Debug_String(PCHAR psz, ULONG ulEAX, ULONG ulEBX)
{
    _asm push esi
    _asm push [ulEAX]
    _asm push [ulEBX]
    _asm mov esi, [psz]
    VMMCall(Queue_Debug_String)
    _asm pop esi
}

#endif  // _VMM_

#define MAKE_HEADER(RetType, DecType, Function, Parameters) \
extern  RetType DecType CAT(LCODE_, CAT(Function, Parameters)); \
extern  RetType DecType CAT(ICODE_, CAT(Function, Parameters)); \
extern  RetType DecType CAT(PCODE_, CAT(Function, Parameters)); \
extern  RetType DecType CAT(SCODE_, CAT(Function, Parameters)); \
extern  RetType DecType CAT(DCODE_, CAT(Function, Parameters)); \
extern  RetType DecType CAT(CCODE_, CAT(Function, Parameters));

#define PREPEND(Name)       CURSEG()##_##Name

#ifdef  _VMM_

WORD VXDINLINE
Get_VMM_Version(VOID)
{
    WORD    w;
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(Get_VMM_Version);
    _asm mov [w], ax
    return(w);
}

MAKE_HEADER(PVOID,_cdecl, _MapPhysToLinear, (ULONG PhysAddr, ULONG nBytes, ULONG flags))
MAKE_HEADER(PVOID,_cdecl,_HeapAllocate, (ULONG Bytes, ULONG Flags))
MAKE_HEADER(ULONG,_cdecl,_HeapFree, (PVOID Address, ULONG Flags))
MAKE_HEADER(PVOID,_cdecl,_HeapReAllocate, (PVOID pOld, ULONG Bytes, ULONG Flags))
MAKE_HEADER(ULONG,_cdecl,_HeapGetSize, (PVOID p, ULONG Flags))
MAKE_HEADER(VOID,_stdcall,Fatal_Error_Handler, (PCHAR pszMessage, DWORD dwExitFlag))
MAKE_HEADER(VOID,_stdcall,Begin_Critical_Section, (ULONG Flags))
MAKE_HEADER(HEVENT,_stdcall,Schedule_Global_Event, (VMM_EVENT_HANDLER pfnEvent, ULONG ulRefData))
MAKE_HEADER(VOID,_stdcall,Cancel_Global_Event, (HEVENT hEvent));
MAKE_HEADER(HVM,_cdecl,Get_Sys_VM_Handle, (VOID))
MAKE_HEADER(DWORD,_stdcall,Get_Profile_Hex_Int, (PCHAR pszSection, PCHAR pszKeyName, DWORD dwDefault))
MAKE_HEADER(BOOL,_stdcall,Get_Profile_Boolean, (PCHAR pszSection, PCHAR pszKeyName, BOOL fDefault))
MAKE_HEADER(VMM_SEMAPHORE,_stdcall,Create_Semaphore, (LONG lTokenCount))
MAKE_HEADER(VOID,_stdcall,Destroy_Semaphore, (VMM_SEMAPHORE vsSemaphore))
MAKE_HEADER(VOID,_stdcall,Signal_Semaphore, (VMM_SEMAPHORE vsSemaphore))
MAKE_HEADER(VOID,_stdcall,Wait_Semaphore, (VMM_SEMAPHORE vsSemaphore, DWORD dwFlags))
MAKE_HEADER(HVM,_cdecl,Get_Execution_Focus, (VOID))
MAKE_HEADER(HTIMEOUT,_stdcall,Set_VM_Time_Out, (VMM_TIMEOUT_HANDLER pfnTimeout, CMS cms, ULONG ulRefData))
MAKE_HEADER(HTIMEOUT,_stdcall,Set_Global_Time_Out, (VMM_TIMEOUT_HANDLER pfnTimeout, CMS cms, ULONG ulRefData))
MAKE_HEADER(VOID,_stdcall,Cancel_Time_Out, (HTIMEOUT htimeout))
MAKE_HEADER(VOID,_stdcall,Update_System_Clock, (ULONG msElapsed))
MAKE_HEADER(BOOL,_stdcall,Install_Exception_Handler, (PVMMEXCEPTION pveException))
MAKE_HEADER(PCHAR,_stdcall,Get_Exec_Path, (PULONG pulPathLength))
MAKE_HEADER(DWORD,_cdecl,Get_Last_Updated_System_Time, (VOID))
MAKE_HEADER(VMMLISTNODE,_stdcall,List_Allocate, (VMMLIST List))
MAKE_HEADER(VOID,_stdcall,List_Attach, (VMMLIST List, VMMLISTNODE Node))
MAKE_HEADER(VOID,_stdcall,List_Attach_Tail, (VMMLIST List, VMMLISTNODE Node))
MAKE_HEADER(VMMLIST,_stdcall,List_Create, (ULONG Flags, ULONG NodeSize))
MAKE_HEADER(VOID,_stdcall,List_Deallocate, (VMMLIST List, VMMLISTNODE Node))
MAKE_HEADER(VOID,_stdcall,List_Destroy, (VMMLIST List))
MAKE_HEADER(VMMLISTNODE,_stdcall,List_Get_First, (VMMLIST List))
MAKE_HEADER(VMMLISTNODE,_stdcall,List_Get_Next, (VMMLIST List, VMMLISTNODE Node))
MAKE_HEADER(VOID,_stdcall,List_Insert, (VMMLIST List, VMMLISTNODE NewNode, VMMLISTNODE Node))
MAKE_HEADER(BOOL,_stdcall,List_Remove, (VMMLIST List, VMMLISTNODE Node))
MAKE_HEADER(VMMLISTNODE,_stdcall,List_Remove_First, (VMMLIST List))
MAKE_HEADER(PVOID,_cdecl,_PageAllocate, (DWORD nPages, DWORD pType, HVM hvm, DWORD AlignMask, DWORD minPhys, DWORD maxPhys, PVOID *PhysAddr, DWORD flags))
MAKE_HEADER(BOOL,_cdecl,_PageFree, (PVOID hMem, DWORD flags))
MAKE_HEADER(DWORD,_cdecl,_AddFreePhysPage, (ULONG PhysPgNum, ULONG nPages, ULONG flags, VMMSWP pfnSwapOutNotify))

//MAKE_HEADER(WORD,_cdecl,_Allocate_GDT_Selector, (DESCDWORDS DescDWORDS, ULONG flags))
//MAKE_HEADER(DESCDWORDS,_cdecl,_BuildDescriptorDWORDs, (DWORD DESCBase, DWORD DESCLimit, DWORD DESCType, DWORD DESCSize, ULONG flags))
//MAKE_HEADER(BOOL,_cdecl,_Free_GDT_Selector, (WORD Selector, ULONG flags))
MAKE_HEADER(HVM,_cdecl,Get_Cur_VM_Handle, (VOID))
MAKE_HEADER(HVM,_cdecl,_LinPageLock, (DWORD HLinPgNum, DWORD nPages, DWORD flags))
MAKE_HEADER(HVM,_cdecl,_LinPageUnlock, (DWORD HLinPgNum, DWORD nPages, DWORD flags))

#ifdef  WIN40SERVICES

MAKE_HEADER(ULONG,_cdecl,VMM_GetSystemInitState, (VOID))
MAKE_HEADER(VOID,_stdcall,_Trace_Out_Service, (PCHAR psz))
MAKE_HEADER(VOID,_stdcall,_Debug_Out_Service, (PCHAR psz))
MAKE_HEADER(VOID,_stdcall,_Debug_Flags_Service, (ULONG flags))
MAKE_HEADER(VOID,_cdecl,_Debug_Printf_Service, (PCHAR pszfmt, ...))
MAKE_HEADER(HTIMEOUT,_stdcall, Set_Async_Time_Out, (VMM_TIMEOUT_HANDLER pfnTimeout, CMS cms, ULONG ulRefData))
MAKE_HEADER(PVMMDDB,_stdcall,Get_DDB, (WORD DeviceID, PCHAR Name))
MAKE_HEADER(DWORD,_stdcall,Directed_Sys_Control, (PVMMDDB pDDB, DWORD SysControl, DWORD rEBX, DWORD rEDX, DWORD rESI, DWORD rEDI))
MAKE_HEADER(BOOL,_cdecl,_Assert_Range, (PVOID p, ULONG ulSize, SIGNATURE sSignature, LONG lSignatureOffset, ULONG ulFlags))
MAKE_HEADER(ULONG,_cdecl,_Sprintf, (PCHAR pszBuf, PCHAR pszFmt, ...))
MAKE_HEADER(PVMMMUTEX,_cdecl,_CreateMutex, (LONG Boost, ULONG Flags))
MAKE_HEADER(BOOL,_cdecl,_DestroyMutex, (PVMMMUTEX hmtx))
MAKE_HEADER(VOID,_cdecl,_EnterMutex, (PVMMMUTEX hmtx, ULONG Flags))
MAKE_HEADER(PTCB,_cdecl,_GetMutexOwner, (PVMMMUTEX hmtx))
MAKE_HEADER(VOID,_cdecl,_LeaveMutex, (PVMMMUTEX hmtx))
MAKE_HEADER(VOID,_cdecl,_SignalID, (DWORD id))
MAKE_HEADER(VOID,_cdecl,_BlockOnID, (DWORD id, ULONG Flags))
MAKE_HEADER(PCHAR,_cdecl,_lstrcpyn,(PCHAR pszDest,const char *pszSrc,DWORD cb))
MAKE_HEADER(ULONG,_cdecl,_lstrlen,(const char *psz))
MAKE_HEADER(ULONG,_cdecl,_lmemcpy,(PVOID pDst, const void *pSrc, DWORD cb))
MAKE_HEADER(DWORD,_cdecl,Get_Boot_Flags, (VOID))
MAKE_HEADER(PTCB,_cdecl,Get_Cur_Thread_Handle, (VOID))
MAKE_HEADER(PVOID,_cdecl,_GetVxDName, (PVOID pLinAddr, PCHAR pBuffer))
MAKE_HEADER(VOID,_cdecl,_Call_On_My_Stack, (VMMCOMS Callback, DWORD LParam, PVOID StackPtr, DWORD StackSize))

#endif  // WIN40SERVICES

#endif  // _VMM_

#ifdef  _SHELL_H

typedef DWORD       SHELL_HINSTANCE;
typedef PVOID       SHELL_FARPROC;

WORD VXDINLINE
SHELL_Get_Version(VOID)
{
    WORD    w;
    VxDCall(SHELL_Get_Version);
    _asm mov [w], ax
    return(w);
}

MAKE_HEADER(DWORD,_stdcall,SHELL_SYSMODAL_Message, (HVM hvm, DWORD dwMBFlags, PCHAR pszMessage, PCHAR pszCaption))

#ifndef WIN31COMPAT

MAKE_HEADER(APPY_HANDLE,_cdecl,_SHELL_CallAtAppyTime, (APPY_CALLBACK pfnAppyCallBack, DWORD dwRefData, DWORD flAppy, ...))
MAKE_HEADER(BOOL,_cdecl,_SHELL_CancelAppyTimeEvent, (APPY_HANDLE appy_handle))
MAKE_HEADER(BOOL,_cdecl,_SHELL_QueryAppyTimeAvailable, (VOID))
MAKE_HEADER(DWORD,_cdecl,_SHELL_LocalAllocEx, (DWORD fl, DWORD cb, PVOID lpvBuf))
MAKE_HEADER(DWORD,_cdecl,_SHELL_LocalFree, (DWORD hdata))
MAKE_HEADER(DWORD,_cdecl,_SHELL_CallDll, (PCHAR lpszDll, PCHAR lpszProcName, DWORD cbArgs, PVOID lpvArgs))
MAKE_HEADER(DWORD,_cdecl,_SHELL_BroadcastSystemMessage, (DWORD dwFlags, PDWORD lpdwRecipients, DWORD uMsg, DWORD wparam, DWORD lparam))
MAKE_HEADER(SYSBHOOK_HANDLE,_cdecl,_SHELL_HookSystemBroadcast, (SYSBHOOK_CALLBACK pfnSysBHookCallBack, DWORD dwRefData, DWORD dwCallOrder))
MAKE_HEADER(VOID,_cdecl,_SHELL_UnhookSystemBroadcast, (SYSBHOOK_HANDLE SysBHookHandle))
MAKE_HEADER(SHELL_HINSTANCE,_cdecl,_SHELL_LoadLibrary, (PCHAR pszDll))
MAKE_HEADER(VOID,_cdecl,_SHELL_FreeLibrary, (SHELL_HINSTANCE hinstance))
MAKE_HEADER(SHELL_FARPROC,_cdecl,_SHELL_GetProcAddress, (SHELL_HINSTANCE hinstance, PCHAR pszProcName))

#endif  // WIN31COMPAT

#endif  // _SHELL_H

#ifdef  _VMMREG_H

#ifndef WIN31COMPAT

MAKE_HEADER(VMMREGRET,cdecl,_RegOpenKey, (VMMHKEY hkey, PCHAR lpszSubKey, PVMMHKEY phkResult))
MAKE_HEADER(VMMREGRET,cdecl,_RegCloseKey, (VMMHKEY hkey))
MAKE_HEADER(VMMREGRET,cdecl,_RegCreateKey, (VMMHKEY hkey, PCHAR lpszSubKey, PVMMHKEY phkResult))
MAKE_HEADER(VMMREGRET,cdecl,_RegDeleteKey, (VMMHKEY hkey, PCHAR lpszSubKey))
MAKE_HEADER(VMMREGRET,cdecl,_RegEnumKey, (VMMHKEY hkey, DWORD iSubKey, PCHAR lpszName, DWORD cchName))
MAKE_HEADER(VMMREGRET,cdecl,_RegQueryValue, (VMMHKEY hkey, PCHAR lpszSubKey, PCHAR lpszValue, PDWORD lpcbValue))
MAKE_HEADER(VMMREGRET,cdecl,_RegSetValue, (VMMHKEY hkey, PCHAR lpszSubKey, DWORD fdwType, PCHAR lpszData, DWORD cbData))
MAKE_HEADER(VMMREGRET,cdecl,_RegDeleteValue, (VMMHKEY hkey, PCHAR lpszValue))
MAKE_HEADER(VMMREGRET,cdecl,_RegEnumValue, (VMMHKEY hkey, DWORD iValue, PCHAR lpszValue, PDWORD lpcbValue, PDWORD lpdwReserved, PDWORD lpdwType, PVOID lpbData, PDWORD lpcbData))
MAKE_HEADER(VMMREGRET,cdecl,_RegQueryValueEx, (VMMHKEY hkey, PCHAR lpszValueName, PDWORD lpdwReserved, PDWORD lpdwType, PVOID lpbData, PDWORD lpcbData))
MAKE_HEADER(VMMREGRET,cdecl,_RegSetValueEx, (VMMHKEY hkey, PCHAR lpszValueName, DWORD dwReserved, DWORD fdwType, PVOID lpbData, DWORD cbData))
MAKE_HEADER(VMMREGRET,cdecl,_RegFlushKey, (VMMHKEY hkey))
MAKE_HEADER(VMMREGRET,cdecl,_RegQueryInfoKey, (VMMHKEY hkey, PCHAR lpszClass, PDWORD lpcchClass,PDWORD lpdwReserved, PDWORD lpcSubKeys, PDWORD lpcchMaxSubKey, PDWORD lpcchMaxClass, \
                        PDWORD lpcValues, PDWORD lpcchMaxValueName, PDWORD lpcbMaxValueData,PDWORD lpcbSecurityDesc, PDWORD lpftLastWriteTime))
MAKE_HEADER(VMMREGRET,cdecl,_RegRemapPreDefKey, (VMMHKEY hkey,VMMHKEY hkRootKey))
MAKE_HEADER(ULONG,cdecl,_GetRegistryPath, (PVMMDDB ThisDDB, PVOID pUserBuff, ULONG ulUserBuffSize))
MAKE_HEADER(VMMREGRET,cdecl,_GetRegistryKey, (DWORD dwType, PCHAR lpszDevName, DWORD dwFlags, PVMMHKEY lpHkey))
MAKE_HEADER(VMMREGRET,cdecl,_RegCreateDynKey, (PCHAR lpszSubKey, PVOID pvKeyContext, PVOID pprovHandlerInfo, PVOID ppvalueValueInfo, DWORD cpvalueValueInfo, PVMMHKEY phkResult))
MAKE_HEADER(VMMREGRET,cdecl,_RegQueryMultipleValues, (VMMHKEY hKey,PVOID val_list,DWORD num_vals, PCHAR lpValueBuf, DWORD *ldwTotsize))

#endif  // WIN31COMPAT

#endif  // _VWWREG_H

#ifdef  _VXDLDR_H

typedef struct DeviceInfo   *PDEVICEINFO;
typedef PDEVICEINFO     *PPDEVICEINFO;

WORD VXDINLINE
VXDLDR_GetVersion(VOID)
{
    WORD    w;
    VxDCall(VXDLDR_GetVersion);
    _asm mov [w], ax
    return(w);
}

MAKE_HEADER(VXDLDRRET,_stdcall,VXDLDR_LoadDevice, (PPVMMDDB ppDDB, PPDEVICEINFO ppDeviceHandle, PCHAR Filename, BOOL InitDevice))
MAKE_HEADER(VXDLDRRET,_stdcall,VXDLDR_UnloadDevice, (USHORT DevID, PCHAR szName))
MAKE_HEADER(VXDLDRRET,_stdcall,VXDLDR_DevInitSucceeded, (PDEVICEINFO DeviceHandle))
MAKE_HEADER(VXDLDRRET,_stdcall,VXDLDR_DevInitFailed, (PDEVICEINFO DeviceHandle))
MAKE_HEADER(PDEVICEINFO,_cdecl,VXDLDR_GetDeviceList, (VOID))

#endif  // _VXDLDR_H

#ifdef _VCOMM_H

WORD VXDINLINE
VCOMM_Get_Version(VOID)
{
    WORD    w;
    VxDCall(VCOMM_Get_Version);
    _asm mov [w], ax
    return(w);
}

// VCOMM headers
#ifndef HPORT
    #define HPORT   DWORD
#endif

MAKE_HEADER(BOOL, _cdecl, _VCOMM_Register_Port_Driver, (PFN InitFn))
MAKE_HEADER(ULONG, _cdecl, _VCOMM_Acquire_Port, (HANDLE PHandle, ULONG PortNum, ULONG OwnerVM, ULONG flags, char *PortName))
MAKE_HEADER(void, _cdecl, _VCOMM_Release_Port,(ULONG PortHandle, ULONG OwnerVM))
MAKE_HEADER(HPORT, _cdecl, _VCOMM_OpenComm, (char *PortName, ULONG VMId))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_SetCommState, (HPORT hPort, _DCB *pDcb, DWORD ActionMask))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_GetCommState, (HPORT hPort, _DCB *pDcb))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_SetupComm, (HPORT hPort,BYTE *RxBase, ULONG RxLength, BYTE *TxBase, ULONG TxLength))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_TransmitCommChar, (HPORT hPort, char ch))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_CloseComm, (HPORT hPort))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_GetCommQueueStatus, (HPORT hPort, _COMSTAT *pComStat))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_ClearCommError, (HPORT hPort, _COMSTAT *pComstat, ULONG *perror))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_GetModemStatus, (HPORT hPort, ULONG *pModemStatus))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_GetCommProperties, (HPORT hPort, _COMMPROP *pCommprop))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_EscapeCommFunction, (HPORT hPort, long lFunc, long IData, long OData))
// MAKE_HEADER(BOOL, _cdecl, _VCOMM_DeviceIOControl, (HPORT hPort, long IOCTL, long IData, long cbIData, long OData, long cbOData, long *cbBytesReturned))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_PurgeComm, (HPORT hPort, long QueueType))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_SetCommEventMask, (HPORT hPort, long EvtMask, long *dwEvents))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_GetCommEventMask, (HPORT hPort, long EvtMaskToClear, long *dwEvents))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_WriteComm, (HPORT hPort, char *lpBuf, ULONG ToWrite,ULONG *Written))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_ReadComm, (HPORT hPort, char *lpBuf, long ToRead, long *Read))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_EnableCommNotification, (HPORT hPort, PVOID Fn, long ReferenceData))
MAKE_HEADER(DWORD, _cdecl, _VCOMM_GetLastError, (HPORT hPort))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_Steal_Port, (ULONG PortHandle, ULONG VMHandle))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_SetReadCallBack, (HPORT hPort, ULONG RecvTrigger, PVOID FnReadEvent, ULONG RefData))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_SetWriteCallBack, (HPORT hPort,ULONG SendTrigger, PVOID FnWriteEvent, ULONG RefData))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_Add_Port, (DWORD refData, PFN PortEntry, char *PortName))

#ifndef WIN31COMPAT
MAKE_HEADER(BOOL, _cdecl, _VCOMM_GetSetCommTimeouts, (HPORT hPort, LPCOMMTIMEOUTS lpct, DWORD dwAction))
MAKE_HEADER(IORequest * , _cdecl, _VCOMM_SetWriteRequest, (HPORT hPort, IORequest *ioreq, ULONG *lpNumWritten))
MAKE_HEADER(IORequest *, _cdecl, _VCOMM_SetReadRequest, (HPORT hPort,IORequest *ioreq, ULONG *lpNumRead))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_Dequeue_Request,(DWORD listElement, PDWORD  lpcbTransfer))
MAKE_HEADER(DWORD, _cdecl, _VCOMM_Enumerate_DevNodes, (void))
MAKE_HEADER(PFN, _cdecl, _VCOMM_Get_Contention_Handler, (char *PortName))
MAKE_HEADER(DWORD, _cdecl, _VCOMM_Map_Name_To_Resource, (char *PortName))
#endif

#endif          // _VCOMM_H

#ifdef      _IRS_H
MAKE_HEADER(void, _cdecl, IOS_Requestor_Service, (ULONG p))
#endif      // _IRS_H

#ifdef      _INC_VPOWERD

WORD VXDINLINE
VPOWERD_Get_Version(VOID)
{
    WORD    w;
    VxDCall(_VPOWERD_Get_Version);
    _asm mov [w], ax
    return(w);
}

MAKE_HEADER(DWORD, _cdecl, _VPOWERD_Get_APM_BIOS_Version, (VOID))
MAKE_HEADER(DWORD, _cdecl, _VPOWERD_Get_Power_Management_Level, (VOID))
MAKE_HEADER(POWERRET, _cdecl, _VPOWERD_Set_Power_Management_Level, (DWORD Power_Management_Level))
MAKE_HEADER(POWERRET, _cdecl, _VPOWERD_Set_Device_Power_State, (POWER_DEVICE_ID Power_Device_ID, POWER_STATE Power_State))
MAKE_HEADER(POWERRET, _cdecl, _VPOWERD_Set_System_Power_State, (POWER_STATE Power_State, DWORD Request_Type))
MAKE_HEADER(POWERRET, _cdecl, _VPOWERD_Restore_Power_On_Defaults, (VOID))
MAKE_HEADER(POWERRET, _cdecl, _VPOWERD_Get_Power_Status, (POWER_DEVICE_ID Power_Device_ID, LPPOWER_STATUS pPower_Status))
MAKE_HEADER(POWERRET, _cdecl, _VPOWERD_Get_Power_State, (POWER_DEVICE_ID Power_Device_ID, LPPOWER_STATE pPower_State))
MAKE_HEADER(VOID, _cdecl, _VPOWERD_OEM_APM_Function, (VOID))
MAKE_HEADER(POWERRET, _cdecl, _VPOWERD_Register_Power_Handler, (POWER_HANDLER Power_Handler, DWORD Priority))
MAKE_HEADER(POWERRET, _cdecl, _VPOWERD_Deregister_Power_Handler, (POWER_HANDLER Power_Handler));

#endif      // _INC_VPOWERD

#define _MapPhysToLinear        PREPEND(_MapPhysToLinear)
#define _HeapAllocate           PREPEND(_HeapAllocate)
#define _HeapFree           PREPEND(_HeapFree)
#define _HeapReAllocate         PREPEND(_HeapReAllocate)
#define _HeapGetSize            PREPEND(_HeapGetSize)
#define _Trace_Out_Service      PREPEND(_Trace_Out_Service)
#define _Debug_Out_Service      PREPEND(_Debug_Out_Service)
#define _Debug_Flags_Service        PREPEND(_Debug_Flags_Service)
#define _Debug_Printf_Service       PREPEND(_Debug_Printf_Service)
#define Fatal_Error_Handler     PREPEND(Fatal_Error_Handler)
#define Begin_Critical_Section      PREPEND(Begin_Critical_Section)
#define Schedule_Global_Event       PREPEND(Schedule_Global_Event)
#define Cancel_Global_Event     PREPEND(Cancel_Global_Event)
#define Get_Sys_VM_Handle       PREPEND(Get_Sys_VM_Handle)
#define Get_Profile_Hex_Int     PREPEND(Get_Profile_Hex_Int)
#define Get_Profile_Boolean	PREPEND(Get_Profile_Boolean)
#define Create_Semaphore        PREPEND(Create_Semaphore)
#define Destroy_Semaphore       PREPEND(Destroy_Semaphore)
#define Signal_Semaphore        PREPEND(Signal_Semaphore)
#define Wait_Semaphore          PREPEND(Wait_Semaphore)
#define Get_Execution_Focus     PREPEND(Get_Execution_Focus)
#define Set_VM_Time_Out         PREPEND(Set_VM_Time_Out)
#define Set_Global_Time_Out     PREPEND(Set_Global_Time_Out)
#define Cancel_Time_Out         PREPEND(Cancel_Time_Out)
#define Update_System_Clock     PREPEND(Update_System_Clock)
#define Set_Async_Time_Out      PREPEND(Set_Async_Time_Out)
#define Get_Last_Updated_System_Time    PREPEND(Get_Last_Updated_System_Time)
#define List_Allocate           PREPEND(List_Allocate)
#define List_Attach         PREPEND(List_Attach)
#define List_Attach_Tail        PREPEND(List_Attach_Tail)
#define List_Create         PREPEND(List_Create)
#define List_Deallocate         PREPEND(List_Deallocate)
#define List_Destroy            PREPEND(List_Destroy)
#define List_Get_First          PREPEND(List_Get_First)
#define List_Get_Next           PREPEND(List_Get_Next)
#define List_Insert         PREPEND(List_Insert)
#define List_Remove         PREPEND(List_Remove)
#define List_Remove_First       PREPEND(List_Remove_First)
#define Get_DDB             PREPEND(Get_DDB)
#define Directed_Sys_Control        PREPEND(Directed_Sys_Control)
#define Install_Exeption_Handler    PREPEND(Install_Exeption_Handler)
#define _Assert_Range           PREPEND(_Assert_Range)
#define _Sprintf            PREPEND(_Sprintf)
#define _PageAllocate           PREPEND(_PageAllocate)
#define _PageFree           PREPEND(_PageFree)
#define _AddFreePhysPage        PREPEND(_AddFreePhysPage)
#define Get_Cur_VM_Handle       PREPEND(Get_Cur_VM_Handle)
#define _CreateMutex            PREPEND(_CreateMutex)
#define _DestroyMutex           PREPEND(_DestroyMutex)
#define _EnterMutex         PREPEND(_EnterMutex)
#define _GetMutexOwner          PREPEND(_GetMutexOwner)
#define _LeaveMutex         PREPEND(_LeaveMutex)
#define _SignalID           PREPEND(_SignalID)
#define _BlockOnID          PREPEND(_BlockOnID)
#define _lstrcpyn	    PREPEND(_lstrcpyn)
#define _lstrlen	    PREPEND(_lstrlen)
#define _lmemcpy	    PREPEND(_lmemcpy)
#define VMM_GetSystemInitState      PREPEND(VMM_GetSystemInitState)
#define Get_Boot_Flags          PREPEND(Get_Boot_Flags)
#define Get_Cur_Thread_Handle       PREPEND(Get_Cur_Thread_Handle)
#define	_GetVxDName		PREPEND(_GetVxDName)
#define	_Call_On_My_Stack	PREPEND(_Call_On_My_Stack)
#define	_LinPageLock		PREPEND(_LinPageLock)
#define	_LinPageUnlock		PREPEND(_LinPageUnlock)
#define _SHELL_CallAtAppyTime       PREPEND(_SHELL_CallAtAppyTime)
#define _SHELL_CancelAppyTimeEvent  PREPEND(_SHELL_CancelAppyTimeEvent)
#define _SHELL_QueryAppyTimeAvailable   PREPEND(_SHELL_QueryAppyTimeAvailable)
#define _SHELL_LocalAllocEx     PREPEND(_SHELL_LocalAllocEx)
#define _SHELL_LocalFree        PREPEND(_SHELL_LocalFree)
#define _SHELL_CallDll          PREPEND(_SHELL_CallDll)
#define _SHELL_BroadcastSystemMessage   PREPEND(_SHELL_BroadcastSystemMessage)
#define _SHELL_HookSystemBroadcast  PREPEND(_SHELL_HookSystemBroadcast)
#define _SHELL_UnhookSystemBroadcast    PREPEND(_SHELL_UnhookSystemBroadcast)
#define _SHELL_LoadLibrary      PREPEND(_SHELL_LoadLibrary)
#define _SHELL_FreeLibrary      PREPEND(_SHELL_FreeLibrary)
#define _SHELL_GetProcAddress       PREPEND(_SHELL_GetProcAddress)
#define SHELL_SYSMODAL_Message      PREPEND(SHELL_SYSMODAL_Message)
#define _RegOpenKey         PREPEND(_RegOpenKey)
#define _RegCloseKey            PREPEND(_RegCloseKey)
#define _RegCreateKey           PREPEND(_RegCreateKey)
#define _RegCreateDynKey        PREPEND(_RegCreateDynKey)
#define _RegQueryMultipleValues PREPEND(_RegQueryMultipleValues)
#define _RegDeleteKey           PREPEND(_RegDeleteKey)
#define _RegEnumKey         PREPEND(_RegEnumKey)
#define _RegQueryValue          PREPEND(_RegQueryValue)
#define _RegSetValue            PREPEND(_RegSetValue)
#define _RegDeleteValue         PREPEND(_RegDeleteValue)
#define _RegEnumValue           PREPEND(_RegEnumValue)
#define _RegQueryValueEx        PREPEND(_RegQueryValueEx)
#define _RegSetValueEx          PREPEND(_RegSetValueEx)
#define _RegFlushKey            PREPEND(_RegFlushKey)
#define _RegQueryInfoKey        PREPEND(_RegQueryInfoKey)
#define _RegRemapPreDefKey      PREPEND(_RegRemapPreDefKey)
#define _GetRegistryPath        PREPEND(_GetRegistryPath)
#define _GetRegistryKey         PREPEND(_GetRegistryKey)
#define VXDLDR_LoadDevice       PREPEND(VXDLDR_LoadDevice)
#define VXDLDR_UnloadDevice     PREPEND(VXDLDR_UnloadDevice)
#define VXDLDR_DevInitSucceeded     PREPEND(VXDLDR_DevInitSucceeded)
#define VXDLDR_DevInitFailed        PREPEND(VXDLDR_DevInitFailed)
#define VXDLDR_GetDeviceList        PREPEND(VXDLDR_GetDeviceList)
#define Get_Exec_Path           PREPEND(Get_Exec_Path)
#define CM_Initialize           PREPEND(_CONFIGMG_Initialize)
#define CM_Locate_DevNode       PREPEND(_CONFIGMG_Locate_DevNode)
#define CM_Get_Parent           PREPEND(_CONFIGMG_Get_Parent)
#define CM_Get_Child            PREPEND(_CONFIGMG_Get_Child)
#define CM_Get_Sibling          PREPEND(_CONFIGMG_Get_Sibling)
#define CM_Get_Device_ID_Size       PREPEND(_CONFIGMG_Get_Device_ID_Size)
#define CM_Get_Device_ID        PREPEND(_CONFIGMG_Get_Device_ID)
#define CM_Get_Depth            PREPEND(_CONFIGMG_Get_Depth)
#define CM_Get_Private_DWord        PREPEND(_CONFIGMG_Get_Private_DWord)
#define CM_Set_Private_DWord        PREPEND(_CONFIGMG_Set_Private_DWord)
#define CM_Create_DevNode       PREPEND(_CONFIGMG_Create_DevNode)
#define CM_Query_Remove_SubTree     PREPEND(_CONFIGMG_Query_Remove_SubTree)
#define CM_Remove_SubTree       PREPEND(_CONFIGMG_Remove_SubTree)
#define CM_Register_Device_Driver   PREPEND(_CONFIGMG_Register_Device_Driver)
#define CM_Register_Enumerator      PREPEND(_CONFIGMG_Register_Enumerator)
#define CM_Register_Arbitrator      PREPEND(_CONFIGMG_Register_Arbitrator)
#define CM_Deregister_Arbitrator    PREPEND(_CONFIGMG_Deregister_Arbitrator)
#define CM_Query_Arbitrator_Free_Size   PREPEND(_CONFIGMG_Query_Arbitrator_Free_Size)
#define CM_Query_Arbitrator_Free_Data   PREPEND(_CONFIGMG_Query_Arbitrator_Free_Data)
#define CM_Sort_NodeList        PREPEND(_CONFIGMG_Sort_NodeList)
#define CM_Yield            PREPEND(_CONFIGMG_Yield)
#define CM_Lock             PREPEND(_CONFIGMG_Lock)
#define CM_Unlock           PREPEND(_CONFIGMG_Unlock)
#define CM_Add_Empty_Log_Conf       PREPEND(_CONFIGMG_Add_Empty_Log_Conf)
#define CM_Free_Log_Conf        PREPEND(_CONFIGMG_Free_Log_Conf)
#define CM_Get_First_Log_Conf       PREPEND(_CONFIGMG_Get_First_Log_Conf)
#define CM_Get_Next_Log_Conf        PREPEND(_CONFIGMG_Get_Next_Log_Conf)
#define CM_Add_Res_Des          PREPEND(_CONFIGMG_Add_Res_Des)
#define CM_Modify_Res_Des       PREPEND(_CONFIGMG_Modify_Res_Des)
#define CM_Free_Res_Des         PREPEND(_CONFIGMG_Free_Res_Des)
#define CM_Get_Next_Res_Des     PREPEND(_CONFIGMG_Get_Next_Res_Des)
#define CM_Get_Res_Des_Header_Size  PREPEND(_CONFIGMG_Get_Res_Des_Header_Size)
#define CM_Get_Res_Des_Data_Size    PREPEND(_CONFIGMG_Get_Res_Des_Data_Size)
#define CM_Get_Res_Des_Data     PREPEND(_CONFIGMG_Get_Res_Des_Data)
#define CM_Process_Events_Now       PREPEND(_CONFIGMG_Process_Events_Now)
#define CM_Create_Range_List        PREPEND(_CONFIGMG_Create_Range_List)
#define CM_Add_Range            PREPEND(_CONFIGMG_Add_Range)
#define CM_Delete_Range         PREPEND(_CONFIGMG_Delete_Range)
#define CM_Test_Range_Available     PREPEND(_CONFIGMG_Test_Range_Available)
#define CM_Dup_Range_List       PREPEND(_CONFIGMG_Dup_Range_List)
#define CM_Free_Range_List      PREPEND(_CONFIGMG_Free_Range_List)
#define CM_Invert_Range_List        PREPEND(_CONFIGMG_Invert_Range_List)
#define CM_Intersect_Range_List     PREPEND(_CONFIGMG_Intersect_Range_List)
#define CM_First_Range          PREPEND(_CONFIGMG_First_Range)
#define CM_Next_Range           PREPEND(_CONFIGMG_Next_Range)
#define CM_Dump_Range_List      PREPEND(_CONFIGMG_Dump_Range_List)
#define CM_Load_DLVxDs          PREPEND(_CONFIGMG_Load_DLVxDs)
#define CM_Get_DDBs         PREPEND(_CONFIGMG_Get_DDBs)
#define CM_Get_CRC_CheckSum     PREPEND(_CONFIGMG_Get_CRC_CheckSum)
#define CM_Register_DevLoader       PREPEND(_CONFIGMG_Register_DevLoader)
#define CM_Reenumerate_DevNode      PREPEND(_CONFIGMG_Reenumerate_DevNode)
#define CM_Setup_DevNode        PREPEND(_CONFIGMG_Setup_DevNode)
#define CM_Reset_Children_Marks     PREPEND(_CONFIGMG_Reset_Children_Marks)
#define CM_Get_DevNode_Status       PREPEND(_CONFIGMG_Get_DevNode_Status)
#define CM_Remove_Unmarked_Children PREPEND(_CONFIGMG_Remove_Unmarked_Children)
#define CM_ISAPNP_To_CM         PREPEND(_CONFIGMG_ISAPNP_To_CM)
#define CM_CallBack_Device_Driver   PREPEND(_CONFIGMG_CallBack_Device_Driver)
#define CM_CallBack_Enumerator      PREPEND(_CONFIGMG_CallBack_Enumerator)
#define CM_Get_Alloc_Log_Conf       PREPEND(_CONFIGMG_Get_Alloc_Log_Conf)
#define CM_Get_DevNode_Key_Size     PREPEND(_CONFIGMG_Get_DevNode_Key_Size)
#define CM_Get_DevNode_Key      PREPEND(_CONFIGMG_Get_DevNode_Key)
#define CM_Read_Registry_Value      PREPEND(_CONFIGMG_Read_Registry_Value)
#define CM_Write_Registry_Value     PREPEND(_CONFIGMG_Write_Registry_Value)
#define CM_Disable_DevNode      PREPEND(_CONFIGMG_Disable_DevNode)
#define CM_Enable_DevNode       PREPEND(_CONFIGMG_Enable_DevNode)
#define CM_Move_DevNode         PREPEND(_CONFIGMG_Move_DevNode)
#define CM_Set_Bus_Info         PREPEND(_CONFIGMG_Set_Bus_Info)
#define CM_Get_Bus_Info         PREPEND(_CONFIGMG_Get_Bus_Info)
#define CM_Set_HW_Prof          PREPEND(_CONFIGMG_Set_HW_Prof)
#define CM_Recompute_HW_Prof        PREPEND(_CONFIGMG_Recompute_HW_Prof)
#define CM_Get_Device_Driver_Private_DWord  PREPEND(_CONFIGMG_Get_Device_Driver_Private_DWord)
#define CM_Set_Device_Driver_Private_DWord  PREPEND(_CONFIGMG_Set_Device_Driver_Private_DWord)
#define CM_Query_Change_HW_Prof     PREPEND(_CONFIGMG_Query_Change_HW_Prof)
#define CM_Get_HW_Prof_Flags        PREPEND(_CONFIGMG_Get_HW_Prof_Flags)
#define CM_Set_HW_Prof_Flags        PREPEND(_CONFIGMG_Set_HW_Prof_Flags)
#define CM_Read_Registry_Log_Confs  PREPEND(_CONFIGMG_Read_Registry_Log_Confs)
#define CM_Run_Detection        PREPEND(_CONFIGMG_Run_Detection)
#define CM_Call_At_Appy_Time        PREPEND(_CONFIGMG_Call_At_Appy_Time)
#define CM_Fail_Change_HW_Prof      PREPEND(_CONFIGMG_Fail_Change_HW_Prof)
#define CM_Set_Private_Problem      PREPEND(_CONFIGMG_Set_Private_Problem)
#define CM_Debug_DevNode        PREPEND(_CONFIGMG_Debug_DevNode)
#define CM_Get_Hardware_Profile_Info    PREPEND(_CONFIGMG_Get_Hardware_Profile_Info)
#define CM_Register_Enumerator_Function	PREPEND(_CONFIGMG_Register_Enumerator_Function)
#define CM_Call_Enumerator_Function	PREPEND(_CONFIGMG_Call_Enumerator_Function)
#define CM_Add_ID			PREPEND(_CONFIGMG_Add_ID)
#define CM_Find_Range			PREPEND(_CONFIGMG_Find_Range)
#define CM_Get_Global_State		PREPEND(_CONFIGMG_Get_Global_State)
#define CM_Broadcast_Device_Change_Message	PREPEND(_CONFIGMG_Broadcast_Device_Change_Message)
#define CM_Call_DevNode_Handler		PREPEND(_CONFIGMG_Call_DevNode_Handler)
#define CM_Remove_Reinsert_All			PREPEND(_CONFIGMG_Remove_Reinsert_All)

#ifdef _VCOMM_H
#define VCOMM_Register_Port_Driver      PREPEND(_VCOMM_Register_Port_Driver)
#define VCOMM_Acquire_Port              PREPEND(_VCOMM_Acquire_Port)
#define VCOMM_Release_Port              PREPEND(_VCOMM_Release_Port)
#define VCOMM_OpenComm                  PREPEND(_VCOMM_OpenComm)
#define VCOMM_SetCommState              PREPEND(_VCOMM_SetCommState)
#define VCOMM_GetCommState              PREPEND(_VCOMM_GetCommState)
#define VCOMM_SetupComm                 PREPEND(_VCOMM_SetupComm)
#define VCOMM_TransmitCommChar          PREPEND(_VCOMM_TransmitCommChar)
#define VCOMM_CloseComm                 PREPEND(_VCOMM_CloseComm)
#define VCOMM_GetCommQueueStatus        PREPEND(_VCOMM_GetCommQueueStatus)
#define VCOMM_ClearCommError            PREPEND(_VCOMM_ClearCommError)
#define VCOMM_GetModemStatus            PREPEND(_VCOMM_GetModemStatus)
#define VCOMM_GetCommProperties         PREPEND(_VCOMM_GetCommProperties)
#define VCOMM_EscapeCommFunction        PREPEND(_VCOMM_EscapeCommFunction)
// #define VCOMM_DeviceIOControl           PREPEND(_VCOMM_DeviceIOControl)
#define VCOMM_PurgeComm                 PREPEND(_VCOMM_PurgeComm)
#define VCOMM_SetCommEventMask          PREPEND(_VCOMM_SetCommEventMask)
#define VCOMM_GetCommEventMask          PREPEND(_VCOMM_GetCommEventMask)
#define VCOMM_WriteComm                 PREPEND(_VCOMM_WriteComm)
#define VCOMM_ReadComm                  PREPEND(_VCOMM_ReadComm)
#define VCOMM_EnableCommNotification    PREPEND(_VCOMM_EnableCommNotification)
#define VCOMM_GetLastError              PREPEND(_VCOMM_GetLastError)
#define VCOMM_Steal_Port                PREPEND(_VCOMM_Steal_Port)
#define VCOMM_SetReadCallBack           PREPEND(_VCOMM_SetReadCallBack)
#define VCOMM_SetWriteCallBack          PREPEND(_VCOMM_SetWriteCallBack)
#define VCOMM_Add_Port                  PREPEND(_VCOMM_Add_Port)

#ifndef WIN31COMPAT
#define VCOMM_GetSetCommTimeouts        PREPEND(_VCOMM_GetSetCommTimeouts)
#define VCOMM_SetWriteRequest           PREPEND(_VCOMM_SetWriteRequest)
#define VCOMM_SetReadRequest            PREPEND(_VCOMM_SetReadRequest)
#define VCOMM_Dequeue_Request           PREPEND(_VCOMM_Dequeue_Request)
#define VCOMM_Enumerate_DevNodes        PREPEND(_VCOMM_Enumerate_DevNodes)
#define VCOMM_Get_Contention_Handler    PREPEND(_VCOMM_Get_Contention_Handler)
#define VCOMM_Map_Name_To_Resource  PREPEND(_VCOMM_Map_Name_To_Resource)
#endif
#endif // _VCOMM_H

#ifdef      _IRS_H
#define IOS_Requestor_Service       PREPEND(IOS_Requestor_Service)
#endif      // _IRS_H

#ifdef      _INC_VPOWERD

#define _VPOWERD_Get_APM_BIOS_Version       PREPEND(_VPOWERD_Get_APM_BIOS_Version)
#define _VPOWERD_Get_Power_Management_Level PREPEND(_VPOWERD_Get_Power_Management_Level)
#define _VPOWERD_Set_Power_Management_Level PREPEND(_VPOWERD_Set_Power_Management_Level)
#define _VPOWERD_Set_Device_Power_State     PREPEND(_VPOWERD_Set_Device_Power_State)
#define _VPOWERD_Set_System_Power_State     PREPEND(_VPOWERD_Set_System_Power_State)
#define _VPOWERD_Restore_Power_On_Defaults  PREPEND(_VPOWERD_Restore_Power_On_Defaults)
#define _VPOWERD_Get_Power_Status       PREPEND(_VPOWERD_Get_Power_Status)
#define _VPOWERD_Get_Power_State        PREPEND(_VPOWERD_Get_Power_State)
#define _VPOWERD_OEM_APM_Function       PREPEND(_VPOWERD_OEM_APM_Function)
#define _VPOWERD_Register_Power_Handler     PREPEND(_VPOWERD_Register_Power_Handler)
#define _VPOWERD_Deregister_Power_Handler   PREPEND(_VPOWERD_Deregister_Power_Handler)

#endif      // _INC_VPOWERD

#endif  // _VXDWRAPS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\VXDLDR.H ===
/****************************************************************************
*                                                                           *
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
* KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
* IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
* PURPOSE.                                                                  *
*                                                                           *
* Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
*                                                                           *
****************************************************************************/

/*
;******************************************************************************
;
;   Title:	VXDLDR.H
;
;   Version:	1.00
;
;==============================================================================
*/

#ifndef	_VXDLDR_H
#define	_VXDLDR_H

/*XLATOFF*/
#ifdef __cplusplus
extern "C" {
#endif
/*XLATON*/

#ifndef	Not_VxD

/*XLATOFF*/
#define	VXDLDR_Service	Declare_Service
/*XLATON*/

/*MACROS*/
Begin_Service_Table	(VXDLDR, VxD)
 VXDLDR_Service	(VXDLDR_GetVersion, LOCAL)
 VXDLDR_Service	(VXDLDR_LoadDevice, LOCAL)
 VXDLDR_Service	(VXDLDR_UnloadDevice, LOCAL)
 VXDLDR_Service	(VXDLDR_DevInitSucceeded, LOCAL)
 VXDLDR_Service	(VXDLDR_DevInitFailed, LOCAL)
 VXDLDR_Service	(VXDLDR_GetDeviceList, LOCAL)
 VXDLDR_Service   (VXDLDR_UnloadMe, LOCAL)

 VXDLDR_Service   (_PELDR_LoadModule, VxD_PAGEABLE_CODE)
 VXDLDR_Service   (_PELDR_GetModuleHandle, VxD_PAGEABLE_CODE)
 VXDLDR_Service   (_PELDR_GetModuleUsage, VxD_PAGEABLE_CODE)
 VXDLDR_Service   (_PELDR_GetEntryPoint, VxD_PAGEABLE_CODE)
 VXDLDR_Service   (_PELDR_GetProcAddress, VxD_PAGEABLE_CODE)
 VXDLDR_Service   (_PELDR_AddExportTable, VxD_PAGEABLE_CODE)
 VXDLDR_Service   (_PELDR_RemoveExportTable, VxD_PAGEABLE_CODE)
 VXDLDR_Service   (_PELDR_FreeModule, VxD_PAGEABLE_CODE)

 VXDLDR_Service   (VXDLDR_Notify, LOCAL)

 VXDLDR_Service   (_PELDR_InitCompleted, VXD_PAGEABLE_CODE)
 VXDLDR_Service   (_PELDR_LoadModuleEx, VxD_PAGEABLE_CODE)

End_Service_Table	(VXDLDR, VxD)
/*ENDMACROS*/

#endif


#define	VXDLDR_INIT_DEVICE	0x000000001

/*
* Error codes returned by VXDLDR
*/

#define	VXDLDR_ERR_OUT_OF_MEMORY	1
#define	VXDLDR_ERR_IN_DOS		2
#define	VXDLDR_ERR_FILE_OPEN_ERROR	3
#define	VXDLDR_ERR_FILE_READ		4
#define	VXDLDR_ERR_DUPLICATE_DEVICE	5
#define	VXDLDR_ERR_BAD_DEVICE_FILE	6
#define	VXDLDR_ERR_DEVICE_REFUSED	7
#define	VXDLDR_ERR_NO_SUCH_DEVICE	8
#define	VXDLDR_ERR_DEVICE_UNLOADABLE	9
#define	VXDLDR_ERR_ALLOC_V86_AREA	10
#define	VXDLDR_ERR_BAD_API_FUNCTION	11

#define	VXDLDR_ERR_MAX			11

/*
* VXDLDR_ObjectNotify notification codes
*/
#define	VXDLDR_NOTIFY_OBJECTUNLOAD	0
#define	VXDLDR_NOTIFY_OBJECTLOAD	1

/*
* API entry point function codes
*/
#define	VXDLDR_APIFUNC_GETVERSION	0
#define	VXDLDR_APIFUNC_LOADDEVICE	1
#define	VXDLDR_APIFUNC_UNLOADDEVICE	2

/*
* Structures used by VXDLDR to maintain the list dynamically loaded vxds
*/

struct	ObjectInfo {
 ULONG OI_LinearAddress;	// start addr of object
 ULONG OI_Size;			// size of object in bytes
 ULONG OI_ObjType;			// obj type, defined in loader.h
 ULONG OI_Resident;		// Static object ?
} ;

struct DeviceInfo {
 struct DeviceInfo		*DI_Next;
 UCHAR 			DI_LoadCount;	// Reference Count
 struct VxD_Desc_Block		*DI_DDB;	// pointer to DDB
 USHORT 			DI_DeviceID;
 CHAR 				*DI_ModuleName;	// module name as stored in LE header
 ULONG 			DI_Signature;	// signature to verify the struc
 ULONG 			DI_ObjCount;	// number of objects
 struct ObjectInfo		*DI_ObjInfo;	// pointer to array of ObjectInfos
 ULONG				DI_V86_API_CSIP;// Save area for v86 api entry point
 ULONG				DI_PM_API_CSIP;	// Save area for pm api entry point
} ;

#define	DI_Loaded	DI_LoadCount

struct _W32IoctlPkt {
 USHORT	W32IO_ErrorCode ;
 USHORT	W32IO_DeviceID ;
 UCHAR		W32IO_ModuleName[1] ;
} ;

#ifndef	Not_VxD

/*XLATOFF*/

typedef	DWORD	VXDLDRRET;

#ifndef	WANTVXDWRAPS

#pragma warning (disable:4035)		// turn off no return code warning

WORD VXDINLINE
DL_GetVersion()
{
	VxDCall(VXDLDR_GetVersion);
}

VXDLDRRET VXDINLINE
DL_LoadDevice(struct VxD_Desc_Block **DDB, struct DeviceInfo **DeviceHandle, PCHAR Filename, BOOL InitDevice)
{
	VXDLDRRET	dlResult;

	_asm	mov	edx, Filename
	_asm	mov	eax, InitDevice
	VxDCall(VXDLDR_LoadDevice);
	_asm	mov	dlResult, eax
	_asm	jc	LoadDeviceError
	_asm	mov	ecx, DDB
	_asm	mov	dword ptr [ecx], eax
	_asm	mov	ecx, DeviceHandle
	_asm	mov	dword ptr [ecx], edx
	_asm	mov	dlResult, 0

LoadDeviceError:
	return(dlResult);
}

VXDLDRRET VXDINLINE
DL_UnloadDevice(USHORT DevID, PCHAR szName)
{
	_asm	mov	bx, DevID
	_asm	mov	edx, szName
	VxDCall(VXDLDR_UnloadDevice);
}

VXDLDRRET VXDINLINE
DL_DevInitSucceeded(struct DeviceInfo *DeviceHandle)
{
	_asm	mov	edx, DeviceHandle
	VxDCall(VXDLDR_DevInitSucceeded);
}

VXDLDRRET VXDINLINE
DL_DevInitFailed(struct DeviceInfo *DeviceHandle)
{
	_asm	mov	edx, DeviceHandle
	VxDCall(VXDLDR_DevInitFailed);
}

struct DeviceInfo VXDINLINE
*DL_GetDeviceList()
{
	VxDCall(VXDLDR_GetDeviceList);
}

#pragma warning (default:4035)		// turn on no return code warning

#endif	// WANTVXDWRAPS

/*XLATON*/

#endif	// Not_VxD

//===========================================================================
//                             PELDR definitions...
//===========================================================================

/*XLATOFF*/

// data types

#ifndef DECLARE_HANDLE
#ifdef STRICT
#define DECLARE_HANDLE(name)    struct name##__ { int unused; }; \
                                typedef const struct name##__ * name
#else   /* STRICT */
#define DECLARE_HANDLE(name)    typedef DWORD name
#endif  /* !STRICT */
#endif

#pragma warning (disable:4209)	// turn off redefinition warning

typedef char *               PSTR ;
typedef void                 *PVOID ;
typedef LONG                 LRESULT ;

#pragma warning (default:4209)	// turn off redefinition warning

// generic reference to a module export table...

DECLARE_HANDLE( HPEEXPORTTABLE ) ;
typedef HPEEXPORTTABLE *PHPEEXPORTTABLE ;

// generic reference to module image

DECLARE_HANDLE( HPEMODULE ) ;
typedef HPEMODULE *PHPEMODULE ;

// generic reference to lists

DECLARE_HANDLE( HLIST ) ;
typedef HLIST *PHLIST ;

/*XLATON*/

// manifest constants

#define PELDR_ERR_NOERROR                0L
#define PELDR_ERR_INVALIDHANDLE          -1L
                                         
#define PELDR_ERR_MEM_NOMEMORY           -2L
                                         
#define PELDR_ERR_FILE_UNABLETOOPEN      -3L
#define PELDR_ERR_FILE_READERROR         -4L
                                         
#define PELDR_ERR_IMAGE_INVALIDSIZE      -5L
#define PELDR_ERR_IMAGE_INVALIDFORMAT    -6L
#define PELDR_ERR_IMAGE_UNKNOWNFIXUP     -7L
#define PELDR_ERR_IMAGE_INVALIDFIXUP     -8L
#define PELDR_ERR_IMAGE_UNDEFINEDIMPORT  -9L

#define PELDR_ERR_EXPORT_DUPLICATE       -10L

#define PELDR_ERR_INIT_WASCOMPLETED      -11L

#define PELDR_LOADFLAG_FREERESOURCES    0x00000001

/*XLATOFF*/

// services:

// function prototypes

LRESULT CDECL PELDR_LoadModule
(
    PHPEMODULE      phl,
    PSTR            pFileName,
    PHLIST          phetl
) ;

LRESULT CDECL PELDR_LoadModuleEx
(
    PHPEMODULE      phl,
    PSTR            pFileName,
    PHLIST          phetl,
    DWORD           dwFlags
) ;

HPEMODULE PELDR_GetModuleHandle
(
    PSTR            pFileName
) ;

LRESULT CDECL PELDR_GetModuleUsage
(
    HPEMODULE       hl
) ;

PVOID PELDR_GetEntryPoint
(
    HPEMODULE       hl
) ;

PVOID CDECL PELDR_GetProcAddress
(
    HPEMODULE       hl,
    PVOID           pFuncName,
    PHLIST          phetl
) ;

LRESULT CDECL PELDR_AddExportTable
(
    PHPEEXPORTTABLE     pht,
    PSTR                pszModuleName,
    ULONG               cExportedFunctions,
    ULONG               cExportedNames,
    ULONG               ulOrdinalBase,
    PVOID               *pExportNameList,
    PUSHORT             pExportOrdinals,
    PVOID               *pExportAddrs,
    PHLIST              phetl
) ;

LRESULT CDECL PELDR_RemoveExportTable
(
    HPEEXPORTTABLE      ht,
    PHLIST              phetl
) ;

LRESULT CDECL PELDR_FreeModule
(
    HPEMODULE       hl,
    PHLIST          phetl
) ;

LRESULT CDECL PELDR_InitCompleted
(
    HPEMODULE       hl
) ;

#ifdef __cplusplus
}
#endif

/*XLATON*/

#endif	// _VXDLDR_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\old\SHELLFSC.INC ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1988-1990
;
;   Title:	SHELLFSC.Inc - EQUATES related to the File Sys Change stuff
;
;   Version:	1.00
;
;   Date:	19-Sep-1988
;
;   Author:	ARR
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   19-Sep-1988 ARR Original
;
;==============================================================================

VDA_FileSysChange	EQU	0400H+20+11

;
; On VDA_FileSysChange, wParam is not used
;   Particular VMDOSAPP instance which gets the message is the VM that has
;   changed the file system
;
; NOTE THERE MUST BE A CALL BACK ON THIS EVENT.
;
; The reference data MUST BE A pointer to a structure of the following type:
;
; It is the responsibility of the caller to "FREE" this structure (if needed)
;   on the call back.
;
; Caller can extend this structure if needed by tacking extra info on the end.
;
MAXFSCINFOSIZE		EQU	256

VMDA_FileSysChng  STRUC
VMDA_FSC_Func		dw	?
VMDA_FSC_Buffer 	db	MAXFSCINFOSIZE DUP(?)
VMDA_FileSysChng  ENDS

;
; equates for VMDA_FSC_Func
;
VMDA_FSC_CREATE 	EQU	0
VMDA_FSC_DELETE 	EQU	1
VMDA_FSC_RENAME 	EQU	2
VMDA_FSC_ATTRIBUTES	EQU	3
VMDA_FSC_NETCONNECT	EQU	4
VMDA_FSC_NETDISCONNECT	EQU	5
VMDA_FSC_REFRESH	EQU	6
VMDA_FSC_MKDIR		EQU	7
VMDA_FSC_RMDIR		EQU	8
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\old\V86MMGR.INC ===
;****************************************************************************
;                                                                           *
; THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
; KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
; IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
; PURPOSE.                                                                  *
;                                                                           *
; Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
;                                                                           *
;****************************************************************************

;******************************************************************************
;
;   Title:	V86MMGR.Inc - Public services for V86MMGR
;
;   Version:	2.00
;
;==============================================================================

Begin_Service_Table V86MMGR

V86MMGR_Service 	V86MMGR_Get_Version,		LOCAL
V86MMGR_Service 	V86MMGR_Allocate_V86_Pages,	LOCAL
V86MMGR_Service 	V86MMGR_Set_EMS_XMS_Limits,	LOCAL
V86MMGR_Service 	V86MMGR_Get_EMS_XMS_Limits,	LOCAL
;
;   Services used for API mapping.
;
V86MMGR_Service 	V86MMGR_Set_Mapping_Info, VxD_ICODE
V86MMGR_Service 	V86MMGR_Get_Mapping_Info
V86MMGR_Service 	V86MMGR_Xlat_API
V86MMGR_Service 	V86MMGR_Load_Client_Ptr
V86MMGR_Service 	V86MMGR_Allocate_Buffer
V86MMGR_Service 	V86MMGR_Free_Buffer
V86MMGR_Service 	V86MMGR_Get_Xlat_Buff_State
V86MMGR_Service 	V86MMGR_Set_Xlat_Buff_State
V86MMGR_Service 	V86MMGR_Get_VM_Flat_Sel
V86MMGR_Service 	V86MMGR_Map_Pages
V86MMGR_Service 	V86MMGR_Free_Page_Map_Region
;***********************************************************
;  END OF 3.00 level services
;
V86MMGR_Service 	V86MMGR_LocalGlobalReg
V86MMGR_Service 	V86MMGR_GetPgStatus,		LOCAL
V86MMGR_Service 	V86MMGR_SetLocalA20,		VxD_ICODE
V86MMGR_Service 	V86MMGR_ResetBasePages, 	LOCAL
V86MMGR_Service 	V86MMGR_SetAvailMapPgs, 	VxD_ICODE
V86MMGR_Service 	V86MMGR_NoUMBInitCalls, 	VxD_ICODE

IFNDEF	WIN31COMPAT

;   Services added post Win 3.1
V86MMGR_Service         V86MMGR_Get_EMS_XMS_Avail,      LOCAL
V86MMGR_Service         V86MMGR_Toggle_HMA
V86MMGR_Service 	V86MMGR_Dev_Init,		LOCAL
V86MMGR_Service 	V86MMGR_Alloc_UM_Page,		LOCAL

ENDIF ;	WIN31COMPAT


End_Service_Table V86MMGR

;
; BITS of returned EAX flags for V86MMGR_GetPgStatus
;
V86PS_ROM       equ     0000000000000001b       ; Page contains global ROM
V86PS_RAM       equ     0000000000000010b       ; Page contains global RAM
V86PS_EMM	equ	0000000010000000b	; Page belongs to EMM driver
V86PS_XMS	equ	0000000100000000b	; Page belongs to XMS driver
V86PS_MAP	equ	0000001000000000b	; Page belongs to mapper
V86PS_UMB       equ     0001000000000000b       ; Page contains imported UMB
                                                ;  (Note that V86PS_XMS is not
                                                ;   necessarily set)

;
; BITS of ECX flags for V86MMGR_Allocate_V86_Pages
;
AV86PLocked			EQU	00000000000000000000000000000001B
AV86PLockedBit			EQU	0	; VM memory is to be
						;   ALWAYS LOCKED regardless of
						;   pager type or whether VM
						;   is suspended.
;
; BITS of ECX flags for V86MMGR_Set_EMS_XMS_Limits
;
; NOTE: If neither Limit_DisableHMA or Limit_EnableHMA is set, the HMA
;	state is not altered.
;
EMS_XMS_Limit_DisableHMA	EQU	00000000000000000000000000000001B
EMS_XMS_Limit_DisableHMABit	EQU	0
EMS_XMS_Limit_EnableHMA 	EQU	00000000000000000000000000000010B
EMS_XMS_Limit_EnableHMABit	EQU	1
EMS_XMS_Limit_XMS_Is_Locked	EQU	00000000000000000000000000000100B
EMS_XMS_Limit_XMS_Is_LockedBit	EQU	2
EMS_XMS_Limit_EMS_Is_Locked	EQU	00000000000000000000000000001000B
EMS_XMS_Limit_EMS_Is_LockedBit	EQU	3



;
;   API mapper equates and macros
;

Xlat_Exec_Int	    EQU     000h
Xlat_Fixed_Len	    EQU     001h
Xlat_Var_Len	    EQU     002h
Xlat_Calc_Len	    EQU     003h
Xlat_ASCIIZ	    EQU     004h
Xlat_Jmp_To_Proc    EQU     005h
Xlat_Return_Ptr     EQU     006h
Xlat_Return_Seg     EQU     007h
Xlat_ASCIIZ_InOut   EQU     008h


Xlat_API_Exec_Int MACRO Int_Number
	db	Xlat_Exec_Int
	db	Int_Number
	ENDM

Xlat_API_Fixed_Len MACRO Ptr_Seg, Ptr_Off, Length
	db	Xlat_Fixed_Len
	dw	Length
	dw	(Client_&Ptr_Seg*100h)+Client_&Ptr_Off
	ENDM

Xlat_API_Var_Len MACRO Ptr_Seg, Ptr_Off, Len_Reg
	db	Xlat_Var_Len
	db	Client_&Len_Reg
	dw	(Client_&Ptr_Seg*100h)+Client_&Ptr_Off
	ENDM

Xlat_API_Calc_Len MACRO Ptr_Seg, Ptr_Off, Calc_Proc_Addr
	db	Xlat_Calc_Len
	dd	OFFSET32 Calc_Proc_Addr
	dw	(Client_&Ptr_Seg*100h)+Client_&Ptr_Off
	ENDM

Xlat_API_ASCIIZ  MACRO Ptr_Seg, Ptr_Off
	db	Xlat_ASCIIZ
	dw	(Client_&Ptr_Seg*100h)+Client_&Ptr_Off
	ENDM

Xlat_API_ASCIIZ_InOut  MACRO Ptr_Seg, Ptr_Off
	db	Xlat_ASCIIZ_InOut
	dw	(Client_&Ptr_Seg*100h)+Client_&Ptr_Off
	ENDM

Xlat_API_Jmp_To_Proc MACRO Proc_Name
	db	Xlat_Jmp_To_Proc
	dd	OFFSET32 Proc_Name
	ENDM


Xlat_API_Return_Ptr MACRO Ptr_Seg, Ptr_Off
	db	Xlat_Return_Ptr
	dw	(Client_&Ptr_Seg*100h)+Client_&Ptr_Off
	ENDM

Xlat_API_Return_Seg MACRO Ptr_Seg
	db	Xlat_Return_Seg
	db	Client_&Ptr_Seg
	ENDM

;
; The V86MMGR does W386_Device_Broadcast call outs. The 'subfunction' number
; for these call outs is contained in the CX register. These are the equates
; for the subfunction numbers.
;
V86CallOut_LclA20forGlblHMA	equ	0	; Should A20 state be local
						;   even if HMA is GLOBAL?
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\old\DEBUG.INC ===
;****************************************************************************
;                                                                           *
; THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
; KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
; IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
; PURPOSE.                                                                  *
;                                                                           *
; Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
;                                                                           *
;****************************************************************************

NOBUGBUG	EQU	1










BUGBUG	macro	d, id, note
endm





























IsDebugOnlyLoaded	macro	lab
	local	var, magic
_DBOSTART segment
var	label	byte
_DBOSTART ends
	db	0F7h, 05h
	dd	OFFSET32 magic
magic	dd	OFFSET32 var - (MAXSYSTEMLADDR + 1)
ifnb <lab>
	jz	lab
endif
	endm










DPublic MACRO	arg
if DEBLEVEL GT DEBLEVELRETAIL
	public	arg
endif
        ENDM















Assumes_Fall_Through MACRO L
ifndef MASM6
IF2
 IFDEF profileall
  IF (?prolog_&L - $) GT 3
  %OUT ERROR:  Fall through to &L invalid
  .ERR
  ENDIF
 ELSE
  IF (L - $) GT 3
  %OUT ERROR:  Fall through to &L invalid
  .ERR
  ENDIF
 ENDIF
ENDIF
else
 IFDEF profileall
.errnz ((?prolog_&L - $) GT 3), <ERROR: Fall through to &L invalid>
 ELSE
.errnz ((L - $) GT 3), <ERROR: Fall through to &L invalid>
 ENDIF
endif

     ENDM


ifndef Not_VxD





























??avh_parse_one_arg macro arg
    ifidni <arg>, <USES_FLAGS>
	??_fUsesFlagsPushfd equ <>
	??_fUsesFlagsPopfd equ <>
    elseifnb <arg>
	??_debLevel = arg
    endif
endm

??avh_parse_args macro DL, fUSES_FLAGS
	??_fUsesFlagsPushfd equ <pushfd>
	??_fUsesFlagsPopfd equ <popfd>
	??_debLevel = DEBLEVELNORMAL
	??avh_parse_one_arg <DL>
	??avh_parse_one_arg <fUSES_FLAGS>
endm

Assert_VM_Handle MACRO R, DL, fUSES_FLAGS
	LOCAL l1

IF DEBLEVEL GT DEBLEVELRETAIL

	??avh_parse_args <DL>, <fUSES_FLAGS>

IF DEBLEVEL GE ??_debLevel

IFNDEF WIN31COMPAT
IF DEBLEVEL LT DEBLEVELMAX
	??_fUsesFlagsPushfd
	cmp	[R].CB_Signature, VMCB_ID
	je	SHORT l1
ENDIF
ENDIF

IFDIFI <ebx>,<R>
	push	ebx
	mov	ebx, R
ENDIF
	VMMCall	Debug_Test_Valid_Handle
IFDIFI <ebx>, <R>
	pop	ebx
ENDIF

IFNDEF WIN31COMPAT
IF DEBLEVEL LT DEBLEVELMAX
l1:
	??_fUsesFlagsPopfd
ENDIF
ENDIF

ENDIF

ENDIF
	ENDM




























Assert_Thread_Handle MACRO R, DL, fUSES_FLAGS
	LOCAL l1

IF DEBLEVEL GT DEBLEVELRETAIL

	??avh_parse_args <DL>, <fUSES_FLAGS>

IF DEBLEVEL GE ??_debLevel

IF DEBLEVEL LT DEBLEVELMAX
	??_fUsesFlagsPushfd
	cmp	dword ptr [R.TCB_Signature], SCHED_OBJ_ID_THREAD
	je	SHORT l1
ENDIF

IFDIFI <edi>,<R>
        push    edi
        mov     edi, R
ENDIF
        VMMCall Debug_Test_Valid_Thread_Handle
IFDIFI <edi>,<R>
        pop     edi
ENDIF

IF DEBLEVEL LT DEBLEVELMAX
l1:
	??_fUsesFlagsPopfd
ENDIF

ENDIF

ENDIF
	ENDM

















Assert_Cur_Thread_Handle MACRO R, DL
	LOCAL myDebLevel
	LOCAL	OK

IF DEBLEVEL GT DEBLEVELRETAIL

IFB <DL>
	myDebLevel EQU DEBLEVELNORMAL
ELSE
	myDebLevel EQU <DL>
ENDIF

IF DEBLEVEL GE myDebLevel

IFDIFI <edi>,<R>
        push    edi
        mov     edi, R
ENDIF
        VMMCall Debug_Test_Cur_Thread
IFDIFI <edi>,<R>
        pop     edi
ENDIF

ENDIF

ENDIF
	ENDM













Debug_Printf	macro	fmt, args, dl
	local	fmtlab, myDebLevel

ife ?_DBOCODE
    ??_fDoit = VMM_TRUE
else
    ??_fDoit = FALSE
endif

if DEBLEVEL GT DEBLEVELRETAIL

ifb <dl>
	myDebLevel EQU <DEBLEVELNORMAL>
else
	myDebLevel EQU <dl>
endif

if DEBLEVEL GE myDebLevel
    ??_fDoit = VMM_TRUE
endif

endif

if ??_fDoit

ife ?_DBOCODE

VxD_DEBUG_ONLY_DATA_SEG
fmtlab	db	fmt, 0
VxD_DEBUG_ONLY_DATA_ENDS

else

ifdef VMMSYS

VMM_LOCKED_DATA_SEG
fmtlab	db	fmt, 0
VMM_LOCKED_DATA_ENDS

else

VxD_LOCKED_DATA_SEG
fmtlab	db	fmt, 0
VxD_LOCKED_DATA_ENDS

endif

endif

	ifb <args>
	VMMCall _Debug_Printf_Service, <(OFFSET32 fmtlab), esp>
	else
	VMMCall _Debug_Printf_Service, <(OFFSET32 fmtlab), esp, args>
	endif

endif

	endm







CHECK_EOL MACRO f, x, ln
	ifdifi <x>,<noeol>
	ifdifi <x>,<no_eol>
	ifdifi <x>,<nocrlf>
	ifdifi <x>,</noeol>
		%OUT Line ln: Unknown symbol (x) in f, taken as NOEOL
	endif
	endif
	endif
	endif

ENDM

??_Gen_String macro lbl:req, str:req
	ife ?_ICODE
	    ??_segName textequ <_IDATA>
	elseife ?_PCODE
	    ??_segName textequ <_PDATA>
	elseife ?_SCODE
	    ??_segName textequ <_SDATA>
	elseife ?_DBOCODE
	    ??_segName textequ <_DBODATA>
	else
	    ??_segName textequ <_LDATA>
	endif

	??_segName segment
	    lbl	db	str
	    ife ??_nocrlf
		db	0dh,0ah
	    endif
		db	0
	??_segName ends
endm


??Trace_Debug_Helper macro typ, str, arg1, arg2
	local	string

    ife ?_DBOCODE
	??_fDoit = VMM_TRUE
    else
	??_fDoit = 0
    endif

    if (DEBLEVEL GT DEBLEVELRETAIL) OR ??_fDoit

	??_nocrlf = 0
	??_debLevel = DEBLEVELNORMAL

	irp x, <arg1, arg2>
	    ifnb <x>
		if ((.TYPE x) AND 20h) GT 0
		    ??_debLevel = x
		else
		    Check_EOL <typ>, <x>, %(@Line)
		    ??_nocrlf = 1
		endif
	    endif
	endm

	if DEBLEVEL GE ??_debLevel
	    ??_fDoit = VMM_TRUE
	endif

    endif

    if ??_fDoit

	irpc c, str
	    ifidn <c>, <">
		??_is_string = 1
	    else
	    ifidni <c>, <'>
		??_is_string = 1
	    else
		??_is_string = 0
	    endif
	    endif
	    exitm
	endm

	if ??_is_string
	    ??_Gen_String string, <str>
	    ??_debug_out_str textequ <OFFSET32 string>
	else
	    ??_debug_out_str textequ <str>
	endif

	ifdef WIN31COMPAT
		pushfd
		pushad
		mov	esi, ??_debug_out_str
		VMMCall Out_Debug_String
	    ifidni <typ>, <Debug_Out>
		VMMCall Test_Debug_Installed
		jz	SHORT $+4
		int	1
	    endif
		popad
		popfd
	else
		push	??_debug_out_str
	    ifidni <typ>, <Debug_Out>
		VMMCall _Debug_Out_Service
	    else
		VMMCall _Trace_Out_Service
	    endif
	endif

    endif

	endm
















irp     cond,<S,C,A,AE,B,BE,E,Z,G,GE,L,LE,O>

Trace_Out&cond macro str, arg1, arg2
	?trace_out <str>,jn&cond, <arg1>, <arg2>
	endm

Trace_OutN&cond macro str, arg1, arg2
	?trace_out <str>,j&cond, <arg1>, <arg2>
	endm

endm

Trace_Out MACRO str, arg1, arg2
	??Trace_Debug_Helper <Trace_Out>, <str>, <arg1>, <arg2>
endm

Trace_OutECXZ   macro str, arg1, arg2
	local	l1,l2
if (DEBLEVEL GT DEBLEVELRETAIL) or (?_DBOCODE eq 0)
	jecxz	l1
	jmp	short l2
l1:	Trace_Out <str>, <arg1>, <arg2>
l2:
endif
	endm

Trace_OutECXNZ macro str, arg1, arg2
	?trace_out <str>,jecxz, <arg1>, <arg2>
	endm

Trace_OutEAXz macro str, arg1, arg2
	local	l1
if (DEBLEVEL GT DEBLEVELRETAIL) or (?_DBOCODE eq 0)
	or	eax,eax
	jnz	short l1
	Trace_Out <str>, <arg1>, <arg2>
l1:
endif
	endm

Trace_OutEAXnz macro str, arg1, arg2
	local	l1
if (DEBLEVEL GT DEBLEVELRETAIL) or (?_DBOCODE eq 0)
	or	eax,eax
	jz	short l1
	Trace_Out <str>, <arg1>, <arg2>
l1:
endif
	endm

?trace_out macro str, jmpop, arg1, arg2
	Local	nomsg
if (DEBLEVEL GT DEBLEVELRETAIL) or (?_DBOCODE eq 0)
	jmpop	short nomsg
	Trace_Out <str>,<arg1>,<arg2>
nomsg:
endif
	endm


















irp	cond,<S,C,A,AE,B,BE,E,Z,G,GE,L,LE,O>

Debug_Out&cond &macro str, arg1
	?debug_out <str>,jn&cond,<arg1>
	&endm

Debug_OutN&cond &macro str, arg1
	?debug_out <str>,j&cond,<arg1>
	&endm

endm

Debug_Out MACRO str, arg1, arg2
	??Trace_Debug_Helper <Debug_Out>, <str>, <arg1>, <arg2>
endm

Debug_OutECXZ	macro str, arg1
	local	l1,l2
if DEBLEVEL GT DEBLEVELRETAIL
	jecxz	l1
	jmp	short l2
l1:	Debug_Out <str>, <arg1>
l2:
endif
	endm

Debug_OutECXNZ macro str, arg1
	?debug_out <str>,jecxz, <arg1>
	endm

Debug_OutEAXz macro str, arg1
	local	l1
if DEBLEVEL GT DEBLEVELRETAIL
	or	eax,eax
	jnz	short l1
	Debug_Out <str>, <arg1>
l1:
endif
	endm

Debug_OutEAXnz macro str, arg1
	local	l1
if DEBLEVEL GT DEBLEVELRETAIL
	or	eax,eax
	jz	short l1
	Debug_Out <str>, <arg1>
l1:
endif
	endm

?debug_out macro str,jmpop, arg1
	Local	nomsg
if DEBLEVEL GT DEBLEVELRETAIL
	jmpop	short nomsg
	Debug_Out <str>, <arg1>
nomsg:
endif
	endm








Queue_Out MACRO S, V1, V2, DL
	LOCAL	Str_Off
	LOCAL MyDebLevel

IF DEBLEVEL GT DEBLEVELRETAIL

IFB <DL>
	myDebLevel = DEBLEVELNORMAL
ELSE
	myDebLevel = DL
ENDIF

IF DEBLEVEL GE myDebLevel

_LDATA SEGMENT
Str_Off db S, 0dh,0ah, 0
_LDATA ENDS

	push	esi
IFNB <V1>
    IF	TYPE V1 GT 0
	push	dword ptr V1
    ELSE
	push	V1
    ENDIF
ELSE
	push	eax
ENDIF
IFNB <V2>
    IF	TYPE V2 GT 0
	push	dword ptr V2
    ELSE
	push	V2
    ENDIF
ELSE
	push	ebx
ENDIF
	mov	esi, OFFSET32 Str_Off
	VMMCall Queue_Debug_String
	pop	esi
ENDIF

ENDIF
	ENDM








Mono_Out MACRO S, nocrlf
	LOCAL	Str_Off
IF DEBLEVEL GT DEBLEVELRETAIL
_LDATA SEGMENT
Str_Off db	S
IFB <nocrlf>
	db	0dh,0ah
ENDIF
	db	0
_LDATA ENDS

	pushfd
	pushad
	mov	esi, OFFSET32 Str_Off
	VMMCall Out_Mono_String
	popad
	popfd
ENDIF
	ENDM








Mono_Out_At MACRO Row, Col, S, nocrlf
	LOCAL	Str_Off
IF DEBLEVEL GT DEBLEVELRETAIL
_LDATA SEGMENT
Str_Off db	S
IFB <nocrlf>
	db	0dh,0ah
ENDIF
	db	0
_LDATA ENDS

	pushfd
	pushad
	mov	dx, (Row SHL 8)+Col
	VMMCall Set_Mono_Cur_Pos
	mov	esi, OFFSET32 Str_Off
	VMMCall Out_Mono_String
	popad
	popfd
ENDIF
	ENDM










Assert_Ints_Disabled MACRO DL

IFB <DL>
	??_debLevel = DEBLEVELNORMAL
ELSE
	??_debLevel = DL
ENDIF

IF DEBLEVEL GE ??_debLevel

ifndef ??_aidMessage
	_LDATA segment
	??_aidMessage	db	"ERROR:  Ints enabled at Assert_Ints_Disabled"
			db	0Dh, 0Ah, 0
	_LDATA ends
endif
	pushfd
	test	byte ptr [esp+1], IF_Mask SHR 8
    .if	!ZERO?
	push	OFFSET32 ??_aidMessage
	VMMCall _Debug_Out_Service
    .endif
	popfd
ENDIF
	ENDM








Assert_Ints_Enabled MACRO DL

IFB <DL>
	??_debLevel = DEBLEVELNORMAL
ELSE
	??_debLevel = DL
ENDIF

IF DEBLEVEL GE ??_debLevel

ifndef ??_aieMessage
	_LDATA segment
	??_aieMessage	db	"ERROR:  Ints disabled at Assert_Ints_Enabled"
			db	0Dh, 0Ah, 0
	_LDATA ends
endif
	pushfd
	test	byte ptr [esp+1], IF_Mask SHR 8
    .if	ZERO?
	push	OFFSET32 ??_aieMessage
	VMMCall _Debug_Out_Service
    .endif
	popfd
ENDIF
	ENDM

















Assert_Cur_VM_Handle MACRO R, DL
	LOCAL	OK
	LOCAL myDebLevel

IF DEBLEVEL GT DEBLEVELRETAIL

IFB <DL>
	myDebLevel = DEBLEVELNORMAL
ELSE
	myDebLevel = DL
ENDIF

IF DEBLEVEL GE myDebLevel

IFDIFI <ebx>,<R>
	push	ebx
	mov	ebx, R
ENDIF
	VMMCall Debug_Test_Cur_VM
IFDIFI <ebx>,<R>
	pop	ebx
ENDIF

ENDIF

ENDIF
	ENDM


Assert_Client_Ptr MACRO Reg, DL
	LOCAL myDebLevel
IF DEBLEVEL GT DEBLEVELRETAIL

IFB <DL>
	myDebLevel = DEBLEVELNORMAL
ELSE
	myDebLevel = DL
ENDIF

IF DEBLEVEL GE myDebLevel
IFDIFI <ebp>,<Reg>
	push	ebp
	mov	ebp, Reg
ENDIF
	VMMCall Validate_Client_Ptr
IFDIFI <ebp>,<Reg>
	pop	ebp
ENDIF
ENDIF

ENDIF
	ENDM

endif























irp	cond,<s,c,a,ae,b,be,e,z,g,ge,l,le,o>

TRAP&cond &macro
	?trap	jn&cond
	&endm

TRAPn&cond &macro
	?trap	j&cond
	&endm

TRAPFATAL&cond &macro
	?trap	jn&cond, FATAL
	&endm

TRAPFATALn&cond &macro
	?trap	j&cond, FATAL
	&endm
endm

TRAP	macro
if DEBLEVEL GT DEBLEVELRETAIL
	int	3
endif
	endm

TRAPFATAL	macro
	local	l
if DEBLEVEL GT DEBLEVELRETAIL
l:	int	3
	jmp	short l
endif
	endm

TRAPecxz macro
	local	l1,l2
if DEBLEVEL GT DEBLEVELRETAIL
	jecxz	l1
	jmp	short l2
l1:	int	3
l2:
endif
	endm

TRAPecxnz macro
	?trap	jecxz
	endm

?trap	macro	jmpop, fatal
	Local	l, n
if DEBLEVEL GT DEBLEVELRETAIL
	jmpop	short n
l:	int	3
ifnb	<fatal>
	jmp	short l
endif
n:
endif
	endm

ifndef Not_VxD




Dump_Struc_Head MACRO
if DEBLEVEL GT DEBLEVELRETAIL
	Trace_Out "  Base    Address   Offs     Value  Field name"
ENDIF
	ENDM

Dump_Struc MACRO Base, X
if DEBLEVEL GT DEBLEVELRETAIL
	pushfd
	pushad
	lea	esi, [Base]
	mov	ecx, X
	lea	edx, [esi+ecx]

IF SIZE X EQ 6
	mov	bx, WORD PTR [edx+4]
	mov	eax, DWORD PTR [edx]
	Trace_Out "#ESI  #EDX  #CX  #BX:#EAX  &X"
ELSE
IF SIZE X EQ 4
	mov	eax, DWORD PTR [edx]
	Trace_Out "#ESI  #EDX  #CX  #EAX  &X"
ELSE
IF SIZE X EQ 2
	mov	ax, WORD PTR [edx]
	Trace_Out "#ESI  #EDX  #CX      #AX  &X"
ELSE
	mov	al, BYTE PTR [edx]
	Trace_Out "#ESI  #EDX  #CX        #AL  &X"
ENDIF
ENDIF
ENDIF

	popad
	popfd
ENDIF
	ENDM

BeginDoc



























EndDoc

Begin_Touch_1st_Meg MACRO DL
	LOCAL myDebLevel
IF DEBLEVEL GT DEBLEVELRETAIL
IFB <DL>
	myDebLevel = DEBLEVELMAX
ELSE
	myDebLevel = DL
ENDIF
IF DEBLEVEL GE myDebLevel
	VMMCall Enable_Touch_1st_Meg
ENDIF
ENDIF
	ENDM



End_Touch_1st_Meg MACRO DL
	LOCAL myDebLevel
IF DEBLEVEL GT DEBLEVELRETAIL
IFB <DL>
	myDebLevel = DEBLEVELMAX
ELSE
	myDebLevel = DL
ENDIF
IF DEBLEVEL GE myDebLevel
	VMMCall Disable_Touch_1st_Meg
ENDIF
ENDIF
	ENDM

endif

IFDEF	DEBUG
TrashThis Macro	l:vararg
    ?TrashThisVal equ <0FFFFFF80h>
    ?TrashThisValSet = 0
    for r, <l>
	or	r, ?TrashThisVal
      ife ?TrashThisValSet
        if (OPATTR r) and 10h
	    ?TrashThisVal equ <r>
	    ?TrashThisValSet = 1
	endif
      endif
    endm
endm
ELSE
TrashThis Macro	l:vararg
endm
ENDIF


ifndef Not_VxD

if DEBLEVEL GT DEBLEVELRETAIL

ENTER_NOBLOCK MACRO
	push	DFS_ENTER_NOBLOCK
	VMMCall _Debug_Flags_Service
	ENDM

EXIT_NOBLOCK MACRO
	push	DFS_EXIT_NOBLOCK
	VMMCall _Debug_Flags_Service
	ENDM

Assert_CLD MACRO
	pushfd
	test	dword ptr [esp], DF_MASK
	Debug_OutNZ "Direction flag is not clear."
	popfd
	ENDM

Assert_Might_Block MACRO
	push	DFS_TEST_BLOCK
	VMMCall _Debug_Flags_Service
	ENDM

Assert_Not_Nest_Exec MACRO
	push	DFS_TEST_NEST_EXEC
	VMMCall _Debug_Flags_Service
	ENDM

ELSE

ENTER_NOBLOCK EQU <>
EXIT_NOBLOCK EQU <>
Assert_CLD EQU <>
Assert_Might_Block EQU <>
Assert_Not_Nest_Exec EQU <>

ENDIF


ifdef Begin_Service_Table
Begin_Service_Table DEBUG
DEBUG_Service	 DEBUG_Get_Version, LOCAL
DEBUG_Service	 DEBUG_Fault, LOCAL
DEBUG_Service	 DEBUG_CheckFault, LOCAL
DEBUG_Service	 _DEBUG_LoadSyms
End_Service_Table DEBUG
endif
endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\old\VDD.INC ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1988-1990
;
;   Title:	vdd.inc - VDD definitions for other VxD's and multiple VDD's
;
;   Version:	1.00
;
;   Date:
;
;   Author: AR, MDW
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   24-Jan-1989 MDW Added service definitions
;==============================================================================


Begin_Service_Table VDD

;***************
;VDD protect mode services for other devices and VMM(Get_Version must be first)
;
VDD_Service	VDD_Get_Version 	; Get version number and ID string ptr
VDD_Service	VDD_PIF_State		; Pass video PIF bits to VDD
VDD_Service	VDD_Get_GrabRtn 	; Get routine addr for video grab
VDD_Service	VDD_Hide_Cursor 	; Hide cursor when display is windowed
VDD_Service	VDD_Set_VMType		; Set VM type(windowed, bckgrnd, excl)
VDD_Service	VDD_Get_ModTime 	; Return system time of last mod
VDD_Service	VDD_Set_HCurTrk 	; Track horiz cursor movement in window
VDD_Service	VDD_Msg_ClrScrn 	; Clear screen for sysmodal message
VDD_Service	VDD_Msg_ForColor	; Set Msg_TextOut forground color
VDD_Service	VDD_Msg_BakColor	; Set Msg_TextOut background color
VDD_Service	VDD_Msg_TextOut 	; Output a string
VDD_Service	VDD_Msg_SetCursPos	; Set cursor position
VDD_Service	VDD_Query_Access	; Is it OK to access video now?

; New services for 3.1	Not supported for 3.0 VDD's
;
VDD_Service	VDD_Check_Update_Soon,,VGA31 ; User action may update screen

End_Service_Table VDD

IFDEF VGA31
VDD_VerNum	EQU	030Ah		; version 3, 10
ELSE
VDD_VerNum	=	0300h

IFDEF DEBUG
IFNDEF VGA
IFNDEF EGA
VDD_VerNum = VDD_VerNum + 0FFh
ENDIF ;EGA
ENDIF ;VGA
ENDIF ;DEBUG

ENDIF	;VGA31

;***************
; PIF_State service definitions
;
; These definitions cannot change without changing the PIF editor!!!
;
fVidTxtEmulate	EQU	0001h		; Do INT 10h TTY and cursor emulation
fVidNoTrpTxt	EQU	0002h		; Do not trap text mode apps
fVidNoTrpLRGrfx EQU	0004h		; Do not trap lo res graphics mode apps
fVidNoTrpHRGrfx EQU	0008h		; Do not trap hi res graphics mode apps
fVidTextMd	EQU	0010h		; Allocate text mode mem
fVidLowRsGrfxMd EQU	0020h		; Allocate lo res graphics mode mem
fVidHghRsGrfxMd EQU	0040h		; Allocate hi res graphics mode mem
fVidRetainAllo	EQU	0080h		; Never deallocate once allocated
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\old\CMACROS.INC ===
IFNDEF MASM6
comment $
cmacros - assembly macros for interfacing to hlls
(C)Copyright Microsoft Corp. 1984-1994
$
.xcref
.xcref ??_out
??_out macro t
ifndef ?QUIET
%out t
endif
endm
outif macro name,defval,onmsg,offmsg
ifndef name
ifb <defval>
name=0
else
name=defval
endif
endif
if name
name=1
ifnb <onmsg>
??_out <! onmsg>
endif
else
ifnb <offmsg>
??_out <! offmsg>
endif
endif
endm
.xcref ??error
??error macro msg
e r r o r ----- msg
.err
endm
.xcref ASMpass
.xcref memS,memM,memL,memC,memH,memMOD,sizec,sized
if1
ASMpass=1
ifdef ?SMALL
memS=1
endif
ifdef ?MEDIUM
memM=1
endif
ifdef ?COMPACT
memC=1
endif
ifdef ?LARGE
memL=1
endif
ifdef ?HUGE
memH=1
endif
??_out <cMacros Version 5.20 - Copyright (c) Microsoft Corp. 1984-1988>
outif memS,0,<Small model>
outif memM,0,<Medium model>
outif memL,0,<Large model>
outif memC,0,<Compact model>
outif memH,0,<Huge model>
memMOD= memS + memM + memL + memC + memH
if memMOD ne 1
if memMOD eq 0
memS = 1
else
??error <more than 1 memory model selected>
endif
endif
sizec= memM + memL + memH
sized= memL + memC + (memH*2)
outif ?DF,0,<No segments or groups will be defined>
outif ?TF,0,<Epilog sequences assume valid SP>
outif ?WIN,1,<Windows support>
ifdef PMODE
?pmd=1
??_out <! 286 protect mode>
else
?pmd=0
endif
ifdef ?386regs
if ?386regs
??_out <! 386 registers enabled>
endif
else
?386regs=0
endif
if ?WIN eq 1
outif ?PLM,1,<>
else
outif ?PLM,1,<Pascal calling convention>
endif
ifndef ?NODATA
?nodata1=0
else
?nodata1=1
??_out <! NODATA module>
endif
ifndef ?CHKSTK
?chkstk1=0
else
?chkstk1=1
ifdef ?CHKSTKPROC
??_out <! Private stack checking enabled>
else
??_out <! Stack checking enabled>
endif
endif
ifndef DOS5
?DOS5=0
else
?DOS5=1
??_out <! DOS5 module>
endif
ifdef ?PROFILE
??_out <! Native profiling enabled>
endif
else
ASMpass=2
endif
ifdef ?pmd
.286p
endif
if ?386regs
.xcref ?n,?ax,?eax,?bx,?ebx
.xcref ?cx,?ecx,?dx,?edx
.xcref ?si,?esi,?di,?edi,?es,?ds,?fs
.xcref ?gs
else
.xcref ?n,?ax,?ah,?al,?bx,?bh
.xcref ?bl,?cx,?ch,?cl,?dx,?dh
.xcref ?dl,?si,?di,?es,?ds,?bp
.xcref ?sp,?ss,?cs
endif
.xcref ?rsl,?cpd,?argl,?argc,?ba
.xcref ?acb,???,?po
.xcref ?pas,?pc
.xcref uconcat,mpush,mpop
.xcref ?ri,?pp,?pp1,?al1
.xcref ?ad,?ap,?atal,?dd,?dd1,?dd2
.xcref ?pg,?pg1,?aloc,?cs1,?cs2
.xcref ?DF,?TF,?ff,?PLM,?WIN,?ia,?pu,?adj
.xcref ?uf,?rp,?nx,?nd,?nodata1,?chkstk1,?DOS5,?pmd,?lds,?exp
.xcref ?wfp,arg,cCall,cProc,assumes,?cs3,?cs2,?cs1
.xcref defgrp,addseg,createSeg
.xcref save,outif,errnz,errn$,errnz1
.xcref ?PLMPrevParm,?gcc
.xcref ?cCall1,?pcc
?rsl = 0
?cpd = 0
?argl = 0
?argc = 0
?ba = 0
?acb = 0
??? = 0
?po = 0
?pas = 0
?pc = 0
?ia = 0
?pu = 0
?adj = 0
?rp = 0
?uf = 0
?nd = 0
?nx = 0
?wfp = 0
?lds = 0
?exp = 0
?ff = 0
?dd2 = 0
?cCall1 = 0
?pcc = 0
?PLMPrevParm = 0
.xcref ?casen
if1
?casen = 0
endif
if ?386regs
?n = 0000000000000000b
?ax = 0000000000000001b
?eax = 0000000000000010b
?bx = 0000000000000100b
?ebx = 0000000000001000b
?cx = 0000000000010000b
?ecx = 0000000000100000b
?dx = 0000000001000000b
?edx = 0000000010000000b
?si = 0000000100000000b
?esi = 0000001000000000b
?di = 0000010000000000b
?edi = 0000100000000000b
?ds = 0001000000000000b
?es = 0010000000000000b
?fs = 0100000000000000b
?gs = 1000000000000000b
else
?n = 0000000000000000b
?ax = 0000000000000011b
?ah = 0000000000000001b
?al = 0000000000000010b
?bx = 0000000000001100b
?bh = 0000000000000100b
?bl = 0000000000001000b
?cx = 0000000000110000b
?ch = 0000000000010000b
?cl = 0000000000100000b
?dx = 0000000011000000b
?dh = 0000000001000000b
?dl = 0000000010000000b
?si = 0000000100000000b
?di = 0000001000000000b
?es = 0000010000000000b
?ds = 0000100000000000b
?bp = 0001000000000000b
?sp = 0010000000000000b
?ss = 0100000000000000b
?cs = 1000000000000000b
endif
.cref
uconcat macro a,b,c,d,e,f,g
a&b c&d e&f&g
endm
if ?386regs
mpush macro r
irp x,<ax,eax,bx,ebx,cx,ecx,dx,edx,si,esi,di,edi,ds,es,fs,gs>
if (r and ?&&x)
	push	x
endif
endm
endm
else
mpush macro r
irp x,<ax,bx,cx,dx,si,di,es,ds,bp,sp,ss,cs>
if (r and ?&&x)
	push	x
endif
endm
endm
endif
if ?386regs
mpop macro r
irp x,<gs,fs,es,ds,edi,di,esi,si,edx,dx,ecx,cx,ebx,bx,eax,ax>
if (r and ?&&x)
	pop	x
endif
endm
endm
else
mpop macro r
irp x,<cs,ss,sp,bp,ds,es,di,si,dx,cx,bx,ax>
if (r and ?&&x)
	pop	x
endif
endm
endm
endif
save macro r
?rsl=0
?ri ?rsl,<r>
endm
?ri macro n,r
irp x,<r>
.ERRNDEF ?&&x
n=n or ?&&x
endm
endm
.xcref
.xcref parmB,parmW,parmD,parmQ,parmT,parmCP,parmDP
.cref
parmB macro n
?pp <n>,<byte>,2,1
endm
parmW macro n
?pp <n>,<word>,2,2
endm
parmD macro n
ife ?PLM
irp x,<n>
?pp <&&x>,<dword>,0,4
?pp <off_&&x>,<word>,2,2
?pp <seg_&&x>,<word>,2,2
endm
else
irp x,<n>
?pp <seg_&&x>,<word>,2,2
?pp <off_&&x>,<word>,2,2
?pp <&&x>,<dword>,0,4
endm
endif
endm
parmQ macro n
?pp <n>,<qword>,8,8
endm
parmT macro n
?pp <n>,<tbyte>,10,10
endm
if sizec
parmCP macro n
parmD <n>
endm
else
parmCP macro n
parmW <n>
endm
endif
if sized
parmDP macro n
parmD <n>
endm
else
parmDP macro n
parmW <n>
endm
endif
?pp macro n,t,l,s
if ?cpd
.xcref
irp x,<n>
.xcref ?t&&x
?t&&x=s
ife ?PLM
?pp1 x,<t>,,,%(?po+?adj)
?po=?po+l
else
?PLMPrevParm=?PLMPrevParm+1
?po=?po+l
?pp1 x,<t>,%?po,%?adj,,%?PLMPrevParm,%(?PLMPrevParm-1)
endif
endm
.cref
else
??error <parm(s) "&n" declared outside proc def>
endif
endm
?pp1 macro n,t,o,a,b,cpc,ppc
ife ?PLM
n equ (t ptr [bp+b])
else
.xcref
.xcref ?PLMParm&cpc
.cref
?PLMParm&cpc &macro po
uconcat <n>,,<equ>,,<(t ptr [bp+>,%(a+po-o),<])>
?PLMParm&ppc po
purge ?PLMParm&cpc
&endm
endif
endm
ifndef ?NOPARMR
if ?pmd
parmR macro n,r,r2
??error <Sorry: ParmR can't be used with PMODE=1>
endm
else
.xcref
.xcref ?pr,parmR
.cref
parmR macro n,r,r2
?pr n,r,r2,%?rp,%(?ia+2)
endm
?pr macro n,r,r2,i,o
.xcref
ifnb <r2>
parmR seg_&n,r
parmR off_&n,r2
n equ (dword ptr [bp-o-2])
.xcref ?t&n
?t&n=4
else
.xcref ?rp&i
?rp&i=0
ifdef ?&r
?rp&i=?&r
endif
if ??? or (?cpd eq 0) or (?rp&i eq 0)
??error <invalid parmR encountered: &n,&r>
exitm
endif
n equ (word ptr [bp-o])
?t&n=2
irp x,<bh,ch,dh,bl,cl,dl,ah,al>
if ?&&x eq ?&r
n equ (byte ptr [bp-o])
?t&n=1
exitm
endif
endm
?ia=?ia+2
?rp=?rp+1
endif
.cref
endm
endif
endif
.xcref
.xcref localB,localW,localD,localQ,localT,localCP,localDP,localV
.cref
localB macro n
?aloc <n>,<byte ptr>,1,1,0
endm
localW macro n
?aloc <n>,<word ptr>,2,2,1
endm
localD macro n
irp x,<n>
?aloc <seg_&&x>,<word ptr>,2,2,1
?aloc <off_&&x>,<word ptr>,2,2,1
?aloc <&&x>,<dword ptr>,0,4,1
endm
endm
localQ macro n
?aloc <n>,<qword ptr>,8,8,1
endm
localT macro n
?aloc <n>,<tbyte ptr>,10,10,1
endm
if sizec
localCP macro n
localD <n>
endm
else
localCP macro n
localW <n>
endm
endif
if sized
localDP macro n
localD <n>
endm
else
localDP macro n
localW <n>
endm
endif
localV macro n,a
?aloc <n>,,%(a),0,1
endm
?aloc macro n,t,l,s,a
if ?cpd
.xcref
irp x,<n>
???=???+l
if a
???=((??? + 1) and 0fffeh)
endif
?al1 x,<t>,%(???+?ia)
.xcref ?t&&x
?t&&x=s
endm
.cref
else
??error <locals "&n" declared outside procedure def>
endif
endm
?al1 macro n,t,o
n equ (t [bp-o])
endm
?gcc macro s,i,cc
s = i
ifnb <cc>
ifidn <cc>,<C>
s=0
endif
ifidn <cc>,<PLM>
s=1
endif
ifidn <cc>,<PASCAL>
s=1
endif
endif
endm
ifndef ?NOGLOBAL
.xcref
.xcref globalB,globalW,globalD,globalQ,globalT,globalCP,globalDP
.cref
globalB macro n,i,s,c
?ad <n>,1
?dd n,1,<byte>,<db>,<i>,<s>,<c>
endm
globalW macro n,i,s,c
?ad <n>,2
?dd n,1,<word>,<dw>,<i>,<s>,<c>
endm
globalD macro n,i,s,c
?ad <n>,4
?dd n,1,<dword>,<dd>,<i>,<s>,<c>
off_&n equ n
seg_&n equ n[2]
endm
globalQ macro n,i,s,c
?ad <n>,8
?dd n,1,<qword>,<dq>,<i>,<s>,<c>
endm
globalT macro n,i,s,c
?ad <n>,10
?dd n,1,<tbyte>,<dt>,<i>,<s>,<c>
endm
if sizec
globalCP macro n,i,s,c
globalD n,<i>,<s>,<c>
endm
else
globalCP macro n,i,s,c
globalW n,<i>,<s>,<c>
endm
endif
if sized
globalDP macro n,i,s,c
globalD n,<i>,<s>,<c>
endm
else
globalDP macro n,i,s,c
globalW n,<i>,<s>,<c>
endm
endif
endif
ifndef ?NOSTATIC
.xcref
.xcref staticB,staticW,staticD,staticQ,staticT,staticCP,staticDP
.cref
staticB macro n,i,s
?ad <n>,1
?dd n,0,<byte>,<db>,<i>,<s>,<PLM>
endm
staticW macro n,i,s
?ad <n>,2
?dd n,0,<word>,<dw>,<i>,<s>,<PLM>
endm
staticD macro n,i,s
?ad <n>,4
?dd n,0,<dword>,<dd>,<i>,<s>,<PLM>
endm
staticQ macro n,i,s
?ad <n>,8
?dd n,0,<qword>,<dq>,<i>,<s>,<PLM>
endm
staticT macro n,i,s
?ad <n>,10
?dd n,0,<tbyte>,<dt>,<i>,<s>,<PLM>
endm
if sizec
staticCP macro n,i,s
staticD n,<i>,<s>
endm
else
staticCP macro n,i,s
staticW n,<i>,<s>
endm
endif
if sized
staticDP macro n,i,s
staticD n,<i>,<s>
endm
else
staticDP macro n,i,s
staticW n,<i>,<s>
endm
endif
endif
?dd macro n,p,t,d,i,s,c
?gcc ?dd2,%?PLM,<c>
ife ?dd2
n label t
?dd1 _&n,p,<d>,<i>,<s>
else
?dd1 n,p,<d>,<i>,<s>
endif
endm
?dd1 macro n,p,d,i,s
if p
public n
endif
ifb <s>
n d i
else
ifb <i>
n d s dup (?)
else
n d s dup (i)
endif
endif
endm
ifndef ?NOEXTERN
.xcref
.xcref ?ex1,?ex2,externB,externW,externD,externQ,externT
.xcref externNP,externFP,externP,externCP,externDP,externA
.cref
?ex2 = 0
externA macro n,c
?ex1 <n>,40h,<abs>,<c>,<>
endm
externB macro n,c
?ex1 <n>,1,<byte>,<c>,<>
endm
externW macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
externD macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
externQ macro n,c
?ex1 <n>,8,<qword>,<c>,<>
endm
externT macro n,c
?ex1 <n>,10,<tbyte>,<c>,<>
endm
externNP macro n,c
?ex1 <n>,2,<near>,<c>,<cc>
endm
externFP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
if sizec
externP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
else
externP macro n,c
?ex1 <n>,2,<near>,<c>,<cc>
endm
endif
if sizec
externCP macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
else
externCP macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
endif
if sized
externDP macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
else
externDP macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
endif
?ex1 macro n,s,d,c,scv
?gcc ?ex2,%?PLM,<c>
irp x,<n>
.xcref
.xcref ?t&&x
.cref
?t&&x=s
ife ?ex2
extrn _&&x:&d
x equ _&&x
else
extrn x:&d
endif
ifidn <scv>,<cc>
.xcref
.xcref ?CC&&x
.cref
?CC&&x=?ex2
endif
endm
endm
endif
ifndef ?NOLABEL
.xcref
.xcref ?lb1,?lblpu,?lb2
.xcref labelB,labelW,labelD,labelQ,labelT
.xcref labelNP,labelFP,labelP,labelCP,labelDP
.cref
?lblpu = 0
?lb2 = 0
labelB macro n,c
?lb1 <n>,1,<byte>,<c>
endm
labelW macro n,c
?lb1 <n>,2,<word>,<c>
endm
labelD macro n,c
?lb1 <n>,4,<dword>,<c>
endm
labelQ macro n,c
?lb1 <n>,8,<qword>,<c>
endm
labelT macro n,c
?lb1 <n>,10,<tbyte>,<c>
endm
labelNP macro n,c
?lb1 <n>,2,<near>,<c>
endm
labelFP macro n,c
?lb1 <n>,4,<far>,<c>
endm
if sizec
labelP macro n,c
?lb1 <n>,4,<far>,<c>
endm
else
labelP macro n,c
?lb1 <n>,2,<near>,<c>
endm
endif
if sizec
labelCP macro n,c
?lb1 <n>,4,<dword>,<c>
endm
else
labelCP macro n,c
?lb1 <n>,2,<word>,<c>
endm
endif
if sized
labelDP macro n,c
?lb1 <n>,4,<dword>,<c>
endm
else
labelDP macro n,c
?lb1 <n>,2,<word>,<c>
endm
endif
?lb1 macro n,s,d,c
?gcc ?lb2,%?PLM,<c>
?lblpu=0
irp x,<n>
ifidn <x>,<PUBLIC>
?lblpu=1
else
.xcref
.xcref ?t&&x
.cref
?t&&x=s
ife ?lb2
if ?lblpu
public _&&x
endif
_&&x label &d
x equ _&&x
else
if ?lblpu
public x
endif
x label &d
endif
endif
endm
endm
endif
ifndef ?NODEF
.xcref
.xcref defB,defW,defD,defQ,defT,defCP,defDP
.cref
defB macro n
?ad <n>,1
endm
defW macro n
?ad <n>,2
endm
defD macro n
?ad <n>,4
endm
defQ macro n
?ad <n>,8
endm
defT macro n
?ad <n>,10
endm
if sizec
defCP macro n
defD <n>
endm
else
defCP macro n
defW <n>
endm
endif
if sized
defDP macro n
defD <n>
endm
else
defDP macro n
defW <n>
endm
endif
endif
?ad macro n,s
irp x,<n>
.xcref
.xcref ?t&&x
.cref
?t&&x=s
endm
endm
ifndef ?NOPTR
.xcref
.xcref regPtr,farPtr
.cref
regPtr macro n,s,o
farPtr n,s,o
endm
farPtr macro n,s,o
.xcref
.xcref ?t&n
.cref
n &macro
	push	s
	push	o
&endm
?t&n=80h
endm
endif
arg macro a
irp x,<a>
?argc=?argc+1
?atal <x>,%?argc
endm
endm
?atal macro n,i
.xcref
.xcref ?ali&i
.cref
?ali&i &macro
?ap n
&endm
endm
?ap macro n
?argl=?argl+2
ifdef ?t&n
ife ?t&n-1
	push	word ptr (n)
exitm
endif
ife ?t&n-2
	push	n
exitm
endif
ife ?t&n-4
	push	word ptr (n)[2]
	push	word ptr (n)
?argl=?argl+2
exitm
endif
ife ?t&n-8
	push	word ptr (n)[6]
	push	word ptr (n)[4]
	push	word ptr (n)[2]
	push	word ptr (n)
?argl=?argl+6
exitm
endif
if ?t&n and 80h
n
?argl=?argl+2
exitm
endif
ife ?t&n
	push	word ptr (n)
exitm
endif
endif
	push	n
endm
cCall macro n,a,c
ifnb <a>
arg <a>
endif
mpush %?rsl
ifdef ?CC&n
?cCall1=?CC&n
else
?cCall1=?PLM
endif
ifnb <c>
?gcc ?cCall1,%?cCall1,<c>
endif
?argl=0
ife ?cCall1
?acb=?argc
else
?acb=1
endif
rept ?argc
uconcat <?ali>,%?acb
uconcat <purge>,,<?ali>,%?acb
ife ?cCall1
?acb=?acb-1
else
?acb=?acb+1
endif
endm
	call	n
if ((?cCall1 eq 0) and (?argl ne 0))
	add	sp,?argl
endif
mpop %?rsl
?rsl=0
?argc= 0
?argl= 0
endm
cProc macro n,cf,a
if ?cpd
?utpe
endif
?cpd=1
???=0
?argc=0
?ba=0
?po=0
?pu=0
?ia=0
?adj=4
?rp=0
?uf=0
?wfp=?WIN
?ff=0
?pas=0
?pcc=?PLM
?lds=0
?exp=0
ifnb <a>
?ri ?pas,<a>
endif
?pc=sizec
?nd=?nodata1
?nx=0
irp x,<cf>
ifidn <x>,<FAR>
?pc=1
endif
ifidn <x>,<NEAR>
?pc=0
endif
ifidn <x>,<PUBLIC>
?pu=1
endif
ifidn <x>,<SMALL>
?uf=1
endif
ifidn <x>,<DATA>
?nd=0
endif
ifidn <x>,<NODATA>
?nd=1
endif
ifidn <x>,<ATOMIC>
?nx=1
endif
ifidn <x>,<C>
?pcc=0
endif
ifidn <x>,<PLM>
?pcc=1
endif
ifidn <x>,<PASCAL>
?pcc=1
endif
ifidn <x>,<WIN>
?wfp=1
endif
ifidn <x>,<NONWIN>
?wfp=0
endif
ifidn <x>,<LOADDS>
?lds=1
endif
ifidn <x>,<EXPORTED>
?exp=1
endif
endm
if ?pcc
?PLMPrevParm=0
.xcref
.xcref ?PLMParm0
.cref
?PLMParm0 &macro
purge ?PLMParm0
&endm
endif
.xcref
.xcref ?CC&n
.cref
?CC&n=?pcc
if (?nx eq 1) and (?nd eq 0)
?nx = 0
??error <ATOMIC specified without NODATA - ATOMIC ignored>
endif
if ?pc
if ?wfp+?exp+?lds
ife ?nx
ife ?pmd
?ia=2
endif
?pas = ?pas and (not ?ds)
endif
endif
?adj=?adj+2
else
?wfp=0
endif
ife ?386regs
?pas = ?pas and (not (?sp+?cs+?ss))
endif
if ?uf
if ?386regs
?pas = ?pas and (not (?si+?di))
else
?pas = ?pas and (not (?bp+?si+?di))
endif
endif
ife ?pcc
?pg <_&n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
else
?pg <n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
endif
endm
?pg macro n,p,c,a,w,nnu,cc
.xcref
if ?uf
if ?nd
??error <NODATA encountered in &n - user frame ignored>
?uf=0
endif
endif
.xcref cBegin
cBegin &macro g
.xcref
if cc
uconcat <?PLMParm>,%?PLMPrevParm,%?po
endif
if ?uf
if ?rp
??error <parmR encountered in &n - user frame ignored>
?uf=0
endif
endif
?pg1 <n>,c,a,%?po,w,%?uf,%?nd,%?rp,cc
?cpd=0
?argc=0
?ba=1
???=(???+1) and 0fffeh
if p
public n
endif
ife c
n proc near
else
n proc far
endif
ife cc
nnu equ n
endif
ifidn <g>,<nogen>
if ???+?po+a+?rp
??_out <cBegin - possible invalid use of nogen>
endif
else
if ?uf
?mf c,%???,%?po
mpush a
else
if w+?exp+?lds
if ?pmd
ife ?nd
if ?lds
mov ax,_DATA
else
if ?exp
mov ax,ds
nop
endif
endif
endif
ife ?nx
if ???+?po
if ?chkstk1
push bp
mov bp,sp
else
if ???
enter ???,0
else
push bp
mov bp,sp
endif
endif
endif
push ds
if ?lds+?exp
mov ds,ax
endif
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
else
ife ?nd
	mov	ax,ds
	nop
endif
ife ?nx
ife ?DOS5
	inc	bp
endif
	push	bp
	mov	bp,sp
	push	ds
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
ife ?nd
	mov	ds,ax
endif
endif
else
if ?pmd
if ?exp
mov ax,ds
nop
else
if ?lds
mov ax,_DATA
endif
endif
if ?ff+???+?po+?rp
if ?chkstk1
push bp
mov bp,sp
else
if ???
enter ???,0
else
push bp
mov bp,sp
endif
endif
endif
if ?exp+?lds
push ds
mov ds,ax
endif
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
endif
if ?rp
?uf=0
rept ?rp
uconcat mpush,,?rp,%?uf
?uf=?uf+1
endm
endif
if ???
if ?chkstk1
ifdef ?CHKSTKPROC
?CHKSTKPROC %???
else
	mov	ax,???
ife cc
	call	_chkstk
else
	call	chkstk
endif
endif
else
ife ?pmd
	sub	sp,???
endif
endif
endif
mpush a
endif
ifdef ?PROFILE
if c
	call	StartNMeas
endif
endif
endif
.cref
purge cBegin
&endm
.xcref ?utpe
?utpe &macro
??error <unterminated procedure definition: "&n">
&endm
.cref
endm
?pg1 macro n,c,a,o,w,f,d,r,cc
.xcref
.xcref cEnd
cEnd &macro g
.xcref
?ba=0
ifidn <g>,<nogen>
if o+a+r
??_out <cEnd - possible invalid use of nogen>
endif
else
ifdef ?PROFILE
if c
call StopNMeas
endif
endif
mpop a
if f
	db	0c3h
else
if w+?exp+?lds
if ?pmd
ife ?nx
pop ds
endif
ife ?nx
if ?chkstk1+???+?po
leave
endif
else
if ?ff+???+?po+?rp
leave
endif
endif
else
ife ?nx
if (?TF eq 0) or (???+?rp)
	lea	sp,-2[bp]
endif
	pop	ds
	pop	bp
ife ?DOS5
	dec	bp
endif
else
if (?TF eq 0) or (???+?rp)
	mov	sp,bp
endif
if ???+?po+?rp
	pop	bp
endif
endif
endif
else
if ?pmd
if ?ff+???+?po+?rp
leave
endif
else
if ?ff+???+?po+?rp
if (?TF eq 0) or (???+?rp)
	mov	sp,bp
endif
	pop	bp
endif
endif
endif
ife cc
	ret
else
	ret	o
endif
endif
endif
n endp
.cref
purge cEnd
&endm
.cref
endm
assumes macro s,ln
ifndef ln&_assumes
assume s:ln
else
ln&_assumes s
endif
endm
createSeg macro n,ln,a,co,cl,grp
ifnb <grp>
addseg grp,n
else
ln&OFFSET equ offset n:
ln&BASE equ n
?cs3 <ln>,<n>
endif
ifnb <cl>
n segment a co '&cl'
else
n segment a co
endif
n ends
?cs1 <ln>,<n>
endm
addseg macro grp,seg
.xcref
.xcref grp&_def
.cref
ifndef grp&_def
grp&_def=0
endif
if grp&_def ne ASMpass
.xcref
.xcref grp&_add
.cref
grp&_add &macro s
grp&_in <seg>,s
&endm
.xcref
.xcref grp&_in
.cref
grp&_in &macro sl,s
ifb <s>
grp group sl
else
grp&_add &macro ns
grp&_in <sl,s>,ns
&endm
endif
&endm
grp&_def=ASMpass
else
grp&_add seg
endif
endm
defgrp macro grp,ln
addseg grp
ifnb <ln>
irp x,<ln>
?cs3 <&x>,<grp>
x&&OFFSET equ offset grp:
x&&BASE equ grp
endm
endif
endm
?cs1 macro ln,n
.xcref
.xcref ln&_sbegin
.cref
ln&_sbegin &macro
.xcref
.xcref ?mf
.cref
?mf &&macro c,l,p
if c
	extrn	n&_FARFRAME:near
	call	n&_FARFRAME
else
	extrn	n&_NEARFRAME:near
	call	n&_NEARFRAME
endif
	db	l shr 1
	db	p shr 1
&&endm
?cs2 <ln>,<n>
n segment
&endm
endm
?cs2 macro ln,n
.xcref
.xcref sEnd
.cref
sEnd &macro
n ends
purge ?mf
purge sEnd
&endm
endm
?cs3 macro ln,n
.xcref
.xcref ln&_assumes
.cref
ln&_assumes &macro s
assume s:&n
&endm
endm
.xcref
.xcref sBegin
.cref
sBegin macro ln
ln&_sbegin
endm
ife ?DF
createSeg _TEXT,Code,word,public,CODE
ife ?nodata1
createSeg _DATA,Data,word,public,DATA,DGROUP
defgrp DGROUP,Data
endif
if ?chkstk1
ifndef ?CHKSTKPROC
externp <chkstk>
endif
endif
endif
errnz macro x
if2
if x
errnz1 <x>,%(x)
endif
endif
endm
errnz1 macro x1,x2
= *errnz* x1 = x2
.err
endm
errn$ macro l,x
errnz <offset $ - offset l x>
endm
ifdef ?PROFILE
externFP <StartNMeas,StopNMeas>
endif
ELSE  ;MASM6
comment $
cmacros - assembly macros for interfacing to hhls
(C)Copyright Microsoft Corp. 1984-1994
$
.xcref
??CM_Paste macro arg1:req, arg2:req
exitm <arg1&arg2>
endm
.xcref ??_out
??_out macro t
ifndef ?QUIET
%out t
endif
endm
outif macro name,defval,onmsg,offmsg
ifndef name
ifb <defval>
name=0
else
name=defval
endif
endif
if name
name=1
ifnb <onmsg>
??_out <! onmsg>
endif
else
ifnb <offmsg>
??_out <! offmsg>
endif
endif
endm
.xcref ??error
??error macro msg
%out e r r o r ----- msg
.err e r r o r ----- msg
endm
.xcref ASMpass
.xcref memS,memM,memL,memC,memH,memMOD,sizec,sized
ASMpass=1
ifdef ?SMALL
memS=1
endif
ifdef ?MEDIUM
memM=1
endif
ifdef ?COMPACT
memC=1
endif
ifdef ?LARGE
memL=1
endif
ifdef ?HUGE
memH=1
endif
??_out <cMacros Version 5.30 - Copyright (c) Microsoft Corp. 1984-1991>
outif memS,0,<Small Model>
outif memM,0,<Medium Model>
outif memL,0,<Large Model>
outif memC,0,<Compact Model>
outif memH,0,<Huge Model>
memMOD= memS + memM + memL + memC + memH
if memMOD ne 1
if memMOD eq 0
memS = 1
outif memS,0,<Small Model>
else
??error <more than 1 memory model selected>
endif
endif
sizec= memM + memL + memH
sized= memL + memC + (memH*2)
outif ?DF,0,<No segments or groups will be defined>
outif ?TF,0,<Epilog sequences assume valid SP>
outif ?WIN,1,<Windows support>
if ?WIN eq 1
outif ?PLM,1,<>
else
outif ?PLM,1,<PL/M calling convention>
endif
ifndef ?NODATA
?nodata1=0
else
?nodata1=1
??_out <! NODATA module>
endif
ifndef ?CHKSTK
?chkstk1=0
else
?chkstk1=1
ifdef ?CHKSTKPROC
??_out <! Private stack checking enabled>
else
??_out <! Stack checking enabled>
endif
endif
ifndef DOS5
?DOS5=0
else
?DOS5=1
??_out <! DOS5 module>
endif
ifdef ?PROFILE
??_out <! Native profiling enabled>
endif
.xcref ?n,?ax,?ah,?al,?bx,?bh
.xcref ?bl,?cx,?ch,?cl,?dx,?dh
.xcref ?dl,?si,?di,?es,?ds,?bp
.xcref ?sp,?ss,?cs
.xcref ?rsl,?cpd,?argl,?argc,?ba
.xcref ?acb,???,?po
.xcref ?pas,?pc
.xcref uconcat,mpush,mpop
.xcref ?ri,?pp,?pp1,?al1
.xcref ?ad,?ap,?atal,?dd,?dd1,?dd2
.xcref ?pg,?pg1,?aloc,?cs1,?cs2
.xcref ?DF,?TF,?ff,?PLM,?WIN,?ia,?pu,?adj
.xcref ?uf,?rp,?nx,?nd,?nodata1,?chkstk1,?DOS5
.xcref ?wfp,arg,cCall,cProc,assumes,?cs3,?cs2,?cs1
.xcref defgrp,addseg,createSeg
.xcref save,outif,errnz,errn$,errnz1
.xcref ?PLMPrevParm,?gcc
.xcref ?cCall1,?pcc
?rsl = 0
?cpd = 0
?argl = 0
?argc = 0
?ba = 0
?acb = 0
??? = 0
?po = 0
?pas = 0
?pc = 0
?ia = 0
?pu = 0
?adj = 0
?rp = 0
?uf = 0
?nd = 0
?nx = 0
?wfp = 0
?ff = 0
?dd2 = 0
?cCall1 = 0
?pcc = ?PLM
?PLMPrevParm = 0
.xcref ?casen
if1
?casen = 0
endif
?n = 0000000000000000b
?ax = 0000000000000011b
?ah = 0000000000000001b
?al = 0000000000000010b
?bx = 0000000000001100b
?bh = 0000000000000100b
?bl = 0000000000001000b
?cx = 0000000000110000b
?ch = 0000000000010000b
?cl = 0000000000100000b
?dx = 0000000011000000b
?dh = 0000000001000000b
?dl = 0000000010000000b
?si = 0000000100000000b
?di = 0000001000000000b
?es = 0000010000000000b
?ds = 0000100000000000b
?bp = 0001000000000000b
?sp = 0010000000000000b
?ss = 0100000000000000b
?cs = 1000000000000000b
.cref
uconcat macro a,b,c,d,e,f,g
a&b c&d e&f&g
endm
mpush macro r
irp x,<ax,bx,cx,dx,si,di,es,ds,bp,sp,ss,cs>
if (r and ??CM_Paste(?,x))
	push	x
endif
endm
endm
mpop macro r
irp x,<cs,ss,sp,bp,ds,es,di,si,dx,cx,bx,ax>
if (r and ??CM_Paste(?,x))
	pop	x
endif
endm
endm
save macro r
?rsl=0
?ri ?rsl,<r>
endm
?ri macro n,r
irp x,<r>
ifdef ??CM_Paste(?,x)
n=n or ??CM_Paste(?,x)
endif
endm
endm
.xcref
.xcref parmB,parmW,parmD,parmQ,parmT,parmCP,parmDP,parmH
.cref
parmB macro n
?pp <n>,<byte>,2,1
endm
parmW macro n
?pp <n>,<word>,2,2
endm
parmD macro n
ife ?pcc
irp x,<n>
?pp <&&x>,<dword>,0,4
?pp <off_&&x>,<word>,2,2
?pp <seg_&&x>,<word>,2,2
endm
else
irp x,<n>
?pp <seg_&&x>,<word>,2,2
?pp <off_&&x>,<word>,2,2
?pp <&&x>,<dword>,0,4
endm
endif
endm
parmH macro n
?pp <n>,<word>,4,2
endm
parmQ macro n
?pp <n>,<qword>,8,8
endm
parmT macro n
?pp <n>,<tbyte>,10,10
endm
if sizec
parmCP macro n
parmD <n>
endm
else
parmCP macro n
parmW <n>
endm
endif
if sized
parmDP macro n
parmD <n>
endm
else
parmDP macro n
parmW <n>
endm
endif
?pp macro n,t,l,s
if ?cpd
.xcref
irp x,<n>
.xcref ??CM_Paste(?t_,x)
??CM_Paste(?t_,x)=s
ife ?pcc
?pp1 x,<t>,,,%(?po+?adj)
?po=?po+l
else
?PLMPrevParm=?PLMPrevParm+1
?po=?po+l
?pp1 x,<t>,%?po,%?adj,,%?PLMPrevParm,%(?PLMPrevParm-1)
endif
endm
.cref
else
??error <parm(s) "&n" declared outside proc def>
endif
endm
?pp1 macro n,t,o,a,b,cpc,ppc
ife ?pcc
n equ (t ptr [bp][+b])
else
.xcref
.xcref ?PLMParm&cpc
.cref
?PLMParm&cpc macro po
uconcat <n>,,<equ>,,<(t ptr [bp][+>,%(a+po-o),<])>
?PLMParm&ppc po
purge ?PLMParm&cpc
endm
endif
endm
ifndef ?NOPARMR
.xcref
.xcref ?pr,parmR
.cref
parmR macro n,r,r2
?pr n,r,r2,%?rp,%(?ia+2)
endm
?pr macro n,r,r2,i,o
.xcref
ifnb <r2>
parmR seg_&n,r
parmR off_&n,r2
n equ (dword ptr [bp][-o-2])
.xcref ?t_&n
?t_&n=4
else
.xcref ?rp&i
?rp&i=0
ifdef ?&r
?rp&i=?&r
endif
if ??? or (?cpd eq 0) or (?rp&i eq 0)
??error <invalid parmR encountered: &n,&r>
exitm
endif
n equ (word ptr [bp][-o])
.xcref ?t_&n
?t_&n=2
irp x,<bh,ch,dh,bl,cl,dl,ah,al>
if ??CM_Paste(?,x) eq ??CM_Paste(?,r)
n equ (byte ptr [bp][-o])
??CM_Paste(?t_,n)=1
exitm
endif
endm
?ia=?ia+2
?rp=?rp+1
endif
.cref
endm
endif
.xcref
.xcref localB,localW,localD,localQ,localT,localCP,localDP,localV
.cref
localB macro n
?aloc <n>,<byte ptr>,1,1,0
endm
localW macro n
?aloc <n>,<word ptr>,2,2,1
endm
localD macro n
irp x,<n>
?aloc <%??CM_Paste(seg_,x)>,<word ptr>,2,2,1
?aloc <%??CM_Paste(off_,x)>,<word ptr>,2,2,1
?aloc <&&x>,<dword ptr>,0,4,1
endm
endm
localQ macro n
?aloc <n>,<qword ptr>,8,8,1
endm
localT macro n
?aloc <n>,<tbyte ptr>,10,10,1
endm
if sizec
localCP macro n
localD <n>
endm
else
localCP macro n
localW <n>
endm
endif
if sized
localDP macro n
localD <n>
endm
else
localDP macro n
localW <n>
endm
endif
localV macro n,a
?aloc <n>,,%(a),0,1
endm
?aloc macro n,t,l,s,a
if ?cpd
.xcref
irp x,<n>
???=???+l
if a
???=((??? + 1) and 0fffeh)
endif
?al1 x,<t>,%(???+?ia)
.xcref ??CM_Paste(?t_,x)
??CM_Paste(?t_,x)=s
endm
.cref
else
??error <locals "&n" declared outside procedure def>
endif
endm
?al1 macro n,t,o
n equ (t [bp][-o])
endm
?gcc macro s,i,cc
s = i
ifnb <cc>
ifidn <cc>,<C>
s=0
endif
ifidn <cc>,<PLM>
s=1
endif
ifidn <cc>,<PASCAL>
s=1
endif
endif
endm
ifndef ?NOGLOBAL
.xcref
.xcref globalB,globalW,globalD,globalQ,globalT,globalCP,globalDP
.cref
globalB macro n,i,s,c
?ad <n>,1
?dd n,1,<byte>,<db>,<i>,<s>,<c>
endm
globalW macro n,i,s,c
?ad <n>,2
?dd n,1,<word>,<dw>,<i>,<s>,<c>
endm
globalD macro n,i,s,c
?ad <n>,4
?dd n,1,<dword>,<dd>,<i>,<s>,<c>
off_&n equ word ptr n[0]
seg_&n equ word ptr n[2]
endm
globalQ macro n,i,s,c
?ad <n>,8
?dd n,1,<qword>,<dq>,<i>,<s>,<c>
endm
globalT macro n,i,s,c
?ad <n>,10
?dd n,1,<tbyte>,<dt>,<i>,<s>,<c>
endm
if sizec
globalCP macro n,i,s,c
globalD n,<i>,<s>,<c>
endm
else
globalCP macro n,i,s,c
globalW n,<i>,<s>,<c>
endm
endif
if sized
globalDP macro n,i,s,c
globalD n,<i>,<s>,<c>
endm
else
globalDP macro n,i,s,c
globalW n,<i>,<s>,<c>
endm
endif
endif
ifndef ?NOSTATIC
.xcref
.xcref staticB,staticW,staticD,staticQ,staticT,staticCP,staticDP
.cref
staticB macro n,i,s
?ad <n>,1
?dd n,0,<byte>,<db>,<i>,<s>,<PLM>
endm
staticW macro n,i,s
?ad <n>,2
?dd n,0,<word>,<dw>,<i>,<s>,<PLM>
endm
staticD macro n,i,s
?ad <n>,4
?dd n,0,<dword>,<dd>,<i>,<s>,<PLM>
endm
staticQ macro n,i,s
?ad <n>,8
?dd n,0,<qword>,<dq>,<i>,<s>,<PLM>
endm
staticT macro n,i,s
?ad <n>,10
?dd n,0,<tbyte>,<dt>,<i>,<s>,<PLM>
endm
if sizec
staticCP macro n,i,s
staticD n,<i>,<s>
endm
else
staticCP macro n,i,s
staticW n,<i>,<s>
endm
endif
if sized
staticDP macro n,i,s
staticD n,<i>,<s>
endm
else
staticDP macro n,i,s
staticW n,<i>,<s>
endm
endif
endif
?dd macro n,p,t,d,i,s,c
?gcc ?dd2,%?PLM,<c>
ife ?dd2
n label t
?dd1 _&n,p,<d>,<i>,<s>
else
?dd1 n,p,<d>,<i>,<s>
endif
endm
?dd1 macro n,p,d,i,s
if p
public n
endif
ifb <s>
n d i
else
ifb <i>
n d s dup (?)
else
n d s dup (i)
endif
endif
endm
ifndef ?NOEXTERN
.xcref
.xcref ?ex1,?ex2,externB,externW,externD,externQ,externT
.xcref externNP,externFP,externP,externCP,externDP,externA
.cref
?ex2 = 0
externA macro n,c
?ex1 <n>,40h,<abs>,<c>,<>
endm
externB macro n,c
?ex1 <n>,1,<byte>,<c>,<>
endm
externW macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
externD macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
externQ macro n,c
?ex1 <n>,8,<qword>,<c>,<>
endm
externT macro n,c
?ex1 <n>,10,<tbyte>,<c>,<>
endm
externNP macro n,c
?ex1 <n>,2,<near>,<c>,<cc>
endm
externFP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
if sizec
externP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
else
externP macro n,c
?ex1 <n>,2,<near>,<c>,<cc>
endm
endif
if sizec
externCP macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
else
externCP macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
endif
if sized
externDP macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
else
externDP macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
endif
?ex1 macro n,s,d,c,scv
?gcc ?ex2,%?PLM,<c>
irp x,<n>
.xcref
.xcref ??CM_Paste(?t_,x)
.cref
??CM_Paste(?t_,x)=s
ife ?ex2
extrn ??CM_Paste(_,x):&d
x equ ??CM_Paste(_,x)
else
extrn x:&d
endif
ifidn <scv>,<cc>
.xcref
.xcref ??CM_Paste(?CC,x)
.cref
??CM_Paste(?CC,x)=?ex2
endif
endm
endm
endif
ifndef ?NOLABEL
.xcref
.xcref ?lb1,?lblpu,?lb2
.xcref labelB,labelW,labelD,labelQ,labelT
.xcref labelNP,labelFP,labelP,labelCP,labelDP
.cref
?lblpu = 0
?lb2 = 0
labelB macro n,c
?lb1 <n>,1,<byte>,<c>
endm
labelW macro n,c
?lb1 <n>,2,<word>,<c>
endm
labelD macro n,c
?lb1 <n>,4,<dword>,<c>
endm
labelQ macro n,c
?lb1 <n>,8,<qword>,<c>
endm
labelT macro n,c
?lb1 <n>,10,<tbyte>,<c>
endm
labelNP macro n,c
?lb1 <n>,2,<near>,<c>
endm
labelFP macro n,c
?lb1 <n>,4,<far>,<c>
endm
if sizec
labelP macro n,c
?lb1 <n>,4,<far>,<c>
endm
else
labelP macro n,c
?lb1 <n>,2,<near>,<c>
endm
endif
if sizec
labelCP macro n,c
?lb1 <n>,4,<dword>,<c>
endm
else
labelCP macro n,c
?lb1 <n>,2,<word>,<c>
endm
endif
if sized
labelDP macro n,c
?lb1 <n>,4,<dword>,<c>
endm
else
labelDP macro n,c
?lb1 <n>,2,<word>,<c>
endm
endif
?lb1 macro n,s,d,c
?gcc ?lb2,%?PLM,<c>
?lblpu=0
irp x,<n>
ifidn <x>,<PUBLIC>
?lblpu=1
else
.xcref
.xcref ??CM_Paste(?t_,x)
.cref
??CM_Paste(?t_,x)=s
ife ?lb2
if ?lblpu
public ??CM_Paste(_,x)
endif
??CM_Paste(_,x) label &d
x equ ??CM_Paste(_,x)
else
if ?lblpu
public x
endif
x label &d
endif
endif
endm
endm
endif
ifndef ?NODEF
.xcref
.xcref defB,defW,defD,defQ,defT,defCP,defDP
.cref
defB macro n
?ad <n>,1
endm
defW macro n
?ad <n>,2
endm
defD macro n
?ad <n>,4
endm
defQ macro n
?ad <n>,8
endm
defT macro n
?ad <n>,10
endm
if sizec
defCP macro n
defD <n>
endm
else
defCP macro n
defW <n>
endm
endif
if sized
defDP macro n
defD <n>
endm
else
defDP macro n
defW <n>
endm
endif
endif
?ad macro n,s
irp x,<n>
.xcref
.xcref ??CM_Paste(?t_,x)
.cref
??CM_Paste(?t_,x)=s
endm
endm
ifndef ?NOPTR
.xcref
.xcref regPtr,farPtr
.cref
regPtr macro n,s,o
farPtr n,s,o
endm
farPtr macro n,s,o
.xcref
.xcref ?t_&n
.cref
n macro
	push	s
	push	o
endm
?t_&n=80h
endm
endif
arg macro a
irp x,<a>
?argc=?argc+1
?atal <x>,%?argc
endm
endm
?atal macro n,i
.xcref
.xcref ?ali&i
.cref
?ali&i macro
?ap <n>
endm
endm
?ap macro n
?argl=?argl+2
ifdef ?t_&n
ife ?t_&n-1
	push	word ptr (n)
exitm
endif
ife ?t_&n-2
	push	n
exitm
endif
ife ?t_&n-4
	push	word ptr (n)[2]
	push	word ptr (n)
?argl=?argl+2
exitm
endif
ife ?t_&n-8
	push	word ptr (n)[6]
	push	word ptr (n)[4]
	push	word ptr (n)[2]
	push	word ptr (n)
?argl=?argl+6
exitm
endif
if ?t_&n and 80h
n
?argl=?argl+2
exitm
endif
ife ?t_&n
	push	word ptr (n)
exitm
endif
endif
	push	n
endm
cCall macro n,a,c
ifnb <a>
arg <a>
endif
mpush %?rsl
ifdef ?CC&n
?cCall1=?CC&n
else
?cCall1=?PLM
endif
ifnb <c>
?gcc ?cCall1,%?cCall1,<c>
endif
?argl=0
ife ?cCall1
?acb=?argc
else
?acb=1
endif
rept ?argc
uconcat <?ali>,%?acb
uconcat <purge>,,<?ali>,%?acb
ife ?cCall1
?acb=?acb-1
else
?acb=?acb+1
endif
endm
	call	n
if ((?cCall1 eq 0) and (?argl ne 0))
	add	sp,?argl
endif
mpop %?rsl
?rsl=0
?argc= 0
?argl= 0
endm
cProc macro n,cf,a
if ?cpd
?utpe
endif
?cpd=1
???=0
?argc=0
?ba=0
?po=0
?pu=0
?ia=0
?adj=4
?rp=0
?uf=0
?wfp=?WIN
?ff=0
?pas=0
?pcc=?PLM
ifnb <a>
?ri ?pas,<a>
endif
?pc=sizec
?nd=?nodata1
?nx=0
irp x,<cf>
ifidn <x>,<FAR>
?pc=1
endif
ifidn <x>,<NEAR>
?pc=0
endif
ifidn <x>,<PUBLIC>
?pu=1
endif
ifidn <x>,<SMALL>
?uf=1
endif
ifidn <x>,<DATA>
?nd=0
endif
ifidn <x>,<NODATA>
?nd=1
endif
ifidn <x>,<ATOMIC>
?nx=1
endif
ifidn <x>,<C>
?pcc=0
endif
ifidn <x>,<PLM>
?pcc=1
endif
ifidn <x>,<PASCAL>
?pcc=1
endif
ifidn <x>,<WIN>
?wfp=1
endif
ifidn <x>,<NONWIN>
?wfp=0
endif
endm
if ?pcc
?PLMPrevParm=0
.xcref
.xcref ?PLMParm0
.cref
?PLMParm0 macro arg
purge ?PLMParm0
endm
endif
.xcref
.xcref ?CC&n
.cref
?CC&n=?pcc
if (?nx eq 1) and (?nd eq 0)
?nx = 0
??error <ATOMIC specified without NODATA - ATOMIC ignored>
endif
if ?pc
if ?wfp
ife ?nx
?ia=2
?pas = ?pas and (not ?ds)
endif
endif
?adj=?adj+2
else
?wfp=0
endif
?pas = ?pas and (not (?sp+?cs+?ss))
if ?uf
?pas = ?pas and (not (?bp+?si+?di))
endif
ife ?pcc
?pg <_&n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
else
?pg <n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
endif
endm
?pg macro n,p,c,a,w,nnu,cc
.xcref
if ?uf
if ?nd
??error <NODATA encountered in &n - user frame ignored>
?uf=0
endif
endif
.xcref cBegin
cBegin macro g
.xcref
if cc
uconcat <?PLMParm>,%?PLMPrevParm,%?po
endif
if ?uf
if ?rp
??error <parmR encountered in &n - user frame ignored>
?uf=0
endif
endif
?pg1 <n>,c,a,%?po,w,%?uf,%?nd,%?rp,cc
?cpd=0
?argc=0
?ba=1
???=(???+1) and 0fffeh
if p
public n
endif
ife c
n proc near
else
n proc far
endif
ife cc
nnu equ n
endif
ifidn <g>,<nogen>
if ???+?po+a+?rp
??_out <cBegin - possible invalid use of nogen>
endif
else
if ?uf
?mf c,%???,%?po
mpush a
else
if w
ife ?nd
	mov	ax,ds
	nop
endif
ife ?nx
ife ?DOS5
	inc	bp
endif
	push	bp
	mov	bp,sp
	push	ds
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
ife ?nd
	mov	ds,ax
endif
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
if ?rp
?uf=0
rept ?rp
uconcat mpush,,?rp,%?uf
?uf=?uf+1
endm
endif
if ???
if ?chkstk1
ifdef ?CHKSTKPROC
?CHKSTKPROC %???
else
	mov	ax,???
ife cc
	call	_chkstk
else
	call	chkstk
endif
endif
else
	sub	sp,???
endif
endif
mpush a
endif
ifdef ?PROFILE
if c
	call	StartNMeas
endif
endif
endif
.cref
purge cBegin
endm
.xcref ?utpe
?utpe macro
??error <unterminated procedure definition: "&n">
endm
.cref
endm
?pg1 macro n,c,a,o,w,f,d,r,cc
.xcref
.xcref cEnd
cEnd macro g
.xcref
?ba=0
ifidn <g>,<nogen>
if o+a+r
??_out <cEnd - possible invalid use of nogen>
endif
else
ifdef ?PROFILE
if c
call StopNMeas
endif
endif
mpop a
if f
	db	0c3h
else
if w
ife ?nx
if (?TF eq 0) or (???+?rp)
	lea	sp,(-2)[bp]
endif
	pop	ds
	pop	bp
ife ?DOS5
	dec	bp
endif
else
if (?TF eq 0) or (???+?rp)
	mov	sp,bp
endif
if ???+?po+?rp
	pop	bp
endif
endif
else
if ?ff+???+?po+?rp
if (?TF eq 0) or (???+?rp)
	mov	sp,bp
endif
	pop	bp
endif
endif
ife cc
	ret
else
	ret	o
endif
endif
endif
n endp
.cref
purge cEnd
endm
.cref
endm
assumes macro s,ln
ifdef MS_STARTUP
ifidn <code>,<ln>
assume s&:_TEXT
exitm
elseifidn <CODE>,<ln>
assume s&:_TEXT
exitm
elseifidn <data>,<ln>
assume s&:dgroup
exitm
elseifidn <DATA>,<ln>
assume s&:dgroup
exitm
endif
endif
ifndef ln&_assumes
assume s:ln
else
ln&_assumes s
endif
endm
createSeg macro n,ln,a,co,cl,grp
ifnb <cl>
n segment a co '&cl'
else
n segment a co
endif
n ends
?cs1 <ln>,<n>
ifnb <grp>
grp group n
?cs3 <ln>,<grp>
ln&OFFSET equ <offset grp:>
ln&BASE equ <grp>
else
?cs3 <ln>,<n>
ln&OFFSET equ <offset>
ln&BASE equ <n>
endif
endm
addseg macro grp,seg
.xcref
.xcref grp&_add
.cref
grp&_add macro s
grp&_in <seg>,s
endm
.xcref
.xcref grp&_in
.cref
grp&_in macro sl,s
ifb <s>
grp group sl
else
grp&_add macro ns
grp&_in <sl,s>,ns
endm
endif
endm
endm
defgrp macro grp,ln
endm
?cs1 macro ln,n
.xcref
.xcref ln&_sbegin
.cref
ln&_sbegin macro
?cs2 <ln>,<n>
n segment
.xcref
.xcref ?mf
.cref
?mf macro c,l,p
if c
	extrn	n&_FARFRAME:near
	call	n&_FARFRAME
else
	extrn	n&_NEARFRAME:near
	call	n&_NEARFRAME
endif
	db	l shr 1
	db	p shr 1
endm
endm
endm
?cs2 macro ln,n
.xcref
.xcref sEnd
.cref
sEnd macro arg
n ends
purge ?mf
purge sEnd
endm
endm
?cs3 macro ln,n
.xcref
.xcref ln&_assumes
.cref
ln&_assumes macro s
assume s:&n
endm
endm
.xcref
.xcref sBegin
.cref
sBegin macro ln
ln&_sbegin
endm
ife ?DF
createSeg _TEXT,Code,word,public,CODE
ife ?nodata1
createSeg _DATA,Data,word,public,DATA,DGROUP
defgrp DGROUP,Data
endif
if ?chkstk1
ifndef ?CHKSTKPROC
externp <chkstk>
endif
endif
endif
errnz macro x
ifnb <x>
.errnz (x),<x>
endif
endm
errnz1 macro x1,x2
= *errnz* x1 = x2
.err
endm
errn$ macro l,x
errnz <offset $ - offset l x>
endm
ifdef ?PROFILE
externFP <StartNMeas,StopNMeas>
endif
callcrt MACRO funcname
ifdef _QC2
call funcname
else
if sizeC
push cs
call near ptr (funcname)
else
call funcname
endif
endif
ENDM
.cref
ENDIF ;MASM6
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\old\MINIVDD.INC ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1988-1993
;
;   Title:	minivdd.inc - VDD definitions for other VxD's and multiple VDD's
;
;   Version:	4.00
;
;   Date:
;
;   Author: FredE for the Mini-VDD interface.  Adapted from VDD.INC in
;	    the general include area.  Added services are ONLY for the
;	    use of the Mini-VDD and should therefore not be documented.
;
;------------------------------------------------------------------------------
;==============================================================================
;
;Some external definitions.  Only define these if we're assembling the
;device independent "main" portion of the Mini-VDD:
;
ifdef MAINVDD
externdef	MiniVDDDispatchTable:dword	;in VDDCTL.ASM
endif ;MAINVDD

;
;VDD protect mode services for other devices and VMM (Get_Version must be first).
;Only define these if we're assembling either the "main" VDD or one of the
;mini-VDD's.  Don't define this if we're assembling a display driver or other
;caller of the MiniVDD stuff:
;
ifdef MINIVDD
Begin_Service_Table VDD
VDD_Service	VDD_Get_Version 	; Get version number and ID string ptr
VDD_Service	VDD_PIF_State		; Pass video PIF bits to VDD
VDD_Service	VDD_Get_GrabRtn 	; Get routine addr for video grab
VDD_Service	VDD_Hide_Cursor 	; Hide cursor when display is windowed
VDD_Service	VDD_Set_VMType		; Set VM type(windowed, bckgrnd, excl)
VDD_Service	VDD_Get_ModTime 	; Return system time of last mod
VDD_Service	VDD_Set_HCurTrk 	; Track horiz cursor movement in window
VDD_Service	VDD_Msg_ClrScrn 	; Clear screen for sysmodal message
VDD_Service	VDD_Msg_ForColor	; Set Msg_TextOut forground color
VDD_Service	VDD_Msg_BakColor	; Set Msg_TextOut background color
VDD_Service	VDD_Msg_TextOut 	; Output a string
VDD_Service	VDD_Msg_SetCursPos	; Set cursor position
VDD_Service	VDD_Query_Access	; Is it OK to access video now?
VDD_Service	VDD_Check_Update_Soon	; User action may update screen
VDD_Service	VDD_Get_Mini_Dispatch_Table
					; Get addr of dispatch table to mini-VDD
VDD_Service	VDD_Register_Virtual_Port
					; Mini-VDD asks us to setup I/O trap
VDD_Service	VDD_Get_VM_Info 	; Returns CRTC owner and MemC owners
					; and other special VM handles
VDD_Service	VDD_Get_Special_VM_IDs	;returns planar & msg mode IDs
VDD_Service	VDD_Register_Extra_Screen_Selector
					;allows display driver to use second
					;screen selector for block moves
VDD_Service	VDD_Takeover_VGA_Port	;allows MiniVDD to takeover a port
					;in range 3C0H through 3DFH
VDD_Service	VDD_Get_DISPLAYINFO	;get DISPLAYINFO data structure
VDD_Service	VDD_Do_Physical_IO	;perform physical I/O for trapped port
VDD_Service	VDD_Set_Sleep_Flag_Addr ;when display driver can't be interrupted
End_Service_Table VDD
endif	;MINIVDD

IFDEF VDD40
VDD_VerNum	EQU	0400h	;version 4.00
ELSE
VDD_VerNum	=	030ah	;return version 3.10 if Makefile switch not set

IFDEF DEBUG
IFNDEF VGA
IFNDEF EGA
VDD_VerNum = VDD_VerNum + 0FFh
ENDIF ;EGA
ENDIF ;VGA
ENDIF ;DEBUG

ENDIF	;VDD40

;***************
; PIF_State service definitions
;
; These definitions cannot change without changing the PIF editor!!!
;
fVidTxtEmulate	EQU	0001h		; Do INT 10h TTY and cursor emulation
fVidNoTrpTxt	EQU	0002h		; Do not trap text mode apps
fVidNoTrpLRGrfx EQU	0004h		; Do not trap lo res graphics mode apps
fVidNoTrpHRGrfx EQU	0008h		; Do not trap hi res graphics mode apps
fVidTextMd	EQU	0010h		; Allocate text mode mem
fVidLowRsGrfxMd EQU	0020h		; Allocate lo res graphics mode mem
fVidHghRsGrfxMd EQU	0040h		; Allocate hi res graphics mode mem
fVidRetainAllo	EQU	0080h		; Never deallocate once allocated

;
;The following stuff was added for mini-VDD support:
;
;Functions that we can call in the hardware-dependent mini-VDD.  Note that
;these equates are used to create the dispatch table for calling functions
;in the mini-VDD:
;
REGISTER_DISPLAY_DRIVER 	equ	0
GET_VDD_BANK			equ	1
SET_VDD_BANK			equ	2
RESET_BANK			equ	3
PRE_HIRES_TO_VGA		equ	4
POST_HIRES_TO_VGA		equ	5
PRE_VGA_TO_HIRES		equ	6
POST_VGA_TO_HIRES		equ	7
SAVE_REGISTERS			equ	8
RESTORE_REGISTERS		equ	9
MODIFY_REGISTER_STATE		equ	10
ACCESS_VGA_MEMORY_MODE		equ	11
ACCESS_LINEAR_MEMORY_MODE	equ	12
ENABLE_TRAPS			equ	13
DISABLE_TRAPS			equ	14
MAKE_HARDWARE_NOT_BUSY		equ	15
VIRTUALIZE_CRTC_IN		equ	16
VIRTUALIZE_CRTC_OUT		equ	17
VIRTUALIZE_SEQUENCER_IN 	equ	18
VIRTUALIZE_SEQUENCER_OUT	equ	19
VIRTUALIZE_GCR_IN		equ	20
VIRTUALIZE_GCR_OUT		equ	21
SET_LATCH_BANK			equ	22
RESET_LATCH_BANK		equ	23
SAVE_LATCHES			equ	24
RESTORE_LATCHES 		equ	25
DISPLAY_DRIVER_DISABLING	equ	26
SELECT_PLANE			equ	27
PRE_CRTC_MODE_CHANGE		equ	28
POST_CRTC_MODE_CHANGE		equ	29
VIRTUALIZE_DAC_OUT		equ	30
VIRTUALIZE_DAC_IN		equ	31
GET_CURRENT_BANK_WRITE		equ	32
GET_CURRENT_BANK_READ		equ	33
SET_BANK			equ	34
CHECK_HIRES_MODE		equ	35
GET_TOTAL_VRAM_SIZE		equ	36
GET_BANK_SIZE			equ	37
SET_HIRES_MODE			equ	38
PRE_HIRES_SAVE_RESTORE		equ	39
POST_HIRES_SAVE_RESTORE 	equ	40
VESA_SUPPORT			equ	41
GET_CHIP_ID			equ	42
CHECK_SCREEN_SWITCH_OK		equ	43
VIRTUALIZE_BLTER_IO		equ	44
SAVE_MESSAGE_MODE_STATE 	equ	45
SAVE_FORCED_PLANAR_STATE	equ	46
VESA_CALL_POST_PROCESSING	equ	47
;
NBR_MINI_VDD_FUNCTIONS		equ	48	;REMEMBER TO RESET THIS!!!!!!

;
;Following are function codes that can be called via the VDD's
;API entry point. These are mainly for display driver --> VDD communication.
;Since Windows 3.0 and 3.1 VDD's may have used the sequential numbers
;(after the Grabber functions) for other VDD API services, we start our
;numbering at 80H so as to avoid ugly conflicts with old 3.1 stuff:
;
MINIVDD_SVC_BASE_OFFSET 		equ	80h
VDD_DRIVER_REGISTER			equ	0 or MINIVDD_SVC_BASE_OFFSET
VDD_DRIVER_UNREGISTER			equ	1 or MINIVDD_SVC_BASE_OFFSET
VDD_SAVE_DRIVER_STATE			equ	2 or MINIVDD_SVC_BASE_OFFSET
VDD_REGISTER_DISPLAY_DRIVER_INFO	equ	3 or MINIVDD_SVC_BASE_OFFSET
VDD_REGISTER_SSB_FLAGS			equ	4 or MINIVDD_SVC_BASE_OFFSET
VDD_GET_DISPLAY_CONFIG			equ	5 or MINIVDD_SVC_BASE_OFFSET
VDD_PRE_MODE_CHANGE			equ	6 or MINIVDD_SVC_BASE_OFFSET
VDD_POST_MODE_CHANGE			equ	7 or MINIVDD_SVC_BASE_OFFSET
VDD_SET_USER_FLAGS			equ	8 or MINIVDD_SVC_BASE_OFFSET
VDD_SET_BUSY_FLAG_ADDR			equ	9 or MINIVDD_SVC_BASE_OFFSET
;
;Port size equates:
;
BYTE_LENGTHED			equ	1
WORD_LENGTHED			equ	2

;
;Flag equates:
;
GOING_TO_WINDOWS_MODE		equ	1
GOING_TO_VGA_MODE		equ	2
DISPLAY_DRIVER_DISABLED 	equ	4
;
;
MiniVDDDispatch 	macro	FunctionCode, HandlerAddr
	mov	[edi+(FunctionCode*4)],OFFSET32 MiniVDD_&HandlerAddr
endm
;
;
MiniVDDCall		macro	FunctionCode, SaveFlags
local	MiniVDDCallExit, MiniVDDCallLeave
	push	edi			;;save this register for now
ifnb	<SaveFlags>
	pushfd				;;save the flags state
endif
	mov	edi,OFFSET32 MiniVDDDispatchTable
	cmp	dword ptr [edi+(FunctionCode*4)],0
	je	MiniVDDCallLeave	;;MiniVDD doesn't support this
ifnb	<SaveFlags>
	popfd				;;just clear the Stack from the flags
endif
	call	dword ptr [edi+(FunctionCode*4)]
ifnb	<SaveFlags>
	jmp	MiniVDDCallExit 	;;we already restored the flags
endif
;
MiniVDDCallLeave:
ifnb	<SaveFlags>
	popfd				;;
endif
;
MiniVDDCallExit:
	pop	edi			;;we're done handling this call
endm

DISPLAYINFO	struc
	diHdrSize		dw	size DisplayInfo
	diInfoFlags		dw	?
	diDevNodeHandle		dd	?
	diDriverName		db	16 dup(?)
	diXRes			dw	?
	diYRes			dw	?
	diDPI			dw	?
	diPlanes		db	?
	diBpp			db	?
	diRefreshRateMax	dw	?
	diRefreshRateMin	dw	?
	diLowHorz		dw	?
	diHighHorz		dw	?
	diLowVert		dw	?
	diHighVert		dw	?
	diMonitorDevNodeHandle	dd	?
	diHorzSyncPolarity	db	?
	diVertSyncPolarity	db	?
DISPLAYINFO	ends
DISPLAYINFO_SIZE	equ	diRefreshRateMax+2-diHdrSize
;
;Following are values and explanations for the diInfoFlags word in DISPLAYINFO:
;
;RETURNED_DATA_IS_STALE, if set, means that this call to VDD_GET_DISPLAY_CONFIG
;or VDD_GetDisplayInfo (which are the Ring 3 and Ring 0 methods by which a
;program would get the DISPLAYINFO structure returned to him) caused the VDD
;to return data that was read in a previous call to VDD_GET_DISPLAY_CONFIG
;insted of actually going out and reading "fresh" data from the Registry.
;
;This flag brings to light the fact that there are some circumstances when the
;VDD cannot go out and read the registry in response to the call to
;VDD_GET_DISPLAY_CONFIG or VDD_GetDisplayInfo (due to system multi-tasking
;considerations).  In this case, this flag will be set to a 1 to indicate that
;the information being returned isn't "fresh" -- that is -- it may be
;incorrect and obsolete.  The caller should respond accordingly if this flag
;is set.
;
RETURNED_DATA_IS_STALE			equ	01h
;
;MINIVDD_FAILED_TO_LOAD if set, indicates that for some reason (typically
;that the MiniVDD didn't match the chipset installed in the machine), the
;MiniVDD didn't load.  Callers can examine this flag and act accordingly.
;
MINIVDD_FAILED_TO_LOAD			equ	02h
;
;MINIVDD_CHIP_ID_DIDNT_MATCH means that although the MiniVDD did load
;successfully, when the ChipID that the MiniVDD calculated was compared
;against the value saved in the registry, they didn't match.  An example of
;when this would happen is when the user is happily using an S3-911 card
;and then decides to upgrade his display card to an S3-864.  Since both
;cards use S3.VXD, the MiniVDD will load, however, since the card model
;is different, the VDD will return a defect to configuration manager and
;set this flag.  Callers of the GET_DISPLAY_CONFIG functions can use this
;flag to take appropriate actions to make sure that the user gets his
;configuration correct.
;
MINIVDD_CHIP_ID_DIDNT_MATCH		equ	04h
;
;REGISTRY_BPP_NOT_VALID if set, means that we failed to obtain the BPP value
;from the registry when the VDD tried to read it.
;
REGISTRY_BPP_NOT_VALID			equ	08h
;
;REGISTRY_RESOLUTION_NOT_VALID if set, means that we failed to obtain the
;resolution value from the registry when the VDD tried to read it.
;
REGISTRY_RESOLUTION_NOT_VALID		equ	10h
;
;REGISTRY_DPI_NOT_VALID if set, means that we failed to obtain the
;DPI value from the registry when the VDD tried to read it.
;
REGISTRY_DPI_NOT_VALID			equ	20h
;
;MONITOR_DEVNODE_NOT_ACTIVE is set if someone tries to make a call to the
;GET_DISPLAY_CONFIG function before the monitor DevNode has been created.
;This is certainly not fatal by any means.  It simply means that the
;monitor refresh rate info in the DISPLAYINFO data structure is totally
;invalid!
;
MONITOR_DEVNODE_NOT_ACTIVE		equ	40h
;
;MONITOR_INFO_NOT_VALID indicates that something within the code which
;retrieves and calculates the refresh rate data has failed.  This indicates
;that the values in diRefreshRateMax through diVertSyncPolarity are not
;valid and could contain random data.
;
MONITOR_INFO_NOT_VALID			equ	80h
;
;MONITOR_INFO_DISABLED_BY_USER indicates that the either the RefreshRate=
;string in SYSTEM.INI had a negative number in it or that the string in
;the display's software key (HKEY_CURRENT_CONFIG\Display\Settings\RefreshRate)
;was 0 or a negative number.
;
MONITOR_INFO_DISABLED_BY_USER		equ	100h
;
;REFRESH_RATE_MAX_ONLY indicates that there was no diLowHorz, diHighHorz,
;diLowVert, diHighVert, or sync polarity data in the registry.	The
;value returned in diRefreshRateMax is the only refresh rate data that
;we have available.  This was derived either from RefreshRate= in SYSTEM.INI
;or the HKEY_CURRENT_CONFIG\Display\Settings\RefreshRate = string in the
;registry.
;
REFRESH_RATE_MAX_ONLY			equ	200h
;
;CARD_VDD_LOADED_OK indicates that a second MiniVDD (which is useful for
;display card manufacturers wishing to extend the capabilities of the chip level
;MiniVDD's ) has successfully been loaded and initialized.
;
CARD_VDD_LOADED_OK			equ	400h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\old\VDD2.INC ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1989-1990
;
;   Title:	vdd2.inc - VDD definitions for Secondary VDD
;
;   Version:	1.00
;
;   Author: MDW
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   02-Aug-1989 MDW Added service definitions
;==============================================================================


Begin_Service_Table VDD2

;***************
;VDD2 services for other devices and VMM(Get_Version must be first)
;
VDD2_Service	VDD2_Get_Version	; Get version number and ID string ptr
End_Service_Table VDD2
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\old\VDDGRB.INC ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1989-1990
;
;***************
; Shell_Event definitions for the VDD
;
;   DO NOT CHANGE THESE EVER WITHOUT REDOING THE SHELL AND THE GRABBER
;	AND THE VDD!!!
;
VDA_Type_Chng		EQU	((0400h+20)+2)

VDA_Display_Event	EQU	((0400h+20)+6)
; On VDA_Display_Event event,
;   VMDOSAPP instance which gets the message has display event
;   wParam is a "subfunction code" which identifies the event.
;
VDA_DE_DispChngMin	EQU	0
VDA_DE_DispChngMax	EQU	80
VDA_DE_ControlChngMin	EQU	VDA_DE_DispChngMax
VDA_DE_ControlChngMax	EQU	160
VDA_DE_ScreenGrabMin	EQU	VDA_DE_ControlChngMax
VDA_DE_ScreenGrabMax	EQU	240

VDA_DE_SpecialMin	EQU	0FFAFh
VDA_DE_SpecialMax	EQU	0FFFFh
;
; Subfunctions >= VDA_DE_DispChngMin, < VDA_DE_DispChngMax indicate
;   that the display has changed without a change to the video controller
;   state.
;
; Subfunctions >= VDA_DE_ControlChngMin, < VDA_DE_ControlChngMax indicate
;   that the video controller state has changed.
;
; Subfunctions >= VDA_DE_ScreenGrabMin, < VDA_DE_ScreenGrabMax indicate
;   that a screen grab event has occured.
;
; Subfunctions >= VDA_DE_SpecialMin, < VDA_DE_SpecialMax indicate
;   private GRABBER events which VMDOSAPP just passes through to the
;   GRABBER
;
; This parameter is passed through VMDOSAPP to the display specific GRABBER.
;   "ranges" on the parameter allow specific info to be passed to the GRABBER
;   while allowing VMDOSAPP to know about the general high level aspect of the
;   event.
;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\old\VKD.INC ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1988-1990
;
;   Title:	vkd.inc -
;
;   Version:	1.00
;
;   Date:	10-Aug-1988
;
;   Author:	RAP
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   10-Aug-1988 RAP started re-write of VKD
;   03-Nov-1988 RAP separated internal stuff out into VKDSYS.INC
;
;==============================================================================


Begin_Service_Table VKD

VKD_Service	VKD_Get_Version, LOCAL
VKD_Service	VKD_Define_Hot_Key, LOCAL
VKD_Service	VKD_Remove_Hot_Key, LOCAL
VKD_Service	VKD_Local_Enable_Hot_Key, LOCAL
VKD_Service	VKD_Local_Disable_Hot_Key, LOCAL
VKD_Service	VKD_Reflect_Hot_Key, LOCAL
VKD_Service	VKD_Cancel_Hot_Key_State, LOCAL
VKD_Service	VKD_Force_Keys, LOCAL
VKD_Service	VKD_Get_Kbd_Owner, LOCAL
VKD_Service	VKD_Define_Paste_Mode, LOCAL
VKD_Service	VKD_Start_Paste, LOCAL
VKD_Service	VKD_Cancel_Paste, LOCAL
VKD_Service	VKD_Get_Msg_Key, LOCAL
VKD_Service	VKD_Peek_Msg_Key, LOCAL
VKD_Service	VKD_Flush_Msg_Key_Queue, LOCAL

End_Service_Table VKD


VKD_Version	equ 200h


;******************************************************************************
;
; shift state bits for both global & local shift states
;
		      ;;5432109876543210
SS_Shift	equ	0000000000000001b   ; left or right
SS_LShift	equ	0000000000000010b
SS_RShift	equ	0000001000000000b
SS_Ctrl 	equ	0000000010000000b   ; left or right
SS_LCtrl	equ	0000000000000100b
SS_RCtrl	equ	0000010000000000b
SS_Alt		equ	0000000100000000b   ; left or right
SS_LAlt 	equ	0000000000001000b
SS_RAlt 	equ	0000100000000000b
SS_CapLock	equ	0000000001000000b
SS_NumLock	equ	0000000000100000b
SS_ScrlLock	equ	0000000000010000b
SS_CapLock_Dn	equ	0100000000000000b   ; SS_CapLock shl 8
SS_NumLock_Dn	equ	0010000000000000b   ; SS_NumLock shl 8
SS_ScrlLock_Dn	equ	0001000000000000b   ; SS_ScrlLock shl 8
SS_Unused	equ	1000000000000000b

SS_Toggle_mask	    equ     SS_CapLock + SS_NumLock + SS_ScrlLock
SS_Toggle_Dn_mask   equ     SS_CapLock_Dn + SS_NumLock_Dn + SS_ScrlLock_Dn
SS_LShift_mask	    equ     SS_LShift + SS_LCtrl + SS_LAlt
SS_Shift_mask	    equ     SS_LShift_mask + SS_RShift + SS_RCtrl + SS_RAlt

SS_Either_Shift     equ     SS_LShift + SS_RShift
SS_Either_Ctrl	    equ     SS_LCtrl + SS_RCtrl
SS_Either_Alt	    equ     SS_LAlt + SS_RAlt


; LED state bits
LED_ScLok	equ	1		    ; Scroll Lock
LED_NmLok	equ	2		    ; Num Lock
LED_CpLok	equ	4		    ; Caps Lock
Toggle_To_LED	equ	4		    ; "state shr Toggle_To_LED" converts
					    ; state bits into kybd LED bits


; VKD_Define_Hot_Key equates & macro

ExtendedKey_B	equ 1
ExtendedKey	equ 100h
AllowExtended_B equ 0FFh
AllowExtended	equ 0FF00h


;VKD_Define_Hot_Key flags:

CallOnPress	equ 1		; Call call-back when key press is detected
CallOnRelease	equ 2		; Call call-back when key release is detected
				; (keyboard may still be in hot-key hold state)
CallOnRepeat	equ 4		; Call call-back when repeated press is detected
CallOnComplete	equ 8		; Call call-back when the hot key state is
				; ended (all shift modifier keys are released)
				; or when a different hot key is entered
				; (i.e. pressing ALT 1 2, if both ALT-1
				;  and ALT-2 are defined hot keys, then ALT-1's
				;  call back will be called before ALT-2's to
				;  indicate that the ALT-1 is complete even
				;  though the ALT key is still down)
CallOnUpDwn	equ CallOnPress + CallOnRelease
				; Call call-back on both press and release
CallOnAll	equ 0		; Call call-back on press, release, auto-repeat
				; and complete
PriorityNotify	equ 10h 	; notification calls to the call-back can only
				; happen when interrupts are enabled and
				; the critical section is un-owned
Local_Key	equ 80h 	; key can be locally enabled/disabled

Hot_Key_Pressed     equ 0
Hot_Key_Released    equ 1
Hot_Key_Repeated    equ 2
Hot_Key_Completed   equ 3

Hot_Key_SysVM_Notify	 equ 80h
Hot_Key_SysVM_Notify_bit equ 7

BeginDoc
;******************************************************************************
;
;   ShiftState
;
;   DESCRIPTION:    Macro to aid in setting EBX with the shift state mask and
;		    shift state compare value for calling VKD_Define_Hot_Key.
;
;   USAGE:	    ShiftState mask, compare
;
;		    The mask specifies the shift state bits that should be
;		    excluded before the compare is done.
;
;==============================================================================
EndDoc
ShiftState MACRO mask, compare
	mov	ebx, ((NOT mask) SHL 16) + compare
	   ENDM

; common shift states

HKSS_Shift  equ (NOT (SS_Either_Shift + SS_Toggle_mask)) SHL 16 + SS_Shift
HKSS_Ctrl   equ (NOT (SS_Either_Ctrl + SS_Toggle_mask)) SHL 16 + SS_Ctrl
HKSS_Alt    equ (NOT (SS_Either_Alt + SS_Toggle_mask)) SHL 16 + SS_Alt


; include structure of entries in paste buffer

include VKDpaste.INC


; paste completion flags passed to the paste call-back

Paste_Complete	equ 0	; paste successful
Paste_Aborted	equ 1	; paste aborted by user
Paste_VM_Term	equ 2	; paste aborted because VM terminated

;
; Modifier byte for Message Keys, retrieved with services VKD_Get_Msg_Key and
; VKD_Peek_Msg_Key
;
MK_Shift	equ 00000010b
MK_Ctrl 	equ 00000100b
MK_Alt		equ 00001000b
MK_Extended	equ 10000000b
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\old\VKDPASTE.INC ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1989-1990
;
;   Title:	vkdpaste.inc -
;
;   Version:	1.00
;
;   Date:	20-Mar-1989
;
;   Author:	RAP
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   20-Mar-1989 RAP
;   23-Mar-1989 RAP added PM API equates
;
;==============================================================================

;
; structure of entries in paste buffer
;
Paste_Rec STRUC
Paste_Char	    db	?   ; OEM char value
Paste_ScanCode	    db	?   ; keyboard scan code
Paste_ShiftState    dw	?   ; shift state
Paste_Rec ENDS

Paste_Key   equ word ptr Paste_Char


;BeginDoc
;------------------------------------------------------------------------------
;
; API services:
;
VKD_API_Version     equ 0
	;   ENTER:  EAX = 0
	;   EXIT:   AH = major version #
	;	    AL = minor version #
	;	    Carry clear

VKD_Current_Version equ 200h

VKD_Force_Key	    equ 1
	;   ENTER:  EAX = 1
	;	    EBX = VM handle  (0 for current)
	;	    CH = scan code
	;	    CL = repeat count
	;	    EDX = shift state  (-1 means no change)
	;   EXIT:   Carry set, if failed

;
; shift state equates
;
FKSS_Insert_Down    equ 1000000000000000b
FKSS_CapLck_Down    equ 0100000000000000b
FKSS_NumLck_Down    equ 0010000000000000b
FKSS_ScrLck_Down    equ 0001000000000000b
FKSS_Insert_On	    equ 0000000010000000b
FKSS_CapLck_On	    equ 0000000001000000b
FKSS_NumLck_On	    equ 0000000000100000b
FKSS_ScrLck_On	    equ 0000000000010000b
FKSS_Alt_Down	    equ 0000000000001000b
FKSS_Ctrl_Down	    equ 0000000000000100b
FKSS_Shift_Down     equ 0000000000000010b

;EndDoc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\old\SHELL.INC ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1988-1990
;
;   Title:	SHELL.Inc - Public services for SHELL
;
;   Version:	1.00
;
;   Date:	30-Nov-1988
;
;   Author:	ARR
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   19-Sep-1988 RAL Original
;   12-Oct-1988 RAL Converted to use VxD_Service macros
;   29-Nov-1988 ARR Redo split from VMCTRL
;
;==============================================================================

Begin_Service_Table SHELL

SHELL_Service  SHELL_Get_Version, LOCAL
SHELL_Service  SHELL_Resolve_Contention
SHELL_Service  SHELL_Event,LOCAL
SHELL_Service  SHELL_SYSMODAL_Message,LOCAL
SHELL_Service  SHELL_Message,LOCAL
;
; Following specific to SHELL version >= 3.10
;
SHELL_Service  SHELL_GetVMInfo, LOCAL

End_Service_Table SHELL

BeginDoc
;
;   Windows Message Box Flags used on SHELL_SYSMODAL_Message and
;	SHELL_Message services
;
MB_OK			 EQU	    00H
MB_OKCANCEL		 EQU	    01H
MB_ABORTRETRYIGNORE	 EQU	    02H
MB_YESNOCANCEL		 EQU	    03H
MB_YESNO		 EQU	    04H
MB_RETRYCANCEL		 EQU	    05H
MB_ICONHAND		 EQU	    010H
MB_ICONEXCLAMATION	 EQU	    030H
MB_ICONASTERISK 	 EQU	    040H
MB_DEFBUTTON1		 EQU	    00H
MB_DEFBUTTON2		 EQU	    0100H
MB_DEFBUTTON3		 EQU	    0200H
MB_APPLMODAL		 EQU	    00H
MB_SYSTEMMODAL		 EQU	    01000H
MB_NOFOCUS		 EQU	    08000H
;
; Following bits are WIN386 SHELL extensions
;
MB_ASAP 		 EQU	    080000000H	; Message is timely, put
						;   up as soon as possible
;
; The following flag bits are 3.10 extensions.
;
MB_NOWINDOW		 EQU	    040000000H	; DO NOT switch to Windows
						;   to do this message, do it
						;   in full screen mode always.
						;   ONLY FOR SHELL_SYSMODAL_Message

MB_HANGSYS		 EQU	    020000000H	; Hang with ints disabled.
						;   This is for especially
						;   severe errors (like parity
						;   errors).
						;   ONLY FOR SHELL_SYSMODAL_Message

;
;   Windows Message Box Return codes used on SHELL_SYSMODAL_Message and
;	SHELL_Message services
;
IDOK                     EQU	1
IDCANCEL                 EQU	2
IDABORT                  EQU	3
IDRETRY                  EQU	4
IDIGNORE                 EQU	5
IDYES                    EQU	6
IDNO                     EQU	7

EndDoc

;
; On SHELL_Event, the wParam in EAX occupies the low 16 bits of EAX. The High 16
;	bits contain extra flags
;
SE_WP_SetFocusBoost	equ	00000000000000010000000000000000b
SE_WP_SetFocusBoostBit	equ	16		; Boost the SYS VM till a
						; Set_Focus call
SE_WP_SwitcherBoost	equ	00000000000000100000000000000000b
SE_WP_SwitcherBoostBit	equ	17		; Boost the SYS VM on Switcher
						;  screen
SE_WP_FilSysChgBoost	equ	00000000000001000000000000000000b
SE_WP_FilSysChgBoostBit equ	18		; Boost the SYS VM till response
						;  to VDA_FileSysChange
SE_WP_ClipAPIBoost	equ	00000000000010000000000000000000b
SE_WP_ClipAPIBoostBit	equ	19		; Boost the SYS VM during clipbrd
						;  API
SE_WP_PrtScBoost	equ	00000000000100000000000000000000b
SE_WP_PrtScBoostBit	equ	20		; Boost the SYS VM during Print screen

SE_WP_DispUpdBoost	equ	00000000001000000000000000000000b
SE_WP_DispUpdBoostBit	equ	21		; Boost the SYS VM during updates

include shellfsc.inc

BeginDoc
;
; Bits of returned EAX flags for SHELL_GetVMInfo service
;
SGVMI_Windowed	  equ 00000000000000000000000000000100B ; Is Windowed
SGVMI_ALTTABdis   equ 00000000000000000000000000100000b ; Alt+Tab is reserved
SGVMI_ALTESCdis   equ 00000000000000000000000001000000b ; Alt+Esc is reserved
SGVMI_ALTSPACEdis equ 00000000000000000000000010000000b ; Alt+Space is reserved
SGVMI_ALTENTERdis equ 00000000000000000000000100000000b ; Alt+Enter is reserved
SGVMI_ALTPRTSCdis equ 00000000000000000000001000000000b ; Alt+PrtSc is reserved
SGVMI_PRTSCdis	  equ 00000000000000000000010000000000b ; PrtSc is reserved
SGVMI_CTRLESCdis  equ 00000000000000000000100000000000b ; Ctrl+Esc is reserved
SGVMI_HasHotKey   equ 00000000000000000100000000000000b ; Has a shortcut key
SGVMI_Polling	  equ 00000000000000000001000000000000b ; Polling detection Enab
SGVMI_FastPaste   equ 00000000000000100000000000000000b ; Allow Fast paste Enab
SGVMI_NoHMA	  equ 00000000000000000010000000000000b ; No HMA
SGVMI_XMS_Lock	  equ 00000000000000010000000000000000b ; XMS Hands Locked
SGVMI_EMS_Lock	  equ 00000000000000001000000000000000b ; EMS Hands Locked
SGVMI_V86_Lock	  equ 00000000000001000000000000000000b ; V86 Memory Locked
SGVMI_ClsExit	  equ 01000000000000000000000000000000b ; Close on Exit Enab

;
; Bits of returned ECX flags for SHELL_GetVMInfo service
;	Currently no bits defined.
;

EndDoc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\old\RM_AUMGR.H ===
//DOSRM_AU.H contains all the header information for both the
//MPU401 VxD and the ResMan VxD.

// NoteOff priority
//
#define URGENT  0
#define NORMAL 1

#define MAX_NUMVOICES MAX_AUPATCH_INPUT		//max. number of notes for the DOS VxD.

#define	DOSRM_USERNAME	0x6969		//just a random number.

//************ Cut from NV32.H ******************************
	/***** Notification Status Values *****/
	/*
	 * NV sets NvNotification.status to NV_STATUS_DONE_OK if the operation
	 * succeeded.
	 */
	#define NV_STATUS_DONE_OK          0
	/*
	 * Client sets NvNotification.status to NV_STATUS_IN_PROGRESS, NV 
	 * sets to a different value when it notifies.
	 */
	#define NV_STATUS_IN_PROGRESS      255
	/***** NvNotification Structure *****/
	/*
	 * NV objects return information about method completion to clients 
	 * via notification structures in main memory.
	 *
	 * The client sets the status field to NV_STATUS_IN_PROGRESS.
	 * NV sets it to something different when it notifies, after setting 
	 * other fields.  NV fills in the timeStamp; the contents and 
	 * interpretation of the statusInfo, otherInfo32, and OtherInfo16 
	 * fields depend on the status value.  See NV_STATUS_ elsewhere.
	 */
	typedef volatile struct {
	 struct tagNvTimeStamp {
	  U032 nanoseconds[2];           /* Nanoseconds since Jan. 1, 1970 */
	 } timeStamp;                  /*                                 0000-0007*/
	 V032 otherInfo32;             /* info reported depends on method 0008-000b*/
	 V016 otherInfo16;             /* info reported depends on method 000c-000d*/
	 V008 statusInfo;              /* ERROR1 code if (status==ERROR1) 000e-000e*/
	 V008 status;                  /* client sets, NV changes         000f-000f*/
	} NvNotification;

//******************************************

typedef struct {
	NvNotification BufNotify;
} DOSRM_NOTE_STRUC;

//List of possible parameter types accepted by NVChangeParam_HW()
#define VOLUME				0
#define SAMPLE_RATE			1
#define VIBRATO				3
#define TREMOLO				4
#define EFFECTS				5

#define VOICE_UNUSED	(0x0FF)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\old\VDD.H ===
#ifndef _VDD_H_
#define _VDD_H_
/************ Operating System Interface for NVidia Hardware ***************\
*                                                                           *
* Module: VDD.H                                                             *
*       Header file for Virtual Display device.                             *
*                                                                           *
*---------------------------------------------------------------------------*
*                                                                           *
* History:                                                                  *
*        David Schmenk (dschmenk)      7/22/95 - wrote it                   *
*                                                                           *
\*********************** Copyright 1995 NVidia, Inc. ***********************/
//***************************************************************************
//
//   (C) Copyright MICROSOFT Corp., 1988-1993
//
//   Title: minivdd.inc - VDD definitions for other VxD's and multiple VDD's
//
//   Version:   4.00
//
//   Date:
//
//   Author: FredE for the Mini-VDD interface.  Adapted from VDD.INC in
//      the general include area.  Added services are ONLY for the
//      use of the Mini-VDD and should therefore not be documented.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Defines.
//
//---------------------------------------------------------------------------
//
// VDD services.
//
#define VDD_Get_Version                     0x0000  // Get version number and ID string ptr
#define VDD_PIF_State                       0x0001  // Pass video PIF bits to VDD
#define VDD_Get_GrabRtn                     0x0002  // Get routine addr for video grab
#define VDD_Hide_Cursor                     0x0003  // Hide cursor when display is windowed
#define VDD_Set_VMType                      0x0004  // Set VM type(windowed, bckgrnd, excl)
#define VDD_Get_ModTime                     0x0005  // Return system time of last mod
#define VDD_Set_HCurTrk                     0x0006  // Track horiz cursor movement in window
#define VDD_Msg_ClrScrn                     0x0007  // Clear screen for sysmodal message
#define VDD_Msg_ForColor                    0x0008  // Set Msg_TextOut forground color
#define VDD_Msg_BakColor                    0x0009  // Set Msg_TextOut background color
#define VDD_Msg_TextOut                     0x000A  // Output a string
#define VDD_Msg_SetCursPos                  0x000B  // Set cursor position
#define VDD_Query_Access                    0x000C  // Is it OK to access video now?
#define VDD_Check_Update_Soon               0x000D  // User action may update screen
#define VDD_Get_Mini_Dispatch_Table         0x000E  // Get addr of dispatch table to mini-VDD
#define VDD_Register_Virtual_Port           0x000F  // Mini-VDD asks us to setup I/O trap
#define VDD_Get_VM_Info                     0x0010  // Returns CRTC owner and MemC owners
                                                    // and other special VM handles
#define VDD_Get_Special_VM_IDs              0x0011  // returns planar & msg mode IDs
#define VDD_Register_Extra_Screen_Selector  0x0012  // allows display driver to use second
                                                    // screen selector for block moves
#define VDD_Takeover_VGA_Port               0x0013  //allows MiniVDD to takeover a port
                                                    // in range 3C0H through 3DFH
#define VDD_Get_DISPLAYINFO                 0x0014  //get DISPLAYINFO data structure
#define VDD_Do_Physical_IO                  0x0015  //perform physical I/O for trapped port
#define VDD_Set_Sleep_Flag_Addr             0x0016  //when display driver can't be interrupted
//
// Following are function codes that can be called via the VDD's
// API entry point. These are mainly for display driver --> VDD communication.
// Since Windows 3.0 and 3.1 VDD's may have used the sequential numbers
// (after the Grabber functions) for other VDD API services, we start our
// numbering at 80H so as to avoid ugly conflicts with old 3.1 stuff:
//
#define MINIVDD_SVC_BASE_OFFSET             0x80
#define VDD_DRIVER_REGISTER                 (0 | MINIVDD_SVC_BASE_OFFSET)
#define VDD_DRIVER_UNREGISTER               (1 | MINIVDD_SVC_BASE_OFFSET)
#define VDD_SAVE_DRIVER_STATE               (2 | MINIVDD_SVC_BASE_OFFSET)
#define VDD_REGISTER_DISPLAY_DRIVER_INFO    (3 | MINIVDD_SVC_BASE_OFFSET)
#define VDD_REGISTER_SSB_FLAGS              (4 | MINIVDD_SVC_BASE_OFFSET)
#define VDD_GET_DISPLAY_CONFIG              (5 | MINIVDD_SVC_BASE_OFFSET)
#define VDD_PRE_MODE_CHANGE                 (6 | MINIVDD_SVC_BASE_OFFSET)
#define VDD_POST_MODE_CHANGE                (7 | MINIVDD_SVC_BASE_OFFSET)
#define VDD_SET_USER_FLAGS                  (8 | MINIVDD_SVC_BASE_OFFSET)
#define VDD_SET_BUSY_FLAG_ADDR              (9 | MINIVDD_SVC_BASE_OFFSET)
typedef struct
{
    WORD  HdrSize;
    WORD  InfoFlags;
    DWORD DevNodeHandle;
    BYTE  DriverName[16];
    WORD  XRes;
    WORD  YRes;
    WORD  DPI;
    BYTE  Planes;
    BYTE  Bpp;
    WORD  RefreshRateMax;
    WORD  RefreshRateMin;
    WORD  LowHorz;
    WORD  HighHorz;
    WORD  LowVert;
    WORD  HighVert;
    DWORD MonitorDevNodeHandle;
    BYTE  HorzSyncPolarity;
    BYTE  VertSyncPolarity;
} DISPLAYINFO, * PDISPLAYINFO;
//
// Following are values and explanations for the diInfoFlags word in DISPLAYINFO:
//
// RETURNED_DATA_IS_STALE, if set, means that this call to VDD_GET_DISPLAY_CONFIG
// or VDD_GetDisplayInfo (which are the Ring 3 and Ring 0 methods by which a
// program would get the DISPLAYINFO structure returned to him) caused the VDD
// to return data that was read in a previous call to VDD_GET_DISPLAY_CONFIG
// insted of actually going out and reading "fresh" data from the Registry.
//
// This flag brings to light the fact that there are some circumstances when the
// VDD cannot go out and read the registry in response to the call to
// VDD_GET_DISPLAY_CONFIG or VDD_GetDisplayInfo (due to system multi-tasking
// considerations).  In this case, this flag will be set to a 1 to indicate that
// the information being returned isn't "fresh" -- that is -- it may be
// incorrect and obsolete.  The caller should respond accordingly if this flag
// is set.
//
#define RETURNED_DATA_IS_STALE          0x0001
//
// MINIVDD_FAILED_TO_LOAD if set, indicates that for some reason (typically
// that the MiniVDD didn't match the chipset installed in the machine), the
// MiniVDD didn't load.  Callers can examine this flag and act accordingly.
//
#define MINIVDD_FAILED_TO_LOAD          0x0002
//
// MINIVDD_CHIP_ID_DIDNT_MATCH means that although the MiniVDD did load
// successfully, when the ChipID that the MiniVDD calculated was compared
// against the value saved in the registry, they didn't match.  An example of
// when this would happen is when the user is happily using an S3-911 card
// and then decides to upgrade his display card to an S3-864.  Since both
// cards use S3.VXD, the MiniVDD will load, however, since the card model
// is different, the VDD will return a defect to configuration manager and
// set this flag.  Callers of the GET_DISPLAY_CONFIG functions can use this
// flag to take appropriate actions to make sure that the user gets his
// configuration correct.
//
#define MINIVDD_CHIP_ID_DIDNT_MATCH     0x0004
//
// REGISTRY_BPP_NOT_VALID if set, means that we failed to obtain the BPP value
// from the registry when the VDD tried to read it.
//
#define REGISTRY_BPP_NOT_VALID          0x0008
//
// REGISTRY_RESOLUTION_NOT_VALID if set, means that we failed to obtain the
// resolution value from the registry when the VDD tried to read it.
//
#define REGISTRY_RESOLUTION_NOT_VALID   0x0010
//
// REGISTRY_DPI_NOT_VALID if set, means that we failed to obtain the
// DPI value from the registry when the VDD tried to read it.
//
#define REGISTRY_DPI_NOT_VALID          0x0020
//
// MONITOR_DEVNODE_NOT_ACTIVE is set if someone tries to make a call to the
// GET_DISPLAY_CONFIG function before the monitor DevNode has been created.
// This is certainly not fatal by any means.  It simply means that the
// monitor refresh rate info in the DISPLAYINFO data structure is totally
// invalid!
//
#define MONITOR_DEVNODE_NOT_ACTIVE      0x0040
//
// MONITOR_INFO_NOT_VALID indicates that something within the code which
// retrieves and calculates the refresh rate data has failed.  This indicates
// that the values in diRefreshRateMax through diVertSyncPolarity are not
// valid and could contain random data.
//
#define MONITOR_INFO_NOT_VALID          0x0080
//
// MONITOR_INFO_DISABLED_BY_USER indicates that the either the RefreshRate=
// string in SYSTEM.INI had a negative number in it or that the string in
// the display's software key (HKEY_CURRENT_CONFIG\Display\Settings\RefreshRate)
// was 0 or a negative number.
//
#define MONITOR_INFO_DISABLED_BY_USER   0x0100
//
// REFRESH_RATE_MAX_ONLY indicates that there was no diLowHorz, diHighHorz,
// diLowVert, diHighVert, or sync polarity data in the registry.    The
// value returned in diRefreshRateMax is the only refresh rate data that
// we have available.  This was derived either from RefreshRate= in SYSTEM.INI
// or the HKEY_CURRENT_CONFIG\Display\Settings\RefreshRate = string in the
// registry.
//
#define REFRESH_RATE_MAX_ONLY           0x0200
//
// CARD_VDD_LOADED_OK indicates that a second MiniVDD (which is useful for
// display card manufacturers wishing to extend the capabilities of the chip level
// MiniVDD's ) has successfully been loaded and initialized.
//
#define CARD_VDD_LOADED_OK              0x0400
//
// Make functions to these services.
//
WORD  vddGetVersion(VOID);
DWORD vddGetDisplayInfo(PDISPLAYINFO, DWORD);

#pragma aux vddGetVersion =                                 \
            CALL_VXD(VDD_Device_ID, VDD_Get_Version)        \
            value [AX];

#pragma aux vddGetDisplayInfo =                             \
            CALL_VXD(VDD_Device_ID, VDD_Get_DISPLAYINFO)    \
            parm [EAX] [ECX]                                \
            value [EAX]                                     \
            modify [EBX ECX EDX ESI EDI];
#endif // _VDD_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\old\VPAGED.H ===
#ifndef _VPAGED_H_
#define _VPAGED_H_
/******** Operating System Interface for NVidia Hardware Simulator  ********\
*                                                                           *
* Module: VPAGED.H                                                          *
*       Header file for Virtual Paging device.                              *
*                                                                           *
*---------------------------------------------------------------------------*
*                                                                           *
* History:                                                                  *
*        David Schmenk (dschmenk)     05/08/95 - wrote it                   *
*                                                                           *
\*********************** Copyright 1994 NVidia, Inc. ***********************/

//---------------------------------------------------------------------------
//
//  Defines.
//
//---------------------------------------------------------------------------

#define PageSwap_Get_Version    0x0000
#define PageSwap_Test_Create    0x0001
#define PageSwap_Create         0x0002
#define PageSwap_Destroy        0x0003
#define PageSwap_In             0x0004
#define PageSwap_Out            0x0005
#define PageSwap_Test_IO_Valid  0x0006
#define PS_Zero_Init_Mask       0x0001
#define PS_Zero_Init_Bit        0x0000
#define PS_Fixed_Page_Mask      0x0008
#define PS_Fixed_Page_Bit       0x0003
#define PS_First_Page_In_Mask   0x0020
#define PS_First_Page_In_Bit    0x0005
#define PS_Dirty_Mask           0x0040
#define PS_Dirty_Bit            0x0006
#define PS_Ever_Dirty_Mask      0x8000
#define PS_Ever_Dirty_Bit       0x000F
#define PS_NoXchg_Mask          0x80000000
#define PS_NoXchg_Bit           0x001F     // DO NOT xchg phys addrs on PageSwap_Out
#define PS_No_Pager             0x01
#define PS_MSDOS_Pager          0x02
#define PS_HW_Pager             0x03
//
// Buffer descriptor for asynchronous I/O
//
#define SIZE_PS_BD_RESERVED     44
struct PageSwapBufferDesc
{
    DWORD PS_BD_Next;
    WORD  PS_BD_List;
    BYTE  PS_BD_Cmd;
    BYTE  PS_BD_Priority;
    DWORD PS_BD_Page_Number;
    DWORD PS_BD_Buffer_Ptr;
    DWORD PS_BD_File_Page;
    DWORD PS_BD_Call_Back;
    BYTE PS_BD_Reserved[SIZE_PS_BD_RESERVED];
};
//
// List values for PS_BD_List
//
#define PS_BDL_Free         1
#define PS_BDL_Pending_WB   2
#define PS_BDL_Submitted_RA 3
#define PS_BDL_Locked       4
#define PS_BDP_Invalid_Data -1
//
// VPAGED callback routines.
//
#pragma aux VPAGED_INT  modify [EAX EBX ECX EDX];
//
// Make functions to these services.
//
DWORD pagerGetVersion(VOID);
BYTE  pagerGetAccessType(VOID);

#pragma aux pagerGetVersion =                                   \
            CALL_VXD(PageSwap_Device_ID, PageSwap_Get_Version)  \
            value [EAX];

#pragma aux pagerGetAccessType =                                \
            CALL_VXD(PageSwap_Device_ID, PageSwap_Get_Version)  \
            value [BL];
#endif // _VPAGED_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\old\THKTYPES.H ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       thktypes.h
 *  Content:	base types used by thunk compiler
 *
 ***************************************************************************/
typedef unsigned short USHORT;
typedef          short  SHORT;
typedef unsigned long  ULONG;
typedef          long   LONG;
typedef unsigned int   UINT;
typedef          int    INT;
typedef unsigned char  UCHAR;
//typedef hinstance HINSTANCE;
//typedef		int	BOOL;

//typedef void    VOID;
typedef void   *PVOID;
typedef void   *LPVOID;
typedef UCHAR   BYTE;
typedef USHORT  WORD;
typedef ULONG   DWORD;
typedef UINT    HANDLE;
typedef char   *LPSTR;
typedef BYTE   *PBYTE;
typedef BYTE   *LPBYTE;
typedef USHORT  SEL;
typedef INT    *LPINT;
typedef UINT   *LPUINT;
typedef DWORD  *LPDWORD;
typedef LONG   *LPLONG;
typedef WORD   *LPWORD;

typedef HANDLE  HWND;
typedef HANDLE  HDC;
typedef HANDLE  HBRUSH;
typedef HANDLE  HBITMAP;
typedef HANDLE  HRGN;
typedef HANDLE  HFONT;
typedef HANDLE  HCURSOR;
typedef HANDLE  HMENU;
typedef HANDLE  HPEN;
typedef HANDLE  HICON;
typedef HANDLE  HUSER;      /* vanilla user handle */
typedef HANDLE  HPALETTE;
typedef HANDLE  HMF;
typedef HANDLE  HEMF;
typedef HANDLE	HCOLORSPACE;
typedef HANDLE  HMEM;
typedef HANDLE  HGDI;       /* vanilla gdi handle */
typedef HANDLE  HGLOBAL;
typedef HANDLE  HRSRC;
typedef HANDLE  HACCEL;

typedef WORD    ATOM;

typedef struct tagRECTL {
    LONG         left;
    LONG         top;
    LONG         right;
    LONG         bottom;
} RECTL;
typedef RECTL *LPRECTL;

typedef struct tagRECT {
    UINT         left;
    UINT         top;
    UINT         right;
    UINT         bottom;
} RECT;
typedef RECT *LPRECT;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\old\VPICD.INC ===
;****************************************************************************
;                                                                           *
; THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
; KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
; IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
; PURPOSE.                                                                  *
;                                                                           *
; Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
;                                                                           *
;****************************************************************************

VPICD_STAT_IRET_PENDING	EQU	01H
VPICD_STAT_IRET_PENDING_BIT	EQU	0
VPICD_STAT_IN_SERVICE	EQU	02H
VPICD_STAT_IN_SERVICE_BIT	EQU	1
VPICD_STAT_PHYS_MASK	EQU	04H
VPICD_STAT_PHYS_MASK_BIT	EQU	2
VPICD_STAT_PHYS_IN_SERV	EQU	08H
VPICD_STAT_PHYS_IN_SERV_BIT	EQU	3
VPICD_STAT_VIRT_MASK	EQU	10H
VPICD_STAT_VIRT_MASK_BIT	EQU	4
VPICD_STAT_VIRT_REQ	EQU	20H
VPICD_STAT_VIRT_REQ_BIT	EQU	5
VPICD_STAT_PHYS_REQ	EQU	40H
VPICD_STAT_PHYS_REQ_BIT	EQU	6
VPICD_STAT_VIRT_DEV_REQ	EQU	80H
VPICD_STAT_VIRT_DEV_REQ_BIT	EQU	7
VPICD_STAT_GLOBAL	EQU	100H
VPICD_STAT_GLOBAL_BIT	EQU	8
VPICD_STAT_OWNED_BY_VM	EQU	200H
VPICD_STAT_OWNED_BY_VM_BIT	EQU	9
VPICD_OPT_READ_HW_IRR	EQU	01H
VPICD_OPT_READ_HW_IRR_BIT	EQU	0
VPICD_OPT_CAN_SHARE	EQU	02H
VPICD_OPT_CAN_SHARE_BIT	EQU	1
VPICD_OPT_REF_DATA	EQU	04H
VPICD_OPT_REF_DATA_BIT	EQU	2
VPICD_OPT_VIRT_INT_REJECT	EQU	10H
VPICD_OPT_VIRT_INT_REJECT_BIT	EQU	4
VPICD_OPT_SHARE_PMODE_ONLY	EQU	20H
VPICD_OPT_SHARE_PMODE_ONLY_BIT	EQU	5
VPICD_OPT_ALL	EQU	3FH
VPICD_FDO_NO_CONTENTION	EQU	10000H
VPICD_FDO_NO_CONTENTION_BIT	EQU	16
VPICD_FDO_FAVOR_FOCUS	EQU	20000H
VPICD_FDO_FAVOR_FOCUS_BIT	EQU	17

VPICD_IRQ_Descriptor	STRUC
VID_IRQ_Number	DW	?
VID_Options	DW	0
VID_Hw_Int_Proc	DD	?
VID_Virt_Int_Proc	DD	0
VID_EOI_Proc	DD	0
VID_Mask_Change_Proc	DD	0
VID_IRET_Proc	DD	0
VID_IRET_Time_Out	DD	500
VID_Hw_Int_Ref	DD	?
VPICD_IRQ_Descriptor	ENDS
Begin_Service_Table VPICD
VPICD_Service	 VPICD_Get_Version, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Virtualize_IRQ, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Set_Int_Request, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Clear_Int_Request, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Phys_EOI, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Get_Complete_Status, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Get_Status, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Test_Phys_Request, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Physically_Mask, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Physically_Unmask, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Set_Auto_Masking, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Get_IRQ_Complete_Status, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Convert_Handle_To_IRQ, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Convert_IRQ_To_Int, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Convert_Int_To_IRQ, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Call_When_Hw_Int, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Force_Default_Owner, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Force_Default_Behavior, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Auto_Mask_At_Inst_Swap
VPICD_Service	 VPICD_Begin_Inst_Page_Swap
VPICD_Service	 VPICD_End_Inst_Page_Swap
VPICD_Service	 VPICD_Virtual_EOI, VxD_LOCKED_CODE
VPICD_Service	 VPICD_Get_Virtualization_Count
VPICD_Service	 VPICD_Post_Sys_Critical_Init, LOCAL
VPICD_Service	 VPICD_VM_SlavePIC_Mask_Change, VxD_LOCKED_CODE
End_Service_Table VPICD
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\old\VMDAVGA.INC ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1988-1990
;
;   Title:	VMDAVGA.INC
;
;   Version:	3.10
;
;   Date:	15-Aug-1990
;
;   Author: AR, MDW, RAP
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   24-Jan-1989 MDW Added service definitions(some from VDAMSG.INC)
;   15-Feb-1989 MDW Memory data structures
;   15-Aug-1990 RAP VGA version of VMDAEGA.INC
;
;==============================================================================



;******************************************************************************
;
;	VDD virtual mode services for the grabber
;
GRB_Get_Version     EQU 0
GRB_Get_Mem	    EQU GRB_Get_Version + 1
GRB_Get_State	    EQU GRB_Get_Mem + 1
GRB_Get_Mod	    EQU GRB_Get_State + 1
GRB_Clear_Mod	    EQU GRB_Get_Mod + 1
GRB_Free_Mem	    EQU GRB_Clear_Mod + 1
GRB_Get_GrbMem	    EQU GRB_Free_Mem + 1
GRB_Free_Grab	    EQU GRB_Get_GrbMem + 1
GRB_Get_GrbState    EQU GRB_Free_Grab + 1
GRB_Unlock_APP	    EQU GRB_Get_GrbState + 1

; New API's for 3.1 display drivers
Private_DspDrvr_1   EQU 0Ah
			    .errnz Private_DspDrvr_1 - GRB_Unlock_APP - 1
DspDrvr_Version     EQU 0Bh
DspDrvr_Addresses   EQU 0Ch


Grabber_VerNum	    EQU     030Ah	    ; version 3, 10


;*******************************************************************************
;
;	Controller state structure
;
VDA_EGA_State	STRUC
    VDA_EGA_Mode    DB	?		; Display mode(0-A)
    VDA_EGA_Colr    DB	?		; Border color
    VDA_EGA_Flags   DB	?		; Flags
    VDA_EGA_Rows    DB	?		; Height of display in lines (text mode)
    VDA_EGA_CurX    DW	?		; Cursor horizontal position
    VDA_EGA_CurY    DW	?		; Cursor vertical position
    VDA_EGA_CurBeg  DW	?		; Cursor start scan line
    VDA_EGA_CurEnd  DW	?		; Cursor end scan line
    VDA_EGA_Pal     DB	16 DUP (?)	; Palettes(6 bits of color mapping)
VDA_EGA_State	ENDS

;*******
;
;	Controller flags
;
fVDA_V_ScOff	    EQU 0001h		; Screen off
fVDA_V_ScOffBit     EQU 0
fVDA_V_HCurTrk	    EQU 0002h		; Horizontal cursor track - keep
fVDA_V_HCurTrkBit   EQU 1		;   cursor position in window
; GEM Ventura programs DAC 0 as white - set if DAC 0 is non-zero
fVDA_V_InvDAC	    EQU 0004h		
fVDA_V_InvDACBit    EQU 2


BeginDoc
;*******************************************************************************
;   EGA/VGA VDD modifications state structure ::= <flag>,<count>,<list>
;
;   <flag> indicates type, list valid and controller change and cursor change.
;   <count> is count of entries(not bytes or words) in list.
;   <list> is type dependent as follows:
;	Type 0 - list is modified pages bit map, 1 bit per displayed 4k page,
;	    count is page count. Bit map is one byte per 32k linear address
;	    space, where byte 0's bits are <page 0 bit>,<page 1 bit>,
;	    ...,<page 7 bit>. byte 1's bits are <page 8 bit>,<page 9 bit>.
;	    A set bit indicates a change in that page.
;
;	    This type is not used for text modes.
;
;	    Modes D and E display is less than two pages long and so the
;	    page count will be two. Mode 10 page count is 7. Modes
;	    11 and 12 page count is 10.
;
;	Type 1 - modified enclosing rectangles, count is rectangle count,
;	    (less than four) , rectangle is two points: <left>,<top> and
;	    <right>,<bottom>. Each point is relative to left, upper
;	    corner which is 0,0 and each value is stored in one word.
;
;	    This type may be used for all modes.
;
;	    For text modes, modes 0-3, there may be a special, scroll rectangle.
;	    If the high bit of R_Left is set in one of these RECTs, then it is
;	    not a rect but a scroll specification.
;		The structure then becomes: <scroll count>,<scroll flags>,
;		<right column>,<left column>,<bottom line>,<top line>,
;		<fill character>,<fill attribute>
;	    Note that all items are byte values and that the scroll event
;		specification takes the same space as an update rectangle.
;
ModListMax	EQU	64		    ; Max size of VDD_Mod_List field
EndDoc
VDD_Mod_State	STRUC

    VDD_Mod_Flag    DW	?		    ; Modified state flag
    VDD_Mod_Count   DW	?		    ; Count of entries in modification list
    VDD_Mod_List    DB	ModListMax dup(?)   ; The modification list(type dependent)

VDD_Mod_State	ENDS

;*******
;
; Masks and bit numbers for VDD_Mod_Flag
;
fVDD_M_Type	EQU 0000000000000111B	; Mask for value field
fVDD_M_TypeBit	EQU 0			; start bit for value field
fVDD_M_Ctlr	EQU 0000000000001000B	; flag indicating controller state chg
fVDD_M_CtlrBit	EQU 3			; bit for controller state change
fVDD_M_VRAM	EQU 0000000000010000B	; flag indicating Video RAM change
fVDD_M_VRAMBit	EQU 4			; bit for Video RAM change
fVDD_M_Curs	EQU 0000000000100000B	; flag indicating Cursor change
fVDD_M_CursBit	EQU 5			; bit for Cursor change
fVDD_M_ScOff	EQU 0000000001000000B	; flag indicating screen is off
fVDD_M_ScOffBit EQU 6			; bit for screen off
fVDD_M_Err	EQU 1000000000000000B	; flag indicating error, can't pass mods
fVDD_M_ErrBit	EQU 15			; bit for error
;
; Values for fVDD_M_TypeMsk field
;
fVDD_M_Type_Page	EQU    0	; Bit field of modified pages
fVDD_M_Type_Rect	EQU    1	; Array of RECT structures

;*******
;
; Structure for accessing RECTs
;
Rect	STRUC
    R_Left  DW	?
    R_Top   DW	?
    R_Right DW	?
    R_Botm  DW	?
Rect	ENDS

;********
;
;	Scroll rect definition
;
; If the high bit of R_Left is set in one of these RECTs, then it is
;  not a rect but a scroll event specification.
;  THIS APPLIES TO TEXT MODE ONLY (modes 0-3)!!
;  A scroll event spec looks like this:
;
ScrollRect STRUC
    ScrCnt  DB	?	    ; Count of lines to scroll in scroll region
    ScrFlgs DB	?	    ; Flags
    ScrRgt  DB	?	    ; Right Col of scroll (0 indexed)(ignore if full width bit set)
    ScrLft  DB	?	    ; Left Col of scroll (0 indexed)(ignore if full width bit set)
    ScrBot  DB	?	    ; Bottom line of scroll (0 indexed)
    ScrTop  DB	?	    ; Top line of scroll (0 indexed)
    ScrFch  DB	?	    ; Fill character for blank lines of scroll
    ScrFatt DB	?	    ; Fill attribute for blank lines of scroll
ScrollRect ENDS

; Masks for ScrFlgs
Scr_M_Scroll	    EQU 10000000B   ; High bit of flags indicates scroll
Scr_M_ScrollBit     EQU 7
Scr_M_FullWid	    EQU 00000001B   ; Set if scroll is full width (ignore Rgt Lft)
Scr_M_FullWidBit    EQU 0
Scr_M_Up	    EQU 00000010B   ; Set if scroll is UP, clear if DOWN
Scr_M_UpBit	    EQU 1

IF2
    IF (SIZE ScrollRect) NE (SIZE Rect)
	%out ERROR -- ScrollRect is wrong size!!!!!
    ENDIF
ENDIF


;*******************************************************************************
;
;	Memory state structure
;
VDA_Mem_State	STRUC
    VDA_Mem_Addr_P0	DD  ?		; Addr of plane 0 video memory
    VDA_Mem_Addr_P1	DD  ?		; Addr of plane 1 video memory
    VDA_Mem_Addr_P2	DD  ?		; Addr of plane 2 video memory
    VDA_Mem_Addr_P3	DD  ?		; Addr of plane 3 video memory
    VDA_Mem_DPagOff	DD  ?		; 32 bit offset to start of display
    VDA_Mem_Size_P0	DD  ?		; Size of plane 0 video memory
    VDA_Mem_Size_P1	DD  ?		; Size of plane 1 video memory
    VDA_Mem_Size_P2	DD  ?		; Size of plane 2 video memory
    VDA_Mem_Size_P3	DD  ?		; Size of plane 3 video memory
    VDA_Mem_DACOff	DD  ?		; address of DAC
VDA_Mem_State	ENDS

VDA_Mem_Addr_Win_State EQU VDA_Mem_Addr_P1  ; In text (0-3,7) modes
VDA_Mem_Size_Win_State EQU VDA_Mem_Size_P1

;*******
;
; ADDRESSING VIDEO DISPLAY
;
; Start of the display memory = VDA_Mem_Addr[plane] + VDA_Mem_DPagOffset
;
;   For modes 0-6, the <plane> is always 0
;
;   Displayed memory within a plane is always contiguous from the start
;	address as computed according to the formula above and the macro below.
;	Addressing the display memory from the computed start is as follows,
;	    where X is 0 based column and Y is 0 based row.
;
;	Mode 0-1: Even byte is char, odd byte is attr, 40 cols, 25 rows
;		   one plane.
;	    ChrByteOff=(X/2)+(Y*80); AttrByteOff=ChrByteOff+1
;
;	Mode 2-3,7: Even byte is char, odd byte is attr, 80 cols, 25 rows,
;		   one plane.
;	    ChrByteOff=(X/2)+(Y*160); AttrByteOff=ChrByteOff+1
;
;	Mode 3,"43": Even byte is char, odd byte is attr, 80 cols,
;		    43 rows on EGA or VGA, one plane.
;	    ChrByteOff=(X/2)+(Y*160); AttrByteOff=ChrByteOff+1
;
;	Mode 3,"50": Even byte is char, odd byte is attr, 80 cols,
;		    50 rows on VGA, one plane.
;	    ChrByteOff=(X/2)+(Y*160); AttrByteOff=ChrByteOff+1
;
;	Mode 4-5: 2 bits per PEL, packed into bytes: bits 7-6 is PEL 0,
;		    bits 5-4 is PEL 1, etc. Where PEL = X MOD 4. Odd rows
;		    offset by 8k from even rows. 320 cols, 200 rows, one plane.
;	    PELByteOff=(X/4)+((Y/2)*80)+((Y MOD 2)*8192)
;
;	Mode 6: 1 bit per PEL, packed into bytes: bit 7 is PEL 0,
;		    bit 6 is PEL 1, bit 5 is PEL 2, etc., where PEL = X MOD 8.
;		    Odd rows offset by 8k from even rows. 640 cols, 200 rows,
;		    one plane.
;	    PELByteOff=(X/8)+((Y/2)*160)+((Y MOD 2)*8192)
;
;	Mode D: 1 bit per PEL in each plane, packed into bytes: bit 7 is PEL 0,
;		    bit 6 is PEL 1, etc., where PEL = X MOD 8. 320 cols,
;		    200 rows, 4 planes. Note that the start of each plane
;		    must be calculated according to the GetStartDispAddr macro.
;	    PELByteOff=(X/8)+(Y*80)
;
;	Mode E: 1 bit per PEL in each plane, packed into bytes: bit 7 is PEL 0,
;		    bit 6 is PEL 1, etc., where PEL = X MOD 8. 640 cols,
;		    200 rows, 4 planes. Note that the start of each plane
;		    must be calculated according to the GetStartDispAddr macro.
;	    PELByteOff=(X/8)+(Y*160)
;
;	Mode 10: 1 bit per PEL in each plane, packed into bytes: bit 7 is PEL 0,
;		    bit 6 is PEL 1, etc., where PEL = X MOD 8. 640 cols,
;		    350 rows, 4 planes. Note that the start of each plane
;		    must be calculated according to the GetStartDispAddr macro.
;	    PELByteOff=(X/8)+(Y*160)
;
;	Mode 12: 1 bit per PEL in each plane, packed into bytes: bit 7 is PEL 0,
;		    bit 6 is PEL 1, etc., where PEL = X MOD 8. 640 cols,
;		    480 rows, 4 planes. Note that the start of each plane
;		    must be calculated according to the GetStartDispAddr macro.
;	    PELByteOff=(X/8)+(Y*160)
;
;	Mode 13: 8 bits or one byte per PEL.  320 cols, 200 rows, 1 plane.
;	    PELByteOff=(X)+(Y*160)
;
;
;	DestReg     = 32 bit register to place video memory address
;	MemStateReg = 32 bit register which -> VDA_Mem_State
;	MemStateSeg = SEGMENT REGISTER for MemStateReg
;	PlaneReg    = 32 bit register holding plane number desired
;
; ALL REGISTERS MUST BE SEPARATE!!!!!
;
;
GetStartDispAddr MACRO	 DestReg,MemStateReg,PlaneReg,MemStateSeg
	mov	DestReg,MemStateSeg:[MemStateReg.VDA_Mem_Addr_P0][PlaneReg*4]
	add	DestReg,MemStateSeg:[MemStateReg.VDA_Mem_DPagOff]
	ENDM
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\old\VMMTYPES.H ===
#ifndef _VMMTYPES_H_
#define _VMMTYPES_H_

#ifndef NULL
#define NULL               0
#endif
#ifndef VOID
#define VOID               void
#endif
#ifndef PASCAL
#define PASCAL             _pascal
#endif
#ifndef CDECL
#define CDECL              _cdecl
#endif

#ifndef BOOL
#define BOOL                unsigned long
#endif
#ifndef FALSE
#define FALSE              0
#endif
#ifndef TRUE
#define TRUE               (~FALSE)
#endif

#ifndef LONG
#define LONG               long
#endif
typedef unsigned char      BYTE;
typedef unsigned short     WORD;
typedef unsigned long      DWORD;
typedef double             QWORD;
typedef unsigned int       UINT;
typedef char *             PSTR;
typedef BYTE *             PBYTE;
typedef int *              PINT;
typedef UINT *             PUINT;
typedef WORD *             PWORD;
typedef DWORD *            PDWORD;
typedef QWORD *            PQWORD;

typedef union
{
    QWORD Desc64;
    DWORD Desc32[2];
    WORD  Desc16[4];
    BYTE  Desc8[8];
} DESCRIPTOR, *PDESCRIPTOR;

typedef union
{
    QWORD HandleAddress;
    struct
    {
        DWORD Handle;
        DWORD Address;
    } ha;
} PAGEALLOC, *PPAGEALLOC;

#ifndef LOBYTE
#define LOBYTE(w)          ((BYTE)(w))
#endif
#ifndef HIBYTE
#define HIBYTE(w)          ((BYTE)(((UINT)(w) >> 8) & 0xFF))
#endif
#ifndef LOWORD
#define LOWORD(l)          ((WORD)(DWORD)(l))
#endif
#ifndef HIWORD
#define HIWORD(l)          ((WORD)((((DWORD)(l)) >> 16) & 0xFFFF))
#endif
#ifndef MAKELONG
#define MAKELONG(low, high) ((LONG)(((WORD)(low)) | (((DWORD)((WORD)(high))) << 16)))
#endif

#endif // _VMMTYPES_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\old\VMM.H ===
#ifndef _VMM_H_
#define _VMM_H_

//---------------------------------------------------------------------------
//
//  vmm.h
//
//              6/21/94   dschmenk    Updated to use Watcom inline functions
//              4/11/95   dschmenk    Updated to use Win 95 extensions
//
//---------------------------------------------------------------------------

#include <vmmtypes.h>

//----------------------------------------------------------------------------
//
//                        Device ID equates
//
//----------------------------------------------------------------------------

#define Undefined_Device_ID    0x00000
#define VMM_Device_ID          0x00001   // Used for dynalink table
#define Debug_Device_ID        0x00002
#define VPICD_Device_ID        0x00003
#define VDMAD_Device_ID        0x00004
#define VTD_Device_ID          0x00005
#define V86MMGR_Device_ID      0x00006
#define PageSwap_Device_ID     0x00007
#define Parity_Device_ID       0x00008
#define Reboot_Device_ID       0x00009
#define VDD_Device_ID          0x0000A
#define VSD_Device_ID          0x0000B
#define VMD_Device_ID          0x0000C
#define VKD_Device_ID          0x0000D
#define VCD_Device_ID          0x0000E
#define VPD_Device_ID          0x0000F
#define BlockDev_Device_ID     0x00010
#define VMCPD_Device_ID        0x00011
#define EBIOS_Device_ID        0x00012
#define BIOSXlat_Device_ID     0x00013
#define VNETBIOS_Device_ID     0x00014
#define DOSMGR_Device_ID       0x00015
#define WINLOAD_Device_ID      0x00016
#define SHELL_Device_ID        0x00017
#define VMPoll_Device_ID       0x00018
#define VPROD_Device_ID        0x00019
#define DOSNET_Device_ID       0x0001A
#define VFD_Device_ID          0x0001B
#define VDD2_Device_ID         0x0001C   // Secondary display adapter
#define WINDEBUG_Device_ID     0x0001D
#define TSRLoad_Device_ID      0x0001E   // TSR instance utility ID
#define BiosHook_Device_ID     0x0001F   // Bios interrupt hooker VxD
#define Int13_Device_ID        0x00020
#define PageFile_Device_ID     0x00021   // Paging File device
#define SCSI_Device_ID         0x00022   // SCSI device
#define MCA_POS_Device_ID      0x00023   // MCA_POS device
#define SCSIFD_Device_ID       0x00024   // SCSI FastDisk device
#define VPEND_Device_ID        0x00025   // Pen device
#define APM_Device_ID          0x00026   // Power Management device
#define VPOWERD_DEVICE_ID      APM_DEVICE_ID   // We overload APM since we replace it
#define VXDLDR_DEVICE_ID       0x00027   // VxD Loader device
#define NDIS_DEVICE_ID         0x00028   // NDIS wrapper
#define BIOS_EXT_DEVICE_ID     0x00029   // Fix Broken BIOS device
#define VWIN32_DEVICE_ID       0x0002A   // for new WIN32-VxD
#define VCOMM_DEVICE_ID        0x0002B   // New COMM device driver
#define SPOOLER_DEVICE_ID      0x0002C   // Local Spooler
#define WIN32S_DEVICE_ID       0x0002D   // Win32S on Win 3.1 driver
#define DEBUGCMD_DEVICE_ID     0x0002E   // Debug command extensions
#define CONFIGMG_DEVICE_ID     0x00033   // Configuration manager (Plug&Play)
#define DWCFGMG_DEVICE_ID      0x00034   // Configuration manager for win31 and DOS
#define SCSIPORT_DEVICE_ID     0x00035   // Dragon miniport loader/driver
#define VFBACKUP_DEVICE_ID     0x00036   // allows backup apps to work with NEC
#define ENABLE_DEVICE_ID       0x00037   // for access VxD
#define VCOND_DEVICE_ID        0x00038   // Virtual Console Device - check vcond.inc
#define ISAPNP_DEVICE_ID       0x0003C   // ISA P&P Enumerator
#define BIOS_DEVICE_ID         0x0003D   // BIOS P&P Enumerator
#define IFSMgr_Device_ID       0x00040   // Installable File System Manager
#define VCDFSD_DEVICE_ID       0x00041   // Static CDFS ID
#define MRCI2_DEVICE_ID        0x00042   // DrvSpace compression engine
#define PCI_DEVICE_ID          0x00043   // PCI P&P Enumerator
#define PELOADER_DEVICE_ID     0x00044   // PE Image Loader
#define EISA_DEVICE_ID         0x00045   // EISA P&P Enumerator
#define DRAGCLI_DEVICE_ID      0x00046   // Dragon network client
#define DRAGSRV_DEVICE_ID      0x00047   // Dragon network server
#define PERF_DEVICE_ID         0x00048   // Config/stat info
#define ETEN_Device_ID         0x00060   // ETEN DOS (Taiwan) driver
#define CHBIOS_Device_ID       0x00061   // CHBIOS DOS (Korean) driver
#define VMSGD_Device_ID        0x00062   // DBCS Message Mode driver
#define VPPID_Device_ID        0x00063   // PC-98 System Control PPI
#define VIME_Device_ID         0x00064   // Virtual DOS IME
#define VHBIOSD_Device_ID      0x00065   // HBIOS (Korean) for HWin31 driver
#define BASEID_FOR_NAMEBASEDVXD        0xF000 // Name based VxD IDs start here
#define BASEID_FOR_NAMEBASEDVXD_MASK   0x0FFF // Mask to get the real vxd id

//----------------------------------------------------------------------------
//
//                     Initialization order equates
//
//----------------------------------------------------------------------------

#define VMM_Init_Order         0x000000000
#define PERF_INIT_ORDER        0x000900000
#define APM_Init_Order         0x001000000
#define VPOWERD_INIT_ORDER     APM_INIT_ORDER  // We overload APM since we replace it
#define Debug_Init_Order       0x004000000
#define BiosHook_Init_Order    0x006000000
#define VPROD_Init_Order       0x008000000
#define VPICD_Init_Order       0x00C000000
#define VTD_Init_Order         0x014000000
#define VXDLDR_INIT_ORDER      0x016000000
#define ENUMERATOR_INIT_ORDER  0x016800000
#define ISAPNP_INIT_ORDER      ENUMERATOR_INIT_ORDER
#define EISA_INIT_ORDER        ENUMERATOR_INIT_ORDER
#define PCI_INIT_ORDER         ENUMERATOR_INIT_ORDER
#define BIOS_INIT_ORDER        ENUMERATOR_INIT_ORDER+1
#define CONFIGMG_INIT_ORDER    ENUMERATOR_INIT_ORDER+0xFFFF
#define VCDFSD_INIT_ORDER      0x016F00000
#define IOS_INIT_ORDER         0x017000000
#define PageFile_Init_Order    0x018000000
#define PageSwap_Init_Order    0x01C000000
#define Parity_Init_Order      0x020000000
#define Reboot_Init_Order      0x024000000
#define EBIOS_Init_Order       0x026000000
#define VDD_Init_Order         0x028000000
#define VSD_Init_Order         0x02C000000
#define VCD_Init_Order         0x030000000
#define COMMDRVR_INIT_ORDER    (VCD_INIT_ORDER - 1)
#define PRTCL_INIT_ORDER       (COMMDRVR_INIT_ORDER - 2)
#define MODEM_INIT_ORDER       (COMMDRVR_INIT_ORDER - 3)
#define PORT_INIT_ORDER        (COMMDRVR_INIT_ORDER - 4)
#define VMD_Init_Order         0x034000000
#define VKD_Init_Order         0x038000000
#define VPD_Init_Order         0x03C000000
#define BlockDev_Init_Order    0x040000000
#define MCA_POS_Init_Order     0x041000000
#define SCSIFD_Init_Order      0x041400000
#define SCSIMaster_Init_Order  0x041800000
#define Int13_Init_Order       0x042000000
#define VFD_Init_Order         0x044000000
#define VMCPD_Init_Order       0x048000000
#define BIOSXlat_Init_Order    0x050000000
#define VNETBIOS_Init_Order    0x054000000
#define DOSMGR_Init_Order      0x058000000
#define DOSNET_Init_Order      0x05C000000
#define WINLOAD_Init_Order     0x060000000
#define VMPoll_Init_Order      0x064000000
#define Undefined_Init_Order   0x080000000
#define WINDEBUG_Init_Order    0x081000000
#define VDMAD_Init_Order       0x090000000
#define V86MMGR_Init_Order     0x0A0000000
#define IFSMgr_Init_Order      0x10000 + V86MMGR_Init_Order
#define FSD_Init_Order         0x00100 + IFSMgr_Init_Order
#define VFD_INIT_ORDER         0x50000 + IFSMgr_Init_Order
//
// Device ID for device that must touch memory in 1st MB
// at crit init (after V86mmgr)
//
#define Undef_Touch_Mem_Init_Order 0x0A8000000
#define SHELL_Init_Order           0x0B0000000
//
// VxD load result.
//
#define VXD_FAILURE 0
#define VXD_SUCCESS 1

//----------------------------------------------------------------------------
//
//                      System control call messages
//
//----------------------------------------------------------------------------

#define Sys_Critical_Init     0x0000
#define Device_Init           0x0001
#define Init_Complete         0x0002
#define Sys_VM_Init           0x0003
#define Sys_VM_Terminate      0x0004
#define System_Exit           0x0005
#define Sys_Critical_Exit     0x0006
#define Create_VM             0x0007
#define VM_Critical_Init      0x0008
#define VM_Init               0x0009
#define VM_Terminate          0x000A
#define VM_Not_Executable     0x000B
#define Destroy_VM            0x000C
#define VM_Suspend            0x000D
#define VM_Resume             0x000E
#define Set_Device_Focus      0x000F
#define Begin_Message_Mode    0x0010
#define End_Message_Mode      0x0011

#define Reboot_Processor      0x0012
#define Query_Destroy         0x0013
#define Debug_Query           0x0014

#define Begin_PM_App          0x0015

#define BPA_32_Bit            0x0001
#define BPA_32_Bit_Flag       0x0001

#define End_PM_App            0x0016

#define Device_Reboot_Notify  0x0017
#define Crit_Reboot_Notify    0x0018

#define Close_VM_Notify       0x0019

#define PnP_New_DevNode       0x0022

#define CVNF_Crit_Close       0x0001
#define CNVF_Crit_Close_Bit   0x0000

#define Power_Event           0x001A

//----------------------------------------------------------------------------
//
//                          Service Table definition.
//
//----------------------------------------------------------------------------

#define BeginServiceTable(did) enum { did##_begin = (did##_Device_ID << 16) - 1,
#define EndServiceTable()      did##_end };

//----------------------------------------------------------------------------
//
//                          VMM Service Definitions
//
//----------------------------------------------------------------------------

#if 0
BeginServiceTable(VMM)
    Get_VMM_Version,
    Get_Cur_VM_Handle,
    Test_Cur_VM_Handle,
    Get_Sys_VM_Handle,
    Test_Sys_VM_Handle,
    Validate_VM_Handle,
    Get_VMM_Reenter_Count,
    Begin_Reentrant_Execution,
    End_Reentrant_Execution,
    Install_V86_Break_Point,
    Remove_V86_Break_Point,
    Allocate_V86_Call_Back,
    Allocate_PM_Call_Back,
    Call_When_VM_Returns,
    Schedule_Global_Event,
    Schedule_VM_Event,
    Call_Global_Event,
    Call_VM_Event,
    Cancel_Global_Event,
    Cancel_VM_Event,
    Call_Priority_VM_Event,
    Cancel_Priority_VM_Event,
    Get_NMI_Handler_Addr,
    Set_NMI_Handler_Addr,
    Hook_NMI_Event,
    Call_When_VM_Ints_Enabled,
    Enable_VM_Ints,
    Disable_VM_Ints,
    Map_Flat,
    Map_Lin_To_VM_Addr,
    Adjust_Exec_Priority,
    Begin_Critical_Section,
    End_Critical_Section,
    End_Crit_And_Suspend,
    Claim_Critical_Section,
    Release_Critical_Section,
    Call_When_Not_Critical,
    Create_Semaphore,
    Destroy_Semaphore,
    Wait_Semaphore,
    Signal_Semaphore,
    Get_Crit_Section_Status,
    Call_When_Task_Switched,
    Suspend_VM,
    Resume_VM,
    No_Fail_Resume_VM,
    Nuke_VM,
    Crash_Cur_VM,
    Get_Execution_Focus,
    Set_Execution_Focus,
    Get_Time_Slice_Priority,
    Set_Time_Slice_Priority,
    Get_Time_Slice_Granularity,
    Set_Time_Slice_Granularity,
    Get_Time_Slice_Info,
    Adjust_Execution_Time,
    Release_Time_Slice,
    Wake_Up_VM,
    Call_When_Idle,
    Get_Next_VM_Handle,
    Set_Global_Time_Out,
    Set_VM_Time_Out,
    Cancel_Time_Out,
    Get_System_Time,
    Get_VM_Exec_Time,
    Hook_V86_Int_Chain,
    Get_V86_Int_Vector,
    Set_V86_Int_Vector,
    Get_PM_Int_Vector,
    Set_PM_Int_Vector,
    Simulate_Int,
    Simulate_Iret,
    Simulate_Far_Call,
    Simulate_Far_Jmp,
    Simulate_Far_Ret,
    Simulate_Far_Ret_N,
    Build_Int_Stack_Frame,
    Simulate_Push,
    Simulate_Pop,
    _HeapAllocate,
    _HeapReAllocate,
    _HeapFree,
    _HeapGetSize,
    _PageAllocate,
    _PageReAllocate,
    _PageFree,
    _PageLock,
    _PageUnLock,
    _PageGetSizeAddr,
    _PageGetAllocInfo,
    _GetFreePageCount,
    _GetSysPageCount,
    _GetVMPgCount,
    _MapIntoV86,
    _PhysIntoV86,
    _TestGlobalV86Mem,
    _ModifyPageBits,
    _CopyPageTable,
    _LinMapIntoV86,
    _LinPageLock,
    _LinPageUnLock,
    _SetResetV86Pageable,
    _GetV86PageableArray,
    _PageCheckLinRange,
    _PageOutDirtyPages,
    _PageDiscardPages,
    _GetNulPageHandle,
    _GetFirstV86Page,
    _MapPhysToLinear,
    _GetAppFlatDSAlias,
    _SelectorMapFlat,
    _GetDemandPageInfo,
    _GetSetPageOutCount,
    Hook_V86_Page,
    _Assign_Device_V86_Pages,
    _DeAssign_Device_V86_Pages,
    _Get_Device_V86_Pages_Array,
    MMGR_SetNULPageAddr,
    _Allocate_GDT_Selector,
    _Free_GDT_Selector,
    _Allocate_LDT_Selector,
    _Free_LDT_Selector,
    _BuildDescriptorDWORDs,
    _GetDescriptor,
    _SetDescriptor,
    _MMGR_Toggle_HMA,
    Get_Fault_Hook_Addrs,
    Hook_V86_Fault,
    Hook_PM_Fault,
    Hook_VMM_Fault,
    Begin_Nest_V86_Exec,
    Begin_Nest_Exec,
    Exec_Int,
    Resume_Exec,
    End_Nest_Exec,
    Allocate_PM_App_CB_Area,
    Get_Cur_PM_App_CB,
    Set_V86_Exec_Mode,
    Set_PM_Exec_Mode,
    Begin_Use_Locked_PM_Stack,
    End_Use_Locked_PM_Stack,
    Save_Client_State,
    Restore_Client_State,
    Exec_VxD_Int,
    Hook_Device_Service,
    Hook_Device_V86_API,
    Hook_Device_PM_API,
    System_Control,
    Simulate_IO,
    Install_Mult_IO_Handlers,
    Install_IO_Handler,
    Enable_Global_Trapping,
    Enable_Local_Trapping,
    Disable_Global_Trapping,
    Disable_Local_Trapping,
    List_Create,
    List_Destroy,
    List_Allocate,
    List_Attach,
    List_Attach_Tail,
    List_Insert,
    List_Remove,
    List_Deallocate,
    List_Get_First,
    List_Get_Next,
    List_Remove_First,
    _AddInstanceItem,
    _Allocate_Device_CB_Area,
    _Allocate_Global_V86_Data_Area,
    _Allocate_Temp_V86_Data_Area,
    _Free_Temp_V86_Data_Area,
    Get_Profile_Decimal_Int,
    Convert_Decimal_String,
    Get_Profile_Fixed_Point,
    Convert_Fixed_Point_String,
    Get_Profile_Hex_Int,
    Convert_Hex_String,
    Get_Profile_Boolean,
    Convert_Boolean_String,
    Get_Profile_String,
    Get_Next_Profile_String,
    Get_Environment_String,
    Get_Exec_Path,
    Get_Config_Directory,
    OpenFile,
    Get_PSP_Segment,
    GetDOSVectors,
    Get_Machine_Info,
    GetSet_HMA_Info,
    Set_System_Exit_Code,
    Fatal_Error_Handler,
    Fatal_Memory_Error,
    Update_System_Clock,
    Test_Debug_Installed,
    Out_Debug_String,
    Out_Debug_Chr,
    In_Debug_Chr,
    Debug_Convert_Hex_Binary,
    Debug_Convert_Hex_Decimal,
    Debug_Test_Valid_Handle,
    Validate_Client_Ptr,
    Test_Reenter,
    Queue_Debug_String,
    Log_Proc_Call,
    Debug_Test_Cur_VM,
    Get_PM_Int_Type,
    Set_PM_Int_Type,
    Get_Last_Updated_System_Time,
    Get_Last_Updated_VM_Exec_Time,
    Test_DBCS_Lead_Byte,
    _AddFreePhysPage,
    _PageResetHandlePAddr,
    _SetLastV86Page,
    _GetLastV86Page,
    _MapFreePhysReg,
    _UnmapFreePhysReg,
    _XchgFreePhysReg,
    _SetFreePhysRegCalBk,
    Get_Next_Arena,
    Get_Name_Of_Ugly_TSR,
    Get_Debug_Options,
    Set_Physical_HMA_Alias,
    _GetGlblRng0V86IntBase,
    _Add_Global_V86_Data_Area,
    GetSetDetailedVMError,
    Is_Debug_Chr,
    Clear_Mono_Screen,
    Out_Mono_Chr,
    Out_Mono_String,
    Set_Mono_Cur_Pos,
    Get_Mono_Cur_Pos,
    Get_Mono_Chr,
    Locate_Byte_In_ROM,
    Hook_Invalid_Page_Fault,
    Unhook_Invalid_Page_Fault,
    Set_Delete_On_Exit_File,
    Close_VM,
    Enable_Touch_1st_Meg,
    Disable_Touch_1st_Meg,
    Install_Exception_Handler,
    Remove_Exception_Handler,
    Get_Crit_Status_No_Block,
    _GetLastUpdatedThreadExecTime,
    _Trace_Out_Service,
    _Debug_Out_Service,
    _Debug_Flags_Service,
    VMMAddImportModuleName,
    VMM_Add_DDB,
    VMM_Remove_DDB,
    Test_VM_Ints_Enabled,
    _BlockOnID,
    Schedule_Thread_Event,
    Cancel_Thread_Event,
    Set_Thread_Time_Out,
    Set_Async_Time_Out,
    _AllocateThreadDataSlot,
    _FreeThreadDataSlot,
    _CreateMutex,
    _DestroyMutex,
    _GetMutexOwner,
    Call_When_Thread_Switched,
    VMMCreateThread,
    _GetThreadExecTime,
    VMMTerminateThread,
    Get_Cur_Thread_Handle,
    Test_Cur_Thread_Handle,
    Get_Sys_Thread_Handle,
    Test_Sys_Thread_Handle,
    Validate_Thread_Handle,
    Get_Initial_Thread_Handle,
    Test_Initial_Thread_Handle,
    Debug_Test_Valid_Thread_Handle,
    Debug_Test_Cur_Thread,
    VMM_GetSystemInitState,
    Cancel_Call_When_Thread_Switched,
    Get_Next_Thread_Handle,
    Adjust_Thread_Exec_Priority,
    _Deallocate_Device_CB_Area,
    Remove_IO_Handler,
    Remove_Mult_IO_Handlers,
    Unhook_V86_Int_Chain,
    Unhook_V86_Fault,
    Unhook_PM_Fault,
    Unhook_VMM_Fault,
    Unhook_Device_Service,
    _PageReserve,
    _PageCommit,
    _PageDecommit,
    _PagerRegister,
    _PagerQuery,
    _PagerDeregister,
    _ContextCreate,
    _ContextDestroy,
    _PageAttach,
    _PageFlush,
    _SignalID,
    _PageCommitPhys,
    _Register_Win32_Services,
    Cancel_Call_When_Not_Critical,
    Cancel_Call_When_Idle,
    Cancel_Call_When_Task_Switched,
    _Debug_Printf_Service,
    _EnterMutex,
    _LeaveMutex,
    Simulate_VM_IO,
    Signal_Semaphore_No_Switch,
    _ContextSwitch,
    _PageModifyPermissions,
    _PageQuery,
    _EnterMustComplete,
    _LeaveMustComplete,
    _ResumeExecMustComplete,
    _GetThreadTerminationStatus,
    _GetInstanceInfo,
    _ExecIntMustComplete,
    _ExecVxDIntMustComplete,
    Begin_V86_Serialization,
    Unhook_V86_Page,
    VMM_GetVxDLocationList,
    VMM_GetDDBList,
    Unhook_NMI_Event,
    Get_Instanced_V86_Int_Vector,
    Get_Set_Real_DOS_PSP,
    Call_Priority_Thread_Event,
    Get_System_Time_Address,
    Get_Crit_Status_Thread,
    Get_DDB,
    Directed_Sys_Control,
    _RegOpenKey,
    _RegCloseKey,
    _RegCreateKey,
    _RegDeleteKey,
    _RegEnumKey,
    _RegQueryValue,
    _RegSetValue,
    _RegDeleteValue,
    _RegEnumValue,
    _RegQueryValueEx,
    _RegSetValueEx,
    _CallRing3,
    Exec_PM_Int,
    _RegFlushKey,
    _PageCommitContig,
    _GetCurrentContext,
    _LocalizeSprintf,
    _LocalizeStackSprintf,
    Call_Restricted_Event,
    Cancel_Restricted_Event,
    Register_PEF_Provider, VMM_ICODE,
    _GetPhysPageInfo,
    _RegQueryInfoKey,
    MemArb_Reserve_Pages,
    Time_Slice_Sys_VM_Idle,
    Time_Slice_Sleep,
    Boost_With_Decay,
    Set_Inversion_Pri,
    Reset_Inversion_Pri,
    Release_Inversion_Pri,
    Get_Thread_Win32_Pri,
    Set_Thread_Win32_Pri,
    Set_Thread_Static_Boost,
    Set_VM_Static_Boost,
    Release_Inversion_Pri_ID,
    Attach_Thread_To_Group,
    Detach_Thread_From_Group,
    Set_Group_Static_Boost,
    _GetRegistryPath,
    _GetRegistryKey,
    Cleanup_Thread_State,
    _RegRemapPreDefKey,
    End_V86_Serialization,
    _Assert_Range,
    _Sprintf,
    _PageChangePager,
    _RegCreateDynKey,
    _RegQueryMultipleValues,
    Boost_Thread_With_VM,
    Get_Boot_Flags,
    Set_Boot_Flags,
    _lstrcpyn,
    _lstrlen,
    _lmemcpy,
    _GetVxDName,
    Force_Mutexes_Free,
    Restore_Forced_Mutexes,
    _AddReclaimableItem,
    _SetReclaimableItem,
    _EnumReclaimableItem,
    Time_Slice_Wake_Sys_VM,
    VMM_Replace_Global_Environment,
    Begin_Non_Serial_Nest_V86_Exec,
    Get_Nest_Exec_Status,
    Open_Boot_Log,
    Write_Boot_Log,
    Close_Boot_Log,
    EnableDisable_Boot_Log,
EndServiceTable()
#endif // 0
#define Get_VMM_Version                     0x00010000
#define Get_Cur_VM_Handle                   0x00010001
#define Test_Cur_VM_Handle                  0x00010002
#define Get_Sys_VM_Handle                   0x00010003
#define Test_Sys_VM_Handle                  0x00010004
#define Validate_VM_Handle                  0x00010005
#define Get_VMM_Reenter_Count               0x00010006
#define Begin_Reentrant_Execution           0x00010007
#define End_Reentrant_Execution             0x00010008
#define Install_V86_Break_Point             0x00010009
#define Remove_V86_Break_Point              0x0001000a
#define Allocate_V86_Call_Back              0x0001000b
#define Allocate_PM_Call_Back               0x0001000c
#define Call_When_VM_Returns                0x0001000d
#define Schedule_Global_Event               0x0001000e
#define Schedule_VM_Event                   0x0001000f
#define Call_Global_Event                   0x00010010
#define Call_VM_Event                       0x00010011
#define Cancel_Global_Event                 0x00010012
#define Cancel_VM_Event                     0x00010013
#define Call_Priority_VM_Event              0x00010014
#define Cancel_Priority_VM_Event            0x00010015
#define Get_NMI_Handler_Addr                0x00010016
#define Set_NMI_Handler_Addr                0x00010017
#define Hook_NMI_Event                      0x00010018
#define Call_When_VM_Ints_Enabled           0x00010019
#define Enable_VM_Ints                      0x0001001a
#define Disable_VM_Ints                     0x0001001b
#define Map_Flat                            0x0001001c
#define Map_Lin_To_VM_Addr                  0x0001001d
#define Adjust_Exec_Priority                0x0001001e
#define Begin_Critical_Section              0x0001001f
#define End_Critical_Section                0x00010020
#define End_Crit_And_Suspend                0x00010021
#define Claim_Critical_Section              0x00010022
#define Release_Critical_Section            0x00010023
#define Call_When_Not_Critical              0x00010024
#define Create_Semaphore                    0x00010025
#define Destroy_Semaphore                   0x00010026
#define Wait_Semaphore                      0x00010027
#define Signal_Semaphore                    0x00010028
#define Get_Crit_Section_Status             0x00010029
#define Call_When_Task_Switched             0x0001002a
#define Suspend_VM                          0x0001002b
#define Resume_VM                           0x0001002c
#define No_Fail_Resume_VM                   0x0001002d
#define Nuke_VM                             0x0001002e
#define Crash_Cur_VM                        0x0001002f
#define Get_Execution_Focus                 0x00010030
#define Set_Execution_Focus                 0x00010031
#define Get_Time_Slice_Priority             0x00010032
#define Set_Time_Slice_Priority             0x00010033
#define Get_Time_Slice_Granularity          0x00010034
#define Set_Time_Slice_Granularity          0x00010035
#define Get_Time_Slice_Info                 0x00010036
#define Adjust_Execution_Time               0x00010037
#define Release_Time_Slice                  0x00010038
#define Wake_Up_VM                          0x00010039
#define Call_When_Idle                      0x0001003a
#define Get_Next_VM_Handle                  0x0001003b
#define Set_Global_Time_Out                 0x0001003c
#define Set_VM_Time_Out                     0x0001003d
#define Cancel_Time_Out                     0x0001003e
#define Get_System_Time                     0x0001003f
#define Get_VM_Exec_Time                    0x00010040
#define Hook_V86_Int_Chain                  0x00010041
#define Get_V86_Int_Vector                  0x00010042
#define Set_V86_Int_Vector                  0x00010043
#define Get_PM_Int_Vector                   0x00010044
#define Set_PM_Int_Vector                   0x00010045
#define Simulate_Int                        0x00010046
#define Simulate_Iret                       0x00010047
#define Simulate_Far_Call                   0x00010048
#define Simulate_Far_Jmp                    0x00010049
#define Simulate_Far_Ret                    0x0001004a
#define Simulate_Far_Ret_N                  0x0001004b
#define Build_Int_Stack_Frame               0x0001004c
#define Simulate_Push                       0x0001004d
#define Simulate_Pop                        0x0001004e
#define _HeapAllocate                       0x0001004f
#define _HeapReAllocate                     0x00010050
#define _HeapFree                           0x00010051
#define _HeapGetSize                        0x00010052
#define _PageAllocate                       0x00010053
#define _PageReAllocate                     0x00010054
#define _PageFree                           0x00010055
#define _PageLock                           0x00010056
#define _PageUnLock                         0x00010057
#define _PageGetSizeAddr                    0x00010058
#define _PageGetAllocInfo                   0x00010059
#define _GetFreePageCount                   0x0001005a
#define _GetSysPageCount                    0x0001005b
#define _GetVMPgCount                       0x0001005c
#define _MapIntoV86                         0x0001005d
#define _PhysIntoV86                        0x0001005e
#define _TestGlobalV86Mem                   0x0001005f
#define _ModifyPageBits                     0x00010060
#define _CopyPageTable                      0x00010061
#define _LinMapIntoV86                      0x00010062
#define _LinPageLock                        0x00010063
#define _LinPageUnLock                      0x00010064
#define _SetResetV86Pageable                0x00010065
#define _GetV86PageableArray                0x00010066
#define _PageCheckLinRange                  0x00010067
#define _PageOutDirtyPages                  0x00010068
#define _PageDiscardPages                   0x00010069
#define _GetNulPageHandle                   0x0001006a
#define _GetFirstV86Page                    0x0001006b
#define _MapPhysToLinear                    0x0001006c
#define _GetAppFlatDSAlias                  0x0001006d
#define _SelectorMapFlat                    0x0001006e
#define _GetDemandPageInfo                  0x0001006f
#define _GetSetPageOutCount                 0x00010070
#define Hook_V86_Page                       0x00010071
#define _Assign_Device_V86_Pages            0x00010072
#define _DeAssign_Device_V86_Pages          0x00010073
#define _Get_Device_V86_Pages_Array         0x00010074
#define MMGR_SetNULPageAddr                 0x00010075
#define _Allocate_GDT_Selector              0x00010076
#define _Free_GDT_Selector                  0x00010077
#define _Allocate_LDT_Selector              0x00010078
#define _Free_LDT_Selector                  0x00010079
#define _BuildDescriptorDWORDs              0x0001007a
#define _GetDescriptor                      0x0001007b
#define _SetDescriptor                      0x0001007c
#define _MMGR_Toggle_HMA                    0x0001007d
#define Get_Fault_Hook_Addrs                0x0001007e
#define Hook_V86_Fault                      0x0001007f
#define Hook_PM_Fault                       0x00010080
#define Hook_VMM_Fault                      0x00010081
#define Begin_Nest_V86_Exec                 0x00010082
#define Begin_Nest_Exec                     0x00010083
#define Exec_Int                            0x00010084
#define Resume_Exec                         0x00010085
#define End_Nest_Exec                       0x00010086
#define Allocate_PM_App_CB_Area             0x00010087
#define Get_Cur_PM_App_CB                   0x00010088
#define Set_V86_Exec_Mode                   0x00010089
#define Set_PM_Exec_Mode                    0x0001008a
#define Begin_Use_Locked_PM_Stack           0x0001008b
#define End_Use_Locked_PM_Stack             0x0001008c
#define Save_Client_State                   0x0001008d
#define Restore_Client_State                0x0001008e
#define Exec_VxD_Int                        0x0001008f
#define Hook_Device_Service                 0x00010090
#define Hook_Device_V86_API                 0x00010091
#define Hook_Device_PM_API                  0x00010092
#define System_Control                      0x00010093
#define Simulate_IO                         0x00010094
#define Install_Mult_IO_Handlers            0x00010095
#define Install_IO_Handler                  0x00010096
#define Enable_Global_Trapping              0x00010097
#define Enable_Local_Trapping               0x00010098
#define Disable_Global_Trapping             0x00010099
#define Disable_Local_Trapping              0x0001009a
#define List_Create                         0x0001009b
#define List_Destroy                        0x0001009c
#define List_Allocate                       0x0001009d
#define List_Attach                         0x0001009e
#define List_Attach_Tail                    0x0001009f
#define List_Insert                         0x000100a0
#define List_Remove                         0x000100a1
#define List_Deallocate                     0x000100a2
#define List_Get_First                      0x000100a3
#define List_Get_Next                       0x000100a4
#define List_Remove_First                   0x000100a5
#define _AddInstanceItem                    0x000100a6
#define _Allocate_Device_CB_Area            0x000100a7
#define _Allocate_Global_V86_Data_Area      0x000100a8
#define _Allocate_Temp_V86_Data_Area        0x000100a9
#define _Free_Temp_V86_Data_Area            0x000100aa
#define Get_Profile_Decimal_Int             0x000100ab
#define Convert_Decimal_String              0x000100ac
#define Get_Profile_Fixed_Point             0x000100ad
#define Convert_Fixed_Point_String          0x000100ae
#define Get_Profile_Hex_Int                 0x000100af
#define Convert_Hex_String                  0x000100b0
#define Get_Profile_Boolean                 0x000100b1
#define Convert_Boolean_String              0x000100b2
#define Get_Profile_String                  0x000100b3
#define Get_Next_Profile_String             0x000100b4
#define Get_Environment_String              0x000100b5
#define Get_Exec_Path                       0x000100b6
#define Get_Config_Directory                0x000100b7
#define OpenFile                            0x000100b8
#define Get_PSP_Segment                     0x000100b9
#define GetDOSVectors                       0x000100ba
#define Get_Machine_Info                    0x000100bb
#define GetSet_HMA_Info                     0x000100bc
#define Set_System_Exit_Code                0x000100bd
#define Fatal_Error_Handler                 0x000100be
#define Fatal_Memory_Error                  0x000100bf
#define Update_System_Clock                 0x000100c0
#define Test_Debug_Installed                0x000100c1
#define Out_Debug_String                    0x000100c2
#define Out_Debug_Chr                       0x000100c3
#define In_Debug_Chr                        0x000100c4
#define Debug_Convert_Hex_Binary            0x000100c5
#define Debug_Convert_Hex_Decimal           0x000100c6
#define Debug_Test_Valid_Handle             0x000100c7
#define Validate_Client_Ptr                 0x000100c8
#define Test_Reenter                        0x000100c9
#define Queue_Debug_String                  0x000100ca
#define Log_Proc_Call                       0x000100cb
#define Debug_Test_Cur_VM                   0x000100cc
#define Get_PM_Int_Type                     0x000100cd
#define Set_PM_Int_Type                     0x000100ce
#define Get_Last_Updated_System_Time        0x000100cf
#define Get_Last_Updated_VM_Exec_Time       0x000100d0
#define Test_DBCS_Lead_Byte                 0x000100d1
#define _AddFreePhysPage                    0x000100d2
#define _PageResetHandlePAddr               0x000100d3
#define _SetLastV86Page                     0x000100d4
#define _GetLastV86Page                     0x000100d5
#define _MapFreePhysReg                     0x000100d6
#define _UnmapFreePhysReg                   0x000100d7
#define _XchgFreePhysReg                    0x000100d8
#define _SetFreePhysRegCalBk                0x000100d9
#define Get_Next_Arena                      0x000100da
#define Get_Name_Of_Ugly_TSR                0x000100db
#define Get_Debug_Options                   0x000100dc
#define Set_Physical_HMA_Alias              0x000100dd
#define _GetGlblRng0V86IntBase              0x000100de
#define _Add_Global_V86_Data_Area           0x000100df
#define GetSetDetailedVMError               0x000100e0
#define Is_Debug_Chr                        0x000100e1
#define Clear_Mono_Screen                   0x000100e2
#define Out_Mono_Chr                        0x000100e3
#define Out_Mono_String                     0x000100e4
#define Set_Mono_Cur_Pos                    0x000100e5
#define Get_Mono_Cur_Pos                    0x000100e6
#define Get_Mono_Chr                        0x000100e7
#define Locate_Byte_In_ROM                  0x000100e8
#define Hook_Invalid_Page_Fault             0x000100e9
#define Unhook_Invalid_Page_Fault           0x000100ea
#define Set_Delete_On_Exit_File             0x000100eb
#define Close_VM                            0x000100ec
#define Enable_Touch_1st_Meg                0x000100ed
#define Disable_Touch_1st_Meg               0x000100ee
#define Install_Exception_Handler           0x000100ef
#define Remove_Exception_Handler            0x000100f0
#define Get_Crit_Status_No_Block            0x000100f1
#define _GetLastUpdatedThreadExecTime       0x000100f2
#define _Trace_Out_Service                  0x000100f3
#define _Debug_Out_Service                  0x000100f4
#define _Debug_Flags_Service                0x000100f5
#define VMMAddImportModuleName              0x000100f6
#define VMM_Add_DDB                         0x000100f7
#define VMM_Remove_DDB                      0x000100f8
#define Test_VM_Ints_Enabled                0x000100f9
#define _BlockOnID                          0x000100fa
#define Schedule_Thread_Event               0x000100fb
#define Cancel_Thread_Event                 0x000100fc
#define Set_Thread_Time_Out                 0x000100fd
#define Set_Async_Time_Out                  0x000100fe
#define _AllocateThreadDataSlot             0x000100ff
#define _FreeThreadDataSlot                 0x00010100
#define _CreateMutex                        0x00010101
#define _DestroyMutex                       0x00010102
#define _GetMutexOwner                      0x00010103
#define Call_When_Thread_Switched           0x00010104
#define VMMCreateThread                     0x00010105
#define _GetThreadExecTime                  0x00010106
#define VMMTerminateThread                  0x00010107
#define Get_Cur_Thread_Handle               0x00010108
#define Test_Cur_Thread_Handle              0x00010109
#define Get_Sys_Thread_Handle               0x0001010a
#define Test_Sys_Thread_Handle              0x0001010b
#define Validate_Thread_Handle              0x0001010c
#define Get_Initial_Thread_Handle           0x0001010d
#define Test_Initial_Thread_Handle          0x0001010e
#define Debug_Test_Valid_Thread_Handle      0x0001010f
#define Debug_Test_Cur_Thread               0x00010110
#define VMM_GetSystemInitState              0x00010111
#define Cancel_Call_When_Thread_Switched    0x00010112
#define Get_Next_Thread_Handle              0x00010113
#define Adjust_Thread_Exec_Priority         0x00010114
#define _Deallocate_Device_CB_Area          0x00010115
#define Remove_IO_Handler                   0x00010116
#define Remove_Mult_IO_Handlers             0x00010117
#define Unhook_V86_Int_Chain                0x00010118
#define Unhook_V86_Fault                    0x00010119
#define Unhook_PM_Fault                     0x0001011a
#define Unhook_VMM_Fault                    0x0001011b
#define Unhook_Device_Service               0x0001011c
#define _PageReserve                        0x0001011d
#define _PageCommit                         0x0001011e
#define _PageDecommit                       0x0001011f
#define _PagerRegister                      0x00010120
#define _PagerQuery                         0x00010121
#define _PagerDeregister                    0x00010122
#define _ContextCreate                      0x00010123
#define _ContextDestroy                     0x00010124
#define _PageAttach                         0x00010125
#define _PageFlush                          0x00010126
#define _SignalID                           0x00010127
#define _PageCommitPhys                     0x00010128
#define _Register_Win32_Services            0x00010129
#define Cancel_Call_When_Not_Critical       0x0001012a
#define Cancel_Call_When_Idle               0x0001012b
#define Cancel_Call_When_Task_Switched      0x0001012c
#define _Debug_Printf_Service               0x0001012d
#define _EnterMutex                         0x0001012e
#define _LeaveMutex                         0x0001012f
#define Simulate_VM_IO                      0x00010130
#define Signal_Semaphore_No_Switch          0x00010131
#define _ContextSwitch                      0x00010132
#define _PageModifyPermissions              0x00010133
#define _PageQuery                          0x00010134
#define _EnterMustComplete                  0x00010135
#define _LeaveMustComplete                  0x00010136
#define _ResumeExecMustComplete             0x00010137
#define _GetThreadTerminationStatus         0x00010138
#define _GetInstanceInfo                    0x00010139
#define _ExecIntMustComplete                0x0001013a
#define _ExecVxDIntMustComplete             0x0001013b
#define Begin_V86_Serialization             0x0001013c
#define Unhook_V86_Page                     0x0001013d
#define VMM_GetVxDLocationList              0x0001013e
#define VMM_GetDDBList                      0x0001013f
#define Unhook_NMI_Event                    0x00010140
#define Get_Instanced_V86_Int_Vector        0x00010141
#define Get_Set_Real_DOS_PSP                0x00010142
#define Call_Priority_Thread_Event          0x00010143
#define Get_System_Time_Address             0x00010144
#define Get_Crit_Status_Thread              0x00010145
#define Get_DDB                             0x00010146
#define Directed_Sys_Control                0x00010147
#define _RegOpenKey                         0x00010148
#define _RegCloseKey                        0x00010149
#define _RegCreateKey                       0x0001014a
#define _RegDeleteKey                       0x0001014b
#define _RegEnumKey                         0x0001014c
#define _RegQueryValue                      0x0001014d
#define _RegSetValue                        0x0001014e
#define _RegDeleteValue                     0x0001014f
#define _RegEnumValue                       0x00010150
#define _RegQueryValueEx                    0x00010151
#define _RegSetValueEx                      0x00010152
#define _CallRing3                          0x00010153
#define Exec_PM_Int                         0x00010154
#define _RegFlushKey                        0x00010155
#define _PageCommitContig                   0x00010156
#define _GetCurrentContext                  0x00010157
#define _LocalizeSprintf                    0x00010158
#define _LocalizeStackSprintf               0x00010159
#define Call_Restricted_Event               0x0001015a
#define Cancel_Restricted_Event             0x0001015b
#define Register_PEF_Provider               0x0001015c
#define _GetPhysPageInfo                    0x0001015d
#define _RegQueryInfoKey                    0x0001015e
#define MemArb_Reserve_Pages                0x0001015f
#define Time_Slice_Sys_VM_Idle              0x00010160
#define Time_Slice_Sleep                    0x00010161
#define Boost_With_Decay                    0x00010162
#define Set_Inversion_Pri                   0x00010163
#define Reset_Inversion_Pri                 0x00010164
#define Release_Inversion_Pri               0x00010165
#define Get_Thread_Win32_Pri                0x00010166
#define Set_Thread_Win32_Pri                0x00010167
#define Set_Thread_Static_Boost             0x00010168
#define Set_VM_Static_Boost                 0x00010169
#define Release_Inversion_Pri_ID            0x0001016a
#define Attach_Thread_To_Group              0x0001016b
#define Detach_Thread_From_Group            0x0001016c
#define Set_Group_Static_Boost              0x0001016d
#define _GetRegistryPath, VMM_ICODE         0x0001016e
#define _GetRegistryKey                     0x0001016f
#define Cleanup_Thread_State                0x00010170
#define _RegRemapPreDefKey                  0x00010171
#define End_V86_Serialization               0x00010172
#define _Assert_Range                       0x00010173
#define _Sprintf                            0x00010174
#define _PageChangePager                    0x00010175
#define _RegCreateDynKey                    0x00010176
#define _RegQueryMultipleValues             0x00010177
#define Boost_Thread_With_VM                0x00010178
#define Get_Boot_Flags                      0x00010179
#define Set_Boot_Flags                      0x0001017a
#define _lstrcpyn                           0x0001017b
#define _lstrlen                            0x0001017c
#define _lmemcpy                            0x0001017d
#define _GetVxDName                         0x0001017e
#define Force_Mutexes_Free                  0x0001017f
#define Restore_Forced_Mutexes              0x00010180
#define _AddReclaimableItem                 0x00010181
#define _SetReclaimableItem                 0x00010182
#define _EnumReclaimableItem                0x00010183
#define Time_Slice_Wake_Sys_VM              0x00010184
#define VMM_Replace_Global_Environment      0x00010185
#define Begin_Non_Serial_Nest_V86_Exec      0x00010186
#define Get_Nest_Exec_Status                0x00010187
#define Open_Boot_Log                       0x00010188
#define Write_Boot_Log                      0x00010189
#define Close_Boot_Log                      0x0001018a
#define EnableDisable_Boot_Log              0x0001018b

//----------------------------------------------------------------------------
//
//                    Flags for page allocator calls
//
//----------------------------------------------------------------------------

#define PageZeroInit            0x00000001
#define PageUseAlign            0x00000002
#define PageContig              0x00000004
#define PageFixed               0x00000008
#define PageDEBUGNulFault       0x00000010
#define PageZeroReInit          0x00000020
#define PageNoCopy              0x00000040
#define PageLocked              0x00000080
#define PageLockedIfDP          0x00000100
#define PageSetV86Pageable      0x00000200
#define PageClearV86Pageable    0x00000400
#define PageSetV86IntsLocked    0x00000800
#define PageClearV86IntsLocked  0x00001000
#define PageMarkPageOut         0x00002000
#define PagePDPSetBase          0x00004000
#define PagePDPClearBase        0x00008000
#define PageDiscard             0x00010000
#define PagePDPQueryDirty       0x00020000
//
// New for 3.10
//
#define PageMapFreePhysReg      0x00040000
//
// NOTE: HIGH 8 BITS (bits 24-31) are reserved
//
//----------------------------------------------------------------------------
//
//                         Page table entry bits
//
//----------------------------------------------------------------------------

#define P_SIZE        0x1000  // page size
#define P_PRES        0x01    // page present bit
#define P_PRESBit     0
#define P_WRITE       0x02    // write access bit
#define P_WRITEBit    1
#define P_USER        0x04    // access bit for User mode
#define P_USERBit     2
#define P_ACC         0x20    // page accessed bit
#define P_ACCBit      5
#define P_DIRTY       0x40    // page dirty bit
#define P_DIRTYBit    6
#define P_AVAIL       (P_PRES|P_WRITE|P_USER) // avail to everyone & present

//----------------------------------------------------------------------------
//
// Page types - definition of the OS reserved
//              bits in the page table entry.
//
//----------------------------------------------------------------------------

#define PG_TYPE       0x0E00  // TYPE bits in PTE

//----------------------------------------------------------------------------
//
// Page types for page allocator calls
//
//----------------------------------------------------------------------------

#define PG_VM         0
#define PG_SYS        1
#define PG_RESERVED1  2
#define PG_PRIVATE    3
#define PG_RESERVED2  4
#define PG_RELOCK     5      // PRIVATE to MMGR
#define PG_INSTANCE   6
#define PG_HOOKED     7
#define PG_IGNORE     0x0FFFFFFFF

//----------------------------------------------------------------------------
//
// Types for page table entries
//
//----------------------------------------------------------------------------

#define PgT_VM        (PG_VM << 9)
#define PgT_SYS       (PG_SYS << 9)
#define PgT_RESERVED1 (PG_RESERVED1 << 9)
#define PgT_PRIVATE   (PG_PRIVATE << 9)
#define PgT_RESERVED2 (PG_RESERVED2 << 9)
#define PgT_RELOCK    (PG_RELOCK << 9)
#define PgT_INSTANCE  (PG_INSTANCE << 9)
#define PgT_HOOKED    (PG_HOOKED << 9)

//----------------------------------------------------------------------------
//
// Definitions for the access byte in a descriptor
//
//----------------------------------------------------------------------------

#define D_PRES       0x80     // present in memory
#define D_NOTPRES    0x00     // not present in memory
#define D_DPL0       0x00     // Ring 0
#define D_DPL1       0x20     // Ring 1
#define D_DPL2       0x40     // Ring 2
#define D_DPL3       0x60     // Ring 3
#define D_SEG        0x10     // Segment descriptor
#define D_CTRL       0x00     // Control descriptor
#define D_GRAN_BYTE  0x00     // Segment length is byte granular
#define D_GRAN_PAGE  0x80     // Segment length is page granular
#define D_DEF16      0x00     // Default operation size is 16 bits
#define D_DEF32      0x40     // Default operation size is 32 bits
#define D_CODE       0x08     // code
#define D_DATA       0x00     // data
#define D_RX         0x02     // if code, readable
#define D_X          0x00     // if code, exec only
#define D_ED         0x04     // if expand down
#define D_EU         0x00     // if expand up
#define D_W          0x02     // if data, writable
#define D_R          0x00     // if data, read only
#define D_ACCESSED   0x01     // segment accessed bit
#define RW_Data_Type (D_PRES+D_SEG+D_DATA+D_W)
#define R_Data_Type  (D_PRES+D_SEG+D_DATA+D_R)
#define Code_Type    (D_PRES+D_SEG+D_CODE+D_RX)
#define D_PAGE32     (D_GRAN_PAGE+D_DEF32)
#define SELECTOR_MASK  0xfff8      // selector index
#define SEL_LOW_MASK   0x00f8      // mask for low byte of sel indx
#define TABLE_MASK     0x0004      // table bit
#define RPL_MASK       0x0003      // priviledge bits
#define RPL_CLR        (~0x0003)   // clear ring bits

//----------------------------------------------------------------------------
//
// Flags for List_Create
//
//----------------------------------------------------------------------------

#define LF_Async            0x0001
#define LF_Async_Bit        0
#define LF_Use_Heap         0x0002
#define LF_Use_Heap_Bit     1
#define LF_Alloc_Error      0x0004
#define LF_Alloc_Error_Bit  2

//----------------------------------------------------------------------------
//
// Scheduler Boost Values
//
//----------------------------------------------------------------------------

#define Reserved_Low_Boost      0x00000001
#define Cur_Run_VM_Boost        0x00000004
#define Low_Pri_Device_Boost    0x00000010
#define High_Pri_Device_Boost   0x00001000
#define Critical_Section_Boost  0x00100000
#define Time_Critical_Boost     0x00400000
#define Reserved_High_Boost     0x40000000

//----------------------------------------------------------------------------
//
// Flags for Call_Priority_VM_Event
//
//----------------------------------------------------------------------------

#define PEF_Wait_For_STI       0x0001
#define PEF_Wait_For_STI_Bit   0
#define PEF_Wait_Not_Crit      0x0002
#define PEF_Wait_Not_Crit_Bit  1
#define PEF_Dont_Unboost       0x0004
#define PEF_Dont_Unboost_Bit   2
#define PEF_Always_Sched       0x0008
#define PEF_Always_Sched_Bit   3
#define PEF_Time_Out           0x0010
#define PEF_Time_Out_Bit       4

//----------------------------------------------------------------------------
//
// Flags for Begin_Critical_Section and Wait_Semaphore
//
//----------------------------------------------------------------------------

#define Block_Svc_Ints                0x0001
#define Block_Svc_Ints_Bit            0
#define Block_Svc_If_Ints_Locked      0x0002
#define Block_Svc_If_Ints_Locked_Bit  1
#define Block_Enable_Ints             0x0004
#define Block_Enable_Ints_Bit         2
#define Block_Poll                    0x0008
#define Block_Poll_Bit                3

//----------------------------------------------------------------------------
//
// Data structures
//
//----------------------------------------------------------------------------

typedef struct tagREGS
{
    DWORD  eflags ;
    DWORD  edi ;
    DWORD  esi ;
    DWORD  ebp ;
    DWORD  esp ;
    DWORD  ebx ;
    DWORD  edx ;
    DWORD  ecx ;
    DWORD  eax ;
} REGS, *PREGS ;

#define EFLAGS_CF   0x00000001
#define EFLAGS_PF   0x00000004
#define EFLAGS_AF   0x00000010
#define EFLAGS_ZF   0x00000040
#define EFLAGS_SF   0x00000080

typedef struct tagCRS_32
{
   DWORD  Client_EDI ;
   DWORD  Client_ESI ;
   DWORD  Client_EBP ;
   DWORD  dwReserved_1 ;          // ESP at pushall
   DWORD  Client_EBX ;
   DWORD  Client_EDX ;
   DWORD  Client_ECX ;
   DWORD  Client_EAX ;
   DWORD  Client_Error ;          // DWORD error code
   DWORD  Client_EIP ;
   WORD   Client_CS ;
   WORD   wReserved_2 ;           // (padding)
   DWORD  Client_EFlags ;
   DWORD  Client_ESP ;
   WORD   Client_SS ;
   WORD   wReserved_3 ;           // (padding)
   WORD   Client_ES ;
   WORD   WReserved_4 ;           // (padding)
   WORD   Client_DS ;
   WORD   wReserved_5 ;           // (padding)
   WORD   Client_FS ;
   WORD   wReserved_6 ;           // (padding)
   WORD   Client_GS ;
   WORD   wReserved_7 ;           // (padding)

   DWORD  Client_Alt_EIP ;
   WORD   Client_Alt_CS ;
   WORD   wReserved_8 ;           // (padding)
   DWORD  Client_Alt_EFlags ;
   DWORD  Client_Alt_ESP ;
   WORD   Client_Alt_SS ;
   WORD   wReserved_9 ;           // (padding)
   WORD   Client_Alt_ES ;
   WORD   WReserved_10 ;          // (padding)
   WORD   Client_Alt_DS ;
   WORD   wReserved_11 ;          // (padding)
   WORD   Client_Alt_FS ;
   WORD   wReserved_12 ;          // (padding)
   WORD   Client_Alt_GS ;
   WORD   wReserved_13 ;          // (padding)
} CRS_32, *PCRS_32 ;

typedef struct tagCRS_16
{
   WORD   Client_DI ;
   WORD   wReserved_1 ;           // (padding)
   WORD   Client_SI ;
   WORD   wReserved_2 ;           // (padding)
   WORD   Client_BP ;
   WORD   wReserved_3 ;           // (padding)
   DWORD  dwReserved_4 ;          // ESP at pushall
   WORD   Client_BX ;
   WORD   wReserved_5 ;           // (padding)
   WORD   Client_DX ;
   WORD   wReserved_6 ;           // (padding)
   WORD   Client_CX ;
   WORD   wReserved_7 ;           // (padding)
   WORD   Client_AX ;
   WORD   wReserved_8 ;           // (padding)
   DWORD  dwReserved_9 ;          // DWORD error code
   WORD   Client_IP ;
   WORD   wReserved_10 ;          // (padding)
   WORD   Client_CS ;
   WORD   wReserved_11 ;          // (padding)
   WORD   Client_Flags ;          // flags (loword)
   WORD   wReserved_12 ;          // (padding)
   WORD   Client_SP ;
   WORD   wReserved_13 ;          // (padding)
   WORD   Client_SS ;
   WORD   wReserved_14 ;          // (padding)
   WORD   Client_ES ;
   WORD   wReserved_15 ;          // (padding)
   WORD   Client_DS ;
   WORD   wReserved_16 ;          // (padding)
   WORD   Client_FS ;
   WORD   wReserved_17 ;          // (padding)
   WORD   Client_GS ;
   WORD   wReserved_18 ;          // (padding)

   WORD   Client_Alt_IP ;
   WORD   wReserved_19 ;          // (padding)
   WORD   Client_Alt_CS ;
   WORD   wReserved_20 ;          // (padding)
   WORD   Client_Alt_Flags ;
   WORD   wReserved_21 ;          // (padding)
   WORD   Client_Alt_SP ;
   WORD   wReserved_22 ;          // (padding)
   WORD   Client_Alt_SS ;
   WORD   wReserved_23 ;          // (padding)
   WORD   Client_Alt_ES ;
   WORD   wReserved_24 ;          // (padding)
   WORD   Client_Alt_DS ;
   WORD   wReserved_25 ;          // (padding)
   WORD   Client_Alt_FS ;
   WORD   wReserved_26 ;          // (padding)
   WORD   Client_Alt_GS ;
   WORD   wReserved_27 ;          // (padding)
} CRS_16, *PCRS_16 ;

typedef struct tagCRS_8
{
   WORD   Client_DI ;
   WORD   wReserved_1 ;           // (padding)
   WORD   Client_SI ;
   WORD   wReserved_2 ;           // (padding)
   WORD   Client_BP ;
   WORD   wReserved_3 ;           // (padding)
   DWORD  dwReserved_4 ;          // ESP at pushall
   BYTE   Client_BL ;
   BYTE   Client_BH ;
   WORD   wReserved_5 ;           // (padding)
   BYTE   Client_DL ;
   BYTE   Client_DH ;
   WORD   wReserved_6 ;           // (padding)
   BYTE   Client_CL ;
   BYTE   Client_CH ;
   WORD   wReserved_7 ;           // (padding)
   BYTE   Client_AL ;
   BYTE   Client_AH ;
   WORD   wReserved_8 ;           // (padding)
   DWORD  dwReserved_9 ;          // DWORD error code
   WORD   Client_IP ;
   WORD   wReserved_10 ;          // (padding)
   WORD   Client_CS ;
   WORD   wReserved_11 ;          // (padding)
   WORD   Client_Flags ;          // flags (loword)
   WORD   wReserved_12 ;          // (padding)
   WORD   Client_SP ;
   WORD   wReserved_13 ;          // (padding)
   WORD   Client_SS ;
   WORD   wReserved_14 ;          // (padding)
   WORD   Client_ES ;
   WORD   wReserved_15 ;          // (padding)
   WORD   Client_DS ;
   WORD   wReserved_16 ;          // (padding)
   WORD   Client_FS ;
   WORD   wReserved_17 ;          // (padding)
   WORD   Client_GS ;
   WORD   wReserved_18 ;          // (padding)

   WORD   Client_Alt_IP ;
   WORD   wReserved_19 ;          // (padding)
   WORD   Client_Alt_CS ;
   WORD   wReserved_20 ;          // (padding)
   WORD   Client_Alt_Flags ;
   WORD   wReserved_21 ;          // (padding)
   WORD   Client_Alt_SP ;
   WORD   wReserved_22 ;          // (padding)
   WORD   Client_Alt_SS ;
   WORD   wReserved_23 ;          // (padding)
   WORD   Client_Alt_ES ;
   WORD   wReserved_24 ;          // (padding)
   WORD   Client_Alt_DS ;
   WORD   wReserved_25 ;          // (padding)
   WORD   Client_Alt_FS ;
   WORD   wReserved_26 ;          // (padding)
   WORD   Client_Alt_GS ;
   WORD   wReserved_27 ;          // (padding)
} CRS_8, *PCRS_8 ;

typedef union tagCRS
{
    CRS_32 Regs32;
    CRS_16 Regs16;
    CRS_8  Regs8;
} CRS, *PCRS ;

//----------------------------------------------------------------------------
//
// VM control block structure (VMM)
//
//----------------------------------------------------------------------------

typedef struct tagVMMCB
{
   DWORD  CB_VM_Status ;
   DWORD  CB_High_Linear ;
   DWORD  CB_Client_Pointer ;
   DWORD  CB_VMID ;
} VMMCB, *PVMMCB ;

#define VMCB_ID 0x62634D56      /* VMcb */

// VM status indicates globally interesting VM states

#define VMStat_Exclusive           0x00001 // VM is exclusive mode
#define VMStat_Exclusive_Bit       0x00
#define VMStat_Background          0x00002 // VM runs in background
#define VMStat_Background_Bit      0x01
#define VMStat_Creating            0x00004 // In process of creating
#define VMStat_Creating_Bit        0x02
#define VMStat_Suspended           0x00008 // VM not scheduled
#define VMStat_Suspended_Bit       0x03
#define VMStat_Not_Executeable     0x00010 // VM partially destroyed
#define VMStat_Not_Executeable_Bit 0x04
#define VMStat_PM_Exec             0x00020 // Currently in PM app
#define VMStat_PM_Exec_Bit         0x05
#define VMStat_PM_App              0x00040 // PM app present in VM
#define VMStat_PM_App_Bit          0x06
#define VMStat_PM_Use32            0x00080 // PM app is 32-bit
#define VMStat_PM_Use32_Bit        0x07
#define VMStat_VxD_Exec            0x00100 // Call from VxD
#define VMStat_VxD_Exec_Bit        0x08
#define VMStat_High_Pri_Back       0x00200 // High pri background
#define VMStat_High_Pri_Back_Bit   0x09
#define VMStat_Blocked             0x00400 // Blocked on semaphore
#define VMStat_Blocked_Bit         0x0A
#define VMStat_Awakening           0x00800 // Woke up after blocked
#define VMStat_Awakening_Bit       0x0B
#define VMStat_PageableV86         0x01000 // part of V86 is pageable (PM app)
#define VMStat_PageableV86Bit      0x0C
#define VMStat_V86IntsLocked       0x02000 // Rest of V86 is locked
#define VMStat_V86IntsLockedBit    0x0D    //    regardless of pager type
#define VMStat_TS_Sched            0x04000 // Scheduled by time-slicer
#define VMStat_TS_Sched_Bit        0x0E
#define VMStat_Idle                0x08000 // VM has released time slice
#define VMStat_Idle_Bit            0x0F
#define VMStat_Closing             0x10000 // Close_VM called for VM
#define VMStat_Closing_Bit         0x10

#define VMStat_Use32_Mask          (VMStat_PM_Use32 | VMStat_VxD_Exec)

typedef struct tagTCB
{
    DWORD   TCB_Flags;              // Thread status flags
    DWORD   TCB_Reserved1;          // Used internally by VMM
    DWORD   TCB_Reserved2;          // Used internally by VMM
    DWORD   TCB_Signature;
    DWORD   TCB_ClientPtr;          // Client registers of thread
    DWORD   TCB_VMHandle;           // VM that thread is part of
    WORD    TCB_ThreadId;           // Unique Thread ID
    WORD    TCB_PMLockOrigSS;       // Original SS:ESP before lock stack
    DWORD   TCB_PMLockOrigESP;
    DWORD   TCB_PMLockOrigEIP;      // Original CS:EIP before lock stack
    DWORD   TCB_PMLockStackCount;
    WORD    TCB_PMLockOrigCS;
    WORD    TCB_PMPSPSelector;
    DWORD   TCB_ThreadType;         // dword passed to VMMCreateThread
    WORD    TCB_pad1;               // reusable; for dword align
    BYTE    TCB_pad2;               // reusable; for dword align
    BYTE    TCB_extErrLocus;        // extended error Locus
    WORD    TCB_extErr;             // extended error Code
    BYTE    TCB_extErrAction;       //      "   "   Action
    BYTE    TCB_extErrClass;        //      "   "   Class
    DWORD   TCB_extErrPtr;          //      "   pointer
} TCB, *PTCB;

#define SCHED_OBJ_ID_THREAD         0x42434854    // THCB in ASCII

//
//  Thread status indicates globally interesting thread states.
//  Flags are for information only and must not be modified.
//

#define THFLAG_SUSPENDED_Bit        0x03   // Thread not scheduled
#define THFLAG_SUSPENDED            (1L << THFLAG_SUSPENDED_Bit)
#define THFLAG_NOT_EXECUTEABLE_Bit  0x04   // Thread partially destroyed
#define THFLAG_NOT_EXECUTEABLE      (1L << THFLAG_NOT_EXECUTEABLE_Bit)
#define THFLAG_THREAD_CREATION_Bit  0x08   // Thread in status nascendi
#define THFLAG_THREAD_CREATION      (1L << THFLAG_THREAD_CREATION_Bit)
#define THFLAG_THREAD_BLOCKED_Bit   0x0A   // Blocked on semaphore
#define THFLAG_THREAD_BLOCKED       (1L << THFLAG_THREAD_BLOCKED_Bit)
#define THFLAG_CHARSET_Bits         0x10   // Default character set
#define THFLAG_CHARSET_MASK         (3L << THFLAG_CHARSET_Bits)
#define THFLAG_ANSI                 (0L << THFLAG_CHARSET_Bits)
#define THFLAG_OEM                  (1L << THFLAG_CHARSET_Bits)
#define THFLAG_UNICODE              (2L << THFLAG_CHARSET_Bits)
#define THFLAG_RESERVED             (3L << THFLAG_CHARSET_Bits)
#define THFLAG_EXTENDED_HANDLES_Bit 0x12   // Thread uses extended file handles
#define THFLAG_EXTENDED_HANDLES     (1L << THFLAG_EXTENDED_HANDLES_Bit)
//
// the win32 loader opens win32 exes with this bit set to notify IFS
// so a defragger won't move these files
// the bit is turned off once the open completes.
// file open flags are overloaded which is why this is here
//
#define THFLAG_OPEN_AS_IMMOVABLE_FILE_Bit 0x13   // File thus opened not moved
#define THFLAG_OPEN_AS_IMMOVABLE_FILE     (1L << THFLAG_OPEN_AS_IMMOVABLE_FILE_Bit)
//
// Protected mode application control blocks
//
typedef struct tagPMCB
{
    DWORD PMCB_Flags;
    DWORD PMCB_Parent;
} PMCB, *PPMCB;
//
//  The reference data for fault error codes 1-5 (GSDVME_PRIVINST through
//  GSDVME_INVALFLT) is a pointer to the following fault information structure.
//
typedef struct tagVMFaultInfo
{
    DWORD VMFI_EIP;             // faulting EIP
    WORD  VMFI_CS;              // faulting CS
    WORD  VMFI_Ints;            // interrupts in service, if any
} VMFAULTINFO, *PVMFAULTINFO;

//----------------------------------------------------------------------------
//
// Device descriptor block structure
//
//----------------------------------------------------------------------------

#define DDK_Version 0x400

typedef struct tagVxD_Desc_Block
{
   DWORD  DDB_Next ;                // VMM reserved field
   WORD   DDB_SDK_Version  ;        // VMM reserved field
   WORD   DDB_Req_Device_Number ;   // Required device number
   BYTE   DDB_Dev_Major_Version ;   // Major device number
   BYTE   DDB_Dev_Minor_Version ;   // Minor device number
   WORD   DDB_Flags ;               // Flags for init calls complete
   BYTE   DDB_Name[ 8 ] ;           // Device name
   DWORD  DDB_Init_Order ;          // Initialization Order
   DWORD  DDB_Control_Proc ;        // Offset of control procedure
   DWORD  DDB_V86_API_Proc ;        // Offset of API procedure
   DWORD  DDB_PM_API_Proc ;         // Offset of API procedure
   DWORD  DDB_V86_API_CSIP ;        // CS:IP of API entry point
   DWORD  DDB_PM_API_CSIP ;         // CS:IP of API entry point
   DWORD  DDB_Reference_Data ;      // Reference data from real mode
   DWORD  DDB_Service_Table_Ptr ;   // Pointer to service table
   DWORD  DDB_Service_Table_Size ;  // Number of services
   DWORD  DDB_Win32_Service_Table;  // INIT <0> Pointer to Win32 services
   DWORD  DDB_Prev;                 // INIT <'Prev'> Ptr to prev 4.0 DDB
   DWORD  DDB_Reserved0;            // INIT <0> Reserved
   DWORD  DDB_Reserved1;            // INIT <'Rsv1'> Reserved
   DWORD  DDB_Reserved2;            // INIT <'Rsv2'> Reserved
   DWORD  DDB_Reserved3;            // INIT <'Rsv3'> Reserved
} DDB ;
//
// Flag values for DDB_Flags
//
#define DDB_SYS_CRIT_INIT_DONE_Bit  0
#define DDB_SYS_CRIT_INIT_DONE      (1 << DDB_SYS_CRIT_INIT_DONE_Bit)
#define DDB_DEVICE_INIT_DONE_Bit    1
#define DDB_DEVICE_INIT_DONE        (1 << DDB_DEVICE_INIT_DONE_Bit)
#define DDB_HAS_WIN32_SVCS_Bit      14
#define DDB_HAS_WIN32_SVCS          (1 << DDB_HAS_WIN32_SVCS_Bit)
#define DDB_DYNAMIC_VXD_Bit         15
#define DDB_DYNAMIC_VXD             (1 << DDB_DYNAMIC_VXD_Bit)
#define DDB_DEVICE_DYNALINKED_Bit   13
#define DDB_DEVICE_DYNALINKED       (1 << DDB_DEVICE_DYNALINKED_Bit)

//----------------------------------------------------------------------------
//
// Data structures for vmmInstallMultIOHandlers
//
//----------------------------------------------------------------------------

typedef UINT (CDECL* VXDIOPROC)( DWORD, UINT, UINT, PCRS_32, UINT ) ;

typedef struct tagVXDIOENTRY
{
   WORD       VxD_IO_Port ;
   VXDIOPROC  VxD_IO_Proc ;
} VXDIOENTRY, *PVXDIOENTRY ;

typedef struct tagVXDIOTABLE
{
   WORD        IOT_Ports ;
   VXDIOENTRY  IOT_Entries[] ;
} VXDIOTABLE, *PVXDIOTABLE ;
//
// The following are the definitions for the "type of I/O" parameter passed
// to a I/O trap routine.
//
#define BYTE_INPUT      0x000
#define BYTE_OUTPUT     0x004
#define WORD_INPUT      0x008
#define WORD_OUTPUT     0x00C
#define DWORD_INPUT     0x010
#define DWORD_OUTPUT    0x014
#define OUTPUT_BIT      2
#define OUTPUT          (1 << OUTPUT_BIT)
#define WORD_IO_BIT     3
#define WORD_IO         (1 << WORD_IO_BIT)
#define DWORD_IO_BIT    4
#define DWORD_IO        (1 << DWORD_IO_BIT)
#define STRING_IO_BIT   5
#define STRING_IO       (1 << STRING_IO_BIT)
#define REP_IO_BIT      6
#define REP_IO          (1 << REP_IO_BIT)
#define ADDR_32_IO_BIT  7
#define ADDR_32_IO      (1 << ADDR_32_IO_BIT)
#define REVERSE_IO_BIT  8
#define REVERSE_IO      (1 << REVERSE_IO_BIT)
#define IO_SEG_MASK     0x0FFFF0000     // Use this to get segment
#define IO_SEG_SHIFT    0x10            // Must shift right this many

//----------------------------------------------------------------------------
//
//  The following equates are for flags sent to the real mode
//  initialization portion of a device driver:
//
//----------------------------------------------------------------------------

#define DUPLICATE_DEVICE_ID_BIT     0   // loaded
#define DUPLICATE_DEVICE_ID         (1 << DUPLICATE_DEVICE_ID_BIT)
#define DUPLICATE_FROM_INT2F_BIT    1   // loaded from INT 2F list
#define DUPLICATE_FROM_INT2F        (1 << DUPLICATE_FROM_INT2F_BIT)
#define LOADING_FROM_INT2F_BIT      2   // in the INT 2F device list
#define LOADING_FROM_INT2F          (1 << LOADING_FROM_INT2F_BIT)

//----------------------------------------------------------------------------
//
//  The following equates are used to indicate the result of the real mode
//  initialization portion of a device driver:
//
//----------------------------------------------------------------------------

#define DEVICE_LOAD_OK          0   // load protected mode portion
#define ABORT_DEVICE_LOAD       1   // don't load protected mode portion
#define ABORT_WIN386_LOAD       2   // fatal-error: abort load of Win386
#define NO_FAIL_MESSAGE_BIT     15  // set bit to suppress error message
#define NO_FAIL_MESSAGE         (1 << NO_FAIL_MESSAGE_BIT)

//----------------------------------------------------------------------------
//
//  The following equates define the loader services available to the real-mode
//  initialization portion of a device driver:
//
//----------------------------------------------------------------------------

#define LDRSRV_GET_PROFILE_STRING       0   // search SYSTEM.INI for string
#define LDRSRV_GET_NEXT_PROFILE_STRING  1   // search for next string
#define LDRSRV_RESERVED                 2   // RESERVED
#define LDRSRV_GET_PROFILE_BOOLEAN      3   // search SYSTEM.INI for boolean
#define LDRSRV_GET_PROFILE_DECIMAL_INT  4   // search SYSTEM.INI for integer
#define LDRSRV_GET_PROFILE_HEX_INT      5   // search SYSTEM.INI for hex int
#define LDRSRV_COPY_EXTENDED_MEMORY     6   // allocate/init extended memory
#define LDRSRV_GET_MEMORY_INFO          7   // get info about machine memory

//----------------------------------------------------------------------------
//  Registry services for Real mode init time
//
//  The parameters for these are as defined in Windows.h for the
//  corresponding Win Reg API and should be on Stack. These are
//  C Callable except that the function no has to be in AX
//
//----------------------------------------------------------------------------

#define LDRSRV_RegOpenKey           0x100
#define LDRSRV_RegCreateKey         0x101
#define LDRSRV_RegCloseKey          0x102
#define LDRSRV_RegDeleteKey         0x103
#define LDRSRV_RegSetValue          0x104
#define LDRSRV_RegQueryValue        0x105
#define LDRSRV_RegEnumKey           0x106
#define LDRSRV_RegDeleteValue       0x107
#define LDRSRV_RegEnumValue         0x108
#define LDRSRV_RegQueryValueEx      0x109
#define LDRSRV_RegSetValueEx        0x10A
#define LDRSRV_RegFlushKey          0x10B
//
// For the Copy_Extended_Memory service, the following types of memory can be
// requested:
//
#define LDRSRV_COPY_INIT            1   // memory discarded after init
#define LDRSRV_COPY_LOCKED          2   // locked memory
#define LDRSRV_COPY_PAGEABLE        3   // pageable memory

//----------------------------------------------------------------------------
//
//   Object types supported by the vxd loader
//
//  Notes : Low bit of all CODE type objects should be set (VXDLDR uses this)
//           Also Init type objects should be added to the second part of the
//           list (which starts with ICODE_OBJ).
//
//----------------------------------------------------------------------------

#define RCODE_OBJ           -1
#define LCODE_OBJ           0x01
#define LDATA_OBJ           0x02
#define PCODE_OBJ           0x03
#define PDATA_OBJ           0x04
#define SCODE_OBJ           0x05
#define SDATA_OBJ           0x06
#define CODE16_OBJ          0x07
#define LMSG_OBJ            0x08
#define PMSG_OBJ            0x09
#define DBOC_OBJ            0x0B
#define DBOD_OBJ            0x0C
#define ICODE_OBJ           0x11
#define IDATA_OBJ           0x12
#define ICODE16_OBJ         0x13
#define IMSG_OBJ            0x14
typedef struct tagObjectLocation
{
    DWORD OL_LinearAddr ;
    DWORD OL_Size ;
    BYTE  OL_ObjType ;
} OBJECTLOC, *POBJECTLOC;
#define MAXOBJECTS  30
//
// Device_Location structure
//
typedef struct tagDevice_Location_List {
    DWORD      DLL_DDB ;
    BYTE       DLL_NumObjects ;
    POBJECTLOC DLL_ObjLocation[1];
} DEVLOCLIST, *PDEVLOCLIST;

//----------------------------------------------------------------------------
//
// Data structure for vmmAddInstanceItem
//
//----------------------------------------------------------------------------

typedef struct tagINSTDATASTRUC
{
   DWORD   dwInstLinkF ;      // reserved set to NULL
   DWORD   dwInstLinkB ;      // reserved set to NULL
   DWORD   dwInstLinAddr ;    // linear address of start of block
   DWORD   dwInstSize ;       // size of block in bytes
   DWORD   dwInstType ;       // type of block
} INSTDATASTRUC, *PINSTDATASTRUC ;

// values for dwInstType

#define INDOS_Field   0x0100
#define ALWAYS_Field  0x0200

//----------------------------------------------------------------------------
//
// Data structure for page fault
//
//----------------------------------------------------------------------------

typedef struct tagIPFDATA
{

   DWORD  IPF_LinAddr ;       // CR2 address of fault
   DWORD  IPF_MapPageNum ;    // Possible converted page # of fault
   DWORD  IPF_PTEEntry ;      // Contents of PTE that faulted
   DWORD  IPF_FaultingVM ;    // May not = Current VM (IPF_V86PgH set)
   DWORD  IPF_Flags ;         // Flags
} IPFDATA, *PIPFDATA ;
//
// Page fault flags.
//
#define IPF_PAGE_NOT_PRESENT            0x00000008
#define IPF_PAGE_DIR_NOT_PRESENT        0x00000001
#define IPF_PAGE_SWAP_ERROR             0x00000010
#define IPF_PROTECTED_MODE              0x00000080
#define IPF_REENTRANT_FAULT             0x00000020
#define IPF_V86_MODE                    0x00000100
#define IPF_V86_PAGE_NOT_PRESENT        0x00000002
#define IPF_V86_HIGH_PAGE_NOT_PRESENT   0x00000004
#define IPF_VIRTUAL_DEVICE_FAULT        0x00000040
//
// Flags for other page allocator calls
//
//  NOTE: HIGH 8 BITS (bits 24-31) are reserved
//
#define PAGEZEROINIT            0x00000001
#define PAGEUSEALIGN            0x00000002
#define PAGECONTIG              0x00000004
#define PAGEFIXED               0x00000008
#define PAGEDEBUGNULFAULT       0x00000010
#define PAGEZEROREINIT          0x00000020
#define PAGENOCOPY              0x00000040
#define PAGELOCKED              0x00000080
#define PAGELOCKEDIFDP          0x00000100
#define PAGESETV86PAGEABLE      0x00000200
#define PAGECLEARV86PAGEABLE    0x00000400
#define PAGESETV86INTSLOCKED    0x00000800
#define PAGECLEARV86INTSLOCKED  0x00001000
#define PAGEMARKPAGEOUT         0x00002000
#define PAGEPDPSETBASE          0x00004000
#define PAGEPDPCLEARBASE        0x00008000
#define PAGEDISCARD             0x00010000
#define PAGEPDPQUERYDIRTY       0x00020000
#define PAGEMAPFREEPHYSREG      0x00040000
#define PAGENOMOVE              0x10000000
#define PAGEMAPGLOBAL           0x40000000
#define PAGEMARKDIRTY           0x80000000
//
// Flags for _PhysIntoV86, _MapIntoV86, and _LinMapIntoV86
//
#define MAPV86_IGNOREWRAP       0x00000001
//
// Flag equates for _BuildDescriptorDWORDs
//
#define BDDEXPLICITDPL          0x00000001
//
// Flag equates for _Allocate_LDT_Selector
//
#define ALDTSPECSEL             0x00000001
//
// Flag equates for _MMGR_Toggle_HMA
//
#define MMGRHMAPHYSICAL         0x00000001
#define MMGRHMAENABLE           0x00000002
#define MMGRHMADISABLE          0x00000004
#define MMGRHMAQUERY            0x00000008
//
// Flags used by List_Create
//
#define LF_ASYNC_Bit            0
#define LF_ASYNC                (1 << LF_ASYNC_Bit)
#define LF_USE_HEAP_BIT         1
#define LF_USE_HEAP             (1 << LF_USE_HEAP_Bit)
#define LF_ALLOC_ERROR_BIT      2
#define LF_ALLOC_ERROR          (1 << LF_ALLOC_ERROR_Bit)
//
// Swappable lists must use the heap.
//
#define LF_SWAP                 (LF_USE_HEAP + (1 << 3))
//
// Flag bits for _Allocate_Global_V86_Data_Area
//
#define GVDAWordAlign           0x00000001
#define GVDADWordAlign          0x00000002
#define GVDAParaAlign           0x00000004
#define GVDAPageAlign           0x00000008
#define GVDAInstance            0x00000100
#define GVDAZeroInit            0x00000200
#define GVDAReclaim             0x00000400
#define GVDAInquire             0x00000800
#define GVDAHighSysCritOK       0x00001000
#define GVDAOptInstance         0x00002000
#define GVDAForceLow            0x00004000
//
// Flag bits for _Allocate_Temp_V86_Data_Area
//
#define TVDANeedTilInitComplete 0x00000001
//
// Flags for heap allocator calls
//
#define HeapZeroInit    0x0001
#define HeapZeroReInit  0x0002
#define HeapNoCopy      0x0004
#define HeapLockedIfDP  0x0100
#define HeapSwap        0x0200
#define HeapInit        0x0400
#define HeapClean       0x0800
//
// OpenFile, if called after init, must point EDI to a buffer of at least
// this size.
//
#define VMM_OPENFILE_BUF_SIZE   260
//
// GetMachineInfo flag bits.
//
#define GMIF_80486_Bit          0x10
#define GMIF_80486              (1 << GMIF_80486_Bit)
#define GMIF_PCXT_BIT           0x11
#define GMIF_PCXT               (1 << GMIF_PCXT_Bit)
#define GMIF_MCA_BIT            0x12
#define GMIF_MCA                (1 << GMIF_MCA_Bit)
#define GMIF_EISA_BIT           0x13
#define GMIF_EISA               (1 << GMIF_EISA_Bit)
#define GMIF_CPUID_BIT          0x14
#define GMIF_CPUID              (1 << GMIF_CPUID_Bit)
//
// Bits for the ECX return of Get_Next_Arena
//
#define GNA_HIDOSLINKED         0x0002 // High DOS arenas linked when WIN386 started
#define GNA_ISHIGHDOS           0x0004 // High DOS arenas do exist
//
// Error code values for the GetSetDetailedVMError service. PLEASE NOTE
// that all of these error code values need to have bits set in the high
// word. This is to prevent collisions with other VMDOSAPP standard errors.
// Also, the low word must be non-zero.
//
// First set of errors (high word = 0001) are intended to be used
// when a VM is CRASHED (VNE_Crashed or VNE_Nuked bit set on
// VM_Not_Executeable).
//
// PLEASE NOTE that each of these errors (high word == 0001) actually
// has two forms:
//
// 0001xxxxh
// 8001xxxxh
//
// The device which sets the error initially always sets the error with
// the high bit CLEAR. The system will then optionally set the high bit
// depending on the result of the attempt to "nicely" crash the VM. This
// bit allows the system to tell the user whether the crash is likely or
// unlikely to destabalize the system.
//
#define GSDVME_PRIVINST         0x00010001  // Privledged instruction
#define GSDVME_INVALINST        0x00010002  // Invalid instruction
#define GSDVME_INVALPGFLT       0x00010003  // Invalid page fault
#define GSDVME_INVALGPFLT       0x00010004  // Invalid GP fault
#define GSDVME_INVALFLT         0x00010005  // Unspecified invalid fault
#define GSDVME_USERNUKE         0x00010006  // User requested NUKE of VM
#define GSDVME_DEVNUKE          0x00010007  // Device specific problem
#define GSDVME_DEVNUKEHDWR      0x00010008  // Device specific problem:
                                            // invalid hardware fiddling
                                            // by VM (invalid I/O)
#define GSDVME_NUKENOMSG        0x00010009  // Supress standard messages:
                                            // SHELL_Message used for
                                            // custom msg.
#define GSDVME_OKNUKEMASK       0x80000000  // "Nice nuke" bit
//
// Second set of errors (high word = 0002) are intended to be used
// when a VM start up is failed (VNE_CreateFail, VNE_CrInitFail, or
// VNE_InitFail bit set on VM_Not_Executeable).
//
#define GSDVME_INSMEMV86        0x00020001  // base V86 mem    - V86MMGR
#define GSDVME_INSV86SPACE      0x00020002  // Kb Req too large - V86MMGR
#define GSDVME_INSMEMXMS        0x00020003  // XMS Kb Req      - V86MMGR
#define GSDVME_INSMEMEMS        0x00020004  // EMS Kb Req      - V86MMGR
#define GSDVME_INSMEMV86HI      0x00020005  // Hi DOS V86 mem   - DOSMGR,V86MMGR
#define GSDVME_INSMEMVID        0x00020006  // Base Video mem   - VDD
#define GSDVME_INSMEMVM         0x00020007  // Base VM mem     - VMM
                                            // CB, Inst Buffer
#define GSDVME_INSMEMDEV        0x00020008  // Couldn't alloc base VM
                                            // memory for device.
#define GSDVME_CRTNOMSG         0x00020009  // Supress standard messages:
                                            // SHELL_Message used for
                                            // custom msg.
//
// Flags for Close_VM service.
//
#define CVF_CONTINUE_EXEC_Bit           0
#define CVF_CONTINUE_EXEC               (1 << CVF_CONTINUE_EXEC_Bit)
//
// Flag equates for _CreateMutex
//
#define MUTEX_MUST_COMPLETE             1
#define MUTEX_NO_CLEANUP_THREAD_STATE   2
//
// Flag equates for _GetThreadTerminationStatus
//
#define THREAD_TERM_STATUS_CRASH_PEND   1
#define THREAD_TERM_STATUS_NUKE_PEND    2
#define THREAD_TERM_STATUS_SUSPEND_PEND 4
//
// Return values for _GetInstanceInfo
//
#define INSTINFO_NONE                   0       // no data instanced in range
#define INSTINFO_SOME                   1       // some data instanced in range
#define INSTINFO_ALL                    2       // all data instanced in range
//
// Get/Set real DOS PSP.
//
#define GSRDP_Set                       0x0001
#ifndef REG_SZ                          // define only if not there already
#define REG_SZ                          0x0001
#define REG_BINARY                      0x0003
#endif
#ifndef HKEY_LOCAL_MACHINE              // define only if not there already
#define HKEY_CLASSES_ROOT               0x80000000
#define HKEY_CURRENT_USER               0x80000001
#define HKEY_LOCAL_MACHINE              0x80000002
#define HKEY_USERS                      0x80000003
#define HKEY_PERFORMANCE_DATA           0x80000004
#define HKEY_CURRENT_CONFIG             0x80000005
#define HKEY_DYN_DATA                   0x80000006
#endif
//
// Return values for _GetPhysPageInfo
//
#define PHYSINFO_NONE   0       // no pages in the specified range exist
#define PHYSINFO_SOME   1       // some pages in the specified range exist
#define PHYSINFO_ALL    2       // all pages in the specified range exist
//
// TYPE definitions for _GetRegistryKey
//
#define REGTYPE_ENUM                0
#define REGTYPE_CLASS               1
#define REGTYPE_VXD                 2
//
// Flag definitions for _GetRegistryKey
//
#define REGKEY_OPEN                 0
#define REGKEY_CREATE_IFNOTEXIST    1
//
// Flag definitions for _Assert_Range
#define ASSERT_RANGE_NULL_BAD       0x00000000
#define ASSERT_RANGE_NULL_OK        0x00000001
#define ASSERT_RANGE_NO_DEBUG       0x80000000
#define ASSERT_RANGE_BITS           0x80000001
//
// Flag definitions for Get_Boot_Flags
//
#define BOOT_CLEAN                  0x00000001
#define BOOT_DOSCLEAN               0x00000002
#define BOOT_NETCLEAN               0x00000004
#define BOOT_INTERACTIVE            0x00000008
//
// Flag definitions for _Add/_Set/_EnumReclaimableItem
//
#define RS_RECLAIM                  0x00000001
#define RS_RESTORE                  0x00000002
#define RS_DOSARENA                 0x00000004
//
// Structure definition for _EnumReclaimableItem
//
typedef struct tagRECLAIMSTRUC
{
    DWORD   RS_Linear;                  // low (< 1meg) address of item
    DWORD   RS_Bytes;                   // size of item in bytes
    DWORD   RS_CallBack;                // callback, if any (zero if none)
    DWORD   RS_RefData;                 // reference data for callback, if any
    DWORD   RS_HookTable;               // real-mode hook table (zero if none)
    DWORD   RS_Flags;                   // 0 or more of the RS_* equates
} RECLAIMSTRUC, *PRECLAIMSTRUC;
//
// Structures for Force_Mutexes_Free/Restore_Forced_Mutexes
//
typedef struct tagFRMTX
{
    struct tagFRMTX *frmtx_pfrmtxNext;
    DWORD frmtx_hmutex;
    DWORD frmtx_cEnterCount;
    DWORD frmtx_pthcbOwner;
    DWORD frmtx_htimeout;
} FRMTX, *PFRMTX;
typedef struct tagVMMFRINFO
{
    FRMTX vmmfrinfo_frmtxDOS;
    FRMTX vmmfrinfo_frmtxV86;
    FRMTX vmmfrinfo_frmtxOther;
} VMMFRINFO, *PVMMFRINFO;
//
//  Data structure for _GetDemandPageInfo
//
struct tagDemandInfoStruc
{
    DWORD DILin_Total_Count;    // # pages in linear address space
    DWORD DIPhys_Count;         // Count of phys pages
    DWORD DIFree_Count;         // Count of free phys pages
    DWORD DIUnlock_Count;       // Count of unlocked Phys Pages
    DWORD DILinear_Base_Addr;   // Base of pageable address space
    DWORD DILin_Total_Free;     // Total Count of free linear pages
    //
    //  The following 5 fields are all running totals, kept from the time
    //  the system was started
    //
    DWORD DIPage_Faults;        // total page faults
    DWORD DIPage_Ins;           // calls to pagers to page in a page
    DWORD DIPage_Outs;          // calls to pagers to page out a pag
    DWORD DIPage_Discards;      // pages discarded w/o calling pager
    DWORD DIInstance_Faults;    // instance page faults
    DWORD DIPagingFileMax;      // maximum # of pages that could be in paging file
    DWORD DIPagingFileInUse;    // # of pages of paging file currently in use
    DWORD DICommit_Count;       // Total committed memory, in pages
    DWORD DIReserved[2];        // Reserved for expansion
};
//
//  Data structure for _AddInstanceItem
//
struct tagInstDataStruc
{
    DWORD InstLinkF;        // INIT <0> RESERVED
    DWORD InstLinkB;        // INIT <0> RESERVED
    DWORD InstLinAddr;      // Linear address of start of block
    DWORD InstSize;         // Size of block in bytes
    DWORD InstType;         // Type of block
};
//
//  Values for InstType
//
#define INDOS_FIELD     0x100   // Bit indicating INDOS switch requirements
#define ALWAYS_FIELD    0x200   // Bit indicating ALWAYS switch requirements
#define OPTIONAL_FIELD  0x400   // Bit indicating optional instancing requirements
//
// Data structure for Hook_Invalid_Page_Fault handlers.
//
// This is the structure of the "invalid page fault information"
// which is pointed to by EDI when Invalid page fault hookers
// are called.
//
// Page faults can occur on a VM which is not current by touching the VM at
// its high linear address.  In this case, IPF_FaultingVM may not be the
// current VM, it will be set to the VM whos high linear address was touched.
//
struct tagIPF_Data
{
    DWORD IPF_LinAddr;      // CR2 address of fault
    DWORD IPF_MapPageNum;   // Possible converted page # of fault
    DWORD IPF_PTEEntry;     // Contents of PTE that faulted
    DWORD IPF_FaultingVM;   // May not = Current VM (IPF_V86PgH set)
    DWORD IPF_Flags;        // Flags
};
//
//
// Install_Exception_Handler data structure
//
//
struct tagException_Handler_Struc
{
    DWORD EH_Reserved;
    DWORD EH_Start_EIP;
    DWORD EH_End_EIP;
    DWORD EH_Handler;
};
//
// Flags passed in new memory manager functions
//
// PageReserve arena values
//
#define PR_PRIVATE      0x80000400  // anywhere in private arena
#define PR_SHARED       0x80060000  // anywhere in shared arena
#define PR_SYSTEM       0x80080000  // anywhere in system arena
//
// PageReserve flags
//
#define PR_FIXED        0x00000008  // don't move during PageReAllocate
#define PR_4MEG         0x00000001  // allocate on 4mb boundary
#define PR_STATIC       0x00000010  // see PageReserve documentation
//
// PageCommit default pager handle values
//
#define PD_ZEROINIT     0x00000001  // swappable zero-initialized pages
#define PD_NOINIT       0x00000002  // swappable uninitialized pages
#define PD_FIXEDZERO    0x00000003  // fixed zero-initialized pages
#define PD_FIXED        0x00000004  // fixed uninitialized pages
//
// PageCommit flags
//
#define PC_FIXED        0x00000008  // pages are permanently locked
#define PC_LOCKED       0x00000080  // pages are made present and locked
#define PC_LOCKEDIFDP   0x00000100  // pages are locked if swap via DOS
#define PC_WRITEABLE    0x00020000  // make the pages writeable
#define PC_USER         0x00040000  // make the pages ring 3 accessible
#define PC_INCR         0x40000000  // increment "pagerdata" each page
#define PC_PRESENT      0x80000000  // make pages initially present
#define PC_STATIC       0x20000000  // allow commit in PR_STATIC object
#define PC_DIRTY        0x08000000  // make pages initially dirty
//
// PageCommitContig additional flags
//
#define PCC_ZEROINIT    0x00000001  // zero-initialize new pages
#define PCC_NOLIN       0x10000000  // don't map to any linear address
//
// Structure and flags for PageQuery
//
#ifndef _WINNT_
typedef struct _MEMORY_BASIC_INFORMATION
{
    DWORD mbi_BaseAddress;
    DWORD mbi_AllocationBase;
    DWORD mbi_AllocationProtect;
    DWORD mbi_RegionSize;
    DWORD mbi_State;
    DWORD mbi_Protect;
    DWORD mbi_Type;
} MEMORY_BASIC_INFORMATION, *PMEMORY_BASIC_INFORMATION;
#define PAGE_NOACCESS           0x00000001
#define PAGE_READONLY           0x00000002
#define PAGE_READWRITE          0x00000004
#define MEM_COMMIT              0x00001000
#define MEM_RESERVE             0x00002000
#define MEM_FREE                0x00010000
#define MEM_PRIVATE             0x00020000
#endif

//----------------------------------------------------------------------------
//
//                            Pager Descriptor
//
// A PD describes a set of routines to call to bring a page into
// the system or to get it out.  Each committed page in the system
// has an associated PD, a handle to which is stored in the page's
// VP.
//
// For any field that is 0, the pager will not be notified
// when that action takes place.
//
// For the purpose of pagers, a page can be in one of the two states
// describing its current contents:
//
//     clean - page has not been written to since its last page out
//     dirty - page has been written to since its last page out
//
// A page also is in one of two persistent states:
//
//     virgin - page has never been written to since it was committed
//     tainted - page has been written to since it was committed
//
// Note that a tainted page may be either dirty or clean, but a
// virgin page is by definition clean.
//
// Examples of PDs:
//
//     For 32-bit EXE code or read-only data:
//
//       pd_virginin = routine to load page from an exe file
//       pd_taintedin = 0
//       pd_cleanout = 0
//       pd_dirtyout = 0
//       pd_virginfree = 0
//       pd_taintedfree = 0
//       pd_dirty = 0
//       pd_type = PD_PAGERONLY
//
//     For 32-bit EXE writeable data:
//
//       pd_virginin = routine to load page from an exe file
//       pd_taintedin = routine to load page from swap file
//       pd_cleanout = 0
//       pd_dirtyout = routine to write a page out to the swap file
//       pd_virginfree = 0
//       pd_taintedfree = routine to free page from the swap file
//       pd_dirty = routine to free page from the swap file
//       pd_type = PD_SWAPPER
//
//     For zero-initialized swappable data:
//
//       pd_virginin = routine to zero-fill a page
//       pd_taintedin = routine to load page from swap file
//       pd_cleanout = 0
//       pd_dirtyout = routine to write a page out to the swap file
//       pd_virginfree = 0
//       pd_taintedfree = routine to free page from the swap file
//       pd_dirty = routine to free page from the swap file
//       pd_type = PD_SWAPPER
//
//----------------------------------------------------------------------------

typedef DWORD _cdecl FUNPAGE(DWORD * ppagerdata, VOID * ppage, DWORD faultpage);
typedef FUNPAGE * PFUNPAGE;
typedef struct tagPD
{
    //
    // The following four fields are entry points in the pager which
    // we call to page in or page out a page.  The following parameters
    // are passed to the pager during these calls:
    //
    // ppagerdata - pointer to the pager-specific dword of data
    //          stored with the virtual page.  The pager is
    //          free to modify the contents of this dword
    //          DURING the page in or out, but not afterwards.
    //
    // ppage - pointer to page going in or out (a ring 0 alias
    //     to the physical page).  The pager should use this
    //     address to access the contents of the page.
    //
    // faultpage - faulting linear page number for page-ins, -1 for
    //         page-outs.  This address should not be accessed
    //         by the pager.  It is provided for information
    //         only.  Note that a single page can be mapped at
    //         more than one linear address because of the
    //         MapIntoV86 and LinMapIntoV86 services.
    //
    // The pager should return non-0 if the page was successfully
    // paged, or 0 if it failed.
    //
    PFUNPAGE pd_virginin;   // in - while page has never been written to
    PFUNPAGE pd_taintedin;  // in - page written to at least once
    PFUNPAGE pd_cleanout;   // out - page not written to since last out
    PFUNPAGE pd_dirtyout;   // out - page was written to since last out
    //
    // The pd_*free routines are used to inform the pager when the last
    // reference to a virtual page controlled by the pager is
    // decommitted.  A common use of this notification is to
    // free space in a backing file, or write the page contents
    // into the backing file.
    //
    // These calls take the same parameters as the page-out and -in
    // functions, but no return value is recognized.  The "ppage"
    // and "faultpage" parameters will always be 0.
    //
    PFUNPAGE pd_virginfree;  // decommit of never-written-to page
    PFUNPAGE pd_taintedfree; // decommit of page written to at least once
    //
    // The pd_dirty routine is used to inform the pager when the
    // memory manager detects that a page has been written to.  The memory
    // manager does not detect the write at the instant it occurs, so
    // the pager should not depend upon prompt notification.  A common
    // use of this notification might be to invalidate cached data.
    // If the page was dirtied in more than one memory context,
    // the pager's pd_dirty routine will be called once for each
    // context.
    //
    // These calls take the same parameters as the page-out and -in
    // functions except that the "ppage" parameter isn't valid and
    // no return value is recognized.
    //
    PFUNPAGE pd_dirty;
    //
    // The pd_type field gives the sytem information about the
    // overcommit characteristics of pages controlled by this pager.
    // The following are allowable values for the field:
    //
    // PD_SWAPPER - under some conditions, pages of this type
    //      may be paged out into the swap file
    // PD_PAGERONLY - pages controlled by this pager will never
    //      be paged out to the swap file
    //
    // In addition, the following value may be or'ed in to the pd_type field:
    //
    // PD_NESTEXEC - must be specified if either the pd_cleanout or pd_dirtyout
    //      functions perform nested excecution or block using the
    //      BLOCK_SVC_INTS flag.  To be safe, this flag should always be
    //      specified if the pager does any sort of file i/o to anything
    //      other than the default paging file.
    //
    DWORD pd_type;
} PD, * PPD;
//
// values for pd_type
//
#define PD_SWAPPER          0   // pages need direct accounting in swap file
#define PD_PAGERONLY        1   // pages will never be swapped
#define PD_NESTEXEC         2   // page out funtion uses nested execution
//
// The size of a page of memory
//
#define PAGESHIFT           12
#define PAGESIZE            (1 << PAGESHIFT)
#define PAGEMASK            (PAGESIZE - 1)
#define PAGE(p)             ((DWORD)(p) >> PAGESHIFT)
#define NPAGES(cb)          (((DWORD)(cb) + PAGEMASK) >> PAGESHIFT)
//
// Address space (arena) boundaries
//
#define MAXSYSTEMLADDR      0xFFBFFFFF    // 4 GB - 4MB
#define MINSYSTEMLADDR      0xC0000000    // 3 GB
#define MAXSHAREDLADDR      0xBFFFFFFF
#define MINSHAREDLADDR      0x80000000    // 2 GB
#define MAXPRIVATELADDR     0x7FFFFFF
#define MINPRIVATELADDR     0x00400000    // 4 MB
#define MAXDOSLADDR         0x003FFFFF
#define MINDOSLADDR         0x00000000
#define MAXSYSTEMPAGE       (MAXSYSTEMLADDR  >> PAGESHIFT)
#define MINSYSTEMPAGE       (MINSYSTEMLADDR  >> PAGESHIFT)
#define MAXSHAREDPAGE       (MAXSHAREDLADDR  >> PAGESHIFT)
#define MINSHAREDPAGE       (MINSHAREDLADDR  >> PAGESHIFT)
#define MAXPRIVATEPAGE      (MAXPRIVATELADDR >> PAGESHIFT)
#define MINPRIVATEPAGE      (MINPRIVATELADDR >> PAGESHIFT)
#define MAXDOSPAGE          (MAXDOSLADDR     >> PAGESHIFT)
#define MINDOSPAGE          (MINDOSLADDR     >> PAGESHIFT)
#define CBPRIVATE           (1 + MAXPRIVATELADDR - MINPRIVATELADDR)
#define CBSHARED            (1 + MAXSHAREDLADDR - MINSHAREDLADDR)
#define CBSYSTEM            (1 + MAXSYSTEMLADDR - MINSYSTEMLADDR)
#define CBDOS               (1 + MAXDOSLADDR - MINDOSLADDR)
#define CPGPRIVATE          (1 + MAXPRIVATEPAGE - MINPRIVATEPAGE)
#define CPGSHARED           (1 + MAXSHAREDPAGE - MINSHAREDPAGE)
#define CPGSYSTEM           (1 + MAXSYSTEMPAGE - MINSYSTEMPAGE)
#define CPGDOS              (1 + MAXDOSPAGE - MINDOSPAGE)
//
// Largest object that could theoretically be allocated
//
#define CBMAXALLOC          (max(CBSHARED,max(CBPRIVATE, CBSYSTEM)))
#define CPGMAXALLOC         (max(CPGSHARED,max(CPGPRIVATE, CPGSYSTEM)))

//----------------------------------------------------------------------------
//
//  EQUATES FOR SYSTEM_CONTROL CALLS
//
//----------------------------------------------------------------------------

//
// SYS_CRITICAL_INIT is a device init call.  Devices that have a
// critical function that needs initializing before interrupts are
// enabled should do it at Sys_Critical_Init.  Devices which REQUIRE a
// certain range of V86 pages to operate (such as the VDD video memory)
// should claim them at Sys_Critical_Init.  SYS VM Simulate_Int,
// Exec_Int ACTIVITY IS NOT ALLOWED.  Returning carry aborts device
// load only.
//
#define SYS_CRITICAL_INIT       0x0000      // Devices req'd for virt mode
//
// DEVICE_INIT is where most devices do the bulk of their initialization.
// SYS VM Simulate_Int, Exec_Int activity is allowed. Returning carry
// aborts device load only.
//
#define DEVICE_INIT             0x0001      // All other devices init
//
// INIT_COMPLETE is the final phase of device init called just before the
// WIN386 INIT pages are released and the Instance snapshot is taken.
// Devices which wish to search for a region of V86 pages >= A0h to use
// should do it at INIT_COMPLETE.
// SYS VM Simulate_Int, Exec_Int activity is allowed.  Returning carry
// aborts device load only.
//
#define INIT_COMPLETE           0x0002      // All devices initialized
//
// --------------- INITIALIZATION CODE AND DATA DISCARDED ------------------
//
//
// Same as VM_Init, except for SYS VM.
//
#define SYS_VM_INIT             0x0003      // Execute the system VM
//
// Same as VM_Terminate, except for SYS VM (Normal WIN386 exit ONLY, on a crash
// exit this call is not made).  SYS VM Simulate_Int, Exec_Int activity is
// allowed.  This and Sys_VM_Terminate2 are your last chances to access
// and/or lock pageable data.
//
#define SYS_VM_TERMINATE        0x0004      // System VM terminated
//
// System_Exit call is made when WIN386 is exiting either normally or via
// a crash.  INTERRUPTS ARE ENABLED.  Instance snapshot has been restored.
// SYS VM Simulate_Int, Exec_Int ACTIVITY IS NOT ALLOWED.
//
#define SYSTEM_EXIT             0x0005      // Devices prepare to exit
//
// SYS_CRITICAL_EXIT call is made when WIN386 is exiting either normally or via
// a crash.  INTERRUPTS ARE DISABLED.  SYS VM Simulate_Int, Exec_Int ACTIVITY
//  IS NOT ALLOWED.
//
#define SYS_CRITICAL_EXIT       0x0006      // System critical devices reset
//
// Create_VM creates a new VM.  EBX = VM handle of new VM.  Returning
// Carry will fail the Create_VM.
//
#define CREATE_VM               0x0007
//
// Second phase of Create_VM.  EBX = VM handle of new VM.  Returning
// Carry will cause the VM to go Not_Executeable, then be destroyed.
// VM Simulate_Int, Exec_Int activity is NOT allowed.
//
#define VM_CRITICAL_INIT        0x0008
//
// Third phase of Create_VM.  EBX = VM handle of new VM.  Returning
// Carry will cause the VM to go Not_Executeable, then be destroyed.
// VM Simulate_Int, Exec_Int activity is allowed.
//
#define VM_INIT                 0x0009
//
// NORMAL (First phase) of Destroy_VM.  EBX = VM Hanlde.  This occurs
// on normal termination of the VM.  Call cannot be failed.  VM
// Simulate_Int, Exec_Int activity is allowed.
//
#define VM_TERMINATE            0x000A      // Still in VM -- About to die
//
// Second phase of Destroy_VM.  EBX = VM Handle, EDX = Flags (see
// below).  Note that in the case of destroying a running VM, this is
// the first call made (VM_Terminate call does not occur).  Call cannot
// be failed.  VM Simulate_Int, Exec_Int activity is NOT allowed.
//
#define VM_NOT_EXECUTEABLE      0x000B      // Most devices die (except VDD)
//
// Final phase of Destroy_VM.  EBX = VM Handle.  Note that considerable
// time can elaps between the VM_Not_Executeable call and this call.
// Call cannot be failed.  VM Simulate_Int, Exec_Int activity is NOT
// allowed.
//
#define DESTROY_VM              0x000C      // VM's control block about to go
//
// Flags for VM_Not_Executeable control call (passed in EDX)
//
#define VNE_CRASHED_Bit         0x00        // VM was crashed
#define VNE_CRASHED             (1 << VNE_CRASHED_Bit)
#define VNE_NUKED_Bit           0x01        // VM was destroyed while active
#define VNE_NUKED               (1 << VNE_NUKED_Bit)
#define VNE_CREATEFAIL_Bit      0x02        // Some device failed Create_VM
#define VNE_CREATEFAIL          (1 << VNE_CREATEFAIL_Bit)
#define VNE_CRINITFAIL_Bit      0x03        // Some device failed VM_Critical_Init
#define VNE_CRINITFAIL          (1 << VNE_CRINITFAIL_Bit)
#define VNE_INITFAIL_Bit        0x04        // Some device failed VM_Init
#define VNE_INITFAIL            (1 << VNE_INITFAIL_Bit)
#define VNE_CLOSED_Bit          0x05
#define VNE_CLOSED              (1 << VNE_CLOSED_Bit)
//
// EBX = VM Handle. Call cannot be failed.
//
#define VM_SUSPEND              0x000D      // VM not runnable until resume
//
// EBX = VM Handle. Returning carry fails and backs out the resume.
//
#define VM_RESUME               0x000E      // VM is leaving suspended state
//
// EBX = VM Handle to set device focus to.  EDX = Device ID if device
// specific setfocus, == 0 if device critical setfocus (all devices).
// THIS CALL CANNOT BE FAILED.
//
// NOTE: In case where EDX == 0, ESI is a FLAG word that indicates
// special functions.  Currently Bit 0 being set indicates that this
// Device critical set focus is also "VM critical".  It means that we
// do not want some other VM to take the focus from this app now.  This
// is primarily used when doing a device critical set focus to Windows
// (the SYS VM) it is interpreted by the SHELL to mean "if an old app
// currently has the Windows activation, set the activation to the
// Windows Shell, not back to the old app".  ALSO in the case where Bit
// 0 is set, EDI = The VM handle of the VM that is "having trouble".
// Set this to 0 if there is no specific VM associated with the
// problem.
//
#define SET_DEVICE_FOCUS        0x000F
//
// EBX = VM Handle going into message mode.  THIS CALL CANNOT BE FAILED.
//
#define BEGIN_MESSAGE_MODE      0x0010
//
// EBX = VM Handle leaving message mode.  THIS CALL CANNOT BE FAILED.
//
#define END_MESSAGE_MODE        0x0011
//
// ----------------------- SPECIAL CONTROL CALLS ---------------------------
//
//
// Request for reboot.  Call cannot be failed.
//
#define REBOOT_PROCESSOR        0x0012
//
// Query_Destroy is an information call made by the SHELL device before
// an attempt is made to initiate a destroy VM sequence on a running VM
// which has not exited normally.  EBX = VM Handle.  Returning carry
// indicates that a device "has a problem" with allowing this.  THE
// DESTROY SEQUENCE CANNOT BE ABORTED HOWEVER, this decision is up to
// the user.  All this does is indicate that there is a "problem" with
// allowing the destroy.  The device which returns carry should call
// the SHELL_Message service to post an informational dialog about the
// reason for the problem.
//
#define QUERY_DESTROY           0x0013
//
// ----------------------- DEBUGGING CONTROL CALL --------------------------
//
// Special call for device specific DEBUG information display and activity.
//
#define DEBUG_QUERY             0x0014
//
// -------- CALLS FOR BEGIN/END OF PROTECTED MODE VM EXECUTION -------------
//
//  About to run a protected mode application.
//  EBX = Current VM handle.
//  EDX = Flags
//  EDI -> Application Control Block
//  Returning with carry set fails the call.
//
#define BEGIN_PM_APP            0x0015
//
// Flags for Begin_PM_App (passed in EDX)
//
#define BPA_32_BIT              0x01
#define BPA_32_BIT_FLAG         1
//
// Protected mode application is terminating.
// EBX = Current VM handle.  THIS CALL CAN NOT FAIL.
// EDI -> Application Control Block
//
#define END_PM_APP              0x0016
//
// Called whenever system is about to be rebooted.  Allows VxDs to clean
// up in preperation for reboot.
//
#define DEVICE_REBOOT_NOTIFY    0x0017
#define CRIT_REBOOT_NOTIFY      0x0018
//
// Called when VM is about to be terminated using the Close_VM service
// EBX = Current VM handle (Handle of VM to close)
// EDX = Flags
//       CVNF_CRIT_CLOSE = 1 if VM is in critical section while closing
//
#define CLOSE_VM_NOTIFY         0x0019
#define CVNF_CRIT_CLOSE_Bit     0
#define CVNF_CRIT_CLOSE         (1 << CVNF_CRIT_CLOSE_Bit)
//
// Power management event notification.
// EBX = 0
// ESI = event notification message
// EDI -> DWORD return value; VxD's modify the DWORD to return info, not EDI
// EDX is reserved
//
#define POWER_EVENT             0x001A
#define SYS_DYNAMIC_DEVICE_INIT 0x001B
#define SYS_DYNAMIC_DEVICE_EXIT 0x001C
//
// Create_THREAD creates a new thread.  EDI = handle of new thread.
// Returning Carry will fail the Create_THREAD. Message is sent in the
// context of the creating thread.
//
#define  CREATE_THREAD          0x001D
//
// Second phase of creating a thread.  EDI = handle of new thread.  Call cannot
// be failed. VM Simulate_Int, Exec_Int activity is not allowed (because
// never allowed in non-initial threads). Message is sent in the context
// of the newly created thread.
//
#define  THREAD_INIT            0x001E
//
// Normal (first) phase of Destroy_THREAD. EDI = handle of thread.
// This occurs on normal termination of the thread.  Call cannot be failed.
// Simulate_Int, Exec_Int activity is allowed.
//
#define  TERMINATE_THREAD       0x001F
//
// Second phase of Destroy_THREAD.  EDI = Handle of thread,
// EDX = flags (see below).  Note that in the case of destroying a
// running thread, this is the first call made (THREAD_Terminate call
// does not occur).  Call cannot be failed.  VM Simulate_Int, Exec_Int
// activity is NOT allowed.
//
#define  THREAD_Not_Executeable 0x0020
//
// Final phase of Destroy_THREAD.  EDI = Thread Handle.  Note that considerable
// time can elapse between the THREAD_Not_Executeable call and this call.
// Call cannot be failed.  VM Simulate_Int, Exec_Int activity is NOT
// allowed.
//
#define  DESTROY_THREAD         0x0021
//
// -------------------- CALLS FOR PLUG&PLAY -------------------------
//
// Configuration manager or a devloader is telling a DLVxD that a new devnode
// has been created. EBX is the handle of the new devnode and EDX is the load
// type (one of the DLVxD_LOAD_* defined in CONFIGMG.H). This is a 'C'
// system control call. Contrarily to the other calls, carry flags must be
// set if any error code other than CR_SUCCESS is to be return.
//
#define PNP_NEW_DEVNODE         0x0022
//
// -------------------- CALLS FOR Win32  -------------------------
//
// vWin32 communicates with Vxds on behalf of Win32 apps thru this mechanism.
// BUGBUG: need more doc here, describing the interface
//
#define W32_DEVICEIOCONTROL     0x0023
//
// sub-functions
//
#define DIOC_GETVERSION         0x0
#define DIOC_OPEN               DIOC_GETVERSION
#define DIOC_CLOSEHANDLE        -1
//
// -------------------- MORE SYSTEM CALLS -------------------------
//
// All these messages are sent immediately following the corresponding
// message of the same name, except that the "2" messages are sent
// in *reverse* init order.
//
#define SYS_VM_TERMINATE2       0x0024
#define SYSTEM_EXIT2            0x0025
#define SYS_CRITICAL_EXIT2      0x0026
#define VM_TERMINATE2           0x0027
#define VM_NOT_EXECUTEABLE2     0x0028
#define DESTROY_VM2             0x0029
#define VM_SUSPEND2             0x002A
#define END_MESSAGE_MODE2       0x002B
#define END_PM_APP2             0x002C
#define DEVICE_REBOOT_NOTIFY2   0x002D
#define CRIT_REBOOT_NOTIFY2     0x002E
#define CLOSE_VM_NOTIFY2        0x002F
//
// VCOMM gets Address of Contention handler from VxDs by sending this
// control message
//
#define GET_CONTENTION_HANDLER  0x0030
#define KERNEL32_INITIALIZED    0x0031
#define KERNEL32_SHUTDOWN       0x0032
#define MAX_SYSTEM_CONTROL      0x0032
//
// Dynamic VxD's can communicate with each other using Directed_Sys_Control
// and a private control message in the following range:
//
#define BEGIN_RESERVED_PRIVATE_SYSTEM_CONTROL   0x70000000
#define END_RESERVED_PRIVATE_SYSTEM_CONTROL     0x7FFFFFFF
//
// Values returned from VMM_GetSystemInitState in EAX.
//
// Comments represent operations performed by VMM; #define's indicate
// what VMM_GetSystemInitState will return if you call it between the
// previous operation and the next.
//
// Future versions of Windows may have additional init states between the
// ones defined here, so you should be careful to use range checks instead
// of test for equality.
//
// Protected mode is entered
//
#define SYSSTATE_PRESYSCRITINIT     0x00000000
//
// SYS_CRITICAL_INIT is broadcast
//
#define SYSSTATE_PREDEVICEINIT      0x10000000
//
// DEVICE_INIT is broadcast
//
#define SYSSTATE_PREINITCOMPLETE    0x20000000
//
// INIT_COMPLETE is broadcast
// VxD initialization complete
//
#define SYSSTATE_VXDINITCOMPLETED   0x40000000
//
// KERNEL32_INITIALIZED is broadcast
//
#define SYSSTATE_KERNEL32INITED     0x50000000
//
// All initialization completed
// System running normally
// System shutdown initiated
// KERNEL32_SHUTDOWN is broadcast
//
#define SYSSTATE_KERNEL32TERMINATED 0xA0000000
//
// System shutdown continues
//
#define SYSSTATE_PRESYSVMTERMINATE  0xB0000000
//
// SYS_VM_TERMINATE is broadcast
//
#define SYSSTATE_PRESYSTEMEXIT      0xE0000000
//
// SYSTEM_EXIT is broadcast
//
#define SYSSTATE_PRESYSTEMEXIT2     0xE4000000
//
// SYSTEM_EXIT2 is broadcast
//
#define SYSSTATE_PRESYSCRITEXIT     0xF0000000
//
// SYS_CRITICAL_EXIT is broadcast
//
#define SYSSTATE_PRESYSCRITEXIT2    0xF4000000
//
// SYS_CRITICAL_EXIT2 is broadcast
//
#define SYSSTATE_POSTSYSCRITEXIT2   0xFFF00000
//
// Return to real mode
// Alternate path: CAD reboot
//
#define SYSSTATE_PREDEVICEREBOOT    0xFFFF0000
//
// DEVICE_REBOOT_NOTIFY is broadcast
//
#define SYSSTATE_PRECRITREBOOT      0xFFFFF000
//
// CRIT_REBOOT_NOTIFY is broadcast
//
#define SYSSTATE_PREREBOOTCPU       0xFFFFFF00
//
// REBOOT_PROCESSOR is broadcast
// Return to real mode
//
//         S C H E D U L E R   B O O S T   V A L U E S
//
#define RESERVED_LOW_BOOST      0x00000001
#define CUR_RUN_VM_BOOST        0x00000004
#define LOW_PRI_DEVICE_BOOST    0x00000010
#define HIGH_PRI_DEVICE_BOOST   0x00001000
#define CRITICAL_SECTION_BOOST  0x00100000
#define TIME_CRITICAL_BOOST     0x00400000
#define RESERVED_HIGH_BOOST     0x40000000
//
//   F L A G S   F O R   C A L L _ P R I O R I T Y _ V M _ E V E N T
//
#define PEF_WAIT_FOR_STI_Bit            0
#define PEF_WAIT_FOR_STI                (1 << PEF_WAIT_FOR_STI_Bit)
#define PEF_WAIT_NOT_CRIT_Bit           1
#define PEF_WAIT_NOT_CRIT               (1 << PEF_WAIT_NOT_CRIT_Bit)
#define PEF_DONT_UNBOOST_Bit            2
#define PEF_DONT_UNBOOST                (1 << PEF_DONT_UNBOOST_Bit)
#define PEF_ALWAYS_SCHED_Bit            3
#define PEF_ALWAYS_SCHED                (1 << PEF_ALWAYS_SCHED_Bit)
#define PEF_TIME_OUT_Bit                4
#define PEF_TIME_OUT                    (1 << PEF_TIME_OUT_Bit)
#define PEF_WAIT_NOT_HW_INT_Bit         5
#define PEF_WAIT_NOT_HW_INT             (1 << PEF_WAIT_NOT_HW_INT_Bit)
#define PEF_WAIT_NOT_NESTED_EXEC_Bit    6
#define PEF_WAIT_NOT_NESTED_EXEC        (1 << PEF_WAIT_NOT_NESTED_EXEC_Bit)
#define PEF_WAIT_IN_PM_Bit              7
#define PEF_WAIT_IN_PM                  (1 << PEF_WAIT_IN_PM_Bit)
#define PEF_THREAD_EVENT_Bit            8
#define PEF_THREAD_EVENT                (1 << PEF_THREAD_EVENT_Bit)
#define PEF_WAIT_FOR_THREAD_STI_Bit     9
#define PEF_WAIT_FOR_THREAD_STI         (1 << PEF_WAIT_FOR_THREAD_STI_Bit)
#define PEF_RING0_EVENT_Bit             10
#define PEF_RING0_EVENT                 (1 << PEF_RING0_EVENT_Bit)
#define PEF_WAIT_CRIT_Bit               11
#define PEF_WAIT_CRIT                   (1 << PEF_WAIT_CRIT_Bit)
#define PEF_WAIT_CRIT_VM_Bit            12
#define PEF_WAIT_CRIT_VM                (1 << PEF_WAIT_CRIT_VM_Bit)
//
// synonyms for event restrictions above
//
#define PEF_WAIT_NOT_TIME_CRIT_Bit          PEF_WAIT_NOT_HW_INT_Bit
#define PEF_WAIT_NOT_TIME_CRIT              PEF_WAIT_NOT_HW_INT
#define PEF_WAIT_NOT_PM_LOCKED_STACK_Bit    PEF_WAIT_NOT_NESTED_EXEC_Bit
#define PEF_WAIT_NOT_PM_LOCKED_STACK        PEF_WAIT_NOT_NESTED_EXEC
//
// FLAGS FOR BEGIN_CRITICAL_SECTION,
// ENTER_MUTEX AND WAIT_SEMAPHORE
//
#define BLOCK_SVC_INTS_Bit              0
#define BLOCK_SVC_INTS                  (1 << BLOCK_SVC_INTS_Bit)
#define BLOCK_SVC_IF_INTS_LOCKED_Bit    1
#define BLOCK_SVC_IF_INTS_LOCKED        (1 << BLOCK_SVC_IF_INTS_LOCKED_Bit)
#define BLOCK_ENABLE_INTS_Bit           2
#define BLOCK_ENABLE_INTS               (1 << BLOCK_ENABLE_INTS_Bit)
#define BLOCK_POLL_Bit                  3
#define BLOCK_POLL                      (1 << BLOCK_POLL_Bit)
#define BLOCK_THREAD_IDLE_Bit           4
#define BLOCK_THREAD_IDLE               (1 << BLOCK_THREAD_IDLE_Bit)
#define BLOCK_FORCE_SVC_INTS_Bit        5
#define BLOCK_FORCE_SVC_INTS            (1 << BLOCK_FORCE_SVC_INTS_Bit)


//----------------------------------------------------------------------------
//
// Function parameter passing/return type defines.
//
//----------------------------------------------------------------------------

#define CARRY       void
#pragma aux VMM_C   "_*" parm caller []         \
                      value no8087 [EAX]        \
                      modify [EAX EBX ECX EDX];
#pragma aux VMM_CTL "*" parm [EAX] [EBX] [EDX]  \
                      modify [EAX EBX ECX EDX];
#pragma aux VMM_CB  "*" parm [EBX] [EDX]  \
                      modify [EAX EBX ECX EDX];
#pragma aux VMM_API "*" parm [EBX] [ECX]        \
                      modify [EAX EBX ECX EDX];

//----------------------------------------------------------------------------
//
// Function prototypes for VMM interface helper functions.
//
//----------------------------------------------------------------------------

#define vmmControlEntry()
CARRY   vmmControlExit(DWORD);
#define vmmCallBackEntry()
CARRY   vmmCallBackExit(DWORD);
VOID    vmmAPIEntry(VOID);
CARRY   vmmAPIExit(DWORD);

//----------------------------------------------------------------------------
//
// VMM interface inline helper functions.
//
//----------------------------------------------------------------------------

#pragma aux vmmControlExit =    \
            "stc"               \
            "or     EAX, EAX"   \
            "jnz    ctlExit"    \
            "clc"               \
            "ctlExit:"          \
            parm [EAX];

#pragma aux vmmCallBackExit =   \
            "stc"               \
            "or     EAX, EAX"   \
            "jnz    cbExit"     \
            "clc"               \
            "cbExit:"           \
            parm [EAX];

#pragma aux vmmAPIEntry =       \
            "mov    ECX, EBP";

#pragma aux vmmAPIExit =        \
            "stc"               \
            "or     EAX, EAX"   \
            "jnz    cbExit"     \
            "clc"               \
            "cbExit:"           \
            parm [EAX];

//----------------------------------------------------------------------------
//
// Function prototypes for VMM API.
//
//----------------------------------------------------------------------------
//
// Win 3.1 services.
//
VOID  vmmAdjustExecPriority(DWORD, DWORD);
VOID  vmmAdjustExecTime(DWORD, DWORD);
DWORD vmmAllocateGDTSelector(DWORD, DWORD, DWORD);
DWORD vmmAllocateLDTSelector(DWORD, DWORD, DWORD, DWORD, DWORD);
VOID  vmmBeginCriticalSection(DWORD);
VOID  vmmBeginNestExecution(VOID);
VOID  vmmBeginNestV86Exec(VOID);
DWORD vmmBeginReentrantExecution(VOID);
VOID  vmmBeginUseLockedPMStack(VOID);
QWORD vmmBuildDescriptorDWORDs(DWORD, DWORD, DWORD, DWORD, DWORD);
VOID  vmmBuildIntStackFrame(DWORD, DWORD);
DWORD vmmCallGlobalEvent(DWORD, DWORD);
DWORD vmmCallPriorityVMEvent(DWORD, DWORD, DWORD, DWORD, DWORD, DWORD);
DWORD vmmCallVMEvent(DWORD, DWORD, DWORD);
DWORD vmmCallWhenIdle(DWORD);
VOID  vmmCallWhenNotCritical(DWORD, DWORD);
VOID  vmmCallWhenVMIntsEnabled(DWORD, DWORD);
VOID  vmmCallWhenVMReturns(DWORD, DWORD, DWORD);
VOID  vmmCancelGlobalEvent(DWORD);
VOID  vmmCancelPriorityVMEvent(DWORD);
VOID  vmmCancelTimeOut(DWORD);
VOID  vmmCancelVMEvent(DWORD, DWORD);
VOID  vmmClaimCriticalSection(DWORD, DWORD);
DWORD vmmCopyPageTable(DWORD, DWORD, DWORD, DWORD);
DWORD vmmCreateSemaphore(DWORD);
VOID  vmmDestroySemaphore(DWORD);
VOID  vmmDisableGlobalTrapping(DWORD);
VOID  vmmDisableLocalTrapping(DWORD, DWORD);
VOID  vmmDisableVMInts(VOID);
VOID  vmmEnableGlobalTrapping(DWORD);
VOID  vmmEnableVMInts(VOID);
DWORD vmmEndCritAndSuspend(VOID);
DWORD vmmEndCriticalSection(VOID);
VOID  vmmEndNestExecution(VOID);
VOID  vmmEndReentrantExecution(DWORD);
VOID  vmmEndUseLockedPMStack(VOID);
VOID  vmmExecInt(DWORD);
VOID  vmmExecVxDInt(DWORD);
VOID  vmmFatalErrorHandler(DWORD, DWORD);
DWORD vmmFreeGDTSelector(DWORD, DWORD);
DWORD vmmFreeLDTSelector(DWORD, DWORD, DWORD);
DWORD vmmGetAppFlatDSAlias(VOID);
PSTR  vmmGetConfigDirectory(VOID);
DWORD vmmGetCritSectionStatus(VOID);
DWORD vmmGetCritStatusNoBlock(VOID);
DWORD vmmGetCurVMHandle();
QWORD vmmGetDescriptor(DWORD, DWORD, DWORD);
PSTR  vmmGetEnvironmentString(PSTR);
PSTR  vmmGetExecPath(VOID);
VOID  vmmGetFaultHookAddrs(DWORD, PDWORD);
QWORD vmmGetFreePageCount(DWORD);
DWORD vmmGetLastUpdatedSystemTime(VOID);
DWORD vmmGetLastUpdatedVMExecTime(VOID);
VOID  vmmGetMachineInfo(PDWORD);
PSTR  vmmGetNextProfileString(PSTR, PSTR);
DWORD vmmGetNulPageHandle(VOID);
DWORD vmmGetProfileBoolean(DWORD, PSTR, PSTR);
DWORD vmmGetProfileDecimalInt(DWORD, PSTR, PSTR);
DWORD vmmGetProfileHexInt(DWORD, PSTR, PSTR);
PSTR  vmmGetProfileString(PSTR, PSTR, PSTR);
DWORD vmmGetPSPSegment(VOID);
DWORD vmmGetSysPageCount(DWORD);
DWORD vmmGetSystemTime(VOID);
DWORD vmmGetSysVMHandle(VOID);
DWORD vmmGetVMExecTime(VOID);
DWORD vmmGetVMMReenterCount(VOID);
WORD  vmmGetVMMVersion(VOID);
QWORD vmmGetVMPgCount(DWORD, DWORD);
BYTE* vmmHeapAllocate(DWORD, DWORD);
DWORD vmmHeapFree(BYTE*, DWORD);
DWORD vmmHeapGetSize(BYTE*, DWORD);
BYTE* vmmHeapReAllocate(BYTE*, DWORD, DWORD);
DWORD vmmHookDevicePMAPI(DWORD, DWORD);
DWORD vmmHookDeviceService(DWORD, DWORD);
DWORD vmmHookDeviceV86API(DWORD, DWORD);
DWORD vmmHookInvalidPageFault(DWORD);
DWORD vmmHookPMFault(DWORD, DWORD);
DWORD vmmHookV86Fault(DWORD, DWORD);
VOID  vmmHookV86IntChain(DWORD, DWORD);
VOID  vmmHookV86Page(DWORD, DWORD);
DWORD vmmHookVMMFault(DWORD, DWORD);
VOID  vmmInstallIOHandler(DWORD, DWORD);
DWORD vmmInstallMultIOHandlers(DWORD*);
DWORD vmmLinMapIntoV86(DWORD, DWORD, DWORD, DWORD, DWORD);
DWORD vmmLinPageLock(DWORD, DWORD, DWORD);
DWORD vmmLinPageUnLock(DWORD, DWORD, DWORD);
DWORD vmmMapFlat(DWORD, DWORD);
DWORD vmmMapFreePhysReg(DWORD, DWORD, DWORD);
DWORD vmmMapIntoV86(DWORD, DWORD, DWORD, DWORD, DWORD, DWORD);
QWORD vmmMapLinToVMAddr(DWORD, DWORD);
DWORD vmmMapPhysToLinear(DWORD, DWORD, DWORD);
DWORD vmmModifyPageBits(DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD);
VOID  vmmNoFailResumeVM(DWORD);
DWORD vmmOpenFile(PSTR, PSTR);
VOID  vmmOutDebugString(PSTR);
VOID  vmmOutDebugStringValue(PSTR, DWORD);
QWORD vmmPageAllocate(DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD);
DWORD vmmPageCheckLinRange(DWORD, DWORD, DWORD);
DWORD vmmPageDiscardPages(DWORD, DWORD, DWORD, DWORD);
DWORD vmmPageFree(DWORD, DWORD);
QWORD vmmPageGetAllocInfo(DWORD);
QWORD vmmPageGetSizeAddr(DWORD, DWORD);
DWORD vmmPageLock(DWORD, DWORD, DWORD, DWORD);
QWORD vmmPageReAllocate(DWORD, DWORD, DWORD);
DWORD vmmPageResetHandlePAddr(DWORD, DWORD, DWORD, DWORD, DWORD);
DWORD vmmPageUnLock(DWORD, DWORD, DWORD, DWORD);
DWORD vmmPhysIntoV86(DWORD, DWORD, DWORD, DWORD, DWORD);
VOID  vmmReleaseCriticalSection(DWORD);
DWORD vmmRemoveExceptionHandler(DWORD);
VOID  vmmRestoreClientState(CRS*);
VOID  vmmResumeExec(VOID);
DWORD vmmResumeVM(DWORD);
VOID  vmmSaveClientState(CRS*);
DWORD vmmScheduleGlobalEvent(DWORD, DWORD);
DWORD vmmScheduleVMEvent(DWORD, DWORD, DWORD);
DWORD vmmSelectorMapFlat(DWORD, DWORD, DWORD);
DWORD vmmSetDescriptor(DWORD, DWORD, DWORD, DWORD, DWORD);
DWORD vmmSetFrePhysRegCalBk(DWORD, DWORD);
DWORD vmmSetGlobalTimeOut(DWORD, DWORD, DWORD);
DWORD vmmSetResetV86Pageable(DWORD, DWORD, DWORD, DWORD);
VOID  vmmSetV86IntVector(DWORD, WORD, DWORD);
DWORD vmmSetVMTimeOut(DWORD, DWORD, DWORD, DWORD);
VOID  vmmSignalSemaphore(DWORD);
VOID  vmmSimulateFarCall(DWORD, DWORD);
VOID  vmmSimulateFarJmp(DWORD, DWORD);
VOID  vmmSimulateFarRet(VOID);
VOID  vmmSimulateFarRetN(DWORD);
VOID  vmmSimulateFarInt(DWORD);
VOID  vmmSimulateIret(VOID);
DWORD vmmSimulatePop(VOID);
VOID  vmmSimulatePush(DWORD);
VOID  vmmTestReenter(VOID);
DWORD vmmTestSysVMHandle(DWORD);
DWORD vmmUnhookInvalidPageFault(DWORD);
DWORD vmmUnhookPMFault(DWORD, DWORD);
DWORD vmmUnhookV86Fault(DWORD, DWORD);
DWORD vmmUnhookVMMFault(DWORD, DWORD);
DWORD vmmUnmapFreePhysReg(DWORD, DWORD, DWORD);
VOID  vmmWaitSemaphore(DWORD, DWORD);
DWORD vmmXchgFreePhysReg(DWORD, DWORD, DWORD);
//
// Win 4.0 services.
//
DWORD vmmPageCommit(DWORD, DWORD, DWORD, DWORD, DWORD);
DWORD vmmPageCommitContig(DWORD, DWORD, DWORD, DWORD, DWORD, DWORD);
DWORD vmmPageCommitPhys(DWORD, DWORD, DWORD, DWORD);
DWORD vmmPageDecommit(DWORD, DWORD, DWORD);
DWORD vmmPageReserve(DWORD, DWORD, DWORD);
DWORD vmmAllocatePMCallBack(DWORD, DWORD);
DWORD vmmAllocateV86CallBack(DWORD, DWORD);
DWORD vmmInstallV86BreakPoint(DWORD, DWORD, DWORD);
DWORD vmmRemoveV86BreakPoint(DWORD);
VOID  vmmCancelThreadEvent(DWORD, DWORD);
DWORD vmmScheduleThreadEvent(DWORD, DWORD, DWORD);
DWORD vmmHookNMIEvent(DWORD);
VOID  vmmUnhookNMIEvent(DWORD);
DWORD vmmCallRestrictedEvent(DWORD, DWORD, DWORD, DWORD, DWORD, DWORD);
DWORD vmmCacelRestrictedEvent(DWORD);
DWORD vmmRegisterPEFProvider(DWORD, DWORD);
DWORD vmmGetNMIHandlerAddr(VOID);
VOID  vmmSetNMIHandlerAddr(DWORD);
DWORD vmmGetSystemInitState(VOID);
DWORD vmmRegisterWin32Services(DWORD, DWORD);
DWORD vmmContextCreate(VOID);
DWORD vmmContextDestroy(DWORD);
DWORD vmmContextSwitch(DWORD);
DWORD vmmGetCurrentContext(VOID);
DWORD vmmPageAttach(DWORD, DWORD, DWORD);
DWORD vmmPageQuery(DWORD, DWORD, DWORD);
DWORD vmmGetRegistryKey(DWORD, DWORD, DWORD, DWORD);
DWORD vmmRegCloseKey(DWORD);
DWORD vmmRegCreateDynKey(DWORD, DWORD, DWORD, DWORD, DWORD, DWORD);
DWORD vmmRegCreateKey(DWORD, DWORD, DWORD);
DWORD vmmRegDeleteKey(DWORD, DWORD);
DWORD vmmRegDeleteValue(DWORD, DWORD);
DWORD vmmRegEnumKey(DWORD, DWORD, DWORD, DWORD);
DWORD vmmRegEnumValue(DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD);
DWORD vmmRegFlushKey(DWORD);
DWORD vmmRegLoadKey(DWORD, DWORD, DWORD);
DWORD vmmRegOpenKey(DWORD, DWORD, DWORD);
DWORD vmmRegQueryInfoKey(DWORD, DWORD, DWORD, DWORD, DWORD, DWORD,
                         DWORD, DWORD, DWORD, DWORD, DWORD, DWORD);
DWORD vmmRegQueryMultipleValues(DWORD, DWORD, DWORD, DWORD, DWORD);
DWORD vmmRegQueryValue(DWORD, DWORD, DWORD, DWORD);
DWORD vmmRegQueryValueEx(DWORD, DWORD, DWORD, DWORD, DWORD, DWORD);
DWORD vmmRegRemapPreDefKey(DWORD, DWORD);
DWORD vmmRegSaveKey(DWORD, DWORD, DWORD, DWORD, DWORD);
DWORD vmmRegSetValue(DWORD, DWORD, DWORD, DWORD, DWORD);
DWORD vmmRegSetValueEx(DWORD, DWORD, DWORD, DWORD, DWORD, DWORD);
VOID  vmmAdjustThreadExecPriority(DWORD, DWORD);
VOID  vmmCallWhenTaskSwitched(DWORD);
VOID  vmmCallWhenThreadSwitched(DWORD);
DWORD vmmCancelCallWhenTaskSwitched(DWORD);
DWORD vmmCancelCallWhenThreadSwitched(DWORD);
DWORD vmmGetLastUdatedThreadExecTime(DWORD);
DWORD vmmGetThreadExecTime(DWORD);
DWORD vmmGetThreadTerminationStatus(DWORD);
DWORD vmmGetCurThreadHandle(VOID);
DWORD vmmGetInitialThreadHandle(DWORD);
DWORD vmmGetNextThreadHandle(VOID);
DWORD vmmGetSysThreadHandle(VOID);
VOID  vmmGetThreadWin32Pri(DWORD, DWORD *, DWORD *, DWORD *, DWORD *);
DWORD vmmGetVMHandleForThread(DWORD);
DWORD vmmAllocateThreadDataSlot(VOID);
VOID  vmmFreeThreadDataSlot(DWORD);
//
// Debug services.
//
VOID  dbgBreakPoint(VOID);

//----------------------------------------------------------------------------
//
// VMM API inline functions.
//
//----------------------------------------------------------------------------

#define CALL_VXD(v,s)       MK_VDDL(DW v, DW s)
#define MK_VDDL(serv, vd)   \
            "int    20h"    \
            #vd             \
            #serv

#define CALL_VMM(s)         MK_VMDL(DD s)
#define MK_VMDL(vs)         \
            "int    20h"    \
            #vs

#pragma aux vmmAdjustExecPriority =                 \
            CALL_VMM(Adjust_Exec_Priority)          \
            parm [EAX] [EBX];

#pragma aux vmmAdjustExecTime =                     \
            CALL_VMM(Adjust_Execution_Time)         \
            parm [EAX] [EBX];

#pragma aux vmmAllocateGDTSelector =                \
            CALL_VMM(_Allocate_GDT_Selector)        \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmAllocateLDTSelector =                \
            CALL_VMM(_Allocate_LDT_Selector)        \
            parm caller []                          \
            value [EAX];

#pragma aux vmmBeginCriticalSection =               \
            CALL_VMM(Begin_Critical_Section)        \
            parm [ECX];

#pragma aux vmmBeginNestExecution =                 \
            CALL_VMM(Begin_Nest_Exec);

#pragma aux vmmBeginNestV86Exec =                   \
            CALL_VMM(Begin_Nest_V86_Exec);

#pragma aux vmmBeginReentrantExecution =            \
            CALL_VMM(Begin_Reentrant_Execution)     \
            value [ECX];

#pragma aux vmmBeginUseLockedPMStack =              \
            CALL_VMM(Begin_Use_Locked_PM_Stack);

#pragma aux vmmBuildDescriptorDWORDs =              \
            CALL_VMM(_BuildDescriptorDWORDs)        \
            parm caller []                          \
            value no8087 [EAX EDX]                  \
            modify [EAX EBX ECX EDX];

#pragma aux vmmBuildIntStackFrame =                 \
            CALL_VMM(Build_Int_Stack_Frame)         \
            parm [ECX] [EDX];

#pragma aux vmmCallGlobalEvent =                    \
            CALL_VMM(Call_Global_Event)             \
            parm [ESI] [EDX]                        \
            value [ESI];

#pragma aux vmmCallPriorityVMEvent =                \
            CALL_VMM(Call_Priority_VM_Event)        \
            parm [EAX] [EBX] [ECX] [EDX] [ESI] [EDI]\
            value [ESI];

#pragma aux vmmCallVMEvent =                        \
            CALL_VMM(Call_VM_Event)                 \
            parm [EBX] [ESI] [EDX]                  \
            value [ESI];

#pragma aux vmmCallWhenIdle =                       \
            CALL_VMM(Call_When_Idle)                \
            "sbb    EAX, EAX"                       \
            parm [ESI]                              \
            value [EAX];

#pragma aux vmmCallWhenNotCritical =                \
            CALL_VMM(Call_When_Not_Critical)        \
            parm [ESI] [EDX];


#pragma aux vmmCallWhenVMIntsEnabled =              \
            CALL_VMM(Call_When_VM_Ints_Enabled)     \
            parm [EDX] [ESI];

#pragma aux vmmCallWhenVMReturns =                  \
            CALL_VMM(Call_When_VM_Returns)          \
            parm [EAX] [EDX] [ESI];

#pragma aux vmmCancelGlobalEvent =                  \
            CALL_VMM(Cancel_Global_Event)           \
            parm [ESI];

#pragma aux vmmCancelPriorityVMEvent =              \
            CALL_VMM(Cancel_Priority_VM_Event)      \
            parm [ESI];

#pragma aux vmmCancelTimeOut =                      \
            CALL_VMM(Cancel_Time_Out)               \
            parm [ESI];

#pragma aux vmmCancelVMEvent =                      \
            CALL_VMM(Cancel_VM_Event)               \
            parm [EBX] [ESI];

#pragma aux vmmClaimCriticalSection =               \
            CALL_VMM(Claim_Critical_Section)        \
            parm [EAX] [ECX];

#pragma aux vmmCopyPageTable =                      \
            CALL_VMM(_CopyPageTable)                \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmCreateSemaphore =                    \
            CALL_VMM(Create_Semaphore)              \
            parm [ECX]                              \
            value [EAX];

#pragma aux vmmDestroySemaphore =                   \
            CALL_VMM(Destroy_Semaphore)             \
            parm [EAX];

#pragma aux vmmDisableGlobalTrapping =              \
            CALL_VMM(Disable_Global_Trapping)       \
            parm [EDX];

#pragma aux vmmDisableLocalTrapping =               \
            CALL_VMM(Disable_Local_Trapping)        \
            parm [EBX] [EDX];

#pragma aux vmmDisableVMInts =                      \
            CALL_VMM(Disable_VM_Ints);

#pragma aux vmmEnableGlobalTrapping =               \
            CALL_VMM(Enable_Global_Trapping)        \
            parm [EDX];

#pragma aux vmmEnableLocalTrapping =                \
            CALL_VMM(Enable_Local_Trapping)         \
            parm [EBX] [EDX];

#pragma aux vmmEnableVMInts =                       \
            CALL_VMM(Enable_VM_Ints);

#pragma aux vmmEndCritAndSuspend =                  \
            CALL_VMM(End_Crit_And_Suspend)          \
            "sbb    EAX, EAX"                       \
            value [EAX];

#pragma aux vmmEndCriticalSection =                 \
            CALL_VMM(End_Critical_Section);

#pragma aux vmmEndNestExecution =                   \
            CALL_VMM(End_Nest_Exec);

#pragma aux vmmEndReentrantExecution =              \
            CALL_VMM(End_Reentrant_Execution)       \
            parm [ECX];

#pragma aux vmmEndUseLockedPMStack =                \
            CALL_VMM(End_Use_Locked_PM_Stack);

#pragma aux vmmExecInt =                            \
            CALL_VMM(Exec_Int)                      \
            parm [EAX];

#pragma aux vmmExecVxDInt =                         \
            CALL_VMM(Exec_VxD_Int)                  \
            parm routine [];

#pragma aux vmmFatalErrorHandler =                  \
            CALL_VMM(Fatal_Error_Handler)           \
            parm [ESI] [EAX];

#pragma aux vmmFreeGDTSelector =                    \
            CALL_VMM(_Free_GDT_Selector)            \
            parm caller []                          \
            modify [EAX EBX ECX EDX];

#pragma aux vmmFreeLDTSelector =                    \
            CALL_VMM(_Free_LDT_Selector)            \
            parm caller []                          \
            modify [EAX EBX ECX EDX];

#pragma aux vmmGetAppFlatDSAlias =                  \
            CALL_VMM(_GetAppFlatDSAlias)            \
            parm caller []                          \
            modify [EAX EBX ECX EDX];

#pragma aux vmmGetConfigDirectory =                 \
            CALL_VMM(Get_Config_Directory)          \
            value [EDX];

#pragma aux vmmGetCritSectionStatus =               \
            CALL_VMM(Get_Crit_Section_Status)       \
            value [ECX];

#pragma aux vmmGetCritStatusNoBlock =               \
            CALL_VMM(Get_Crit_Status_No_Block)      \
            value [ECX];

#pragma aux vmmGetCurVMHandle =                     \
            CALL_VMM(Get_Cur_VM_Handle)             \
            value [EBX];

#pragma aux vmmGetDescriptor =                      \
            CALL_VMM(_GetDescriptor)                \
            parm caller []                          \
            value no8087 [EAX EDX]                  \
            modify [EAX EBX ECX EDX];

#pragma aux vmmGetEnvironmentString =               \
            CALL_VMM(Get_Environment_String)        \
            parm [ESI]                              \
            value [EDX];

#pragma aux vmmGetExecPath =                        \
            CALL_VMM(Get_Exec_Path)                 \
            value [EDX];

#pragma aux vmmGetFaultHookAddrs =                  \
            "mov    EAX, [ESP]"                     \
            CALL_VMM(Get_Fault_Hook_Addrs)          \
            "mov    EBX, [ESP + 4]"                 \
            "mov    [EBX], EDI"                     \
            "mov    [EBX + 4], EDX"                 \
            "mov    [EBX + 8], ESI"                 \
            parm caller [];

#pragma aux vmmGetFreePageCount =                   \
            CALL_VMM(_GetFreePageCount)             \
            parm caller []                          \
            value no8087 [EAX EDX]                  \
            modify [EAX EBX ECX EDX];

#pragma aux vmmGetLastUpdatedSystemTime =           \
            CALL_VMM(Get_Last_Updated_System_Time)  \
            value [EAX];

#pragma aux vmmGetLastUpdatedVMExecTime =           \
            CALL_VMM(Get_Last_Updated_VM_Exec_Time) \
            value [EAX];

#pragma aux vmmGetMachineInfo =                     \
            CALL_VMM(Get_Machine_Info)              \
            "mov    EDI, [ESP]"                     \
            "mov    [EDI], EAX"                     \
            "mov    [EDI + 4], EBX"                 \
            "mov    [EDI + 8], ECX"                 \
            "mov    [EDI + 12], EDX"                \
            parm []                                 \
            modify [EAX EBX ECX EDX EDI];

#pragma aux vmmGetNextProfileString =               \
            CALL_VMM(Get_Next_Profile_String)       \
            "jnc    gnpsFound"                      \
            "xor    EDX, EDX"                       \
            "gnpsFound:"                            \
            parm [EDX] [EDI]                        \
            value [EDX];

#pragma aux vmmGetNulPageHandle =                   \
            CALL_VMM(_GetNulPageHandle)             \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmGetProfileBoolean =                  \
            CALL_VMM(Get_Profile_Boolean)           \
            parm [EAX] [ESI] [EDI]                  \
            value [EAX];

#pragma aux vmmGetProfileDecimalInt =               \
            CALL_VMM(Get_Profile_Decimal_Int)       \
            parm [EAX] [ESI] [EDI]                  \
            value [EAX];

#pragma aux vmmGetProfileHexInt =                   \
            CALL_VMM(Get_Profile_Hex_Int)           \
            parm [EAX] [ESI] [EDI]                  \
            value [EAX];

#pragma aux vmmGetProfileString =                   \
            CALL_VMM(Get_Profile_String)            \
            parm [EDX] [ESI] [EDI]                  \
            value [EDX];

#pragma aux vmmGetPSPSegment =                      \
            CALL_VMM(Get_PSP_Segment)               \
            value [EAX];

#pragma aux vmmGetSysPageCount =                    \
            CALL_VMM(_GetSysPageCount)              \
            parm caller []                          \
            modify [EAX EBX ECX EDX];

#pragma aux vmmGetSystemTime =                      \
            CALL_VMM(Get_System_Time)               \
            value [EAX];

#pragma aux vmmGetSysVMHandle =                     \
            CALL_VMM(Get_Sys_VM_Handle)             \
            value [EBX];

#pragma aux vmmGetVMExecTime =                      \
            CALL_VMM(Get_VM_Exec_Time)              \
            value [EAX];

#pragma aux vmmGetVMMReenterCount =                 \
            CALL_VMM(Get_VMM_Reenter_Count)         \
            value [ECX];

#pragma aux vmmGetVMMVersion =                      \
            CALL_VMM(Get_VMM_Version)               \
            value [EAX];

#pragma aux vmmGetVMPgCount =                       \
            CALL_VMM(_GetVMPgCount)                 \
            parm caller []                          \
            modify [EAX EBX ECX EDX];

#pragma aux vmmHeapAllocate =                       \
            CALL_VMM(_HeapAllocate)                 \
            parm caller []                          \
            modify [EAX EBX ECX EDX];

#pragma aux vmmHeapFree =                           \
            CALL_VMM(_HeapFree)                     \
            parm caller []                          \
            modify [EAX EBX ECX EDX];

#pragma aux vmmHeapGetSize =                        \
            CALL_VMM(_HeapGetSize)                  \
            parm caller []                          \
            modify [EAX EBX ECX EDX];

#pragma aux vmmHeapReAllocate =                     \
            CALL_VMM(_HeapReAllocate)               \
            parm caller []                          \
            modify [EAX EBX ECX EDX];

#pragma aux vmmHookDevicePMAPI =                    \
            CALL_VMM(Hook_Device_PM_API)            \
            "jnc    hdpaFound"                      \
            "xor    ESI, ESI"                       \
            "hdpaFound:"                            \
            parm [EAX] [ESI]                        \
            value [ESI];

#pragma aux vmmHookDeviceService =                  \
            CALL_VMM(Hook_Device_Service)           \
            "jnc    hdsFound"                       \
            "xor    ESI, ESI"                       \
            "hdsFound:"                             \
            parm [EAX] [ESI]                        \
            value [ESI];

#pragma aux vmmHookDeviceV86API =                   \
            CALL_VMM(Hook_Device_V86_API)           \
            "jnc    hdvaFound"                      \
            "xor    ESI, ESI"                       \
            "hdvaFound:"                            \
            parm [EAX] [ESI]                        \
            value [ESI];

#pragma aux vmmHookPMFault =                        \
            CALL_VMM(Hook_PM_Fault)                 \
            parm [EAX] [ESI]                        \
            value [ESI];

#pragma aux vmmHookV86Fault =                       \
            CALL_VMM(Hook_V86_Fault)                \
            parm [EAX] [ESI]                        \
            value [ESI];

#pragma aux vmmHookV86IntChain =                    \
            CALL_VMM(Hook_V86_Int_Chain)            \
            parm [EAX] [ESI];

#pragma aux vmmHookV86Page =                        \
            CALL_VMM(Hook_V86_Page)                 \
            parm [EAX] [ESI];

#pragma aux vmmHookVMMFault =                       \
            CALL_VMM(Hook_VMM_Fault)                \
            parm [EAX] [ESI]                        \
            value [ESI];

#pragma aux vmmInstallIOHandler =                   \
            CALL_VMM(Install_IO_Handler)            \
            parm [ESI] [EDX];

#pragma aux vmmInstallMultIOHandlers =              \
            CALL_VMM(Install_Mult_IO_Handlers)      \
            parm [EDI]                              \
            value [EDX];

#pragma aux vmmLinMapIntoV86 =                      \
            CALL_VMM(_LinMapIntoV86)                \
            parm caller []                          \
            modify [EAX EBX ECX EDX];

#pragma aux vmmLinPageLock =                        \
            CALL_VMM(_LinPageLock)                  \
            parm caller []                          \
            modify [EAX EBX ECX EDX];

#pragma aux vmmLinPageUnLock =                      \
            CALL_VMM(_LinPageUnLock)                \
            parm caller []                          \
            modify [EAX EBX ECX EDX];

#pragma aux vmmMapFlat =                            \
            "mov    AH, AL"                         \
            "mov    AL, BL"                         \
            CALL_VMM(Map_Flat)                      \
            parm [EAX] [EBX]                        \
            value [EAX];

#pragma aux vmmMapFreePhysReg =                     \
            CALL_VMM(_MapFreePhysReg)               \
            parm caller []                          \
            modify [EAX EBX ECX EDX];

#pragma aux vmmMapIntoV86 =                         \
            CALL_VMM(_MapIntoV86)                   \
            parm caller []                          \
            modify [EAX EBX ECX EDX];

#pragma aux vmmMapLinToVMAddr =                     \
            CALL_VMM(Map_Lin_To_VM_Addr)            \
            parm [EAX ECX]                          \
            value no8087 [ECX EDX];


#pragma aux vmmMapPhysToLinear =                    \
            CALL_VMM(_MapPhysToLinear)              \
            parm caller []                          \
            modify [EAX EBX ECX EDX];

#pragma aux vmmModifyPageBits =                     \
            CALL_VMM(_ModifyPageBits)               \
            parm caller []                          \
            modify [EAX EBX ECX EDX];

#pragma aux vmmNoFailResumeVM =                     \
            CALL_VMM(No_Fail_Resume_VM)             \
            parm [EBX];

#pragma aux vmmOpenFile =                           \
            CALL_VMM(OpenFile)                      \
            "jnc    ofFound"                        \
            "xor    EAX, EAX"                       \
            "ofFound:"                              \
            parm [EDX] [EDI]                        \
            value [EAX];

#pragma aux vmmOutDebugString =                     \
            "pushfd"                                \
            "pushad"                                \
            CALL_VMM(Out_Debug_String)              \
            "popad"                                 \
            "popfd"                                 \
            parm [ESI];

#pragma aux vmmOutDebugStringValue =                \
            "pushfd"                                \
            "pushad"                                \
            CALL_VMM(Out_Debug_String)              \
            "popad"                                 \
            "popfd"                                 \
            parm [ESI] [EAX];

#pragma aux vmmPageAllocate =                       \
            CALL_VMM(_PageAllocate)                 \
            parm caller []                          \
            value no8087 [EAX EDX]                  \
            modify [EAX EBX ECX EDX];

#pragma aux vmmPageCheckLinRange =                  \
            CALL_VMM(_PageCheckLinRange)            \
            parm caller []                          \
            modify [EAX EBX ECX EDX];

#pragma aux vmmPageDiscardPages =                   \
            CALL_VMM(_PageDiscardPages)             \
            parm caller []                          \
            modify [EAX EBX ECX EDX];

#pragma aux vmmPageFree =                           \
            CALL_VMM(_PageFree)                     \
            parm caller []                          \
            modify [EAX EBX ECX EDX];

#pragma aux vmmPageGetAllocInfo =                   \
            CALL_VMM(_PageGetAllocInfo)             \
            parm caller []                          \
            value no8087 [EAX EDX]                  \
            modify [EAX EBX ECX EDX];

#pragma aux vmmPageGetSizeAddr =                    \
            CALL_VMM(_PageGetSizeAddr)              \
            parm caller []                          \
            value no8087 [EAX EDX]                  \
            modify [EAX EBX ECX EDX];

#pragma aux vmmPageLock =                           \
            CALL_VMM(_PageLock)                     \
            parm caller []                          \
            modify [EAX EBX ECX EDX];

#pragma aux vmmPageReAllocate =                     \
            CALL_VMM(_PageReAllocate)               \
            parm caller []                          \
            value no8087 [EAX EDX]                  \
            modify [EAX EBX ECX EDX];

#pragma aux vmmPageResetHandlePAddr =               \
            CALL_VMM(_PageResetHandlePAddr)         \
            parm caller []                          \
            modify [EAX EBX ECX EDX];

#pragma aux vmmPageUnLock =                         \
            CALL_VMM(_PageUnLock)                   \
            parm caller []                          \
            modify [EAX EBX ECX EDX];

#pragma aux vmmPhysIntoV86 =                        \
            CALL_VMM(_PhysIntoV86)                  \
            parm caller []                          \
            modify [EAX EBX ECX EDX];

#pragma aux vmmReleaseCriticalSection =             \
            CALL_VMM(Release_Critical_Section)      \
            parm [ECX];

#pragma aux vmmRemoveExceptionHandler =             \
            CALL_VMM(Remove_Exception_Handler)      \
            "sbb    EAX, EAX"                       \
            parm [ESI]                              \
            value [EAX];

#pragma aux vmmRestoreClientState =                 \
            CALL_VMM(Restore_Client_State)          \
            parm [ESI];

#pragma aux vmmResumeExec =                         \
            CALL_VMM(Resume_Exec);

#pragma aux vmmResumeVM =                           \
            CALL_VMM(Resume_VM)                     \
            "sbb    EAX, EAX"                       \
            parm [EBX]                              \
            value [EAX];

#pragma aux vmmSaveClientState =                    \
            CALL_VMM(Save_Client_State)             \
            parm [EDI];

#pragma aux vmmScheduleGlobalEvent =                \
            CALL_VMM(Schedule_Global_Event)         \
            parm [ESI] [EDX]                        \
            value [ESI];

#pragma aux vmmScheduleVMEvent =                    \
            CALL_VMM(Schedule_VM_Event)             \
            parm [EBX] [ESI] [EDX]                  \
            value [ESI];

#pragma aux vmmSelectorMapFlat =                    \
            CALL_VMM(_SelectorMapFlat)              \
            parm caller []                          \
            modify [EAX EBX ECX EDX];

#pragma aux vmmSetDescriptor =                      \
            CALL_VMM(_SetDescriptor)                \
            parm caller []                          \
            modify [EAX EBX ECX EDX];

#pragma aux vmmSetFreePhysRegCalBk =                \
            CALL_VMM(_SetFreePhysRegCalBk)          \
            parm caller []                          \
            modify [EAX EBX ECX EDX];

#pragma aux vmmSetGlobalTimeOut =                   \
            CALL_VMM(Set_Global_Time_Out)           \
            parm [EAX] [EDX] [ESI]                  \
            value [ESI];

#pragma aux vmmSetResetV86Pageable =                \
            CALL_VMM(_SetResetV86Pageable)          \
            parm caller []                          \
            modify [EAX EBX ECX EDX];

#pragma aux vmmSetV86IntVector =                    \
            CALL_VMM(Set_V86_Int_Vector)            \
            parm [EAX] [CX] [EDX];
            
#pragma aux vmmSetVMTimeOut =                       \
            CALL_VMM(Set_VM_Time_Out)               \
            parm [EAX] [EBX] [EDX] [ESI]            \
            value [ESI];

#pragma aux vmmSignalSemaphore =                    \
            CALL_VMM(Signal_Semaphore)              \
            parm [EAX];

#pragma aux vmmSimulateFarCall =                    \
            CALL_VMM(Simulate_Far_Call)             \
            parm [ECX] [EDX];

#pragma aux vmmSimulateFarJmp =                     \
            CALL_VMM(Simulate_Far_Jmp)              \
            parm [ECX] [EDX];

#pragma aux vmmSimulateFarRet =                     \
            CALL_VMM(Simulate_Far_Ret);

#pragma aux vmmSimulateFarRetN =                    \
            CALL_VMM(Simulate_Far_Ret_N)            \
            parm [EAX];

#pragma aux vmmSimulateFarInt =                     \
            CALL_VMM(Simulate_Int)                  \
            parm [EAX];

#pragma aux vmmSimulateIret =                       \
            CALL_VMM(Simulate_Iret);

#pragma aux vmmSimulatePop =                        \
            CALL_VMM(Simulate_Pop)                  \
            value [EAX];

#pragma aux vmmSimulatePush =                       \
            CALL_VMM(Simulate_Push)                 \
            parm [EAX];

#pragma aux vmmTestReenter =                        \
            CALL_VMM(Test_Reenter);

#pragma aux vmmTestSysVMHandle =                    \
            CALL_VMM(Test_Sys_VM_Handle)            \
            "clc"                                   \
            "jz     tsvhYes"                        \
            "stc"                                   \
            "tsvhYes:"                              \
            "sbb    EAX, EAX"                       \
            parm [EBX]                              \
            value [EAX];

#pragma aux vmmUnhookInvalidPageFault =             \
            CALL_VMM(Unhook_Invalid_Page_Fault)     \
            "sbb    EAX, EAX"                       \
            parm [ESI]                              \
            value [EAX];

#pragma aux vmmUnhookV86IntChain =                  \
            CALL_VMM(Unhook_V86_Int_Chain)           \
            parm [EAX] [ESI];


#pragma aux vmmUnmapFreePhysReg =                   \
            CALL_VMM(_UnmapFreePhysReg)             \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmWaitSemaphore =                      \
            CALL_VMM(Wait_Semaphore)                \
            parm [EAX] [ECX];

#pragma aux vmmXchgFreePhysReg =                    \
            CALL_VMM(_XchgFreePhysReg)              \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

//----------------------------------------------------------------------------
//
//  END OF 3.10 SERVICE TABLE MUST NOT SHUFFLE SERVICES BEFORE THIS POINT
//  FOR COMPATIBILITY.
//
//----------------------------------------------------------------------------

#pragma aux vmmPageCommit =                         \
            CALL_VMM(_PageCommit)                   \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmPageCommitContig =                   \
            CALL_VMM(_PageCommitContig)             \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmPageCommitPhys =                     \
            CALL_VMM(_PageCommitPhys)               \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmPageDecommit =                       \
            CALL_VMM(_PageDecommit)                 \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmPageReserve =                        \
            CALL_VMM(_PageReserve)                  \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmAllocatePMCallBack =                 \
            CALL_VMM(Allocate_PM_Call_Back)         \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmAllocateV86CallBack =                \
            CALL_VMM(Allocate_V86_Call_Back)        \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmInstallV86BreakPoint =               \
            CALL_VMM(Install_V86_Break_Point)       \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmRemoveV86BreakPoint =                \
            CALL_VMM(Remove_V86_Break_Point)        \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmCancelThreadEvent =                  \
            CALL_VMM(Cancel_Thread_Event)           \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmScheduleThreadEvent =                \
            CALL_VMM(Schedule_Thread_Event)         \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmHookNMIEvent =                       \
            CALL_VMM(Hook_NMI_Event)                \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmUnhookNMIEvent =                     \
            CALL_VMM(Unhook_NMI_Event)              \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmCallRestrictedEvent =                \
            CALL_VMM(Call_Restricted_Event)         \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmCancelRestrictedEvent =              \
            CALL_VMM(Cancel_Restricted_Event)       \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmRegisterPEFProvider =                \
            CALL_VMM(Register_PEF_Provider)         \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmGetNMIHandlerAddr =                  \
            CALL_VMM(Get_NMI_Handler_Addr)          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmSetNMIHandlerAddr =                  \
            CALL_VMM(Set_NMI_Handler_Addr)          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmGetSystemInitState =                 \
            CALL_VMM(VMM_GetSystemInitState)        \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmRegisterWin32Services =              \
            CALL_VMM(_Register_Win32_Services)      \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmContextCreate =                      \
            CALL_VMM(_ContextCreate)                \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmContextDestroy =                     \
            CALL_VMM(_ContextDestroy)               \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmContextSwitch =                      \
            CALL_VMM(_ContextSwitch)                \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmGetCurrentContext =                  \
            CALL_VMM(_GetCurrentContext)            \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmPageAttach =                         \
            CALL_VMM(_PageAttach)                   \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmPageQuery =                          \
            CALL_VMM(_PageQuery)                    \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmGetRegistryKey =                     \
            CALL_VMM(_GetRegistryKey)               \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmRegCloseKey =                        \
            CALL_VMM(_RegCloseKey)                  \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmRegCreateDynKey =                    \
            CALL_VMM(_RegCreateDynKey)              \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmRegCreateKey =                       \
            CALL_VMM(_RegCreateKey)                 \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmRegDeleteKey =                       \
            CALL_VMM(_RegDeleteKey)                 \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmRegDeleteValue =                     \
            CALL_VMM(_RegDeleteValue)               \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmRegEnumKey =                         \
            CALL_VMM(_RegEnumKey)                   \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmRegEnumValue =                       \
            CALL_VMM(_RegEnumValue)                 \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmRegFlushKey =                        \
            CALL_VMM(_RegFlushKey)                  \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

//#pragma aux vmmRegLoadKey =                         \
//            CALL_VMM(Reg_Load_Key)                  \
//            value [EAX]                             \
//            modify [EAX EBX ECX EDX];

#pragma aux vmmRegOpenKey =                         \
            CALL_VMM(_RegOpenKey)                   \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmRegQueryInfoKey =                    \
            CALL_VMM(_RegQueryInfoKey)              \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmRegQueryMultipleValues =             \
            CALL_VMM(_RegQueryMultipleValues)       \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmRegQueryValue =                      \
            CALL_VMM(_RegQueryValue)                \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmRegQueryValueEx =                    \
            CALL_VMM(_RegQueryValueEx)              \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmRegRemapPreDefKey =                  \
            CALL_VMM(_RegRemapPreDefKey)            \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

//#pragma aux vmmRegSaveKey =                         \
//            CALL_VMM(Reg_Save_Key)                  \
//            value [EAX]                             \
//            modify [EAX EBX ECX EDX];

#pragma aux vmmRegSetValue =                        \
            CALL_VMM(_RegSetValue)                  \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmRegSetValueEx =                      \
            CALL_VMM(_RegSetValueEx)                \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmAdjustThreadExecPriority =           \
            CALL_VMM(Adjust_Thread_Exec_Priority)   \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmCallWhenTaskSwitched =               \
            CALL_VMM(Call_When_Task_Switched)       \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmCallWhenThreadSwitched =             \
            CALL_VMM(Call_When_Thread_Switched)     \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmCancelCallWhenTaskSwitched =         \
            CALL_VMM(Cancel_Call_When_Task_Switched)\
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmCancelCallWhenThreadSwitched =       \
            CALL_VMM(Cancel_Call_When_Thread_Switched)\
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmGetLastUpdatedThreadExecTime =       \
            CALL_VMM(_GetLastUpdatedThreadExecTime) \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmGetThreadExecTime =                  \
            CALL_VMM(_GetThreadExecTime)            \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmGetThreadTerminationStatus =         \
            CALL_VMM(_GetThreadTerminationStatus)   \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmGetCurThreadHandle =                 \
            CALL_VMM(Get_Cur_Thread_Handle)         \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmGetInitialThreadHandle =             \
            CALL_VMM(Get_Initial_Thread_Handle)     \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmGetNextThreadHandle =                \
            CALL_VMM(Get_Next_Thread_Handle)        \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmGetSysThreadHandle =                 \
            CALL_VMM(Get_Sys_Thread_Handle)         \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmGetThreadWin32Pri =                  \
            CALL_VMM(Get_Thread_Win32_Pri)          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

//#pragma aux vmmGetVMHandleForThread =               \
//            CALL_VMM(Get_VM_Handle_For_Thread)      \
//            value [EAX]                             \
//            modify [EAX EBX ECX EDX];

#pragma aux vmmAllocateThreadDataSlot =             \
            CALL_VMM(_AllocateThreadDataSlot)       \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

#pragma aux vmmFreeThreadDataSlot =                 \
            CALL_VMM(_FreeThreadDataSlot)           \
            parm caller []                          \
            value [EAX]                             \
            modify [EAX EBX ECX EDX];

//----------------------------------------------------------------------------
//
//  DEBUG macros.
//
//----------------------------------------------------------------------------

#pragma aux dbgBreakPoint =                         \
            "int 03h";

#endif // _VMM_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\old\VMM.INC ===
;****************************************************************************
;                                                                           *
; THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
; KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
; IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
; PURPOSE.                                                                  *
;                                                                           *
; Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
;                                                                           *
;****************************************************************************

ifndef _VMM_
_VMM_	EQU	1
FALSE	EQU	0
VMM_TRUE	EQU	(NOT FALSE)
DEBLEVELRETAIL	EQU	0
DEBLEVELNORMAL	EQU	1
DEBLEVELMAX	EQU	2
ifndef DEBLEVEL
ifdef DEBUG
DEBLEVEL	EQU	DEBLEVELNORMAL
else
DEBLEVEL	EQU	DEBLEVELRETAIL
endif
endif
ifndef WIN31COMPAT
WIN40SERVICES	EQU	1
endif
ifdef MASM6
ifndef NO_MASM6_OPTIONS



    option oldmacros
ifndef  NEWSTRUCTS
    option oldstructs
endif
    option noscoped
    option segment:flat
    option offset:flat
    option proc:private
endif
endif




IFDEF MASM6
BeginDoc MACRO
     ENDM
EndDoc MACRO
       ENDM

BeginMsg MACRO
     ENDM
EndMsg MACRO
       ENDM
ELSE
BeginDoc EQU <>
EndDoc EQU <>

BeginMsg EQU <>
EndMsg EQU <>
ENDIF

UNDEFINED_DEVICE_ID	EQU	00000H
VMM_DEVICE_ID	EQU	00001H
DEBUG_DEVICE_ID	EQU	00002H
VPICD_DEVICE_ID	EQU	00003H
VDMAD_DEVICE_ID	EQU	00004H
VTD_DEVICE_ID	EQU	00005H
V86MMGR_DEVICE_ID	EQU	00006H
PAGESWAP_DEVICE_ID	EQU	00007H
PARITY_DEVICE_ID	EQU	00008H
REBOOT_DEVICE_ID	EQU	00009H
VDD_DEVICE_ID	EQU	0000AH
VSD_DEVICE_ID	EQU	0000BH
VMD_DEVICE_ID	EQU	0000CH
VKD_DEVICE_ID	EQU	0000DH
VCD_DEVICE_ID	EQU	0000EH
VPD_DEVICE_ID	EQU	0000FH
BLOCKDEV_DEVICE_ID	EQU	00010H
VMCPD_DEVICE_ID	EQU	00011H
EBIOS_DEVICE_ID	EQU	00012H
BIOSXLAT_DEVICE_ID	EQU	00013H
VNETBIOS_DEVICE_ID	EQU	00014H
DOSMGR_DEVICE_ID	EQU	00015H
WINLOAD_DEVICE_ID	EQU	00016H
SHELL_DEVICE_ID	EQU	00017H
VMPOLL_DEVICE_ID	EQU	00018H
VPROD_DEVICE_ID	EQU	00019H
DOSNET_DEVICE_ID	EQU	0001AH
VFD_DEVICE_ID	EQU	0001BH
VDD2_DEVICE_ID	EQU	0001CH
WINDEBUG_DEVICE_ID	EQU	0001DH
TSRLOAD_DEVICE_ID	EQU	0001EH
BIOSHOOK_DEVICE_ID	EQU	0001FH
INT13_DEVICE_ID	EQU	00020H
PAGEFILE_DEVICE_ID	EQU	00021H
SCSI_DEVICE_ID	EQU	00022H
MCA_POS_DEVICE_ID	EQU	00023H
SCSIFD_DEVICE_ID	EQU	00024H
VPEND_DEVICE_ID	EQU	00025H
APM_DEVICE_ID	EQU	00026H
VPOWERD_DEVICE_ID	EQU	APM_DEVICE_ID
VXDLDR_DEVICE_ID	EQU	00027H
NDIS_DEVICE_ID	EQU	00028H
BIOS_EXT_DEVICE_ID	EQU	00029H
VWIN32_DEVICE_ID	EQU	0002AH
VCOMM_DEVICE_ID	EQU	0002BH
SPOOLER_DEVICE_ID	EQU	0002CH
WIN32S_DEVICE_ID	EQU	0002DH
DEBUGCMD_DEVICE_ID	EQU	0002EH
CONFIGMG_DEVICE_ID	EQU	00033H
DWCFGMG_DEVICE_ID	EQU	00034H
SCSIPORT_DEVICE_ID	EQU	00035H
VFBACKUP_DEVICE_ID	EQU	00036H
ENABLE_DEVICE_ID	EQU	00037H
VCOND_DEVICE_ID	EQU	00038H
ISAPNP_DEVICE_ID	EQU	0003CH
BIOS_DEVICE_ID	EQU	0003DH
IFSMgr_Device_ID	EQU	00040H
VCDFSD_DEVICE_ID	EQU	00041H
MRCI2_DEVICE_ID	EQU	00042H
PCI_DEVICE_ID	EQU	00043H
PELOADER_DEVICE_ID	EQU	00044H
EISA_DEVICE_ID	EQU	00045H
DRAGCLI_DEVICE_ID	EQU	00046H
DRAGSRV_DEVICE_ID	EQU	00047H
PERF_DEVICE_ID	EQU	00048H
AWREDIR_DEVICE_ID	EQU	00049H
ETEN_Device_ID	EQU	00060H
CHBIOS_Device_ID	EQU	00061H
VMSGD_Device_ID	EQU	00062H
VPPID_Device_ID	EQU	00063H
VIME_Device_ID	EQU	00064H
VHBIOSD_Device_ID	EQU	00065H
BASEID_FOR_NAMEBASEDVXD	EQU	0f000H
BASEID_FOR_NAMEBASEDVXD_MASK	EQU	0fffH
VMM_INIT_ORDER	EQU	000000000H
DEBUG_INIT_ORDER	EQU	000000000H
DEBUGCMD_INIT_ORDER	EQU	000000000H
PERF_INIT_ORDER	EQU	000900000H
APM_INIT_ORDER	EQU	001000000H
VPOWERD_INIT_ORDER	EQU	APM_INIT_ORDER
BIOSHOOK_INIT_ORDER	EQU	006000000H
VPROD_INIT_ORDER	EQU	008000000H
VPICD_INIT_ORDER	EQU	00C000000H
VTD_INIT_ORDER	EQU	014000000H
VXDLDR_INIT_ORDER	EQU	016000000H
ENUMERATOR_INIT_ORDER	EQU	016800000H
ISAPNP_INIT_ORDER	EQU	ENUMERATOR_INIT_ORDER
EISA_INIT_ORDER	EQU	ENUMERATOR_INIT_ORDER
PCI_INIT_ORDER	EQU	ENUMERATOR_INIT_ORDER
BIOS_INIT_ORDER	EQU	ENUMERATOR_INIT_ORDER+1
CONFIGMG_INIT_ORDER	EQU	ENUMERATOR_INIT_ORDER+0FFFFH
VCDFSD_INIT_ORDER	EQU	016F00000H
IOS_INIT_ORDER	EQU	017000000H
PAGEFILE_INIT_ORDER	EQU	018000000H
PAGESWAP_INIT_ORDER	EQU	01C000000H
PARITY_INIT_ORDER	EQU	020000000H
REBOOT_INIT_ORDER	EQU	024000000H
EBIOS_INIT_ORDER	EQU	026000000H
VDD_INIT_ORDER	EQU	028000000H
VSD_INIT_ORDER	EQU	02C000000H
VCD_INIT_ORDER	EQU	030000000H
COMMDRVR_INIT_ORDER	EQU	(VCD_INIT_ORDER-1)
PRTCL_INIT_ORDER	EQU	(COMMDRVR_INIT_ORDER-2)
MODEM_INIT_ORDER	EQU	(COMMDRVR_INIT_ORDER-3)
PORT_INIT_ORDER	EQU	(COMMDRVR_INIT_ORDER-4)
VMD_INIT_ORDER	EQU	034000000H
VKD_INIT_ORDER	EQU	038000000H
VPD_INIT_ORDER	EQU	03C000000H
BLOCKDEV_INIT_ORDER	EQU	040000000H
MCA_POS_INIT_ORDER	EQU	041000000H
SCSIFD_INIT_ORDER	EQU	041400000H
SCSIMASTER_INIT_ORDER	EQU	041800000H
INT13_INIT_ORDER	EQU	042000000H
VMCPD_INIT_ORDER	EQU	048000000H
BIOSXLAT_INIT_ORDER	EQU	050000000H
VNETBIOS_INIT_ORDER	EQU	054000000H
DOSMGR_INIT_ORDER	EQU	058000000H
DOSNET_INIT_ORDER	EQU	05C000000H
WINLOAD_INIT_ORDER	EQU	060000000H
VMPOLL_INIT_ORDER	EQU	064000000H
UNDEFINED_INIT_ORDER	EQU	080000000H
WIN32_INIT_ORDER	EQU	UNDEFINED_INIT_ORDER
VCOND_INIT_ORDER	EQU	UNDEFINED_INIT_ORDER
WINDEBUG_INIT_ORDER	EQU	081000000H
VDMAD_INIT_ORDER	EQU	090000000H
V86MMGR_INIT_ORDER	EQU	0A0000000H
IFSMgr_Init_Order	EQU	10000H+V86MMGR_Init_Order
FSD_Init_Order	EQU	00100H+IFSMgr_Init_Order
VFD_INIT_ORDER	EQU	50000H+IFSMgr_Init_Order
UNDEF_TOUCH_MEM_INIT_ORDER	EQU	0A8000000H
SHELL_INIT_ORDER	EQU	0B0000000H






IO_Delay    macro
jmp $+2
ENDM

VXD_FAILURE	EQU	0
VXD_SUCCESS	EQU	1

Pushad_Struc	STRUC
Pushad_EDI	DD	?
Pushad_ESI	DD	?
Pushad_EBP	DD	?
Pushad_ESP	DD	?
Pushad_EBX	DD	?
Pushad_EDX	DD	?
Pushad_ECX	DD	?
Pushad_EAX	DD	?
Pushad_Struc	ENDS
ifndef Not_VxD
??_CUR_CODE_SEG = 0

??_LCODE    =   1
??_ICODE    =   2
??_PCODE    =   3
??_SCODE    =   4
??_DBOCODE  =   5
??_16ICODE  =   6
??_RCODE    =   7
??_LOCKABLECODE =   8

?_LCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_LCODE>
?_ICODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_ICODE>
?_PCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_PCODE>
?_SCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_SCODE>
?_DBOCODE   equ <(??_CUR_CODE_SEG MOD 16) - ??_DBOCODE>
?_16ICODE   equ <(??_CUR_CODE_SEG MOD 16) - ??_16ICODE>
?_RCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_RCODE>
?_LOCKABLECODE  equ <(??_CUR_CODE_SEG MOD 16) - ??_LOCKABLECODE>

ifndef NO_SEGMENTS





IFDEF   MASM6
_FLAT   EQU FLAT
ELSE
_FLAT   EQU USE32
ENDIF


_LTEXT      SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_LTEXT      ENDS

_TEXT       SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_TEXT       ENDS


_PTEXT      SEGMENT DWORD PUBLIC _FLAT 'PCODE'
_PTEXT      ENDS



MakeCodeSeg MACRO seglist, classname, grpname, iseg

    IRP segname,<seglist>

IFNB    <classname>
    segname     SEGMENT DWORD PUBLIC _FLAT "&classname&CODE"
ELSE
    segname     SEGMENT DWORD PUBLIC _FLAT "&segname&CODE"
ENDIF

IFB <iseg>
VxD_&&segname&&_CODE_SEG MACRO
segname  SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_PCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

        ENDM
ELSE
VxD_&&segname&&_CODE_SEG MACRO
segname  SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + iseg
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

        ENDM
ENDIF

VxD_&&segname&&_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
segname ENDS
        ENDM

segname     ENDS

IFNDEF BLD_COFF
IFNB    <grpname>
    _&grpname GROUP segname
ELSE
    _&&segname GROUP segname
ENDIF
ENDIF

    ENDM

    ENDM

MakeCodeSeg <LOCKABLE_BEGIN, LOCKABLE, LOCKABLE_END>, \
    LOCKABLE, LOCKABLE, ??_LOCKABLECODE
MakeCodeSeg INT21
MakeCodeSeg SYSEXIT
MakeCodeSeg RARE
MakeCodeSeg W16
MakeCodeSeg W32
MakeCodeSeg VMCREATE
MakeCodeSeg VMDESTROY
MakeCodeSeg THCREATE
MakeCodeSeg THDESTROY
MakeCodeSeg VMSUSPEND
MakeCodeSeg VMRESUME
MakeCodeSeg PNP
MakeCodeSeg DOSVM











DefLockableCodeBegin MACRO name, private
VxD_LOCKABLE_BEGIN_CODE_SEG
IFB <private>
    PUBLIC  name
ENDIF
name    LABEL   NEAR
VxD_LOCKABLE_BEGIN_CODE_ENDS
ifndef WIN31COMPAT
if DEBLEVEL
VxD_LOCKED_DATA_SEG
    PUBLIC name&_Debug_Flags
name&_Debug_Flags DD DFS_TEST_BLOCK
VxD_LOCKED_DATA_ENDS
??_debug_flags equ <name&_Debug_Flags>
endif
endif
    ENDM









DefLockableCodeEnd MACRO name, private
VxD_LOCKABLE_END_CODE_SEG
IFB <private>
    PUBLIC  name
ENDIF
name    LABEL   NEAR
VxD_LOCKABLE_END_CODE_ENDS
    ENDM





CodeLockFlags MACRO name
ifndef WIN31COMPAT
if DEBLEVEL
    ifndef name&_Debug_Flags
    VxD_LOCKED_DATA_SEG
        extrn   name&_Debug_Flags:dword
    VxD_LOCKED_DATA_ENDS
    ??_debug_flags equ <name&_Debug_Flags>
    endif
endif
endif
    ENDM






MarkCodeLocked MACRO
ifndef WIN31COMPAT
if DEBLEVEL
ifdef ??_debug_flags
    pushfd
    and ??_debug_flags,NOT DFS_TEST_BLOCK
    popfd
endif
endif
endif
    ENDM






MarkCodeUnlocked MACRO
ifndef WIN31COMPAT
if DEBLEVEL
ifdef ??_debug_flags
    pushfd
    or  ??_debug_flags,DFS_TEST_BLOCK
    popfd
endif
endif
endif
    ENDM



_ITEXT      SEGMENT DWORD PUBLIC _FLAT 'ICODE'
_ITEXT      ENDS


_LDATA      SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_LDATA      ENDS

_DATA       SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_DATA       ENDS


_PDATA      SEGMENT DWORD PUBLIC _FLAT 'PDATA'
_PDATA      ENDS


_IDATA      SEGMENT DWORD PUBLIC _FLAT 'ICODE'
_IDATA      ENDS


_BSS        SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_BSS        ENDS

CONST       SEGMENT DWORD PUBLIC _FLAT 'LCODE'
CONST       ENDS

_TLS        SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_TLS        ENDS


_STEXT      SEGMENT DWORD PUBLIC _FLAT 'SCODE'
_STEXT      ENDS


_SDATA      SEGMENT DWORD PUBLIC _FLAT 'SCODE'
_SDATA      ENDS


_DBOSTART   SEGMENT DWORD PUBLIC _FLAT 'DBOCODE'
_DBOSTART   ENDS


_DBOCODE    SEGMENT DWORD PUBLIC _FLAT 'DBOCODE'
_DBOCODE    ENDS


_DBODATA    SEGMENT DWORD PUBLIC _FLAT 'DBOCODE'
_DBODATA    ENDS

if DEBLEVEL

_PATHSTART  SEGMENT DWORD PUBLIC  _FLAT 'LCODE'
_PATHSTART  ENDS


_PATHDATA   SEGMENT DWORD PUBLIC  _FLAT 'LCODE'
_PATHDATA   ENDS


_PATHEND    SEGMENT DWORD PUBLIC  _FLAT 'LCODE'
_PATHEND    ENDS
endif


_16ICODE    SEGMENT WORD USE16 PUBLIC '16ICODE'
_16ICODE    ENDS


_RCODE      SEGMENT WORD USE16 PUBLIC 'RCODE'
_RCODE      ENDS

IFNDEF BLD_COFF
_LGROUP   GROUP _LTEXT, _TEXT, _LDATA, _DATA, _BSS, CONST, _TLS
_IGROUP   GROUP _ITEXT, _IDATA
_SGROUP   GROUP _STEXT, _SDATA
_DBOGROUP GROUP _DBOSTART, _DBOCODE, _DBODATA
IF DEBLEVEL
_PGROUP	  GROUP _PATHSTART, _PATHDATA, _PATHEND
ENDIF
ENDIF

endif

    ASSUME CS:FLAT, DS:FLAT, ES:FLAT, SS:FLAT

OFFSET32 EQU <OFFSET FLAT:>


BeginDoc





































EndDoc

Begin_Service_Table MACRO Device_Name, Def_Segment

IFDEF   Device_Name&_Name_Based
 IFNDEF @@NextInternalID
    @@NextInternalID    = 0
 ENDIF
 @@NextInternalID = (@@NextInternalID + 1)
 Device_Name&_Internal_ID   = @@NextInternalID + BASEID_FOR_NAMEBASEDVXD
 DefineVxDName  Device_Name, %Device_Name&_Internal_ID
ENDIF

IFB <Def_Segment>
    BST2 Device_Name, VxD
ELSE
    BST2 Device_Name, Def_Segment
ENDIF
    ENDM

DefineVxDName   MACRO Device_Name, InternalID
 @@VxDName&InternalID EQU   <___&Device_Name&STable>
ENDM


BST2 MACRO Device_Name, Def_Segment

Num_&Device_Name&_Services = 0

IFDEF Create_&Device_Name&_Service_Table

Def_Segment&_LOCKED_DATA_SEG

Device_Name&_Service_Table LABEL DWORD

Device_Name&_Service MACRO Procedure, Local_Seg, Condition
LOCAL $$&Procedure

  IFNB <Condition>
  $$&&Procedure MACRO extern
    IFDEF &Condition
      IFNB <extern>
    EXTRN   Procedure:NEAR
      ELSE
    dd  OFFSET32 Procedure
      ENDIF
    ELSE
      IFB <extern>
      dd      0
      ENDIF
    ENDIF
    ENDM
  ENDIF

  IFDIFI <Procedure>, <RESERVED>
    PUBLIC _&&Procedure
     IF1
    _&&Procedure LABEL DWORD
     ENDIF
     IFDIFI <Local_Seg>, <LOCAL>
        IFNB <Local_Seg>
Local_Seg&&_SEG
       ELSE
Def_Segment&_CODE_SEG
        ENDIF
        IFNB <Condition>
    $$&&Procedure extern
       ELSE
    EXTRN   Procedure:NEAR
        ENDIF
        IFNB <Local_Seg>
Local_Seg&&_ENDS
        ELSE
Def_Segment&_CODE_ENDS
        ENDIF
     ENDIF
      IFNB <Condition>
    $$&&Procedure
      ELSE
    dd  OFFSET32 Procedure
      ENDIF

          IFDEF Device_Name&_Name_Based
        @@&&Procedure = (Device_Name&_Internal_ID SHL 16) + Num_&Device_Name&_Services
          ELSE
        @@&&Procedure = (Device_Name&_Device_ID SHL 16) + Num_&Device_Name&_Services
          ENDIF
  ELSE
    dd  0
  ENDIF
    Num_&Device_Name&_Services = Num_&Device_Name&_Services + 1
  IFNB <Condition>
    Purge $$&&Procedure
  ENDIF
    ENDM

ELSE



IFDEF   Device_Name&_Name_Based

Device_Name&_Service MACRO Procedure, Local_Seg, Condition


  IFDIFI <Procedure>, <RESERVED>
    @@&&Procedure = (Device_Name&_Internal_ID SHL 16) + Num_&Device_Name&_Services
  ENDIF
    Num_&Device_Name&_Services = Num_&Device_Name&_Services + 1

    ENDM
ELSE

Device_Name&_Service MACRO Procedure, Local_Seg, Condition

  IFDIFI <Procedure>, <RESERVED>
    @@&&Procedure = (Device_Name&_Device_ID SHL 16) + Num_&Device_Name&_Services
  ENDIF
    Num_&Device_Name&_Services = Num_&Device_Name&_Services + 1

    ENDM
ENDIF

ENDIF

    ENDM



End_Service_Table MACRO Device_Name, Def_Segment

    PURGE   Device_Name&_Service

IFDEF Create_&Device_Name&_Service_Table

IFB <Def_Segment>
VxD_LOCKED_DATA_ENDS
ELSE
Def_Segment&_LOCKED_DATA_ENDS
ENDIF

ENDIF

    ENDM

GetVxDServiceOrdinal    macro   reg,service
    mov reg,@@&service
    endm

GetVxDServiceAddress    macro   reg,service
    mov reg,OFFSET32 service
    endm


















Begin_Win32_Services MACRO VxDName
ifndef Create_Win32_Services
    Create_Win32_Services = 0
endif
    .errb <VxDName>, <VxD name missing>
    ??w32svcno = 0
if Create_Win32_Services
VxDName&_Win32_Services label dword
    dd  csvc&VxDName, 0
endif
    ??inw32svc = 1

    VxDName&_Win32_Service MACRO Name
        .erre ??inw32svc, <Missing Begin_Win32_Services>
    if Create_Win32_Services
        dd  OFFSET32 Name,cparm&&Name
    endif
        @32&&Name equ   ((VxDName&_Device_ID SHL 16) + ??w32svcno)
        ??w32svcno = ??w32svcno + 1
        ENDM
    ENDM










End_Win32_Services MACRO VxDName
    .errb <VxDName>, <VxD name misssing>
if Create_Win32_Services
    csvc&VxDName    equ ($ - VxDName&_Win32_Services)/8 - 1
endif
    ??inw32svc = 0
    PURGE VxDName&_Win32_Service
    ENDM











Declare_Win32_Service MACRO Name, cParms
ifndef Create_Win32_Services
    Create_Win32_Services = 0
endif
if Create_Win32_Services
    ?merge  <Name>,,,,<EQU>,<_>,<Name>,<@>,%(cParms*4 + 8)
    ?merge  <cparm>,<Name>,,,<EQU>,<cParms>
VxD_CODE_SEG
    ?merge  <EXTRN>,,,,,<_>,<Name>,<@>,%(cParms*4 + 8),<:NEAR>
VxD_CODE_ENDS
endif
    ENDM












Win32call MACRO Service, CallBack
ifndef Create_Win32_Services
    Create_Win32_Services = 0
endif
ife Create_Win32_Services
    mov eax,@32&Service
ifdef IS_16
    movzx   esp,sp
endif
    call    fword ptr [CallBack]
ifdef DEBUG
    int 3
endif
endif
    ENDM







Dword_Align MACRO Seg_Name
    LOCAL segn
IFDEF MASM6
    align 4
ELSE
IFNB <Seg_Name>
    segn equ Seg_Name
ELSE
IFE ?_LCODE
    segn equ <_LTEXT>
ELSE
IFE ?_ICODE
    segn equ <_ITEXT>
ELSE
IFE ?_PCODE
    segn equ <_PTEXT>
ELSE
IFE ?_SCODE
    segn equ <_STEXT>
ELSE
.err <Dword_Align not supported>
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
IF (($-OFFSET segn:0) MOD 4)
db 4 - (($-OFFSET segn:0) MOD 4) DUP (90h)
ENDIF
ENDIF
        ENDM


BeginDoc

















EndDoc

Fatal_Error MACRO Msg_Ptr, Exit_Flags
    pushad
IFB <Msg_Ptr>
    xor esi, esi
ELSE
    mov esi, Msg_Ptr
IFB <Exit_Flags>
    xor eax, eax
ELSE
    mov eax, Exit_Flags
ENDIF
ENDIF
    VMMCall Fatal_Error_Handler
    ENDM

EF_Hang_On_Exit     EQU     1h


cb_s	STRUC
CB_VM_Status	DD	?
CB_High_Linear	DD	?
CB_Client_Pointer	DD	?
CB_VMID	DD	?
CB_Signature	DD	?
cb_s	ENDS
VMCB_ID	EQU	62634D56H
VMSTAT_EXCLUSIVE_BIT	EQU	00H
VMSTAT_EXCLUSIVE	EQU	(1 SHL VMSTAT_EXCLUSIVE_BIT)
VMSTAT_BACKGROUND_BIT	EQU	01H
VMSTAT_BACKGROUND	EQU	(1 SHL VMSTAT_BACKGROUND_BIT)
VMSTAT_CREATING_BIT	EQU	02H
VMSTAT_CREATING	EQU	(1 SHL VMSTAT_CREATING_BIT)
VMSTAT_SUSPENDED_BIT	EQU	03H
VMSTAT_SUSPENDED	EQU	(1 SHL VMSTAT_SUSPENDED_BIT)
VMSTAT_NOT_EXECUTEABLE_BIT	EQU	04H
VMSTAT_NOT_EXECUTEABLE	EQU	(1 SHL VMSTAT_NOT_EXECUTEABLE_BIT)
VMSTAT_PM_EXEC_BIT	EQU	05H
VMSTAT_PM_EXEC	EQU	(1 SHL VMSTAT_PM_EXEC_BIT)
VMSTAT_PM_APP_BIT	EQU	06H
VMSTAT_PM_APP	EQU	(1 SHL VMSTAT_PM_APP_BIT)
VMSTAT_PM_USE32_BIT	EQU	07H
VMSTAT_PM_USE32	EQU	(1 SHL VMSTAT_PM_USE32_BIT)
VMSTAT_VXD_EXEC_BIT	EQU	08H
VMSTAT_VXD_EXEC	EQU	(1 SHL VMSTAT_VXD_EXEC_BIT)
VMSTAT_HIGH_PRI_BACK_BIT	EQU	09H
VMSTAT_HIGH_PRI_BACK	EQU	(1 SHL VMSTAT_HIGH_PRI_BACK_BIT)
VMSTAT_BLOCKED_BIT	EQU	0AH
VMSTAT_BLOCKED	EQU	(1 SHL VMSTAT_BLOCKED_BIT)
VMSTAT_AWAKENING_BIT	EQU	0BH
VMSTAT_AWAKENING	EQU	(1 SHL VMSTAT_AWAKENING_BIT)
VMSTAT_PAGEABLEV86BIT	EQU	0CH
VMSTAT_PAGEABLEV86_BIT	EQU	VMSTAT_PAGEABLEV86BIT
VMSTAT_PAGEABLEV86	EQU	(1 SHL VMSTAT_PAGEABLEV86BIT)
VMSTAT_V86INTSLOCKEDBIT	EQU	0DH
VMSTAT_V86INTSLOCKED_BIT	EQU	VMSTAT_V86INTSLOCKEDBIT
VMSTAT_V86INTSLOCKED	EQU	(1 SHL VMSTAT_V86INTSLOCKEDBIT)
VMSTAT_IDLE_TIMEOUT_BIT	EQU	0EH
VMSTAT_IDLE_TIMEOUT	EQU	(1 SHL VMSTAT_IDLE_TIMEOUT_BIT)
VMSTAT_IDLE_BIT	EQU	0FH
VMSTAT_IDLE	EQU	(1 SHL VMSTAT_IDLE_BIT)
VMSTAT_CLOSING_BIT	EQU	10H
VMSTAT_CLOSING	EQU	(1 SHL VMSTAT_CLOSING_BIT)
VMSTAT_TS_SUSPENDED_BIT	EQU	11H
VMSTAT_TS_SUSPENDED	EQU	(1 SHL VMSTAT_TS_SUSPENDED_BIT)
VMSTAT_TS_MAXPRI_BIT	EQU	12H
VMSTAT_TS_MAXPRI	EQU	(1 SHL VMSTAT_TS_MAXPRI_BIT)
VMSTAT_USE32_MASK	EQU	(VMSTAT_PM_USE32 OR VMSTAT_VXD_EXEC)

tcb_s	STRUC
TCB_Flags	DD	?
TCB_Reserved1	DD	?
TCB_Reserved2	DD	?
TCB_Signature	DD	?
TCB_ClientPtr	DD	?
TCB_VMHandle	DD	?
TCB_ThreadId	DW	?
TCB_PMLockOrigSS	DW	?
TCB_PMLockOrigESP	DD	?
TCB_PMLockOrigEIP	DD	?
TCB_PMLockStackCount	DD	?
TCB_PMLockOrigCS	DW	?
TCB_PMPSPSelector	DW	?
TCB_ThreadType	DD	?
TCB_pad1	DW	?
TCB_pad2	DB	?
TCB_extErrLocus	DB	?
TCB_extErr	DW	?
TCB_extErrAction	DB	?
TCB_extErrClass	DB	?
TCB_extErrPtr	DD	?
tcb_s	ENDS
SCHED_OBJ_ID_THREAD	EQU	42434854H
THFLAG_SUSPENDED_BIT	EQU	03H
THFLAG_SUSPENDED	EQU	(1 SHL THFLAG_SUSPENDED_BIT)
THFLAG_NOT_EXECUTEABLE_BIT	EQU	04H
THFLAG_NOT_EXECUTEABLE	EQU	(1 SHL THFLAG_NOT_EXECUTEABLE_BIT)
THFLAG_THREAD_CREATION_BIT	EQU	08H
THFLAG_THREAD_CREATION	EQU	(1 SHL THFLAG_THREAD_CREATION_BIT)
THFLAG_THREAD_BLOCKED_BIT	EQU	0AH
THFLAG_THREAD_BLOCKED	EQU	(1 SHL THFLAG_THREAD_BLOCKED_BIT)
THFLAG_RING0_THREAD_BIT	EQU	1CH
THFLAG_RING0_THREAD	EQU	(1 SHL THFLAG_RING0_THREAD_BIT)
THFLAG_CHARSET_BITS	EQU	10H
THFLAG_CHARSET_MASK	EQU	(3 SHL THFLAG_CHARSET_BITS)
THFLAG_ANSI	EQU	(0 SHL THFLAG_CHARSET_BITS)
THFLAG_OEM	EQU	(1 SHL THFLAG_CHARSET_BITS)
THFLAG_UNICODE	EQU	(2 SHL THFLAG_CHARSET_BITS)
THFLAG_RESERVED	EQU	(3 SHL THFLAG_CHARSET_BITS)
THFLAG_EXTENDED_HANDLES_BIT	EQU	12H
THFLAG_EXTENDED_HANDLES	EQU	(1 SHL THFLAG_EXTENDED_HANDLES_BIT)
THFLAG_OPEN_AS_IMMOVABLE_FILE_BIT	EQU	13H
THFLAG_OPEN_AS_IMMOVABLE_FILE	EQU	(1 SHL THFLAG_OPEN_AS_IMMOVABLE_FILE_BIT)

pmcb_s	STRUC
PMCB_Flags	DD	?
PMCB_Parent	DD	?
pmcb_s	ENDS

VMFaultInfo	STRUC
VMFI_EIP	DD	?
VMFI_CS	DW	?
VMFI_Ints	DW	?
VMFaultInfo	ENDS
Begin_Service_Table VMM, VMM
VMM_Service  Get_VMM_Version, LOCAL
VMM_Service  Get_Cur_VM_Handle
VMM_Service  Test_Cur_VM_Handle
VMM_Service  Get_Sys_VM_Handle
VMM_Service  Test_Sys_VM_Handle
VMM_Service  Validate_VM_Handle
VMM_Service  Get_VMM_Reenter_Count
VMM_Service  Begin_Reentrant_Execution
VMM_Service  End_Reentrant_Execution
VMM_Service  Install_V86_Break_Point
VMM_Service  Remove_V86_Break_Point
VMM_Service  Allocate_V86_Call_Back
VMM_Service  Allocate_PM_Call_Back
VMM_Service  Call_When_VM_Returns
VMM_Service  Schedule_Global_Event
VMM_Service  Schedule_VM_Event
VMM_Service  Call_Global_Event
VMM_Service  Call_VM_Event
VMM_Service  Cancel_Global_Event
VMM_Service  Cancel_VM_Event
VMM_Service  Call_Priority_VM_Event
VMM_Service  Cancel_Priority_VM_Event
VMM_Service  Get_NMI_Handler_Addr
VMM_Service  Set_NMI_Handler_Addr
VMM_Service  Hook_NMI_Event
VMM_Service  Call_When_VM_Ints_Enabled
VMM_Service  Enable_VM_Ints
VMM_Service  Disable_VM_Ints
VMM_Service  Map_Flat
VMM_Service  Map_Lin_To_VM_Addr
VMM_Service  Adjust_Exec_Priority
VMM_Service  Begin_Critical_Section
VMM_Service  End_Critical_Section
VMM_Service  End_Crit_And_Suspend
VMM_Service  Claim_Critical_Section
VMM_Service  Release_Critical_Section
VMM_Service  Call_When_Not_Critical
VMM_Service  Create_Semaphore
VMM_Service  Destroy_Semaphore
VMM_Service  Wait_Semaphore
VMM_Service  Signal_Semaphore
VMM_Service  Get_Crit_Section_Status
VMM_Service  Call_When_Task_Switched
VMM_Service  Suspend_VM
VMM_Service  Resume_VM
VMM_Service  No_Fail_Resume_VM
VMM_Service  Nuke_VM
VMM_Service  Crash_Cur_VM
VMM_Service  Get_Execution_Focus
VMM_Service  Set_Execution_Focus
VMM_Service  Get_Time_Slice_Priority
VMM_Service  Set_Time_Slice_Priority
VMM_Service  Get_Time_Slice_Granularity
VMM_Service  Set_Time_Slice_Granularity
VMM_Service  Get_Time_Slice_Info
VMM_Service  Adjust_Execution_Time
VMM_Service  Release_Time_Slice
VMM_Service  Wake_Up_VM
VMM_Service  Call_When_Idle
VMM_Service  Get_Next_VM_Handle
VMM_Service  Set_Global_Time_Out
VMM_Service  Set_VM_Time_Out
VMM_Service  Cancel_Time_Out
VMM_Service  Get_System_Time
VMM_Service  Get_VM_Exec_Time
VMM_Service  Hook_V86_Int_Chain
VMM_Service  Get_V86_Int_Vector
VMM_Service  Set_V86_Int_Vector
VMM_Service  Get_PM_Int_Vector
VMM_Service  Set_PM_Int_Vector
VMM_Service  Simulate_Int
VMM_Service  Simulate_Iret
VMM_Service  Simulate_Far_Call
VMM_Service  Simulate_Far_Jmp
VMM_Service  Simulate_Far_Ret
VMM_Service  Simulate_Far_Ret_N
VMM_Service  Build_Int_Stack_Frame
VMM_Service  Simulate_Push
VMM_Service  Simulate_Pop
VMM_Service  _HeapAllocate
VMM_Service  _HeapReAllocate
VMM_Service  _HeapFree
VMM_Service  _HeapGetSize
HEAPZEROINIT	EQU	00000001H
HEAPZEROREINIT	EQU	00000002H
HEAPNOCOPY	EQU	00000004H
HEAPLOCKEDIFDP	EQU	00000100H
HEAPSWAP	EQU	00000200H
HEAPINIT	EQU	00000400H
HEAPCLEAN	EQU	00000800H
VMM_Service  _PageAllocate
VMM_Service  _PageReAllocate
VMM_Service  _PageFree
VMM_Service  _PageLock
VMM_Service  _PageUnLock
VMM_Service  _PageGetSizeAddr
VMM_Service  _PageGetAllocInfo
VMM_Service  _GetFreePageCount
VMM_Service  _GetSysPageCount
VMM_Service  _GetVMPgCount
VMM_Service  _MapIntoV86
VMM_Service  _PhysIntoV86
VMM_Service  _TestGlobalV86Mem
VMM_Service  _ModifyPageBits
VMM_Service  _CopyPageTable
VMM_Service  _LinMapIntoV86
VMM_Service  _LinPageLock
VMM_Service  _LinPageUnLock
VMM_Service  _SetResetV86Pageable
VMM_Service  _GetV86PageableArray
VMM_Service  _PageCheckLinRange
VMM_Service  _PageOutDirtyPages
VMM_Service  _PageDiscardPages
PAGEZEROINIT	EQU	00000001H
PAGEUSEALIGN	EQU	00000002H
PAGECONTIG	EQU	00000004H
PAGEFIXED	EQU	00000008H
PAGEDEBUGNULFAULT	EQU	00000010H
PAGEZEROREINIT	EQU	00000020H
PAGENOCOPY	EQU	00000040H
PAGELOCKED	EQU	00000080H
PAGELOCKEDIFDP	EQU	00000100H
PAGESETV86PAGEABLE	EQU	00000200H
PAGECLEARV86PAGEABLE	EQU	00000400H
PAGESETV86INTSLOCKED	EQU	00000800H
PAGECLEARV86INTSLOCKED	EQU	00001000H
PAGEMARKPAGEOUT	EQU	00002000H
PAGEPDPSETBASE	EQU	00004000H
PAGEPDPCLEARBASE	EQU	00008000H
PAGEDISCARD	EQU	00010000H
PAGEPDPQUERYDIRTY	EQU	00020000H
PAGEMAPFREEPHYSREG	EQU	00040000H
PAGENOMOVE	EQU	10000000H
PAGEMAPGLOBAL	EQU	40000000H
PAGEMARKDIRTY	EQU	80000000H
MAPV86_IGNOREWRAP	EQU	00000001H
VMM_Service  _GetNulPageHandle
VMM_Service  _GetFirstV86Page
VMM_Service  _MapPhysToLinear
VMM_Service  _GetAppFlatDSAlias
VMM_Service  _SelectorMapFlat
VMM_Service  _GetDemandPageInfo
VMM_Service  _GetSetPageOutCount
GSPOC_F_GET	EQU	00000001H
VMM_Service  Hook_V86_Page
VMM_Service  _Assign_Device_V86_Pages
VMM_Service  _DeAssign_Device_V86_Pages
VMM_Service  _Get_Device_V86_Pages_Array
VMM_Service  MMGR_SetNULPageAddr
VMM_Service  _Allocate_GDT_Selector
VMM_Service  _Free_GDT_Selector
VMM_Service  _Allocate_LDT_Selector
VMM_Service  _Free_LDT_Selector
VMM_Service  _BuildDescriptorDWORDs
VMM_Service  _GetDescriptor
VMM_Service  _SetDescriptor
BDDEXPLICITDPL	EQU	00000001H
ALDTSPECSEL	EQU	00000001H
VMM_Service  _MMGR_Toggle_HMA
MMGRHMAPHYSICAL	EQU	00000001H
MMGRHMAENABLE	EQU	00000002H
MMGRHMADISABLE	EQU	00000004H
MMGRHMAQUERY	EQU	00000008H
VMM_Service  Get_Fault_Hook_Addrs
VMM_Service  Hook_V86_Fault
VMM_Service  Hook_PM_Fault
VMM_Service  Hook_VMM_Fault
VMM_Service  Begin_Nest_V86_Exec
VMM_Service  Begin_Nest_Exec
VMM_Service  Exec_Int
VMM_Service  Resume_Exec
VMM_Service  End_Nest_Exec
VMM_Service  Allocate_PM_App_CB_Area, VMM_ICODE
VMM_Service  Get_Cur_PM_App_CB
VMM_Service  Set_V86_Exec_Mode
VMM_Service  Set_PM_Exec_Mode
VMM_Service  Begin_Use_Locked_PM_Stack
VMM_Service  End_Use_Locked_PM_Stack
VMM_Service  Save_Client_State
VMM_Service  Restore_Client_State
VMM_Service  Exec_VxD_Int
VMM_Service  Hook_Device_Service
VMM_Service  Hook_Device_V86_API
VMM_Service  Hook_Device_PM_API
VMM_Service  System_Control
VMM_Service  Simulate_IO
VMM_Service  Install_Mult_IO_Handlers
VMM_Service  Install_IO_Handler
VMM_Service  Enable_Global_Trapping
VMM_Service  Enable_Local_Trapping
VMM_Service  Disable_Global_Trapping
VMM_Service  Disable_Local_Trapping
VMM_Service  List_Create
VMM_Service  List_Destroy
VMM_Service  List_Allocate
VMM_Service  List_Attach
VMM_Service  List_Attach_Tail
VMM_Service  List_Insert
VMM_Service  List_Remove
VMM_Service  List_Deallocate
VMM_Service  List_Get_First
VMM_Service  List_Get_Next
VMM_Service  List_Remove_First
LF_ASYNC_BIT	EQU	0
LF_ASYNC	EQU	(1 SHL LF_ASYNC_BIT)
LF_USE_HEAP_BIT	EQU	1
LF_USE_HEAP	EQU	(1 SHL LF_USE_HEAP_BIT)
LF_ALLOC_ERROR_BIT	EQU	2
LF_ALLOC_ERROR	EQU	(1 SHL LF_ALLOC_ERROR_BIT)
LF_SWAP	EQU	(LF_USE_HEAP+(1 SHL 3))
VMM_Service  _AddInstanceItem
VMM_Service  _Allocate_Device_CB_Area
VMM_Service  _Allocate_Global_V86_Data_Area, VMM_ICODE
VMM_Service  _Allocate_Temp_V86_Data_Area, VMM_ICODE
VMM_Service  _Free_Temp_V86_Data_Area, VMM_ICODE
GVDAWordAlign	EQU	00000001H
GVDADWordAlign	EQU	00000002H
GVDAParaAlign	EQU	00000004H
GVDAPageAlign	EQU	00000008H
GVDAInstance	EQU	00000100H
GVDAZeroInit	EQU	00000200H
GVDAReclaim	EQU	00000400H
GVDAInquire	EQU	00000800H
GVDAHighSysCritOK	EQU	00001000H
GVDAOptInstance	EQU	00002000H
GVDAForceLow	EQU	00004000H
TVDANeedTilInitComplete	EQU	00000001H
VMM_Service  Get_Profile_Decimal_Int, VMM_ICODE
VMM_Service  Convert_Decimal_String, VMM_ICODE
VMM_Service  Get_Profile_Fixed_Point, VMM_ICODE
VMM_Service  Convert_Fixed_Point_String, VMM_ICODE
VMM_Service  Get_Profile_Hex_Int, VMM_ICODE
VMM_Service  Convert_Hex_String, VMM_ICODE
VMM_Service  Get_Profile_Boolean, VMM_ICODE
VMM_Service  Convert_Boolean_String, VMM_ICODE
VMM_Service  Get_Profile_String, VMM_ICODE
VMM_Service  Get_Next_Profile_String, VMM_ICODE
VMM_Service  Get_Environment_String, VMM_ICODE
VMM_Service  Get_Exec_Path, VMM_ICODE
VMM_Service  Get_Config_Directory, VMM_ICODE
VMM_Service  OpenFile, VMM_ICODE
VMM_OPENFILE_BUF_SIZE	EQU	260
VMM_Service  Get_PSP_Segment, VMM_ICODE
VMM_Service  GetDOSVectors, VMM_ICODE
VMM_Service  Get_Machine_Info
GMIF_80486_BIT	EQU	10H
GMIF_80486	EQU	(1 SHL GMIF_80486_BIT)
GMIF_PCXT_BIT	EQU	11H
GMIF_PCXT	EQU	(1 SHL GMIF_PCXT_BIT)
GMIF_MCA_BIT	EQU	12H
GMIF_MCA	EQU	(1 SHL GMIF_MCA_BIT)
GMIF_EISA_BIT	EQU	13H
GMIF_EISA	EQU	(1 SHL GMIF_EISA_BIT)
GMIF_CPUID_BIT	EQU	14H
GMIF_CPUID	EQU	(1 SHL GMIF_CPUID_BIT)
VMM_Service  GetSet_HMA_Info
VMM_Service  Set_System_Exit_Code
VMM_Service  Fatal_Error_Handler
VMM_Service  Fatal_Memory_Error
VMM_Service  Update_System_Clock
VMM_Service  Test_Debug_Installed
VMM_Service  Out_Debug_String
VMM_Service  Out_Debug_Chr
VMM_Service  In_Debug_Chr
VMM_Service  Debug_Convert_Hex_Binary
VMM_Service  Debug_Convert_Hex_Decimal
VMM_Service  Debug_Test_Valid_Handle
VMM_Service  Validate_Client_Ptr
VMM_Service  Test_Reenter
VMM_Service  Queue_Debug_String
VMM_Service  Log_Proc_Call
VMM_Service  Debug_Test_Cur_VM
VMM_Service  Get_PM_Int_Type
VMM_Service  Set_PM_Int_Type
VMM_Service  Get_Last_Updated_System_Time
VMM_Service  Get_Last_Updated_VM_Exec_Time
VMM_Service  Test_DBCS_Lead_Byte
.errnz  @@Test_DBCS_Lead_Byte - 100D1h

VMM_Service  _AddFreePhysPage, VMM_ICODE
VMM_Service  _PageResetHandlePAddr
VMM_Service  _SetLastV86Page, VMM_ICODE
VMM_Service  _GetLastV86Page
VMM_Service  _MapFreePhysReg
VMM_Service  _UnmapFreePhysReg
VMM_Service  _XchgFreePhysReg
VMM_Service  _SetFreePhysRegCalBk, VMM_ICODE
VMM_Service  Get_Next_Arena, VMM_ICODE
VMM_Service  Get_Name_Of_Ugly_TSR, VMM_ICODE
VMM_Service  Get_Debug_Options, VMM_ICODE
AFPP_SWAPOUT	EQU	0001H
PCP_CHANGEPAGER	EQU	1H
PCP_CHANGEPAGERDATA	EQU	2H
PCP_VIRGINONLY	EQU	4H
GNA_HIDOSLINKED	EQU	0002H
GNA_ISHIGHDOS	EQU	0004H
VMM_Service  Set_Physical_HMA_Alias, VMM_ICODE
VMM_Service  _GetGlblRng0V86IntBase, VMM_ICODE
VMM_Service  _Add_Global_V86_Data_Area, VMM_ICODE
VMM_Service  GetSetDetailedVMError
GSDVME_PRIVINST	EQU	00010001H
GSDVME_INVALINST	EQU	00010002H
GSDVME_INVALPGFLT	EQU	00010003H
GSDVME_INVALGPFLT	EQU	00010004H
GSDVME_INVALFLT	EQU	00010005H
GSDVME_USERNUKE	EQU	00010006H
GSDVME_DEVNUKE	EQU	00010007H
GSDVME_DEVNUKEHDWR	EQU	00010008H
GSDVME_NUKENOMSG	EQU	00010009H
GSDVME_OKNUKEMASK	EQU	80000000H
GSDVME_INSMEMV86	EQU	00020001H
GSDVME_INSV86SPACE	EQU	00020002H
GSDVME_INSMEMXMS	EQU	00020003H
GSDVME_INSMEMEMS	EQU	00020004H
GSDVME_INSMEMV86HI	EQU	00020005H
GSDVME_INSMEMVID	EQU	00020006H
GSDVME_INSMEMVM	EQU	00020007H
GSDVME_INSMEMDEV	EQU	00020008H
GSDVME_CRTNOMSG	EQU	00020009H
VMM_Service  Is_Debug_Chr
VMM_Service  Clear_Mono_Screen
VMM_Service  Out_Mono_Chr
VMM_Service  Out_Mono_String
VMM_Service  Set_Mono_Cur_Pos
VMM_Service  Get_Mono_Cur_Pos
VMM_Service  Get_Mono_Chr
VMM_Service  Locate_Byte_In_ROM, VMM_ICODE
VMM_Service  Hook_Invalid_Page_Fault
VMM_Service  Unhook_Invalid_Page_Fault
IPF_PGDIR	EQU	00000001H
IPF_V86PG	EQU	00000002H
IPF_V86PGH	EQU	00000004H
IPF_INVTYP	EQU	00000008H
IPF_PGERR	EQU	00000010H
IPF_REFLT	EQU	00000020H
IPF_VMM	EQU	00000040H
IPF_PM	EQU	00000080H
IPF_V86	EQU	00000100H
VMM_Service  Set_Delete_On_Exit_File
VMM_Service  Close_VM
CVF_CONTINUE_EXEC_BIT	EQU	0
CVF_CONTINUE_EXEC	EQU	(1 SHL CVF_CONTINUE_EXEC_BIT)
VMM_Service  Enable_Touch_1st_Meg
VMM_Service  Disable_Touch_1st_Meg
VMM_Service  Install_Exception_Handler
VMM_Service  Remove_Exception_Handler
VMM_Service  Get_Crit_Status_No_Block

.errnz   @@Get_Crit_Status_No_Block - 100F1h

ifdef WIN40SERVICES
VMM_Service  _GetLastUpdatedThreadExecTime
VMM_Service  _Trace_Out_Service
VMM_Service  _Debug_Out_Service
VMM_Service  _Debug_Flags_Service
endif
DFS_LOG_BIT	EQU	0
DFS_LOG	EQU	(1 SHL DFS_LOG_BIT)
DFS_PROFILE_BIT	EQU	1
DFS_PROFILE	EQU	(1 SHL DFS_PROFILE_BIT)
DFS_TEST_CLD_BIT	EQU	2
DFS_TEST_CLD	EQU	(1 SHL DFS_TEST_CLD_BIT)
DFS_NEVER_REENTER_BIT	EQU	3
DFS_NEVER_REENTER	EQU	(1 SHL DFS_NEVER_REENTER_BIT)
DFS_TEST_REENTER_BIT	EQU	4
DFS_TEST_REENTER	EQU	(1 SHL DFS_TEST_REENTER_BIT)
DFS_NOT_SWAPPING_BIT	EQU	5
DFS_NOT_SWAPPING	EQU	(1 SHL DFS_NOT_SWAPPING_BIT)
DFS_TEST_BLOCK_BIT	EQU	6
DFS_TEST_BLOCK	EQU	(1 SHL DFS_TEST_BLOCK_BIT)
DFS_RARE_SERVICES	EQU	0FFFFFF80H
DFS_EXIT_NOBLOCK	EQU	(DFS_RARE_SERVICES+0)
DFS_ENTER_NOBLOCK	EQU	(DFS_RARE_SERVICES+DFS_TEST_BLOCK)
DFS_TEST_NEST_EXEC	EQU	(DFS_RARE_SERVICES+1)
ifdef WIN40SERVICES
VMM_Service  VMMAddImportModuleName
VMM_Service  VMM_Add_DDB
VMM_Service  VMM_Remove_DDB
VMM_Service  Test_VM_Ints_Enabled
VMM_Service  _BlockOnID
VMM_Service  Schedule_Thread_Event
VMM_Service  Cancel_Thread_Event
VMM_Service  Set_Thread_Time_Out
VMM_Service  Set_Async_Time_Out
VMM_Service  _AllocateThreadDataSlot
VMM_Service  _FreeThreadDataSlot
MUTEX_MUST_COMPLETE	EQU	1
MUTEX_NO_CLEANUP_THREAD_STATE	EQU	2
VMM_Service  _CreateMutex
VMM_Service  _DestroyMutex
VMM_Service  _GetMutexOwner
VMM_Service  Call_When_Thread_Switched
VMM_Service  VMMCreateThread
VMM_Service  _GetThreadExecTime
VMM_Service  VMMTerminateThread
VMM_Service  Get_Cur_Thread_Handle
VMM_Service  Test_Cur_Thread_Handle
VMM_Service  Get_Sys_Thread_Handle
VMM_Service  Test_Sys_Thread_Handle
VMM_Service  Validate_Thread_Handle
VMM_Service  Get_Initial_Thread_Handle
VMM_Service  Test_Initial_Thread_Handle
VMM_Service  Debug_Test_Valid_Thread_Handle
VMM_Service  Debug_Test_Cur_Thread
VMM_Service  VMM_GetSystemInitState
VMM_Service  Cancel_Call_When_Thread_Switched
VMM_Service  Get_Next_Thread_Handle
VMM_Service  Adjust_Thread_Exec_Priority
VMM_Service  _Deallocate_Device_CB_Area
VMM_Service  Remove_IO_Handler
VMM_Service  Remove_Mult_IO_Handlers
VMM_Service  Unhook_V86_Int_Chain
VMM_Service  Unhook_V86_Fault
VMM_Service  Unhook_PM_Fault
VMM_Service  Unhook_VMM_Fault
VMM_Service  Unhook_Device_Service
VMM_Service  _PageReserve
VMM_Service  _PageCommit
VMM_Service  _PageDecommit
VMM_Service  _PagerRegister
VMM_Service  _PagerQuery
VMM_Service  _PagerDeregister
VMM_Service  _ContextCreate
VMM_Service  _ContextDestroy
VMM_Service  _PageAttach
VMM_Service  _PageFlush
VMM_Service  _SignalID
VMM_Service  _PageCommitPhys
VMM_Service  _Register_Win32_Services
VMM_Service  Cancel_Call_When_Not_Critical
VMM_Service  Cancel_Call_When_Idle
VMM_Service  Cancel_Call_When_Task_Switched
VMM_Service  _Debug_Printf_Service
VMM_Service  _EnterMutex
VMM_Service  _LeaveMutex
VMM_Service  Simulate_VM_IO
VMM_Service  Signal_Semaphore_No_Switch
VMM_Service  _ContextSwitch
VMM_Service  _PageModifyPermissions
VMM_Service  _PageQuery
VMM_Service  _EnterMustComplete
VMM_Service  _LeaveMustComplete
VMM_Service  _ResumeExecMustComplete
THREAD_TERM_STATUS_CRASH_PEND	EQU	1
THREAD_TERM_STATUS_NUKE_PEND	EQU	2
THREAD_TERM_STATUS_SUSPEND_PEND	EQU	4
VMM_Service  _GetThreadTerminationStatus
VMM_Service  _GetInstanceInfo
INSTINFO_NONE	EQU	0
INSTINFO_SOME	EQU	1
INSTINFO_ALL	EQU	2
VMM_Service  _ExecIntMustComplete
VMM_Service  _ExecVxDIntMustComplete
VMM_Service  Begin_V86_Serialization
VMM_Service  Unhook_V86_Page
VMM_Service  VMM_GetVxDLocationList
VMM_Service  VMM_GetDDBList
VMM_Service  Unhook_NMI_Event
VMM_Service  Get_Instanced_V86_Int_Vector
VMM_Service  Get_Set_Real_DOS_PSP
GSRDP_Set	EQU	0001H
VMM_Service  Call_Priority_Thread_Event
VMM_Service  Get_System_Time_Address
VMM_Service  Get_Crit_Status_Thread
VMM_Service  Get_DDB
VMM_Service  Directed_Sys_Control
VMM_Service  _RegOpenKey
VMM_Service  _RegCloseKey
VMM_Service  _RegCreateKey
VMM_Service  _RegDeleteKey
VMM_Service  _RegEnumKey
VMM_Service  _RegQueryValue
VMM_Service  _RegSetValue
VMM_Service  _RegDeleteValue
VMM_Service  _RegEnumValue
VMM_Service  _RegQueryValueEx
VMM_Service  _RegSetValueEx
ifndef REG_SZ
REG_SZ	EQU	0001H
REG_BINARY	EQU	0003H
endif
ifndef HKEY_LOCAL_MACHINE
HKEY_CLASSES_ROOT	EQU	80000000H
HKEY_CURRENT_USER	EQU	80000001H
HKEY_LOCAL_MACHINE	EQU	80000002H
HKEY_USERS	EQU	80000003H
HKEY_PERFORMANCE_DATA	EQU	80000004H
HKEY_CURRENT_CONFIG	EQU	80000005H
HKEY_DYN_DATA	EQU	80000006H
endif
VMM_Service  _CallRing3
VMM_Service  Exec_PM_Int
VMM_Service  _RegFlushKey
VMM_Service  _PageCommitContig
VMM_Service  _GetCurrentContext
VMM_Service  _LocalizeSprintf
VMM_Service  _LocalizeStackSprintf
VMM_Service  Call_Restricted_Event
VMM_Service  Cancel_Restricted_Event
VMM_Service  Register_PEF_Provider, VMM_ICODE
VMM_Service  _GetPhysPageInfo
VMM_Service  _RegQueryInfoKey
VMM_Service  MemArb_Reserve_Pages
PHYSINFO_NONE	EQU	0
PHYSINFO_SOME	EQU	1
PHYSINFO_ALL	EQU	2
VMM_Service  Time_Slice_Sys_VM_Idle
VMM_Service  Time_Slice_Sleep
VMM_Service  Boost_With_Decay
VMM_Service  Set_Inversion_Pri
VMM_Service  Reset_Inversion_Pri
VMM_Service  Release_Inversion_Pri
VMM_Service  Get_Thread_Win32_Pri
VMM_Service  Set_Thread_Win32_Pri
VMM_Service  Set_Thread_Static_Boost
VMM_Service  Set_VM_Static_Boost
VMM_Service  Release_Inversion_Pri_ID
VMM_Service  Attach_Thread_To_Group
VMM_Service  Detach_Thread_From_Group
VMM_Service  Set_Group_Static_Boost
VMM_Service  _GetRegistryPath, VMM_ICODE
VMM_Service  _GetRegistryKey
REGTYPE_ENUM	EQU	0
REGTYPE_CLASS	EQU	1
REGTYPE_VXD	EQU	2
REGKEY_OPEN	EQU	0
REGKEY_CREATE_IFNOTEXIST	EQU	1
ASSERT_RANGE_NULL_BAD	EQU	00000000H
ASSERT_RANGE_NULL_OK	EQU	00000001H
ASSERT_RANGE_NO_DEBUG	EQU	80000000H
ASSERT_RANGE_BITS	EQU	80000001H
VMM_Service  Cleanup_Thread_State
VMM_Service  _RegRemapPreDefKey
VMM_Service  End_V86_Serialization
VMM_Service  _Assert_Range
VMM_Service  _Sprintf
VMM_Service  _PageChangePager
VMM_Service  _RegCreateDynKey
VMM_Service  _RegQueryMultipleValues
VMM_Service  Boost_Thread_With_VM
BOOT_CLEAN	EQU	00000001H
BOOT_DOSCLEAN	EQU	00000002H
BOOT_NETCLEAN	EQU	00000004H
BOOT_INTERACTIVE	EQU	00000008H
VMM_Service  Get_Boot_Flags
VMM_Service  Set_Boot_Flags
VMM_Service  _lstrcpyn
VMM_Service  _lstrlen
VMM_Service  _lmemcpy
VMM_Service  _GetVxDName
VMM_Service  Force_Mutexes_Free
VMM_Service  Restore_Forced_Mutexes
VMM_Service  _AddReclaimableItem
VMM_Service  _SetReclaimableItem
VMM_Service  _EnumReclaimableItem
VMM_Service  Time_Slice_Wake_Sys_VM
VMM_Service  VMM_Replace_Global_Environment
VMM_Service  Begin_Non_Serial_Nest_V86_Exec
VMM_Service  Get_Nest_Exec_Status
VMM_Service  Open_Boot_Log
VMM_Service  Write_Boot_Log
VMM_Service  Close_Boot_Log
VMM_Service  EnableDisable_Boot_Log
VMM_Service  _Call_On_My_Stack
VMM_Service  Get_Inst_V86_Int_Vec_Base
VMM_Service  _lstrcmpi
VMM_Service  _strupr
VMM_Service  Log_Fault_Call_Out
VMM_Service  _AtEventTime
endif
End_Service_Table VMM, VMM
RS_RECLAIM	EQU	00000001H
RS_RESTORE	EQU	00000002H
RS_DOSARENA	EQU	00000004H

ReclaimStruc	STRUC
RS_Linear	DD	?
RS_Bytes	DD	?
RS_CallBack	DD	?
RS_RefData	DD	?
RS_HookTable	DD	?
RS_Flags	DD	?
ReclaimStruc	ENDS

frmtx	STRUC
frmtx_pfrmtxNext	DD	?
frmtx_hmutex	DD	?
frmtx_cEnterCount	DD	?
frmtx_pthcbOwner	DD	?
frmtx_htimeout	DD	?
frmtx	ENDS

vmmfrinfo	STRUC
vmmfrinfo_frmtxDOS	DB	SIZE frmtx DUP (?)
vmmfrinfo_frmtxV86	DB	SIZE frmtx DUP (?)
vmmfrinfo_frmtxOther	DB	SIZE frmtx DUP (?)
vmmfrinfo	ENDS

DemandInfoStruc	STRUC
DILin_Total_Count	DD	?
DIPhys_Count	DD	?
DIFree_Count	DD	?
DIUnlock_Count	DD	?
DILinear_Base_Addr	DD	?
DILin_Total_Free	DD	?
DIPage_Faults	DD	?
DIPage_Ins	DD	?
DIPage_Outs	DD	?
DIPage_Discards	DD	?
DIInstance_Faults	DD	?
DIPagingFileMax	DD	?
DIPagingFileInUse	DD	?
DICommit_Count	DD	?
DIReserved	DD	2 DUP (?)
DemandInfoStruc	ENDS

InstDataStruc	STRUC
InstLinkF	DD	0
InstLinkB	DD	0
InstLinAddr	DD	?
InstSize	DD	?
InstType	DD	?
InstDataStruc	ENDS
INDOS_FIELD	EQU	100H
ALWAYS_FIELD	EQU	200H
OPTIONAL_FIELD	EQU	400H

IPF_Data	STRUC
IPF_LinAddr	DD	?
IPF_MapPageNum	DD	?
IPF_PTEEntry	DD	?
IPF_FaultingVM	DD	?
IPF_Flags	DD	?
IPF_Data	ENDS

Exception_Handler_Struc	STRUC
EH_Reserved	DD	?
EH_Start_EIP	DD	?
EH_End_EIP	DD	?
EH_Handler	DD	?
Exception_Handler_Struc	ENDS
PR_PRIVATE	EQU	80000400H
PR_SHARED	EQU	80060000H
PR_SYSTEM	EQU	80080000H
PR_FIXED	EQU	00000008H
PR_4MEG	EQU	00000001H
PR_STATIC	EQU	00000010H
PD_ZEROINIT	EQU	00000001H
PD_NOINIT	EQU	00000002H
PD_FIXEDZERO	EQU	00000003H
PD_FIXED	EQU	00000004H
PC_FIXED	EQU	00000008H
PC_LOCKED	EQU	00000080H
PC_LOCKEDIFDP	EQU	00000100H
PC_WRITEABLE	EQU	00020000H
PC_USER	EQU	00040000H
PC_INCR	EQU	40000000H
PC_PRESENT	EQU	80000000H
PC_STATIC	EQU	20000000H
PC_DIRTY	EQU	08000000H
PCC_ZEROINIT	EQU	00000001H
PCC_NOLIN	EQU	10000000H
ifndef _WINNT_

_MEMORY_BASIC_INFORMATION	STRUC
mbi_BaseAddress	DD	?
mbi_AllocationBase	DD	?
mbi_AllocationProtect	DD	?
mbi_RegionSize	DD	?
mbi_State	DD	?
mbi_Protect	DD	?
mbi_Type	DD	?
_MEMORY_BASIC_INFORMATION	ENDS
PAGE_NOACCESS	EQU	01H
PAGE_READONLY	EQU	02H
PAGE_READWRITE	EQU	04H
MEM_COMMIT	EQU	1000H
MEM_RESERVE	EQU	2000H
MEM_FREE	EQU	10000H
MEM_PRIVATE	EQU	20000H
endif

pd_s	STRUC
pd_virginin	DD	?
pd_taintedin	DD	?
pd_cleanout	DD	?
pd_dirtyout	DD	?
pd_virginfree	DD	?
pd_taintedfree	DD	?
pd_dirty	DD	?
pd_type	DD	?
pd_s	ENDS
PD_SWAPPER	EQU	0
PD_PAGERONLY	EQU	1
PD_NESTEXEC	EQU	2
endif
PAGESHIFT	EQU	12
PAGESIZE	EQU	(1 SHL PAGESHIFT)
PAGEMASK	EQU	(PAGESIZE-1)
MAXSYSTEMLADDR	EQU	(0ffbfffffH)
MINSYSTEMLADDR	EQU	(0c0000000H)
MAXSHAREDLADDR	EQU	(0bfffffffH)
MINSHAREDLADDR	EQU	(80000000H)
MAXPRIVATELADDR	EQU	(7fffffffH)
MINPRIVATELADDR	EQU	(00400000H)
MAXDOSLADDR	EQU	(003fffffH)
MINDOSLADDR	EQU	(00000000H)
MAXSYSTEMPAGE	EQU	(MAXSYSTEMLADDR SHR PAGESHIFT)
MINSYSTEMPAGE	EQU	(MINSYSTEMLADDR SHR PAGESHIFT)
MAXSHAREDPAGE	EQU	(MAXSHAREDLADDR SHR PAGESHIFT)
MINSHAREDPAGE	EQU	(MINSHAREDLADDR SHR PAGESHIFT)
MAXPRIVATEPAGE	EQU	(MAXPRIVATELADDR SHR PAGESHIFT)
MINPRIVATEPAGE	EQU	(MINPRIVATELADDR SHR PAGESHIFT)
MAXDOSPAGE	EQU	(MAXDOSLADDR SHR PAGESHIFT)
MINDOSPAGE	EQU	(MINDOSLADDR SHR PAGESHIFT)
CBPRIVATE	EQU	(1+MAXPRIVATELADDR-MINPRIVATELADDR)
CBSHARED	EQU	(1+MAXSHAREDLADDR-MINSHAREDLADDR)
CBSYSTEM	EQU	(1+MAXSYSTEMLADDR-MINSYSTEMLADDR)
CBDOS	EQU	(1+MAXDOSLADDR-MINDOSLADDR)
CPGPRIVATE	EQU	(1+MAXPRIVATEPAGE-MINPRIVATEPAGE)
CPGSHARED	EQU	(1+MAXSHAREDPAGE-MINSHAREDPAGE)
CPGSYSTEM	EQU	(1+MAXSYSTEMPAGE-MINSYSTEMPAGE)
CPGDOS	EQU	(1+MAXDOSPAGE-MINDOSPAGE)
IFDEF DEBUG
DebFar  EQU NEAR PTR
ELSE
DebFar  EQU SHORT
ENDIF

ifndef Not_VxD
SYS_CRITICAL_INIT	EQU	0000H
DEVICE_INIT	EQU	0001H
INIT_COMPLETE	EQU	0002H
SYS_VM_INIT	EQU	0003H
SYS_VM_TERMINATE	EQU	0004H
SYSTEM_EXIT	EQU	0005H
SYS_CRITICAL_EXIT	EQU	0006H
CREATE_VM	EQU	0007H
VM_CRITICAL_INIT	EQU	0008H
VM_INIT	EQU	0009H
VM_TERMINATE	EQU	000AH
VM_NOT_EXECUTEABLE	EQU	000BH
DESTROY_VM	EQU	000CH
VNE_CRASHED_BIT	EQU	00H
VNE_CRASHED	EQU	(1 SHL VNE_CRASHED_BIT)
VNE_NUKED_BIT	EQU	01H
VNE_NUKED	EQU	(1 SHL VNE_NUKED_BIT)
VNE_CREATEFAIL_BIT	EQU	02H
VNE_CREATEFAIL	EQU	(1 SHL VNE_CREATEFAIL_BIT)
VNE_CRINITFAIL_BIT	EQU	03H
VNE_CRINITFAIL	EQU	(1 SHL VNE_CRINITFAIL_BIT)
VNE_INITFAIL_BIT	EQU	04H
VNE_INITFAIL	EQU	(1 SHL VNE_INITFAIL_BIT)
VNE_CLOSED_BIT	EQU	05H
VNE_CLOSED	EQU	(1 SHL VNE_CLOSED_BIT)
VM_SUSPEND	EQU	000DH
VM_RESUME	EQU	000EH
SET_DEVICE_FOCUS	EQU	000FH
BEGIN_MESSAGE_MODE	EQU	0010H
END_MESSAGE_MODE	EQU	0011H
REBOOT_PROCESSOR	EQU	0012H
QUERY_DESTROY	EQU	0013H
DEBUG_QUERY	EQU	0014H
BEGIN_PM_APP	EQU	0015H
BPA_32_BIT	EQU	01H
BPA_32_BIT_FLAG	EQU	1
END_PM_APP	EQU	0016H
DEVICE_REBOOT_NOTIFY	EQU	0017H
CRIT_REBOOT_NOTIFY	EQU	0018H
CLOSE_VM_NOTIFY	EQU	0019H
CVNF_CRIT_CLOSE_BIT	EQU	0
CVNF_CRIT_CLOSE	EQU	(1 SHL CVNF_CRIT_CLOSE_BIT)
POWER_EVENT	EQU	001AH
SYS_DYNAMIC_DEVICE_INIT	EQU	001BH
SYS_DYNAMIC_DEVICE_EXIT	EQU	001CH
CREATE_THREAD	EQU	001DH
THREAD_INIT	EQU	001EH
TERMINATE_THREAD	EQU	001FH
THREAD_Not_Executeable	EQU	0020H
DESTROY_THREAD	EQU	0021H
PNP_NEW_DEVNODE	EQU	0022H
W32_DEVICEIOCONTROL	EQU	0023H
DIOC_GETVERSION	EQU	0H
DIOC_OPEN	EQU	DIOC_GETVERSION
DIOC_CLOSEHANDLE	EQU	-1
SYS_VM_TERMINATE2	EQU	0024H
SYSTEM_EXIT2	EQU	0025H
SYS_CRITICAL_EXIT2	EQU	0026H
VM_TERMINATE2	EQU	0027H
VM_NOT_EXECUTEABLE2	EQU	0028H
DESTROY_VM2	EQU	0029H
VM_SUSPEND2	EQU	002AH
END_MESSAGE_MODE2	EQU	002BH
END_PM_APP2	EQU	002CH
DEVICE_REBOOT_NOTIFY2	EQU	002DH
CRIT_REBOOT_NOTIFY2	EQU	002EH
CLOSE_VM_NOTIFY2	EQU	002FH
GET_CONTENTION_HANDLER	EQU	0030H
KERNEL32_INITIALIZED	EQU	0031H
KERNEL32_SHUTDOWN	EQU	0032H
MAX_SYSTEM_CONTROL	EQU	0032H
BEGIN_RESERVED_PRIVATE_SYSTEM_CONTROL	EQU	70000000H
END_RESERVED_PRIVATE_SYSTEM_CONTROL	EQU	7FFFFFFFH
endif
SYSSTATE_PRESYSCRITINIT	EQU	00000000H
SYSSTATE_PREDEVICEINIT	EQU	10000000H
SYSSTATE_PREINITCOMPLETE	EQU	20000000H
SYSSTATE_VXDINITCOMPLETED	EQU	40000000H
SYSSTATE_KERNEL32INITED	EQU	50000000H
SYSSTATE_KERNEL32TERMINATED	EQU	0A0000000H
SYSSTATE_PRESYSVMTERMINATE	EQU	0B0000000H
SYSSTATE_PRESYSTEMEXIT	EQU	0E0000000H
SYSSTATE_PRESYSTEMEXIT2	EQU	0E4000000H
SYSSTATE_PRESYSCRITEXIT	EQU	0F0000000H
SYSSTATE_PRESYSCRITEXIT2	EQU	0F4000000H
SYSSTATE_POSTSYSCRITEXIT2	EQU	0FFF00000H
SYSSTATE_PREDEVICEREBOOT	EQU	0FFFF0000H
SYSSTATE_PRECRITREBOOT	EQU	0FFFFF000H
SYSSTATE_PREREBOOTCPU	EQU	0FFFFFF00H
BeginDoc











































































EndDoc












??_pf_Check equ 1
??_pf_ArgsUsed  equ 2
??_pf_Entered   equ 4
??_pf_Left  equ 8
??_pf_Returned  equ    16

??_pushed       =       0
??_align    =   0
??_ends     equ <>

BeginProc macro Name, P1, P2, P3, P4, P5, P6, P7, LastArg
    local   Profile_Data, prelabeldata, ??_hookvar
    ??_frame = 0
    ??_aframe = 0
    ??_initaframe = 0
    ??_numargs = 0
    ??_numlocals = 0
    ??_numlocalsymbols = 0
    ??_procflags = 0
    ??_esp = 0
    ??_pushed = 0
    ??_align = 0
    ??_hook = 0
    ??_hookarg = 0
    ??_service = 0
    ??_async_service = 0
IF DEBLEVEL GT DEBLEVELNORMAL
    ??_log = DFS_LOG
    ??_profile = DFS_PROFILE
    ??_test_cld = DFS_TEST_CLD
ELSE
    ??_log = 0
IFDEF DEBUG
IFDEF profileall
IF ?_ICODE
    ??_profile = DFS_PROFILE
ELSE
    ??_profile = 0
ENDIF
ELSE
    ??_profile = 0
ENDIF
ELSE
    ??_profile = 0
ENDIF
    ??_test_cld = 0
ENDIF
    ??_might_block = 0
    ??_test_reenter = 0
    ??_never_reenter = 0
    ??_not_swapping = 0
    ??_prolog_disabled = 0
    ??_public = 1
    ??_cleanoff = 0
    ??_ccall = 0
    ??_pcall = 0
    ??_scall = 0
    ??_w32svc = 0
    ??_fleave = FALSE

    ??_name equ <Name>

    .errnb ??_ends, <Cannot nest functions with named segments>
    .errnb <LastArg>, <Too many arguments to BeginProc>


    irp arg, <P1, P2, P3, P4, P5, P6, P7>
        if ??_hookarg
        ??_hookarg = 0
        ??_hookvar equ <arg>
        elseifdef ?&&arg&&_BeginProc
            ?&&arg&&_BeginProc
        elseifdef VxD_&&arg&&_CODE_SEG
        ??_ends textequ <VxD_&&arg&&_CODE_ENDS>
        VxD_&&arg&&_CODE_SEG
        else
        .err <Bad param "&arg" to BeginProc>
        endif
    endm


    ifndef Not_VxD
	ife ??_service
	    ifndef profileall
	      ??_profile = 0
	    endif
	    ifdef VMMSYS
		??_prolog_disabled = 1
	    endif
	else
	    ??_test_cld = DFS_TEST_CLD
	endif

	ife ?_16ICODE
	    ??_prolog_disabled = 1
	else
	ife ?_RCODE
	    ??_prolog_disabled = 1
	else
	    ife ?_PCODE
		??_might_block = DFS_TEST_BLOCK
	    endif
	    if ??_service
		ife ??_async_service
		    ??_test_reenter = DFS_TEST_REENTER
		endif
	    endif
    endif
    endif
    endif

    if ??_esp

	??_basereg equ <esp+??_pushed>
	??_initaframe = 4
    else

	??_basereg equ <ebp>
	??_initaframe = 8
    endif
    @Caller equ <dword ptr [??_basereg+??_initaframe-4]>

    ??_cleanoff = ??_pcall or ??_scall


    ??_dfs = ??_never_reenter + ??_test_reenter + ??_not_swapping + \
         ??_log + ??_profile + ??_test_cld + ??_might_block

    if ??_prolog_disabled
        ??_dfs = 0
    endif



    ifndef Not_VxD

	if ??_hook
	    if ??_align
	    Dword_Align
	    endif
	    prelabeldata:
	    ifndef ??_hookvar
	    .err <HOOK_PROC requires next arg to be name of dword location>
	    endif
	    jmp short Name
	    jmp [??_hookvar]
	    ifdef DEBUG
	    Profile_Data dd  0
	    endif
	    if ??_align
	    .errnz ($ - prelabeldata) mod 4
	    endif
	endif

	ifdef DEBUG
	    ?prolog_&Name label near
	    if (??_service OR ??_profile) AND (??_hook EQ 0)
	    jmp short Name
	    if ??_align
		Dword_Align
	    endif

	    IF ?_ICODE
	    ifdef profileall
	      ?ProfileHeader_BeginProc Profile_Data, %@filename
	    else
	      Profile_Data dd 0
	    endif
	    ELSE
	      Profile_Data dd 0
	    ENDIF

	    endif
	endif

	if ??_align
	    Dword_Align
	endif

    endif

    Name proc near



    ife ??_pcall or ??_ccall or ??_scall
        if ??_public
            public Name
        else
            ifdef DEBUG
                % ?merge @FileName,$,Name,:
                % ?merge public,,,,,@FileName,$,Name
            endif
        endif
    endif
    if ??_ccall
        if ??_public
            _&Name equ Name
	    ifdef Not_VxD
		 public C Name
	    else
                 public _&Name
	    endif
        endif
    endif
    if ??_pcall
        if ??_public
            ?toupper Name
            ?merge  public,,,,%?upper
        endif
    endif


    ifndef Not_VxD
	ifdef DEBUG
	    if ??_dfs EQ DFS_LOG
		VMMCall Log_Proc_Call
	    else
	    if ??_dfs EQ DFS_TEST_REENTER
		VMMCall Test_Reenter
	    else
	    if ??_dfs or ?_LOCKABLECODE eq 0
		ifdef WIN31COMPAT
		    if ??_dfs AND DFS_LOG
			VMMCall Log_Proc_Call
		    endif
		    if ??_dfs AND DFS_TEST_REENTER
			VMMCall Test_Reenter
		    endif
		else
		    ife ?_LOCKABLECODE
		    ifdef ??_debug_flags
			push    ??_debug_flags
			if ??_dfs
			pushfd
			or  dword ptr [esp+4],??_dfs
			popfd
			endif
			VMMCall _Debug_Flags_Service
		    elseif ??_dfs
			push    ??_dfs
			VMMCall _Debug_Flags_Service
		    endif
		    else
		    push    ??_dfs
		    VMMCall _Debug_Flags_Service
		    endif
		endif
	    else
	      ifdef profileall
		IncProfileCount
	      endif
	    endif
	    endif
	    endif
	endif
    endif



endm






?_BeginProc macro
endm

?PUBLIC_BeginProc macro
    ??_public = 1
endm

?LOCAL_BeginProc macro
    ??_public = 0
endm

?HIGH_FREQ_BeginProc macro
    ??_align = 1
endm

?HOOK_PROC_BeginProc macro
    ??_hook = 1
    ??_hookarg = 1
endm

?SERVICE_BeginProc macro
    ??_service = 1
    .erre ?_16ICODE, <SERVICEs must be in 32 bit code>
    .erre ?_RCODE, <SERVICEs must be in 32 bit code>
endm

?ASYNC_SERVICE_BeginProc macro
    ??_service = 1
    ??_async_service = 1
    .errnz ?_LCODE, <ASYNC_SERVICE's must be in LOCKED code>
endm

?NO_LOG_BeginProc macro
    ??_log = 0
endm

?NO_PROFILE_BeginProc macro
    ??_profile = 0
endm

?NO_TEST_CLD_BeginProc macro
    ??_test_cld = 0
endm

?TEST_BLOCK_BeginProc macro
    ??_might_block = DFS_TEST_BLOCK
endm

?TEST_REENTER_BeginProc macro
    ??_test_reenter = DFS_TEST_REENTER
endm

?NEVER_REENTER_BeginProc macro
    ??_never_reenter = DFS_NEVER_REENTER
endm

?NOT_SWAPPING_BeginProc macro
    ??_not_swapping = DFS_NOT_SWAPPING
endm

?NO_PROLOG_BeginProc macro
    ??_prolog_disabled = 1
endm

?ESP_BeginProc macro
    ??_esp = VMM_TRUE
    ifndef Not_VxD
	.erre ?_16ICODE, <Beginproc ESP attribute invalid in 16 bit seg.>
	.erre ?_RCODE, <Beginproc ESP attribute invalid in real-mode seg.>
    endif
endm

?CCALL_BeginProc macro
    ??_ccall = 1
endm

?PCALL_BeginProc macro
    ??_pcall = 1
endm

?SCALL_BeginProc macro
    ??_scall = 1
endm

?ICALL_BeginProc macro
    ??_scall = 1
endm

?W32SVC_BeginProc macro
    ??_scall = 1
    ??_w32svc = 1
endm

ifdef DEBUG
ifdef profileall
?ProfileHeader_BeginProc macro PL, filename
ifndef _&filename&__proc_list
  _&filename&__proc_list = 0
  PUBLIC _&filename&__proc_list
endif
    dd OFFSET32 _&filename&__proc_list
PL  dd 0
_&filename&__proc_list = PL
endm
endif

IncProfileCount macro
    if ??_service OR ??_profile
        inc dword ptr [??_name-4]
    else
        ifndef profileall
        .err <IncProfileCount can be used only in services.>
        endif
    endif
endm
else
IncProfileCount macro
endm
endif
















ArgVar  macro   name,length,used
    ??_numargs = ??_numargs + 1
    if ??_pcall
        ?mkarg  <name>, <length>, <used>, %??_numargs
    else
        ?argvar <name>, <length>, <used>
    endif
    ??_procflags = ??_procflags OR ??_pf_Check
    endm

?mkarg  macro   name, length, used, num
    .xcref  ?MKA&num
    ?deflocal <name>
    ?MKA&num &macro
        ?argvar <name>, <length>, <used>
        &endm
    ??_aframe = ??_aframe + 4
    endm
    .xcref  ?mkarg

?argvar macro   name,length,used
    local   a
    ifidni  <length>,<BYTE>
        a = ??_aframe
        ??_aframe =  ??_aframe + 4
        ?setname <name>, <byte ptr [??_basereg+??_initaframe+a]>, <used>
    elseifidni <length>,<WORD>
        a = ??_aframe
        ??_aframe =  ??_aframe + 4
        ?setname <name>, <word ptr [??_basereg+??_initaframe+a]>, <used>
    elseifidni <length>,<DWORD>
        a = ??_aframe
        ??_aframe =  ??_aframe + 4
        ?setname <name>,  <dword ptr [??_basereg+??_initaframe+a]>, <used>
        ?setname <name&l>,<word ptr [??_basereg+??_initaframe+a]>, <used>
        ?setname <name&ll>,<byte ptr [??_basereg+??_initaframe+a]>, <used>
        ?setname <name&lh>,<byte ptr [??_basereg+??_initaframe+a+1]>, <used>
        ?setname <name&h>,<word ptr [??_basereg+??_initaframe+a+2]>, <used>
        ?setname <name&hl>,<byte ptr [??_basereg+??_initaframe+a+2]>, <used>
        ?setname <name&hh>,<byte ptr [??_basereg+??_initaframe+a+3]>, <used>
    else
        a = ??_aframe
        ??_aframe =  ??_aframe + ((length + 3)/4)*4
        ?setname <name>, <[??_basereg+??_initaframe+a]>, <used>
    endif
endm






?setname macro name, value, used
    ?deflocal <name>
    ifidni <used>, <NOTUSED>
        name equ _inaccessible_NOTUSED_
    else
        name equ value
        ??_procflags = ??_procflags OR ??_pf_ArgsUsed OR ??_pf_Check
    endif
endm



















LocalVar    macro   name,length,flag
    local   a
    ??_numlocals = ??_numlocals + 1
    ??_pad = 1
    ifidni <flag>, <PACK>
        ??_pad = 0
    endif
    ifidni  <length>,<BYTE>
        ??_frame = ??_frame + 1 + 3 * ??_pad
        a = ??_frame
        ?deflocal <name>
        name equ byte ptr [??_basereg-a]
    elseifidni <length>,<WORD>
        ??_frame =  ??_frame + 2 + 2 * ??_pad
        a = ??_frame
        ?deflocal <name>
        name equ word ptr [??_basereg-a]
    elseifidni <length>,<DWORD>
        ??_frame = ??_frame + 4
        a = ??_frame
        ?deflocal <name, name&l, name&ll, name&lh, name&h, name&hl, name&hh>
        name equ dword ptr [??_basereg-a]
        name&l equ word ptr [??_basereg-a]
        name&ll equ byte ptr [??_basereg-a]
        name&lh equ byte ptr [??_basereg-a+1]
        name&h equ word ptr [??_basereg-a+2]
        name&hl equ byte ptr [??_basereg-a+2]
        name&hh equ byte ptr [??_basereg-a+3]
    else
        ??_frame =  ??_frame + ((length + 3)/4)*4
        a = ??_frame
        ?deflocal <name>
        name equ [??_basereg-a]
    endif
    ??_procflags = ??_procflags OR ??_pf_Check
endm

?deflocal macro name
    irp nm, <name>
        ??_numlocalsymbols = ??_numlocalsymbols + 1
        ?dodeflocal <nm>, %(??_numlocalsymbols)
    endm
endm
    .xcref  ?deflocal

?dodeflocal macro name, num
    .xcref  ?LOC&num
    ?LOC&num &macro
        name    equ <__inaccessible__NOTINSCOPE__>
        &endm
    endm
    .xcref  ?dodeflocal



EnterProc macro
    .errnz ??_frame and 3, <Total size of local variables not a multiple of 4.>
    if ??_scall
        if ??_public
	    ifdef Not_VxD
                ?merge  %??_name,@,%(??_aframe),,label,near
                ?merge  public,,,,C,%??_name,@,%(??_aframe)
	    else
                ?merge  _,%??_name,@,%(??_aframe),label,near
                ?merge  public,,,,,_,%??_name,@,%(??_aframe)
	    endif
        endif
    endif
    if ??_pcall
        ??_aframe = 0
        ?count = ??_numargs
        rept    ??_numargs
            ?invprg <?MKA>,%?count
            ?count = ?count - 1
        endm
    endif
    ??_fleave = FALSE
    if ??_esp
        if  ??_frame
            sub esp, ??_frame
            ??_pushed = ??_pushed + ??_frame
            ??_fleave = VMM_TRUE
        endif
    else
        if  ??_frame eq 0
            if (??_aframe eq 0) OR ((??_procflags AND ??_pf_ArgsUsed) EQ 0)
                ifdef DEBUG
                    push    ebp
                    mov ebp,esp
                    ??_fleave = VMM_TRUE
                endif
            else
                push    ebp
                mov ebp,esp
                ??_fleave = VMM_TRUE
            endif
        else
            enter   ??_frame, 0
            ??_fleave = VMM_TRUE
        endif
    endif
    ??_procflags = ??_procflags OR ??_pf_Entered
endm















LeaveProc macro flags
    if ??_fleave
        if ??_esp
            ifidni <flags>,<PRESERVE_FLAGS>
                lea esp,[esp + ??_frame]
            else
                add esp,??_frame
            endif
        else
            leave
        endif
    endif
    ??_procflags = ??_procflags OR ??_pf_Left
endm







Return  macro
    if  ??_cleanoff OR ??_w32svc
        if  ??_w32svc AND (??_aframe LT 8)
            ret 8
        else
            ret ??_aframe
        endif
    else
        ret
    endif
    ??_procflags = ??_procflags OR ??_pf_Returned
    endm




EndProc macro Name, Flag
    Name endp
if ??_w32svc
    if ??_aframe lt 8
        cparm&Name equ 0
    else
        cparm&Name equ (??_aframe/4 - 2)
    endif
endif
if ??_procflags AND ??_pf_Left
if ??_fleave
if ??_esp
    ??_pushed = ??_pushed - ??_frame
endif
endif
endif
ifdifi  <Flag>,<NOCHECK>
    if ??_pushed ne 0
        %out Warning: stack not balanced in Name
    endif
    if ??_procflags AND ??_pf_Check
        ife ??_procflags AND ??_pf_Entered
            %out Warning: ArgVar/LocalVar without EnterProc in Name
        endif
        ife ??_procflags AND ??_pf_Left
            %out Warning: ArgVar/LocalVar without LeaveProc in Name
        endif
        ife ??_procflags AND ??_pf_Returned
            %out Warning: ArgVar/LocalVar without Return in Name
        endif
    endif
endif
ifdifi  <Flag>,<KEEPFRAMEVARS>
    ?count = 0
    rept    ??_numlocalsymbols
        ?count = ?count + 1
        ?invprg <?LOC>,%?count
    endm
endif
    ??_ends
    ??_ends equ <>
    endm







cCall   macro   name, arglst, flags
    ife .TYPE name
       CondExtern name, near
    endif
    PushCParams <arglst>, <flags>
    call    name
    ClearCParams
    endm
    .xcref  cCall






pCall   macro   name, arglst
    local   ??saved
    ife .TYPE name
        ?toupper name
    else
        ?upper equ <name>
    endif
    CondExtern %?upper, near
    ??saved = ??_pushed
    irp x,<arglst>
        push    x
        ??_pushed = ??_pushed + 4
    endm
    call    ?upper
    ??_pushed = ??saved
    endm
    .xcref  pCall







sCall   macro   name, arglst
    local   ??saved
    ??saved = ??_pushed
    PushCParams <arglst>
    ?scall  name, %(??_argc * 4)
    ??_pushed = ??saved
    endm
    .xcref  sCall





iCall   equ <sCall>














IFNDEF  STANDARD_CCALL
NONSTANDARD_CCALL = 1
ENDIF

PushCParams macro arglst, flags
    ??_argc = 0
IFDEF   NONSTANDARD_CCALL
    ??_popargs = 0
ELSE
    ??_popargs = ??_align EQ 0
ENDIF
    ifidni  <flags>, <SMALL>
        ??_popargs = 1
    elseifidni <flags>, <FAST>
        ??_popargs = 0
    endif

    irp x,<arglst>
        ??_argc = ??_argc + 1
        ?marg   <x>,%??_argc
    endm
    ?count = ??_argc
    rept    ??_argc
        ?invprg <?AM>,%?count
        ?count = ?count - 1
    endm
    endm
















ClearCParams macro fPreserveFlags
	if	??_argc ne 0
	    if (??_popargs) AND (??_argc LE 2)
	      rept ??_argc
		pop	ecx
	      endm
	    else
	      ifidni <fPreserveFlags>, <PRESERVE_FLAGS>
		lea	esp, [esp][??_argc * 4]
	      else
		add	esp,??_argc * 4
	      endif
	    endif
	endif
	??_pushed = ??_pushed - (??_argc * 4)
	endm



?marg   macro   name, num
    .xcref
    .xcref  ?AM&num
    .cref
    ?AM&num &macro
        push    name
        ??_pushed = ??_pushed + 4
        &endm
    endm
    .xcref  ?marg



?invprg macro   name1, name2
    name1&name2
    purge   name1&name2
    endm
    .xcref  ?invprg



?scall  macro   name1, name2
    CondExtern _&name1&@&name2, near
    call    _&name1&@&name2
    endm
    .xcref  ?scall



?merge  macro   l1, l2, l3, l4, op, r1, r2, r3, r4, r5, r6, r7, r8, r9
    l1&l2&l3&l4 op r1&r2&r3&r4&r5&r6&r7&r8&r9
    endm



?toupper macro s
      ?upper equ <>
      irpc x,<s>
        if '&x' GE 'a'
          if '&x' LE 'z'
        ?t1 substr <ABCDEFGHIJKLMNOPQRSTUVWXYZ>,'&x'-'a'+1,1
        ?upper catstr ?upper,?t1
          else
        ?upper catstr ?upper,<&x>
          endif
        else
          ?upper catstr ?upper,<&x>
        endif
      endm
    endm
    .xcref






CondExtern macro name,dist
    ifdef MASM6
        ifndef name
        externdef name:dist
        endif
    else
        if2
        ifndef name
            extrn name:dist
        endif
        endif
    endif
endm



SaveReg macro   reglist
    irp reg,<reglist>
        ifidni <reg>, <fd>
            pushfd
            ??_pushed = ??_pushed + 4
        else
        ifidni <reg>, <ad>
            pushad
            ??_pushed = ??_pushed + SIZE Pushad_Struc
        else
            push    reg
            ??_pushed = ??_pushed + 4
        endif
        endif
    endm
endm







RestoreReg macro     reglist
    irp reg,<reglist>
        ifidni <reg>, <fd>
            popfd
            ??_pushed = ??_pushed - 4
        else
        ifidni <reg>, <ad>
            popad
            ??_pushed = ??_pushed - SIZE Pushad_Struc
        else
            pop reg
            ??_pushed = ??_pushed - 4
        endif
        endif
    endm
endm

ifdef DEBUG
Begin_Profile_List macro devname
ifdef profileall
VxD_DATA_SEG
    db  'PROCLIST'
PUBLIC devname&_Proc_Profile_List
devname&_Proc_Profile_List label dword
endif
endm

Profile_Link macro modname
ifdef profileall
ifdifi <modname>,@filename
EXTRN _&modname&__proc_list:near
endif
    dd  OFFSET32 _&modname&__proc_list
endif
endm

End_Profile_List macro
ifdef profileall
    dd  0
VxD_DATA_ENDS
endif
endm


endif
ifndef Not_VxD
RESERVED_LOW_BOOST	EQU	00000001H
CUR_RUN_VM_BOOST	EQU	00000004H
LOW_PRI_DEVICE_BOOST	EQU	00000010H
HIGH_PRI_DEVICE_BOOST	EQU	00001000H
CRITICAL_SECTION_BOOST	EQU	00100000H
TIME_CRITICAL_BOOST	EQU	00400000H
RESERVED_HIGH_BOOST	EQU	40000000H
PEF_WAIT_FOR_STI_BIT	EQU	0
PEF_WAIT_FOR_STI	EQU	(1 SHL PEF_WAIT_FOR_STI_BIT)
PEF_WAIT_NOT_CRIT_BIT	EQU	1
PEF_WAIT_NOT_CRIT	EQU	(1 SHL PEF_WAIT_NOT_CRIT_BIT)
PEF_DONT_UNBOOST_BIT	EQU	2
PEF_DONT_UNBOOST	EQU	(1 SHL PEF_DONT_UNBOOST_BIT)
PEF_ALWAYS_SCHED_BIT	EQU	3
PEF_ALWAYS_SCHED	EQU	(1 SHL PEF_ALWAYS_SCHED_BIT)
PEF_TIME_OUT_BIT	EQU	4
PEF_TIME_OUT	EQU	(1 SHL PEF_TIME_OUT_BIT)
PEF_WAIT_NOT_HW_INT_BIT	EQU	5
PEF_WAIT_NOT_HW_INT	EQU	(1 SHL PEF_WAIT_NOT_HW_INT_BIT)
PEF_WAIT_NOT_NESTED_EXEC_BIT	EQU	6
PEF_WAIT_NOT_NESTED_EXEC	EQU	(1 SHL PEF_WAIT_NOT_NESTED_EXEC_BIT)
PEF_WAIT_IN_PM_BIT	EQU	7
PEF_WAIT_IN_PM	EQU	(1 SHL PEF_WAIT_IN_PM_BIT)
PEF_THREAD_EVENT_BIT	EQU	8
PEF_THREAD_EVENT	EQU	(1 SHL PEF_THREAD_EVENT_BIT)
PEF_WAIT_FOR_THREAD_STI_BIT	EQU	9
PEF_WAIT_FOR_THREAD_STI	EQU	(1 SHL PEF_WAIT_FOR_THREAD_STI_BIT)
PEF_RING0_EVENT_BIT	EQU	10
PEF_RING0_EVENT	EQU	(1 SHL PEF_RING0_EVENT_BIT)
PEF_WAIT_CRIT_BIT	EQU	11
PEF_WAIT_CRIT	EQU	(1 SHL PEF_WAIT_CRIT_BIT)
PEF_WAIT_CRIT_VM_BIT	EQU	12
PEF_WAIT_CRIT_VM	EQU	(1 SHL PEF_WAIT_CRIT_VM_BIT)
PEF_PROCESS_LAST_BIT	EQU	13
PEF_PROCESS_LAST	EQU	(1 SHL PEF_PROCESS_LAST_BIT)
PEF_WAIT_NOT_TIME_CRIT_BIT	EQU	PEF_WAIT_NOT_HW_INT_BIT
PEF_WAIT_NOT_TIME_CRIT	EQU	PEF_WAIT_NOT_HW_INT
PEF_WAIT_NOT_PM_LOCKED_STACK_BIT	EQU	PEF_WAIT_NOT_NESTED_EXEC_BIT
PEF_WAIT_NOT_PM_LOCKED_STACK	EQU	PEF_WAIT_NOT_NESTED_EXEC
BLOCK_SVC_INTS_BIT	EQU	0
BLOCK_SVC_INTS	EQU	(1 SHL BLOCK_SVC_INTS_BIT)
BLOCK_SVC_IF_INTS_LOCKED_BIT	EQU	1
BLOCK_SVC_IF_INTS_LOCKED	EQU	(1 SHL BLOCK_SVC_IF_INTS_LOCKED_BIT)
BLOCK_ENABLE_INTS_BIT	EQU	2
BLOCK_ENABLE_INTS	EQU	(1 SHL BLOCK_ENABLE_INTS_BIT)
BLOCK_POLL_BIT	EQU	3
BLOCK_POLL	EQU	(1 SHL BLOCK_POLL_BIT)
BLOCK_THREAD_IDLE_BIT	EQU	4
BLOCK_THREAD_IDLE	EQU	(1 SHL BLOCK_THREAD_IDLE_BIT)
BLOCK_FORCE_SVC_INTS_BIT	EQU	5
BLOCK_FORCE_SVC_INTS	EQU	(1 SHL BLOCK_FORCE_SVC_INTS_BIT)

Client_Reg_Struc	STRUC
Client_EDI	DD	?
Client_ESI	DD	?
Client_EBP	DD	?
Client_res0	DD	?
Client_EBX	DD	?
Client_EDX	DD	?
Client_ECX	DD	?
Client_EAX	DD	?
Client_Error	DD	?
Client_EIP	DD	?
Client_CS	DW	?
Client_res1	DW	?
Client_EFlags	DD	?
Client_ESP	DD	?
Client_SS	DW	?
Client_res2	DW	?
Client_ES	DW	?
Client_res3	DW	?
Client_DS	DW	?
Client_res4	DW	?
Client_FS	DW	?
Client_res5	DW	?
Client_GS	DW	?
Client_res6	DW	?
Client_Alt_EIP	DD	?
Client_Alt_CS	DW	?
Client_res7	DW	?
Client_Alt_EFlags	DD	?
Client_Alt_ESP	DD	?
Client_Alt_SS	DW	?
Client_res8	DW	?
Client_Alt_ES	DW	?
Client_res9	DW	?
Client_Alt_DS	DW	?
Client_res10	DW	?
Client_Alt_FS	DW	?
Client_res11	DW	?
Client_Alt_GS	DW	?
Client_res12	DW	?
Client_Reg_Struc	ENDS

Client_Word_Reg_Struc	STRUC
Client_DI	DW	?
Client_res13	DW	?
Client_SI	DW	?
Client_res14	DW	?
Client_BP	DW	?
Client_res15	DW	?
Client_res16	DD	?
Client_BX	DW	?
Client_res17	DW	?
Client_DX	DW	?
Client_res18	DW	?
Client_CX	DW	?
Client_res19	DW	?
Client_AX	DW	?
Client_res20	DW	?
Client_res21	DD	?
Client_IP	DW	?
Client_res22	DW	?
Client_res23	DD	?
Client_Flags	DW	?
Client_res24	DW	?
Client_SP	DW	?
Client_res25	DW	?
Client_res26	DD	5 DUP (?)
Client_Alt_IP	DW	?
Client_res27	DW	?
Client_res28	DD	?
Client_Alt_Flags	DW	?
Client_res29	DW	?
Client_Alt_SP	DW	?
Client_Word_Reg_Struc	ENDS

Client_Byte_Reg_Struc	STRUC
Client_res30	DD	4 DUP (?)
Client_BL	DB	?
Client_BH	DB	?
Client_res31	DW	?
Client_DL	DB	?
Client_DH	DB	?
Client_res32	DW	?
Client_CL	DB	?
Client_CH	DB	?
Client_res33	DW	?
Client_AL	DB	?
Client_AH	DB	?
Client_Byte_Reg_Struc	ENDS
?UnionSize = 0
if size Client_Reg_Struc gt ?UnionSize
	?UnionSize = size Client_Reg_Struc
endif
CRS	equ	<(byte ptr 0)>

if size Client_Word_Reg_Struc gt ?UnionSize
	?UnionSize = size Client_Word_Reg_Struc
endif
CWRS	equ	<(byte ptr 0)>

if size Client_Byte_Reg_Struc gt ?UnionSize
	?UnionSize = size Client_Byte_Reg_Struc
endif
CBRS	equ	<(byte ptr 0)>


tagCLIENT_STRUC	STRUC
	DB	?UnionSize dup(?)
tagCLIENT_STRUC	ENDS

IF 0
.ERRNZ Client_SP - Client_ESP
.ERRNZ Client_AL - Client_EAX

endif
DYNA_LINK_INT	EQU	20H












DeclareNonstandardCcallService macro arglst
	irp	x,<arglst>
	    ??_nonstandardccall_&x = 1
	endm
endm







DeclareNonstandardCcallService <_BlockOnID, _LocalizeSprintf>
DeclareNonstandardCcallService <_SetLastV86Page, _Assert_Range>

BeginDoc













EndDoc


BeginDoc








EndDoc

DefTable MACRO vt, vn
    vt EQU <vn>
ENDM

GenDD2 MACRO vt, sn, jf
    dd  OFFSET32 vt[sn+jf]
ENDM

GenDD   MACRO   P, vid, snum, jflag
    LOCAL   vtable
IFDEF   @@VxDName&vid
    Deftable    vtable, %@@VxDName&vid
    EXTRN   vtable:DWORD
    GenDD2 %vtable, snum, jflag
ELSE
    dd  @@&P+jflag
ENDIF

ENDM


VxDCall MACRO P, Param, flags
    ??_vxdid = (@@&P SHR 16)
    ??_servicenum = (@@&P AND 0FFFFh)
    ifdef ??_nonstandardccall_&P
    PushCParams <Param>, <FAST>
    else
    PushCParams <Param>, <flags>
    endif
    int Dyna_Link_Int
    GenDD   P, %??_vxdid, %??_servicenum, 0
    ifdef ??_nonstandardccall_&P
	ClearCParams PRESERVE_FLAGS
    else
	ClearCParams
    endif
    ENDM

VxDJmp  MACRO P, Param
    ??_vxdid = (@@&P SHR 16)
    ??_servicenum = (@@&P AND 0FFFFh)
    .errnb <Param>, <Parameters may not be passed to VxDJmp or VMMJmp>
    int Dyna_Link_Int
    GenDD   P, %??_vxdid, %??_servicenum, DL_Jmp_Mask
    ENDM

DL_Jmp_Mask EQU 8000h
DL_Jmp_Bit  EQU 0Fh

VMMCall MACRO P, Param
    .ERRNZ (@@&P SHR 16) - VMM_DEVICE_ID
    VxDCall <P>, <Param>
    ENDM

VMMJmp MACRO P, Param
    .ERRNZ (@@&P SHR 16) - VMM_DEVICE_ID
    VxDJmp <P>, <Param>
    ENDM

BeginDoc




























EndDoc




VxD_CODE_SEG    EQU <VxD_LOCKED_CODE_SEG>
VxD_CODE_ENDS   EQU <VxD_LOCKED_CODE_ENDS>


VxD_LOCKED_CODE_SEG MACRO
_LTEXT   SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_LCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

        ENDM

VxD_LOCKED_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_LTEXT   ENDS
        ENDM




VxD_PAGEABLE_CODE_SEG MACRO
_PTEXT   SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_PCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

        ENDM

VxD_PAGEABLE_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_PTEXT   ENDS
        ENDM




VxD_DEBUG_ONLY_CODE_SEG MACRO
_DBOCODE    SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_DBOCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT
        ENDM

VxD_DEBUG_ONLY_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_DBOCODE    ENDS
        ENDM




VxD_INIT_CODE_SEG   MACRO
_ITEXT  SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_ICODE
    ASSUME  cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT
    ENDM

VxD_INIT_CODE_ENDS  MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_ITEXT  ENDS
        ENDM

VxD_ICODE_SEG equ VxD_INIT_CODE_SEG
VxD_ICODE_ENDS equ VxD_INIT_CODE_ENDS




VxD_DATA_SEG    EQU <VxD_LOCKED_DATA_SEG>
VxD_DATA_ENDS   EQU <VxD_LOCKED_DATA_ENDS>

VxD_LOCKED_DATA_SEG MACRO NO_ALIGN
_LDATA   SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
        ENDM

VxD_LOCKED_DATA_ENDS MACRO
_LDATA   ENDS
        ENDM




VxD_IDATA_SEG   MACRO
_IDATA  SEGMENT
        ENDM
VxD_IDATA_ENDS  MACRO
_IDATA  ENDS
        ENDM




VxD_PAGEABLE_DATA_SEG MACRO NO_ALIGN
_PDATA   SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
        ENDM

VxD_PAGEABLE_DATA_ENDS MACRO
_PDATA   ENDS
        ENDM




VxD_STATIC_CODE_SEG MACRO
_STEXT   SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_SCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

        ENDM

VxD_STATIC_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_STEXT   ENDS
        ENDM




VxD_STATIC_DATA_SEG MACRO NO_ALIGN
_SDATA   SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
        ENDM

VxD_STATIC_DATA_ENDS MACRO
_SDATA   ENDS
        ENDM



VxD_DEBUG_ONLY_DATA_SEG MACRO NO_ALIGN
_DBODATA    SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
        ENDM

VxD_DEBUG_ONLY_DATA_ENDS MACRO
_DBODATA    ENDS
        ENDM




VxD_16BIT_INIT_SEG  MACRO
_16ICODE SEGMENT
ASSUME CS:_16ICODE, DS:NOTHING, ES:NOTHING, SS:NOTHING
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_16ICODE
          ENDM

VxD_16BIT_INIT_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_16ICODE ENDS
           ENDM



VxD_REAL_INIT_SEG  MACRO
_RCODE SEGMENT
ASSUME CS:_RCODE, DS:_RCODE, ES:_RCODE, SS:_RCODE
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_RCODE
          ENDM

VxD_REAL_INIT_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_RCODE ENDS
           ENDM

endif
ifndef DDK_VERSION
ifdef WIN31COMPAT
DDK_VERSION	EQU	30AH
else
DDK_VERSION	EQU	400H
endif
endif

VxD_Desc_Block	STRUC
DDB_Next	DD	?
DDB_SDK_Version	DW	DDK_VERSION
DDB_Req_Device_Number	DW	UNDEFINED_DEVICE_ID
DDB_Dev_Major_Version	DB	0
DDB_Dev_Minor_Version	DB	0
DDB_Flags	DW	0
DDB_Name	DB	"        "
DDB_Init_Order	DD	UNDEFINED_INIT_ORDER
DDB_Control_Proc	DD	?
DDB_V86_API_Proc	DD	0
DDB_PM_API_Proc	DD	0
DDB_V86_API_CSIP	DD	0
DDB_PM_API_CSIP	DD	0
DDB_Reference_Data	DD	?
DDB_Service_Table_Ptr	DD	0
DDB_Service_Table_Size	DD	0
DDB_Win32_Service_Table	DD	0
DDB_Prev	DD	'Prev'
DDB_Size	DD	SIZE(VxD_Desc_Block)
DDB_Reserved1	DD	'Rsv1'
DDB_Reserved2	DD	'Rsv2'
DDB_Reserved3	DD	'Rsv3'
VxD_Desc_Block	ENDS
ifndef Not_VxD
DDB_SYS_CRIT_INIT_DONE_BIT	EQU	0
DDB_SYS_CRIT_INIT_DONE	EQU	(1 SHL DDB_SYS_CRIT_INIT_DONE_BIT)
DDB_DEVICE_INIT_DONE_BIT	EQU	1
DDB_DEVICE_INIT_DONE	EQU	(1 SHL DDB_DEVICE_INIT_DONE_BIT)
DDB_HAS_WIN32_SVCS_BIT	EQU	14
DDB_HAS_WIN32_SVCS	EQU	(1 SHL DDB_HAS_WIN32_SVCS_BIT)
DDB_DYNAMIC_VXD_BIT	EQU	15
DDB_DYNAMIC_VXD	EQU	(1 SHL DDB_DYNAMIC_VXD_BIT)
DDB_DEVICE_DYNALINKED_BIT	EQU	13
DDB_DEVICE_DYNALINKED	EQU	(1 SHL DDB_DEVICE_DYNALINKED_BIT)
BeginDoc







EndDoc
Declare_Virtual_Device MACRO Name, Major_Ver, Minor_Ver, Ctrl_Proc, Device_Num, Init_Order, V86_Proc, PM_Proc, Reference_Data
    LOCAL   V86_API_Offset, PM_API_Offset, Serv_Tab_Offset, Serv_Tab_Len, Ref_Data_Offset

dev_id_err MACRO

IFNDEF Name&_Name_Based
.err <Device ID required when providing services>
ENDIF
    ENDM

IFB <V86_Proc>
    V86_API_Offset EQU 0
ELSE
 IFB <Device_Num>
    dev_id_err
 ENDIF
    V86_API_Offset EQU <OFFSET32 V86_Proc>
ENDIF

IFB <PM_Proc>
    PM_API_Offset EQU 0
ELSE
 IFB <Device_Num>
    dev_id_err
 ENDIF
    PM_API_Offset EQU <OFFSET32 PM_Proc>
ENDIF

IFDEF Name&_Service_Table
 IFB <Device_Num>
    dev_id_err
 ELSE
  IFE Device_Num - UNDEFINED_DEVICE_ID
    dev_id_err
  ENDIF
 ENDIF
    Serv_Tab_Offset EQU <OFFSET32 Name&_Service_Table>
    Serv_Tab_Len    EQU Num_&Name&_Services
ELSE
    Serv_Tab_Offset EQU 0
    Serv_Tab_Len    EQU 0
ENDIF

IFNB    <Device_Num>
  .erre (Device_Num LT BASEID_FOR_NAMEBASEDVXD), <Device ID  must be less than BASEID_FOR_NAMEBASEDVXD>
ENDIF

IFB <Reference_Data>
        Ref_Data_Offset EQU 0
ELSE
        Ref_Data_Offset EQU   <OFFSET32 Reference_Data>
ENDIF

IFDEF DEBUG
VxD_IDATA_SEG
    db  0dh, 0ah, 'D_E_B_U_G===>'
        db      "&Name", '<===', 0dh, 0ah
VxD_IDATA_ENDS
ENDIF

VxD_LOCKED_DATA_SEG

PUBLIC Name&_DDB
Name&_DDB VxD_Desc_Block <,,Device_Num,Major_Ver,Minor_Ver,,"&Name",Init_Order,\
             OFFSET32 Ctrl_Proc, V86_API_Offset, PM_API_Offset, \
             ,,Ref_Data_Offset,Serv_Tab_Offset, Serv_Tab_Len>

VxD_LOCKED_DATA_ENDS

    ENDM





























Begin_Control_Dispatch MACRO VxD_Name, p1, p2
??_cd_low = 0FFFFFFFFh
??_cd_high = 0

BeginProc VxD_Name&_Control, p1, p2, LOCKED
ENDM

End_Control_Dispatch   MACRO VxD_Name
    LOCAL ignore, table

procoff MACRO num
IFDEF ??_cd_&&num
    dd  OFFSET32 ??_cd_&&num
ELSE
    dd  OFFSET32 ignore
ENDIF
ENDM

IF ??_cd_low EQ ??_cd_high
    cmp eax, ??_cd_low
    ?merge  <jz>,,,,,<??_cd_>, %(??_cd_low)
    clc
    ret
ELSE
IF ??_cd_low GT 0
    sub eax, ??_cd_low
ENDIF
    cmp eax, ??_cd_high - ??_cd_low + 1
    jae short ignore
    jmp [eax*4+table]
ignore:
    clc
    ret

table label dword
    REPT   ??_cd_high - ??_cd_low + 1
    procoff %(??_cd_low)
    ??_cd_low = ??_cd_low + 1
    ENDM
ENDIF

EndProc VxD_Name&_Control

PURGE procoff
PURGE Begin_Control_Dispatch
PURGE Control_Dispatch
PURGE End_Control_Dispatch
ENDM

BeginDoc




















EndDoc
Control_Dispatch MACRO Service, Procedure, callc, arglst
    LOCAL Skip_Interseg_Jump

.errnz ?_LCODE, <Control_Dispatch must be in VxD_LOCKED_CODE_SEG.>

IFB <callc>

IFDEF ??_cd_low
Equate_Service MACRO Serv
??_cd_&&Serv equ Procedure
ENDM

Equate_Service %(Service)

IF Service LT ??_cd_low
??_cd_low = Service
ENDIF
IF Service GT ??_cd_high
??_cd_high = Service
ENDIF

PURGE Equate_Service

ELSE
    cmp eax, Service
    jz  Procedure
ENDIF

ELSE

    cmp eax, Service
    jne SHORT Skip_Interseg_Jump
    callc   Procedure, <arglst>
IF Service EQ PNP_NEW_DEVNODE
    stc
ELSE
    cmp eax,1
ENDIF
    ret
Skip_Interseg_Jump:

ENDIF

    ENDM

BYTE_INPUT	EQU	000H
BYTE_OUTPUT	EQU	004H
WORD_INPUT	EQU	008H
WORD_OUTPUT	EQU	00CH
DWORD_INPUT	EQU	010H
DWORD_OUTPUT	EQU	014H
OUTPUT_BIT	EQU	2
OUTPUT	EQU	(1 SHL OUTPUT_BIT)
WORD_IO_BIT	EQU	3
WORD_IO	EQU	(1 SHL WORD_IO_BIT)
DWORD_IO_BIT	EQU	4
DWORD_IO	EQU	(1 SHL DWORD_IO_BIT)
STRING_IO_BIT	EQU	5
STRING_IO	EQU	(1 SHL STRING_IO_BIT)
REP_IO_BIT	EQU	6
REP_IO	EQU	(1 SHL REP_IO_BIT)
ADDR_32_IO_BIT	EQU	7
ADDR_32_IO	EQU	(1 SHL ADDR_32_IO_BIT)
REVERSE_IO_BIT	EQU	8
REVERSE_IO	EQU	(1 SHL REVERSE_IO_BIT)
IO_SEG_MASK	EQU	0FFFF0000H
IO_SEG_SHIFT	EQU	10H
BeginDoc






EndDoc
Dispatch_Byte_IO MACRO In_Proc, Out_Proc
    LOCAL   Byte_IO
    cmp ecx, Byte_Output
    jbe SHORT Byte_IO
    VMMJmp  Simulate_IO
Byte_IO:
IFIDNI <In_Proc>, <Fall_Through>
    je  Out_Proc
ELSE
IFIDNI <Out_Proc>, <Fall_Through>
    jb  In_Proc
ELSE
    je  Out_Proc
    jmp In_Proc
ENDIF
ENDIF
    ENDM

BeginDoc







EndDoc
Emulate_Non_Byte_IO MACRO
    LOCAL   Byte_IO
    cmp ecx, Byte_Output
    jbe SHORT Byte_IO
    VMMJmp  Simulate_IO
Byte_IO:
    ENDM

BeginDoc








EndDoc


VxD_IOT_Hdr	STRUC
VxD_IO_Ports	DW	?
VxD_IOT_Hdr	ENDS

VxD_IO_Struc	STRUC
VxD_IO_Port	DW	?
VxD_IO_Proc	DD	?
VxD_IO_Struc	ENDS
.ERRNZ SIZE VxD_IOT_Hdr - 2
Begin_VxD_IO_Table MACRO Table_Name
PUBLIC Table_Name
Table_Name LABEL WORD

ifndef MASM6
IF2
IFNDEF Table_Name&_Entries
.err <No End_VxD_IO_Table for &Table_Name>
ENDIF
    dw  Table_Name&_Entries
ELSE
    dw  ?
ENDIF
ELSE
    dw  Table_Name&_Entries
ENDIF

    ENDM

.ERRNZ SIZE VxD_IO_Struc - 6
VxD_IO MACRO Port, Proc_Name
    dw  Port
    dd  OFFSET32 Proc_Name
    ENDM

End_VxD_IO_Table MACRO Table_Name

IFNDEF Table_Name
.err <No Begin_VxD_IO_Table for &Table_Name>
ELSE
    Table_Name&_Entries EQU (($-Table_Name)-2) / (SIZE VxD_IO_Struc)
IF Table_Name&_Entries LE 0
.err <Invalid number of port traps in &Table_Name>
ENDIF
ENDIF
        ENDM













Push_Client_State MACRO Can_Trash_EDI
    sub esp, SIZE Client_Reg_Struc
    ??_pushed = ??_pushed + SIZE Client_Reg_Struc
    ifidni <Can_Trash_EDI>, <USES_EDI>
    mov edi, esp
    VMMCall Save_Client_State
    else
    push    edi
    lea edi, [esp+4]
    VMMCall Save_Client_State
    pop edi
    endif
    ENDM

Pop_Client_State MACRO Can_Trash_ESI
    ifdifi <Can_Trash_ESI>, <USES_ESI>
    push    esi
    lea esi, [esp+4]
    VMMCall Restore_Client_State
    pop esi
    else
    mov esi, esp
    VMMCall Restore_Client_State
    endif
    add esp, SIZE Client_Reg_Struc
    ??_pushed = ??_pushed - SIZE Client_Reg_Struc
    ENDM

BeginDoc














EndDoc

CallRet MACRO P1, P2
IFDEF DEBUG
IFIDNI <P1>, <SHORT>
    call    P2
ELSE
    call    P1
ENDIF
    ret
ELSE
    jmp P1 P2
ENDIF
    ENDM

BeginDoc






EndDoc

IFDEF   DEBUG

VxDCallRet macro p:req
    VxDCall p
    ret
endm

VMMCallRet macro p:req
    VMMCall p
    ret
endm

ELSE

VxDCallRet equ <VxDJmp>
VMMCallRet equ <VMMJmp>

ENDIF



PClient_DS equ WORD PTR -4
PClient_ES equ WORD PTR -8
PClient_FS equ WORD PTR -12
PClient_GS equ WORD PTR -16











Client_Ptr_Flat MACRO Reg_32, Cli_Seg, Cli_Off, Can_Trash_EAX

IFDIFI <Reg_32>, <EAX>
    IFDIFI <Can_Trash_EAX>, <USES_EAX>
    xchg    Reg_32, eax
    ENDIF
ENDIF
IFB <Cli_Off>
    mov ax, (Client_&Cli_Seg * 100h) + 0FFh
ELSE
    mov ax, (Client_&Cli_Seg * 100h) + Client_&Cli_Off
ENDIF
    VMMCall Map_Flat

IFDIFI <Reg_32>, <EAX>
    xchg    Reg_32, eax
ENDIF

    ENDM



VxDint  MACRO   Int_Number
    if  (OPATTR Int_Number) AND 4
    push    Int_Number
    else
    push    DWORD PTR Int_Number
    endif
    VMMCall Exec_VxD_Int
    ENDM

VxDintMustComplete MACRO   Int_Number
    if  (OPATTR Int_Number) AND 4
    push    Int_Number
    else
    push    DWORD PTR Int_Number
    endif
        VMMCall _ExecVxDIntMustComplete
    ENDM



endif
DUPLICATE_DEVICE_ID_BIT	EQU	0
DUPLICATE_DEVICE_ID	EQU	(1 SHL DUPLICATE_DEVICE_ID_BIT)
DUPLICATE_FROM_INT2F_BIT	EQU	1
DUPLICATE_FROM_INT2F	EQU	(1 SHL DUPLICATE_FROM_INT2F_BIT)
LOADING_FROM_INT2F_BIT	EQU	2
LOADING_FROM_INT2F	EQU	(1 SHL LOADING_FROM_INT2F_BIT)
DEVICE_LOAD_OK	EQU	0
ABORT_DEVICE_LOAD	EQU	1
ABORT_WIN386_LOAD	EQU	2
NO_FAIL_MESSAGE_BIT	EQU	15
NO_FAIL_MESSAGE	EQU	(1 SHL NO_FAIL_MESSAGE_BIT)
LDRSRV_GET_PROFILE_STRING	EQU	0
LDRSRV_GET_NEXT_PROFILE_STRING	EQU	1
LDRSRV_RESERVED	EQU	2
LDRSRV_GET_PROFILE_BOOLEAN	EQU	3
LDRSRV_GET_PROFILE_DECIMAL_INT	EQU	4
LDRSRV_GET_PROFILE_HEX_INT	EQU	5
LDRSRV_COPY_EXTENDED_MEMORY	EQU	6
LDRSRV_GET_MEMORY_INFO	EQU	7
LDRSRV_RegOpenKey	EQU	100H
LDRSRV_RegCreateKey	EQU	101H
LDRSRV_RegCloseKey	EQU	102H
LDRSRV_RegDeleteKey	EQU	103H
LDRSRV_RegSetValue	EQU	104H
LDRSRV_RegQueryValue	EQU	105H
LDRSRV_RegEnumKey	EQU	106H
LDRSRV_RegDeleteValue	EQU	107H
LDRSRV_RegEnumValue	EQU	108H
LDRSRV_RegQueryValueEx	EQU	109H
LDRSRV_RegSetValueEx	EQU	10AH
LDRSRV_RegFlushKey	EQU	10BH
LDRSRV_COPY_INIT	EQU	1
LDRSRV_COPY_LOCKED	EQU	2
LDRSRV_COPY_PAGEABLE	EQU	3
RCODE_OBJ	EQU	-1
LCODE_OBJ	EQU	01H
LDATA_OBJ	EQU	02H
PCODE_OBJ	EQU	03H
PDATA_OBJ	EQU	04H
SCODE_OBJ	EQU	05H
SDATA_OBJ	EQU	06H
CODE16_OBJ	EQU	07H
LMSG_OBJ	EQU	08H
PMSG_OBJ	EQU	09H
DBOC_OBJ	EQU	0BH
DBOD_OBJ	EQU	0CH
ICODE_OBJ	EQU	11H
IDATA_OBJ	EQU	12H
ICODE16_OBJ	EQU	13H
IMSG_OBJ	EQU	14H

ObjectLocation	STRUC
OL_LinearAddr	DD	?
OL_Size	DD	?
OL_ObjType	DB	?
ObjectLocation	ENDS
MAXOBJECTS	EQU	25

Device_Location_List	STRUC
DLL_DDB	DD	?
DLL_NumObjects	DB	?
DLL_ObjLocation	DB	SIZE ObjectLocation * 1 DUP (?)
Device_Location_List	ENDS
PE_BIT	EQU	0
PE_MASK	EQU	(1 SHL PE_BIT)
MP_BIT	EQU	1
MP_MASK	EQU	(1 SHL MP_BIT)
EM_BIT	EQU	2
EM_MASK	EQU	(1 SHL EM_BIT)
TS_BIT	EQU	3
TS_MASK	EQU	(1 SHL TS_BIT)
ET_BIT	EQU	4
ET_MASK	EQU	(1 SHL ET_BIT)
PG_BIT	EQU	31
PG_MASK	EQU	(1 SHL PG_BIT)
CF_BIT	EQU	0
CF_MASK	EQU	(1 SHL CF_BIT)
PF_BIT	EQU	2
PF_MASK	EQU	(1 SHL PF_BIT)
AF_BIT	EQU	4
AF_MASK	EQU	(1 SHL AF_BIT)
ZF_BIT	EQU	6
ZF_MASK	EQU	(1 SHL ZF_BIT)
SF_BIT	EQU	7
SF_MASK	EQU	(1 SHL SF_BIT)
TF_BIT	EQU	8
TF_MASK	EQU	(1 SHL TF_BIT)
IF_BIT	EQU	9
IF_MASK	EQU	(1 SHL IF_BIT)
DF_BIT	EQU	10
DF_MASK	EQU	(1 SHL DF_BIT)
OF_BIT	EQU	11
OF_MASK	EQU	(1 SHL OF_BIT)
IOPL_MASK	EQU	3000H
IOPL_BIT0	EQU	12
IOPL_BIT1	EQU	13
NT_BIT	EQU	14
NT_MASK	EQU	(1 SHL NT_BIT)
RF_BIT	EQU	16
RF_MASK	EQU	(1 SHL RF_BIT)
VM_BIT	EQU	17
VM_MASK	EQU	(1 SHL VM_BIT)
AC_BIT	EQU	18
AC_MASK	EQU	(1 SHL AC_BIT)
VIF_BIT	EQU	19
VIF_MASK	EQU	(1 SHL VIF_BIT)
VIP_BIT	EQU	20
VIP_MASK	EQU	(1 SHL VIP_BIT)






IFDEF MASM6
loopde EQU <looped>
loopdne EQU <loopned>
loopdz EQU <loopzd>
loopdnz EQU <loopnzd>
ELSE
loopd EQU <loop>
loopde EQU <loope>
loopdne EQU <loopne>
loopdz EQU <loopz>
loopdnz EQU <loopnz>
ENDIF

P_SIZE	EQU	1000H
P_PRESBIT	EQU	0
P_PRES	EQU	(1 SHL P_PRESBIT)
P_WRITEBIT	EQU	1
P_WRITE	EQU	(1 SHL P_WRITEBIT)
P_USERBIT	EQU	2
P_USER	EQU	(1 SHL P_USERBIT)
P_ACCBIT	EQU	5
P_ACC	EQU	(1 SHL P_ACCBIT)
P_DIRTYBIT	EQU	6
P_DIRTY	EQU	(1 SHL P_DIRTYBIT)
P_AVAIL	EQU	(P_PRES+P_WRITE+P_USER)
PG_VM	EQU	0
PG_SYS	EQU	1
PG_RESERVED1	EQU	2
PG_PRIVATE	EQU	3
PG_RESERVED2	EQU	4
PG_RELOCK	EQU	5
PG_INSTANCE	EQU	6
PG_HOOKED	EQU	7
PG_IGNORE	EQU	0FFFFFFFFH
D_PRES	EQU	080H
D_NOTPRES	EQU	0
D_DPL0	EQU	0
D_DPL1	EQU	020H
D_DPL2	EQU	040H
D_DPL3	EQU	060H
D_SEG	EQU	010H
D_CTRL	EQU	0
D_GRAN_BYTE	EQU	000H
D_GRAN_PAGE	EQU	080H
D_DEF16	EQU	000H
D_DEF32	EQU	040H
D_CODE	EQU	08H
D_DATA	EQU	0
D_X	EQU	0
D_RX	EQU	02H
D_C	EQU	04H
D_R	EQU	0
D_W	EQU	02H
D_ED	EQU	04H
D_ACCESSED	EQU	1
RW_DATA_TYPE	EQU	(D_PRES+D_SEG+D_DATA+D_W)
R_DATA_TYPE	EQU	(D_PRES+D_SEG+D_DATA+D_R)
CODE_TYPE	EQU	(D_PRES+D_SEG+D_CODE+D_RX)
D_PAGE32	EQU	(D_GRAN_PAGE+D_DEF32)
SELECTOR_MASK	EQU	0FFF8H
SEL_LOW_MASK	EQU	0F8H
TABLE_MASK	EQU	04H
RPL_MASK	EQU	03H
RPL_CLR	EQU	(NOT RPL_MASK)
IVT_ROM_DATA_SIZE	EQU	500H
endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\old\VNV0D.H ===
#ifndef _VNV0D_H_
#define _VNV0D_H_
/******** Operating System Interface for NVidia Hardware Simulator  ********\
*                                                                           *
* Module: NVRM.H                                                            *
*       Header file for NV0 defines and service exports.                    *
*                                                                           *
*---------------------------------------------------------------------------*
*                                                                           *
* History:                                                                  *
*        David Schmenk (dschmenk)     06/21/94 - wrote it                   *
*                                                                           *
\*********************** Copyright 1994 NVidia, Inc. ***********************/

//---------------------------------------------------------------------------
//
//  Defines.
//
//---------------------------------------------------------------------------

//
// Version numbers.
//
#define NV0_Major_Version  1
#define NV0_Minor_Version  0
//
// Device IDs.
//
#define NV0_Device_ID      0x32DB
//
// Init order.
//
#define NV0_Init_Order     0x70000000
//
// Virtual device services.
//
#define NV0_Get_Version        0
#define NV0_Install_Handlers   1

//---------------------------------------------------------------------------
//
//  Types.
//
//---------------------------------------------------------------------------

//
// Shared communication buffer structure.
//
typedef DWORD CDECL (*RDPROC)(DWORD, DWORD);
typedef DWORD CDECL (*WRPROC)(DWORD, DWORD, DWORD);
typedef VOID  CDECL (*CTPROC)(VOID);
typedef struct
{
    RDPROC memRead;
    WRPROC memWrite;
    RDPROC ioRead;
    WRPROC ioWrite;
    RDPROC cfgRead;
    WRPROC cfgWrite;
    CTPROC Interrupt;
    DWORD  physBase;
    DWORD  linBase;
    DWORD  ufifoBase;
    DWORD  ufifoCount;
} NV0PROCS, *PNV0PROCS;

//---------------------------------------------------------------------------
//
//  Prototypes to call NV0 services.
//
//---------------------------------------------------------------------------

DWORD nvsimGetVersion(VOID);
LONG  nvsimInstallHandlers(DWORD, PNV0PROCS);
#pragma aux nvsimGetVersion =                           \
            CALL_VXD(NV0_Device_ID, NV0_Get_Version)    \
            parm caller []                              \
            value no8087 [EAX]                          \
            modify [EAX EBX ECX EDX];
#pragma aux nvsimInstallHandlers =                          \
            CALL_VXD(NV0_Device_ID, NV0_Install_Handlers)   \
            parm caller []                                  \
            value no8087 [EAX]                              \
            modify [EAX EBX ECX EDX];
#endif // _VNV0D_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\old\VNV0D.INC ===
;******** Operating System Interface for NVidia Hardware Simulator  ********;
;                                                                           ;
; Module: NV0.INC                                                           ;
;       Header file for NV0 defines and service exports.                    ;
;                                                                           ;
;---------------------------------------------------------------------------;
;                                                                           ;
; History:                                                                  ;
;        David Schmenk (dschmenk)     11/19/93 - wrote it                   ;
;                                                                           ;
;*********************** Copyright 1993 NVidia, Inc. ***********************;

;
; Version numbers.
;

NV0_Major_Version  EQU     01h
NV0_Minor_Version  EQU     00h

;
; Device IDs.
;

NV0_Device_ID      EQU     032DBh

;
; Init order.
;

NV0_Init_Order     EQU     070000000h

;===========================================================================;
;                                                                           ;
;                     Virtual device services.                              ;
;                                                                           ;
;       The virtual device services are declared here, along with their     ;
;       cod segments.  The service entrypoints are declared with a preceding;
;       underscore, the service is a C based function with stack based      ;
;       parameters.  Otherwise, it is an assembly based function with       ;
;       register based parameters.                                          ;
;                                                                           ;
;===========================================================================;

Begin_Service_Table     NV0
        NV0_Service     _nv0GetVersion,         LOCAL
        NV0_Service     _nv0InstallHandlers,    LOCAL
End_Service_Table       NV0
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\old\WATCOM.H ===
#ifndef _WATCOM_H_
#define _WATCOM_H_
//
// (C) Copyright NVIDIA Corporation Inc., 1995,1996. All rights reserved.
//
/*************************** OS Specific Module ****************************\
*                                                                           *
* Module: WATCOM.H                                                          *
*       WATCOM and Windows specific defines and pragmas.                    *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       David Schmenk (dschmenk)     1/06/95 - copied from nvrm.h.          *
*                                                                           *
\***************************************************************************/
//
// Special pragmas for the WATCOM VxD build environment.
//
#ifdef _LGROUP
#pragma data_seg( "_LDATA", "CODE" )
#endif
#ifdef _IGROUP
#pragma data_seg( "_IDATA", "ICODE" )
#endif
#endif // _WATCOM_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\modeset\modehw.c ===
//
// modehw.c -  OS specific NV register access routines for mode set code.
//
// These routines utilize IO to access the NV3 controller. To use
// the modeset code in a non-IO based environment, the following
// routines must be modified to access the NV3 through the PCI
// addressing.
//
// Copyright (c) 1997 - NVidia Corporation. All Rights Reserved.
//
#include <nv_ref.h>
#include <nvrm.h>
#include "nvhw.h"
#include "modes.h"


//
// Enable Register Extensions
//
VOID OEMEnableExtensions(VOID)
{
    WriteIndexed(NV_PRMCIO_CRX__COLOR, 0x571F);
}                            

//
// Disable Register Extensions
// 
VOID OEMDisableExtensions(VOID)
{       
    WriteIndexed(NV_PRMCIO_CRX__COLOR, 0x991F);
}                                 

//       WriteFb32 - Write a dword value to a fb address
//
//       Entry:  EAX = Value to write
//               ESI = fb offset
//       Exit:   None
//
VOID WriteFb32(U032 datum, U032 addr)
{
    fbAddr->Reg032[addr] = datum;       // MEM_WR32/PDFB macros resolve to this
}                          


//       ReadFb32 - Read a dword value from a fb address
//
//       Entry:  ESI = fb offset
//       Exit:   EAX = Value read
//
U032 ReadFb32(U032 addr)
{               
    return fbAddr->Reg032[addr];        // MEM_RD32/PDFB macros resolve to this
}                          


//       WritePriv32 - Write a dword value to an NV register
//
//       Entry:  EAX = Value to write
//               ESI = NV register address
//               Extended CRTC registers unlocked
//       Exit:   None
//
VOID WritePriv32(U032 datum, U032 addr)
{
    REG_WR32(addr, datum);
}                          


//       ReadPriv32 - Read a dword value from an NV register
//
//       Entry:  ESI = NV register address
//               Extended CRTC registers unlocked
//       Exit:   EAX = Value read
//
U032 ReadPriv32(U032 addr)
{               
    return(REG_RD32(addr));
}                          

// Write a data word to Priveledged IO
//
// Entry: U032 addr                // Address of Controller Register
//        U016 datum              // Data to write to SR/GR/CR
//
// Exit:  none
//
VOID WriteIndexed(U032 addr, U016 datum)
{                                    
    //
    // Keep it 8bit to be safe; index in lower byte, data in upper
    //
    REG_WR08(addr, datum & 0xFF);
    REG_WR08(addr+1, (datum >> 8) & 0xFF);
}                          


// Write a data byte to Priveledged IO
//
// Entry: U032 addr                // Address of Controller Register
//        U008 datum               // Data to write to SR/GR/CR
//
// Exit:  none
//
VOID WritePriv08(U032 addr, U008 datum)
{                                    
    REG_WR08(addr, datum);
}                          

//
// Read a data word from Priveledged IO
//
// Entry: U032 addr                // Address of controller register
//        U008 reg                 // CR/GR/SR register to read
//
// Exit:  index/data pair
//
U016 ReadIndexed(U032 addr, U008 reg)
{      
    U016 datum;
              
    //
    // Return the data in the upper byte, index in the lower
    //
    REG_WR08(addr, reg);
    datum = (REG_RD08(addr+1) << 8) & 0xFF00;
    datum |= reg;
    
    return(datum);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\incvxd\old\VPICD.H ===
#ifndef _VPICD_H_
#define _VPICD_H_
/******** Operating System Interface for NVidia Hardware Simulator  ********\
*                                                                           *
* Module: VPICD.H                                                           *
*       Header file for Virtual PIC device.                                 *
*                                                                           *
*---------------------------------------------------------------------------*
*                                                                           *
* History:                                                                  *
*        David Schmenk (dschmenk)     10/12/94 - wrote it                   *
*                                                                           *
\*********************** Copyright 1994 NVidia, Inc. ***********************/

//---------------------------------------------------------------------------
//
//  Defines.
//
//---------------------------------------------------------------------------

//
// Output of picGetStatus()
//
#define VPICD_Stat_IRET_Pending     0x01
#define VPICD_Stat_IRET_Pending_Bit 0
#define VPICD_Stat_In_Service	    0x02
#define VPICD_Stat_In_Service_Bit   1
#define VPICD_Stat_Phys_Mask	    0x04
#define VPICD_Stat_Phys_Mask_Bit    2
#define VPICD_Stat_Phys_In_Serv     0x08
#define VPICD_Stat_Phys_In_Serv_Bit 3
#define VPICD_Stat_Virt_Mask	    0x10
#define VPICD_Stat_Virt_Mask_Bit    4
#define VPICD_Stat_Virt_Req         0x20
#define VPICD_Stat_Virt_Req_Bit     5
#define VPICD_Stat_Phys_Req	        0x40
#define VPICD_Stat_Phys_Req_Bit     6
#define VPICD_Stat_Virt_Dev_Req     0x80
#define VPICD_Stat_Virt_Dev_Req_Bit 7
//
// Options in IRQ Descriptor
//
#define VPICD_Opt_Read_Hw_IRR       0x01
#define VPICD_Opt_Read_Hw_IRR_Bit   0
#define VPICD_Opt_Can_Share         0x02
#define VPICD_Opt_Can_Share_Bit     1
//
// IRQ descriptor.
//
struct VPICD_IRQ_Descriptor
{
    WORD  VID_IRQ_Number;
    WORD  VID_Options;
    DWORD VID_Hw_Int_Proc;
    DWORD VID_Virt_Int_Proc;
    DWORD VID_EOI_Proc;
    DWORD VID_Mask_Change_Proc;
    DWORD VID_IRET_Proc;
    DWORD VID_IRET_Time_Out;
};
//
// VPICD service defines.
//
#define VPICD_Get_Version               0x0000
#define VPICD_Virtualize_IRQ            0x0001
#define VPICD_Set_Int_Request           0x0002
#define VPICD_Clear_Int_Request         0x0003
#define VPICD_Phys_EOI                  0x0004
#define VPICD_Get_Complete_Status       0x0005
#define VPICD_Get_Status                0x0006
#define VPICD_Test_Phys_Request         0x0007
#define VPICD_Physically_Mask           0x0008
#define VPICD_Physically_Unmask         0x0009
#define VPICD_Set_Auto_Masking          0x000A
#define VPICD_Get_IRQ_Complete_Status   0x000B
#define VPICD_Convert_Handle_To_IRQ     0x000C
#define VPICD_Convert_IRQ_To_Int        0x000D
#define VPICD_Convert_Int_To_IRQ        0x000E
#define VPICD_Call_When_Hw_Int          0x000F
#define VPICD_Force_Default_Owner       0x0010
#define VPICD_Force_Default_Behavior    0x0011
#define VPICD_Auto_Mask_At_Inst_Swap    0x0012
#define VPICD_Begin_Inst_Page_Swap      0x0013
#define VPICD_End_Inst_Page_Swap        0x0014
//
// VID callback routines.
//
#pragma aux VPICD_INT   parm [EAX] [EBX];
//
// Make functions to these services.
//
WORD  picGetVersion(VOID);
DWORD picVirtualizeIRQ(struct VPICD_IRQ_Descriptor *);
VOID  picSetIntRequest(DWORD, DWORD);
VOID  picClearIntRequest(DWORD, DWORD);
VOID  picPhysEOI(DWORD);
DWORD picGetCompleteStatus(DWORD, DWORD);
DWORD picGetStatus(DWORD, DWORD);
DWORD picTestPhysRequest(DWORD);
VOID  picPhysicallyMask(DWORD);
VOID  picPhysicallyUnmask(DWORD);
VOID  picSetAutoMasking(DWORD);
DWORD picGetIRQCompleteStatus(DWORD, DWORD);
DWORD picGetIRQVirtualizedStatus(DWORD, DWORD);
DWORD picConvertHandleToIRQ(DWORD);
DWORD picConvertIRQToInt(DWORD, DWORD);
DWORD picConvertntToIRQ(DWORD);
DWORD picCallWhenHwInt(DWORD);
DWORD picForceDefaultOwner(DWORD, DWORD);
VOID  picForceDefaultBehavior(DWORD);

#pragma aux picGetVersion =                                 \
            CALL_VXD(VPICD_Device_ID, VPICD_Get_Version)    \
            value [AX];

#pragma aux picVirtualizeIRQ =                              \
            CALL_VXD(VPICD_Device_ID, VPICD_Virtualize_IRQ) \
            parm [EDI]                                      \
            value [EAX];

#pragma aux picSetIntRequest =                              \
            CALL_VXD(VPICD_Device_ID, VPICD_Set_Int_Request)\
            parm [EAX] [EBX];

#pragma aux picClearIntRequest =                            \
            CALL_VXD(VPICD_Device_ID, VPICD_Clear_Int_Request)\
            parm [EAX] [EBX];

#pragma aux picPhysEOI =                                    \
            CALL_VXD(VPICD_Device_ID, VPICD_Phys_EOI)       \
            parm [EAX];

#pragma aux picGetCompleteStatus =                          \
            CALL_VXD(VPICD_Device_ID, VPICD_Get_Complete_Status)\
            parm [EAX] [EBX]                                \
            value [ECX];

#pragma aux picGetStatus =                                  \
            CALL_VXD(VPICD_Device_ID, VPICD_Get_Status)     \
            parm [EAX] [EBX]                                \
            value [ECX];

#pragma aux picTestPhysRequest =                            \
            CALL_VXD(VPICD_Device_ID, VPICD_Test_Phys_Request)\
            parm [EAX]                                      \
            value [EAX];

#pragma aux picPhysicallyMask =                             \
            CALL_VXD(VPICD_Device_ID, VPICD_Physically_Mask)\
            parm [EAX];

#pragma aux picPhysicallyUnmask =                           \
            CALL_VXD(VPICD_Device_ID, VPICD_Physically_Unmask)\
            parm [EAX];

#pragma aux picSetAutoMasking =                             \
            CALL_VXD(VPICD_Device_ID, VPICD_Set_Auto_Masking)\
            parm [EAX];

#pragma aux picGetIRQCompleteStatus =                       \
            CALL_VXD(VPICD_Device_ID, VPICD_Get_IRQ_Complete_Status)\
            parm [EAX] [EBX]                                 \
            value [ECX];

#pragma aux picGetIRQVirtualizedStatus =                       \
            CALL_VXD(VPICD_Device_ID, VPICD_Get_IRQ_Complete_Status)\
            "sbb    EAX, EAX"                               \
            parm [EAX] [EBX]                                 \
            value [EAX];

#pragma aux picConvertHandleToIRQ =                         \
            CALL_VXD(VPICD_Device_ID, VPICD_Convert_Handle_To_IRQ)\
            parm [EAX]                                      \
            value [ESI];

#pragma aux picConvertIRQToInt =                            \
            CALL_VXD(VPICD_Device_ID, VPICD_Convert_IRQ_To_Int)\
            parm [EAX] [EBX]                                \
            value [EAX];
            
#pragma aux picConvertIntToIRQ =                            \
            CALL_VXD(VPICD_Device_ID, VPICD_Convert_Int_To_IRQ)\
            parm [EAX]                                      \
            value [EAX];

#pragma aux picCallWhenHwInt =                              \
            CALL_VXD(VPICD_Device_ID, VPICD_Call_When_Hw_Int)\
            parm [ESI]                                      \
            value [ESI];

#pragma aux picForceDefaultOwner =                          \
            CALL_VXD(VPICD_Device_ID, VPICD_Force_Default_Owner)\
            parm [EAX] [EBX]                                \
            value [EAX];

#pragma aux picForceDefaultBehavior =                      \
            CALL_VXD(VPICD_Device_ID, VPICD_Force_Default_Behavior)\
            parm [EAX];

#endif // _VPICD_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\modeset\MODES.H ===
//
// MODES.H - Header file for mode sets in 'C'.
//
// Copyright (c) 1997 - NVidia Corp.
// All Rights Reserved.
//
// Defines and structures for use with the 'C' based modeset code.
//                
//

//  TVformat types
#define NTSC    0
#define PAL     1
//  TV encoders
#define NO_ENCODER 0
#define BROOKTREE  1
#define CHRONTEL   2
#define BROOKTREE_ID    0x8A
#define CHRONTEL_ID     0xEA

#ifdef DOS_COMPILE
typedef unsigned long U032;
typedef unsigned short U016;
typedef unsigned char U008;
typedef unsigned long V032;
typedef unsigned short V016;
typedef unsigned char V008;
#define VOID void
#endif


#define PACKED  0
#define PLANAR  1

#define NVRM_ACCESS         0x38
#define NVRM_ACCESS_MASK    0x01
#define NVRM_IDENT          0x00
#define NVRM_ADDRESS        0x02
#define NVRM_DATA           0x04
#define NVRM_DATA32         0x06
#define NVRM_SELECT_MASK    0x06    // Mask for decode bits
#define NVRM_SELECT         0x01    // Least signifcant bit is 1

#ifdef DOS_COMPILE
//                                           
// These defines are the standard NV defines... the appropriate include
// file should be utilized, rather than these values.
//
#define DRF_SHIFT(drf)          ((0?drf) % 32)
#define NV_PDFB_DATA032                    0x01000000 /* RW-4A */
#define NV_PFB_BOOT_0_RAM_AMOUNT_1MB       0x00000000 /* RW--V */
#define NV_PFB_BOOT_0_RAM_AMOUNT_2MB       0x00000001 /* RW--V */
#define NV_PFB_BOOT_0_RAM_AMOUNT_4MB       0x00000002 /* RW--V */
#define NV_PRMVIO_MISC__WRITE              0x000C03c2 /* -W-1R */
#define NV_PRMVIO_SRX                      0x000C03c4 /* RW-1R */
#define NV_PRMVIO_GRX                      0x000C03ce /* RW-1R */
#define NV_PFB_BOOT_0                      0x00100000 /* RW-4R */
#define NV_PFB_CONFIG_0                    0x00100200 /* RW-4R */
#define NV_PRMCIO_ARX                      0x006013c0 /* RW-1R */
#define NV_PRMCIO_AR_PALETTE__WRITE        0x006013c0 /* -W-1R */
#define NV_PRMCIO_AR_PALETTE__READ         0x006013c1 /* R--1R */
#define NV_PRMCIO_CRX__COLOR               0x006013d4 /* RW-1R */
#define NV_PRMCIO_INP0__COLOR              0x006013da /* R--1R */
#define NV_PRAMDAC_VPLL_COEFF              0x00680508 /* RW-4R */
#define NV_PRAMDAC_PLL_COEFF_SELECT        0x0068050C /* RW-4R */
#define NV_PRAMDAC_GENERAL_CONTROL         0x00680600 /* RW-4R */
#define NV_PRAMDAC_GENERAL_CONTROL_PIXMIX        5:4  /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_VGA_STATE     8:8  /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_ALT_MODE     12:12 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_BPC          20:20 /* RWIVF */
#define NV_USER_DAC_PIXEL_MASK             0x006813C6 /* RWI1R */
#define NV_USER_DAC_READ_MODE_ADDRESS      0x006813C7 /* RW-1R */
#define NV_USER_DAC_WRITE_MODE_ADDRESS     0x006813C8 /* RW-1R */
#define NV_USER_DAC_PALETTE_DATA           0x006813C9 /* RW-1R */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VCLK_RATIO  28:28 /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VPLL_SOURCE 16:16 /* RWIVF */
#define NV_PFB_CONFIG_0_TILING                  12:12 /* RWIVF */
#define NV_PFB_CONFIG_0_TILING_DISABLED    0x00000001 /* RWI-V */

#define NV_PRAMDAC_VPLL_COEFF              0x00680508 /* RW-4R */
#define NV_PRMVIO_MISC__READ               0x000C03CC 
#define NV_PRMVIO_SR_CLOCK_INDEX           0x000C03C5
#define NV_CIO_CRE_ILACE__INDEX            0x039
#define NV_CIO_CR_VRE_INDEX                0x011
#define NV_CIO_CRE_PIXEL_INDEX             0x028
#define NV_CIO_CRE_DEC__INDEX              0x029
#define NV_CIO_CR_HDT_INDEX                0x0
#define NV_CIO_CR_HDE_INDEX                0x1
#define NV_CIO_CR_HBS_INDEX                0x2
#define NV_CIO_CR_HBE_INDEX                0x3
#define NV_CIO_CR_HRS_INDEX                0x4
#define NV_CIO_CR_HRE_INDEX                0x5
#define NV_CIO_CR_VDT_INDEX                0x6
#define NV_CIO_CR_OVL_INDEX                0x7
#define NV_CIO_CR_VRS_INDEX                0x10
#define NV_CIO_CR_VDE_INDEX                0x12
#define NV_CIO_CR_VBS_INDEX                0x15
#define NV_CIO_CR_VBE_INDEX                0x16
#define NV_PRAMDAC_HSYNC_WIDTH             0x00680720 /* RW-4R */
#define NV_PRAMDAC_HBURST_START            0x00680724 /* RW-4R */
#define NV_PRAMDAC_HBLANK_START            0x0068072C /* RW-4R */
#define NV_PRAMDAC_HTOTAL                  0x00680734 /* RW-4R */
#define NV_PRAMDAC_HEQU_WIDTH              0x00680738 /* RW-4R */
#define NV_PRAMDAC_HSERR_WIDTH             0x0068073C /* RW-4R */
#define NV_PMC_ENABLE                      0x00000200 /* RW-4R */
#define NV_PEXTDEV_BOOT_0                  0x00101000 /* RW-4R */
#define NV_PRAMDAC_MPLL_COEFF              0x00680504 /* RW-4R */
#define NV_USER_DAC_PIXEL_MASK             0x006813C6 /* RWI1R */
#define NV_USER_DAC_READ_MODE_ADDRESS      0x006813C7 /* RW-1R */
#define NV_USER_DAC_WRITE_MODE_ADDRESS     0x006813C8 /* RW-1R */
#define NV_USER_DAC_PALETTE_DATA           0x006813C9 /* RW-1R */
#endif // DOS_COMPILE

                                                   
#define CRYSTAL_FREQ143         14318180           // 14.318,180 MHz
#define CRYSTAL_FREQ135         13500000           // 13.500,180 MHz
#define CRYSTAL_FREQ143KHZ      14318              // 14318 kHz
#define CRYSTAL_FREQ135KHZ      13500              // 13500 kHz

//
// VBE3.0-based CRTC Timings Table
//
typedef struct gtf_timings_structure
{
    U016	horiz_total;
	U016	horiz_start;
	U016	horiz_end;
	U016	vertical_total;
	U016	vertical_start;
	U016	vertical_end;
	U008	flags;
	U032	dot_clock;
	U016	refresh;
} GTF_TIMINGS, *PGTF_TIMINGS;

//
// DMT Override Table
//
typedef struct DMT_Overrides_structure
{
    U016    DotClock;
    U016    Polarity;
    U016    CR0;
    U016    CR2;
    U016    CR3;
    U016    CR4;
    U016    CR5;
    U016    CR6;
    U016    CR7;
    U016    CR10;
    U016    CR11;
    U016    CR15;
    U016    CR16;

} DMT_OVERRIDES, *PDMT_OVERRIDES;

//
// State flags for GTF structure
//
#define GTF_FLAGS_SINGLE_SCANNED    0x00
#define GTF_FLAGS_DOUBLE_SCANNED    0x01
#define GTF_FLAGS_NON_INTERLACED    0x00
#define GTF_FLAGS_INTERLACED        0x02
#define GTF_FLAGS_HSYNC_POSITIVE    0x00
#define GTF_FLAGS_HSYNC_NEGATIVE    0x04 
#define GTF_FLAGS_VSYNC_POSITIVE    0x00
#define GTF_FLAGS_VSYNC_NEGATIVE    0x08

// Indexes into the clock table 
#define MAX_DCLK    0x1F            // 229.50 Mhz
#define MAX_ATC     0x16            // 108 Mhz
                                   
#define    CLKID_50_35     0x00
#define    CLKID_56_64     0x01
#define    CLKID_33_25     0x02
#define    CLKID_52        0x03
#define    CLKID_80        0x04
#define    CLKID_63        0x05
#define    CLKID_EXT       0x06
#define    CLKID_75        0x07
#define    CLKID_25_175    0x08
#define    CLKID_28_322    0x09
#define    CLKID_31_5      0x0A
#define    CLKID_36        0x0B
#define    CLKID_40        0x0C
#define    CLKID_44_9      0x0D
#define    CLKID_50        0x0E
#define    CLKID_65        0x0F
#define    CLKID_108       0x10        // Requires clock doubler
#define    CLKID_135       0x11        // Requires clock doubler
#define    CLKID_49_5      0x12            
#define    CLKID_56_25     0x13
#define    CLKID_78_75     0x14
#define    CLKID_94_5      0x15
#define    CLKID_108_5     0x16        // Requires clock doubler
#define    CLKID_35_5      0x17            
#define    CLKID_158       0x18        // Requires clock doubler
#define    CLKID_55_86     0x19            
#define    CLKID_20        0x1A
#define    CLKID_27_93     0x1B
#define    CLKID_32_5      0x1C
#define    CLKID_12_588    0x1D
#define    CLKID_81_62     0x1E            
#define    CLKID_219_566   0x1F            
#define    CLKID_172_798   0x20            
#define    CLKID_193_156   0x21            
#define    CLKID_229_5     0x22
#define    CLKID_266_95    0x23

// Video Mode Control Structure
typedef struct _vmode_
{
    U016  mdVMode;                // Mode Number of this mode
    U008   mdMode;                 // Internal Mode Number
    U008   mdIMode;                // Standard Mode Table Index
    U008   mdEMode;                // Extended Mode Table Index
    U008   mdTVMode;               // TV Mode Table Index
    U008   mdCMode;                // Extended CRTC Override Index
    U008   mdBPP;                  // Bits per Pixel
    U016  mdXRes;                 // X resolutio
    U016  mdYRes;                 // Y resolutionn
    U016  mdRowOff;               // Scanline Row Offset
    U016  mdMaxDotClock;          // Maximum DCLK
    
} MODEDESC;                            

  
typedef struct _ext_regs_
{
                            // ++++------- Reserved
                            // |||| +----- NV_PRAMDAC_GENERAL_CONTROL[20] - DAC Width
                            // |||| |+---- CR1C[2] - Sequential Chain 4
                            // |||| ||+--- CR1C[1] - Page Select Control
                            // |||| |||+-- CR1A[0] - Address Wrap
    U008   xrFlags;         // VVVV VVVV
                            // 7654 3210
                            
                            // +---------- NV_PRAMDAC_GENERAL_CONTROL[12] - 565_MODE
                            // |+++------- NV_PRAMDAC_GENERAL_CONTROL[20] - DAC Width
                            // |||| +----- CR25[5] - Bit 11 of offset
                            // |||| |+++-- CR19[7:5] - Bits 8->10 of Offset
    U008   xrOffset;        // VVVV VVVV               
                            // 7654 3210
                            
                            // ++--------- CR2D[3:2] - Bit 8 of HRetrace & HBlank Starts
                            // ||+-------- CR1A[2] - Large Screen bit
                            // |||+------- CR25[4] - Bit 6 of HBlank End
                            // |||| ++---- Bit 10 of VBlank & VRetrace Start
                            // |||| ||++-- VDisp End, VTotal
    U008   xrVOver;         // VVVV VVVV                         
                            // 7654 3210

                            // ++--------- CR2D[1:0] - Bit 8 of DHisp End and HTotoal
                            // ||++------- CR1C[4:3] - Optimized chain-4 write/read access
                            // |||| +----- CR28[3] - NV_PRAMDAC_PLL_COEFF_SELECT[28]
                            // |||| |                VCLK Divide by 1 or 2
                            // |||| |+---- CR28[2] - Linear/Tile mode
                            // |||| ||++-- CR28[1:0] - Pixel Format
    U008   xrPixFmt;        // VVVV VVVV                         
                            // 7654 3210
                            
    U008   xrVOffset;      // CR13 - VGA Offset register
    U008   xrIntlace;      // CR39 - Interlace Half Field Start
    U016  xrRegenLength;   // Override of PT_RegenLength (res+color depth specific)
    U008   xrClkSel;       // Pixel Clock Select
    
} EXTREGS;                              

typedef struct _tv_regs_
{
    U008   tvIntlace;              // CRTC[39] (Interlace Half Field Start)
    U008   tvDecimate_NTSC;        // CRTC[29] (Decimate for TV)
    U008   tvHT_NTSC;              // CRTC[00] (Horiztonal total for NTSC)
    U008   tvHRS_NTSC;             // CRTC[04] (Horizontal retrace start for NTSC)
    U008   tvVT_NTSC;              // CRTC[06] (Vertical total for NTSC)
    U008   tvVO_NTSC;              // CRTC[07] (Vertical overflow for NTSC)
    U008   tvVRS_NTSC;             // CRTC[10] (Vertical retrace start for NTSC)
    U008   tvHDE_NTSC;             // CRTC[01] (Horizontal Display End)
    U008   tvHBS_NTSC;             // CRTC[02] (Horizontal Blank Start)
    U008   tvHBE_NTSC;             // CRTC[03] (Horizontal Blank End)
    U008   tvHRE_NTSC;             // CRTC[05] (Horizontal Retrace End)
    U008   tvVRE_NTSC;             // CRTC[11] (Vertical Retrace End)
    U008   tvVDE_NTSC;             // CRTC[12] (Vertical Display End)
    U008   tvVBS_NTSC;             // CRTC[15] (Vertical Blank Start)
    U008   tvVBE_NTSC;             // CRTC[16] (Vertical Blank End)
    U008   tvDecimate_PAL;         // CRTC[29] (Decimate for TV)
    U008   tvHT_PAL;               // CRTC[00] (Horiztonal total for PAL)
    U008   tvHRS_PAL;              // CRTC[04] (Horizontal retrace start for PAL)
    U008   tvVT_PAL;               // CRTC[06] (Vertical total for PAL)
    U008   tvVO_PAL;               // CRTC[07] (Vertical overflow for PAL)
    U008   tvVRS_PAL;              // CRTC[10] (Vertical retrace start for PAL)
    U008   tvHDE_PAL;              // CRTC[01] (Horizontal Display End)
    U008   tvHBS_PAL;              // CRTC[02] (Horizontal Blank Start)
    U008   tvHBE_PAL;              // CRTC[03] (Horizontal Blank End)
    U008   tvHRE_PAL;              // CRTC[05] (Horizontal Retrace End)
    U008   tvVRE_PAL;              // CRTC[11] (Vertical Retrace End)
    U008   tvVDE_PAL;              // CRTC[12] (Vertical Display End)
    U008   tvVBS_PAL;              // CRTC[15] (Vertical Blank Start)
    U008   tvVBE_PAL;              // CRTC[16] (Vertical Blank End)
    
} TVREGS;

typedef struct _vesamodeentry_
{
    U016    vesa_mode_number;
    U008    tv_mode_number;
} VESAMODEENTRY;

 
// CRTC Override Structure. This structure overrides the settings selected
// from the standard modeset mode table.
//
typedef struct _crtc_ovr_
{
    U008   columns;
    U008   rows;
    U008   char_height;
    U008   CO_Misc;                // Misc Register
    U008   CO_ClockMode;           // SR1
    U008   HTotal;                 // CR00
    U008   HDispEnd;               // CR01
    U008   HBlankS;                // CR02
    U008   HBlankE;                // CR03
    U008   HSyncS;                 // CR04
    U008   HSyncE;                 // CR05
    U008   VTotal;                 // CR06
    U008   Overflow;               // CR07
    U008   CO_CellHeight;          // CR09
    U008   CO_VSyncStart;          // CR10
    U008   VSyncE;                 // CR11
    U008   VDispE;                 // CR12
    U008   CO_VBlankStart;         // CR15
    U008   VBlandE;                // CR16
                                              
}CRTC_OVERRIDE;

//
// Fifo settings
//
typedef struct _modeset_fifo_
{
    U016  Freq;                   // Maximum frequency for these water marks
    U008   LowWaterMark64;         // Low water mark for 64 bit bus
    U008   BurstSize64;            // Burst size for 64 bit bus
    U008   LowWaterMark128;        // Low water mark for 128 bit bus
    U008   BurstSize128;           // Burst size for 128 bit bus
                                      
} MODESET_FIFO;

//
// CRTC access state (for dos compile)
//
typedef struct _save_astate_
{
    U016   crtc_addr;          // CRTC Address
    U032   nv_address;         // 32-bit NV address
    U008   access_bits;        // Access Control Bits
    U008   access_reg;         // Access Register (NVRM_ACCESS)
    U016   data_low;           // Low 32-bits of data register
} ACCESS_STATE;

//  I2C defines

#define DEBUG0                  0	// print download byte
#define DEBUG1                  0	// print bit
#define DEBUG2                  0	// print ack/no ack
#define DEBUG3                  0	// create strobe on pins 16 & 17
#define DEBUG4                  0	// print reback diags

#define CRTC_INDEX  0x3D4
#define CRTC_DATA   0x3D5
#define DDC_STATUS  0x3E
#define DDC_WRITE   0x3F    // bit 5 = clock, bit 4 = data, bit 0 = enable

#define write_port	0x3d5   // 
#define read_port	0x3d5	// 

#define SCLOCK		0x04	// read scl
#define SDATA		0x20	// read sda (latched data)
#define SDATA_BIT   5
#define clockhi		0x21	// 'or' to set high
#define clocklo		0xDF	// 'and' to set low
#define clrdata		0xEF	// 'and' this to clear the data bit
#define setdata		0x11	// 'or' this to set the data bit

#define i2c_state0	0x31	// clock and data high
#define i2c_state1	0x21	// clock high, data low
#define i2c_state2	0x01	// clock and data low

#define clock0_lo	0x01	// clock and data low
#define clock0_hi	0x11	// clock low, data hi
#define clock1_lo	0x21	// clock high, data low
#define clock1_hi	0x31	// clock and data high

#define ack_state0	0x11	// clock low, data hi
#define ack_state1	0x31	// clock and data high
#define ack_state2	0x11	// clock low, data hi

#define data_in     0x08    // SDA
#define clock_in    0x04    // SCL

//#define KHz400		1250/200
#define I2C_DELAY		1250/200


//
// Modeset function prototypes
//
VOID NvPost(VOID);
U016 VBESetMode(U016, PGTF_TIMINGS,PDMT_OVERRIDES,U016);         // VESA SetMode
U016 VBESetRefresh(PGTF_TIMINGS);
MODEDESC *ValidateMode(U016 );    // Validate VESA Mode
U008 isTV(VOID);
U008 isPAL(VOID);
U008 OEMValidateMode(MODEDESC *);
U016 OEMGetMemSize(VOID);
VOID SaveNVAccessState(ACCESS_STATE *);
VOID RestoreNVAccessState(ACCESS_STATE *);
//KYH U032 ReadPriv32(U032 );
//KYH U016 ReadIndexed(U032 , U008 );
VOID OEMDisableExtensions(VOID);
VOID OEMEnableExtensions(VOID);
VOID WriteIndexed(U032, U016);
VOID OEMPreSetRegs(VOID);
VOID SetRegs(MODEDESC *);
VOID LoadIndexRange(U032, U008, U008, U008 *);
VOID ATCOff(VOID);
VOID ATCOn(VOID);
VOID OEMSetRegs(MODEDESC *);
VOID FullCpuOn(VOID);
VOID FullCpuOff(VOID);
U032 CalcMNP(U016 *);
VOID OEMSetClock(U016 );
//KYH VOID WritePriv32(U032 , U032 );
VOID LoadDefaultATCAndSavePtr(U008 *);
VOID LoadDefaultRAMDAC(MODEDESC *);
VOID LoadPalette(MODEDESC *);
VOID LoadColorDACTable(VOID);
VOID LoadColor256DAC(VOID);
VOID LoadIdentityDAC(VOID);
VOID WriteColor(U008 );
VOID WriteColor2(U016 , U016 , U016 , U016 );
VOID FixLowWaterMark(U016 );
VOID SetDACClock(U032 );
//KYH VOID WritePriv08(U032 , U008 );
U016 h2i(U008 *);                // Hex 2 Integer

typedef struct
{
    U008    SR01;
    U008    CR00;
    U008    CR04;
    U008    CR06;
    U008    CR07;
    U008    CR08;
    U008    CR10;
    U008    CR12;
    U008    CR25;
    U008    CR28;
} CH_ADJ;      

typedef struct
{
    U008    SR01;
    U008    CR00;
    U008    CR04;
    U008    CR06;
    U008    CR07;
    U008    CR08;
    U008    CR10;
    U008    CR12;
} BT_ADJ;

//typedef struct _I2C_string_struct_
typedef struct 
{
    U008    Dev;
    U008    Reg0;
    U008    Data0;
    U008    Reg7;
    U008    Data7;
    U008    Reg8;
    U008    Data8;
    U008    RegA;
    U008    DataA;
    U008    RegB;
    U008    DataB;
    U008    Reg13;
    U008    Data13;
    U008    Data14;
    U008    Data15;
} I2C_string, *PI2C_string;
    
    
//  Brooktree values -- 1 byte device ID, 6 bytes centering info, 33 bytes resolution info
typedef struct 
{
    U008    Dev;
    U008    btc1;
    U008    btc2;
    U008    btc3;
    U008    btc4;
    U008    btc5;
    U008    btc6;
    U008    bt1;
    U008    bt2;
    U008    bt3;
    U008    bt4;
    U008    bt5;
    U008    bt6;
    U008    bt7;
    U008    bt8;
    U008    bt9;
    U008    bt10;
    U008    bt11;
    U008    bt12;
    U008    bt13;
    U008    bt14;
    U008    bt15;
    U008    bt16;
    U008    bt17;
    U008    bt18;
    U008    bt19;
    U008    bt20;
    U008    bt21;
    U008    bt22;
    U008    bt23;
    U008    bt24;
    U008    bt25;
    U008    bt26;
    U008    bt27;
    U008    bt28;
    U008    bt29;
    U008    bt30;
    U008    bt31;
    U008    bt32;
    U008    bt33;
    U008    termination;
} BT_string, *PBT_string;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\modeset\modehw.h ===
//
// MODEHW.H - Header file for OS specific portions of mode sets in 'C'.
//
// Copyright (c) 1997 - NVidia Corp.
// All Rights Reserved.
//
// Defines for accessing NV registers in the 'C' based modeset code.
//                
//
VOID OEMEnableExtensions(VOID);
VOID OEMDisableExtensions(VOID);
VOID WriteFb32(U032 datum, U032 addr);
U032 ReadFb32(U032 addr);
VOID WritePriv32(U032 datum, U032 addr);
U032 ReadPriv32(U032 addr);
VOID WriteIndexed(U032 addr, U016 datum);
VOID WritePriv08(U032 addr, U008 datum);
U016 ReadIndexed(U032 addr, U008 reg);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\modeset\MODESET.C ===
//
// modeset.c -  Program to set a VESA mode. Assumes the controller is
//              already initialized.
//
// Copyright (c) 1997-2000 - NVidia Corporation. All Rights Reserved.
//
#ifdef DOS_COMPILE
#include    <stdio.h>
#include    <stdlib.h>
#else
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <os.h>
#include <vga.h>
#include <i2c.h>
#endif // DOS_COMPILE
                
#include    "modes.h"
#include    "modedata.c"
#include	"modehw.h"
#include "nvhw.h"
#include "dac.h"
#include "nvcm.h"

#define ERR_I2C_MODE    1
#define ERR_I2C_COMM    2
#define ERR_I2C_UNKNOWN 3


U016 setI2C(MODEDESC *);
VOID ProgramTV(	U008 tvmode );
U016 programBrooktree(U016 TVmode);
U016 programChrontel(U016 TVmode);
VOID SetDMTOverrideValues(PDMT_OVERRIDES pDMTOverrides);
VOID output(U016, U008);
U008 input(U016);
VOID DDCout(U008);
U008 DDCin();
VOID FlatPanelCrtc();
U008 getDisplayType();
// U032 GetDefaultPosition();
// VOID SaveDefaultPosition();

//JJV-New Registry Process extern char strDevNodeDisplay[];
//JJV-New Registry Process extern char strDisplayType[];
//JJV-New Registry Process extern char strTVtype[];

//U008        DisplayType;
#ifndef PAL // just in case you want to default to PAL
U008        TVformat = NTSC;    
#else
U008        TVformat = PAL;
#endif

//
// VBE Function 02h - Vesa SetMode routine.
//
// Used to set a VESA mode. This routine will not accept standard
// VGA Mode numbers, nor will it load/support fonts. This means that
// TTY output is DISABLED.
//
// Entry:   U016 mode             // VESA mode to be set
//
//          +------------------ Don't clear screen (1=Save Screen)
//          |+----------------- Linear Frame Buffer (1=Enable)
//          ||++--------------- Reserved for VBE/AF 
//          ||||+-------------- User Refresh (1=User Specified)
//          |||||++------------ Reserved
//          |||||||+-++++++++-- Mode Number
//          VVVVVVVV VVVVVVVV
//          00000000 00000000
//
//          111111           
//          54321098 76543210
//
//          CRTCInfoBlk *cib        // Pointer to CRTCInfoBlock Structure
//
// Exit:    U016 rc               // VESA Error Status
//                                                  

U016 VBESetMode(U016 mode, PGTF_TIMINGS timings, PDMT_OVERRIDES pDMTOverrides, U016 UseDmtFlag)
{
    MODEDESC    *minfo;             // Mode Information
    U016        wv;
    U016        rc = 0x014F;        // Default to FAIL
    U016        status;
    U016        shadow, data;
    U032        data32;
    U008        data8;

    // initDac has set the pDev variable to the correct display type based on what the bios says.
    // If it is TV, setup the format.
    if (pDev->Framebuffer.DisplayType == DISPLAY_TYPE_TV)
    {
        mode &= ~0x800;     // do not use custom refresh rates
        if(pDev->Framebuffer.MonitorType == MONITOR_TYPE_PAL)
        {
            TVformat = PAL;
        }
        else       
        {
            TVformat = NTSC;
        }
    }        

    // check for registry override for TV type (PAL/NTSC)
    if (osReadRegistryDword(pDev->Registry.DBstrDevNodeDisplay, strTVtype, &data32) == RM_OK)
    {
        if (data32 == 0)
            TVformat = NTSC;
        if (data32 == 1)
        {
            TVformat = PAL;
            pDev->Framebuffer.MonitorType = MONITOR_TYPE_PAL;   // tell display driver what type of display
        }
    }
    // check for registry override for display type (TV/MONITOR/BOTH)
    if (osReadRegistryDword(pDev->Registry.DBstrDevNodeDisplay, strDisplayType, &data32) == RM_OK)
    {
        switch (data32)
        {
            case DISPLAY_TYPE_MONITOR:
                pDev->Framebuffer.DisplayType = DISPLAY_TYPE_MONITOR;
                // we're overriding, so change to monitor timing. The following code assumes this is set correctly.
                CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, data8);
                data8 &= 0x3f;
                CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, data8);
                pDev->Framebuffer.MonitorType = MONITOR_TYPE_VGA;   // tell display driver what type of display
                break;
            case DISPLAY_TYPE_TV:
                mode &= ~0x800;     // do not use custom refresh rates
                pDev->Framebuffer.DisplayType = DISPLAY_TYPE_TV;
                // we're overriding, so change to TV timing. The following code assumes this is set correctly.
                CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, data8);
                if (TVformat == NTSC)
                {
                    data8 |= 0x80; 
                    pDev->Framebuffer.MonitorType = MONITOR_TYPE_NTSC;   // tell display driver what type of display
                }
                else
                {
//                    data8 |= 0xc0; // PAL                   
                    data8 |= 0x80; // not in NV4, bit 6 is overscan color
                    pDev->Framebuffer.MonitorType = MONITOR_TYPE_PAL;   // tell display driver what type of display
                }
                CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, data8);
                break;
            case DISPLAY_TYPE_DUALSURFACE:
                pDev->Framebuffer.DisplayType = DISPLAY_TYPE_DUALSURFACE;
                break;
            case DISPLAY_TYPE_FLAT_PANEL:        
                pDev->Framebuffer.DisplayType = DISPLAY_TYPE_FLAT_PANEL;
                pDev->Framebuffer.MonitorType = MONITOR_TYPE_FLAT_PANEL;   // tell display driver what type of display
                break;
            default:
                pDev->Framebuffer.DisplayType = DISPLAY_TYPE_MONITOR;
        }
    }
    // check whether monitor is a flat panel
    if (pDev->Framebuffer.DisplayType == DISPLAY_TYPE_FLAT_PANEL)
    {
             // de-couple vertical sync from flat panel while setting mode
            data32 = REG_RD32(NV_PRAMDAC_FP_DEBUG_0); // usual macro won't help us here
            data32 |= (NV_PRAMDAC_FP_DEBUG_0_TEST_NEWPIX << 16);   // set VCLK bits
            REG_WR32(NV_PRAMDAC_FP_DEBUG_0, data32);
    }
    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "Setting mode ",mode);

    OEMEnableExtensions();          // Unlock the registers
    shadow = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x21);        // read shadow lock (is there really no define for this reg?)

    data = shadow | 0xC800;         // Enable loading of CRTC's: bit 7 Horiz shadow, bit 3 Vert shadow
                                    // bit 6 = scanline doubling shadow
    WriteIndexed(NV_PRMCIO_CRX__COLOR, data);

    if (pDev->Framebuffer.DisplayType == DISPLAY_TYPE_FLAT_PANEL)
    {
        // bug workaround--disable scanline doubling and then shadow it. This allows writes to CR09 to affect the CRTC,
        //   but not the flat panel controller (else the flat panel controller may quadruple the scanline count).
        data = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x09);         // read scanline double
        WriteIndexed(NV_PRMCIO_CRX__COLOR, (data &= ~0x8000));   // clear scanline double bit

        // Wait one vsync before shadowing the scanline double bit
        while (REG_RD08(NV_PRMCIO_INP0__COLOR) & 0x08);     // wait for active display
        while (!(REG_RD08(NV_PRMCIO_INP0__COLOR) & 0x08));  // wait for retrace start
    
        // shadow = CR21
        shadow &= ~0x4000;  // shadow the scanline double bit
        WriteIndexed(NV_PRMCIO_CRX__COLOR, (shadow |= 0x8800)); // allow horiz & vert write-thru
    }    
    if ((minfo = ValidateMode((U016)(mode & 0x1FF))) != NULL)
    {                                
        // If we are requested to do DualSurface, check that the bit depth is 16.
        if (pDev->Framebuffer.DisplayType == DISPLAY_TYPE_DUALSURFACE)
            if (minfo->mdBPP != 16)
                pDev->Framebuffer.DisplayType = DISPLAY_TYPE_MONITOR;  // if not 16 bpp, we can't do it, so use monitor only
        // Program the TV encoder thru the I2C port.
        status = setI2C(minfo);  // Set up encoder. 
        if (status)
        {
            switch (status)
            {
                case ERR_I2C_MODE:
                    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "Can't program the TV encoder for mode ",mode);
                    break;
                case ERR_I2C_COMM:
                    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "I2C error programming mode ",mode);
                    break;
                case ERR_I2C_UNKNOWN:
                    DBG_PRINT_STRING (DEBUGLEVEL_WARNINGS, "NVRM: I2C error. Unknown encoder\n");
                    break;
            }                
            if (pDev->Framebuffer.DisplayType == DISPLAY_TYPE_TV)      // if flat panel, leave it that way.
                pDev->Framebuffer.DisplayType = DISPLAY_TYPE_MONITOR;  // I2C failed, set up for monitor
        }
        // Mode is maintained here, for the linear/regen flags
        // minfo now points to everything we need to program the mode.
        
        // Set the mode
        ATCOff();                   // Screen off
        OEMPreSetRegs();            // Set up DAC for programming palette.
        
        SetRegs(minfo);             // Set the VGA Registers
                                    // Always set the same packed pixel mode 
                                    // (the CRTC's will be overwritten for the particular mode later)
        FullCpuOn();
        
        OEMSetRegs(minfo);          // Set the OEM Registers
                                    //   if TV, use TV table to adjust timings).
        LoadPalette(minfo);
        
        DualSurfaceDesktop((U016)pDev->Framebuffer.DisplayType);    // Setup the DAC scan out and possibly video scalar.

        // Mode now successfully set
        // Use DMT override values instead of GTF timings
        if (UseDmtFlag && (pDev->Framebuffer.DisplayType == DISPLAY_TYPE_MONITOR))
            {
            // Mode now successfully set .. Set DMT override values
            SetDMTOverrideValues(pDMTOverrides);            
            }
            
        else
            {
            
            // Mode now successfully set .. Set GTF timings
            if ((mode & 0x0800) && timings && (pDev->Framebuffer.DisplayType == DISPLAY_TYPE_MONITOR))  // See if bit 11 is set for VBE Refresh
              VBESetRefresh(timings);        // Set the VBE 3.0 Refresh
            }
              
        FullCpuOff();
        ATCOn();

        // Save the retrace start/end values (display position default)
        dacSaveMonitorDefaultPosition(pDev);

        // See if there are any registry overrides for the desktop positioning.
        if (pDev->Framebuffer.DisplayType == DISPLAY_TYPE_MONITOR)
        {
            U032 cbLen;
            NV_CFGEX_SET_DESKTOP_POSITION_MONITOR_PARAMS position;

            cbLen = 4 * sizeof(U032);
            status = dacReadDesktopPositionFromRegistry(pDev, 
                                                        TRUE,  // isMonitor
                                                        (U008 *) &(position.HRetraceStart),
                                                        &cbLen);
            if (status == RM_OK)
            {
                // Program the new values.
                dacSetMonitorPosition(pDev, 
                                      position.HRetraceStart, position.HRetraceEnd,
                                      position.VRetraceStart, position.VRetraceEnd);
            }
        }
        // See if there are any registry overrides for the TV desktop positioning.
        // We currently only have adjustments for Brooktree.
        if ((pDev->Framebuffer.DisplayType == DISPLAY_TYPE_TV) 
        && (TV_ENCODER_FAMILY(pDev->Framebuffer.EncoderType) == TV_ENCODER_BROOKTREE))
        {
            U032 cbLen;
            NV_CFGEX_DESKTOP_POSITION_TV_PARAMS position;

            cbLen = 4 * sizeof(NV_CFGEX_DESKTOP_POSITION_TV_PARAMS);
            status = dacReadDesktopPositionFromRegistry(pDev, 
                                                        FALSE,  // isMonitor
                                                        (U008 *) &(position.HRetraceStart),
                                                        &cbLen);
            if (status == RM_OK)
            {
                // Program the new values.
                dacSetTVPosition(pDev, position.HRetraceStart, position.HRetraceEnd, position.VRetraceStart, 
                        position.VRetraceEnd, position.reg0x80, position.reg0x82, position.reg0x92, position.reg0x98, 
                        position.reg0x9A, position.reg0xC8, position.reg0xCA, position.reg0xCC);
            }
        }
        // Set the default mode if the display type is flat panel.
        if (pDev->Framebuffer.DisplayType == DISPLAY_TYPE_FLAT_PANEL)
        {
            U032 fpMode, fpMaxX, fpMaxY;
            status = dacGetFlatPanelInfo(pDev, &fpMode, &fpMaxX, &fpMaxY, 
                                         TRUE /* from registry */);
            if (status == RM_OK)
            {
                dacSetFlatPanelMode(pDev, fpMode, FALSE /* don't commit changes */);
            }
        }
                
        // Clear the DPMS State
        wv = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x1A);
        wv &= 0x3FFF;                   // Strip to standard DAC settings
        WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);

        // blank monitor if TV
        if (pDev->Framebuffer.DisplayType == DISPLAY_TYPE_TV)
            FLD_WR_DRF_DEF(_PRAMDAC, _TEST_CONTROL, _PWRDWN_DAC, _OFF);
        else
            FLD_WR_DRF_DEF(_PRAMDAC, _TEST_CONTROL, _PWRDWN_DAC, _ON);

        rc &= 0x00FF;               // Clear error status
    }                                   
    if (pDev->Framebuffer.DisplayType == DISPLAY_TYPE_TV)
    {
        shadow &= ~0x8000;          // shadow Horiz only
        WriteIndexed(NV_PRMCIO_CRX__COLOR, shadow);     // restore the shadow lock
    }
    OEMDisableExtensions();         // Lock the registers
    
    return(rc);                     // Mode Not Supported
}          

//
// Program the CRTC timing values given by the GTF parameters
//
// WARNING: This is not going to be pretty!!
// TODO: Clean the code to be more straightforward.
//
U016 VBESetRefresh(PGTF_TIMINGS timings)
{

    U032 val32;
    U016 val16, val16b, val16c;
    U008 val08;
    U016 pixperclk;
    U016 border;
    U008 ov07, ov25, ov2D;
    U016 horiz_total;
    U016 hbe;


    //
    // Program the new clocks
    //
    OEMSetClock((U016)(timings->dot_clock / 10000));

    /*
        ; Program new horizontal sync polarity
        mov     bl, [edi].CRTCInfoBlock.HorizontalSyncPolarity
        cmp     bl, '-'
        jne     @f
        or      al, 040h
@@:
        ; Program new vertical sync polarity
        mov     bl, [edi].CRTCInfoBlock.VerticalSyncPolarity
        cmp     bl, '-'
        jne     @f
        or      al, 080h
@@:
        mov     dx, MISC_OUTPUT
        LOG_GO  dx, al
    */
    //
    // Program the sync polarities
    //
    val32 = ReadPriv32(NV_PRMVIO_MISC__READ) & 0x3F;
    if (timings->flags & GTF_FLAGS_HSYNC_NEGATIVE)
        val32 |= 0x40;
    if (timings->flags & GTF_FLAGS_VSYNC_NEGATIVE)
        val32 |= 0x80;
    WritePriv08(NV_PRMVIO_MISC__WRITE, (U008)val32);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: PRMVIO_MISC=",(U008)val32);

    /*
        ;---------------------------------------------------------
        ; Compute CRTC settings
        call    PixPerCharClk
        mov     si, ax
    */
    // 
    // Get the pixels per char settings
    //
    if (ReadIndexed(NV_PRMVIO_SRX, NV_PRMVIO_SR_CLOCK_INDEX) & 0x0100)
        pixperclk = 8;
    else
        pixperclk = 9;    

    /*
        ; Another way to compute vertical border would be to
        ; subtract current CR12 (VDE[0:7]) from CR15 (VBS[0:7])
        call    GetCRTCAddr
        mov     al, 012h
        call    GetIndexRegister        ; VDE[7:0]
        mov     bh, ah
        mov     al, 015h
        call    GetIndexRegister        ; VBS[7:0]
        sub     ah, bh
        ;add    ah, 1-1                 ; VGA adjustments cancel
        xor     al, al
        or      ah, ah
        jz      @f
        inc     al                      ; 1 character horizontal
@@:
        mov     bx, [edi].CRTCInfoBlock.RefreshRate
        cmp     bx, 7200
        jle     @f
        xor     ax,ax                   ; No boarder for refresh above 72Hz
@@:
        mov     bp, ax                  ; Save boarders in bp
    */
    //
    // Get the border setting
    //
    border = (U016)ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x15) & 0xFF00;
    border -= (U016)ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x12) & 0xFF00;
    border &= 0xFF00;
    if (border & 0xFF00)
        border++;
    if (timings->refresh > 7200)
        border = 0;
    
    /*        
        ;---------------------------------------------------------
        ; Store CRTC settings
        ; Get overflow values to accumulate
        mov     al, 007h
        call    GetIndexRegister
        mov     ch, ah                  ; Save off overflow register
        and     ch, 01010010b           ; Mask bits to save
        mov     al, 025h
        call    GetIndexRegister
        mov     cl, ah                  ; Save off extra bits screen register
        and     cl, 11100010b           ; Mask bits to save
IFDEF NVIDIA_SPECIFIC
        ; Load original 02Dh
        mov     al,02Dh
        call    GetIndexRegister
        and     ah,0E2h         ; Save unused bits and HDE
        rol     ecx,16          ; switch to upper part of ECX
        mov     cl,ah
        ror     ecx,16          ; switch back to lower part of ECX
ENDIF ; NVIDIA_SPECIFIC
    */
    //
    // Get the overflow bits
    //
    ov07 = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x07) >> 8;
    ov07 &= 0x52;
    ov25 = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x25) >> 8;
    ov25 &= 0xE2;
    ov2D = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x2D) >> 8;
    ov2D &= 0xE2;
    
    /*
        ; cl = CRTC[25] overflow
        ; ch = CRTC[07] overflow
        ; upper cl = CRTC[2D] overflow
        ; dx = CRTC I/O address
        ; si = pixels per character
        ; es:di = pointer to CRTCInfoBlock
        ; ds = seg0
        ; bp = boarder
        mov     ax, [edi].CRTCInfoBlock.HorizontalTotal
        push    dx
        xor     dx, dx
        div     si
        pop     dx
        mov     bx, ax                  ; Save original
        sub     ax, 5                   ; VGA HT adjustment
IFDEF NVIDIA_SPECIFIC
        ; Do bit 8 of HT
        and     ah,1            ; mask out bit 8
        ;shl     ah,0-0          ; already in position 0
        rol     ecx,16          ; switch to upper part of ECX
        or      cl,ah
        ror     ecx,16          ; switch back to lower part of ECX
ENDIF ; NVIDIA_SPECIFIC
        ;
        ; CRTC[00]
        mov     ah, al
        mov     al, 000h
        LOG_GO  dx, ax
    */
    //
    // Calculate and program horizontal total (CR00)
    //
    horiz_total = timings->horiz_total / pixperclk;
    val16 = horiz_total - 5;
    val16 &= 0x01FF;
    ov2D |= (U008)(val16 >> 8);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)((val16 << 8) & 0xFF00));
    
    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR00=",(U008)val16);
    
    /*            
IFDEF NVIDIA_SPECIFIC
        ; CRTC[39]
        ; Note, we are assuming that the 9th bit of interlace half field start is always 0
        mov     ax, bx
        shr     ax, 1           ; Compute horizontal total divided by 2
        mov     ah, [edi].CRTCInfoBlock.Flags
        and     ah,00000010b    ; ?Interlaced mode
        jnz     @f              ; Y: Leave ah at 1/2 HT
        mov     al, 0FFh        ; N: Disable interlace
@@:
        mov     ah, al
        mov     al, 039h
        SIM_NO  dx, ax
ENDIF ; NVIDIA_SPECIFIC
    */
    //
    // Program interlace half-field value (CR39)
    //
    if (timings->flags & GTF_FLAGS_INTERLACED)
        val16 = (((horiz_total >> 1) << 8) & 0xFF00) | 0x39;
    else
        val16 = 0xFF39;   // disabled
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);
    
    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR39=",(U008)(val16>>8));
    
    /*            
        mov     ax, bp
        xor     ah, ah                  ; Make into word
        sub     bx, ax                  ; Subtract boarder from HT
        ; CRTC[03]
        mov     al, 003h
        call    GetIndexRegister
        and     ah, 11100000b
        dec     bl                      ; VGA HBE Adjustment
        mov     bh, bl                  ; save HBE
        and     bl, 00011111b           ; HBE[4:0]
        or      ah, bl
        LOG_GO  dx, ax
    */
    //
    // Program horizontal blanking end (CR03)
    //
    val16 = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x03);
    val16 &= 0xE0FF;
    hbe = horiz_total - (border & 0xFF) - 1;
    val16 |= ((hbe & 0x1F) << 8);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);
    
    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR03=",(U008)(val16>>8));
    
    /*        
        ; CRTC[05]
        mov     ax, [edi].CRTCInfoBlock.HorizontalSyncEnd
        push    dx
        xor     dx, dx
        div     si
        pop     dx
        mov     bl, al
        mov     al, 028h                ; See if we are in native mode or vga mode
IFDEF NVIDIA_SPECIFIC
        call    GetIndexRegister
        and     ah, 003h
ENDIF ; NVIDIA_SPECIFIC
        .if (zero?)
                inc     bl              ; VGA HSE adjustment is +2
        .endif
        inc     bl                      ; Native HSE adjustment is +1
        mov     al, 005h
        call    GetIndexRegister
        and     ah, 01100000b
        and     bl, 00011111b           ; HSE[4:0]
        or      ah, bl
        mov     bl, bh                  ; restore HBE
        and     bl, 00100000b           ; HBE[5]
        shl     bl, 7-5                 ; Move from bit 5 to bit 7
        or      ah, bl
        LOG_GO  dx, ax
    */
    //
    // Program horizontal retrace end (CR05)
    //
    val16 = timings->horiz_end / pixperclk;
    val16++;    // always native mode
    val16 &= 0x1F;
    val16b = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x05);
    val16b &= 0x60FF;
    val16b |= (val16 << 8);
    val16 = (hbe & 0x20) << 2;
    val16b |= (val16 << 8);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16b);
    
    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR05=",(U008)(val16b>>8));
    
    /*        
IFDEF NVIDIA_SPECIFIC
        and     bh, 01000000b
        shr     bh, 6-4
        ; MSK - Assume HBE[6] can always be set, but only takes effect if LC ignore flag is set
        or      cl, bh                  ; HBE[6]
ENDIF ; NVIDIA_SPECIFIC
    */
    //
    // Modify overflow25
    //
    ov25 |= ((hbe & 0x40) >> 2);
    
    /*
        ; CRTC[02]
        mov     al, 001h
        call    GetIndexRegister        ; HDE[0:7]
        mov     al, ah
IFDEF NVIDIA_SPECIFIC
        ; Get bit 8 of HDE
        rol     ecx,16          ; switch to upper part of ECX
        mov     ah, cl
        ror     ecx,16          ; switch back to lower part of ECX
        and     ah, 2           ; mask out bit 1
        shr     ah, 1-0         ; shift into position 0
ELSE ; NVIDIA_SPECIFIC
        xor     ah, ah
ENDIF ; NVIDIA_SPECIFIC
        ;
        inc     ax                      ; VGA HDE adjustment
        mov     bx, bp
        xor     bh, bh
        add     ax, bx
        dec     ax                      ; VGA HBS Adjustment
IFDEF NVIDIA_SPECIFIC
        ; Store bit 8 of HBS
        and     ah,1            ; mask out bit 8
        shl     ah,2-0          ; shift into position 2
        rol     ecx,16          ; switch to upper part of ECX
        or      cl,ah
        ror     ecx,16          ; switch back to lower part of ECX
ENDIF ; NVIDIA_SPECIFIC
        ;
        mov     ah, al
        mov     al, 002h
        LOG_GO  dx, ax
    */
    //
    // Program horizontal blanking start (CR02)
    //
    val16 = (ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x01) >> 8) & 0x00FF;
    val16 |= ((U016)(ov2D & 2) << 7) & 0xFF00;
    val16++;
    val16 += (border & 0xFF);
    val16--;
    val08 = ((val16 >> 8) & 1) << 2;
    ov2D |= (U016)val08;
    val16 = ((val16 << 8) & 0xFF00) | 0x02;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);
    
    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR02=",(U008)(val16>>8));
    
    /*
        ; CRTC[04]
        mov     ax, [edi].CRTCInfoBlock.HorizontalSyncStart
        push    dx
        xor     dx, dx
        div     si
        pop     dx
        mov     bx, ax
        mov     al, 028h                ; See if we are in native mode or vga mode
IFDEF NVIDIA_SPECIFIC
        call    GetIndexRegister
        and     ah, 003h
ENDIF ; NVIDIA_SPECIFIC
        .if (zero?)
                inc     bx              ; VGA HSS adjustment is +2
        .endif
        inc     bx                      ; Native HSS adjustment is +1
IFDEF NVIDIA_SPECIFIC
        ; do bit 8 of HRS
        and     bh,1            ; mask out bit 8
        shl     bh,3-0          ; shift into position 3
        rol     ecx,16          ; switch to upper part of ECX
        or      cl,bh
        ror     ecx,16          ; switch back to lower part of ECX
ENDIF ; NVIDIA_SPECIFIC
        ;
        mov     ah, bl
        mov     al, 004h
        LOG_GO  dx, ax
    */
    //
    // Program horizontal retrace start (CR04)
    //
    val16 = timings->horiz_start / pixperclk;
    val16++;    // always native mode
    val08 = ((val16 >> 8) & 1) << 3;
    ov2D |= val08;
    val16 = ((val16 << 8) & 0xFF00) | 0x04;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);
    
    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR04=",(U008)(val16>>8));
    
    /*    
IFDEF NVIDIA_SPECIFIC
        ; CRTC[2D]
        rol     ecx,16          ; switch to upper part of ECX
        mov     ah,cl
        ror     ecx,16          ; switch back to lower part of ECX
        mov     al,02Dh
        SIM_NO  dx,ax
ENDIF ; NVIDIA_SPECIFIC
    */
    //
    // Program CR2D
    //
    val16 = ((((U016)ov2D) << 8) & 0xFF00) | 0x2D;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);
    
    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR2D=",(U008)(val16>>8));
    
    /* 
        ; CRTC[16]
        mov     bx, [edi].CRTCInfoBlock.VerticalTotal
        mov     ax, bp
        mov     al, ah
        xor     ah, ah
        sub     ax, bx
        neg     ax
        mov     ah, al
        mov     al, 016h
        dec     ah                      ; VGA VBE Adjustment
        LOG_GO  dx, ax                  ; VBE[0:7]
    */
    //
    // Program vertical blanking end (CR16)
    //
    val16 = (border >> 8) - timings->vertical_total;
    val16 = -val16;
    val16--;
    val16 = ((val16 << 8) & 0xFF00) | 0x16;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);
    
    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR16=",(U008)(val16>>8));
    
    /*            
        ; CRTC[06]
        mov     al, 006h
        sub     bx, 2                   ; VGA VT Adjustement
        mov     ah, bl
        LOG_GO  dx, ax                  ; VT[0:7]
    */
    //
    // Program the vertical total (CR06)
    //
    val16 = timings->vertical_total - 2;        
    val16 = ((val16 << 8) & 0xFF00) | 0x06;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);
    
    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR06=",(U008)(val16>>8));
    
    /*
        mov     bl, bh
        and     bl, 00000001b
        ;shl    0-(8-8)
        or      ch, bl                  ; VT[8]
        mov     bl, bh
        and     bl, 00000010b
        shl     bl, 5-(9-8)
        or      ch, bl                  ; VT[9]
        and     bh, 00000100b
        shr     bh, (10-8)-0
        or      cl, bh                  ; VT[10]
        ; CRTC[15]
        mov     ah, cl                  ; CRTC[25]
        and     ah, 00000010b
        shl     ah, (10-8)-1
        mov     bh, ah                  ; VDE[10]
        mov     al, ch                  ; CRTC[7]
        and     al, 01000000b
        shr     al, 6-(9-8)
        or      bh, al                  ; VDE[9]
        mov     ah, ch                  ; CRTC[7]
        and     ah, 00000010b
        shr     ah, 1-(8-8)
        or      bh, ah                  ; VDE[8]
        mov     al, 012h
        call    GetIndexRegister        ; VDE[7:0]
        mov     bl, ah
        inc     bx                      ; VGA VDE adjustment
        mov     ax, bp                  ; Adjust boarder
        mov     al, ah
        xor     ah, ah
        add     bx, ax
        mov     al, 015h
        dec     bx                      ; VGA VBS adjustment
        mov     ah, bl
        LOG_GO  dx, ax                  ; VBS[0:7]
    */
    //
    // Program vertical blanking start (CR15)
    //
    val16 = timings->vertical_total - 2;
    val08 = (val16 >> 8) & 0x01;
    ov07 |= (U016)val08;
    val08 = (val16 >> 8) & 0x02;
    val08 <<= 4;
    ov07 |= (U016)val08;
    val08 = (val16 >> 8) & 0x04;
    val08 >>= 2;
    ov25 |= (U016)val08;
    
    val08 = (ov25 & 0x02) << 1;
    val16 = (U016)val08 << 8;
    val08 = (ov07 & 0x40) >> 5;
    val16 |= (U016)val08 << 8;
    val08 = (ov07 & 0x02) >> 1;
    val16 |= (U016)val08 << 8;
    
    val16 &= 0xFF00;
    val16 |= (ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x12) >> 8) & 0x00FF;
    val16++;
    val16 += (border >> 8);
    val16--;
    val16c = val16;                     // save for later
    val16b = ((val16 << 8) & 0xFF00) | 0x15;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16b);
    
    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR15=",(U008)(val16b>>8));
    
    /*
        mov     bl, bh
        and     bl, 00000001b
        shl     bl, 3-(8-8)
        or      ch, bl                  ; VBS[8]
    */
    val08 = ((val16 >> 8) & 1) << 3;
    ov07 |= val08;
    
    /*        
        ; CRTC[09]
        ; MSK - 5/15/97
        ; To allow a double scan mode to be non double scanned, we need to preserve the
        ; double scan bit so we can check it later
        ; We need to adjust VDE based on the old and new double scan bits
        ; We also need the original VDE
        ; NOTE: alternate way would be to get the value from the mode tables

        mov     al, 009h
        call    GetIndexRegister
        mov     bl, [edi].CRTCInfoBlock.Flags
        and     ah,10000000b    ; Old double scan mode
        shr     ah,7-0
        and     bl,00000001b    ; ?Double scan mode
        cmp     bl, ah
        .if     (!zero?)        ; Mismatch
    */
    //
    // Is the current doublescan status different from the requested flag?
    //
    val16 = (ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x09) >> 8) & 0x00FF;
    val16 >>= 7;
    // this takes advantage that the flag is 0x01
    if ((timings->flags & GTF_FLAGS_DOUBLE_SCANNED) != (U008)val16)
    {
     
        /*               
                ; New mode had different double scan setting from old mode
                ; We have to multiply or divide VDE by 2

                mov     bl, ch          ; CR[7].1
                and     bl, 00000010b
                shr     bl, 1-0         ; move to bit 0

                mov     ah, ch          ; CR[7].6
                and     ah, 01000000b
                shr     ah, 6-1         ; move to bit 1
                or      bl, ah

                mov     ah, cl          ; CR[25].1
                and     ah, 00000010b
                shl     ah, 2-1         ; Move to bit 2
                or      bl, ah
        */
        //
        // Adjust VDE
        //
        val08 = (ov07 & 0x02) >> 1;
        val08 |= (ov07 & 0x40) >> 5;
        val08 |= (ov25 & 0x02) << 1;
        
        /*
                mov     al, 012h
                call    GetIndexRegister
                mov     al, [edi].CRTCInfoBlock.Flags
                and     al, 00000001b   ; Is new mode a double scan mode?
                .if (zero?)
                        ; was double scan, now is not, so divide by 2
                        shr     bl, 1           ; Divide by 2
                        rcr     ah, 1
                .else
                        ; was not double scan, now is, so multiply by 2
                        shl     ah, 1           ; Multiply by 2
        BUG? =>         rcr     bl, 1
                        inc     ah              ; Make lsb set

                .endif
                mov     al, 012h

                LOG_GO  dx, ax          ; VDE[0:7]
        */
        
        val16 = (ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x12) >> 8) & 0x00FF;
        val16 |= (U016)val08 << 8;
        if (!(timings->flags & GTF_FLAGS_DOUBLE_SCANNED))
        {
            val16 >>= 1;
        } 
        else 
        {
            val16 <<= 1;
            val16++;
        }            
        val16b = ((val16 << 8) & 0xFF00) | 0x12;
        WriteIndexed(NV_PRMCIO_CRX__COLOR, val16b);
                        
        DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR12=",(U008)(val16b>>8));
                        
        /*
                and     ch, NOT 01000010b       ; Strip old VDE
                mov     al, bl
                and     al, 00000001b
                shl     al, 1-0         ; move to bit 1
                or      ch, al          ; CR[7].1
                mov     al, bl
                and     al, 00000010b
                shl     al, 6-1         ; move to bit 6
                or      ch, al          ; CR[7].1

                and     cl, NOT 00000010b       ; Strip old VDE
                mov     al, bl
                and     al, 00000100b
                shr     al, 2-1         ; move to bit 1
                or      cl, al          ; CR[25].1

        .endif
        ; End MSK - 5/15/97
        */
        //
        // Adjust the overflows based on the new VDE
        //
        ov07 &= 0xBD;   
        val08 = (U008)(val16 >> 8);
        val08 = (val08 & 0x01) << 1;
        ov07 |= val08;
        val08 = (U008)(val16 >> 8);
        val08 = (val08 & 0x02) << 5;
        ov07 |= val08;
        ov25 &= 0xFD;
        val08 = (U008)(val16 >> 8);
        val08 = (val08 & 0x04) >> 1;
        ov25 |= val08;
    }        

    /*
        mov     al, 009h
        call    GetIndexRegister
        and     ah, NOT 10100000b
        mov     bl, [edi].CRTCInfoBlock.Flags
        and     bl,00000001b    ; ?Double scan mode
        jz      @f              ; N: Leave clear
        or      ah, 10000000b   ; Y: Set double scan
@@:
        mov     bl, bh
        and     bl, 00000010b
        shl     bl, 5-(9-8)
        or      ah, bl                  ; VBS[9]
        LOG_GO  dx, ax
    */        
    //
    //
    val16b = (ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x09) >> 8) & 0x00FF;
    val16b &= 0x5F;
    if (timings->flags & GTF_FLAGS_DOUBLE_SCANNED)
        val16b |= 0x80;
    val08 = (U008)(val16c >> 8);
    val08 = (val08 & 0x02) << 4;
    val16b |= (U016)val08;    
    val16 = ((val16b << 8) & 0xFF00) | 0x09;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);
    
    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR09=",(U008)(val16>>8));
    
    /*
        and     bh, 00000100b
        shl     bh, 3-(10-8)
        or      cl, bh                  ; VBS[10]
        ; CRTC[10]
        mov     al, 010h
        mov     bx, [edi].CRTCInfoBlock.VerticalSyncStart
        mov     ah, bl
        LOG_GO  dx, ax                  ; VSS[0:7]
    */
    //
    // 
    val08 = (U008)(val16c >> 8);
    val08 = (val08 & 0x04) << 1;
    ov25 |= val08;
    val16 = timings->vertical_start;
    val16 = ((val16 << 8) & 0xFF00) | 0x10;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);
    
    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR10=",(U008)(val16>>8));
    
    /*        
        mov     bl, bh
        and     bl, 00000001b
        shl     bl, 2-(8-8)
        or      ch, bl                  ; VSS[8]
        mov     bl, bh
        and     bl, 00000010b
        shl     bl, 7-(9-8)
        or      ch, bl                  ; VSS[9]
        and     bh, 00000100b
        ;shl     bh, 2-(10-8)
        or      cl, bh                  ; VSS[10]
        ; CRTC[11]
        mov     al, 011h
        call    GetIndexRegister
        and     ah, 11110000b
        mov     bl, byte ptr [edi].CRTCInfoBlock.VerticalSyncEnd
        and     bl, 00001111b
        or      ah, bl
        LOG_GO  dx, ax                  ; VSE[0:3]
    */
    //
    // 
    val08 = (U008)(timings->vertical_start >> 8);
    val08 = (val08 & 0x01) << 2;
    ov07 |= val08;    
    val08 = (U008)(timings->vertical_start >> 8);
    val08 = (val08 & 0x02) << 6;
    ov07 |= val08;    
    val08 = (U008)(timings->vertical_start >> 8);
    val08 = val08 & 0x04;
    ov25 |= val08;    
    val16b = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x11);
    val16b &= 0xF0FF;
    val16b |= (timings->vertical_end & 0x000F) << 8;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16b);
    
    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR11=",(U008)(val16b>>8));
    
    /*        
        ; Store overflow registers
        ; CRTC[7]
        mov     al, 007h
        mov     ah, ch
        LOG_GO  dx, ax
    */
    val16 = ((((U016)ov07) << 8) & 0xFF00) | 0x07;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);
            
    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR07=",(U008)(val16>>8));
            
    /*        
        ; CRTC[25]
IFDEF NVIDIA_SPECIFIC
        mov     al, 025h
        mov     ah, cl
        SIM_NO  dx, ax
ENDIF ; NVIDIA_SPECIFIC
    */
    val16 = ((((U016)ov25) << 8) & 0xFF00) | 0x25;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR25=",(U008)(val16>>8));

    return(0);
}

//*****************************************************************************
//
// Function: SetDMTOverrideValues()
//
// Description:
//    
//      Do VESA 1.0 rev 0.7 DMT timings for the following modes:
//
//      DMT timing calculations were produced with the VESA DMT 1.0 rev 0.7 
//      Monitor Timing Specifications and D.Reed's NV3 CRTC spreadsheet.
//
//           1600 x 1200 @ 60,70,75,85
//           1280 x 1024 @ 60,75,85
//           1152 x  864 @ 75
//           1024 x  768 @ 60,70,75,85
//            800 x  600 @ 60,72,75,85
//            640 x  480 @ 60,72,75,85
//
//      DMT_Overrides_structure
//
//          U016	DotClock;
//          U016    Polarity;
//          U016    CR0;
//          U016    CR2;
//          U016    CR3;
//          U016    CR4;
//          U016    CR5;
//          U016    CR6;
//          U016    CR7;
//          U016    CR10;
//          U016    CR11;
//          U016    CR15;
//          U016    CR16;
//  
//*****************************************************************************


VOID SetDMTOverrideValues(PDMT_OVERRIDES pDMTOverrides)            

{

    U032 val32;
    U016 val16;
    U016  wv;                     

    //
    // Program the new clocks
    //

    OEMSetClock((U016)(((U032)(pDMTOverrides->DotClock))));

    //
    // Program the sync polarity
    //

    val32   = ReadPriv32(NV_PRMVIO_MISC__READ) & 0x3F;
    val32  &= 0xf3;
    val32  |= 0x8;
    val32  |= pDMTOverrides->Polarity;
    WritePriv08(NV_PRMVIO_MISC__WRITE, (U008)val32);

    //
    // Clear the crtc protection bit.
    //
    
    val16 = 0x0011;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);


    //
    // Update CR0
    //

    val16 = pDMTOverrides->CR0;
    val16 = ((val16 << 8) & 0xFF00) | 0x00;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);


    //
    // Update CR2
    //

    val16 = pDMTOverrides->CR2;
    val16 = ((val16 << 8) & 0xFF00) | 0x02;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    //
    // Update CR3
    //

    val16 = pDMTOverrides->CR3;
    val16 = ((val16 << 8) & 0xFF00) | 0x03;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    //
    // Update CR4
    //

    val16 = pDMTOverrides->CR4;
    val16 = ((val16 << 8) & 0xFF00) | 0x04;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    //
    // Update CR5
    //

    val16 = pDMTOverrides->CR5;
    val16 = ((val16 << 8) & 0xFF00) | 0x05;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    //
    // Update CR6
    //

    val16 = pDMTOverrides->CR6;
    val16 = ((val16 << 8) & 0xFF00) | 0x06;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    //
    // Update CR7
    //

    val16 = pDMTOverrides->CR7;
    val16 = ((val16 << 8) & 0xFF00) | 0x07;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    //
    // Update CR10
    //

    val16 = pDMTOverrides->CR10;
    val16 = ((val16 << 8) & 0xFF00) | 0x10;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);
    //
    // Update CR11
    //

    val16 = pDMTOverrides->CR11;
    val16 = ((val16 << 8) & 0xFF00) | 0x11;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    //
    // Update CR15
    //

    val16 = pDMTOverrides->CR15;
    val16 = ((val16 << 8) & 0xFF00) | 0x15;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    //
    // Update CR16
    //

    val16 = pDMTOverrides->CR16;
    val16 = ((val16 << 8) & 0xFF00) | 0x16;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

}


//       OEMSetRegs - Set extended registers (standard VGA has been set)
//
//       Entry:  ES:DI = Standard VGA parameter pointer
//               DS = Seg0
//       Exit:   None
//
VOID OEMSetRegs(MODEDESC *mi)
{
    U016  wv;                     // Write value    
    U016  i, c;
    U032   lwv;
    U032   lrv;
    U008   cv;

    if (mi->mdCMode != 0xFF)        // Do we have a CRTC Override Table?
    {
        // Yep - program it
        WritePriv08(NV_PRMVIO_MISC__WRITE, crt_override[mi->mdCMode].CO_Misc);
                                                                      
        wv = crt_override[mi->mdCMode].CO_ClockMode;
        wv <<= 8;
        wv |= 0x01;
        WriteIndexed(NV_PRMVIO_SRX, wv); // Write SR01
        
        wv = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x11);    // Read CR11
        wv &= 0x7FFF;               // Unlock CR0-7
        WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Write CR11
        
        // Do CR0-CR8 sequentially
        LoadIndexRange(NV_PRMCIO_CRX__COLOR, 0, 8, (U008 *)&(crt_override[mi->mdCMode].HTotal));
        
        wv = crt_override[mi->mdCMode].CO_CellHeight;
        wv <<= 8;
        wv |= 0x09;
        WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Write CR09
        
        // Do CR10-CR12 sequentially
        LoadIndexRange(NV_PRMCIO_CRX__COLOR, 0x10, 0x03, (U008 *)&(crt_override[mi->mdCMode].CO_VSyncStart));
        
        // Do CR15-CR16 sequentially
        LoadIndexRange(NV_PRMCIO_CRX__COLOR, 0x15, 0x02, (U008 *)&(crt_override[mi->mdCMode].CO_VBlankStart));
    }
    
    // Program Extended Registers
    
    wv = eregs[mi->mdEMode].xrOffset;
    wv <<= 13;              
    wv &= 0xE000;                   // Clear start address bits
    wv |= 0x19;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Write CR19
                                                       
    wv = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x1A);
    wv &= 0xC0FF;                   // Preserve sync disables
    wv |= 0x3800;                   // Set reserved bits and text mode
                    
    c = (eregs[mi->mdEMode].xrFlags);
         
    if (c & 0x01)
        wv |= 0x0100;               // Set address wrap
        
    i = (eregs[mi->mdEMode].xrVOver);
    i &= 0x20;
    i >>= 0x03;
    wv |= (i << 8);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Write CR1A
    
    // Default Fifo
    wv = 0x011B;                    // Default CR1B value for VGA modes
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Write CR1B
                                                        
    wv = c;
    wv &= 0x06; 
    wv <<= 8;
    wv |= 0x1C;                     // CR1C
    
    i = (eregs[mi->mdEMode].xrPixFmt);
    i &= 0x30;                      // Mask off chain-4 optimize bits
    i >>= 1;            // (shr 4-3?)
    
    wv |= (i << 8);                 // Set chain 4 optimize bits
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Write CR1A
    
    
    wv = 0x001D;                    // Clear CR1D & 1E
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Write CR1D
    
    wv = 0x001E;                    // Clear CR1D & 1E
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Write CR1E
    
    wv = 0x1020;                    // Fifo Setting for Standar VGA modes
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Set low water mark at CR20
    
    c = (eregs[mi->mdEMode].xrVOver); // Vertical Overflow
    c &= 0x1F;                      // Mask our bits                                               
    
    i = (eregs[mi->mdEMode].xrOffset);
    i &= 0x08;                      // Bit 3
    i <<= 2;                        // Move to bit 5
    c |= i;
    wv =  (c << 8) | 0x25;          // Write data to CR25
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Set CR25
                                               
    
    wv = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x28);
    wv &= 0xF8FF;                   // Preserve sync disables
             
    c = eregs[mi->mdEMode].xrPixFmt;
    c &= 0x07;                      // Set bits [2:0] - clear rest
    wv |= (c << 8);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Set CR28
                                                   
    c = eregs[mi->mdEMode].xrPixFmt;
    c &= 0xC0;
    c >>= 6;
    
    i = eregs[mi->mdEMode].xrVOver;
    i &= 0xC0;
    i >>= 4;
    c |= i;
    wv = ((c << 8) | 0x2D);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Set CR2D
                                                      
    wv = 0x29;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  
    wv = 0x2A;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  
    
    // Do CR29-33
    /*
    for (i = 0x30; i <= 0x33; i++)
    {                      
        wv = (U016)i;
        WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  
    } 
    */                                          
    
    wv = (((eregs[mi->mdEMode].xrIntlace) << 8) | 0x39);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  
    
    // Set dot clock
    //OEMSetClock(eregs[mi->mdEMode].xrClkSel);
    if (pDev->Framebuffer.MonitorType != MONITOR_TYPE_FLAT_PANEL)
        OEMSetClock(tblClockFreq[eregs[mi->mdEMode].xrClkSel]);

    wv = (((eregs[mi->mdEMode].xrVOffset) << 8) | 0x13);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  
                                                     
    pDev->Framebuffer.CursorAdjust = 0;   // default to no adjustment of cursor position
    if (pDev->Framebuffer.DisplayType == DISPLAY_TYPE_TV)
    {
        ProgramTV( mi->mdTVMode );              // CRTC tweaks for TV
        // plus some additional tweaks for pixel/line doubled modes
        if (mi->mdTVMode <= TV_MODE_400x300)    // if clock doubling
        {
            WritePriv32(0x01030700, NV_PRAMDAC_PLL_COEFF_SELECT);   // clock doubled mode
        }
        else
            WritePriv32(0x10030700, NV_PRAMDAC_PLL_COEFF_SELECT);
    }
    else    
    {
        // Not TV, if flat panel, we may need to adjust CRTC's
        if (pDev->Framebuffer.DisplayType == DISPLAY_TYPE_FLAT_PANEL)
            FlatPanelCrtc(mi->mdXRes);
        else
            WritePriv32(0x10000700, NV_PRAMDAC_PLL_COEFF_SELECT);
    }        

    // if flat panel, leave DAC alone
    if (pDev->Framebuffer.DisplayType != DISPLAY_TYPE_FLAT_PANEL)
    {
        lrv = ReadPriv32(NV_PRAMDAC_GENERAL_CONTROL);
    
        lrv &= (U032)(((1L << DRF_SHIFT(NV_PRAMDAC_GENERAL_CONTROL_ALT_MODE)) |
             (1L << DRF_SHIFT(NV_PRAMDAC_GENERAL_CONTROL_VGA_STATE)) |
             (1L << DRF_SHIFT(NV_PRAMDAC_GENERAL_CONTROL_BPC))) ^ -1L);
        
        lrv |= (U032)(1L << DRF_SHIFT(NV_PRAMDAC_GENERAL_CONTROL_VGA_STATE));
        
        wv = (eregs[mi->mdEMode].xrOffset);
        lwv = (U032)(wv & 0x80);       // Set 565 Mode
    
        lwv <<= (DRF_SHIFT(NV_PRAMDAC_GENERAL_CONTROL_ALT_MODE) - 7L);
        
        lrv |= lwv; 
    
        cv = (eregs[mi->mdEMode].xrFlags);
        cv ^= (U008)-1;
        cv &= 0x08;                 // Isolate DAC width
    
        lwv = (U032)(cv);          // Dac Width
        lwv <<= (U032)(DRF_SHIFT(NV_PRAMDAC_GENERAL_CONTROL_BPC) - 3L);
                                       
        lrv |= lwv; 
        
        cv = (eregs[mi->mdEMode].xrPixFmt);
        cv ^= (U008)-1;                   // Invert
        cv &= 0x02;                 // Isolate index/gamma bit
                             
        lwv = (U032)(cv);
        
        //KJK lwv <<= (U032)(DRF_SHIFT(NV_PRAMDAC_GENERAL_CONTROL_IDC_MODE) - 1L);
        lrv |= lwv; 
    
        WritePriv32(lrv, NV_PRAMDAC_GENERAL_CONTROL);
    }
        
    WritePriv08(NV_PRMCIO_CRX__COLOR, 0x18);    // Select CR18 (why?)
}

//  
//  The H/V timings may have to be adjusted for TV.
//  Also, the fifo low water mark should be set for TV.
//
VOID ProgramTV
(
	U008	tvmode
)
{
 
	U008	data;
    U016    data16 = 0;
    U008    hbeAdjust;
        
    CRTC_WR(NV_CIO_CRE_FFLWM__INDEX, 0x20);     // if TV, we can fix low water mark at 20.

    //  fix up CRTC timing for NV4
    if (TV_ENCODER_FAMILY(pDev->Framebuffer.EncoderType) == TV_ENCODER_CHRONTEL)
    {
        if (TVformat == NTSC)
        {
            CRTC_WR(NV_CIO_CR_HDT_INDEX, CRTC_CH_NTSC[ tvmode ].CR00);
            CRTC_WR(NV_CIO_CR_HRS_INDEX, CRTC_CH_NTSC[ tvmode ].CR04);
            CRTC_WR(NV_CIO_CR_VDT_INDEX, CRTC_CH_NTSC[ tvmode ].CR06);
            CRTC_WR(NV_CIO_CR_OVL_INDEX, CRTC_CH_NTSC[ tvmode ].CR07);
            CRTC_WR(NV_CIO_CR_RSAL_INDEX, CRTC_CH_PAL[ tvmode ].CR08);
            CRTC_WR(NV_CIO_CR_VRS_INDEX, CRTC_CH_NTSC[ tvmode ].CR10);
            CRTC_WR(NV_CIO_CR_VDE_INDEX, CRTC_CH_NTSC[ tvmode ].CR12);
            CRTC_WR(NV_CIO_CRE_LSR_INDEX, CRTC_CH_NTSC[ tvmode ].CR25);
            CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, data);      // read pixel format
            data |= CRTC_CH_NTSC[ tvmode ].CR28;        // OR with horizontal pixel adjust and slave TV to encoder
            CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, data);

            // write Seq 01
            WriteIndexed(NV_PRMVIO_SRX, (U016) ((CRTC_CH_NTSC[ tvmode ].SR01 << 8) | NV_PRMVIO_SR_CLOCK_INDEX));         
        }
        else // its PAL
        {
            CRTC_WR(NV_CIO_CR_HDT_INDEX, CRTC_CH_PAL[ tvmode ].CR00);
            CRTC_WR(NV_CIO_CR_HRS_INDEX, CRTC_CH_PAL[ tvmode ].CR04);
            CRTC_WR(NV_CIO_CR_VDT_INDEX, CRTC_CH_PAL[ tvmode ].CR06);
            CRTC_WR(NV_CIO_CR_OVL_INDEX, CRTC_CH_PAL[ tvmode ].CR07);
            CRTC_WR(NV_CIO_CR_RSAL_INDEX, CRTC_CH_PAL[ tvmode ].CR08);
            CRTC_WR(NV_CIO_CR_VRS_INDEX, CRTC_CH_PAL[ tvmode ].CR10);
            CRTC_WR(NV_CIO_CR_VDE_INDEX, CRTC_CH_PAL[ tvmode ].CR12);
            CRTC_WR(NV_CIO_CRE_LSR_INDEX, CRTC_CH_PAL[ tvmode ].CR25);
            CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, data);      // read pixel format
            data |= CRTC_CH_PAL[ tvmode ].CR28;           // OR with horizontal pixel adjust and slave TV to encoder
            CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, data);

            // write Seq 01
            WriteIndexed(NV_PRMVIO_SRX, (U016) ((CRTC_CH_PAL[ tvmode ].SR01 << 8) | NV_PRMVIO_SR_CLOCK_INDEX));         
        }
    }
    else if (TV_ENCODER_FAMILY(pDev->Framebuffer.EncoderType) == TV_ENCODER_BROOKTREE)
    {
        if (TVformat == NTSC)
        {
            // write Seq 01
            if (CRTC_BT[ tvmode ].SR01 != 0xff) // if table entry exists, do these adjustments
            {
                WriteIndexed(NV_PRMVIO_SRX, (U016) ((CRTC_BT[ tvmode ].SR01 << 8) | NV_PRMVIO_SR_CLOCK_INDEX));         
        
                // Adjust Horiz and Vert totals
                CRTC_WR(NV_CIO_CR_HDT_INDEX, CRTC_BT[ tvmode ].CR00);
                CRTC_WR(NV_CIO_CR_HRS_INDEX, CRTC_BT[ tvmode ].CR04);
                CRTC_WR(NV_CIO_CR_VDT_INDEX, CRTC_BT[ tvmode ].CR06);
                CRTC_WR(NV_CIO_CR_OVL_INDEX, CRTC_BT[ tvmode ].CR07);
                CRTC_WR(NV_CIO_CR_RSAL_INDEX, CRTC_BT[ tvmode ].CR08);
                CRTC_WR(NV_CIO_CR_VRS_INDEX, CRTC_BT[ tvmode ].CR10);
                CRTC_WR(NV_CIO_CR_VDE_INDEX, CRTC_BT[ tvmode ].CR12);
                if (tvmode == TV_MODE_320x200)  // 320 modes require additional adjustment for HDE
                {
                    CRTC_RD(NV_CIO_CR_HRS_INDEX, data);       // read CR04
                    CRTC_WR(NV_CIO_CR_HDE_INDEX, data-2);                
                    CRTC_WR(NV_CIO_CR_HBS_INDEX, data-2);                
                }
                if (tvmode == TV_MODE_320x240)  // 320 modes require additional adjustment for HDE
                {
                    CRTC_RD(NV_CIO_CR_HRS_INDEX, data);       // read CR04
                    CRTC_WR(NV_CIO_CR_HDE_INDEX, data-3);                
                    CRTC_WR(NV_CIO_CR_HBS_INDEX, data-3);                
                }
            }
        }
        else    // Brooktree PAL
        {
                
            // write Seq 01
            if (CRTC_BT_PAL[ tvmode ].SR01 != 0xff) // if table entry exists, do these adjustments
            {
                WriteIndexed(NV_PRMVIO_SRX, (U016) ((CRTC_BT[ tvmode ].SR01 << 8) | NV_PRMVIO_SR_CLOCK_INDEX));         
        
                // Adjust Horiz and Vert totals
                CRTC_WR(NV_CIO_CR_HDT_INDEX, CRTC_BT_PAL[ tvmode ].CR00);
                CRTC_WR(NV_CIO_CR_HRS_INDEX, CRTC_BT_PAL[ tvmode ].CR04);
                CRTC_WR(NV_CIO_CR_VDT_INDEX, CRTC_BT_PAL[ tvmode ].CR06);
                CRTC_WR(NV_CIO_CR_OVL_INDEX, CRTC_BT_PAL[ tvmode ].CR07);
                CRTC_WR(NV_CIO_CR_RSAL_INDEX, CRTC_BT_PAL[ tvmode ].CR08);
                CRTC_WR(NV_CIO_CR_VRS_INDEX, CRTC_BT_PAL[ tvmode ].CR10);
                CRTC_WR(NV_CIO_CR_VDE_INDEX, CRTC_BT_PAL[ tvmode ].CR12);
                if (tvmode <= TV_MODE_320x400)  // 320 modes require additional adjustment for HDE
                {
                    CRTC_RD(NV_CIO_CR_HRS_INDEX, data);       // read CR04
                    CRTC_WR(NV_CIO_CR_HDE_INDEX, data-5);                
                    CRTC_WR(NV_CIO_CR_HBS_INDEX, data-5);                
                }
            }
        }        
    } // encoder specific

    CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, data);              // get CR28
    data &= ~0x38;
    CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, data);              // clear the pixel shift 

    if (tvmode <= TV_MODE_320x400)
    {
        // adjust HBE = HT. This lets the cursor move across the whole screen.
        CRTC_RD(NV_CIO_CR_HDT_INDEX, data16);           // get HT (CR0)
        CRTC_RD(NV_CIO_CR_HBE_INDEX, data);             // CR03
        data &= ~0x1f;                                  // lose the HBE bits
        data |= (U008) data16 & 0x1F;
        CRTC_WR(NV_CIO_CR_HBE_INDEX, data);             // HBE 4:0
        pDev->Framebuffer.CursorAdjust = 8;
    }
    else
    {
        if (tvmode == TV_MODE_400x300)
        {
            CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, data);          // get CR28
            data &= ~0x38;
            CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, data | (5<<3)); // bits[5:3] shift 5 pixels right        
            pDev->Framebuffer.CursorAdjust = 0;
            if (TVformat == NTSC)   // PAL 400x300 requires special case for HBE for cursor position
                hbeAdjust = 4;
            else                
                hbeAdjust = 2;
        }
        else
        {
            pDev->Framebuffer.CursorAdjust = 5;
            hbeAdjust = 4;
        }
        // adjust HBE = HT + 4. This lets the cursor move across the whole screen.
        CRTC_RD(NV_CIO_CR_HDT_INDEX, data16);           // get HT (CR0)
        CRTC_RD(NV_CIO_CRE_HEB__INDEX, data);           // MS bit HT (CR2D)            
        if (data & 1)
            data16 |= 0x100;
        data16 += hbeAdjust;                            // HT effective

        CRTC_RD(NV_CIO_CR_HBE_INDEX, data);             // CR03
        data &= ~0x1f;                                  // lose the HBE bits
        data |= (U008) data16 & 0x1F;
        CRTC_WR(NV_CIO_CR_HBE_INDEX, data);             // HBE 4:0

        CRTC_RD(NV_CIO_CR_HRE_INDEX, data);             // CR05
        data &= ~0x80;                                  // lose the HBE bit
        if (data16 & 0x20)
            data |= 0x80;
        CRTC_WR(NV_CIO_CR_HRE_INDEX, data);             // HBE 5
                            
        CRTC_RD(NV_CIO_CRE_LSR_INDEX, data);            // CR25
        data & ~0x10;
        if (data16 & 0x40)
            data |= 0x10;
        CRTC_WR(NV_CIO_CRE_LSR_INDEX, data);            // HBE 6
    }
    // adjust VBE = VT + 1. This lets the cursor move vertically through the whole screen.
    CRTC_RD(NV_CIO_CR_VDT_INDEX, data);             // CR6
    data += 1;
    CRTC_WR(NV_CIO_CR_VBE_INDEX, data);             // CR16

    // adjust normally scanline doubled modes which are not doubled for TV
    if ((tvmode == TV_MODE_512x384) | (tvmode == TV_MODE_480x360))
        CRTC_WR(NV_CIO_CR_CELL_HT_INDEX, 0x40);
        
}

//
//       LoadPalette - Load the system palette and the user defined palette if there is one
//
//       Entry:  DS = Seg0
//               ES:DI = Pointer to parameter entry
//       Exit:   None
VOID LoadPalette(MODEDESC *mi)
{
    U016  flags;
    
#ifdef DOS_COMPILE    
    _asm    pushf;                  // Save Interrupt state
    _asm    pop ax;
    _asm    mov flags,ax
    _asm    cli;                    // No interrupts during this!
#endif 
    
    //
    // Load default internal palette
    //
    LoadDefaultATCAndSavePtr((vga_tbl[mi->mdIMode].PT_ATC));
                             
    ReadPriv32(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop
    
    WritePriv08(NV_PRMCIO_ARX, 0x14);   // Select AR14
    WritePriv08(NV_PRMCIO_ARX, 0x00);   // Zero it!
                                           
    //
    // Load default external palette
    //
    LoadDefaultRAMDAC(mi);
 
#ifdef DOS_COMPILE    
    _asm    mov ax,flags
    _asm    push ax
    _asm    popf;                   // Restore interrupt status
#endif
        
}

//
//       LoadDefaultATCAndSavePtr - Load a the default ATC registers and store them in the saveptr area if necessary
//
//       Entry:  ES:SI = Pointer to palette data
//               DX = I/O Address of Input Status Register
//               DS = Seg0
//       Exit:   None
//
//       AX, CX, SI are trashed
//       DX is preserved
//
VOID LoadDefaultATCAndSavePtr(U008 *pal)
{
    U008  i;
    U016  flags;
    
#ifdef DOS_COMPILE    
    _asm    pushf;                  // Save Interrupt state
    _asm    pop ax;
    _asm    mov flags,ax
    _asm    cli;                    // No interrupts during this!
#endif    
     
    ReadPriv32(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop
    
    for (i = 0; i < 20; i++)
    {
        WritePriv08(NV_PRMCIO_ARX, i);      // Select AR
        WritePriv08(NV_PRMCIO_ARX, *pal++); // Write color data
    }
                                                
    ReadPriv32(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop
                                    // So DOS Edit doesn't barf
#ifdef DOS_COMPILE    
    _asm    mov ax,flags
    _asm    push ax
    _asm    popf;                   // Restore interrupt status
#endif    
}

//
//       LoadDefaultRAMDAC - Load the default palette
//
//       Entry:  DS = Seg0
//       Exit:   None
//
//       AX, BX, CX, DX, SI are trashed
//

// #define DAC_MASK 0x3C6

VOID LoadDefaultRAMDAC(MODEDESC *mi)
{
    WritePriv08(NV_USER_DAC_PIXEL_MASK, 0xFF);      // Write DAC Mask
    // outp(DAC_MASK, 0xFFh);
    
    switch(mi->mdBPP)
    {
    case    4:          // 4bpp - Planar
        LoadColorDACTable();
        break;
        
    case    8:          // 8bpp - Packed
        LoadColor256DAC();
        break;
        
    case    16:         // 16bpp - Packed
    case    32:         // 16bpp - Packed
    default:
        LoadIdentityDAC();
        break;
    }       
}                        

//
//       LoadColorDACTable - Load the DAC for the 16-color modes
//
//       Entry:  DS = Seg0
//       Exit:   None
//
//       WARNING! This routine must follow "LoadColorTextDACTable"!
//
//       AX, BX, CX, DX, SI are trashed.
//
VOID LoadColorDACTable(VOID)
{
    U008  i;
    U016  flags;
    
#ifdef DOS_COMPILE    
    _asm    pushf;                  // Save Interrupt state
    _asm    pop ax;
    _asm    mov flags,ax
    _asm    cli;                    // No interrupts during this!
#endif    
    
    // Select the DAC address
    WritePriv08(NV_USER_DAC_WRITE_MODE_ADDRESS, 0x00);
    
    // Do the first 64 locations
    for (i = 0; i < 64; i++)
        WriteColor(i);
        
#ifdef DOS_COMPILE    
    _asm    mov ax,flags
    _asm    push ax
    _asm    popf;                   // Restore interrupt status
#endif    
}
    
//
//       LoadColor256DAC - Load the DAC for the 256-color modes
//
//       Entry:  DS = Seg0
//       Exit:   None
//
//       AX, BX, CX, DX, SI are trashed.
//
//------------------------------------------------------------------------
// First 16 colors for mode 13h (compatible R'G'B'RGB)
//
extern U008 CompatColors[];
                         
//------------------------------------------------------------------------
// Gray values for next 16 (6 bits of intensity)
//
extern U008 GrayColors[];
                                                                              
//------------------------------------------------------------------------
// Fixup values for DAC color registers after summing to gray shades
//
extern U008 FixupColors[];
                                                                       
//------------------------------------------------------------------------
// 9 groups of five intensities are used to generate the next 216 colors.
// Each group is used to generate 24 colors by walking around a "color
// triangle" with eight colors per side.
//
extern U008 IntenseTable[];                              
                                                                   
VOID LoadColor256DAC(VOID)
{
    U016  i;
    U016  red;
    U016  green;
    U016  blue;
    U016  flags;
    
#ifdef DOS_COMPILE    
    _asm    pushf;                  // Save Interrupt state
    _asm    pop ax;
    _asm    mov flags,ax
    _asm    cli;                    // No interrupts during this!
#endif    
    
    // Select the DAC address
    WritePriv08(NV_USER_DAC_WRITE_MODE_ADDRESS, 0x00);
    
    //--------------------------------------------------------------------
    // The first 16 colors are the compatible colors (i.e. 0,1,2,3,4,5,14,
    // 7,38,39,3A,3B,3C,3D,3E,3F).
    //
    for (i = 0; i < 16; i++)
        WriteColor(CompatColors[i]);
    
    //--------------------------------------------------------------------
    // The next 16 give various intensities of gray (0,5,8,B,E,11,14,18,
    // 1C,20,24,28,2D,32,38,3F).
    //
    for (i = 0; i < 16; i++)
    {
        WritePriv08(NV_USER_DAC_PALETTE_DATA, (U008)GrayColors[i]);
        WritePriv08(NV_USER_DAC_PALETTE_DATA, (U008)GrayColors[i]);
        WritePriv08(NV_USER_DAC_PALETTE_DATA, (U008)GrayColors[i]);
    }                                                
        
    //--------------------------------------------------------------------
    // The next 216 registers give a variety of colors.
    //
    
    red = 0;
    green = 0;
    blue = 4;

    for (i = 0; i < 9; i++)
    {                       
    
        // I know these could probably be a function, but for now...
        // (this is getting tedious).
        
        // Traverse(blue, red);
        do
        {
            // To loop
            WriteColor2(red, green, blue, (U016)(i * 5));
            red++;                                          
        } while (red < blue);
        
        do
        {
            // From loop
            WriteColor2(red, green, blue, (U016)(i * 5));
            blue--;
        } while (blue);
        
        // Traverse(red, green);
        do
        {
            // To loop
            WriteColor2(red, green, blue, (U016)(i * 5));
            green++;
        } while (green < red);
                         
        do
        {
            // From loop
            WriteColor2(red, green, blue, (U016)(i * 5));
            red--;
        } while (red);
                 
            
        // Traverse(green, blue);
        do
        {
            // To loop
            WriteColor2(red, green, blue, (U016)(i * 5));
            blue++;
        } while (blue < green);
                         
        do
        {
            // From loop
            WriteColor2(red, green, blue, (U016)(i * 5));
            green--;
        } while (green);
    }                
             
    //-----------------------------------------------------------------------
    // The last 8 colors are black.
    //
    //               +---+-- 8 blanks * 3 locations (r/g/b)
    for (i = 0; i < (8 * 3); i++)
        WritePriv08(NV_USER_DAC_PALETTE_DATA, 0x00);
    
#ifdef DOS_COMPILE    
    _asm    mov ax,flags
    _asm    push ax
    _asm    popf;                   // Restore interrupt status
#endif    
    
}

//
//       WriteColor - Writes one color value (three bytes) to the video DAC
//               R(analog) = R * 2Ah + R' * 15h
//               G(analog) = G * 2Ah + G' * 15h
//               B(analog) = B * 2Ah + B' * 15h
//
//       Entry:  DAC address already written
//               DX = DAC data address
//               BL = 6 bit color (R'G'B'RGB)
//       Exit:   None
//
//       AX is trashed
//
VOID WriteColor(U008 colorval)
{
    U008   component;          // color component 4=red/2=green/1=blue
    U008   color;              // Color component to write
    
    for (component = 0x04; component; component >>= 1)
    {
        // Color?
        if (colorval & component)
            color = 0x2A;               // Add color
        else
            color = 0;                  // No color on this component
        
        // Intensity?
        if (colorval & (component << 3))
            color += 0x15;
    
        WritePriv08(NV_USER_DAC_PALETTE_DATA, color);
    }
}        
        
//
//       WriteColor2 - Writes one color value (three bytes) to the video DAC
//               R(analog) = R * 2Ah + R' * 15h
//               G(analog) = G * 2Ah + G' * 15h
//               B(analog) = B * 2Ah + B' * 15h
//
//       Entry:  DAC address already written
//               DX = DAC data address
//               CS:BX points to intensity table
//               SI = Red index (0 to 4)
//               DI = Green index (0 to 4)
//               CX = Blue index (0 to 4)
//
//       Exit:   None
//
//       AL is trashed
//
VOID WriteColor2(U016 red, U016 green, U016 blue, U016 tblidx)
{
    WritePriv08(NV_USER_DAC_PALETTE_DATA, IntenseTable[tblidx+red]);
    WritePriv08(NV_USER_DAC_PALETTE_DATA, IntenseTable[tblidx+green]);
    WritePriv08(NV_USER_DAC_PALETTE_DATA, IntenseTable[tblidx+blue]);
}

//
//       LoadIdentityDAC - Load the DAC with a gamma ramp
//
//       Entry:  DS = Seg0
//               ES = _TEXT
//       Exit:   None
//
//       AX, BX, CX, DX, SI are trashed.
//
VOID LoadIdentityDAC(VOID)
{
    U016  i;
    U016  flags;
    
#ifdef DOS_COMPILE    
    _asm    pushf;                  // Save Interrupt state
    _asm    pop ax;
    _asm    mov flags,ax
    _asm    cli;                    // No interrupts during this!
#endif    
    
    // Select the DAC address
    WritePriv08(NV_USER_DAC_WRITE_MODE_ADDRESS, 0x00);
                                                  
    for (i = 0; i < 256; i++)
    {           
        WritePriv08(NV_USER_DAC_PALETTE_DATA, (U008)i);
        WritePriv08(NV_USER_DAC_PALETTE_DATA, (U008)i);
        WritePriv08(NV_USER_DAC_PALETTE_DATA, (U008)i);
    }                                     
    
#ifdef DOS_COMPILE    
    _asm    mov ax,flags
    _asm    push ax
    _asm    popf;                   // Restore interrupt status
#endif    
}
 
//       OEMSetClock - Set the clock chip to the requested frequency
//
//       Entry:  AL = Clock select index
//       Exit:   None
//
//       All registers are preserved.
VOID OEMSetClock(U016 clock)
{
    U032   mnp;
    
    //clock = tblClockFreq[csel];         // Get selected clock value 
    FixLowWaterMark(clock);             // Set low water mark.
    mnp = CalcMNP(&clock);              // Get the MNP of frequency
    
    // mnp = xxxxxxxx PPPPPPPP NNNNNNNN MMMMMMMM
    
//  AL = M parameter
//  AH = N parameter
//  DL = P parameter

    SetDACClock(mnp);
}

//       SetDACClock - Set the VPLL parameters in the NVidia DAC
//
//  Entry:  mnp = xxxxxxxx PPPPPPPP NNNNNNNN MMMMMMMM
//
//       Entry:  AL = M parameter
//               AH = N parameter
//               DL = P parameter
//       Exit:   None
//
VOID SetDACClock(U032 mnp)
{
    // NOTE: if we need to support divide by two, use msb of p parameter
    // Set the MNP VPLL parameters in the DAC
    WritePriv32(mnp, NV_PRAMDAC_VPLL_COEFF);
}

//
//       FixLowWaterMark
//
//       Entry:  AX = Dot clock frequency in kHz*100
//       Exit:   None
//
VOID FixLowWaterMark(U016 clock)
{
    U016  wv;
    U016  i;
    U032  clockMHz;
    
    wv = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x28);
    wv >>= 8;
    wv &= 0x03;       // mask pixel format bits
    
    // Check dac format
    if (wv)
    {
        wv--;
        clockMHz = clock;
        clockMHz <<= (U008)wv;
        clockMHz /= 100;
        
        for (i = 0; clockMHz > DACFifoTable[i].Freq ; i++)
            ;   // Find the proper FIFO value
        
        if (pDev->Dac.InputWidth == 128)
        {
            // 128 bit
            // Do WV first, as I get's blown away
            wv = ((DACFifoTable[i].LowWaterMark128) << 8) | 0x20;
            i  = ((DACFifoTable[i].BurstSize128) << 8) | 0x1B; 
            
        }                                                   
        else
        {
            // 64 bit   
            wv = ((DACFifoTable[i].LowWaterMark64) << 8) | 0x20;
            i  = ((DACFifoTable[i].BurstSize64) << 8) | 0x1B;
        }                                                  
        
        WriteIndexed(NV_PRMCIO_CRX__COLOR, i);
        WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);         // otherwise, we have an optimum value
    }
}   

//       CalcMNP - Set the clock chip to the requested frequency
//
//       Entry:  AX = Clock frequency in 100 kHz
//       Exit:   AL = M parameter
//               AH = N parameter
//               DL = P parameter
//               BX = Closest clock frequency in 100 kHz
//
//      Returns: long lwv = xxxxxxxx PPPPPPPP NNNNNNNN MMMMMMMM
//
U032 CalcMNP(U016 *clock)
{
    U016  crystalFreq;
    U032   vclk;
    U016  vclkClosest;
    U016  deltaOld;
    U016  bestM;
    U016  bestP;
    U016  bestN;
    U016  lowM;
    U016  highM;
    
    U016  powerP;
    U016  m;
    U016  n;
    U016  i, j;
    U032   lwv;
    
    U032   edx;
    U016  dx, cx, bx;
    U016  lwvs, vclks;
    U016  t;
    
    vclk = (U032)(*clock * 10);     // Make KHz
    
    deltaOld = 0xFFFF;
                                    
    lwv = ReadPriv32(NV_PEXTDEV_BOOT_0) & 0x00000040;
    
    if (lwv)
    {
        // 14.3Khz
        dx = CRYSTAL_FREQ143KHZ;
        cx = 1;
        bx = 14;
    }
    else
    {
        // 13.5Khz
        dx = CRYSTAL_FREQ135KHZ;
        cx = 1;
        bx = 13;
    }                      
    
    lowM = cx;
    highM = bx;
    crystalFreq = dx;
                                              
    // Register usage below
    // eax = scratch
    // ebx = scratch
    // edx = scratch
    // si = m
    // di = n
    
    // P Loop
    for (powerP = 0; powerP <= 4; powerP++) // Init Power of P
    {                             
        // M Loop
        for (m = lowM; m <= highM; m++)
        {                          
            lwv = vclk << powerP;   // vclk * P
            
            // Compare with internal range of DAC
            if ((lwv >= 128000) && (lwv <= 350000))
            //if (1)
            {
                lwv *= (U032)m;    // vclk * P * M
                
                // Add crystal Frequency /2 - will round better
                lwv += (crystalFreq >> 1);
                
                lwv /= crystalFreq; // N = vclk*P*M/crystal
                n = (U016)(lwv & 0xFFFF);
                
                lwv *= crystalFreq; // N * crystal
                   
                i = 1 << powerP;    // for rounding
                i >>= 1;            // /2
                
                lwv += i;           // Add 1/2 of P
                lwv >>= powerP;     // N*cyrstal/P
                
                i = m;
                j = m;
                
                j >>= 1;            // M/2
                lwv += j;           // For rounding
                lwv /= m;           // Freq = N*crystal/P/M
                                       
                
//                   ; upper part of ebx should still be 0
//                   mov     bx, m
//                   ; Note: edx should be zero from multiply above
//                   mov     dx, bx
//                   shr     dx, 1           ; m / 2
//                   add     eax, edx        ; This will round better
//                   xor     dx, dx
//                   div     ebx             ; Freq=N*crystal/P/M
//                   
//                   mov     edx, eax        ; Save a copy        

                edx = lwv;          // Save a copy

                // Because the only divide in computing N is by the
                // crystal frequency, the remainder will always be
                // less than the crystal frequency which fits into
                // a word, so we can do the delta math on words
                //
                // Compute delta
                
                lwvs = (U016)(lwv & 0xFFFF);
                vclks = (U016)(vclk & 0xFFFF);
                
                if (lwvs < vclks)
                {               
                    // Exchange the values
                    t = lwvs;
                    lwvs = vclks;
                    vclks = t;
                }            
                    
                lwvs -= vclks;      // ABS(Freq-Vclk);
                
                // lwvs is ax
                // vclks is bx
                if (((vclk / lwvs) > 500) && ((*clock) < 25000))
                {
                    bestP = powerP;
                    bestM = m;
                    bestN = n;
                    edx /= 10;
                    vclkClosest = (U016)(edx & 0xFFFF);
                    lwv = bestP;
                    lwv <<= 16;
                    lwv |= ((bestN << 8) | (bestM));
                    
                   
                    // mov     bx, vclkClosest
                    *clock = vclkClosest;
                    
                    return(lwv);
                
                }                
                else  if (lwvs < deltaOld)
                {
                    // Closer match
                    deltaOld = lwvs;
                    
                    bestP = powerP;
                    bestM = m;
                    bestN = n;
                            
                    //         mov     deltaOld, ax
                    //         mov     bestP, powerP
                    //         mov     ax, m  
                    //         mov     bestM, al
                    //         mov     ax, n
                    //         mov     bestN, al
                    
                    edx /= 10;
                    
                    //         mov     eax,edx
                    //         xor     edx,edx
                    //         mov     ebx,10
                    //         div     ebx             ; Convert
                    //         mov     vclkClosest,ax
                    vclkClosest = (U016)(edx & 0xFFFF);
                }
            }
        }
    }                             
    
  //  lwv = ((bestP << 16) | (bestN << 8) | (bestM));
    lwv = bestP;
    lwv <<= 16;
    lwv |= ((bestN << 8) | (bestM));
    
   
    // mov     bx, vclkClosest
    *clock = vclkClosest;
    
    return(lwv);
} 

//       FullCpuOn - Give the CPU full bandwidth to video memory
//
//       Entry:  None
//       Exit:   None
//
VOID FullCpuOn(VOID)
{
    U016  datum;
    
    datum = ReadIndexed(NV_PRMVIO_SRX, 0x01);    // Read SR1
    datum |= 0x2000;                            // Full Bandwidth bit ON
    WriteIndexed(NV_PRMVIO_SRX, datum);          // Set bit
} 
                                                   
//       FullCpuOff - Share the CPU bandwidth with the CRTC
//
//       Entry:  None
//       Exit:   None
//
VOID FullCpuOff(VOID)
{            
    U016  datum;
    
    datum = ReadIndexed(NV_PRMVIO_SRX, 0x01);    // Read SR1
    datum &= 0xDFFF;                            // Full Bandwidth bit OFF
    WriteIndexed(NV_PRMVIO_SRX, datum);          // Set bit            
} 

//
//       SetRegs - Set VGA registers
//
//       Entry:  ES:DI = Pointer to standard parameter table entry
//               DS = Seg0
//       Exit:   None
VOID SetRegs(MODEDESC *mi)
{                    
    // Load Sequencer and Misc. Output
    WriteIndexed(NV_PRMVIO_SRX, 0x0100);         // Sync Reset
    
    WritePriv08(NV_PRMVIO_MISC__WRITE, vga_tbl[mi->mdIMode].PT_Misc);
                                                   
    // Load Sequencers, beginning at SR1, load 4 SR's (SR1-4), from the mode table
    LoadIndexRange(NV_PRMVIO_SRX, 1, sizeof(SEQ), (U008 *)&(vga_tbl[mi->mdIMode].seq_regs));
                                            
    WriteIndexed(NV_PRMVIO_SRX, 0x0300);         // End Sync Reset
                                  
    // Load CRTC's
    WriteIndexed(NV_PRMCIO_CRX__COLOR, 0x2011);  // Unlock CR0-7
                                            
    // Load CRTC, beginning at CR0, for all CR's (CR0-18), from the mode table
    LoadIndexRange(NV_PRMCIO_CRX__COLOR, 0, sizeof(CRTC), (U008 *)&(vga_tbl[mi->mdIMode].crtc_regs));
                                                                                                   
    // Load GDC's
    // Load GR, beginning at GR0, for all GR's (GR0-8), from the mode table
    LoadIndexRange(NV_PRMVIO_GRX, 0, sizeof(GR), (U008 *)&(vga_tbl[mi->mdIMode].gr_regs));
}                                           

VOID LoadIndexRange(U032 addr, U008 st_idx, U008 count, U008 *regs)
{
    U016  i;
    U016  wv;
    
    // Program SR1-4
    for (i = 0; i < count; i++)
    {               
        wv = *regs++;
        wv <<= 8;               // Put data in high half
        wv |= st_idx++;         // Get index and increment it
        WriteIndexed(addr, wv);
    }               
}                                  

//       OEMPreSetRegs - Make special preparations to load registers
//
//       Entry:  ES:DI = Pointer to standard parameter table entry
//               DS = Seg0
//       Exit:   None
VOID OEMPreSetRegs(VOID)
{                      
    U016  rc;
    
    rc = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x28);
    rc &= 0xF8FF;                   // Strip to standard DAC settings
    WriteIndexed(NV_PRMCIO_CRX__COLOR, rc);
    
    rc = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x1A);
    rc |= 0x0200;                   // Use 6-bit DAC
    WriteIndexed(NV_PRMCIO_CRX__COLOR, rc);
}                               

//
//       ATCOff - Turn off Attribute Controller
//
//       Entry:  None
//       Exit:   None
VOID ATCOff(VOID)
{
    U016  flags = 0;
    
#ifdef DOS_COMPILE    
    _asm    pushf;                  // Save Interrupt state
    _asm    pop ax;
    _asm    mov flags,ax            // Save flags 
    _asm    cli;                    // No interrupts during this!
#endif    
    
    ReadPriv32(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop
    WritePriv08(NV_PRMCIO_ARX, 0x00);   // Turn off screen at AR
    
#ifdef DOS_COMPILE    
    _asm    mov ax,flags
    _asm    push ax
    _asm    popf
#endif    
}

//
//       ATCOn - Turn on Attribute Controller
//
//       Entry:  None
//       Exit:   None
VOID ATCOn(VOID)    
{
    U016  flags;
    
#ifdef DOS_COMPILE    
    _asm
    {
        pushf
        pop ax
        mov flags,ax
        cli
    }
#endif    
    
    ReadPriv32(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop
    WritePriv08(NV_PRMCIO_ARX, 0x20);   // Turn off screen at AR
    ReadPriv32(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop
                                    // So DOS Edit doesn't barf
#ifdef DOS_COMPILE    
    _asm
    {
        mov ax,flags
        push ax
        popf
    }
#endif        
}

//
// ValidateMode - Validate the passed mode is valid, and if it is,
//                return the pointer to the mode information block.
//
//  Entry:  U016  mode            // VESA Mode Number to validate
//
//  Exit:   MODEDESC *mi            // Mode Information Block Pointer
//                                  // NULL if error (invalid mode)
//  NOTES:  This function must also verify the operational mode,
//          and return failure status if not valid on TV
//

MODEDESC *ValidateMode(U016 mode)
{
    MODEDESC    *mi;
    
    for (mi = &mib[0]; mi->mdVMode != 0xFFFF; mi++)
    {
        if (mi->mdVMode == mode)
        {
            if (OEMValidateMode(mi))
                return(mi);            
            break;      // Out of the for - report error
        }   
    }   
    return(NULL);
}

// From OEMIsModeAvailable - validate the mode from the OEM perspective.
//
U008 OEMValidateMode(MODEDESC *m)
{
    U032   memory;
            
    // Are we running tv mode? If so, we need an additional filter
    if (pDev->Framebuffer.DisplayType == DISPLAY_TYPE_TV)
    {
        if (m->mdTVMode == 0xFF)
            return((U008)0);
    }
    
    // Validate we have enough memory
    // (XRes * YRes * Bpp)/8
    //           +--- XRes / 8
    //           V
    memory = (((m->mdXRes >> 3) * m->mdBPP) * m->mdYRes);
    memory += 0xFFFF;               // Take to next 64K bank size
    memory >>= 16;                  // Divide by 64K for number of banks
    
    // memory now has the 64K blocks necessary for this mode.
    
    if (((U016)memory) > OEMGetMemSize())
        return((U008)0);
    return((U008)1);
}

// some CRTC bit definitions
// CR07
#define VT08    1
#define VT09    0x20
#define VRS08   0x04
#define VRS09   0x80
#define EXT_VRS 0x84
#define VDE08   0x02
#define VDE09   0x40
#define VBS08   0x08
// CR09
#define VBS09   0x20
// CR25
#define VT10    0x01
#define VDE10   0x02
#define VRS10   0x04
#define VBS10   0x08

VOID FlatPanelCrtc( XRes )
{
U032    DacHcrtc, DacHt, Ht, Hrs, Hre, DacVcrtc, DacVt, Vt, Vrs, Vre, Vbs, data32;
U016    Attr, Seq;
U008    Cr07, Cr09, Cr11, Cr25;

    // check for pixel doubled modes
    if (XRes < 640)
    {
        Seq = ReadIndexed(NV_PRMVIO_SRX, 1);
        Seq |= 0x800;   // divide pixel clock to double size
        WriteIndexed(NV_PRMVIO_SRX, Seq);
    }        
    // Make sure attr is set correctly
    Cr07 = REG_RD08(NV_PRMCIO_INP0__COLOR); // read 3DA to toggle (data = don't care)
    REG_WR08(NV_PRMCIO_ARX, 0x30);          // select reg 0x10, bit 5 set to access reg (not palette)
    REG_WR08(NV_PRMCIO_ARX, 0x01);          // clear bit 5

    // New rules
    // VRS = VT - 3
    // VRE = VT - 2
    // HRS = HT - 3
    // HRE = HT - 2
    Ht = (ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x00)>>8);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)((Ht-3)<<8 | 0x04));   // HRS
    Hre = ((ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x05)>>8) & 0xe0);    // read CR05 and mask 4:0
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(((Ht-2) | Hre)<<8 | 0x05));   // HRE = Ht - 2, CR04[4:0]
    
    // gather VT bits
    Vt = (ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x06)>>8);
    Cr07 = (U008)(ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x07)>>8);
    Cr25 = (U008)(ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x25)>>8);
    if (Cr07 & VT08)
        Vt |= 0x0100;
    if (Cr07 & VT09)
        Vt |= 0x0200;
    if (Cr25 & VT10)
        Vt |= 0x0400;

    // VRS: CR10,7,25
    Vrs = Vt - 3;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(Vrs<<8 | 0x10));
    Cr07 &= ~EXT_VRS;
    if (Vrs & 0x100) Cr07 |= VRS08;
    if (Vrs & 0x200) Cr07 |= VRS09;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(Cr07<<8 | 0x07));
    if (Vrs & 0x400) Cr25 |= VRS10;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(Cr25<<8 | 0x25));
    
    // VRE: CR11[3:0]
    Vre = (Vt - 2) & 0x0f;
    Cr11 = (U008)(ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x11)>>8);
    Vre |= (Cr11 & 0xf0);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(Vre<<8 | 0x11));
    
    // VBS = VRS
    Cr09 = (U008)(ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x09)>>8);
    Vbs = Vrs;
                
    // write VBS            
    Cr07 &= ~VBS08;
    if (Vbs & 0x100) Cr07 |= VBS08;
    Cr09 &= ~VBS09;
    if (Vbs & 0x200) Cr09 |= VBS09;
    Cr25 &= ~VBS10;
    if (Vbs & 0x400) Cr25 |= VBS10;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(Vbs<<8 | 0x15));
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(Cr07<<8 | 0x07));
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(Cr09<<8 | 0x09));
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(Cr25<<8 | 0x25));
            
    // wait for vsync
    while (REG_RD08(NV_PRMCIO_INP0__COLOR) & 0x08);     // wait for active display
    while (!(REG_RD08(NV_PRMCIO_INP0__COLOR) & 0x08));  // wait for retrace start
    
    data32 = REG_RD32(NV_PRAMDAC_FP_DEBUG_0);           // usual macro won't help us here
    data32 &= ~(NV_PRAMDAC_FP_DEBUG_0_TEST_BOTH << 16);    // clear VCNTR bits
    REG_WR32(NV_PRAMDAC_FP_DEBUG_0, data32);
}

U008 getDisplayType(VOID)
{
    U016   rc;
               
    OEMEnableExtensions();          // Unlock the registers
    rc = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x28);
    if (rc & 0x8000)    // is VGA slaved to something?
    {
        rc = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x33);
        if (rc & 0x0100)
            return DISPLAY_TYPE_FLAT_PANEL;   
        else
            return DISPLAY_TYPE_TV;      
    }
    else
        return DISPLAY_TYPE_MONITOR;    
}

U008 isTV(VOID)
{
    U016   rc;
               
    OEMEnableExtensions();          // Unlock the registers
    rc = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x28);
    return((U008)((rc >> 8) & 0x80));
}

U008 isPAL(VOID)
{
    U016   rc;
               
    rc = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x2C);   // BIOS sets 2c bit 5 for PAL, bit 4 for NTSC
    return((U008)((rc >> 8) & 0x20));
}

//
//       OEMGetMemSize - Return the pre-calculated memory size
//
//       Entry:  None
//       Exit:   AX = Number of 64K blocks
//
U016 OEMGetMemSize(VOID)
{

#ifdef DEBUG
    // This should never happen, since RamSize was set during initMapping
    if (!pDev->Framebuffer.RamSize) {
        DBG_BREAKPOINT();
    }
#endif

    return (pDev->Framebuffer.RamSize >> 16);
}          


/**********************************************************************/
/**********************************************************************/
/**********************************************************************/
/**********************************************************************/
    
// And the following routines will become "throwaway" code, as they
// deal with the saving and restoring of the IO state during the
// accesses to the PRIV_IO.

/**********************************************************************/
/**********************************************************************/
/**********************************************************************/
/**********************************************************************/
//       SaveNVAccessState - Save the state of the NV real mode access registers
//
//       Entry:  ds = seg0
//               Extended CRTC registers unlocked
//       Exit:   cx  = CRTC address
//               eax = 32-bit NV address
//               bh  = real mode access control bits
//               bl  = real mode access register (NVRM_ACCESS)
//               dx  = LSW of 32-bit data register
//               Real mode access registers set to address
VOID SaveNVAccessState(ACCESS_STATE *as)
{                      
    U008   rc;
    
    U016  wval;
    U032   dval;
           
/*            
    as->crtc_addr = 0x3D4;           // Set 3D4 by default
    as->access_reg = 0x38;           // Set CR38
                                            
    // rc = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x38);
    dval = NV_PRMCIO_CRX__COLOR;
                           
    // Output the MSW of the address    
    outpw(0x3D2, (U016)((dval >> 16) & 0xFFFF));
                           
    // and the LSW of the address   
    outpw(0x3D0, (U016)(dval & 0xFFFF));
                                
    // Select the data port
    outpw(as->crtc_addr, (((NVRM_ACCESS_MASK | NVRM_DATA) << 8) | (as->access_reg)));
                                                                     
    outp(0x3D0, 0x38);              // Select the register
    wval = inpw(0x3D0);             // This data is Byte/Word accessable
    
    as->access_reg = (U008)(wval & 0xFF);
    as->access_bits = (U008)((wval >> 8) & 0xFF);
                               
    // Select the data port
    outpw(as->crtc_addr, (((NVRM_ACCESS_MASK | NVRM_DATA) << 8) | (as->access_reg)));
                                                                     
    as->data_low = inpw(0x3D0);      // Save lsw of 32-bit data
                               
    // Get the address next
    outpw(as->crtc_addr, (((NVRM_ACCESS_MASK | NVRM_ADDRESS) << 8) | (as->access_reg)));
                                                                        
    as->nv_address = inpw(0x3D2);    // Read MSW of address
    as->nv_address <<= 16;           // Put in high word.
    as->nv_address |= inpw(0x3D0);   // Read LSW of address
*/
    
}


//       RestoreNVAccessState - Restore the state of the NV real mode access registers
//
//       Entry:  ds = seg0
//               Extended CRTC registers unlocked
//               cx  = CRTC address
//               eax = 32-bit NV address
//               bh  = real mode access control bits
//               bl  = real mode access register (NVRM_ACCESS)
//               dx  = LSW of 32-bit data register
//       Exit:   none
VOID RestoreNVAccessState(ACCESS_STATE *as)
{
/*
    // Get the address next
    outpw(as->crtc_addr, (((NVRM_ACCESS_MASK | NVRM_ADDRESS) << 8) | (as->access_reg)));
    outpw(0x3D2, (U016)(as->nv_address >> 16));       // MSW of address
    outpw(0x3D0, (U016)(as->nv_address & 0xFFFF));    // LSW of address

    // Select the buffered data port
    outpw(as->crtc_addr, (((NVRM_ACCESS_MASK | NVRM_DATA32) << 8) | (as->access_reg)));
                                                                       
    outpw(0x3D0, as->data_low);     // LSW of address
    
    outpw(as->crtc_addr, (((as->access_bits) << 8) | (as->access_reg)));
*/    
}

/**********************************************************************/
/**********************************************************************/

//
// POST the chip, just like the BIOS normally does
//
#ifdef KJK
//
// Needs completely rewritten for NV4
//
VOID NvPost()
{
    U032 memconfig;
    U032 val32;

    //////////////////////////////////////////////
    //
    // Taken from BIOS POST sequence
    //
    
    //
    // Enable requisite engines
    //
    WritePriv32(0x11111111, NV_PMC_ENABLE);
    
    //
    // Program 100MHz MPLL clocking
    //
    if (ReadPriv32(NV_PEXTDEV_BOOT_0) & 0x00000040)
        WritePriv32(0x0001C40E, NV_PRAMDAC_MPLL_COEFF);    
    else
        WritePriv32(0x0001A30B, NV_PRAMDAC_MPLL_COEFF);    

    //
    // Program PFB Config to defaults
    //
    WritePriv32( DRF_DEF(_PFB,_CONFIG_0,_RESOLUTION,_DEFAULT)
               | DRF_DEF(_PFB,_CONFIG_0,_PIXEL_DEPTH,_DEFAULT)
               | DRF_DEF(_PFB,_CONFIG_0,_TILING,_DISABLED)
               | DRF_DEF(_PFB,_CONFIG_0,_TILING_DEBUG,_DISABLED), NV_PFB_CONFIG_0);
    
    //
    // Program VPLL clocking
    //
    if (ReadPriv32(NV_PEXTDEV_BOOT_0) & 0x00000040)
        WritePriv32(0x00028D0E, NV_PRAMDAC_MPLL_COEFF);    
    else
        WritePriv32(0x0001400C, NV_PRAMDAC_MPLL_COEFF);    
    
    //
    // Program PFB Power control
    //
    WritePriv32(DRF_DEF(_PFB,_GREEN_0,_LEVEL,_VIDEO_ENABLED), NV_PFB_GREEN_0);    

    //
    // Program memory timings based on framebuffer size
    //
    //
    
    //
    // Determine how wide/deep is the framebuffer
    //
    /*  
     Memory layout:

           4mb 128-bit     33221100 77665544 bbaa9988 ffeeddcc
           2mb 128-bit     33221100 77665544 xxxxxxxx xxxxxxxx

           128-bit covers address 0-3fffff in both 2mb and 4mb configs,
           but the second 2 dwords are garbage on 2mb boards.
              
           4mb 64-bit      33221100 77665544 bbaa9988 ffeeddcc
           2mb 64-bit      33221100 77665544 bbaa9988 ffeeddcc

           64-bit covers address 0-3fffff in 4mb configs, while
           64-bit covers address 0-1fffff in 2mb configs. All bytes are
           addressed.
    */
    
    memconfig = ReadPriv32(NV_PFB_BOOT_0);
    memconfig &= 0xFFFFFFFC;
    memconfig |= DRF_DEF(_PFB, _BOOT_0, _RAM_AMOUNT, _DEFAULT); // mask to 4meg, keep bus width
  
    //
    // Poke the framebuffer based on bus width
    //    
    if (memconfig & DRF_DEF(_PFB, _BOOT_0, _RAM_WIDTH_128, _ON))
    {
        //
        // 128bit test
        //
        WriteFb32('NV3A', 0x00200008);  // 2meg+8
    
        //
        // 4meg?
        //
        if (ReadFb32(0x00200008) != 'NV3A')
            //
            // Assume 2meg
            //
            memconfig = (memconfig & 0xFFFFFFFC) | DRF_DEF(_PFB, _BOOT_0, _RAM_AMOUNT, _2MB);
    
    } else {
    
        //
        // 64bit test
        //
        WriteFb32('NV3A', 0x00100000);  // 1meg
        WriteFb32('NV3B', 0x00300000);  // 3meg
        
        //
        // 4meg?
        //
        if (ReadFb32(0x00300000) != 'NV3B')
            //
            // Assume 2meg
            //
            memconfig = (memconfig & 0xFFFFFFFC) | DRF_DEF(_PFB, _BOOT_0, _RAM_AMOUNT, _2MB);
        
            //
            // 2meg?
            //
            if (ReadFb32(0x00100000) != 'NV3A')
                //
                // Assume 1meg
                //
                ;//memconfig = (memconfig & 0xFFFFFFFC) | DRF_DEF(_PFB, _BOOT_0, _RAM_AMOUNT, _1MB);
        
    }
    
    //
    // Write the memory config
    //
    WritePriv32(memconfig, NV_PFB_BOOT_0);
    
    // 
    // Now program the appropriate memory timings
    //
    if ((memconfig & 3) == DRF_DEF(_PFB, _BOOT_0, _RAM_AMOUNT, _2MB))
    {
        //
        // 2meg timings
        //
        WritePriv32(DRF_DEF(_PFB,_DELAY_1,_WRITE_ENABLE_RISE,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_WRITE_ENABLE_FALL,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_CAS_ENABLE_RISE,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_CAS_ENABLE_FALL,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_OUTPUT_DATA,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_RAS_ENABLE,_0), NV_PFB_DELAY_1);
                  
        WritePriv32(DRF_DEF(_PFB,_DEBUG_0,_CKE_ALWAYSON,_ON)
                  | DRF_DEF(_PFB,_DEBUG_0,_CKE_INVERT,_OFF)
                  | DRF_DEF(_PFB,_DEBUG_0,_CASOE,_ENABLED)
                  | DRF_DEF(_PFB,_DEBUG_0,_REFRESH_COUNTX64,_DEFAULT)
                  | DRF_DEF(_PFB,_DEBUG_0,_REFRESH,_ENABLED)
                  | DRF_DEF(_PFB,_DEBUG_0,_PAGE_MODE,_ENABLED), NV_PFB_DEBUG_0);
                  
        WritePriv32(DRF_DEF(_PFB,_CONFIG_1,_CAS_LATENCY,_3)
                  | DRF_DEF(_PFB,_CONFIG_1,_SGRAM100,_ENABLED)
                  | DRF_DEF(_PFB,_CONFIG_1,_RAS_RAS,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_RAS_PCHG,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_RAS_LOW,_DEFAULT) 
                  | DRF_DEF(_PFB,_CONFIG_1,_MRS_TO_RAS,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_WRITE_TO_READ,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_RAS_TO_CAS_M1,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_READ_TO_WRITE,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_READ_TO_PCHG,_ON), NV_PFB_CONFIG_1);
                  
        WritePriv32(DRF_DEF(_PFB,_RTL,_S,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_V,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_M,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_H,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_A,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_G,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_ARB_GR_HI_PRIOR,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_ARB_MEDIA_HI_PRIOR,_DEFAULT), NV_PFB_RTL);
                  
        //
        // Program 100MHz MPLL clocking
        //
        if (ReadPriv32(NV_PEXTDEV_BOOT_0) & 0x00000040)
            WritePriv32(0x0001C40E, NV_PRAMDAC_MPLL_COEFF);    
        else
            WritePriv32(0x0001A30B, NV_PRAMDAC_MPLL_COEFF);    
                  
    } else {
        //
        // 4meg
        //
        WritePriv32(DRF_DEF(_PFB,_DELAY_1,_WRITE_ENABLE_RISE,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_WRITE_ENABLE_FALL,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_CAS_ENABLE_RISE,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_CAS_ENABLE_FALL,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_OUTPUT_DATA,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_RAS_ENABLE,_0), NV_PFB_DELAY_1);
                  
        WritePriv32(DRF_DEF(_PFB,_DEBUG_0,_CKE_ALWAYSON,_ON)
                  | DRF_DEF(_PFB,_DEBUG_0,_CKE_INVERT,_OFF)
                  | DRF_DEF(_PFB,_DEBUG_0,_CASOE,_ENABLED)
                  | DRF_DEF(_PFB,_DEBUG_0,_REFRESH_COUNTX64,_DEFAULT)
                  | DRF_DEF(_PFB,_DEBUG_0,_REFRESH,_ENABLED)
                  | DRF_DEF(_PFB,_DEBUG_0,_PAGE_MODE,_ENABLED), NV_PFB_DEBUG_0);
    
        WritePriv32(DRF_DEF(_PFB,_CONFIG_1,_CAS_LATENCY,_3)
                  | DRF_DEF(_PFB,_CONFIG_1,_SGRAM100,_ENABLED)
                  | DRF_DEF(_PFB,_CONFIG_1,_RAS_RAS,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_RAS_PCHG,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_RAS_LOW,_DEFAULT) 
                  | DRF_DEF(_PFB,_CONFIG_1,_MRS_TO_RAS,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_WRITE_TO_READ,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_RAS_TO_CAS_M1,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_READ_TO_WRITE,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_READ_TO_PCHG,_ON), NV_PFB_CONFIG_1);
    
        WritePriv32(DRF_DEF(_PFB,_RTL,_S,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_V,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_M,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_H,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_A,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_G,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_ARB_GR_HI_PRIOR,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_ARB_MEDIA_HI_PRIOR,_DEFAULT), NV_PFB_RTL);
    
        //
        // Program 100MHz MPLL clocking
        //
        if (ReadPriv32(NV_PEXTDEV_BOOT_0) & 0x00000040)
            WritePriv32(0x0001C40E, NV_PRAMDAC_MPLL_COEFF);    
        else
            WritePriv32(0x0001A30B, NV_PRAMDAC_MPLL_COEFF);    
    
    }
    
    //
    // Enable clocking
    //
    WritePriv32(DRF_DEF(_PRAMDAC,_PLL_COEFF_SELECT,_DLL_BYPASS,_FALSE)
              | DRF_DEF(_PRAMDAC,_PLL_COEFF_SELECT,_MPLL_SOURCE,_PROG)
              | DRF_DEF(_PRAMDAC,_PLL_COEFF_SELECT,_MPLL_BYPASS,_FALSE)
              | DRF_DEF(_PRAMDAC,_PLL_COEFF_SELECT,_VPLL_SOURCE,_DEFAULT)
              | DRF_DEF(_PRAMDAC,_PLL_COEFF_SELECT,_VPLL_BYPASS,_FALSE) 
              | DRF_DEF(_PRAMDAC,_PLL_COEFF_SELECT,_PCLK_SOURCE,_VPLL)
              | DRF_DEF(_PRAMDAC,_PLL_COEFF_SELECT,_VCLK_RATIO,_DB1), NV_PRAMDAC_PLL_COEFF_SELECT);
            
    //
    // Setup optimal PCI interface
    //
    WritePriv32(DRF_DEF(_PBUS,_DEBUG_1,_PCIM_THROTTLE,_DISABLED)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIM_CMD,_SIZE_BASED)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIM_AGP,_IS_AGP)
              | DRF_DEF(_PBUS,_DEBUG_1,_AGPM_CMD,_LP_ONLY)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIS_WRITE,_0_CYCLE)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIS_2_1,_ENABLED)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIS_RETRY,_ENABLED)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIS_RD_BURST,_ENABLED)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIS_WR_BURST,_ENABLED)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIS_EARLY_RTY,_ENABLED)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIS_RMAIO,_DISABLED)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIS_CPUQ,_ENABLED)
              | DRF_DEF(_PBUS,_DEBUG_1,_SPARE1,_ZERO)
              | DRF_DEF(_PBUS,_DEBUG_1,_SPARE2,_ZERO), NV_PBUS_DEBUG_1);                  


    //
    // Make sure hsync and vsync are on (we only set them in DPMS calls)
    //
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x1A) & 0x3FFF) | 0x0000);
    
    //
    // Boot with TV off, and set for NTSC if it was on.
    // Also set horizontal pixel adjustment
    // Sets pixel format to VGA
    //
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x28) & 0x00FF) | 0x0000);
    
    //
    // Float DDC pins high (not touched during a mode set or save/restore state)
    //
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x3F) & 0x00FF) | 0x3300);

    //
    // Disable DDC
    //
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x3F) & 0x00FF) | 0x3200);

    //
    // Program NTSC TV settings
    //
    WritePriv32(0x00000006, NV_PRAMDAC_VSERR_WIDTH); 
    WritePriv32(0x0000000C, NV_PRAMDAC_VEQU_END);
    WritePriv32(0x0000000C, NV_PRAMDAC_VBBLANK_END);
    WritePriv32(0x00000024, NV_PRAMDAC_VBLANK_END);
    WritePriv32(0x0000020C, NV_PRAMDAC_VBLANK_START);
    WritePriv32(0x00000206, NV_PRAMDAC_VBBLANK_START);
    WritePriv32(0x00000207, NV_PRAMDAC_VEQU_START);
    WritePriv32(0x0000020D, NV_PRAMDAC_VTOTAL);
    WritePriv32(0x0000003F, NV_PRAMDAC_HSYNC_WIDTH);
    WritePriv32(0x00000048, NV_PRAMDAC_HBURST_START);
    WritePriv32(0x0000006A, NV_PRAMDAC_HBURST_END);
    WritePriv32(0x0000034A, NV_PRAMDAC_HBLANK_START);
    WritePriv32(0x00000088, NV_PRAMDAC_HBLANK_END);
    WritePriv32(0x0000035A, NV_PRAMDAC_HTOTAL);
    WritePriv32(0x0000001F, NV_PRAMDAC_HEQU_WIDTH);
    WritePriv32(0x0000016E, NV_PRAMDAC_HSERR_WIDTH);

    //
    // If strapped to PAL, program PAL TV settings
    //
    if ((ReadPriv32(NV_PEXTDEV_BOOT_0) & 0x00000180) == 0x00000100)
    {
    
        WritePriv32(0x00000005, NV_PRAMDAC_VSERR_WIDTH);
        WritePriv32(0x0000000A, NV_PRAMDAC_VEQU_END);
        WritePriv32(0x0000000A, NV_PRAMDAC_VBBLANK_END);
        WritePriv32(0x0000002C, NV_PRAMDAC_VBLANK_END);
        WritePriv32(0x0000026C, NV_PRAMDAC_VBLANK_START);        
        WritePriv32(0x00000269, NV_PRAMDAC_VBBLANK_START);
        WritePriv32(0x0000026C, NV_PRAMDAC_VEQU_START);
        WritePriv32(0x00000271, NV_PRAMDAC_VTOTAL);
        WritePriv32(0x0000003F, NV_PRAMDAC_HSYNC_WIDTH);
        WritePriv32(0x00000048, NV_PRAMDAC_HBURST_START);
        WritePriv32(0x0000006A, NV_PRAMDAC_HBURST_END);
        WritePriv32(0x00000350, NV_PRAMDAC_HBLANK_START);
        WritePriv32(0x00000092, NV_PRAMDAC_HBLANK_END);
        WritePriv32(0x00000360, NV_PRAMDAC_HTOTAL);
        WritePriv32(0x0000001F, NV_PRAMDAC_HEQU_WIDTH);
        WritePriv32(0x0000016E, NV_PRAMDAC_HSERR_WIDTH);
    }
    
}
#endif // KJK

/**********************************************************************/
/**********************************************************************/


//
// The following MAIN() routine is only used for standalone DOS compiles
//                                   
#ifdef DOS_COMPILE                                                 
VOID main(U016 ac, U008 **av)
{
    U016  mode;                   // Mode to be set
    U016  rc;                     // Return code
    
    printf("NVIDIA MODESET V1.00\n\n");
    
    if (ac < 2)
    {
        printf("Usage: modeset vmode\n");
        printf("       vmode - Vesa Mode Number\n");
        exit(1);
    }           
    
    if ((mode = h2i(*(++av))) == 0xFFFF)
    {
        printf("Error! Bad Vesa Mode Number\n");
        exit(2);
    }        
    
    printf("Setting Mode 0x%02X\n", mode);
    getchar();
    
    rc = VBESetMode(mode);
    
    if (((rc & 0xFF) != 0x4F) || ((rc & 0xFF00) >> 8))
    {
        printf("Error! Could Not Set Mode 0x%02X [rc=%04X]\n", mode, rc);
        exit(3);
    }        
                                                      
    exit(0);
}

//
// h2i - convert Hex string to an Unsigned Integer
U016 h2i(U008 *str)                 
{
    U016  sus = 0;                // Starting unsigned short
    U016  i;
    U016  val;                    // Conversion value
    
    // Since we only do U016's, we have a max of 0xFFFF-1
    if ((i = strlen(str)) > 4)
        return(0xFFFF);
    
    while (i--)
    {    
        val = toupper(*str) - 0x30;  // Convert Hex 0-9
        if (val > 9)
        {
            val -= 7;               // Take 7 more to convert A-F
            if (val < 0x0A || val > 0x0F)
                return(0xFFFF);     // Error!
        }                                  
        sus *= 16;                  // Shift by 4
        sus += val;             
        str++;
    }                                                 
    return(sus);
}
#endif // DOS_COMPILE
 


//****************************************************************************************
//
//  Program the I2C device for a display mode
//  returns:    status word
U016 setI2C(MODEDESC *minfo)
{
U016     status;

#ifdef IKOS
    return ERR_I2C_COMM;
#endif
    // Identify which part: Chrontel or Brooktree?
    // ID was done at fbinit.
    i2cInit(pDev->Dac.TVOutPortID);
    switch (pDev->Framebuffer.EncoderID)
    {
        case 0x88:
        case 0x8A:
            status = programBrooktree(minfo->mdTVMode);
            break;
        case 0xEA:
        case 0xEC:
            status = programChrontel(minfo->mdTVMode);
            break;                        
    }
    return (status);
}

#define	HSYNCWIDTH	0x3f	// bits we must preserve	
//****************************************************************************************
//
//  Program the Brooktree device for a display mode
//  args:       internal TV mode
//  returns:    status word
U016 programBrooktree(U016 TVmode)
{
U016    i, status;
U008    *strptr;
U008    Data, Adr;

    // to send a string to the I2C: send the start sequence, send the string, send the stop sequence

    if (pDev->Framebuffer.DisplayType != DISPLAY_TYPE_TV)    // can be MONITOR, TV, or FLAT PANEL
    {
        TVmode = TV_MODE_640x480;   // program the encoder anyway, to get synched display on TV
    }        

    // send an init string
    i2cStart(pDev->Dac.TVOutPortID);                       // start state for I2C
    strptr = (U008 *)&BT_Init;          // send init sequence
    status = i2cSendByte(pDev->Dac.TVOutPortID, (U008)pDev->Framebuffer.EncoderID);   // send ID
    strptr++;                                  // string includes ID, skip it
    for (i=0; *strptr != 0xff; i++)
    {
        status = i2cSendByte(pDev->Dac.TVOutPortID, *strptr++);  
        if (status)
            break;
    }     
    i2cStop(pDev->Dac.TVOutPortID);                         // end state for I2C

    // get a pointer to the string to write to the I2C controller
    if (TVformat == NTSC)
        strptr = (U008 *)BT_NTSC[TVmode];
    else
        strptr = (U008 *)BT_PAL[TVmode];

    // send a timing string
    i2cStart(pDev->Dac.TVOutPortID);                       // start state for I2C
    status = i2cSendByte(pDev->Dac.TVOutPortID, (U008)pDev->Framebuffer.EncoderID);   // send ID
    strptr++;                                  // string includes ID, skip it
    for (i=0; *strptr != 0xff; i++)
    {
        status = i2cSendByte(pDev->Dac.TVOutPortID, *strptr++);
        if (status)
            break;
    }
    i2cStop(pDev->Dac.TVOutPortID);                           // end state for I2C

    // If not TV, blank TV image
    if (pDev->Framebuffer.DisplayType != DISPLAY_TYPE_TV)    // can be MONITOR, TV, or FLAT PANEL
    {
        Data = 0x07;                // set luminance to 0 gain
        Adr = 0xca;
        i2cWrite(pDev->Dac.TVOutPortID, (U008)(pDev->Framebuffer.EncoderID >> 1), (U016) 1, &Adr, 1, &Data);
        Data = 0x07;                // set chroma to 0 gain
        Adr = 0xcc;
        i2cWrite(pDev->Dac.TVOutPortID, (U008)(pDev->Framebuffer.EncoderID >> 1), (U016) 1, &Adr, 1, &Data);
    }
    return (status);
}

//****************************************************************************************
//
//  Program the Chrontel device for a display mode
//  args:       internal TV mode
//  returns:    status word
U016 programChrontel(U016 TVmode)
{    
U016    i, status;
U008    *strptr;
U008    *initptr;

    if (pDev->Framebuffer.EncoderType != NV_ENCODER_CHRONTEL_7003) 
    {
        // The only Chrontel encoder we know how to program is 7003.
        return ERR_I2C_UNKNOWN;
    }

    // to send a string to the I2C: send the start sequence, send the string, send the stop sequence

    if ((pDev->Framebuffer.DisplayType != DISPLAY_TYPE_TV) | (TVmode == 0xff))    // can be MONITOR, NTSC, or PAL
    {
        TVmode = TV_MODE_640x480;   // program the encoder anyway, to get synched display on TV
    }        
    
    // send an init string
    i2cStart(pDev->Dac.TVOutPortID);                   // start state for I2C
    strptr = (U008 *)&I2C_Init;     // send init sequence
    status = i2cSendByte(pDev->Dac.TVOutPortID, (U008)pDev->Framebuffer.EncoderID);   // send ID
    strptr++;                                  // string includes ID, skip it
    for (i=0; *strptr != 0xff; i++)
    {
//      DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, " ", *initptr);
        status = i2cSendByte(pDev->Dac.TVOutPortID, *strptr++);  
        if (status)
            break;
    }     
    i2cStop(pDev->Dac.TVOutPortID);                     // end state for I2C

    // get a pointer to the string to write to the I2C controller
    if (TVformat == NTSC)
        strptr = (U008 *)i2c_NTSC[TVmode];
    else
        strptr = (U008 *)i2c_PAL[TVmode];
            
    // send a timing string
    i2cStart(pDev->Dac.TVOutPortID);                   // start state for I2C
    i2cSendByte(pDev->Dac.TVOutPortID, (U008)pDev->Framebuffer.EncoderID);   // send ID
    strptr++;                                  // string includes ID, skip it
    for (i=0; *strptr != 0xff; i++)
    {
//        DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, " ", *strptr);
        status = i2cSendByte(pDev->Dac.TVOutPortID, *strptr++);
        if (status)
            break;
    }
    i2cStop(pDev->Dac.TVOutPortID);                     // end state for I2C
    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\modeset\MODEDATA.C ===
//
// modedata.c - Data tables used for setting extended VESA modes.
//
// Copyright (c) 1997 - NVidia Corporation. All Rights Reserved.
//

#ifdef DOS_COMPILE
#include    <stdio.h>
#include    "modes.h"
#endif // DOS_COMPILE

//  Basic VGA mode. This setup is used initially in all mode sets.
VGATBL   vga_tbl[] =
{
    // U008   columns;
    // U008   rows;
    // U008   char_height;
    // U016  RegenLenght;
    // SEQ     seq_regs;              // SR1-4
    // U008   PT_Misc;               // Misc Register
    // CRTC    crtc_regs;             // CR0-18
    // U008   PT_ATC[20];            // Attribute Controller
    // GR      gr_regs;               // GR0-8

    // Basic CRTC Table for Packed Pixel Graphics Modes.
    {0x50, 0x1D, 0x10,
     0xFFFF,
    {0x01, 0x0F, 0x00, 0x0E},               // Seq
     0xEB,
    {0x5F, 0x4F, 0x4F, 0x83, 0x53, 0x9F,    // CR0-18
     0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0xEA, 0x0C,
     0xDF, 0x50, 0x00, 0xDF, 0x0C, 0xE3,
     0xFF},
     0x00, 0x01, 0x02, 0x03, 0x04, 0x05,    // Attr
     0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B,
     0x0C, 0x0D, 0x0E, 0x0F, 0x01, 0x00,
     0x0F, 0x00,
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x40,    // GR
     0x05, 0x0F, 0xFF}
    },
     
    // Basic CRTC Table for Planar Graphics Modes.
    // We never use this! (ported this code from BIOS)
    {0x50, 0x1D, 0x10,
     0xA000,
    {0x01, 0x0F, 0x00, 0x06},
     0xE3,
    {0x5F, 0x4F, 0x50, 0x82, 0x54, 0x80,
     0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0xEA, 0x8C,
     0xDF, 0x28, 0x00, 0xE7, 0x04, 0xE3,
     0xFF},
     0x00, 0x01, 0x02, 0x03, 0x04, 0x05,
     0x14, 0x07, 0x38, 0x39, 0x3A, 0x3B,
     0x3C, 0x3D, 0x3E, 0x3F, 0x01, 0x00,
     0x0F, 0x00,
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x05, 0x0F, 0xFF}
    }
};   


//  Mode Information Block
//  This is the starting point for a mode set (after vga_tbl). 
//  This shows which crtc_override and e_regs (extended register) table to use.
//  This is converted from the BIOS, and therefore has some unused fields.

//  define some special cases
#define TV_MODE_320x200 0
#define TV_MODE_320x240 1
#define TV_MODE_320x400 2
#define TV_MODE_400x300 3
#define TV_MODE_480x360 4
#define TV_MODE_512x384 5
#define TV_MODE_640x480 6   // tv_modetbl entry for 640x480

MODEDESC mib[] =             // Our Mode List
{                                       
//    +------- vmode                                max DCLK     ------+
//    |      +----- imode                           row offset   -----+|
//    |      |      +----- std_modetbl              y resolution ----+||
//    |      |      |      +----- ext_modetbl       x resolution ---+|||
//    |      |      |      |     +----- tv_modetbl                  ||||
//    |      |      |      |     |     +----- crtc_override         ||||
//    |      |      |      |     |     |     +----- bits per pixel  ||||
//    |      |      |      |     |     |     |    +-----------------+|||
//    |      |      |      |     |     |     |    |     +------------+||
//    |      |      |      |     |     |     |    |     |     +-------+|
//    |      |      |      |     |     |     |    |     |     |    +---+
//    V      V      V      V     V     V     V    V     V     V    V    
    {0x100, 0x5B, PACKED, 0x11, 0x06, 0x06,  8,  640,  400,  640, MAX_DCLK},  // Mode 100 - 640x400    8bpp
    {0x101, 0x5F, PACKED, 0x01, 0x07, 0xFF,  8,  640,  480,  640, MAX_DCLK},  // Mode 101 - 640x480    8bpp
//    {0x102, 0x58, PLANAR, 0x02, 0x03, 0x07,  4,  800,  600,  100, MAX_ATC },  // Mode 102 - 800x600    4bpp
//    {0x102, 0x6A, PLANAR, 0x02, 0x03, 0x07,  4,  800,  600,  100, MAX_ATC },  // Mode  6A - 800x600    4bpp
    {0x103, 0x5C, PACKED, 0x03, 0x08, 0x08,  8,  800,  600,  800, MAX_DCLK},  // Mode 103 - 800x600    8bpp
//    {0x104, 0x5D, PLANAR, 0x04, 0x03, 0x0A,  4, 1024,  768, 1024, MAX_ATC },  // Mode 104 - 1024x768   4bpp
    {0x105, 0x5E, PACKED, 0x05, 0xff, 0x0B,  8, 1024,  768, 1024, MAX_DCLK},  // Mode 105 - 1024x768   8bpp
//    {0x106, 0x5A, PLANAR, 0x06, 0x03, 0x0D,  4, 1280, 1024,  160, MAX_ATC },  // Mode 106 - 1280x1024  4bpp
    {0x107, 0x6B, PACKED, 0x07, 0xff, 0x0E,  8, 1280, 1024, 1280, MAX_DCLK},  // Mode 107 - 1280x1024  8bpp
    {0x10E, 0x78, PACKED, 0x0D, 0x00, 0x00, 16,  320,  200,  640, MAX_DCLK},  // Mode 10E - 320x200   16bpp
    {0x10F, 0x20, PACKED, 0x12, 0x00, 0x00, 32,  320,  200, 1280, MAX_DCLK},  // Mode 10F - 320x200 32bpp
    {0x111, 0x6E, PACKED, 0x0E, 0x07, 0xFF, 16,  640,  480, 1280, MAX_DCLK},  // Mode 111 - 640x480 16bpp
    {0x112, 0x21, PACKED, 0x19, 0x07, 0xFF, 32,  640,  480, 2560, MAX_DCLK},  // Mode 112 - 640x480 32bpp
    {0x114, 0x6F, PACKED, 0x0F, 0x08, 0x08, 16,  800,  600, 1600, MAX_DCLK},  // Mode 114 - 800x600 16bpp
    {0x115, 0x22, PACKED, 0x1A, 0x08, 0x08, 32,  800,  600, 3200, MAX_DCLK},  // Mode 115 - 800x600 32bpp
    {0x117, 0x72, PACKED, 0x10, 0xff, 0x0B, 16, 1024,  768, 2048, MAX_DCLK},  // Mode 117 - 1024x768 16bpp
    {0x118, 0x3F, PACKED, 0x1C, 0xff, 0x0B, 32, 1024,  768, 4096, MAX_DCLK},  // Mode 118 - 1024x768 32bpp
    {0x11A, 0x44, PACKED, 0x2F, 0xff, 0x0E, 16, 1280, 1024, 2560, MAX_DCLK},  // Mode 11A - 1280x1024 16bbp
    {0x130, 0x30, PACKED, 0x1E, 0x00, 0x00,  8,  320,  200,  320, MAX_DCLK},  // Mode 130 - 320x200  8bbp
    {0x131, 0x31, PACKED, 0x1F, 0x02, 0x02,  8,  320,  400,  320, MAX_DCLK},  // Mode 131 - 320x400 8bpp
    {0x132, 0x32, PACKED, 0x27, 0x02, 0x02, 16,  320,  400,  640, MAX_DCLK},  // Mode 132 - 320x400 16bpp
    {0x133, 0x33, PACKED, 0x13, 0x02, 0x02, 32,  320,  400, 1280, MAX_DCLK},  // Mode 133 - 320x400 32bpp
    {0x134, 0x34, PACKED, 0x20, 0x01, 0x01,  8,  320,  240,  320, MAX_DCLK},  // Mode 134 - 320x240 8bpp
    {0x135, 0x35, PACKED, 0x28, 0x01, 0x01, 16,  320,  240,  640, MAX_DCLK},  // Mode 135 - 320x240 16
    {0x136, 0x36, PACKED, 0x14, 0x01, 0x01, 32,  320,  240, 1280, MAX_DCLK},  // Mode 136 - 320x240 32
    {0x137, 0x37, PACKED, 0x21, 0x03, 0x03,  8,  400,  300,  400, MAX_DCLK},  // Mode 137 - 400x300 8
    {0x138, 0x38, PACKED, 0x29, 0x03, 0x03, 16,  400,  300,  800, MAX_DCLK},  // Mode 138 - 400x300 16
    {0x139, 0x39, PACKED, 0x15, 0x03, 0x03, 32,  400,  300, 1600, MAX_DCLK},  // Mode 139 - 400x300 32
    {0x13A, 0x3A, PACKED, 0x23, 0x05, 0x05,  8,  512,  384,  512, MAX_DCLK},  // Mode 13A - 512x384 8
    {0x13B, 0x3B, PACKED, 0x2B, 0x05, 0x05, 16,  512,  384, 1024, MAX_DCLK},  // Mode 13B - 512x384 16
    {0x13C, 0x3C, PACKED, 0x17, 0x05, 0x05, 32,  512,  384, 2048, MAX_DCLK},  // Mode 13C - 512x384 32
    {0x13D, 0x3D, PACKED, 0x2C, 0x06, 0x06, 16,  640,  400, 1280, MAX_DCLK},  // Mode 13D - 640x400 16
    {0x13E, 0x3E, PACKED, 0x18, 0x06, 0x06, 32,  640,  400, 2560, MAX_DCLK},  // Mode 13E - 640x400 32
    {0x141, 0x41, PACKED, 0x25, 0xff, 0x0C,  8, 1152,  864, 1152, MAX_DCLK},  // Mode 141 - 1152x864 8
    {0x142, 0x42, PACKED, 0x2E, 0xff, 0x0C, 16, 1152,  864, 2304, MAX_DCLK},  // Mode 142 - 1152x864 16
    {0x143, 0x43, PACKED, 0x1D, 0xff, 0x0C, 32, 1152,  864, 4608, MAX_DCLK},  // Mode 143 - 1152x864 32
    {0x145, 0x45, PACKED, 0x26, 0xFF, 0x0F,  8, 1600, 1200, 1600, MAX_DCLK},  // Mode 145 - 1600x1200 8
    {0x146, 0x46, PACKED, 0x30, 0xFF, 0x0F, 16, 1600, 1200, 3200, MAX_DCLK},  // Mode 146 - 1600x1200 16
    // more TV modes?
    {0x147, 0x47, PACKED, 0x22, 0x04, 0x04,  8,  480,  360,  480, MAX_DCLK},  // Mode 147 - 480x360 8
    {0x148, 0x48, PACKED, 0x2A, 0x04, 0x04, 16,  480,  360,  960, MAX_DCLK},  // Mode 148 - 480x360 16
    {0x149, 0x49, PACKED, 0x16, 0x04, 0x04, 32,  480,  360, 1920, MAX_DCLK},  // Mode 149 - 480x360 32
    {0x14A, 0x4A, PACKED, 0x24, 0xff, 0x09,  8,  960,  720,  960, MAX_DCLK},  // Mode 14A - 960x720 8
    {0x14B, 0x4B, PACKED, 0x2D, 0xff, 0x09, 16,  960,  720, 1920, MAX_DCLK},  // Mode 14B - 960x720 16
    {0x14C, 0x4C, PACKED, 0x1B, 0xff, 0x09, 32,  960,  720, 3840, MAX_DCLK},  // Mode 14C - 960x720 32
    {0x14D, 0x4D, PACKED, 0x31, 0xff, 0x0E, 32, 1280, 1024, 5120, MAX_DCLK},  // Mode 14D - 1280x1024 32
    {0x14E, 0x4E, PACKED, 0x32, 0xFF, 0x0F, 32, 1600, 1200, 6400, MAX_DCLK},  // Mode 14E - 1600x1200 32

	// JJV - New Modes
    {0x14F, 0x80, PACKED, 0x33, 0xFF, 0x10,  8, 1800, 1440, 1800, MAX_DCLK},    // Mode 14F - 1800x1440 8
    {0x150, 0x81, PACKED, 0x34, 0xFF, 0x11, 16, 1800, 1440, 3600, MAX_DCLK},    // Mode 150 - 1800x1440 16
    {0x151, 0x82, PACKED, 0x35, 0xFF, 0x12,  8, 1920, 1080, 1920, MAX_DCLK},    // Mode 151 - 1920x1080 8
    {0x152, 0x83, PACKED, 0x36, 0xFF, 0x13, 16, 1920, 1080, 3840, MAX_DCLK},    // Mode 152 - 1920x1080 16
    {0x153, 0x84, PACKED, 0x37, 0xFF, 0x14, 32, 1920, 1080, 7680, MAX_DCLK},    // Mode 153 - 1920x1080 32
    {0x154, 0x85, PACKED, 0x38, 0xFF, 0x15,  8, 1920, 1200, 1920, MAX_DCLK},    // Mode 154 - 1920x1200 8
    {0x155, 0x86, PACKED, 0x39, 0xFF, 0x16, 16, 1920, 1200, 3840, MAX_DCLK},    // Mode 155 - 1920x1200 16
    {0x156, 0x87, PACKED, 0x3A, 0xFF, 0x17, 32, 1920, 1200, 7680, MAX_DCLK},    // Mode 156 - 1920x1200 32
    
    {0x157, 0x88, PACKED, 0x3B, 0xFF, 0x18, 32, 1800, 1440, 1800, MAX_DCLK},    // Mode 157 - 1800x1440 32
    {0x158, 0x89, PACKED, 0x3C, 0xFF, 0x19,  8, 2048, 1536, 2048, MAX_DCLK},    // Mode 158 - 2048x1536 8
    {0x159, 0x8A, PACKED, 0x3D, 0xFF, 0x1A, 16, 2048, 1536, 2048, MAX_DCLK},    // Mode 159 - 2048x1536 16
    {0x15A, 0x8B, PACKED, 0x3E, 0xFF, 0x1B, 32, 2048, 1536, 2048, MAX_DCLK},    // Mode 15A - 2048x1536 32
    // JJV - New Modes

    {0xFFFF,0xFF, 0xFF,   0xFF, 0xFF, 0xFF,  0,    0,    0,    0, 0}          // List Terminator
};                                 

//  Table of extended (NV only) CRTC registers
//  The data is in packed format (bits from several regs combined in each byte)
//
//  Array of xrFlags, xrOffset, xrVOver, xrPixFmt, xrVOffset, xrIntlace, xrRegenLength,
//  xrClkSel.  See MODES.H for bit definitions.
//
EXTREGS eregs[] =    // Extended Register Tables
{                                      
    {0x49, 0x00, 0x20, 0x30, 0xFF, 0xFF, 0x0000, CLKID_25_175}, // 00: VGA Modes	  00:
    {0x4C, 0x00, 0x20, 0x39, 0x50, 0xFF, 0xFFFF, CLKID_25_175}, // 08: Mode 5F/101	  01:
    {0x48, 0x00, 0x20, 0x30, 0x32, 0xFF, 0xFA00, CLKID_40},     // 09: Mode 58/6A/102 02:
    {0x4C, 0x00, 0x20, 0x39, 0x64, 0xFF, 0xFFFF, CLKID_40},     // 0A: Mode 5C/103	  03:
    {0x48, 0x00, 0x20, 0x30, 0x40, 0xFF, 0xFFFF, CLKID_65},     // 0B: Mode 5D/104	  04:
    {0x4C, 0x00, 0x20, 0x39, 0x80, 0xFF, 0xFFFF, CLKID_65},     // 0C: Mode 5E/105	  05:
    {0x08, 0x00, 0x15, 0x30, 0x50, 0xFF, 0xFFFF, CLKID_108_5},  // 0F: Mode 5A/106	  06:
    {0x0C, 0x00, 0x15, 0x39, 0xA0, 0xFF, 0xFFFF, CLKID_108_5},  // 10: Mode 6B/107	  07:
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0000, 0x00},         // Text - unused mode 08:                             
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0000, 0x00},         // Text - unused mode 09:                             
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0000, 0x00},         // Text - unused mode 0A:                             
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0000, 0x00},         // Text - unused mode 0B:                             
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0000, 0x00},         // Text - unused mode 0C:                             
    {0x44, 0x80, 0x20, 0x3A, 0x50, 0xFF, 0xFFFF, CLKID_12_588}, // 22: Mode 78		  0D:
    {0x44, 0x80, 0x20, 0x3A, 0xA0, 0xFF, 0xFFFF, CLKID_25_175}, // 23: Mode 6E		  0E:
    {0x44, 0x80, 0x20, 0x3A, 0xC8, 0xFF, 0xFFFF, CLKID_40},     // 24: Mode 6F		  0F:
    {0x54, 0x81, 0x20, 0x3A, 0x00, 0xFF, 0xFFFF, CLKID_65},     // 25: Mode 72		  10:
    {0x4C, 0x00, 0x20, 0x39, 0x50, 0xFF, 0xFFFF, CLKID_25_175}, // 26: Mode 5B		  11:
    {0x44, 0x00, 0x20, 0x3B, 0xA0, 0xFF, 0xFFFF, CLKID_12_588}, // 27: Mode 20		  12:
    {0x44, 0x00, 0x20, 0x3B, 0xA0, 0xFF, 0xFFFF, CLKID_12_588}, // 27: Mode 20		  13:
    {0x44, 0x00, 0x20, 0x3B, 0xA0, 0xFF, 0xFFFF, CLKID_12_588}, // 27: Mode 20		  14:
    {0x44, 0x00, 0x20, 0x3B, 0xC8, 0xFF, 0xFFFF, CLKID_20},     // 27: Mode 20		  15:
    {0x44, 0x00, 0x20, 0x3B, 0xF0, 0xFF, 0xFFFF, CLKID_27_93},  // 25: Mode 72		  16:
    {0x54, 0x01, 0x20, 0x3B, 0x00, 0xFF, 0xFFFF, CLKID_32_5},   // 25: Mode 72		  17:
    {0x54, 0x01, 0x20, 0x3B, 0x40, 0xFF, 0xFFFF, CLKID_25_175}, // 26: Mode 5B		  18:
    {0x54, 0x01, 0x20, 0x3B, 0x40, 0xFF, 0xFFFF, CLKID_25_175}, // 28: Mode 21		  19:
    {0x54, 0x01, 0x20, 0x3B, 0x90, 0xFF, 0xFFFF, CLKID_40},     // 29: Mode 22		  1A:
    {0x54, 0x01, 0x20, 0x3B, 0xE0, 0xFF, 0xFFFF, CLKID_55_86},  // 25: Mode 72		  1B:
    {0x64, 0x02, 0x20, 0x3B, 0x00, 0xFF, 0xFFFF, CLKID_65},     // 25: Mode 72		  1C:
    {0x24, 0x02, 0x20, 0x3B, 0x40, 0xFF, 0xFFFF, CLKID_81_62},  // 25: Mode 72		  1D:
    {0x4C, 0x00, 0x20, 0x39, 0x28, 0xFF, 0x4000, CLKID_12_588}, // 27: Mode 20		  1E:
    {0x4C, 0x00, 0x20, 0x39, 0x28, 0xFF, 0x8000, CLKID_12_588}, // 27: Mode 20		  1F:
    {0x4C, 0x00, 0x20, 0x39, 0x28, 0xFF, 0x5000, CLKID_12_588}, // 27: Mode 20		  20:
    {0x4C, 0x00, 0x20, 0x39, 0x32, 0xFF, 0x8000, CLKID_20},     // 27: Mode 20		  21:
    {0x4C, 0x00, 0x20, 0x39, 0x3C, 0xFF, 0xB000, CLKID_27_93},  // 25: Mode 72		  22:
    {0x4C, 0x00, 0x20, 0x39, 0x40, 0xFF, 0xD000, CLKID_32_5},   // 25: Mode 72		  23:
    {0x4C, 0x00, 0x20, 0x39, 0x78, 0xFF, 0xFFFF, CLKID_55_86},  // 0C: Mode 5E/105	  24:
    {0x0C, 0x00, 0x20, 0x39, 0x90, 0xFF, 0xFFFF, CLKID_81_62},  // 25: Mode 72		  25:
    {0x0C, 0x00, 0x0F, 0x79, 0xC8, 0xFF, 0xFFFF, CLKID_158},    // 25: Mode 72		  26:
    {0x44, 0x80, 0x20, 0x3A, 0x50, 0xFF, 0xFFFF, CLKID_12_588}, // 27: Mode 20		  27:
    {0x44, 0x80, 0x20, 0x3A, 0x50, 0xFF, 0xA000, CLKID_12_588}, // 27: Mode 20		  28:
    {0x44, 0x80, 0x20, 0x3A, 0x64, 0xFF, 0xF000, CLKID_20},     // 27: Mode 20		  29:
    {0x44, 0x80, 0x20, 0x3A, 0x78, 0xFF, 0xFFFF, CLKID_27_93},  // 25: Mode 72		  2A:
    {0x44, 0x80, 0x20, 0x3A, 0x80, 0xFF, 0xFFFF, CLKID_32_5},   // 25: Mode 72		  2B:
    {0x44, 0x80, 0x20, 0x3A, 0xA0, 0xFF, 0xFFFF, CLKID_25_175}, // 26: Mode 5B		  2C:
    {0x44, 0x80, 0x20, 0x3A, 0xF0, 0xFF, 0xFFFF, CLKID_55_86},  // 25: Mode 72		  2D:
    {0x14, 0x81, 0x20, 0x3A, 0x20, 0xFF, 0xFFFF, CLKID_81_62},  // 25: Mode 72		  2E:
    {0x14, 0x81, 0x15, 0x3A, 0x40, 0xFF, 0xFFFF, CLKID_108_5},  // 10: Mode 6B/107	  2F:
    {0x14, 0x81, 0x0F, 0x7A, 0x90, 0xFF, 0xFFFF, CLKID_158},    // 25: Mode 72		  30:
    {0x24, 0x02, 0x15, 0x3B, 0x80, 0xFF, 0xFFFF, CLKID_108_5},  // 10: Mode 6B/107	  31:
    {0x24, 0x03, 0x0F, 0x7B, 0x20, 0xFF, 0xFFFF, CLKID_158},    // 25: Mode 72		  32:
																					  
	// JJV - New Modes (I think this starts at 0x33 ??)								  
    {0x0C, 0x40, 0x0F, 0x79, 0xE1, 0xFF, 0xFFFF, CLKID_219_566}, // 33: 1800X1440X8	  
    {0x0C, 0x41, 0x0F, 0x7A, 0xC2, 0xFF, 0xFFFF, CLKID_219_566}, // 34: 1800X1440X16	  
    {0x0C, 0x40, 0x9F, 0x79, 0xF0, 0xFF, 0xFFFF, CLKID_172_798}, // 35: 1920X1080X8	  
    {0x0C, 0x41, 0x9F, 0x7A, 0xE0, 0xFF, 0xFFFF, CLKID_172_798}, // 36: 1920X1080X16	  
    {0x0C, 0x43, 0x9F, 0x7B, 0xC0, 0xFF, 0xFFFF, CLKID_172_798}, // 37: 1920X1080X32	  
    {0x0C, 0x40, 0x9F, 0x79, 0xF0, 0xFF, 0xFFFF, CLKID_193_156}, // 38: 1920X1200X8	  
    {0x0C, 0x41, 0x9F, 0x7A, 0xE0, 0xFF, 0xFFFF, CLKID_193_156}, // 39: 1920X1200X16	  
    {0x0C, 0x43, 0x9F, 0x7B, 0xC0, 0xFF, 0xFFFF, CLKID_193_156}, // 3A: 1920X1200X32	  
    {0x0C, 0x43, 0x9F, 0x7B, 0xC0, 0xFF, 0xFFFF, CLKID_219_566}, // 3B: 1800x1440x32
    {0x0C, 0x40, 0x9F, 0x79, 0xF0, 0xFF, 0xFFFF, CLKID_266_95},  // 3C: 2048x1536x8
    {0x0C, 0x41, 0x9F, 0x7A, 0xE0, 0xFF, 0xFFFF, CLKID_266_95},  // 3D: 2048x1536x16
    {0x0C, 0x43, 0x9F, 0x7B, 0xC0, 0xFF, 0xFFFF, CLKID_266_95}   // 3E: 2048x1536x32
	// JJV - New Modes																  
																					  
};                                             										  

//  Table of Std CRTC settings for all modes.
//
//  Array of override values for the following registers:
//  cols, rows, height, misc, SR1, CR00, CR01, CR02, CR03, CR04, CR05, CR06
//  CR07, CR09, CR10, CR11, CR12, CR15, CR16.
//
//  See MODES.H for bit definitions.
//
CRTC_OVERRIDE crt_override[] =       // Mode overide table for CRTC
{
    // 0. Mode 20h, 78h / VESA Mode 10Eh, 10Fh
    //    320x200 16-bit/32-bit color graphics
    { 0x28, 0x18, 0x08, 0x63, 0x01, 0x2D, 0x27, 0x27, 0x91, 0x2A, 0x9F,
      0xBF, 0x1F, 0xC0, 0x9C, 0x0E, 0x8F, 0x8F, 0xC0 },
      
    // 1. Mode 34h,35h,36h / VESA Mode 134h,135h,136h
    //       320x240 16-bit Color Graphics (8x8 font, 40x30 "Text")
    { 0x28, 0x1D, 0x08, 0xE3, 0x01, 0x2D, 0x27, 0x27, 0x91, 0x2A, 0x9F,
      0x0B, 0x3E, 0xC0, 0xEA, 0x0C, 0xDF, 0xDF, 0x0C },    
                                                      
    // 2. Mode 31h,32h,33h / VESA Mode 131h,132h,133h
    //    320x400 16-bit Color Graphics (8x16 font, 40x25 "Text")
    { 0x28, 0x18, 0x10, 0x63, 0x01, 0x2D, 0x27, 0x27, 0x91, 0x2A, 0x9F,
      0xBF, 0x1F, 0x40, 0x9C, 0x0E, 0x8F, 0x8F, 0xC0 },
      
    // 3. Mode 37h,38h,39h / VESA Mode 137h,138h,139h
    //       400x300 16-bit Color Graphics (8x8 font, 50x37 "Text")
    { 0x32, 0x24, 0x08, 0x2B, 0x01, 0x3D, 0x31, 0x31, 0x81, 0x35, 0x1D,
      0x72, 0xF0, 0xE0, 0x59, 0x0D, 0x57, 0x57, 0x73 },
                                                    
    // 4. Mode 72 / VESA Mode 117h / Internal Mode 25h
    //       480x360 16-bit Color Graphics (8x16 font, 128x48 "Text")
    { 0x3C, 0x2C, 0x08, 0xEB, 0x01, 0x49, 0x3B, 0x3B, 0x8D, 0x40, 0x08,
      0xE8, 0xF0, 0xE0, 0xD1, 0x04, 0xCF, 0xCF, 0xE9 },
                                                    
    // 5. Mode 3Ah,3Bh,3Ch / VESA Mode 13Ah,13Bh,13Ch
    //       512x384 16-bit Color Graphics (8x8 font, 64x48 "Text")
    { 0x40, 0x2F, 0x08, 0xEB, 0x01, 0x4F, 0x3F, 0x3F, 0x93, 0x43, 0x0B,
      0x24, 0xF5, 0xE0, 0x03, 0x09, 0xFF, 0xFF, 0x25 },
                                                    
    // 6. Mode 5Bh / VESA Mode 100h / Internal Mode 26h
    //       640x400 8-bit Color Graphics (8x16 font, 80x25 "Text")
    { 0x50, 0x18, 0x10, 0x63, 0x01, 0x5F, 0x4F, 0x4F, 0x83, 0x53, 0x9F,
      0xBF, 0x1F, 0x40, 0x9C, 0x0E, 0x8F, 0x8F, 0xC0 },
                                                    
    // 7. Internal Mode 9
    // Mode 58 / VESA Mode 6A / VESA Mode 102 800x600x4
    { 0x64, 0x24, 0x10, 0x2B, 0x01, 0x7F, 0x63, 0x63, 0x83, 0x6B, 0x1B,
      0x72, 0xF0, 0x60, 0x59, 0x0D, 0x57, 0x57, 0x73 },
                                                    
    // 8. Mode 6F / VESA Mode 114h / Internal Mode 24h
    //       800x600 16-bit Color Graphics (8x16 font, 100x37 "Text")
    { 0x64, 0x24, 0x10, 0x2B, 0x01, 0x7F, 0x63, 0x63, 0x83, 0x6A, 0x1A,
      0x72, 0xF0, 0x60, 0x59, 0x0D, 0x57, 0x57, 0x73 },
                                                    
    // 9. Mode 72 / VESA Mode 117h / Internal Mode 25h
    //       960x720 16-bit Color Graphics (8x16 font, 128x48 "Text")
    { 0x78, 0x2C, 0x10, 0xEB, 0x01, 0x97, 0x77, 0x77, 0x9B, 0x7F, 0x0B,
      0xE8, 0xF0, 0x60, 0xD1, 0x04, 0xCF, 0xCF, 0xE9 },
                                                    
    // A. Mode B
    // Mode 5D / VESA Mode 104 1024x768x4
    { 0x80, 0x2F, 0x10, 0xEB, 0x01, 0xA3, 0x7F, 0x7F, 0x87, 0x85, 0x96,
      0x24, 0xF5, 0x60, 0x03, 0x09, 0xFF, 0xFF, 0x25 },
                                                    
    // B. Mode 72 / VESA Mode 117h / Internal Mode 25h
    //       1024x768 16-bit Color Graphics (8x16 font, 128x48 "Text")
    { 0x80, 0x2F, 0x10, 0xEB, 0x01, 0xA3, 0x7F, 0x7F, 0x87, 0x84, 0x95,
      0x24, 0xF5, 0x60, 0x03, 0x09, 0xFF, 0xFF, 0x25 },
                                                    
    // C. Mode 41h/42h/43h / VESA Mode 141,142,143
    // 1152x864x16
    { 0x90, 0x35, 0x10, 0x2B, 0x01, 0xB9, 0x8F, 0x8F, 0x9D, 0x9A, 0x89,
      0x7D, 0xFF, 0x60, 0x61, 0x04, 0x5F, 0x5F, 0x7E },
                                                    
    // D. Internal Mode F
    // Mode 5A / VESA Mode 106 1280x1024x4
    { 0xA0, 0x3F, 0x10, 0x2B, 0x01, 0xCF, 0x9F, 0x9F, 0x93, 0xAA, 0x1A,
      0x28, 0x5A, 0x60, 0x01, 0x04, 0xFF, 0xFF, 0x29 },
                                                    
    // E. Internal Mode 10
    // Mode 6B / VESA Mode 107 1280x1024x8
    { 0xA0, 0x3F, 0x10, 0x2B, 0x01, 0xCF, 0x9F, 0x9F, 0x93, 0xA9, 0x19,
      0x28, 0x5A, 0x60, 0x01, 0x04, 0xFF, 0xFF, 0x29 },
                                                    
    // F. Mode 45h/46h / VESA Mode 145,146
    // 1600x1200x16
    { 0xC8, 0x4A, 0x10, 0x2B, 0x01, 0x03, 0xC7, 0xC7, 0x87, 0xD1, 0x09,
      0xE0, 0x10, 0x40, 0xB1, 0x04, 0xAF, 0xAF, 0xE1 },
         
    // JJV - Start                                                
    // 10. Mode ?
    // 1880x1440x8
    { 0xE1, 0x59, 0x10, 0x2B, 0x01, 0x2E, 0xE0, 0xE0, 0x92, 0xF2, 0x8B,
      0xD0, 0x1F, 0x40, 0xA1, 0x24, 0x9F, 0x9F, 0xD1 },
                                                    
    // 11. Mode ?
    // 1880x1440x16
    { 0xE1, 0x59, 0x10, 0x2B, 0x01, 0x2E, 0xE0, 0xE0, 0x92, 0xF2, 0x8B,
      0xD0, 0x1F, 0x40, 0xA1, 0x24, 0x9F, 0x9F, 0xD1 },
                                                    
    // 12. Mode ?
    // 1920x1080x8
    { 0xF0, 0x42, 0x10, 0x2B, 0x01, 0x3D, 0xEF, 0xEF, 0x81, 0x00, 0x1A,
      0x5C, 0x10, 0x40, 0x39, 0x2C, 0x37, 0x37, 0x5D },
                                                    
    // 13. Mode ?
    // 1920x1080x16
    { 0xF0, 0x42, 0x10, 0x2B, 0x01, 0x3D, 0xEF, 0xEF, 0x81, 0x00, 0x1A,
      0x5C, 0x10, 0x40, 0x39, 0x2C, 0x37, 0x37, 0x5D },
                                                    
    // 14. Mode ?
    // 1920x1080x32
    { 0xF0, 0x42, 0x10, 0x2B, 0x01, 0x3D, 0xEF, 0xEF, 0x81, 0x00, 0x1A,
      0x5C, 0x10, 0x40, 0x39, 0x2C, 0x37, 0x37, 0x5D },
                                                    
    // 15. Mode ?
    // 1920x1200x8
    { 0xF0, 0x4A, 0x10, 0x2B, 0x01, 0x3F, 0xEF, 0xEF, 0x83, 0x01, 0x1B,
      0xD8, 0x10, 0x40, 0xB0, 0x23, 0xAF, 0xAF, 0xD9 },
                                                    
    // 16. Mode ?
    // 1920x1200x16
    { 0xF0, 0x4A, 0x10, 0x2B, 0x01, 0x3F, 0xEF, 0xEF, 0x83, 0x01, 0x1B,
      0xD8, 0x10, 0x40, 0xB0, 0x23, 0xAF, 0xAF, 0xD9 },
      
    // 17. Mode ?
    // 1920x1200x32
    { 0xF0, 0x4A, 0x10, 0x2B, 0x01, 0x3F, 0xEF, 0xEF, 0x83, 0x01, 0x1B,
      0xD8, 0x10, 0x40, 0xB0, 0x23, 0xAF, 0xAF, 0xD9 },
      
    // 18. Mode ?
    // 1800x1440x32
    { 0xE1, 0x59, 0x10, 0x2B, 0x01, 0x3F, 0xEF, 0xEF, 0x83, 0x01, 0x1B,
      0xD8, 0x10, 0x40, 0xB0, 0x23, 0xAF, 0xAF, 0xD9 },
      
    // 19. Mode ?
    // 2048x1536x8
    { 0xFF, 0x5F, 0x10, 0x2B, 0x01, 0x3F, 0xEF, 0xEF, 0x83, 0x01, 0x1B,
      0xD8, 0x10, 0x40, 0xB0, 0x23, 0xAF, 0xAF, 0xD9 },
      
    // 1A. Mode ?
    // 2048x1536x16
    { 0xFF, 0x5F, 0x10, 0x2B, 0x01, 0x3F, 0xEF, 0xEF, 0x83, 0x01, 0x1B,
      0xD8, 0x10, 0x40, 0xB0, 0x23, 0xAF, 0xAF, 0xD9 },
      
    // 1B. Mode ?
    // 2048x1536x32
    { 0xFF, 0x5F, 0x10, 0x2B, 0x01, 0x3F, 0xEF, 0xEF, 0x83, 0x01, 0x1B,
      0xD8, 0x10, 0x40, 0xB0, 0x23, 0xAF, 0xAF, 0xD9 }
      
    // JJV - End
                                                    
};


//
// Fifo/Watermark settings (100MHz/100MHz operation)
//
//    Freq;                   // Maximum frequency for these water marks
//    LowWaterMark64;         // Low water mark for 64 bit bus
//    BurstSize64;            // Burst size for 64 bit bus
//    LowWaterMark128;        // Low water mark for 128 bit bus
//    BurstSize128;           // Burst size for 128 bit bus
MODESET_FIFO DACFifoTable[] =
{
    { 440, 0x20, 0x03, 0x20, 0x04 },
    { 460, 0x21, 0x03, 0x21, 0x04 },
    { 480, 0x23, 0x03, 0x23, 0x04 },
    { 500, 0x26, 0x03, 0x26, 0x04 },
    { 520, 0x27, 0x03, 0x27, 0x04 },
    { 540, 0x27, 0x03, 0x27, 0x04 },
    { 560, 0x29, 0x03, 0x29, 0x04 },
    { 580, 0x2b, 0x03, 0x2b, 0x04 },
    { 600, 0x2e, 0x03, 0x2e, 0x04 },
    { 620, 0x31, 0x03, 0x31, 0x04 },
    { 640, 0x32, 0x02, 0x32, 0x04 },
    { 660, 0x32, 0x02, 0x32, 0x04 },
    { 680, 0x33, 0x02, 0x33, 0x04 },
    { 700, 0x34, 0x02, 0x34, 0x04 },
    { 720, 0x36, 0x02, 0x36, 0x04 },
    { 740, 0x3a, 0x01, 0x3a, 0x04 },
    {0xFFFF, 0x3f, 0x01, 0x3f, 0x04 }       // max marker
};                                  

//
// Mode clock frequencies
//
U016 tblClockFreq[] =
{
    5035,       // 00: 50.350
    5664,       // 01: 56.644
    3325,       // 02: 33.250
    5200,       // 03: 52.000
    8000,       // 04: 80.000
    6300,       // 05: 63.000
    0000,       // 06: Ext
    7500,       // 07: 75.000 (1024x768@70)
    2518,       // 08: 25.175 (VGA)
    2832,       // 09: 28.322 (VGA)
    3150,       // 0A: 31.500 (640x480@72)
    3600,       // 0B: 36.000 (800x600@56)
    4000,       // 0C: 40.000 (800x600@60)
    4490,       // 0D: 44.900 (1024x768@87i)
    5000,       // 0E: 50.000 (800x600@72)
    6500,       // 0F: 65.000 (1024x768@60)
    10800,      // 10: 108.000/2 (1280x1024@60) use clock doubler
    13500,      // 11: 135.000/2 (1280x1024@75) use clock doubler
    4950,       // 12: 49.500
    5625,       // 13: 56.250
    7875,       // 14: 78.750
    9450,       // 15: 94.500
    10850,      // 16: 108.500/2 use clock doubler
    3550,       // 17: 35.500
    15800,      // 18: 158.000/2 use clock doubler
    5586,       // 19: 55.860
    2000,       // 1A: 20.000
    2793,       // 1B: 27.930
    3250,       // 1C: 32.500
    1259,       // 1D: 12.588 (VGA/2)
    8162,       // 1E: 81.624
    21957,		// 1F: 219.566
    17280,		// 20: 172.798
    19316,		// 21: 193.156
    22950,      // 22: 229.50 (for max dot clock)
    26695       // 23: 266.95
};

//
//  TV  register adjustments
//

//
//  NV4 TV CRTC adjustments for Chrontel
//
CH_ADJ CRTC_CH_NTSC[] =
{
//  SR01   CR00  CR04  CR06  CR07  CR08  CR10  CR12  CR25  CR28
    {0x09, 0x2b, 0x2a, 0x0c, 0x3e, 0x60, 0xc0, 0x8f, 0x00, 0x98},     // Mode 0 - 320x200
    {0x09, 0x2b, 0x2b, 0x3c, 0x3e, 0x60, 0xe4, 0xdf, 0x00, 0x88},     // Mode 1 - 320x240
    {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},     // Mode 2 - 320x400
    {0x09, 0x3d, 0x3d, 0x72, 0xf0, 0x00, 0x59, 0x57, 0x00, 0x80},     // Mode 3 - 400x300
    {0x01, 0x49, 0x40, 0x20, 0xB3, 0x00, 0x90, 0x67, 0x00, 0x80},     // Mode 4 - 480x360
//    {0x01, 0x4f, 0x43, 0x24, 0xf5, 0xff, 0xff, 0x00, 0x80},     // Mode 5 - 512x384
    {0x01, 0x58, 0x57, 0x3c, 0x3e, 0x00, 0xd0, 0x7f, 0x00, 0x80},     // Mode 5 - use 640x400 and adjust 9 and 12
    {0x01, 0x58, 0x57, 0x3c, 0x3e, 0x00, 0xd0, 0x8f, 0x00, 0x80},     // Mode 6 - 640x400
    {0x01, 0x58, 0x57, 0x3c, 0x3e, 0x00, 0xe4, 0xdf, 0x00, 0x80},     // Mode 7 - 640x480
    {0x01, 0x75, 0x6f, 0xb8, 0xf0, 0x00, 0x59, 0x57, 0x00, 0x80},     // Mode 8 - 800x600
};
//
CH_ADJ  CRTC_CH_PAL[] =
{
//  SR01   CR00  CR04  CR06  CR07  CR08  CR10  CR12  CR25  CR28
    {0x09, 0x2c, 0x28, 0x0c, 0x3e, 0x60, 0xc0, 0x8f, 0x00, 0x98},     // Mode 0 - 320x200
    {0x09, 0x2c, 0x28, 0x3c, 0x3e, 0x60, 0xe4, 0xdf, 0x00, 0x88},     // Mode 1 - 320x240
    {0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff},     // Mode 2 - 320x400
    {0x09, 0x3d, 0x3d, 0xb0, 0xf0, 0x00, 0x57, 0x57, 0x00, 0x80},     // Mode 3 - 400x300
    {0x01, 0x49, 0x40, 0xf0, 0xB2, 0x00, 0x90, 0x67, 0x00, 0x80},     // Mode 4 - 480x360
//    {0x01, 0x4f, 0x43, 0x0b, 0xf5, 0xff, 0xff, 0x00, 0x80},     // Mode 5 - 512x384
    {0x01, 0x58, 0x57, 0x0e, 0x3e, 0x60, 0xc0, 0x7f, 0x00, 0x80},     // Mode 5 - 640x400, adjust 9 and 12
    {0x01, 0x58, 0x55, 0x0C, 0x3e, 0x00, 0xc0, 0x8f, 0x00, 0x80},     // Mode 6 - 640x400
    {0x01, 0x58, 0x55, 0x3c, 0x3e, 0x00, 0xe4, 0xdf, 0x00, 0x80},     // Mode 7 - 640x480
    {0x01, 0x75, 0x6a, 0xb8, 0xf0, 0x00, 0x59, 0x57, 0x00, 0x80},     // Mode 8 - 800x600
};
    
//
//  CRTC adjustments for Brooktree 
//
BT_ADJ    CRTC_BT[] =
{   
//   SR01  CR00  CR04  CR06  CR07  CR08  CR10  CR12
    {0x09, 0x2b, 0x26, 0x0c, 0x3e, 0x60, 0xc0, 0x8f},       // Mode 0 - 320x200
    {0x09, 0x2b, 0x26, 0x3c, 0x3e, 0x60, 0xe4, 0xdf},       // Mode 1 - 320x240
    {0x09, 0x2c, 0x29, 0x3c, 0x3e, 0x00, 0xe4, 0xdf},       // Mode 2 - 320x400
    {0x09, 0x3d, 0x3d, 0xb0, 0xf0, 0x00, 0x59, 0x57},       // Mode 3 - 400x300
    {0x01, 0x49, 0x40, 0xe4, 0xB2, 0x00, 0x90, 0x67},       // Mode 4 - 480x360
//    {0x01, 0x4f, 0x43, 0x24, 0xf5, 0x03, 0x7f},       // Mode 5 - 512x384 -- USE WHEN WE HAVE CORRECT 512X384 ENCODER VALUES
    {0x01, 0x57, 0x50, 0x0c, 0x3e, 0x00, 0xc0, 0x7f},       // Mode 5 - 640x400   -- USE 640X400 BECAUSE THE ENCODER IS PROGRAMMED
                                                      // FOR THIS MODE. THEN SET CR09 AND CR12 (CR12 IS ADJUSTED HERE)
    {0x01, 0x57, 0x50, 0x0c, 0x3e, 0x00, 0xc0, 0x8f},       // Mode 6 - 640x400
    {0x01, 0x5c, 0x53, 0x0b, 0x3e, 0x00, 0xbf, 0xdf},       // Mode 7 - 640x480
    {0x01, 0x72, 0x72, 0xb0, 0xf0, 0x00, 0x5b, 0x57},       // Mode 8 - 800x600
};    
BT_ADJ    CRTC_BT_PAL[] =
{   
//   SR01  CR00  CR04  CR06  CR07  CR08  CR10  CR12
    {0x09, 0x2d, 0x29, 0x0c, 0x3e, 0x60, 0xc0, 0x8f},       // Mode 0 - 320x200
    {0x09, 0x2d, 0x29, 0x3c, 0x3e, 0x60, 0xe4, 0xdf},       // Mode 1 - 320x240
    {0x09, 0x2c, 0x29, 0x3c, 0x3e, 0x00, 0xe4, 0xdf},       // Mode 2 - 320x400
    {0x09, 0x35, 0x35, 0xb4, 0xf0, 0x00, 0x59, 0x57},       // Mode 3 - 400x300
    {0x01, 0x49, 0x40, 0xe4, 0xB2, 0x00, 0x90, 0x67},       // Mode 4 - 480x360
//    {0x01, 0x4f, 0x43, 0x24, 0xf5, 0x03, 0x7f},       // Mode 5 - 512x384 -- USE WHEN WE HAVE CORRECT 512X384 ENCODER VALUES  
    {0x01, 0x57, 0x50, 0x0c, 0x3e, 0x00, 0xc0, 0x7f},       // Mode 5 - 640x400   -- USE 640X400 BECAUSE THE ENCODER IS PROGRAMMED
                                                      // FOR THIS MODE. THEN SET CR09 AND CR12 (CR12 IS ADJUSTED HERE)
    {0x01, 0x57, 0x50, 0x0c, 0x3e, 0x00, 0xc0, 0x8f},       // Mode 6 - 640x400
    {0x01, 0x57, 0x50, 0x3c, 0x3e, 0x00, 0xea, 0xdf},       // Mode 7 - 640x480
    {0x01, 0x76, 0x70, 0xb7, 0xf0, 0x00, 0x59, 0x57},       // Mode 8 - 800x600
};    

//
//  I2C tables
//

BT_string  BT_NULL_STRING =
{   0xff    };
I2C_string  NULL_STRING =
{   0xff    };

//
// Brooktree strings
//

//  Init string
U008    BT_Init[] = { 0x8A, 0xC4, 0x01, 0x98, 0x18, 0xC0, 0xC0, 0x18, 0xff };

//  First byte is device ID, followed by 3 bytes of centering data, followed by 00 01, followed by 33 bytes of 
//  resolution data, terminated by ff (not sent).
//  line/pixel doubled modes use the double resolution (e.g. 320x200 = 640x400)
//  NTSC
BT_string BT_NTSC320X200 =    
{   0X8A, 0x6e, 0x1f, 0x02,
    0x00, 0x01,
    0X30, 0X90, 0X88, 0X9A, 0X66, 0X87, 0X23, 0XD2, 0X27, 0X00, 0X98, 0XE7, 0X03, 0X0D, 0X44, 0XA0,
    0X36, 0X00, 0X50, 0XFC, 0XDD, 0X0C, 0X0A, 0XE5, 0X75, 0X79, 0X44, 0X85, 0XDF, 0XF4, 0XA6, 0X1F, 0X00, 
    0XFF
};
BT_string BT_NTSC320X240 =
{   0X8A, 0x6e, 0x8f, 0xc2,
    0x00, 0x01,
    0X20, 0X90, 0X86, 0X98, 0X64, 0X7F, 0X24, 0XD0, 0X27, 0X00, 0XF8, 0X5A, 0X02, 0X76, 0X53, 0XF0, 
    0X36, 0X66, 0X56, 0X58, 0XC1, 0X0C, 0X0A, 0XE5, 0X75, 0X79, 0X44, 0X85, 0XFC, 0X08, 0XEE, 0X1F, 0X00, 
    0XFF
};
BT_string BT_NTSC320X400 =    
{   0X8A, 0x6e, 0x1f, 0x02,
    0x00, 0x01,
    0X30, 0X90, 0X88, 0X9A, 0X66, 0X87, 0X23, 0XD2, 0X27, 0X00, 0X98, 0XE7, 0X03, 0X0D, 0X44, 0XA0,
    0X36, 0X00, 0X50, 0XFC, 0XDD, 0X0C, 0X0A, 0XE5, 0X75, 0X79, 0X44, 0X85, 0XDF, 0XF4, 0XA6, 0X1F, 0X00, 
    0XFF
};
//  400x300 = 800x600
BT_string BT_NTSC400X300 =
{   0X8A, 0x6e, 0x8f, 0xc2,
    0x00, 0x01,
    0xA0, 0x20, 0xB6, 0xCE, 0xB4, 0x55, 0x20, 0xD8, 0x39, 0x00, 0x70, 0x44, 0x03, 0xDF, 0x56, 0x58,
    0x3A, 0xCD, 0x9C, 0x14, 0x3B, 0x11, 0x0A, 0xE5, 0x74, 0x77, 0x43, 0x85, 0xBA, 0xE8, 0xA2, 0x17, 0x00,
    0XFF
};
//  these are 640x400 values--use until we get real 480x360 values
BT_string BT_NTSC480X360 =
{   0X8A, 0x6e, 0x86, 0x02,
    0x00, 0x01,
    0X30, 0X90, 0X88, 0X9A, 0X66, 0X87, 0X23, 0XD2, 0X27, 0X00, 0X98, 0XE7, 0X03, 0X0D, 0X44, 0XA0,
    0X36, 0X00, 0X50, 0XFC, 0XDD, 0X0C, 0X0A, 0XE5, 0X75, 0X79, 0X44, 0X85, 0XDF, 0XF4, 0XA6, 0X1F, 0X00, 
    0XFF
};
//  these are 640x400 values--use until we get real 512x384 values
BT_string BT_NTSC512X384 =
{   0X8A, 0x6e, 0x86, 0x02,
    0x00, 0x01,
    0X30, 0X90, 0X88, 0X9A, 0X66, 0X87, 0X23, 0XD2, 0X27, 0X00, 0X98, 0XE7, 0X03, 0X0D, 0X44, 0XA0,
    0X36, 0X00, 0X50, 0XFC, 0XDD, 0X0C, 0X0A, 0XE5, 0X75, 0X79, 0X44, 0X85, 0XDF, 0XF4, 0XA6, 0X1F, 0X00, 
    0XFF
};
BT_string BT_NTSC640X400 =
{   0X8A, 0x6e, 0x50, 0x02,
    0x00, 0x01,
    0X30, 0X90, 0X88, 0X9A, 0X66, 0X87, 0X23, 0XD2, 0X27, 0X00, 0X98, 0XE7, 0X03, 0X0D, 0X44, 0XA0,
    0X36, 0X00, 0X50, 0XFC, 0XDD, 0X0C, 0X0A, 0XE5, 0X75, 0X79, 0X44, 0X85, 0XDF, 0XF4, 0XA6, 0X1F, 0X00, 
    0XFF
};
#if 1
/* new initialization values based on code from brooktree (jsun) */
BT_string BT_NTSC640X480 =
{   0X8A, 0x6e, 0xd4, 0xc2,
    0x00, 0x01,
/*  76    78    7A    7C    7E    80    82    84    86    88    8A    8C    8E    90    92    94 */
    0X00, 0X80, 0X84, 0X96, 0X60, 0X7D, 0X22, 0XD4, 0X27, 0X00, 0X10, 0X7E, 0X03, 0X58, 0X4B, 0XE0, 
/*  96    98    9A    9C    9E    A0    A2    A4    A6    A8    AA    AC    AE    B0    B2    B4    B6 */
    0X36, 0X92, 0X54, 0X0E, 0X88, 0X0C, 0X0A, 0XE5, 0X76, 0X79, 0X44, 0X85, 0X00, 0X00, 0X80, 0X20, 0X00, 
    0XFF
};
#else
BT_string BT_NTSC640X480 =
{   0X8A, 0x6e, 0xd4, 0xc2,
    0x00, 0x01,
    0X20, 0X90, 0X86, 0X98, 0X64, 0X7F, 0X24, 0XD0, 0X27, 0X00, 0XF8, 0X5A, 0X02, 0X76, 0X53, 0XF0, 
    0X36, 0X66, 0X56, 0X58, 0XC1, 0X0C, 0X0A, 0XE5, 0X75, 0X79, 0X44, 0X85, 0XFC, 0X08, 0XEE, 0X1F, 0X00, 
    0XFF
};
#endif
#if 1
/* new initialization values based on code from brooktree (jsun) */
BT_string BT_NTSC800X600 =
{   0X8A, 0x6e, 0xe2, 0xc2,
    0x00, 0x01,
/*  76    78    7A    7C    7E    80    82    84    86    88    8A    8C    8E    90    92    94 */
    0xA0, 0x20, 0xB6, 0xCE, 0xB4, 0x55, 0x20, 0xD8, 0x39, 0x00, 0x70, 0x42, 0x03, 0xDF, 0x56, 0x58,
/*  96    98    9A    9C    9E    A0    A2    A4    A6    A8    AA    AC    AE    B0    B2    B4    B6 */
    0x3A, 0xCD, 0x9C, 0x14, 0x3B, 0x11, 0x0A, 0xE5, 0x74, 0x77, 0x43, 0x85, 0xBA, 0xE8, 0xA2, 0x17, 0x00,
    0XFF
};
#else
BT_string BT_NTSC800X600 =
{   0X8A, 0x6e, 0xe2, 0xc2,
    0x00, 0x01,
    0xA0, 0x20, 0xB6, 0xCE, 0xB4, 0x55, 0x20, 0xD8, 0x39, 0x00, 0x70, 0x44, 0x03, 0xDF, 0x56, 0x58,
    0x3A, 0xCD, 0x9C, 0x14, 0x3B, 0x11, 0x0A, 0xE5, 0x74, 0x77, 0x43, 0x85, 0xBA, 0xE8, 0xA2, 0x17, 0x00,
    0XFF
};
#endif

//  PAL 
BT_string BT_PAL320X200 =    
{   0X8A, 0x6e, 0x24, 0x42, 
    0x00, 0x01,
    0Xe0, 0X90, 0X94, 0Xb0, 0X78, 0XF9, 0X2a, 0Xfa, 0X27, 0X00, 0Xb0, 0Xd9, 0X0c, 0X0d, 0X44, 0Xa0, 
    0X36, 0Xe1, 0X4a, 0X00, 0X00, 0X0e, 0X24, 0Xf0, 0X58, 0X81, 0X48, 0X8c, 0Xd3, 0X2d, 0X08, 0X24, 0X00, 
    0XFF
};
BT_string BT_PAL320X240 =
{   0X8A, 0x6e, 0x54, 0x02,
    0x00, 0x01,
    0x90, 0x90, 0x8e, 0xaa, 0x6e, 0xcd, 0x2a, 0xfa, 0x27, 0x00, 0xc8, 0x11, 0x0b, 0x71, 0x52, 0xf0,
    0x36, 0x00, 0x50, 0xc7, 0x71, 0x0d, 0x24, 0xf0, 0x58, 0x81, 0x49, 0x8c, 0xea, 0x57, 0x85, 0x25, 0x00,
    0XFF
};
BT_string BT_PAL320X400 =    
{   0X8A, 0x6e, 0x24, 0x42, 
    0x00, 0x01,
    0Xe0, 0X90, 0X94, 0Xb0, 0X78, 0XF9, 0X2a, 0Xfa, 0X27, 0X00, 0Xb0, 0Xd9, 0X0c, 0X0d, 0X44, 0Xa0, 
    0X36, 0Xe1, 0X4a, 0X00, 0X00, 0X0e, 0X24, 0Xf0, 0X58, 0X81, 0X48, 0X8c, 0Xd3, 0X2d, 0X08, 0X24, 0X00, 
    0XFF
};
//  400x300 = 800x600
BT_string BT_PAL400X300 =
{   0X8A, 0x6e, 0x00, 0x02,
    0x00, 0x01,
    0x00, 0x20, 0xAA, 0xCA, 0x9A, 0x0D, 0x29, 0xFC, 0x39, 0x00, 0xC0, 0x8C, 0x03, 0xEE, 0x5F, 0x58, 
    0x3A, 0x66, 0x96, 0x00, 0x00, 0x10, 0x24, 0xF0, 0x57, 0x80, 0x48, 0x8C, 0x18, 0x28, 0x87, 0x1F, 0x00,
    0XFF
};
//  using 640x400 for now
BT_string BT_PAL480X360 =
{   0X8A, 0x6e, 0x7c, 0x42, 
    0x00, 0x01,
    0Xe0, 0X90, 0X94, 0Xb0, 0X78, 0XF9, 0X2a, 0Xfa, 0X27, 0X00, 0Xb0, 0Xd9, 0X0c, 0X0d, 0X44, 0Xa0, 
    0X36, 0Xe1, 0X4a, 0X00, 0X00, 0X0e, 0X24, 0Xf0, 0X58, 0X81, 0X48, 0X8c, 0Xd3, 0X2d, 0X08, 0X24, 0X00, 
    0XFF
};
//  using 640x400 for now
BT_string BT_PAL512X384 =
{   0X8A, 0x6e, 0x7c, 0x42, 
    0x00, 0x01,
    0Xe0, 0X90, 0X94, 0Xb0, 0X78, 0XF9, 0X2a, 0Xfa, 0X27, 0X00, 0Xb0, 0Xd9, 0X0c, 0X0d, 0X44, 0Xa0, 
    0X36, 0Xe1, 0X4a, 0X00, 0X00, 0X0e, 0X24, 0Xf0, 0X58, 0X81, 0X48, 0X8c, 0Xd3, 0X2d, 0X08, 0X24, 0X00, 
    0XFF
};
BT_string BT_PAL640X400 =
{   0X8A, 0x6e, 0x40, 0x42, 
    0x00, 0x01,
    0Xe0, 0X90, 0X94, 0Xb0, 0X78, 0XF9, 0X2a, 0Xfa, 0X27, 0X00, 0Xb0, 0Xd9, 0X0c, 0X0d, 0X44, 0Xa0, 
    0X36, 0Xe1, 0X4a, 0X00, 0X00, 0X0e, 0X24, 0Xf0, 0X58, 0X81, 0X48, 0X8c, 0Xd3, 0X2d, 0X08, 0X24, 0X00, 
    0XFF
};
#if 0   // seem to be invalid -- TV doesn't recognize this as PAL
/* new initialization values based on code from brooktree (jsun) */
BT_string BT_PAL640X480 =
{   0X8A, 0x6e, 0x80, 0x02,
    0x00, 0x01,
/*  76    78    7A    7C    7E    80    82    84    86    88    8A    8C    8E    90    92    94 */
    0x60, 0x80, 0x8A, 0xA6, 0x68, 0xC1, 0x2E, 0xF2, 0x27, 0x00, 0xB0, 0x0A, 0x0B, 0x71, 0x5A, 0xE0,
/*  96    98    9A    9C    9E    A0    A2    A4    A6    A8    AA    AC    AE    B0    B2    B4    B6 */
    0x36, 0x00, 0x50, 0x72, 0x1C, 0x0D, 0x04, 0xF0, 0x58, 0x81, 0x49, 0x8C, 0x0C, 0x8C, 0x79, 0x26, 0x00,
    0XFF
};
#else
BT_string BT_PAL640X480 =
{   0X8A, 0x6e, 0x80, 0x02,
    0x00, 0x01,
    0x90, 0x90, 0x8e, 0xaa, 0x6e, 0xcd, 0x2a, 0xfa, 0x27, 0x00, 0xc8, 0x11, 0x0b, 0x71, 0x52, 0xf0,
    0x36, 0x00, 0x50, 0xc7, 0x71, 0x0d, 0x24, 0xf0, 0x58, 0x81, 0x49, 0x8c, 0xea, 0x57, 0x85, 0x25, 0x00,
    0XFF
};
#endif
#if 0   // seem to be invalid -- TV doesn't recognize this as PAL
/* new initialization values based on code from brooktree (jsun) */
BT_string BT_PAL800X600 =
{   0X8A, 0x6e, 0xfa, 0xc1,
    0x00, 0x01,
/*  76    78    7A    7C    7E    80    82    84    86    88    8A    8C    8E    90    92    94 */
    0x00, 0x20, 0xAA, 0xCA, 0x9A, 0x0D, 0x29, 0xFC, 0x39, 0x00, 0xC0, 0x8C, 0x03, 0xEE, 0x5F, 0x58, 
/*  96    98    9A    9C    9E    A0    A2    A4    A6    A8    AA    AC    AE    B0    B2    B4    B6 */
    0x3A, 0x66, 0x96, 0x00, 0x00, 0x10, 0x04, 0xF0, 0x57, 0x80, 0x48, 0x8C, 0x18, 0x28, 0x87, 0x1F, 0x00,
    0XFF
};
#else
BT_string BT_PAL800X600 =
{   0X8A, 0x6e, 0xfa, 0xc1,
    0x00, 0x01,
    0x00, 0x20, 0xAA, 0xCA, 0x9A, 0x0D, 0x29, 0xFC, 0x39, 0x00, 0xC0, 0x8C, 0x03, 0xEE, 0x5F, 0x58, 
    0x3A, 0x66, 0x96, 0x00, 0x00, 0x10, 0x24, 0xF0, 0x57, 0x80, 0x48, 0x8C, 0x18, 0x28, 0x87, 0x1F, 0x00,
    0XFF
};
#endif


// Brooktree I2C tables for TV modes 0..8
BT_string *BT_NTSC[] = {&BT_NTSC320X200, &BT_NTSC320X240, &BT_NTSC320X400, &BT_NTSC400X300, &BT_NTSC480X360, 
    &BT_NTSC512X384, &BT_NTSC640X400, &BT_NTSC640X480, &BT_NTSC800X600};

BT_string *BT_PAL[]  = {&BT_PAL320X200, &BT_PAL320X240, &BT_PAL320X400, &BT_PAL400X300, &BT_PAL480X360, 
    &BT_PAL512X384, &BT_PAL640X400, &BT_PAL640X480, &BT_PAL800X600};

//
//  Chrontel strings
//

//  The I2C init string
U008    I2C_Init[] = { 0xea, 0x04, 0x05, 0x06, 0x40, 0x0d, 0x07, 0xff };

//  The I2C disable string
U008    I2C_Disable[] = { 0xea, 0x0d, 0x03, 0x0e, 0x09, 0xff };

//
// Chrontel I2C timing tables. All resolutions are multiples of these modes.
// Reg A is horizontal position; Reg B is vertical position
// DEVICE REG 0       REG 7       REG A       REG B       REG13, AUTOINC TO REG 15
I2C_string  NTSC320X200 =
{   0xea, 0x00, 0x49, 0x07, 0x70, 0x0a, 0x30, 0x0b, 0x00, 0x53, 0x00, 0x0b, 0x16, 0xff };  // NTSC 320x200 (640x400)
I2C_string  NTSC320X240 =
{   0xea, 0x00, 0x6a, 0x07, 0x5c, 0x0a, 0x28, 0x0b, 0x04, 0x53, 0x00, 0x3f, 0x7e, 0xff };  // NTSC 320x240 (640x480)
I2C_string NTSC400X300 =
{   0xea, 0x00, 0x8D, 0x07, 0x8c, 0x0a, 0x34, 0x0b, 0xe8, 0x53, 0x02, 0x59, 0x2E, 0xff };  // NTSC 400x300 (800x600)
I2C_string  NTSC480X360 =
{   0xea, 0x00, 0x49, 0x07, 0x70, 0x0a, 0x34, 0x0b, 0x16, 0x53, 0x00, 0x0b, 0x16, 0xff };  // NTSC 480x360 (640x400) 
I2C_string  NTSC512X384 = 
//{   0xea, 0x00, 0x09, 0x07, 0xd4, 0x0a, 0x0a, 0x0b, 0x00, 0x53, 0x00, 0x63, 0x16, 0xff };  // NTSC 512x384
{   0xea, 0x00, 0x49, 0x07, 0x70, 0x0a, 0x48, 0x0b, 0x10, 0x53, 0x00, 0x0b, 0x16, 0xff };  // use NTSC 640x400 
I2C_string  NTSC640X400 =
{   0xea, 0x00, 0x49, 0x07, 0x70, 0x0a, 0x34, 0x0b, 0x10, 0x53, 0x00, 0x0b, 0x16, 0xff };  // NTSC 640x400 
I2C_string  NTSC640X480 = 
{   0xea, 0x00, 0x6A, 0x07, 0x5c, 0x0a, 0x2a, 0x0b, 0x00, 0x53, 0x00, 0x3F, 0x7E, 0xff };  // NTSC 640x480
I2C_string  NTSC800X600 = 
{   0xea, 0x00, 0x8D, 0x07, 0x8c, 0x0a, 0x3c, 0x0b, 0x00, 0x53, 0x02, 0x59, 0x2E, 0xff };  // NTSC 800x600

// PAL values 
I2C_string  PAL320X200 =
{   0xea, 0x00, 0x40, 0x07, 0xc8, 0x0a, 0x34, 0x0b, 0x08, 0x53, 0x00, 0x3d, 0x6c, 0xff };  // PAL 320x200 (640x400)
I2C_string  PAL320X240 =
{   0xea, 0x00, 0x61, 0x07, 0xc0, 0x0a, 0x38, 0x0b, 0x00, 0x53, 0x00, 0x04, 0x09, 0xff };  // PAL 320x240 (640x480)
I2C_string  PAL400X300 = 
{   0xea, 0x00, 0x83, 0x07, 0xc0, 0x0a, 0x40, 0x0b, 0x00, 0x53, 0x00, 0x21, 0x56, 0xff };  // PAL  800x600 (800x600)
I2C_string  PAL480X360 = 
{   0xea, 0x00, 0x40, 0x07, 0x5c, 0x0a, 0x30, 0x0b, 0x10, 0x53, 0x00, 0x3d, 0x6c, 0xff };  // PAL  480x360 (640x400)
I2C_string  PAL512X384 = 
{   0xea, 0x00, 0x40, 0x07, 0x5c, 0x0a, 0x30, 0x0b, 0x10, 0x53, 0x00, 0x3d, 0x6c, 0xff };  // PAL  512x384 (640x400)
I2C_string  PAL640X400 = 
{   0xea, 0x00, 0x40, 0x07, 0x5c, 0x0a, 0x2e, 0x0b, 0x10, 0x53, 0x00, 0x3d, 0x6c, 0xff };  // PAL  640x400 100
I2C_string  PAL640X480 = 
{   0xea, 0x00, 0x61, 0x07, 0x70, 0x0a, 0x38, 0x0b, 0x00, 0x53, 0x00, 0x04, 0x09, 0xff };  // PAL  640x480 101
I2C_string  PAL800X600 = 
{   0xea, 0x00, 0x83, 0x07, 0xc0, 0x0a, 0x40, 0x0b, 0x00, 0x53, 0x00, 0x21, 0x56, 0xff };  // PAL  800x600 103

// Chrontel I2C strings for TV modes 0..8 (no mode 2)
I2C_string *i2c_NTSC[] = {&NTSC320X200, &NTSC320X240, &NULL_STRING, &NTSC400X300, &NTSC480X360, &NTSC512X384, 
    &NTSC640X400, &NTSC640X480, &NTSC800X600};
I2C_string *i2c_PAL[]  = {&PAL320X200, &PAL320X240, &NULL_STRING, &PAL400X300, &PAL480X360, &PAL512X384, 
    &PAL640X400, &PAL640X480, &PAL800X600};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vdd\nvidia.inc ===
;       (C) Copyright NVIDIA Corporation Inc., 1996,1997. All rights reserved.
;       Portions Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.
;
;       NVIDIA.INC - Include file for MiniVDD definitions
;
;       Written by:     Mark Stephen Krueger
;       Date:           10/1/96
;
;       $Revision: 6 $
;       $Date: 5/05/98 6:36p $
;       $Logfile: /resman.050/win96/vdd/nvidia.inc $
;       $Log: /resman.050/win96/vdd/nvidia.inc $
; 
; 6     5/05/98 6:36p Jhinman
; Removed Weitek simulation equates.
; 
; 5     1/14/98 3:04p Jhinman
; Moved API functions to 1xx.
; 
; 4     1/09/98 2:03p Jhinman
; Added some equates for API definitions.
; 
; 3     11/07/97 6:42p Jhinman
; Add equate for nv_device_id.
; 
; 2     10/27/97 3:02p Jhinman
; Define RM_OK (status).
; 
; 1     5/13/97 10:43a Jeffwe
; 
; 1     5/12/97 6:49p Jeffwe
; 
; 6     1/23/97 11:02a Markk
; Removed tabs.
; 
; 5     1/14/97 3:42p Markk
; Added EXT_NV_PDAC_GEN_CTRL and EXT_NV_PFB_CONFIG_0 to save
; corresponding NV3 registers.
; 
; 4     11/15/96 6:05p Markk
; Put in NVIDIA_COMMON stuff for simulating.
; 
; 3     11/13/96 12:28p Markk
; Updated PerVMData for NV3.
; Fixed PCI_DWORD_* constants.
; Added other PCI commands and error codes.
; 
; 2     10/21/96 7:02p Markk
; Added more VGA register definitions.
; Added flag to save structure to know when values saved.
; 
; 1     10/16/96 9:16a Markk
; Include file for the NVidia Mini-VDD.
;

; OS Version numbers
VERS_MILLENNIUM    EQU     045ah
VERS_WIN98         EQU     040AH

; Definitions of ACPI power states. Should be (but aren't) defined in CONFIGMG.INC.
CM_POWERSTATE_D3   EQU     8   
CM_POWERSTATE_D2   EQU     4
CM_POWERSTATE_D1   EQU     2
CM_POWERSTATE_D0   EQU     1
CM_POWERSTATE_HIBERNATE   EQU     10h

; Resource Manager API functions
NVRM_API_ARCHITECTURE_32 equ 1000+73
NVRM_API_DISPLAY         equ 1000+75
NVRM_API_ACPI_ENABLED    equ 1000+82

NVRM_API_ALLOC_FIFO equ     1000+1
NVRM_API_MAP_FIFO   equ     1000+3
MAP_LINEAR          equ     1
NVRM_API_INIT       equ     1000+100
NVRM_API_ENABLEVGA  equ     1000+101
NVRM_API_ENABLEHIRES equ    1000+102
NVRM_API_DEV_HANDLE equ     1000+103
NVRM_API_DEV_HANDLE_2 equ   1000+104
NVRM_API_POWER_UP   equ     1000+105
NVRM_API_POWER_DOWN equ     1000+106
NVRM_API_EXIT       equ     1000+107
NVRM_API_POWER_D1   equ     1000+108
NVRM_API_POWER_D2   equ     1000+109
NVRM_API_READ_EDID  equ     1000+112
NVRM_API_NUM_HEADS  equ     1000+113
NVRM_API_GET_DDC_CAPS equ   1000+114
NVRM_API_HIBERNATE  equ     1000+115
NVRM_API_SET_MONITOR_POWER equ 1000+116
NVRM_API_BLANK_SECONDARY   equ 1000+117   
NVRM_API_DISPLAY_GET_BOOT_PHYS_MAP      equ     1000+118
; RM display types
DISPLAY_TYPE_MONITOR    equ 0
DISPLAY_TYPE_TV         equ 1
DISPLAY_TYPE_FLAT_PANEL equ 3

;
;Chip ID equates:
;
NV31A           equ     DRF_DEF(_PMC,_BOOT_0,_IMPLEMENTATION,_NV3) OR \
                        DRF_DEF(_PMC,_BOOT_0,_MASK_REVISION_A) OR \
                        DRF_DEF(_PMC,_BOOT_0,_FIB_REVISION_0)
  
RM_OK                   equ             0

NV3_DEVICE_ID   EQU             0018H

;
; I/O addresses
;
CRTC_INDEX_MONO         equ     03B4h
CRTC_DATA_MONO          equ     03B5h
CRTC_INDEX_COLOR        equ     03D4h
CRTC_DATA_COLOR         equ     03D5h
INPUT_STATUS_MONO       equ     CRTC_INDEX_MONO + 6
INPUT_STATUS_COLOR      equ     CRTC_INDEX_COLOR + 6
OUTPUT_FC_MONO          equ     CRTC_INDEX_MONO + 6
OUTPUT_FC_COLOR         equ     CRTC_INDEX_COLOR + 6
ATC_INDEX               equ     03C0h
ATC_RDATA               equ     03C1h
MISC_OUTPUT             equ     03C2h
FEAT_STATUS             equ     03C2h
SUBSYS_ENABLE           equ     03C3h
SEQ_INDEX               equ     03C4h
SEQ_DATA                equ     03C5h
DAC_MASK                equ     03C6h
DAC_RINDEX              equ     03C7h
DAC_WINDEX              equ     03C8h
DAC_DATA                equ     03C9h
FC_INPUT                equ     03CAh
MISC_INPUT              equ     03CCh
GDC_INDEX               equ     03CEh
GDC_DATA                equ     03CFh
;
BIOS_SCRATCH1       equ     2Ch         ; BIOS SCRATCH REG
BIOS_PGRM_TV        equ     2           ; BIOS will program TV encoder when CLEAR
NVRM_ACCESS         equ     038h
NVRM_ACCESS_MASK    equ     001h
NVRM_IDENT          equ     000h
NVRM_ADDRESS        equ     002h
NVRM_DATA           equ     004h
NVRM_DATA32         equ     006h
NVRM_SELECT_MASK    equ     006h        ; Mask for decode bits
NVRM_SELECT         equ     1           ; Least signifcant bit is 1


;----------------------------------------------------------------------------
unlock_extension_regs           macro

        mov     edx,SEQ_INDEX           ; EDX -> SR index register
        in      al,dx                   ; get current SR index
        ror     eax,8                   ; save it

        mov     ax,05706h               ; this will unlock the extension regs
        out     dx,ax                   ;
;
        rol     eax,8                   ; get the index
        out     dx,al                   ; restore SR index
        endm


;
;The PerVMData structure.  This structure represents the our reserved space
;in the so-called CB data structure.  The CB data structure is created for
;each VM started in the system.  We can therefore, save states that we need
;to remember on a per-VM basis.  This data will vary for every mini-VDD.
;The NVidia chipsets requires a few registers states for its extension registers
;to be saved.
;
PerVMData       struc
        Latch0                  db      ?               ; Graphics controller latches
        Latch1                  db      ?
        Latch2                  db      ?
        Latch3                  db      ?
        SeqReg06                db      ?
IFDEF NVIDIA_SPECIFIC
        EXT_Repaint0NV          db      ?               ; CRTC[19]
        EXT_Repaint1NV          db      ?               ; CRTC[1A]
        EXT_Repaint1NVSet       db      ?               ; CRTC[1A] Set?
        EXT_FifoBurst           db      ?               ; CRTC[1B]
        EXT_Repaint3NV          db      ?               ; CRTC[1C]
ENDIF ; NVIDIA_SPECIFIC
        EXT_WriteBank           db      ?               ; CRTC[1D]
        EXT_ReadBank            db      ?               ; CRTC[1E]
        EXT_Unlock              db      ?               ; CRTC[1F]
IFDEF NVIDIA_SPECIFIC
        EXT_FifoLowWaterMark    db      ?               ; CRTC[20]
        EXT_ExtraBits           db      ?               ; CRTC[25]
        EXT_PixelFormat         db      ?               ; CRTC[28]
        EXT_TVDecimation        db      ?               ; CRTC[29]
        EXT_OverscanHigh        db      ?               ; CRTC[2A]
        EXT_HorizontalExtra     db      ?               ; CRTC[2D]
ENDIF ; NVIDIA_SPECIFIC
        EXT_HWCursorAddress0    db      ?               ; CRTC[30]
        EXT_HWCursorAddress1    db      ?               ; CRTC[31]
IFDEF NVIDIA_SPECIFIC
        EXT_VideoWindow0        db      ?               ; CRTC[32]
        EXT_VideoWindow1        db      ?               ; CRTC[33]
ENDIF ; NVIDIA_SPECIFIC
IFDEF NVIDIA_COMMON
        EXT_RealModeAccess      db      ?               ; CRTC[38]
ENDIF ; NVIDIA_COMMON
IFDEF NVIDIA_SPECIFIC
        EXT_Interlace           db      ?               ; CRTC[39]
ENDIF ; NVIDIA_SPECIFIC
            EXT_CanopusTVReg    db      ?               ; Canopus TV Flag register (which ever it is. )
IFDEF NVIDIA_COMMON
        EXT_RealModeAddress     dd      ?               ; Real mode address
        EXT_RealModeData32      dw      ?               ; Latched word for real mode data
;        EXT_VpllM               db      ?               ; VPLL M
;        EXT_VpllN               db      ?               ; VPLL N
;        EXT_VpllP               db      ?               ; VPLL P
        EXT_NV_VPLL_COEFF       dd      ?               ; VPLL Coefficients        
        EXT_NV_PRAMDAC          dd      ?               ; NV_PRAMDAC_PLL_COEFF_SELECT
        EXT_NV_PDAC_GEN_CTRL    dd      ?               ; NV_PRAMDAC_GENERAL_CONTROL
        EXT_NV_PFB_CONFIG_0     dd      ?               ; NV_PFB_CONFIG_0
        EXT_NV_VPLL2_COEFF      dd      ?               ; VPLL Coefficients        
ENDIF ; NVIDIA_COMMON
        Majic                   dd      ?               ; Used for debugging
        StdCRTC                 db      25 dup (?)      ; CRTC 0-18h
;;;;;;;;SR1                     db      ?               ; Sequencer 1
        GoingFullscreen         db      ?               ; set in PostHiresToVGA, cleared in RestoreRegs
IFDEF NVIDIA_SPECIFIC
        EXT_HeadOwner           db      ?               ; CRTC[44]
ENDIF ; NVIDIA_SPECIFIC
PerVMData       ends
;
;FALSE           equ     TRUE
TRUE            equ     (NOT FALSE)
;
PCI_MECH1_CNT           record  PCI_ENABLE_CONFIG1:1, PCI_RESA1:7, PCI_BUS1:8, \
                                PCI_DEVICE1:5, PCI_FUNCTION1:3, PCI_DWORD1:6, PCI_RESB1:2
;PCI_DEVICE_MAX          equ     32      
;PCI_DEVICE_LOW_BIT      equ     11      
PCI_MECH1_ADDR          equ     00CF8h
PCI_MECH1_DATA          equ     00CFCh
;
PCI_MECH2_CSE         equ     00CF8h
PCI_MECH2_FORWARD     equ     00CFAh
PCI_MECH2_BASE        equ     0C000h
PCI_MECH2_ADDR          record  PCI_RESA2:4, PCI_DEVICE2:4, PCI_DWORD2:6, PCI_RESB2:2
PCI_MECH2_CNT           record  PCI_ENABLE_CONFIG2:4, PCI_FUNCTION2:3, PCI_SCE2:1
PCI_MECH2_KEY_ENABLE    equ     00Fh
;PCI_ENABLE_CONFIG_MASK  equ     080000000h
;PCI_VENDOR_ID_MASK      equ     0FFFFh
;PCI_BASE_ADDR_MASK      equ     0FFFFFFF0h
;PCI_FUNC_LOW_BIT        equ     8
PCI_CONF_00             record  PCI_DEV_ID:16, PCI_VENDOR_ID:16
PCI_CONF_01             record  PCI_STATUS:16, PCI_COMMAND:16
PCI_CONF_02             record  PCI_CLASS:24, PCI_REV:8
PCI_CONF_03             record  PCI_BIST:8, PCI_HEADER_TYPE:8, PCI_LATENCY:8, PCI_CACHE_LINE:8
PCI_CONF_11             record  PCI_SUB_ID:16, PCI_SUB_VENDOR_ID:16
PCI_CONF_15             record  PCI_MAX_LAT:8, PCI_MIN_GNT:8, PCI_INT_PIN:8, PCI_INT_LINE:8
PCI_BAR                 record  PCI_ADDR:28, PCI_PREFETCH:1, PCI_TYPE:2, PCI_MEM:1
PCI_CMD                 record  PCI_CMD_RES:6, PCI_CMD_FAST_BB:1, PCI_CMD_SERR:1, PCI_CMD_WAIT_CC:1, \
                                PCI_CMD_PARITY:1, PCI_CMD_PALETTE:1, PCI_CMD_MWI:1, PCI_CMD_SCM:1, \
                                PCI_CMD_MASTER:1, PCI_CMD_MEM:1, PCI_CMD_IO:1
;
PCI_DWORD_0             equ     0
PCI_DWORD_1             equ     1
PCI_DWORD_2             equ     2
PCI_DWORD_3             equ     3
PCI_DWORD_4             equ     4
PCI_DWORD_5             equ     5
PCI_DWORD_6             equ     6
PCI_DWORD_7             equ     7
PCI_DWORD_8             equ     8
PCI_DWORD_9             equ     9
PCI_DWORD_10            equ     10
PCI_DWORD_11            equ     11
PCI_DWORD_12            equ     12
PCI_DWORD_13            equ     13
PCI_DWORD_14            equ     14
PCI_DWORD_15            equ     15
;
NV_DEFAULT              equ     0CC000000h
;
PCI_FUNCTION_ID         equ     0B1h
PCI_BIOS_PRESENT        equ     001h
FIND_PCI_DEVICE         equ     002h
FIND_PCI_CLASS_CODE     equ     003h
GENERATE_SPECIAL_CYCLE  equ     006h
READ_CONFIG_BYTE        equ     008h
READ_CONFIG_WORD        equ     009h
READ_CONFIG_DWORD       equ     00Ah
WRITE_CONFIG_BYTE       equ     00Bh
WRITE_CONFIG_WORD       equ     00Ch
WRITE_CONFIG_DWORD      equ     00Dh
;
PCI_SUCCESSFUL          equ     000h
PCI_FUNC_NOT_SUPPORTED  equ     081h
PCI_BAD_VENDOR_ID       equ     083h
PCI_DEVICE_NOT_FOUND    equ     086h
PCI_BAD_REGISTER_NUMBER equ     087h
;
RefreshRateStruct       struc
VetricalRefreshRate             dd      ?               ; Vertical refresh rate in Hz
HorizontalRefreshRate           dd      ?               ; Horizontal refresh rate in Hz
crtcInfoBlockForced             CRTCInfoBlock   <>      ; CRTCInfoBlock        
RefreshRateStruct       ends
;
PRefreshRateStruct      typedef ptr RefreshRateStruct
;
; Clock rates that must be in the NVidia BIOS clock table
DC_031_500              equ     3150
DC_025_175              equ     2518
DC_049_500              equ     4950
DC_050_000              equ     5000
DC_040_000              equ     4000
DC_036_000              equ     3600
DC_078_750              equ     7875
DC_075_000              equ     7500
DC_065_000              equ     6500
DC_044_900              equ     4490
DC_135_000              equ     13500
DC_108_500              equ     10850

;;;;typedef struct def_rmusrapi_struct {
;;;;  U032  function;       
;;;;  U032  device; 
;;;;} RMUSRAPI_STRUCT,*PRMUSRAPI_STRUCT;
minivdd_CALLRM_rmusrapi_Struct struct
  rmusrapi_function           dd      0
  rmusrapi_device             dd      0
minivdd_CALLRM_rmusrapi_Struct ends
DEFAULT_PRIMARY_HDEV          equ 1
DISPLAY_TYPE_MONITOR          equ 0
DISPLAY_TYPE_TV               equ 1
DISPLAY_TYPE_DUALSURFACE      equ 2
DISPLAY_TYPE_FLAT_PANEL       equ 3
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vdd\nvmini2.asm ===
;       (C) Copyright NVIDIA Corporation Inc., 1996,1997. All rights reserved.
;       Portions Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.
;
;       NV3MINI2.ASM - NVidia secondary Mini-VDD for NV3
;
;       Written by:     JohnH
;       Date:           12/17/97
;
;
;
page            ,132
title           NVidia NV3 Secondary Mini-VDD Support Functions
.386p
;

;
.xlist
MINIVDD                 EQU             1               ; this must be defined for minivdd.inc

include         VMM.INC
include         VWIN32.INC                      ; used for IOCTL for KMVT
include                 VXDLDR.INC
include         DEBUG.INC
include         MINIVDD.INC
include         configmg.inc
include         VNVRMD.INC
include         V86MMGR.INC
include         NVDEF.INC
include         VBE30.INC
include         NVIDIA.INC
IFDEF NVIDIA_COMMON
include         NV_REF.INC
include         NV_MAC.INC
include         NV_SIM.INC
ENDIF ; NVIDIA_COMMON
include                  SURFACES.INC

IFDEF   DIOC
extrn           GetDDHAL:near
extrn                            NvFillTable:near
extern                   NVGetSetCallback:near
extern          NVSetVidTexSuf:near
ENDIF   ;DIOC

.list

;**************************************************************************************************************************
subttl          Virtual Device Declaration
page +
;       Then MiniVDD must have the UNDEFINED_DEVICE_ID
;       and it is a dynamic load VxD, so it cannot have a service table.
Declare_Virtual_Device  NVMINI2, \
                        3,      \
                        1,      \
                        MiniVDD_Control,        \
                        UNDEFINED_DEVICE_ID,    \
                        VDD_INIT_ORDER,         \
                                                ,                                               \
                        ,                                       \
                        ,

;
;
;**************************************************************************************************************************
subttl          Initialization Data
page +
VxD_IDATA_SEG
NVRM_String            db      'NVCORE.VXD',0
VxD_IDATA_ENDS
;
;**************************************************************************************************************************
subttl          Locked Data Area
page +
VxD_LOCKED_DATA_SEG
TotalMemorySize dd              400000h
VxD_LOCKED_DATA_ENDS
;
;**************************************************************************************************************************
subttl          General Data Area
page +
VxD_DATA_SEG
;
OSVersion       dw      0
ResManAPI       dd      0
devNode         dd      0
nvAddr          dd      0
nvPhys          dd      0
fbPhys          dd      0
fbLength        dd      0
nvIRQ           dd      0
hDev            dd      0
DevCtlRet       dd      0
NumUnits	dd      0               ; number of "units" or heads
;
public  VGAModeFlag
VGAModeFlag             db      0               ;=FFh when in 16 color mode (VGA driver)


; JJV-MM
; This Minivdd must handle up to 8 secondary devices (7 if the primary is also an NV4).
minivdd_instance_Struct struct
  instance_devNode          dd      0
  instance_nvAddr           dd      0
  instance_nvPhys           dd      0
  instance_fbPhys           dd      0
  instance_fbLength         dd      0
  instance_nvIRQ            dd      0
  instance_hDev             dd      0
  instance_ACPI_state       dd      0
minivdd_instance_Struct ends
; Static structures for each instance.
device1_instance minivdd_instance_Struct <>
device2_instance minivdd_instance_Struct <>
device3_instance minivdd_instance_Struct <>
device4_instance minivdd_instance_Struct <>
device5_instance minivdd_instance_Struct <>
device6_instance minivdd_instance_Struct <>
device7_instance minivdd_instance_Struct <>
device8_instance minivdd_instance_Struct <>

; resource manager parameter passing structure.
minivdd_RM_Parameter_Struct struct
  callrm_device_handle        dd      0
  callrm_modechange_callback  dd      0
  callrm_irq_bus              dd      0
  callrm_fbphys               dd      0
  callrm_nvphys               dd      0
  callrm_registry_path        dd      0
minivdd_RM_Parameter_Struct ends
callrm_struct minivdd_RM_Parameter_Struct <>
callrm_rmusrapi minivdd_CALLRM_rmusrapi_Struct <>

public  DisplayInfoStructure
DisplayInfoStructure    DISPLAYINFO     <>

PUBLIC  dwCreatingVM
dwCreatingVM            DD      0

JIMK1   EQU     <1>

IF JIMK1
PUBLIC  dwDisplayDevnodeHandle
dwDisplayDevnodeHandle  DD      0

PUBLIC  szEnumAndMore
szEnumAndMore   DB      "Enum\"
szAndMore       DB      128 DUP(0)

PUBLIC  szLocalDisplayPath, szLocalDisplayPathEnd
szLocalDisplayPath      DB      "System\CurrentControlSet\Services\Class\"
szLocalDisplayPathEnd   DB      32 DUP(0)

PUBLIC  szDriver
szDriver        DB      "Driver",0

PUBLIC  szDisplayEndPath
szDisplayEndPath        DB      32 DUP(0)

ALIGN 4
PUBLIC  dwCBType, dwCBLen, hKey
dwCBType        DD      0
dwCBLen         DD      0
hKey            DD      0
ENDIF

VxD_DATA_ENDS
;
;
;**************************************************************************************************************************
subttl          Device Initialization
page +
VxD_ICODE_SEG

public  MiniVDD_Dynamic_Exit
BeginProc MiniVDD_Dynamic_Exit
   xor eax, eax
   ret
EndProc MiniVDD_Dynamic_Exit

;
public  MiniVDD_Dynamic_Init
BeginProc MiniVDD_Dynamic_Init
;
;Entry:
;       EBX contains the VM handle of the Windows VM.
;Exit:
;       If success, return NC.
;       If failure, return CY.
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_Dyanmic_Init", DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        push    ebx                     ;save Windows VM handle in EBX
        push    ebp
;
;               Load the resource manager. If already loaded, this will just return the entry point.
                mov             edx, OFFSET32 NVRM_String
                mov             eax, VXDLDR_INIT_DEVICE
                VxDcall VXDLDR_LoadDevice
        jnc     @f
                jmp             MVDIErrorExit                   ;failed, nothing we can do

@@:
;       returns DDB address in eax and device handle in edx
;       save the API entry
                mov             eax, [eax].DDB_PM_API_Proc
                mov             ResManAPI, eax
;

;	Correct the string for multihead configuration
;	Change %s\Unit%d --> %s\U%d
	push	ecx
	push	edx
	push	edi
	mov	eax,0ah
	xor	edi,edi
	VMMCall	Get_DDB
	or	ecx,ecx
	jz	@F
	lea	edi,[ecx+18h]
	mov	edx,ASSERT_RANGE_NO_DEBUG OR ASSERT_RANGE_NULL_BAD
	VMMCall	_Assert_Range,<edi,4,0,0,edx>
	or	eax,eax
	jz	@F
	mov	edi,[edi]
	lea	edi,[edi+13fch]
	VMMCall	_Assert_Range,<edi,4,2574696eh,0,edx>
	or	eax,eax
	jz	@F
	mov	ecx,6425h		; '%d'
	mov	[edi],ecx
@@:
	pop	edi
	pop	edx
	pop	ecx
;
public  MVDIDispatch
MVDIDispatch:
;
;
;Fill in the addresses of all the functions that we need to handle in this
;mini-VDD in the table provided by the "master" VDD whose address is
;contained in EDI.  Note that if you do not need to support a function,
;you do not need to fill in the dispatch table entry for that function.
;If you do not fill in an entry, the "master" VDD won't try to call
;this mini-VDD to support the function.  It'll just handle it in a
;default manner.
;
        VxDCall VDD_Get_Mini_Dispatch_Table
        cmp     ecx,NBR_MINI_VDD_FUNCTIONS      ;perform a cursory version check
        jb      MVDIErrorExit                   ;oops, versions don't match!
;
public  MVDI_FillInTable
MVDI_FillInTable:
        MiniVDDDispatch REGISTER_DISPLAY_DRIVER,RegisterDisplayDriver
        MiniVDDDispatch GET_TOTAL_VRAM_SIZE,GetTotalVRAMSize
        ;
        ; new Win98 functions...
        ;
        VMMcall Get_VMM_Version
;        .if (!(carry?) && (ax == 040ah))
        jc  PreWin98
        mov   OSVersion,ax
        cmp   ax,VERS_WIN98
        jb    PreWin98
;       The primary needs to support these
        MiniVDDDispatch TURN_VGA_OFF,TurnVgaOff
        MiniVDDDispatch TURN_VGA_ON,TurnVgaOn

;       This is required if the device supports multiple displays (NV4?)
        MiniVDDDispatch GET_NUM_UNITS,GetNumUnits

         ;These are for power management. We don't need the monitor functions, since Windows will use VESA calls
         ; if we don't hook them.
;ifdef ON_NOW
          MiniVDDDispatch SET_ADAPTER_POWER_STATE,SetAdapterPowerState
          MiniVDDDispatch GET_ADAPTER_POWER_STATE_CAPS,GetAdapterPowerStateCaps
;endif
;          MiniVDDDispatch SET_MONITOR_POWER_STATE,SetMonitorPowerState
;          MiniVDDDispatch GET_MONITOR_POWER_STATE_CAPS,GetMonitorPowerStateCaps
;        .endif
PreWin98:

;
MVDIGoodExit:
        clc                             ;return success
        jmp     MVDIExit                ;
;
MVDIErrorExit:
        stc
;
MVDIExit:
        pop     ebp
        pop     ebx                     ;restore Windows VM handle to EBX
IFDEF DEBUG_LOG
        pushf
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "\n\r", DEBLEVELMAX
                pop     eax
        .endif
        popf
ENDIF ; DEBUG_LOG
        ret
EndProc MiniVDD_Dynamic_Init
;

;
VxD_ICODE_ENDS
;
;**************************************************************************************************************************
subttl          Dispatch Table for VMM Calling This Mini-VDD
page +
VxD_LOCKED_CODE_SEG
;
;
Begin_Control_Dispatch  MiniVDD
        Control_Dispatch SYS_DYNAMIC_DEVICE_INIT, MiniVDD_Dynamic_Init  ;init function for dynamic VXD
        Control_Dispatch PnP_New_DevNode, MiniVDD_PnP_New_DevNode ;init function for new pnp devnode
                Control_Dispatch SYS_VM_TERMINATE, MiniVDD_Sys_VM_Terminate             ;try to release traps here
                ;Control_Dispatch SYS_DYNAMIC_DEVICE_EXIT, MiniVDD_Dynamic_Exit  ;try to release traps here
            Control_Dispatch W32_DEVICEIOCONTROL, MiniVDD_W32_DIOC
        ;
End_Control_Dispatch MiniVDD

public  MiniVDD_W32_DIOC
BeginProc MiniVDD_W32_DIOC
;-----------------------------------------------------------------
;       D E V I C E I O C O N T R O L   I N T E R F A C E
;-----------------------------------------------------------------
;  ENTRY :
;        ESI -> address of DIOC structure

        pushad

        mov  ecx, [ esi ].dwIoControlCode
        cmp  ecx, DIOC_CLOSEHANDLE
        je   DevCtl_CloseHandle

        cmp  ecx, DIOC_GETVERSION
        je   DevCtl_GetVersion

        cmp  ecx, VDD_IOCTL_NV_GETSETCALLBACK
        jnz  Next0
        call NVGetSetCallback
        jmp  MiniVDDDone

Next0:
        cmp  ecx, VDD_IOCTL_NV_FILLTABLE
        jnz  Next1
        call   NvFillTable
        jmp     MiniVDDDone
Next1:
        cmp  ecx, VDD_IOCTL_GET_DDHAL
        jnz  Next2
        call GetDDHAL
        jmp  MiniVDDDone
Next2:
   cmp  ecx, VDD_IOCTL_NV_SETVIDTEXSURF
        jnz  MiniVDDDone
        call NVSetVidTexSuf


MiniVDDDone:
        cmp     eax,1
        jae  DevCtl_Fails

;----------------------------------------------------------------
;
;  ECX = -1 ( DIOC_CLOSEHANDLE )
;
;----------------------------------------------------------------

DevCtl_CloseHandle      :

        jmp  DevCtl_OKey

;----------------------------------------------------------------
;
;  ECX = 0 ( DIOC_GETVERSION )
;
;----------------------------------------------------------------
DevCtl_GetVersion :

        jmp  DevCtl_OKey

DevCtl_Fails :

        mov DevCtlRet, 50    ; ERROR_NOT_SUPPORTED
        stc                  ; indicate error
        jmp DevCtl_Exit

DevCtl_OKey :

        mov DevCtlRet, 0
        clc
        jmp DevCtl_Exit

DevCtl_Exit :

        popad
        mov eax, DevCtlRet
        ret
EndProc MiniVDD_W32_DIOC

;
;--------------------------------------------------------------------------
public  MiniVDD_TurnVgaOff
BeginProc       MiniVDD_TurnVgaOff, DOSVM

                push    eax
                push    esi

                ;Disable VGA through the VGA Enable IO register.
                REG_RD08(NV_PRMVIO_VSE2)
                and al,0feh
                REG_WR08(NV_PRMVIO_VSE2)

                ;Disable NV PCI IO, bit0 = 0.
                REG_RD32(NV_PBUS_PCI_NV_1)
                and     al,0feh
                REG_WR32(NV_PBUS_PCI_NV_1)

                ;Disable NV interrupts.
;;                xor     eax,eax
;;                REG_WR32(NV_PMC_INTR_EN_0)

                pop     esi
                pop     eax

                ret
EndProc         MiniVDD_TurnVgaOff
;
;--------------------------------------------------------------------------
public  MiniVDD_TurnVgaOn
BeginProc       MiniVDD_TurnVgaOn, DOSVM

                push    eax
                push    esi

                ;We may not be mapped into the linear address space.
                ;If not, make it so.
                REG_RD32(NV_PBUS_PCI_NV_4)      ;get Bar 0 thru linear space
                cmp     eax,nvPhys              ;are we still here?
                jz      @f
                
                ;Go out to PCI space and reenable
                mov     edx,0cf8h
                mov     esi, offset callrm_struct
                mov     eax, dword ptr [esi].minivdd_RM_Parameter_Struct.callrm_irq_bus
                and     eax,0ffffff00h          ;clear lower byte (IRQ)
                or      eax,80000004h           ;enable config space mapping, reg 4 = command reg
                out     dx,eax
                mov     dx,0cfch
                in      eax,dx
                or      eax,3                   ;enable mem + I/O
                out     dx,eax
@@:                
                ;Enable NV PCI IO, bit0 = 1.
                REG_RD32(NV_PBUS_PCI_NV_1)
                or      al,01h
                REG_WR32(NV_PBUS_PCI_NV_1)

                ;Enable VGA through the VGA Enable IO register.
;This comment is here because the assembler was giving "line too long" error--comment fixes it. Very strange!
                REG_RD08(NV_PRMVIO_VSE2)
;
                or al,01h
                REG_WR08(NV_PRMVIO_VSE2)

                ;Enable NV interrupts.
                xor     eax,eax
                mov     al,1
                REG_WR32(NV_PMC_INTR_EN_0)

                pop     esi
                pop     eax

                ret
EndProc         MiniVDD_TurnVgaOn

;----------------------------------------
;Entry: none
;Exit:  ax = number of heads (crtc's)
public MiniVDD_GetNumUnits
BeginProc       MiniVDD_GetNumUnits, DOSVM
                pushad
;               Ask the RM how many heads are supported
                mov     ebx, DEFAULT_PRIMARY_HDEV
                mov     eax, NVRM_API_NUM_HEADS     ; load up the function number
                call    CallRM                      ; go to RM's API procedure
                mov     eax,ebx                     ; return in eax
                mov     NumUnits,eax                ; save in static area

;               We cannot run dual heads in VGA mode. Find out if we are in 16 color mode.
                cmp     eax,2                   ; dual CRTC device?
                jl      NumUnitsGotten          ; no, then the mode doesn't matter

;               Get Display Info from VDD
                push    ecx
                push    edi
                mov     eax,OFFSET32 DisplayInfoStructure
                mov     ecx,SIZE DISPLAYINFO    ;pass size in ECX, address in EAX
                mov     [eax].diHdrSize,cx      ;fill in this entry
                push    eax                     ;save EAX --> DisplayInfoStructure
                VxDCall VDD_Get_DISPLAYINFO     ;get information from the VDD
                pop     edi                     ;restore EAX --> DisplayInfoStructure
                mov     VGAModeFlag,0
                cmp     [edi].diBpp,4           ;16 color?
                jne     @f
                mov     VGAModeFlag,0FFh
                mov     NumUnits,1              ;Don't allow dual head if VGA.DRV is running!
@@:
                pop     edi
                pop     ecx
NumUnitsGotten:

                popad
                mov     eax, NumUnits
                ret
EndProc         MiniVDD_GetNumUnits

;******************************************************************************
;
;   GetBusDeviceAndFunctionNumber
;
;   DESCRIPTION:
;       Locates the device on the PCI Bus and returns the Bus, Device and Function Numbers.
;
;   ENTRY:
;       EBX = nvPhys
;       ECX = fbPhys
;       EDX = nvIRQ
;
;   EXIT:
;       EAX = EDX will now contain the needed info.
;         EDX xxxxxxxx xxxxxxxx xxxxx  xxx  xxxxxxxx
;             00000000    Bus # Device Func        IRQ #
;
;   USES:
;       Can use all registers and flags
;
;==============================================================================
BASE0_OFFSET EQU 10h
BASE1_OFFSET EQU 14h
IRQ_OFFSET       EQU 3ch
BeginProc GetBusDeviceAndFunctionNumber

  local bus_number:BYTE
  local device_number:BYTE
  local function_number:BYTE
  local base0:DWORD
  local base1:DWORD
  local irq:BYTE
  local return_val:DWORD

  pushad

  mov   base0, ebx
  mov   base1, ecx
  mov   irq, dl
  ; Check all buses devices and functions for the memory windows and IRQ input.
  mov   bus_number,0
  .repeat
    mov   device_number,0
    .repeat
      mov   function_number,0
      .repeat
        ; Read the PCI bus and check if we have a match.
        xor   eax,eax
        mov   al, bus_number
        shl   eax,16
        mov   ah, device_number
        shl   ah,3
        or    ah, function_number
        mov   al, BASE0_OFFSET
        or    eax, 80000000h           ; eax will now contain the configuration address for the PCI read.
        ReadPCI                                ; Returns the Dword read from the PCI Config space in edx.
        and   dl,0
        .if(edx == base0)
          mov   al, BASE1_OFFSET
          ReadPCI                                  ; Returns the Dword read from the PCI Config space in edx.
          and   dl,0
          .if(edx == base1)
            mov   al, IRQ_OFFSET
            ReadPCI                                ; Returns the Dword read from the PCI Config space in edx.
            .if(dl == irq)
              ; WOW ! It works. Lets get out and return this stuff
              and   eax,00FFFF00h          ; AND off the config bit and offset.
              mov   al, irq                        ; OR in the irq
              mov   return_val, eax
              jmp   we_gots_a_match
            .endif
          .endif
        .endif
        inc   function_number
      .until function_number == 08h
      inc   device_number
    .until device_number == 01fh
    inc   bus_number
  .until bus_number == 0ffh

  mov  return_val,-1

  we_gots_a_match:
  exit_out:

  popad
  mov  edx, return_val
  ret

EndProc   GetBusDeviceAndFunctionNumber

;==============================================================================
;   findDevNode
;
;   DESCRIPTION:
;   Finds the array that matches the devNode.
;
;   ENTRY:
;       EBX = Devnode handle
;
;   EXIT:
;   Sets carry on error. On Success, sets ESI to point to the correct instance.
;
;   USES:
;       Can use all registers and flags
;
;==============================================================================
BeginProc findDevNode

    mov   esi, offset device1_instance
    .IF (dword ptr [esi].minivdd_instance_Struct.instance_devNode != ebx)
        mov   esi, offset device2_instance
        .IF (dword ptr [esi].minivdd_instance_Struct.instance_devNode != ebx)
            mov   esi, offset device3_instance
           .IF (dword ptr [esi].minivdd_instance_Struct.instance_devNode != ebx)
               mov   esi, offset device4_instance
              .IF (dword ptr [esi].minivdd_instance_Struct.instance_devNode != ebx)
                  mov   esi, offset device5_instance
                  .IF (dword ptr [esi].minivdd_instance_Struct.instance_devNode != ebx)
                      mov   esi, offset device6_instance
                      .IF (dword ptr [esi].minivdd_instance_Struct.instance_devNode != ebx)
                          mov   esi, offset device7_instance
                          .IF (dword ptr [esi].minivdd_instance_Struct.instance_devNode != ebx)
                              mov   esi, offset device8_instance
                              .IF (dword ptr [esi].minivdd_instance_Struct.instance_devNode != ebx)
                                  ; Did not find a match
                                  stc
                                  ret
                              .ENDIF
                          .ENDIF
                      .ENDIF
                  .ENDIF
              .ENDIF
           .ENDIF
        .ENDIF
    .ENDIF

    ; Found the devNode. ESI is setup to point to that instance
    clc
    ret
EndProc findDevNode

;==============================================================================
;   DoConfigRemove
;
;   DESCRIPTION:
;       Handles the CONFIG_REMOVE message. In reality it handles any message that
;   gives us a hint that the device is going to be removed. We never get a CONFIG_REMOVE!
;
;   ENTRY:
;       EBX = Devnode handle
;
;   EXIT:
;       EAX = CR_RESULT
;
;   USES:
;       Can use all registers and flags
;
;==============================================================================
BeginProc DoConfigRemove

    mov  devNode, ebx
    call findDevNode  ; ebx has the devnode.
    .IF (carry?)
       mov eax, CR_FAILURE
    .ELSE
       ; Found the device to be removed
       mov      eax, NVRM_API_EXIT          ; load up the function number
       mov      ebx, dword ptr [esi].minivdd_instance_Struct.instance_hDev
       call     CallRM                                      ; go to RM's API procedure

       ; Zero out the instance
       xor     ebx, ebx
       mov     dword ptr [esi].minivdd_instance_Struct.instance_devNode, ebx
       mov     dword ptr [esi].minivdd_instance_Struct.instance_nvAddr, ebx
       mov     dword ptr [esi].minivdd_instance_Struct.instance_nvPhys, ebx
       mov     dword ptr [esi].minivdd_instance_Struct.instance_fbPhys, ebx
       mov     dword ptr [esi].minivdd_instance_Struct.instance_fbLength, ebx
       mov     dword ptr [esi].minivdd_instance_Struct.instance_nvIRQ, ebx
       mov     dword ptr [esi].minivdd_instance_Struct.instance_hDev, ebx

       mov      eax, CR_SUCCESS

    .ENDIF


    ret
EndProc DoConfigRemove

;==============================================================================
;   DoConfigStart
;
;   DESCRIPTION:
;       Handles the CONFIG_START message.
;
;   ENTRY:
;       EBX = Devnode handle
;
;   EXIT:
;       EAX = CR_RESULT
;
;   USES:
;       Can use all registers and flags
;
;==============================================================================

BeginProc DoConfigStart

        .ERRNZ  SIZE Config_Buff_s MOD 4

        sub     esp, SIZE Config_Buff_s
        mov     edi, esp                ; alloc buffer on stack

        xor eax, eax
        mov devNode, ebx

IF JIMK1
    mov     dwDisplayDevnodeHandle,ebx
ENDIF

;       call the Configuration Manager to get the device config.
        VxDcall _CONFIGMG_Get_Alloc_Log_Conf, <edi, ebx, CM_GET_ALLOC_LOG_CONF_ALLOC>
        test    eax, eax
        jz      @F
        Debug_Out "MiniVDD:  Unexpected config manager error #EAX"
        jmp     DoConfigStartDone

@@:

IF JIMK1
    ; Here we determine the local registry path
    push    edi

    ; Get the correct display path in the registry
    mov     eax,[ebx + 4]
    mov     esi,OFFSET szAndMore

    ; eax now points to a string that we concatenate onto
    ; "Enum\\".  We look up this path in HKEY_LOCAL_MACHINE
@@: mov     cl,[eax]
    inc     eax
    mov     [esi],cl
    inc     esi
    or      cl,cl
    jne     @B

    ; Now open the key
    mov     hKey,0
    mov     esi,OFFSET szEnumAndMore
    mov     eax,OFFSET hkey
    VMMCall _RegOpenKey, <HKEY_LOCAL_MACHINE,esi,eax>
    or      eax,eax
    jne     UseDefaultKey

    ; Now Read the display sub path
    mov     szDisplayEndPath,0
    mov     dwCBType,REG_SZ
    mov     dwCBLen,32
    mov     eax,OFFSET dwCBType
    mov     ebx,OFFSET szDisplayEndPath
    mov     ecx,OFFSET dwCBLen
    mov     edx,OFFSET szDriver
    VMMCall _RegQueryValueEx, <hKey, edx, 0, eax, ebx, ecx>

    ; CLose the key and zero it out.
    VMMCall _RegCloseKey, <hKey>
    mov     hKey,0

    ; Now, did we get a valid string (like "DISPLAY\0005")
    cmp     szDisplayEndPath,0
    je      UseDefaultKey

    ; Make the complete path
    mov     eax,OFFSET szDisplayEndPath
    mov     ebx,OFFSET szLocalDisplayPathEnd
@@:
    mov     cl,[eax]
    inc     eax
    mov     [ebx],cl
    inc     ebx
    or      cl,cl
    jne     @B
    jmp     GotRegPath

UseDefaultKey:
    mov     eax,OFFSET szLocalDisplayPathEnd
    mov     dword ptr [eax + 0],'PSID'
    mov     dword ptr [eax + 4],'\YAL'
    mov     dword ptr [eax + 8],'0000'
    mov     byte ptr [eax + 12],0

GotRegPath:
    pop     edi
    mov     ebx,dwDisplayDevnodeHandle
    ; The local registry path is in szLocalDisplayPath
ENDIF

;       We got the device config; now parse the info and call the resource manager to map it.

        ;mov    esi, [dwRefData]        ; ESI -> adapter reference data

    ;
    ; NV3 should be given four or five memory windows
    ;
    ;   two for VGA (A0000 and B0000)
    ;   two for the PCI Bars (NV and FB)
    ;   one for AGP aperture/ROM (optional)
    ;
    ; We should find NV at index 2 and FB at index 3, but let's
    ; parse to make sure.
    ;
    ; Zero out the globals to start with.
    mov     nvPhys, 0
    mov     fbPhys, 0
    mov     fbLength, 0
    mov     nvIRQ, 0

    xor     ebx, ebx
start_1:
    ; starting with NV 4.5, we may optionally have a 32 MB fb
    ; NV10 goes up to 128MB, so we'll check for that size too
    cmp     [edi.dMemLength][ebx*4], 08000000h      ; don't expect to find fb first, but just in case
    je      found_fb
    cmp     [edi.dMemLength][ebx*4], 02000000h      ; don't expect to find fb first, but just in case
    je      found_fb
    cmp     [edi.dMemLength][ebx*4], 01000000h
    je      @F
    inc     ebx
    cmp     bx, [edi.wNumMemWindows]
    jl      start_1
    mov     eax, CR_DEVICE_NOT_THERE
    jmp     DoConfigStartDone

@@:
    ;
    ; Found a 16meg window.  Which one is it?
    ; We should always find nv first and fb second--this is the order in the PCI config
    ; BUT -- we won't rely on this order.
        ; The config manager doesn't always return attrib = 5 (prefetchable) for fb, although this is set in PCI space,
        ; so we won't depend on it. Problem with win98 beta only? Maybe we can rely on this.
        ; We will test which window is which by reading some nv register in InitMapping (in the resource manager).
;    cmp     [edi.wMemAttrib][ebx*2], 0005h
    mov     eax, [edi.dMemBase][ebx*4]
;    je      @F
    mov     nvPhys, eax                ; nv has attrib of 1
    jmp     short start_2
;@@:
;    mov     fbPhys, eax                ; fb has attrib of 5 (PF)

; 32 or 128MB window -- must be fb
found_fb:
    mov     eax, [edi.dMemBase][ebx*4]
    mov     fbPhys, eax                ; fb has attrib of 5 (PF)
    mov     eax, [edi.dMemLength][ebx*4]
    mov     fbLength, eax

start_2:
    ;
    ; Find the next nv window
    ;
    inc     ebx
    cmp     bx, [edi.wNumMemWindows]    ; at end?
    jl      @F
    mov     eax, CR_DEVICE_NOT_THERE    ; fail
    jmp     DoConfigStartDone

@@:
    cmp     [edi.dMemLength][ebx*4], 08000000h      ; NV10
    je      @f
    cmp     [edi.dMemLength][ebx*4], 04000000h      ; NV20
    je      @f
    cmp     [edi.dMemLength][ebx*4], 02000000h      ; NV5
    je      @f
    cmp     [edi.dMemLength][ebx*4], 01000000h      ; NV4
    jne     start_2
    ;
    ; Found another 16/32 meg window.  Which one is it?
    ;
@@:
; Don't count on attrib = 5!
;    cmp     [edi.wMemAttrib][ebx*2], 0005h
    mov     eax, [edi.dMemBase][ebx*4]
;    je      @F
;       jne             @f                                                      ; yes, it must be fb
;    mov     nvPhys, eax                ; nv has attrib of 1
;    jmp     short start_3
    cmp     fbPhys, 0                   ; did we find fb already? (unlikely)
    je      @f
    mov     nvPhys, eax                 ; already have fb, must be nv
    jmp     start_3
@@:
    mov     fbPhys, eax
    mov     eax, [edi.dMemLength][ebx*4]
    mov     fbLength, eax

start_3:
    ;
    ; We now have our two memory windows.  Let's look for the IRQ.
    ;
    cmp     [edi.wNumIRQs], 1
    je      @F
    ; If none, go to PCI space and find it. We can do this in InitMapping, after nvAddr is mapped
    ;
;    mov     eax, CR_DEVICE_NOT_THERE    ; more than one irq?  ooops.
;       jmp             MiniVDD_PnP_Done
@@:
    xor     eax, eax
    mov     al, [edi.bIRQRegisters][0]
    mov     nvIRQ, eax

;       check that we got something (shouldn't ever be 0 unless PCI error)
    mov     eax, CR_DEVICE_NOT_THERE    ; assume failure
    cmp             nvPhys, 0
    jz              DoConfigStartDone
    cmp             fbPhys, 0
    jz              DoConfigStartDone
;   just getting the addresses is enough for now
;       cmp             _nvIRQ, 0
;       jz              DoConfigStartDone

;
;       Map the physical addresses to linear addresses and install interrupt
;       Addresses should be in correct order, but we'll check in InitMapping.
map_config:
    push    ebx
    push    ecx
    push    edx
    push    edi

    mov     edx, nvIRQ
    mov     ecx, fbPhys
    mov     ebx, nvPhys                                     ; pass physical config to RM
    ; Before we initialize in the RM, Lets pass in the Bus, Device and Function numbers along with the IRQ.
    ; This will be helpful later when we may need to turn on the device.
    ; This function will fill edx with the PCI bus, device and function info along with the IRQ.
    call    GetBusDeviceAndFunctionNumber

    mov     eax, fbLength
    shr     eax, 16
    or      ecx, eax                    ; put the upper word of the length (ie # of 64k blocks) in the lower word
    push    esi
    xor     esi, esi

    mov     esi, offset callrm_struct
    mov     dword ptr [esi].minivdd_RM_Parameter_Struct.callrm_device_handle, 2
    mov     dword ptr [esi].minivdd_RM_Parameter_Struct.callrm_modechange_callback, 0
    mov     dword ptr [esi].minivdd_RM_Parameter_Struct.callrm_irq_bus, edx
    mov     dword ptr [esi].minivdd_RM_Parameter_Struct.callrm_fbphys, ecx
    mov     dword ptr [esi].minivdd_RM_Parameter_Struct.callrm_nvphys, ebx
    lea     eax, szLocalDisplayPath
    mov     dword ptr [esi].minivdd_RM_Parameter_Struct.callrm_registry_path, eax
    mov     eax, NVRM_API_INIT                      ; load up the function number
    mov     ebx, DEFAULT_PRIMARY_HDEV
    call    CallRM                                  ; go to RM's API procedure
                                                    ; do mapping to logical addresses and installing interrupt
    pop     esi
    mov     nvAddr, ebx                 ; return with logical address to NV
    mov     hDev, ecx                   ; and a RM handle to the device.

    .IF     (eax == RM_OK)

        ; save off all these values for this devnode
        .if hDev == 1
          mov   esi, offset device1_instance
        .elseif hDev == 2
          mov   esi, offset device2_instance
        .elseif hDev == 3
          mov   esi, offset device3_instance
        .elseif hDev == 4
          mov   esi, offset device4_instance
        .elseif hDev == 5
          mov   esi, offset device5_instance
        .elseif hDev == 6
          mov   esi, offset device6_instance
        .elseif hDev == 7
          mov   esi, offset device7_instance
        .elseif hDev == 8
          mov   esi, offset device8_instance
        .else
          ; Too many devices !
          int 3h
        .endif

        mov     eax, devNode
        mov     dword ptr [esi].minivdd_instance_Struct.instance_devNode, eax

        mov     eax, nvAddr
        mov     dword ptr [esi].minivdd_instance_Struct.instance_nvAddr, eax
        mov     eax, nvPhys
        mov     dword ptr [esi].minivdd_instance_Struct.instance_nvPhys, eax
        mov     eax, fbPhys
        mov     dword ptr [esi].minivdd_instance_Struct.instance_fbPhys, eax
        mov     eax, fbLength
        mov     dword ptr [esi].minivdd_instance_Struct.instance_fbLength, eax
        mov     eax, nvIRQ
        mov     dword ptr [esi].minivdd_instance_Struct.instance_nvIRQ, eax
        mov     eax, hDev
        mov     dword ptr [esi].minivdd_instance_Struct.instance_hDev, eax

        mov     eax, CR_SUCCESS

    .ENDIF

    pop     edi
    pop             edx
    pop             ecx
    pop             ebx


;       end up here after success or fail
DoConfigStartDone:
    add     esp, SIZE Config_Buff_s                 ; adjust stack
    cmp     eax, CR_SUCCESS
    je      DoConfigStartExit

DoConfigStartError:
    Debug_Out "MiniVDD:  MiniVDD PnP_New_Devnode failed"
    stc

DoConfigStartExit:
    ret

EndProc DoConfigStart

;******************************************************************************
;
;   MiniVDD_PnP_New_DevNode
;
;   DESCRIPTION:
;       Handles system control calls for PnP_NEW_DEVNODE.  This routine
;       allocates the reference data for the adapter, and registers as the
;       driver for the devnode.
;
;   ENTRY:
;       EBX = Devnode handle
;       EDX = Subfunction (should always be LOAD_DRIVER)
;
;   EXIT:
;       EAX = CR_RESULT
;
;   USES:
;       Can use all registers and flags
;
;==============================================================================

BeginProc MiniVDD_PnP_New_DevNode

        cmp     edx, DLVXD_LOAD_DRIVER  ; Q: Is this the driver?
        jne     SSND_Error              ;    N: Strange!!!

;       It seems CM_Register_Device_Driver causes a problem in the Win95 VDD. The VDD won't do the VESA DDC call (4F15).
;       Avoid doing it (CM_Register_Device_Driver) in Win95.

;   Well. It does not work on Win98 also! So Just do it the old way. The code to register for
;   config manager messages is left here commented out. Maybe someday Microsoft will fix this
;   and we can do it the documented way :-)

    VMMcall     Get_VMM_Version
    .IF (!(carry?) && (ax == 040ah))
       ; This is win98. Register to get config messages.
       VxDcall _CONFIGMG_Register_Device_Driver, <ebx, OFFSET32 MiniVDD_Config_Handler, 0, CM_REGISTER_DEVICE_DRIVER_DISABLEABLE OR CM_REGISTER_DEVICE_DRIVER_REMOVABLE>
           .ERRNZ       CR_SUCCESS
           test eax, eax
           jnz  SSND_Couldnt_Reg_Driver

       ; Register succeeded.
    .ENDIF

    ; Just do the init here for both win95 and win98.
    ; On win98, eventhough we get the CONFIG_START message, we get it multiple times
    ; for each devNode. To avoid hassles, just do the handling here and ignore the CONFIG_START
    ; messages.
    call DoConfigStart
    cmp eax, CR_SUCCESS
    jne SSND_Error
    jmp MiniVDD_new_devnode_Exit

;   Unable to register driver.
SSND_Couldnt_Reg_Driver:
        Debug_Out "MiniVDD:  Register device driver failed for devnode #EDI"

SSND_Error:
        Debug_Out "MiniVDD:  MiniVDD PnP_New_Devnode failed"
        mov     eax, CR_FAILURE
        stc
MiniVDD_new_devnode_Exit:
        ret

EndProc MiniVDD_PnP_New_Devnode

;******************************************************************************
;
;   MiniVDD_Config_Handler
;
;   DESCRIPTION:
;       This is the plug and play driver entry point for the MiniVDD.
;       This routine is called by the config manager to notify this driver
;       of configuration related actions.
;
;   THIS PROC IS NOT USED NOW. To enable this procedure, uncomment the code
;   to register for config manager messages in MiniVDD_PnP_New_Devnode.
;
;   ENTRY:
;       cfFuncName = The function to perform.
;       sbfSubFuncName = The subfunction to perform.
;       dnToDevNode = Handle of the devnode being called.
;       dnAboutDevNode = Handle of the subject of the event.
;       ulFlags = Flags value.
;
;   EXIT:
;       EAX = CR_RESULT
;
;   USES:
;       EAX, ECX, EDX
;
;==============================================================================

BeginProc MiniVDD_Config_Handler, CCALL

ArgVar  cfFuncName, DWORD
ArgVar  scfSubFuncName, DWORD
ArgVar  dnDevNode, DWORD
ArgVar  dwRefData, DWORD
ArgVar  ulFlags, DWORD

        EnterProc
        push    ebx
        push    esi
        push    edi

        .IF ([cfFuncName] == CONFIG_FILTER)

           ;> Filter logical configurations for controller.
           ;> This is called before start and may not be required.

           mov eax, CR_SUCCESS

        .ELSEIF ([cfFuncName] == CONFIG_START)

           Debug_Out "MiniVDD:  PnP Start"
       ; We should called twice with CONFIG_START. Once with a subfunction of CONFIG_START_FIRST_START
       ; and once with a subfunction of CONFIG_START_DYNAMIC_START.
       ; But both times we get CONFIG_START_FIRST_START. So the handling of this message is already
       ; done in pnp_new_devnode.
       mov eax, CR_SUCCESS

        .ELSEIF ([cfFuncName] == CONFIG_STOP)

       Debug_Out "MiniVDD:  PnP Stop"
       ; need to add code to handle this.
       mov eax, CR_SUCCESS

        .ELSEIF ([cfFuncName] == CONFIG_TEST)

           Debug_Out "MiniVDD:  PnP Test"
           mov  eax, CR_SUCCESS         ; Secondary device can be removed.

        .ELSEIF ([cfFuncName] == CONFIG_TEST_SUCCEEDED)

           Debug_Out "MiniVDD:  PnP Test succeeded"
       mov ebx, dnDevNode
       call DoConfigRemove

        .ELSEIF ([cfFuncName] == CONFIG_REMOVE)

       Debug_Out "MiniVDD:  PnP Remove"
           ;> The controller devnode is being removed, this driver must stop
           ;> using the allocated configuration.  Any allocated data for this
           ;> devnode should be freed.  If the driver is dynamically loaded it
           ;> will be unloaded by the config manager.  This driver will not be
           ;> called again after this call.

           ; If the user removes the device from the registry via the Device Manager,
           ; and we are the primary display, we can't just unload. We should keep displaying and the Config Manager should
           ; take care of the registry and ask if we want to restart.
       ;        call    _rmConfigStop
           ;VMMcall _HeapFree, <dwRefData, 0>
       ;        jmp     MiniVDDPnP_Success
       ;        mov     eax, CR_REMOVE_VETOED           ; if we are primary display, we can't be removed now
       ;        jmp MiniVDDPnP_Exit

       ; need to add code to handle this.
           mov  eax, CR_FAILURE         ; don't allow removal

    .ELSEIF ([cfFuncName] == CONFIG_PRESHUTDOWN)
       Debug_Out "MiniVDD:  PnP PreShutdown"
       ; need to add code to handle this.
       mov eax, CR_SUCCESS

    .ELSE
       mov eax, CR_DEFAULT

    .ENDIF

        .ERRNZ CR_SUCCESS

; Exit with eax = status
        pop     edi
        pop     esi
        pop     ebx
        LeaveProc
        Return

EndProc MiniVDD_Config_Handler

;******************************************************************************
;
;   MiniVDD_Sys_VM_Terminate
;
;   DESCRIPTION:        Windows is shutting down. We set a mode 3 to prepare for the Windows shutting down message
;
;   ENTRY:
;
;   EXIT:
;       EAX = CR_RESULT
;
;   USES:
;       EAX, ECX, EDX
;
;==============================================================================

public  MiniVDD_Sys_VM_Terminate
BeginProc MiniVDD_Sys_VM_Terminate
;We are leaving Windows and going to text mode
;Entry:
;       EBX contains the VM handle of the Windows VM.
;Exit:

;               Nothing to do?
;               Tell the SysVM we did it successfully then
                clc
                ret
EndProc MiniVDD_Sys_VM_Terminate
;

;
subttl          Display Driver Is Being Disabled Notification
page +
public  MiniVDD_DisplayDriverDisabling
BeginProc       MiniVDD_DisplayDriverDisabling, RARE
;
;The display driver is in its Disable routine and is about to set the
;hardware back into VGA text mode.  Since this could either mean that
;the Windows session is ending or that some Windows application is switching
;to a VGA mode to display something full screen (such as MediaPlayer), we
;need to disable our MiniVDD_RestoreRegisters code because we're liable
;to restore a Windows HiRes state when we shouldn't!  Thus, clear the
;DisplayEnabledFlag to prevent this:
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_DisplayDriverDisabling", DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG

MDDDExit:
IFDEF DEBUG_LOG
        pushf
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "\n\r", DEBLEVELMAX
                pop     eax
        .endif
        popf
ENDIF ; DEBUG_LOG
        ret                             ;
EndProc MiniVDD_DisplayDriverDisabling
;

subttl          Register Display Driver Dependent Data
page +
public  MiniVDD_RegisterDisplayDriver
BeginProc MiniVDD_RegisterDisplayDriver, RARE
;
;Oft-times, the display driver must set flags whenever it is doing
;certain things to a hardware BLTer (such as "I'm in the middle of
;transferring a source bitmap").  This routine is called to allow
;this mini-VDD to get data (usually containing addresses inside the
;display driver's Data segment) directly from the display driver.
;We can also save appropriately needed states here.
;
;       The only client registers that are reserved (and cannot be used
;to pass data in) are EAX (which contains the function code which the
;display driver uses to call the "main" VDD) and EBX (which contains the
;Windows VM handle).  When we get called by the "main" VDD, we'll be
;passed a flag in Client_AL which will be set to non-zero if the VFLATD
;VxD is being used for banked support or zero if VFLATD is NOT involved in
;this session.
;
;NVIDIA: we use this function to pass the device handle to the resource manager. If running multiple devices, we need
;       to know which device (from the display driver's point of view), is associated with which address (the RM's
;       point of view). The miniVDD is the link between these entities.
;Entry:
;       EBP --> the Client Register Structure (documented in VMM.INC)
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_RegisterDisplayDriver", DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG

MRDDExit:

;
        ; This is no longer used.
        ret                             ;
EndProc MiniVDD_RegisterDisplayDriver


;******************************************************************************
;       Any use for this function?
public  MiniVDD_GetTotalVRAMsize
BeginProc       MiniVDD_GetTotalVRAMsize, DOSVM
        push    eax
        mov     ecx,800000h             ; default = 8M
        REG_RD32(NV_PFB_BOOT_0)
        test    ax,40h
        jnz     @f
        shr     ecx,1                   ; 4M?
        test    ax,4
        jnz     @f
        shr     ecx,1                   ; must be 2M
@@:     mov     TotalMemorySize,ecx     ; probably won't use this
        stc                             ;
        pop     eax

                ret
EndProc         MiniVDD_GetTotalVRAMsize

;******************************************************************************
;
;   MiniVDD_GetAdpaterPowerState
;
;   DESCRIPTION:        ACPI power capabilities
;
;   ENTRY:  Device Node (stack)
;
;   EXIT:
;       EAX = Capabilities (bit 0-3 set if D0-D3 supported)
;
;==============================================================================
public  MiniVdd_GetAdapterPowerStateCaps
BeginProc MiniVdd_GetAdapterPowerStateCaps, RARE
;
;Entry:
;       DevNode.
;Exit:
;       The CAPS of adapter
        ArgVar  DeviceNode, DWORD               ;message number
        EnterProc
        cmp     OSVersion,VERS_MILLENNIUM       ;Win98 or Millennium?
        jb      OSVer_Win98
        mov     eax, (CM_POWERSTATE_D0 or CM_POWERSTATE_D3 or CM_POWERSTATE_D1 or CM_POWERSTATE_HIBERNATE)
        jmp     GAPSC_Done
OSVer_Win98:
        mov     eax, (CM_POWERSTATE_D0 or CM_POWERSTATE_D3 or CM_POWERSTATE_D1)
GAPSC_Done:
        LeaveProc
        Return
EndProc MiniVdd_GetAdapterPowerStateCaps

subttl          Set adapter Power State
page +

;******************************************************************************
;
;   MiniVDD_SetAdpaterPowerState
;
;   DESCRIPTION:        ACPI power state transition
;
;   ENTRY:  Device Node, Power State (stack)
;
;   EXIT:
;       EAX = CR_RESULT
;
;==============================================================================
public  MiniVdd_SetAdapterPowerState
BeginProc MiniVdd_SetAdapterPowerState, RARE
;Entry:
;       DevNode.
;       PowerState.
;Exit:
;       CR_DEFAULT  - OS should POST the device
;   CR_SUCCESS  - OS should do nothing
        ArgVar  DeviceNode, DWORD
        ArgVar  PowerState, DWORD
        ArgVar  DevInstance, DWORD

        EnterProc
        pushad
; Find the device instance and the current state
        mov     ebx,DeviceNode
        call    findDevNode
        jc      SAPS_Ret    ; find it?

        mov     ebx, [esi].minivdd_instance_Struct.instance_hDev
        mov     DevInstance,ebx
        mov     ebx, [esi].minivdd_instance_Struct.instance_ACPI_state
        mov     ebx,PowerState  ; requested state
;
; Check for restoring to D0, if not we must be going to D1, D2, or D3.
;
; state n = bit n
        test    ebx,CM_POWERSTATE_D3
        jnz     SAPS_D3
        test    ebx,CM_POWERSTATE_D2
        jnz     SAPS_D2
        test    ebx,CM_POWERSTATE_D1
        jnz     SAPS_D1
        test    ebx,CM_POWERSTATE_HIBERNATE
        jnz     SAPS_D3

;   if we are going to state 3, we shut down.
;   if we are coming back to state 0, we must start up.
SAPS_D0:
        mov     ebx,PowerState
        cmp     [esi].minivdd_instance_Struct.instance_ACPI_state, ebx
        je      SAPS_Ret
        mov     [esi].minivdd_instance_Struct.instance_ACPI_state, ebx   ; save new state
;       call RM to start up (use API)
        mov     ebx,DevInstance     ; device instance
        mov     eax, NVRM_API_POWER_UP
        call    CallRM
        jmp     SAPS_Ret

SAPS_D3:
        mov     ebx,PowerState
        cmp     [esi].minivdd_instance_Struct.instance_ACPI_state, ebx
        je      SAPS_Ret
        mov     [esi].minivdd_instance_Struct.instance_ACPI_state, ebx   ; save new state
;       call RM to shut down (use API)
        mov     ebx,DevInstance     ; device instance
        mov     eax, NVRM_API_POWER_DOWN
        call    CallRM
        jmp     SAPS_Ret

SAPS_D2:
;   not supported
if 0
        mov     ebx,PowerState
        cmp     [esi].minivdd_instance_Struct.instance_ACPI_state, ebx
        je      SAPS_Ret
        mov     [esi].minivdd_instance_Struct.instance_ACPI_state, ebx   ; save new state
;       call RM to shut down (use API)
        mov     ebx,DevInstance     ; device instance
        mov     eax, NVRM_API_POWER_D2
        call    CallRM
endif
        jmp     SAPS_Ret

SAPS_D1:
        mov     ebx,PowerState
        cmp     [esi].minivdd_instance_Struct.instance_ACPI_state, ebx
        je      SAPS_Ret
        mov     [esi].minivdd_instance_Struct.instance_ACPI_state, ebx   ; save new state
;       call RM to shut down (use API)
        mov     ebx,DevInstance     ; device instance
        mov     eax, NVRM_API_POWER_D1
        call    CallRM

SAPS_Ret:
        popad
        mov     eax,CR_DEFAULT
        LeaveProc
        Return
EndProc MiniVdd_SetAdapterPowerState
;
; Call the resource manager.
;
BeginProc       CALLRM
;               push everything onto stack so we have the top of a client reg struct. (see VMM.H)
        push    esi
        mov     esi, offset callrm_rmusrapi
        mov     dword ptr [esi].minivdd_CALLRM_rmusrapi_Struct.rmusrapi_function, eax
	dec     ebx
        mov     dword ptr [esi].minivdd_CALLRM_rmusrapi_Struct.rmusrapi_device, ebx
        mov     eax,esi
        pop     esi

        push    eax
        push    ecx
        push    edx
        push    ebx
        push    eax                             ; res0, documented as "ESP at pushall"
        push    ebp
        push    esi
        push    edi
        mov     ebp, esp                ; point ebp to client reg struct
        call    DWORD PTR ResManAPI
        pop     edi
        pop     esi
        pop     ebp
        pop     eax                             ; res0
        pop     ebx
        pop     edx
        pop     ecx
        pop     eax
        ret
EndProc CALLRM

;
VxD_LOCKED_CODE_ENDS
;
;
end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vdd\common\colorctl.c ===
#ifndef NV3_HW
#define COMPILEDINVDD
#else
#undef COMPILEDINVDD
#endif 

#ifdef COMPILEDINVDD


#ifdef NV4_HW
#define NV4
#endif
#ifdef NV10_HW
#define NV4
#endif


#ifdef DEBUG
#define TIMEOUT_DMA_XFER 500
#else
#define TIMEOUT_DMA_XFER 42
#endif

// ------------------------------------------------------------------------------------------
// YUV422ColourControl
//      Simulates colour controls on YUV422 surfaces.
//      Returns TRUE if success

#ifdef COMPILEDINVDD //------------------------------------------------------
#define NV_WIN_DEVICE                            0x00002002

#define NV4
#include "windows.h"
#include "ddraw.h"
#include "Ddrawp.h"
#include "ddrawi.h"
// #include "nvPusher.h"
#include "ddmini.h"
#include "dvp.h"
#include "dmemmgr.h"
//  vdd specific MS includes
#include "minivdd.h"
#include "ddkmmini.h"

#include "vmm.h"

// NV includes
#include "nvwin32.h"
#include "nvhw.h"
#include <nv_ref.h>
#include "nvrmr0api.h"

#include "nvddobj.h"
#include "surfaces.h"
#include "timing.h"


extern vpSurfaces             MySurfaces;

extern DWORD vwin32WaitSingleObject( DWORD, DWORD, DWORD );
extern DWORD vwin32ResetWin32Event(DWORD);
extern DWORD vwin32TimeSliceSleep(DWORD);

// requires just the handle passed in

//#undef POLLINGMODE
#define POLLINGMODE

#ifdef POLLINGMODE
#define R0SLEEP(a)        \
{                         \
     _asm { \
    emms \
   }; \
vwin32TimeSliceSleep(a);   \
}
#endif


#define PDRIVERDATA (MySurfaces.pDriverData)

#define WAIT_FOR_FIFO(n) { \
        while (videoFreeCount < n) { \
            NvRmR0Interrupt (((GLOBALDATA*)(MySurfaces.pDriverData))->ROOTHANDLE, NV_WIN_DEVICE); \
            videoFreeCount = NvGetFreeCount(npDevVideo, NV_DD_SPARE); \
        } \
        videoFreeCount -= n; }

#ifdef POLLINGMODE
#define RESET_OCC_EVENT { \
       while(pPioColourControlEventNotifier[1].status == NV_IN_PROGRESS)  { \
             NvRmR0Interrupt (((GLOBALDATA*)(MySurfaces.pDriverData))->ROOTHANDLE, NV_WIN_DEVICE); \
             R0SLEEP(0)  \
       } \
        pPioColourControlEventNotifier[1].status = NV_IN_PROGRESS; }

#else
#define RESET_OCC_EVENT { \
   _asm { \
    emms \
   }; \
  (vwin32ResetWin32Event((U032)lpProcInfo->hOCCSyncEvent0)); \
  }
#endif

#ifdef POLLINGMODE

#if 1
#define  COLORCTL_039_NOTIFYVALUE     NV039_BUFFER_NOTIFY_WRITE_ONLY
#define WAIT_FOR_OCC_EVENT  while(pPioColourControlEventNotifier[1].status == NV_IN_PROGRESS)  { \
     NvRmR0Interrupt (((GLOBALDATA*)(MySurfaces.pDriverData))->ROOTHANDLE, NV_WIN_DEVICE); \
     R0SLEEP(0)  \
} 
#else
#define  COLORCTL_039_NOTIFYVALUE     NV039_BUFFER_NOTIFY_WRITE_ONLY
#define WAIT_FOR_OCC_EVENT  while(pPioColourControlEventNotifier[1].status == NV_IN_PROGRESS)  { \
      \
} 
#endif

#else
#define  COLORCTL_039_NOTIFYVALUE     NV039_BUFFER_NOTIFY_WRITE_THEN_AWAKEN
#define WAIT_FOR_OCC_EVENT { \
  NvRmR0Interrupt(((GLOBALDATA*)(MySurfaces.pDriverData))->ROOTHANDLE,NV_WIN_DEVICE); \
   _asm { \
    emms \
   }; \
}
#endif


//MarkTiming (WAITOCCCOLORCTL, vwin32WaitSingleObject((U032)lpProcInfo->hOCCSyncEvent0,TIMEOUT_DMA_XFER,0), 1); 
  





BOOL YUV422ColourControl(DWORD  dwPitch, DWORD dwWidth, DWORD dwHeight, DWORD dwSrcOffset, DWORD dwDstOffset, LPDDCOLORCONTROL lpDDCC)
#else  //COMPILEDINVDD ------------------------------------------------------

extern DWORD WaitForIdle(BOOL bWait, BOOL bZeroFreeCount, BOOL bUseEvent);

#define PDRIVERDATA (pDriverData)
#define WAIT_FOR_FIFO(n) { \
        while (videoFreeCount < n) { \
            videoFreeCount = NvGetFreeCount(npDevVideo, NV_DD_SPARE); \
            if (videoFreeCount < n) NV_SLEEP; \
        } \
        videoFreeCount -= n; }
#define RESET_OCC_EVENT (ResetEvent((HANDLE)lpProcInfo->hOCCSyncEvent3))
#define WAIT_FOR_OCC_EVENT (WaitForSingleObject((HANDLE)lpProcInfo->hOCCSyncEvent3, TIMEOUT_DMA_XFER))

BOOL __stdcall YUV422ColourControl(LPDDRAWI_DDRAWSURFACE_GBL lpGbl, DWORD dwWidth, DWORD dwHeight, DWORD dwSrcOffset, DWORD dwDstOffset, LPDDCOLORCONTROL lpDDCC)

#endif //COMPILEDINVDD ------------------------------------------------------
{

NvNotification *pPioColourControlEventNotifier = PDRIVERDATA->pPioColourControlEventNotifierFlat;
#ifndef COMPILEDINVDD
DDPIXELFORMAT *lpPixelFormat = &lpGbl->ddpfSurface;
#endif //COMPILEDINVDD
DWORD overlayFourCC = 0;
BOOL bOverContrast;
DWORD dwContrast, dwBrightness, cnt, brt;
short hue, sat;

FAST Nv3ChannelPio *npDevVideo = (Nv3ChannelPio *)PDRIVERDATA->NvDevVideoFlatPio;
FAST long videoFreeCount = NvGetFreeCount(npDevVideo, NV_DD_SPARE);
DWORD dwYPhase, dwSrcPitch, dwDstPitch;
BOOL doContrastBlt, doLuma, doChroma;
DWORD dwChromaOffset;
LPPROCESSINFO lpProcInfo = NULL;

#ifndef COMPILEDINVDD
    lpProcInfo = pmGetProcess(GetCurrentProcessId());    
#endif
    
#ifdef POLLINGMODE
    if (!PDRIVERDATA->vpp.regOverlayColourControlEnable ||
        !PDRIVERDATA->vpp.fpOverlayShadow)
#else
    if (!PDRIVERDATA->vpp.regOverlayColourControlEnable ||
        !PDRIVERDATA->vpp.fpOverlayShadow ||
        !lpProcInfo ||
        !lpProcInfo->hOCCSyncEvent3)
#endif
        return FALSE;

#ifdef COMPILEDINVDD
    if( (PDRIVERDATA->vpp.regRing0ColourCtlInterlockFlags & 0x01 ) != 0x01) {
      // if bit zero is zero this means we should simply return... ie not run
      return 0;
    }
    
    // note there is an assumption here that there is no other way to exit this routine between
    // here and the final return!!!!!!
    // set bit 1 meaning we're now in operation
    PDRIVERDATA->vpp.regRing0ColourCtlInterlockFlags = PDRIVERDATA->vpp.regRing0ColourCtlInterlockFlags | 0x02;
#endif   

    MarkTiming(ENTERCOLORCTL,dwSrcOffset + MySurfaces.pDriverData->BaseAddress,0);
        
    if (lpDDCC->lContrast > 0xFF) {
        cnt = lpDDCC->lContrast >> 1;
        bOverContrast = TRUE;
    } else {
        cnt = lpDDCC->lContrast;
        bOverContrast = FALSE;
    }
    if(lpDDCC->lBrightness  < 0 ) {
      brt = -lpDDCC->lBrightness;
    } else {
      brt = lpDDCC->lBrightness;
    }
    hue = (short) lpDDCC->lHue;
    sat = (short) lpDDCC->lSaturation;

#ifndef COMPILEDINVDD
    dwSrcPitch = lpGbl->lPitch;
#else
    dwSrcPitch = dwPitch;
#endif
    
#ifndef COMPILEDINVDD
    if (lpPixelFormat->dwFlags & DDPF_FOURCC) {
        overlayFourCC = lpPixelFormat->dwFourCC;
        if (overlayFourCC == MAKEFOURCC('U','Y','V','Y') ||
            overlayFourCC == MAKEFOURCC('U','Y','N','V')) {
            dwContrast   = (cnt << 8) | (cnt << 24) | 0x00FF00FF;
            dwBrightness = brt | (brt << 8) | (brt << 16) | (brt << 24);
            dwYPhase = 1;
        } else {
            dwContrast   = cnt | (cnt << 16) | 0xFF00FF00;
            dwBrightness = brt | (brt << 8) | (brt << 16) | (brt << 24);
            dwYPhase = 0;
        }
        if (overlayFourCC == MAKEFOURCC('Y','V','1','2') ||
            overlayFourCC == MAKEFOURCC('Y','V','U','9') ||
            overlayFourCC == MAKEFOURCC('I','F','0','9') ||
            overlayFourCC == MAKEFOURCC('I','V','3','1') ||
            overlayFourCC == MAKEFOURCC('I','V','3','2')) {
            dwSrcPitch <<= 1;
            WaitForIdle(TRUE, FALSE, TRUE);   // wait for prior ConvertOverlay to finish
        }
    } else {
        dwContrast   = 0xFFFFFFFF;
        dwBrightness = 0;
        bOverContrast = FALSE;
        dwYPhase = 0;
    }
#else
    dwContrast   = (cnt << 8) | (cnt << 24) | 0x00FF00FF;
    dwBrightness = brt | (brt << 8) | (brt << 16) | (brt << 24);
    // dwYPhase is used to act on information about which field we're on in interleaved surfaces
    // So, we need to program it appropriately
    dwYPhase = 1;
#endif //COMPILEDINVDD

    dwDstPitch = dwSrcPitch >> 1;
    dwWidth = (dwWidth + 1) & ~1;      // width must be even
    //if (dwWidth > dwDstPitch)
    //   dwWidth -= 2;

    doContrastBlt = (dwContrast != 0xFFFFFFFF);
    doLuma        = (dwBrightness != 0 || bOverContrast);
    doChroma      = (hue != 0 || sat != 0x100);

#ifndef COMPILEDINVDD
    NV_DD_DMA_PUSHER_SYNC();
#else
    // perhaps should do something here to sync up the dma pushers.... ?
#endif
    
    
    if (pPioColourControlEventNotifier[1].status == NV_IN_PROGRESS)
        WAIT_FOR_OCC_EVENT;
    
    if (doChroma) {
        // Apply a chroma vector scale and rotation
        // [U'] = [ sat*cos(hue)  sat*sin(hue)] [U]
        // [V']   [-sat*sin(hue)  sat*cos(hue)] [V]
        NvNotification *NvPioBufferNotifier = PDRIVERDATA->pDmaBufferNotifierFlat;
        short sinhue, coshue;
        __int64 c1, c2;
        static const __int64 bOneTwentyEight = 0x8080808080808080;
        static const __int64 evenMask        = 0x00FF00FF00FF00FF;
        static const __int64 oddMask         = 0xFF00FF00FF00FF00;
        static const __int64 zero            = 0;
        DWORD dwAdjWidth, j;
        LPBYTE qPtr;
        // sin table normalized to 256
        
        static const short sintable[91] = {  0,  4,  9, 13, 18, 22, 27, 31,
                                            36, 40, 44, 49, 53, 58, 62, 66,
                                            71, 75, 79, 83, 88, 92, 96,100,
                                           104,108,112,116,120,124,128,132,
                                           136,139,143,147,150,154,158,161,
                                           165,168,171,175,178,181,184,187,
                                           190,193,196,199,202,204,207,210,
                                           212,215,217,219,222,224,226,228,
                                           230,232,234,236,237,239,241,242,
                                           243,245,246,247,248,249,250,251,
                                           252,253,254,254,255,255,255,256,
                                           256,256,256 };

        dwChromaOffset = dwDstPitch * dwHeight;

        // move chroma data to system memory
        RESET_OCC_EVENT;
        WAIT_FOR_FIFO(48);

        pPioColourControlEventNotifier[1].status = NV_IN_PROGRESS;

        npDevVideo->dDrawSpare.SetObject = NV_VPP_V2OSH_FORMAT_IID;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.SetContextDmaNotifies = NV_DD_PIO_COLOUR_CONTROL_EVENT_NOTIFIER;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.SetContextDmaBufferIn = NV_DD_PIO_CONTEXT_DMA_FROM_VIDEO_MEMORY;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.SetContextDmaBufferOut = NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_OVERLAY_SHADOW;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.OffsetIn     = dwSrcOffset + (dwYPhase ^ 1);
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.OffsetOut    = dwChromaOffset;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.PitchOut     = dwDstPitch;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.LineLengthIn = dwWidth;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.LineCount    = dwHeight;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.PitchIn      = dwSrcPitch;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.Format       = 0x102;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.BufferNotify = COLORCTL_039_NOTIFYVALUE;

        // coefficient calculations
        // possible MMX multiply overflow later, so halve the coefficients now
        // and double the result later with saturation
        if (lpDDCC->lHue <= 90) {
            sinhue = ((long)sat * sintable[hue]) >> 9;
            coshue = ((long)sat * sintable[90 - hue]) >> 9;
        } else if (lpDDCC->lHue <= 180) {
            sinhue = ((long)sat * sintable[180 - hue]) >> 9;
            coshue = ((long)sat * -sintable[hue - 90]) >> 9;
        } else if (lpDDCC->lHue <= 270) {
            sinhue = ((long)sat * -sintable[hue - 180]) >> 9;
            coshue = ((long)sat * -sintable[270 - hue]) >> 9;
        } else {
            sinhue = ((long)sat * -sintable[360 - hue]) >> 9;
            coshue = ((long)sat * sintable[hue - 270]) >> 9;
        }

        // c1 = sat*cos(hue), sat*cos(hue), sat*cos(hue), sat*cos(hue)
        c1 = (__int64)coshue & 0xFFFF;
        c1 |= c1 << 16;
        c1 |= c1 << 32;
        // c2 = -sat*sin(hue), sat*sin(hue), -sat*sin(hue), sat*sin(hue)
        c2 = (__int64)sinhue & 0xFFFF;
        c2 |= ((__int64)-sinhue & 0xFFFF) << 16;
        c2 |= c2 << 32;

        // init MMX const data
        qPtr       = (LPBYTE) (PDRIVERDATA->vpp.fpOverlayShadow + dwChromaOffset);
        dwAdjWidth = (dwWidth + 7) / 8;
        _asm {
            movq        mm0, zero
            movq        mm1, bOneTwentyEight 
		    }

        // while we are doing some host MMX things, overlap with some luma operations
        // since we are main memory throughput bound, DO NOT overlap with operations that touch main memory
        if (doContrastBlt) {
            WAIT_FOR_FIFO(40);

            /* Trash spare subchannel */
            npDevVideo->dDrawSpare.SetObject = NV_DD_CONTEXT_BETA4;
            npDevVideo->dDrawSpare.nv4ContextBeta.SetBetaFactor = dwContrast;
            npDevVideo->dDrawSpare.SetObject = NV_DD_SURFACES_2D_A8R8G8B8;
            npDevVideo->dDrawSpare.nv4ContextSurfaces2D.SetPitch = (dwSrcPitch << 16) | dwSrcPitch;
            npDevVideo->dDrawSpare.nv4ContextSurfaces2D.SetOffsetSource = dwSrcOffset;
            if (doLuma)
                // more stuff to do later, do this in place
                npDevVideo->dDrawSpare.nv4ContextSurfaces2D.SetOffsetDestin = dwSrcOffset;
            else
                npDevVideo->dDrawSpare.nv4ContextSurfaces2D.SetOffsetDestin = dwDstOffset;
            npDevVideo->dDrawSpare.SetObject = NV_DD_SRCCOPY_PREMULT_A8R8G8B8_IMAGE_BLIT;
            npDevVideo->dDrawSpare.nv4ImageBlit.ControlPointIn = 0;
            npDevVideo->dDrawSpare.nv4ImageBlit.ControlPointOut = 0;
            npDevVideo->dDrawSpare.nv4ImageBlit.Size = (dwHeight << 16) | (dwWidth >> 1);
            PDRIVERDATA->dDrawSpareSubchannelObject = 0;
        }

        if (!doContrastBlt && !doLuma) {
            // luma has not and will not move, do that now
            WAIT_FOR_FIFO(36);

            npDevVideo->dDrawSpare.SetObject = NV_DD_VIDEO_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT;
            npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.OffsetIn     = dwSrcOffset + dwYPhase;
            npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.OffsetOut    = dwDstOffset + dwYPhase;
            npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.PitchOut     = dwSrcPitch;
            npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.LineLengthIn = dwWidth;
            npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.LineCount    = dwHeight;
            npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.PitchIn      = dwSrcPitch;
            npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.Format       = 0x202;
            npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.BufferNotify = 0;
        }

        // wait for chroma to arrive in system memory
        WAIT_FOR_OCC_EVENT;
        //MarkTiming(WAITCHROMAARRIVE,dwSrcOffset + MySurfaces.pDriverData->BaseAddress,10);
        
/*      // commented out because this appears to cause a cache coherency problem (bug in BX?)
        // preload the first 8 scan lines into the cache
        for (j=0; j<8; j++) {
            _asm {
                        mov     esi, qPtr
                        mov     ecx, dwAdjWidth
                        shr     ecx, 2
                preld1: mov     eax, [esi]
                        mov     eax, 0
                        add     esi, 32
                        dec     ecx
                        jnz     preld1
            }
            qPtr += dwDstPitch;
        }
*/
        // do the chroma vector scale and rotation, 2.25 cycles/pixel
        // mm0 = 0
        // mm1 = 128
        // mm2 = sign mask
        // mm3 = data quad / expanded data / result high
        // mm4 = expanded data / result low
        // mm5 = expanded data, UV swapped
        // mm6 = UV swapped quad / expanded swapped data
        // mm7 = work space
        if (PDRIVERDATA->vpp.regOverlayColourControlEnable == 2) {
            // full chroma resolution
            for (j=0; j<dwHeight; j++) {
                _asm {
                            mov         ecx, dwAdjWidth
                            mov         esi, qPtr
                            mov         edi, qPtr
                            mov         ebx, dwDstPitch
                    ;        shl         ebx, 3
                            movq        mm3, [esi]
                            psubb       mm3, mm1
                            movq        mm2, mm0
                            pcmpgtb     mm2, mm3
                            movq        mm4, mm3
                            movq        mm7, mm3
                            punpcklbw   mm4, mm2
                    nextc:  mov         eax, [esi+ebx]  ; U  ; preload cache for next scan line
                            mov         eax, 0          ; V  ; ensure OOE works
                            pmullw      mm4, c1         ; U  ; mm4 = c1 * low(UV)
                            movq        mm6, mm3        ; V  ; mm6 = copy of quad data-128
                            add         esi, 8          ; U  ; next source address
                            psrlq       mm6, 8          ; V  ; mm6 >>= 8
                            pand        mm6, evenMask   ; U  ; mm6 &= 0x00FF00FF00FF00FF
                            psllq       mm7, 8          ; V  ; mm7 <<= 8
                            pand        mm7, oddMask    ; U  ; mm7 &= 0xFF00FF00FF00FF00
                            punpckhbw   mm3, mm2        ; V  ; mm3 = unpacked signed high data
                            pmullw      mm3, c1         ; U  ; mm3 = c1 * high(UV)
                            por         mm6, mm7        ; V  ; mm6 |= mm7, UV are now swapped
                            movq        mm5, mm6        ; U  ; mm5 = quad data with UV swapped
                            movq        mm2, mm0        ; V  ; mm2 = 0
                            add         edi, 8          ; U  ; next destination address
                            pcmpgtb     mm2, mm6        ; V  ; mm2 = sign bits of swapped UV
                            punpcklbw   mm5, mm2        ; U  ; mm5 = unpacked signed low VU data
                            movq        mm7, mm3        ; V  ; move result to mm7 so we can reuse mm3 early
                            movq        mm3, [esi]      ; U  ; mm3 = new data quad
                            punpckhbw   mm6, mm2        ; V  ; mm6 = unpacked signed high VU data
                            pmullw      mm5, c2         ; U  ; mm5 = c2 * low(VU)
                            movq        mm2, mm0        ; V  ; mm2 = 0
                            pmullw      mm6, c2         ; U  ; mm6 = c2 * high(VU)
                            psubb       mm3, mm1        ; V  ; mm3 -= 128
                            paddsw      mm5, mm4        ; U  ; mm5 += mm4
                            paddsw      mm6, mm7        ; V  ; mm6 += mm7
                            dec         ecx             ; U  ; decrement loop count
                            psraw       mm5, 7          ; V  ; downshift result and multiply by 2
                            psraw       mm6, 7          ; U  ; downshift result and multiply by 2
                            pcmpgtb     mm2, mm3        ; V  ; mm2 = sign bits
                            packsswb    mm5, mm6        ; U  ; mm5 = packed(mm5,mm6)
                            paddb       mm5, mm1        ; V  ; mm5 += 128
                            movq        mm7, mm3        ; U  ; mm7 = copy of quad data-128
                            movq        mm4, mm3        ; V  ; mm4 = copy of quad data-128
                            movq        [edi-8], mm5    ; U  ; store data from mm5
                            punpcklbw   mm4, mm2        ; V  ; mm4 = unpacked signed low UV data
                            jnz         nextc
                }
                qPtr += dwDstPitch;
            }
        } else {
            // vertical chroma subsample
            // in this case, ESI is used for source and in-place destination, and EDI is used for next line in destination
            for (j=0; j<dwHeight; j+=2) {
                _asm {
                            mov         ecx, dwAdjWidth
                            mov         esi, qPtr
                            mov         edi, qPtr
                            add         edi, dwDstPitch
                            mov         ebx, dwDstPitch
                            shl         ebx, 1
                    ;        shl         ebx, 3
                            movq        mm3, [esi]
                            psubb       mm3, mm1
                            movq        mm2, mm0
                            pcmpgtb     mm2, mm3
                            movq        mm4, mm3
                            movq        mm7, mm3
                            punpcklbw   mm4, mm2
                    nextc2: mov         eax, [esi+ebx]  ; U  ; preload cache for next scan line
                            mov         eax, 0          ; V  ; ensure OOE works
                            pmullw      mm4, c1         ; U  ; mm4 = c1 * low(UV)
                            movq        mm6, mm3        ; V  ; mm6 = copy of quad data-128
                            add         esi, 8          ; U  ; next source address
                            psrlq       mm6, 8          ; V  ; mm6 >>= 8
                            pand        mm6, evenMask   ; U  ; mm6 &= 0x00FF00FF00FF00FF
                            psllq       mm7, 8          ; V  ; mm7 <<= 8
                            pand        mm7, oddMask    ; U  ; mm7 &= 0xFF00FF00FF00FF00
                            punpckhbw   mm3, mm2        ; V  ; mm3 = unpacked signed high data
                            pmullw      mm3, c1         ; U  ; mm3 = c1 * high(UV)
                            por         mm6, mm7        ; V  ; mm6 |= mm7, UV are now swapped
                            movq        mm5, mm6        ; U  ; mm5 = quad data with UV swapped
                            movq        mm2, mm0        ; V  ; mm2 = 0
                            add         edi, 8          ; U  ; next destination address
                            pcmpgtb     mm2, mm6        ; V  ; mm2 = sign bits of swapped UV
                            movq        mm7, mm3        ; U  ; move result to mm7 so we can reuse mm3 early
                            punpcklbw   mm5, mm2        ; V  ; mm5 = unpacked signed low VU data
                            movq        mm3, [esi]      ; U  ; mm3 = new data quad
                            punpckhbw   mm6, mm2        ; V  ; mm6 = unpacked signed high VU data
                            pmullw      mm5, c2         ; U  ; mm5 = c2 * low(VU)
                            movq        mm2, mm0        ; V  ; mm2 = 0
                            pmullw      mm6, c2         ; U  ; mm6 = c2 * high(VU)
                            psubb       mm3, mm1        ; V  ; mm3 -= 128
                            paddsw      mm5, mm4        ; U  ; mm5 += mm4
                            paddsw      mm6, mm7        ; V  ; mm6 += mm7
                            dec         ecx             ; U  ; decrement loop count
                            psraw       mm5, 7          ; V  ; downshift result and multiply by 2
                            psraw       mm6, 7          ; U  ; downshift result and multiply by 2
                            pcmpgtb     mm2, mm3        ; V  ; mm2 = sign bits
                            packsswb    mm5, mm6        ; U  ; mm5 = packed(mm5,mm6)
                            paddb       mm5, mm1        ; V  ; mm5 += 128
                            movq        mm7, mm3        ; U  ; mm7 = copy of quad data-128
                            movq        mm4, mm3        ; V  ; mm4 = copy of quad data-128
                            movq        [edi-8], mm5    ; U  ; store data from mm5
                            punpcklbw   mm4, mm2        ; V  ; mm4 = unpacked signed low UV data
                            movq        [esi-8], mm5    ; U  ; store same data on next line
                            jnz         nextc2          ; V
                }
                qPtr += dwDstPitch << 1;
            }
        }

        if (!doLuma) {
          // move chroma data to back to video memory
          RESET_OCC_EVENT;
          WAIT_FOR_FIFO(48);
  
          PDRIVERDATA->dDrawSpareSubchannelObject = 0;
          pPioColourControlEventNotifier[1].status = NV_IN_PROGRESS;
  
          npDevVideo->dDrawSpare.SetObject = NV_VPP_OSH2V_FORMAT_IID;
          npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.SetContextDmaNotifies = NV_DD_PIO_COLOUR_CONTROL_EVENT_NOTIFIER;
          npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.SetContextDmaBufferIn = NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_OVERLAY_SHADOW;
          npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.SetContextDmaBufferOut = NV_DD_PIO_CONTEXT_DMA_TO_VIDEO_MEMORY;
          npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.OffsetIn     = dwChromaOffset;
          npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.OffsetOut    = dwDstOffset + (dwYPhase ^ 1);
          npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.PitchOut     = dwSrcPitch;
          npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.LineLengthIn = dwWidth;
          npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.LineCount    = dwHeight;
          npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.PitchIn      = dwDstPitch;
          npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.Format       = 0x201;
          if (!doLuma) {
              npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.BufferNotify = COLORCTL_039_NOTIFYVALUE;
              WAIT_FOR_OCC_EVENT;
              //MarkTiming(WAITCHROMARETURN,dwSrcOffset + MySurfaces.pDriverData->BaseAddress,20);
            
          } else {
              npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.BufferNotify = 0;
          }
        } 
        
    } else if (doContrastBlt) {
        // Contrast Blit, since the hardware can only do multiplies up to one (0xFF),
        // and if the contrast is from 100% to 200%, then divide contrast by 2 and worry
        // about left shift and saturation in the MMX routines below
        WAIT_FOR_FIFO(40);

        /* Trash spare subchannel */
        npDevVideo->dDrawSpare.SetObject = NV_DD_CONTEXT_BETA4;
        npDevVideo->dDrawSpare.nv4ContextBeta.SetBetaFactor = dwContrast;
        npDevVideo->dDrawSpare.SetObject = NV_DD_SURFACES_2D_A8R8G8B8;
        npDevVideo->dDrawSpare.nv4ContextSurfaces2D.SetPitch = (dwSrcPitch << 16) | dwSrcPitch;
        npDevVideo->dDrawSpare.nv4ContextSurfaces2D.SetOffsetSource = dwSrcOffset;
        if (doLuma)
            // more stuff to do later, do this in place
            npDevVideo->dDrawSpare.nv4ContextSurfaces2D.SetOffsetDestin = dwSrcOffset;
        else
            npDevVideo->dDrawSpare.nv4ContextSurfaces2D.SetOffsetDestin = dwDstOffset;
        npDevVideo->dDrawSpare.SetObject = NV_DD_SRCCOPY_PREMULT_A8R8G8B8_IMAGE_BLIT;
        npDevVideo->dDrawSpare.nv4ImageBlit.ControlPointIn = 0;
        npDevVideo->dDrawSpare.nv4ImageBlit.ControlPointOut = 0;
        npDevVideo->dDrawSpare.nv4ImageBlit.Size = (dwHeight << 16) | (dwWidth >> 1);
        PDRIVERDATA->dDrawSpareSubchannelObject = 0;
    }

    // OverContrast and Brightness calculations
    if (doLuma) {
        static const __int64 shiftMask   = 0xFEFEFEFEFEFEFEFE;
        static const __int64 cmpOverflow = 0xFFFFFFFFFFFFFFFF;
        DWORD j, dwAdjWidth;
        LPBYTE qPtr;

        // move Y data to system memory
        RESET_OCC_EVENT;
        WAIT_FOR_FIFO(48);

        pPioColourControlEventNotifier[1].status = NV_IN_PROGRESS;

        npDevVideo->dDrawSpare.SetObject = NV_VPP_V2OSH_FORMAT_IID;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.SetContextDmaNotifies = NV_DD_PIO_COLOUR_CONTROL_EVENT_NOTIFIER;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.SetContextDmaBufferIn = NV_DD_PIO_CONTEXT_DMA_FROM_VIDEO_MEMORY;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.SetContextDmaBufferOut = NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_OVERLAY_SHADOW;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.OffsetIn     = dwSrcOffset + dwYPhase;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.OffsetOut    = 0;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.PitchOut     = dwDstPitch;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.LineLengthIn = dwWidth;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.LineCount    = dwHeight;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.PitchIn      = dwSrcPitch;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.Format       = 0x102;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.BufferNotify = COLORCTL_039_NOTIFYVALUE;

        if (!doChroma) {
            // chroma has not and will not move, do that now
            WAIT_FOR_FIFO(36);

            npDevVideo->dDrawSpare.SetObject = NV_DD_VIDEO_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT;
            npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.OffsetIn     = dwSrcOffset + (dwYPhase ^ 1);
            npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.OffsetOut    = dwDstOffset + (dwYPhase ^ 1);
            npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.PitchOut     = dwSrcPitch;
            npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.LineLengthIn = dwWidth;
            npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.LineCount    = dwHeight;
            npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.PitchIn      = dwSrcPitch;
            npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.Format       = 0x202;
            npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.BufferNotify = 0;
        }

        // init MMX const data
        qPtr       = (LPBYTE) PDRIVERDATA->vpp.fpOverlayShadow;
        dwAdjWidth = (dwWidth + 15) / 16;
        _asm {
            movd        mm0, dwBrightness
            punpckldq   mm0, dwBrightness
            movq        mm2, shiftMask
            movq        mm3, cmpOverflow 
		    }

        // wait for luma data to arrive in system memory
        WAIT_FOR_OCC_EVENT;
        //MarkTiming(WAITLUMAARIVE,dwSrcOffset + MySurfaces.pDriverData->BaseAddress,30);
        
        
        if(doChroma) {  
          // move chroma data to back to video memory
          RESET_OCC_EVENT;
          WAIT_FOR_FIFO(48);
  
          PDRIVERDATA->dDrawSpareSubchannelObject = 0;
          pPioColourControlEventNotifier[1].status = NV_IN_PROGRESS;
  
          npDevVideo->dDrawSpare.SetObject = NV_VPP_OSH2V_FORMAT_IID;
          npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.SetContextDmaNotifies = NV_DD_PIO_COLOUR_CONTROL_EVENT_NOTIFIER;
          npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.SetContextDmaBufferIn = NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_OVERLAY_SHADOW;
          npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.SetContextDmaBufferOut = NV_DD_PIO_CONTEXT_DMA_TO_VIDEO_MEMORY;
          npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.OffsetIn     = dwChromaOffset;
          npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.OffsetOut    = dwDstOffset + (dwYPhase ^ 1);
          npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.PitchOut     = dwSrcPitch;
          npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.LineLengthIn = dwWidth;
          npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.LineCount    = dwHeight;
          npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.PitchIn      = dwDstPitch;
          npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.Format       = 0x201;
          if (!doLuma) {
              npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.BufferNotify = COLORCTL_039_NOTIFYVALUE;
              WAIT_FOR_OCC_EVENT;
              //MarkTiming(WAITCHROMARETURN,dwSrcOffset + MySurfaces.pDriverData->BaseAddress,20);
            
          } else {
              npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.BufferNotify = 0;
          }
        }
        
/*
        // preload the first 8 scan lines into the cache
        for (j=0; j<8; j++) {
            _asm {
                        mov     esi, qPtr
                        mov     ecx, dwAdjWidth
                        shr     ecx, 1
                preld2: mov     eax, [esi]
                        mov     eax, 0
                        add     esi, 32
                        dec     ecx
                        jnz     preld2
            }
            qPtr += dwDstPitch;
        }
*/
        // do brightness and/or overcontrast
        // mm0 = brightness
        // mm1 = quad data chunk
        // mm2 = shift mask
        // mm3 = overflow compare value
        // mm4 = compare register
        // mm5 = next quad data chunk
        // mm6 = next compare register
        if (lpDDCC->lBrightness >= 0) {
            if (bOverContrast) {
                // overcontrast and positive brightness, 0.6875 cycles/pixel
                // AND is commented out for performance -> noise in the lowest bit of precision
                for (j=0; j<dwHeight; j++) {
                    _asm {
                                mov     ecx, dwAdjWidth
                                mov     esi, qPtr
                                mov     edi, qPtr
                                mov     ebx, dwDstPitch
                       ;         shl     ebx, 3
                                movq    mm1, [esi]
                                movq    mm4, mm3
                        nextq1: movq    mm5, [esi+8]    ; Ui+   ; mm5 = data[i+1]
                                pcmpgtb mm4, mm1        ; Vi    ; mm4 = sign bit of data[i]
                                add     esi, 16         ; U     ; next source address
                                movq    mm6, mm3        ; Vi+   ; mm6 = overflow compare value
                                add     edi, 16         ; U     ; next destination address
                                psll    mm1, 1          ; Vi    ; mm1 <<= 1
                                pcmpgtb mm6, mm5        ; Ui+   ; mm6 = sign bit of data[i+1]
                       ;         pand    mm1, mm2        ; i    ; mm1 &= 0xFE (since there is no PSLLB)
                                por     mm4, mm1        ; Vi    ; mm4 |= mm1 (saturated result[i])

                                psll    mm5, 1          ; Ui+   ; mm5 <<= 1
                                paddusb mm4, mm0        ; Vi    ; mm4 += brightness
                       ;         pand    mm5, mm2        ; i+   ; mm5 &= 0xFE
                                movq    [edi-16], mm4   ; Ui    ; store result[i]
                                por     mm6, mm5        ; Vi+   ; mm6 |= mm5 (saturated result[i+1])
                                movq    mm1, [esi]      ; Ui    ; mm1 = data[i]
                                paddusb mm6, mm0        ; Vi+   ; mm6 += brightness
                                dec     ecx             ; U     ; decrement loop count
                                movq    mm4, mm3        ; Vi    ; mm4 = overflow compare value
                                movq    [edi-8], mm6    ; Ui+   ; store result[i+1]
                                jnz     nextq1          ; V
                    }
                    qPtr += dwDstPitch;
                }
            } else {
                // positive brightness only
                for (j=0; j<dwHeight; j++) {
                    _asm {
                                mov     ecx, dwAdjWidth
                                mov     esi, qPtr
                                mov     edi, qPtr
                                mov     ebx, dwDstPitch
                        ;        shl     ebx, 3
                                movq    mm1, [esi]
                        nextq2: movq    mm5, [esi+8]    ; Ui+   ; mm5 = data[i+1]
                                paddusb mm1, mm0        ; Vi    ; mm1 += brightness
                                add     esi, 16         ; U     ; next source address
                                add     edi, 16         ; V     ; next destination address
                                dec     ecx             ; U     ; decrement loop count
                                movq    [edi-16], mm1   ; Ui    ; store result[i]
                                paddusb mm5, mm0        ; Vi+   ; mm5 += brightness
                                movq    [edi-8], mm5    ; Ui+   ; store result[i+1]
                                movq    mm1, [esi]      ; Ui    ; mm1 = data[i]
                                jnz     nextq2          ; V
                    }
                    qPtr += dwDstPitch;
                }
            }
        } else {
            if (bOverContrast) {
                // overcontrast and negative brightness
                for (j=0; j<dwHeight; j++) {
                    _asm {
                                mov     ecx, dwAdjWidth
                                mov     esi, qPtr
                                mov     edi, qPtr
                                mov     ebx, dwDstPitch
                        ;        shl     ebx, 3
                                movq    mm1, [esi]
                                movq    mm4, mm3
                        nextq3: movq    mm5, [esi+8]    ; Ui+   ; mm5 = data[i+1]
                                pcmpgtb mm4, mm1        ; Vi    ; mm4 = sign bit of data[i]
                                add     esi, 16         ; U     ; next source address
                                movq    mm6, mm3        ; Vi+   ; mm6 = overflow compare value
                                add     edi, 16         ; U     ; next destination address
                                psll    mm1, 1          ; Vi    ; mm1 <<= 1
                                pcmpgtb mm6, mm5        ; Ui+   ; mm6 = sign bit of data[i+1]
                       ;         pand    mm1, mm2        ; i    ; mm1 &= 0xFE (since there is no PSLLB)
                                por     mm4, mm1        ; Vi    ; mm4 |= mm1 (saturated result[i])

                                psll    mm5, 1          ; Ui+   ; mm5 <<= 1
                                psubusb mm4, mm0        ; Vi    ; mm4 -= brightness
                       ;         pand    mm5, mm2        ; i+   ; mm5 &= 0xFE
                                movq    [edi-16], mm4   ; Ui    ; store result[i]
                                por     mm6, mm5        ; Vi+   ; mm6 |= mm5 (saturated result[i+1])
                                movq    mm1, [esi]      ; Ui    ; mm1 = data[i]
                                psubusb mm6, mm0        ; Vi+   ; mm6 -= brightness
                                dec     ecx             ; U     ; decrement loop count
                                movq    mm4, mm3        ; Vi    ; mm4 = overflow compare value
                                movq    [edi-8], mm6    ; Ui+   ; store result[i+1]
                                jnz     nextq3          ; V
                    }
                    qPtr += dwDstPitch;
                }
            } else {
                // negative brightness only
                for (j=0; j<dwHeight; j++) {
                    _asm {
                                mov     ecx, dwAdjWidth
                                mov     esi, qPtr
                                mov     edi, qPtr
                                mov     ebx, dwDstPitch
                        ;        shl     ebx, 3
                                movq    mm1, [esi]
                        nextq4: movq    mm5, [esi+8]    ; Ui+   ; mm5 = data[i+1]
                                psubusb mm1, mm0        ; Vi    ; mm1 -= brightness
                                add     esi, 16         ; U     ; next source address
                                add     edi, 16         ; V     ; next destination address
                                dec     ecx             ; U     ; decrement loop count
                                movq    [edi-16], mm1   ; Ui    ; store result[i]
                                psubusb mm5, mm0        ; Vi+   ; mm5 -= brightness
                                movq    [edi-8], mm5    ; Ui+   ; store result[i+1]
                                movq    mm1, [esi]      ; Ui    ; mm1 = data[i]
                                jnz     nextq4          ; V
                    }
                    qPtr += dwDstPitch;
                }
            }
        }

        // move Y data to back to video memory
        RESET_OCC_EVENT;
        WAIT_FOR_FIFO(48);

        pPioColourControlEventNotifier[1].status = NV_IN_PROGRESS;

        npDevVideo->dDrawSpare.SetObject = NV_VPP_OSH2V_FORMAT_IID;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.SetContextDmaNotifies = NV_DD_PIO_COLOUR_CONTROL_EVENT_NOTIFIER;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.SetContextDmaBufferIn = NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_OVERLAY_SHADOW;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.SetContextDmaBufferOut = NV_DD_PIO_CONTEXT_DMA_TO_VIDEO_MEMORY;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.OffsetIn     = 0;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.OffsetOut    = dwDstOffset + dwYPhase;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.PitchOut     = dwSrcPitch;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.LineLengthIn = dwWidth;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.LineCount    = dwHeight;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.PitchIn      = dwDstPitch;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.Format       = 0x201;
        npDevVideo->dDrawSpare.nv3MemoryToMemoryFormat.BufferNotify = COLORCTL_039_NOTIFYVALUE;
        PDRIVERDATA->dDrawSpareSubchannelObject = 0;

        WAIT_FOR_OCC_EVENT;
        //MarkTiming(WAITLUMARETURN,dwSrcOffset + MySurfaces.pDriverData->BaseAddress,40);
        
    }

    _asm { 
		  emms 
	  };

#ifdef COMPILEDINVDD
    // reset bit 1 meaning we're no longer in operation
    PDRIVERDATA->vpp.regRing0ColourCtlInterlockFlags = PDRIVERDATA->vpp.regRing0ColourCtlInterlockFlags & 0xFFFFFFFD;
#endif   
    MarkTiming(LEAVECOLORCTL,dwSrcOffset + MySurfaces.pDriverData->BaseAddress,50);
    
    return doContrastBlt || doLuma || doChroma;
}


BOOL WillDoYUV422ColourControl( LPDDCOLORCONTROL lpDDCC)
{

  BOOL bOverContrast;
  DWORD dwContrast, dwBrightness, cnt, brt;
  short hue, sat;
  
  BOOL doContrastBlt, doLuma, doChroma;
  LPPROCESSINFO lpProcInfo = NULL;

#ifndef COMPILEDINVDD
  lpProcInfo = pmGetProcess(GetCurrentProcessId());    
#endif
    
#ifdef POLLINGMODE
  if (!PDRIVERDATA->vpp.regOverlayColourControlEnable ||
      !PDRIVERDATA->vpp.fpOverlayShadow)
#else
  if (!PDRIVERDATA->vpp.regOverlayColourControlEnable ||
      !PDRIVERDATA->vpp.fpOverlayShadow ||
      !lpProcInfo ||
      !lpProcInfo->hOCCSyncEvent3)
#endif
    return FALSE;
  
  if (lpDDCC->lContrast > 0xFF) {
    cnt = lpDDCC->lContrast >> 1;
    bOverContrast = TRUE;
  } else {
    cnt = lpDDCC->lContrast;
    bOverContrast = FALSE;
  }
  if(lpDDCC->lBrightness  < 0 ) {
    brt = -lpDDCC->lBrightness;
  } else {
    brt = lpDDCC->lBrightness;
  }
  hue = (short) lpDDCC->lHue;
  sat = (short) lpDDCC->lSaturation;
  
  
  dwContrast   = (cnt << 8) | (cnt << 24) | 0x00FF00FF;
  dwBrightness = brt | (brt << 8) | (brt << 16) | (brt << 24);
  
  doContrastBlt = (dwContrast != 0xFFFFFFFF);
  doLuma        = (dwBrightness != 0 || bOverContrast);
  doChroma      = (hue != 0 || sat != 0x100);
  
  return doContrastBlt || doLuma || doChroma;
}


#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vdd\nvmini.asm ===
;       (C) Copyright NVIDIA Corporation Inc., 1996,1997. All rights reserved.
;       Portions Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.
;
;       NVidia Mini-VDD
;
;       Written by:     Mark Stephen Krueger
;       Date:           10/1/96
;               JohnH 10/15/97  spun off version for release 2
;
;       $Revision: 6 $
;       $Date: 6/04/98 6:08p $
;       $Logfile: /resman.050/win96/vdd/nv4.asm $
;       $Log: /resman.050/win96/vdd/nv4.asm $
;
; 6     6/04/98 6:08p Jhinman
; Added WaitTicks call to POST_HIRESTOVGA and POST_VGATOHIRES.
;
; 5     6/02/98 3:49p Schaefer
; partway complete change to enable another level of indirection with the
; setcallback system.
;
; -C-
;
; 4     5/28/98 4:47p Schaefer
; * added callback routines for VBI and Image field completion
;
; 3     5/28/98 10:36a Schaefer
; add functionality for VPE support,  moved data structres into Ring0
; space
;
; 2     5/14/98 4:35p Schaefer
; updated to include KMVT functions in VDD
;
; 1     5/07/98 1:00p Jhinman
; Name change.
;
; 1     5/05/98 5:14p Jhinman
; Gave the mini-VDD a non-chip-specific name.
;
; 28    4/29/98 11:51p Kevink
; Cleaned up NV4 naming (again)
;
; 27    4/29/98 11:14p Kevink
; Fixed an IFDEF
;
; 26    4/28/98 6:20p Kevink
; Added NV4 naming
;
; 24    4/23/98 8:00p Jhinman
; Set DisplayEnabledFlag in PostCRTCModeChange, in case GetVDDBank does
; not get called.
;
; 23    4/16/98 9:07p Jhinman
; Set displayenabledflag in DisplayDriverDisabling and check it in
; RestoreRegisters.
;
; 22    4/01/98 12:09p Jhinman
; Move system vm handle to ebx before save registers/save message mode
; state.
;
; 21    3/30/98 8:40p Jvito
; Don't bother with the cursor HW address registers on a restore.
;
; 20    3/10/98 10:36a Jhinman
; Added comment which fixes "line too long" error.
;
; 19    3/09/98 5:49p Jhinman
; Do the saveRegisters/SaveMessageModeState at pnp_new_devnode.
;
; 18    2/26/98 5:08p Jhinman
; Pass the address of PostCRTCModeChange to the resource manager, so it
; can notify us when a mode change has taken place, and we will save
; registers.
;
; 17    2/24/98 11:22p Jvito
; Code changes to allow the MiniVDD to monitor mode changes in the RM.
;
; 16    2/18/98 3:58p Jvito
; Exit the minivdd_restoreregisters routine if entered by the system.
;
; 15    2/13/98 2:27p Jhinman
; Add device number to the call to resource manager to map device. Add
; amount of video RAM to GetTotalVRAMsize. Add SaveRegisters to
; PostCRTCModeChange.
;
; 14    1/14/98 3:05p Jhinman
; Handle SYSTEM_EXIT message.
;
; 13    1/09/98 2:01p Jhinman
; Split miniVDD from the resource manager again. Load RM and communicate
; with it through its API.
;
; 12    12/17/97 2:29p Jhinman
; Check for Windows 98 before hooking turnVGAon/off. Don't do FindNV3.
;
; 11    12/10/97 11:05a Jhinman
; Enable VGATurnOff/On.
;
; 10    12/02/97 6:10p Jhinman
; pnp_new_devnode: jmp to minivdd_pnp_done if error.
;
; 8     11/21/97 5:56p Jhinman
; Check addresses and IRQ are nonzero before we call rmConfigStart.
;
; 7     11/15/97 11:37a Jhinman
; Enable pnp_new_devnode, but do not hook the pnp handler. Get the config
; from config manager and call configStart in pnp_new_devnode.
;
; 6     11/07/97 6:44p Jhinman
; If P_N_P defined, do plug and play stuff.
;
; 5     10/30/97 6:44p Jhinman
; Changed the way miniVDD communicates the addresses to RM (nvAddr,
; nvPhys, etc. are global).
;
; 4     10/29/97 4:53p Waynek
; Add new Memphis MiniVDD entry points to allow the minivdd to turn off
; access to the VGA resources.
;
; 3     10/29/97 4:29p Jhinman
; Removed the ifdef UNIFY_VXDS and added some debug messages in Plug and
; Play handler.
;
; 2     10/27/97 3:07p Jhinman
; Unified miniVDD/resource manager.
;
;
page            ,132
title           NVidia NV3 Mini-VDD Support Functions
.386p
;

VESA20  equ 1   ; turn on fixup of VBE DDC functions: 
                ; 1) create 1.x EDID from a 2.0 EDID,
                ; 2) read from alternate device addresses (A6, A2, A0)
RM_GET_DDC_CAPS equ     1       ; let RM handle GET DDC CAPABILITES instead of the BIOS

;
.xlist
MINIVDD                 EQU             1               ; this must be defined for minivdd.inc

include         VMM.INC
include         SHELL.INC
include         VWIN32.INC                      ; used for IOCTL for KMVT
include                 VXDLDR.INC
include         DEBUG.INC
include         MINIVDD.INC
include         configmg.inc
include         VNVRMD.INC
include         V86MMGR.INC
include         NVDEF.INC
include         VBE30.INC
include         NVIDIA.INC
IFDEF NVIDIA_COMMON
include         NV_REF.INC
include         NV_MAC.INC
include         NV_SIM.INC
ENDIF ; NVIDIA_COMMON
include         SURFACES.INC
IFDEF NVPE
include         NVPEOS.INC
ENDIF
include         ..\..\..\..\..\sdk\nvidia\inc\rddapi.inc

IFDEF   DIOC
extrn           GetDDHAL:near
extrn           NvFillTable:near
extern          NVGetSetCallback:near
extern          NVSetVidTexSuf:near
ENDIF   ;DIOC

IFDEF NVPE
extrn           _nvpeVDDCmdHandler:near
extrn           _nvpeVDDClearState:near
extrn               _nvpeVDDInit:near
ENDIF

IFDEF   I2C
extrn           _vddI2COpen:near
extrn           _vddI2CAccess:near
NOCHANNEL       equ     -1
ENDIF   ;I2C

public                  MiniVDD_BroadcastHandler


; defines needed for Canopus TV extensions

TVB_VBE_FCT             equ 04f14h  ; VBE OEM function number
TVB_VBE_TV_GET          equ 00102h  ; sub function to get the TV flag
TVB_VBE_TV_SET          equ 00202h  ; sub function to set the TV flag
TVB_VBE_TV_CRTC         equ 00302h  ; sub function to get the TV flag CRTC index
TVF_WINDOWS             equ 040h    ; marker for our mini VDD
TVF_INACTIVE            equ 080h    ; no hardware initialisation (of the Chrontel chip)

CANOPUS_TV_REG                  equ             02bh    ;; TV flag register index

; defines needed for Advanced Power Management

WM_POWERBROADCAST                               EQU 218h

PBT_APMQUERYSUSPEND             EQU 0
PBT_APMQUERYSTANDBY             EQU 1

PBT_APMQUERYSUSPENDFAILED       EQU 2
PBT_APMQUERYSTANDBYFAILED       EQU 3

PBT_APMSUSPEND                  EQU 4
PBT_APMSTANDBY                  EQU 5

PBT_APMRESUMECRITICAL           EQU 6
PBT_APMRESUMESUSPEND            EQU 7
PBT_APMRESUMESTANDBY            EQU 8

PBTF_APMRESUMEFROMFAILURE       EQU 1

PBT_APMBATTERYLOW               EQU 9
PBT_APMPOWERSTATUSCHANGE        EQU 0Ah

PBT_APMOEMEVENT                 EQU 0Bh
PBT_APMRESUMEAUTOMATIC          EQU 12h

.list

;**************************************************************************************************************************
subttl          Virtual Device Declaration
page +
;       Then MiniVDD must have the UNDEFINED_DEVICE_ID
;       and it is a dynamic load VxD, so it cannot have a service table.
Declare_Virtual_Device  NVMINI, \
                        3,      \
                        1,      \
                        MiniVDD_Control,        \
                        UNDEFINED_DEVICE_ID,    \
                        VDD_INIT_ORDER,         \
                                                ,                                               \
                        ,                                       \
                        ,

;
;
;**************************************************************************************************************************
subttl          Initialization Data
page +
VxD_IDATA_SEG

VxD_IDATA_ENDS
;
;**************************************************************************************************************************
subttl          Locked Data Area
page +
VxD_LOCKED_DATA_SEG
PUBLIC  dwCallbacksSelector, pfnLockOffscreen, pfnUnlockOffscreen, pfnPowerOn, pfnPowerOff
dwCallbacksSelector     DD      0
pfnLockOffscreen        DD      0
pfnUnlockOffscreen      DD      0
pfnPowerOn              DD      0
pfnPowerOff             DD      0
pfnCurrentCall          DD      0

GetMonInfoCount         DD      -1
dwInt10EntryCount       DD      -1

PUBLIC  dwDisplayDevnodeHandle
dwDisplayDevnodeHandle  DD      0

PUBLIC  szEnumAndMore
szEnumAndMore           DB      "Enum\"
szAndMore               DB      128 DUP(0)
szAllowMightyModes      DB      "AllowMightyModes",0
dwAllowMightyModes      DD      0

PUBLIC  szLocalDisplayPath, szLocalDisplayPathEnd
szLocalDisplayPath      DB      "System\CurrentControlSet\Services\Class\"
szLocalDisplayPathEnd   DB      32 DUP(0)

PUBLIC  szDriver
szDriver        DB      "Driver",0

PUBLIC  szDisplayEndPath
szDisplayEndPath        DB      32 DUP(0)

ALIGN 4
PUBLIC  dwCBType, dwCBLen, hKey
dwCBType        DD      0
dwCBLen         DD      0
hKey            DD      0

EDID1_HEADER    DB      0,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0

; Need to rewrite ReenumerateDevNode routine
; when increase this number!!!
MAX_CRTCS       equ     2
LogicalDevice   DD      MAX_CRTCS DUP (0)

PUBLIC  pDDrawFullScreenDOSActive
pDDrawFullScreenDOSActive       DD      0
VxD_LOCKED_DATA_ENDS
;
;**************************************************************************************************************************
subttl          General Data Area
page +
VxD_DATA_SEG
;
IFDEF DEBUG_LOG
public  DebugOn
DebugOn                 dd      1               ;Should routines log debug info?
;
ENDIF ; DEBUG_LOG
public  WindowsVMHandle
WindowsVMHandle         dd      ?               ;init'd at Device_Init
;
public  PlanarStateID, MessageModeID
PlanarStateID           dd      ?               ;init'd at RegisterPlanarState
MessageModeID           dd      ?               ;init'd at RegisterMessageMode
;
public  OSVersion
OSVersion               dw      ?               ;init'd at Device_Init

public  TotalMemorySize
TotalMemorySize         dd      ?               ;init'd at Sys_Critical_Init
;
public  Vid_PhysA0000
Vid_PhysA0000           dd      0               ;
;
public  OurCBDataPointer
OurCBDataPointer        dd      ?               ;init'd at Device_Init
;
public  MessageModeCBData
MessageModeCBData       db      size PerVMData dup(0)
;
public  ForcedPlanarCBData
ForcedPlanarCBData      db      size PerVMData dup(0)
;
public  MemoryMappedSelector
MemoryMappedSelector    dd      0               ;init'd at RegisterDisplayDriver
;
public  ChipID                                  ;NVidia specific variable!
ChipType                db      3               ;init'd at pnp_new_devnode
;

public  ModeChangeFlags
ModeChangeFlags         db      ?               ;=FFH when in BIOS mode change

public  DosBoxActive
DosBoxActive            db      ?
; Equate used by for API to the RM
NVRM_API_SIGNAL_MODE_SAVE       equ     1000+71
;
public  DisplayEnabledFlag
DisplayEnabledFlag      db      0               ;=FFH when display in HiRes mode
;
public  SuperVGAModeFlag
SuperVGAModeFlag        db      0               ;=FFH when NOT running VGA mode
;
public  MsgModeInitDone
MsgModeInitDone         db      0               ;=FFH when collecting states
;
public  VGAModeFlag
VGAModeFlag             db      0               ;=FFh when in 16 color mode (VGA driver)
;
public  InRefreshSetMode
InRefreshSetMode        db      0               ;=FFH when in int 10 already

SeqIdx                  db      ?
LockValue               db      ?

ResManAPI               dd      0                               ; NVRM API entry point
;
nvPhys                  dd      0                               ; physical address given us by Configuration Manager
fbPhys                  dd      0                               ;         "
fbLength                dd      0               ; 16 or 32 MB
nvIRQ                   dd      0                               ; physical irq       "
nvAddr                  dd      0                               ; linear address used everywhere to access chip
fbAddr                  dd      0
nvCustomer              dd      0                               ; bitmask of current customer support
NVCUSTOMER_CANOPUS      EQU     1
NVCUSTOMER_TOSHIBA      EQU     2
fbBuffer                dd      0
fpDDC                   dd      0
NumUnits                dd      0               ; number of "units" or heads
cursor_pos              dw      0
ChipID                  dd      0                               ; master control boot register
hDev                    dd      0
NVRM_String             db      'NVCORE.VXD',0   ; filename of the resource manager
DevCtlRet               dd      0               ; Dev IOCTL function ret val
ACPI_state              db      0               ; ACPI state 0-3
configStartDone         db      0               ; Flag to protect duplicate call to CONFIG_START
public  DoNotSimulate
DoNotSimulate           db      0
RestoreStdCrtc          db      0
DisplayChanged          db      0
DDC_Caps                dw      0       ; Save DDC Caps
BuffOff                 dw      0       ; V86 buffer passed in to VESASupport
BuffSeg                 dw      0       ;  "
Edid2Map                dw      0
DetTimOff               dw      0
DDCAddrFake             dw      0       ; DDC address map
pEdid1                  dd      0       ; pointer to caller's 128 byte EDID buffer
pEdid2                  dd      0       ; pointer to V86 buffer alloc'd for 256 byte EDID
TempEdidBufOff          dw      0       ; real mode address of our EDID buffer
TempEdidBufSeg          dw      0       ;
EdidAddress             db      0       ; Save device address when retrying EDID reads
DontRecurse             db      0       ; when != just pass down
nDetTim                 db      0
numDevice               db      0       ; number of devices = number of times map config called

; Canopus globals
InFullScreen            db      0
bCanopusTVReg           db      0

; resource manager parameter passing structure.
minivdd_RM_Parameter_Struct struct
  callrm_device_handle        dd      0
  callrm_modechange_callback  dd      0
  callrm_irq_bus              dd      0
  callrm_fbphys               dd      0
  callrm_nvphys               dd      0
  callrm_registry_path        dd      0
minivdd_RM_Parameter_Struct ends
callrm_struct minivdd_RM_Parameter_Struct <>
callrm_rmusrapi minivdd_CALLRM_rmusrapi_Struct <>

;
public  DisplayInfoStructure, refreshRates
DisplayInfoStructure    DISPLAYINFO     <>
;
refreshRates    PRefreshRateStruct Refresh640,Refresh800,Refresh1024,Refresh1280
;
Refresh640      RefreshRateStruct<75,37,<0840,0656,0656+064,0500,0481,0481+3,'-','-',0,DC_031_500,7500>>
                RefreshRateStruct<60,31,<0800,0656,0656+096,0525,0490,0490+2,'-','-',0,DC_025_175,6000>>
                dd      0
;
Refresh800      RefreshRateStruct<75,46,<1056,0816,0816+080,0625,0601,0601+3,'+','+',0,DC_049_500,7500>>
                RefreshRateStruct<72,48,<1040,0856,0856+120,0666,0637,0637+6,'+','+',0,DC_050_000,7200>>
                RefreshRateStruct<60,37,<1056,0840,0840+128,0628,0601,0601+4,'+','+',0,DC_040_000,6000>>
                RefreshRateStruct<56,35,<1024,0824,0824+072,0625,0601,0601+2,'+','+',0,DC_036_000,5600>>
                dd      0
;
Refresh1024     RefreshRateStruct<75,60,<1312,1040,1040+096,0800,0769,0769+3,'+','+',0,DC_078_750,7500>>
                RefreshRateStruct<70,56,<1328,1048,1048+136,0806,0771,0771+6,'-','-',0,DC_075_000,7000>>
                RefreshRateStruct<60,48,<1344,1048,1048+136,0806,0771,0771+6,'-','-',0,DC_065_000,6000>>
                RefreshRateStruct<43,35,<1264,1032,1032+176,0817,0768,0768+4,'+','+',1,DC_044_900,4300>> ; Interlaced
                dd      0
;
Refresh1280     RefreshRateStruct<60,64,<1696,1344,1344+016,1066,1025,1025+3,'+','+',0,DC_108_500,6000>>
                RefreshRateStruct<75,79,<1688,1296,1296+144,1066,1025,1025+3,'+','+',0,DC_135_000,7500>>
                dd      0
;
; EDID 1.0 template
; for creating a phony version 1 EDID when the actual EDID is version 2
EdidTemp        db      0,0ffh,0ffh,0ffh,0ffh,0ffh,0ffh,0   ; header
                db      0,0,0,0,0,0,0,0,1,10                ; vendor/product ID
                db      1,0                                 ; EDID version
                db      0ch,20h,18h,0beh,0e8h               ; display parameters
                db      0e1h,062h,09eh,055h,04ah,098h,027h,012h,048h,04fh ; color characteristics
                db      3   dup(0)                          ; established timings
                db      16  dup(0)                          ; standard timing
                db      72  dup(0)                          ; detailed timing
                db      0                                   ; extension flag
                db      0                                   ; checksum
; end of EDID

EDID1_VENDOR    equ     8
EDID1_SIZE      equ     128
EDID1_DET_TIMING        equ 36h     ;offset to detailed timing

EDID2_VENDOR    equ     1
EDID2_SIZE      equ     256
; EDID 2 offsets and bit defs
EDID2_MAP               equ 7eh     ;offset to map
EDID2_TIMING_START      equ 80h     ;offset to timing
EDID2_LUM_TABLE_EXIST   equ 20h
EDID2_LUM_ENTRIES       equ 1fh
EDID2_LUMX3             equ 80h
EDID2_RL                equ 1ch
EDID2_RL_SHIFT          equ 2
EDID2_DRL               equ 3
EDID2_TIMING_CODES      equ 0f8h
EDID2_TC_SHIFT          equ 3
EDID2_DET_TIMINGS       equ 07h

; DDC bit defs
DDC_ADDR_A0             equ 03h     ; DDC address is A0 (DDC 1 or DDC 2)
DDC_ADDR_A2             equ 08h     ; DDC address is A2 (DDC 2)
DDC_ADDR_A6             equ 10h     ; DDC address is A6 (DDC 2)
DDC_SUBF_1              equ 1       ; DDC read EDID at A0
DDC_SUBF_3              equ 3       ; DDC read EDID at A2
DDC_SUBF_4              equ 4       ; DDC read EDID at A6


VxD_DATA_ENDS
;
;
;**************************************************************************************************************************
subttl          Device Initialization
page +
VxD_ICODE_SEG

;
public  MiniVDD_Dynamic_Init
BeginProc MiniVDD_Dynamic_Init

;
;Entry:
;       EBX contains the VM handle of the Windows VM.
;Exit:
;       If success, return NC.
;       If failure, return CY.
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_Dyanmic_Init", DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        push    ebx                     ;save Windows VM handle in EBX
        push    ebp
        mov     WindowsVMHandle,ebx     ;save the Windows VM handle
        mov     ModeChangeFlags,0       ;initialize this
        mov     DosBoxActive,0
;ifdef  SEPARATE_RM
;
;       We are the primary display
;       load NV ResMan
;
        mov             edx, OFFSET32 NVRM_String
        mov             eax, VXDLDR_INIT_DEVICE
        VxDcall VXDLDR_LoadDevice
        jc              MVDIErrorExit                   ;failed, nothing we can do

;       returns DDB address in eax and device handle in edx
;       save the API entry
        mov             eax, [eax].DDB_PM_API_Proc
        mov             ResManAPI, eax
;endif  ;SEPARATE_RM

;       Correct the string for multihead configuration
;       Change %s\Unit%d --> %s\U%d
        push    ecx
        push    edx
        push    edi
        mov     eax,0ah
        xor     edi,edi
        VMMCall Get_DDB
        or      ecx,ecx
        jz      @F
        lea     edi,[ecx+18h]
        mov     edx,ASSERT_RANGE_NO_DEBUG OR ASSERT_RANGE_NULL_BAD
        VMMCall _Assert_Range,<edi,4,0,0,edx>
        or      eax,eax
        jz      @F
        mov     edi,[edi]
        lea     edi,[edi+13fch]
        VMMCall _Assert_Range,<edi,4,2574696eh,0,edx>
        or      eax,eax
        jz      @F
        mov     ecx,6425h               ; '%d'
        mov     [edi],ecx
@@:
        ; Initialize LogicalDevice structure.
        lea     edi,LogicalDevice
        sub     ecx,ecx

@@:
        mov     [edi],ecx
        inc     ecx
        add     edi,4
        cmp     ecx,MAX_CRTCS
        jb      @B

        pop     edi
        pop     edx
        pop     ecx
;
;Get the linear address of physical A0000H addressable for 64K:
;
        VMMCall _MapPhysToLinear,<0A0000h,10000h,0>
        cmp     eax,-1                  ;was there an error?
        je      MVDIErrorExit           ;yes, better not load!
        mov     Vid_PhysA0000,eax       ;save this off!

;       clear VPE's global state
        call _nvpeVDDClearState

;       initialize WDM prescale values
        call _nvpeVDDInit
;
public  MVDIGetSpecialVMs
MVDIGetSpecialVMs:
;
;There are two special VM states that the "main" VDD establishes.  The
;first is the planar state which is simply a state that the "main" VDD
;restores to establish the VGA 4 plane mode.  When we restore the states
;at MiniVDD_RestoreRegisterState, we check for the special identifier which
;flags that we're restoring this state.  If we find that we are restoring
;the planar state, we have the opportunity to special case the register
;state restore.
;
;Similarly, there is a special state called "Message Mode".  This is the
;state when the Shell VxD is displaying a full-screen message (usually
;with a blue background) telling the user of a serious anomaly in the
;running state of Windows.  We also retrieve the special VM handle
;for the "Message Mode" state so we can handle it special too if needed.
;
        VxDCall VDD_Get_Special_VM_IDs  ;go get special VM information
        mov     PlanarStateID,esi       ;save off returned identifiers
        mov     MessageModeID,edi       ;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    ":PlanarStateID:%08lX", esi, DEBLEVELMAX
                Debug_Printf    ":MessageModeID:%08lX", edi, DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
;
public  MVDIDispatch
MVDIDispatch:
;
;We want to allocate space in the per-VM CB data structure.  This will
;be used by the mini-VDD to store per-VM data relating to states of registers.
;
        VMMCall _Allocate_Device_CB_Area,<<size PerVMData>,0>
        mov     OurCBDataPointer,eax    ;save offset of our VxD's area
        or      eax,eax                 ;was call sucessful?
        jz      MVDIErrorExit           ;nope, leave fatally!
;
;The "master" VDD (VDD.386) contains all of the routines and procedures
;that are necessary to virtualize a standard VGA environment on high
;resolution super-VGA cards.  This "mini-VDD" provides some simple
;services which provide support which are peculiar to the chipset
;that we're providing support for.
;
;We must register the entry point addresses of our chipset-dependent
;routines with the "master" VDD.  To do this, we call a service in the
;"master" VDD, which returns the address of a dispatch table of the
;which is an array of the format:
;
;               dd      Address of support routine in this mini-VDD.
;                       This address will be initialized to 0 by the "master"
;                       VDD.  If we need to implement this functionality,
;                       we fill in the address of our routine.
;
;Then, when the "master" VDD needs to call this function, it'll see if we've
;filled in the address field in for the function's entry and will call our
;routine if the address is filled in.  Otherwise, the VDD will skip the call
;and continue on its way without calling us.
;
;The following function calls the "master" VDD and returns a pointer to the
;dispatch table documented above in EDI and the number of functions
;supported in ECX. If the number of functions returned by the "master" VDD
;is less than what we think it is, we return an error and don't allow
;Windows to continue running.
;
        VxDCall VDD_Get_Mini_Dispatch_Table
        cmp     ecx,NBR_MINI_VDD_FUNCTIONS      ;perform a cursory version check
        jb      MVDIErrorExit                   ;oops, versions don't match!
;
public  MVDIFillInTable
MVDIFillInTable:
;
;Fill in the addresses of all the functions that we need to handle in this
;mini-VDD in the table provided by the "master" VDD whose address is
;contained in EDI.  Note that if you do not need to support a function,
;you do not need to fill in the dispatch table entry for that function.
;If you do not fill in an entry, the "master" VDD won't try to call
;this mini-VDD to support the function.  It'll just handle it in a
;default manner.
;
        MiniVDDDispatch REGISTER_DISPLAY_DRIVER,RegisterDisplayDriver
; if we don't support vitualizing planar mode, we don't need the following 2 functions:
        MiniVDDDispatch GET_VDD_BANK,GetVDDBank
        MiniVDDDispatch SET_VDD_BANK,SetVDDBank
        MiniVDDDispatch RESET_BANK,ResetBank
;We still need these routines for ourselves in RestoreLatches, but the
;main VDD should never call them because we have SaveLatches and
;RestoreLatches.
        MiniVDDDispatch SET_LATCH_BANK,SetLatchBank
        MiniVDDDispatch RESET_LATCH_BANK,ResetLatchBank
;        MiniVDDDispatch SAVE_LATCHES,SaveLatches
;        MiniVDDDispatch RESTORE_LATCHES,RestoreLatches
        MiniVDDDispatch PRE_HIRES_TO_VGA,PreHiResToVGA
        MiniVDDDispatch POST_HIRES_TO_VGA,PostHiResToVGA
        MiniVDDDispatch PRE_VGA_TO_HIRES,PreVGAToHiRes
        MiniVDDDispatch POST_VGA_TO_HIRES,PostVGAToHiRes
        MiniVDDDispatch SAVE_REGISTERS,SaveRegisters
        MiniVDDDispatch RESTORE_REGISTERS,RestoreRegisters
        MiniVDDDispatch DISPLAY_DRIVER_DISABLING,DisplayDriverDisabling
        MiniVDDDispatch GET_TOTAL_VRAM_SIZE,GetTotalVRAMSize
        MiniVDDDispatch GET_CURRENT_BANK_WRITE,GetCurrentBankWrite
        MiniVDDDispatch GET_CURRENT_BANK_READ,GetCurrentBankRead
        MiniVDDDispatch GET_BANK_SIZE,GetBankSize
        MiniVDDDispatch SET_BANK,SetBank
        MiniVDDDispatch PRE_HIRES_SAVE_RESTORE,PreHiResSaveRestore
        MiniVDDDispatch POST_HIRES_SAVE_RESTORE,PostHiResSaveRestore
        MiniVDDDispatch CHECK_SCREEN_SWITCH_OK,CheckScreenSwitchOK
        MiniVDDDispatch GET_CHIP_ID,GetChipID
        MiniVDDDispatch VIRTUALIZE_SEQUENCER_OUT,VirtSeqOut
        MiniVDDDispatch VIRTUALIZE_SEQUENCER_IN,VirtSeqIn
        MiniVDDDispatch ENABLE_TRAPS,EnableTraps
        MiniVDDDispatch DISABLE_TRAPS,DisableTraps
        MiniVDDDispatch MAKE_HARDWARE_NOT_BUSY,MakeHardwareNotBusy
        MiniVDDDispatch VIRTUALIZE_CRTC_OUT,VirtCRTCOut
        MiniVDDDispatch VIRTUALIZE_CRTC_IN,VirtCRTCIn
        MiniVDDDispatch PRE_CRTC_MODE_CHANGE,PreCRTCModeChange
        MiniVDDDispatch POST_CRTC_MODE_CHANGE,PostCRTCModeChange
        MiniVDDDispatch SAVE_FORCED_PLANAR_STATE,SaveForcedPlanarState
        MiniVDDDispatch SAVE_MESSAGE_MODE_STATE,SaveMessageModeState
        MiniVDDDispatch VESA_SUPPORT,VESASupport
        MiniVDDDispatch GET_MONITOR_INFO,GetMonitorInfo
        ;===============================================
        ;
        ; new Win98 functions...
        ;
        VMMcall Get_VMM_Version
        mov OSVersion,ax        ; save OS version
        jc  PreWin98
        cmp   ax,VERS_WIN98
        jb    PreWin98
;         cmp   ax,045ah
;         jb    PreMillen
IFDEF   I2C
        ;I2C functions
          MiniVDDDispatch I2C_OPEN, I2COpen
          MiniVDDDispatch I2C_ACCESS, I2CAccess
ENDIF   ;I2C
        ;These are required for multi-display support
          MiniVDDDispatch TURN_VGA_OFF,TurnVgaOff
          MiniVDDDispatch TURN_VGA_ON,TurnVgaOn
        ;This is required if the device supports multiple displays
          MiniVDDDispatch GET_NUM_UNITS,GetNumUnits
        ;These are for power management. We don't need the monitor functions, since Windows will use VESA calls
        ; if we don't hook them.
;ifdef   ON_NOW
        pushad
        mov     eax,OFFSET32 DisplayInfoStructure
        mov     ecx,SIZE DISPLAYINFO    ;pass size in ECX, address in EAX
        mov     [eax].diHdrSize,cx      ;fill in this entry
        push    eax                     ;save EAX --> DisplayInfoStructure
        VxDCall VDD_Get_DISPLAYINFO     ;get information from the VDD
        pop     edi                     ;restore EAX --> DisplayInfoStructure
        mov     VGAModeFlag,0
        cmp     [edi].diBpp,4           ;16 color?
        je      SkipAdapterPM
        
        popad

        MiniVDDDispatch SET_MONITOR_POWER_STATE,SetMonitorPowerState
        MiniVDDDispatch GET_MONITOR_POWER_STATE_CAPS,GetMonitorPowerStateCaps
        MiniVDDDispatch SET_ADAPTER_POWER_STATE,SetAdapterPowerState
        MiniVDDDispatch GET_ADAPTER_POWER_STATE_CAPS,GetAdapterPowerStateCaps
        jmp     PreWin98

SkipAdapterPM:
        popad
;endif
PreWin98:
        ;===============================================

;
public  MVDI_SetupPortTrapping
MVDI_SetupPortTrapping:
;Trapping ports 3D0-3D3 is required on Win95 because it splits word accesses into bytes.
;Our HW cannot deal with bytes accesses, so I trap the access and reconstruct byte I/O
;into word I/O. If the system VM is the owner, it's windowed DOS, and I do not let the I/O thru.
;Win95 gives us system_exit, sys_vm_terminate, etc. so when windows exits, we let the I/O thru
;even if it is the system VM. However, Win98 & later OS's don't give us the sys_VM_terminate msg.
;Since we don't have a means to detect system exit, we better not trap. Fortunately, these OS's
;also don't split up the I/O.

        mov   ax,OSVersion
        cmp   ax,VERS_WIN98     
        jae   @f                

;
;Now comes the hard part (conceptually).  We must call the "master" VDD to
;setup port trapping for any port that the Windows display driver would
;write to (or read from) in order to draw onto the display when it's
;running in Windows Hi-Res mode.  For example, on the IBM 8514/A display
;card, the hardware BLTer is used to draw onto the screen.  Ports such as
;9AE8H, E2E8H, BEE8H are used on the 8514/A to perform the drawing.  The
;VDD "system" must set I/O port traps on these registers so that we are
;informed that the Windows display driver is writing or reading these
;ports. Only set traps on those ports which the display driver would
;write or read in the process of drawing.
;
; On NV chips, the CRTC extended registers are used, along with the linear
; frame buffer and the 64KB memory mapped channel to the NV chip FIFO.
; The display driver will register the channel and linear frame buffer, but
; we have to register the NV VGA real mode access registers that the BIOS
; uses. These remained trapped while Windows is running, but our port simulator
; routine checks whether it has been called from the Windows VM (in which case it ignores
; the trap) or someone else (it accesses the register).
IFDEF NVIDIA_COMMON
        mov     edx,003D0h              ;register port 003D0h
        mov     ecx,OFFSET32 MiniVDD_VirtualRealModeAccess
        VxDCall VDD_Takeover_VGA_Port
        mov     edx,003D1h              ;register port 003D1h
        mov     ecx,OFFSET32 MiniVDD_VirtualRealModeAccess
        VxDCall VDD_Takeover_VGA_Port
        mov     edx,003D2h              ;register port 003D2h
        mov     ecx,OFFSET32 MiniVDD_VirtualRealModeAccess
        VxDCall VDD_Takeover_VGA_Port
        mov     edx,003D3h              ;register port 003D3h
        mov     ecx,OFFSET32 MiniVDD_VirtualRealModeAccess
        VxDCall VDD_Takeover_VGA_Port
ENDIF ; NVIDIA_COMMON
@@:
        mov             eax, OFFSET32 MiniVDD_BroadcastHandler
        VxDcall _SHELL_HookSystemBroadcast, < eax, 0, 0 >

        ; Hook Int 10 so we can intercept the DDC calls
        mov     eax, 10h
        mov     esi, OFFSET32 MiniVDD_Int10Handler
        VxDcall Hook_V86_Int_Chain
;
; CANOPUS SUPPORT - detect if TV interface is present
;
;   Because we might need to change the CRTC index register we use to support TV, we
;       will get it from the bios and dynamicly handle the one we get.
MVDI_GetCanopusTVIndex:
        push    bx                      ;--- save regs

        mov ax, TVB_VBE_FCT             ; VBE OEM function
        mov     bx, TVB_VBE_TV_CRTC     ; get CRTC index to flag register
        push    010h                    ; call int 0x10
        VMMCall Exec_VxD_Int            ; execute interrupt

        cmp ax, 0004fh                  ; success ???
        je  MVDI_SaveTVIndex            ; yes, go on and save index
        xor bl, bl                      ; just set it to zero to mark, that we don't support it
MVDI_SaveTVIndex:
        mov bCanopusTVReg, bl           ; just save the value

        pop bx                          ;--- restore regs

;
MVDIGoodExit:
        clc                             ;return success
        jmp     MVDIExit                ;
;
MVDIErrorExit:
        stc
;
MVDIExit:
        pop     ebp
        pop     ebx                     ;restore Windows VM handle to EBX
IFDEF DEBUG_LOG
        pushf
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "\n\r", DEBLEVELMAX
                pop     eax
        .endif
        popf
ENDIF ; DEBUG_LOG
        ret
EndProc MiniVDD_Dynamic_Init
;

; Imhoff - Message handler for broadcast messages... We are interested in
; the WM_POWERBROADCAST message in order to do some kind of simple blanking
; of the monitor during suspend/standby... This addresses a problem we have seen
; under Win95 OSR2 where the monitor does not get blanked at all...

; JohnH - besides blanking the screen, which we do in the RM, this also prevents a problem on the Dell Optiplex system:
; a few seconds after going into Suspend, we get a Resume message. Adding this handler prevents us from leaving Suspend
; too soon.
; Apparently the sequence is this: RM gets Suspend (VxD Control message). Mini-VDD gets Suspend (System message).
; RM gets Resume (Control message). Mini-VDD gets another Suspend (System message). The second System Suspend message
; lets us blank the screen again after the RM Resume turned on the screen, so we will suspend until activity causes us
; to get a legitimate Resume.
; This may be a bug in APM in one of the other device's drivers on the Dell Optiplex. It doesn't occur like this on most
; machines.
;--------------------------------------------------------------------------
BeginProc       MiniVDD_BroadcastHandler, DOSVM

ArgVar  dwMessage, DWORD
ArgVar  dwParam, DWORD
ArgVar  dwlParam, DWORD
ArgVar  dwRef, DWORD

                EnterProc

                cmp     ACPI_state,0
                jne     PS_Exit

                cmp     dwMessage, WM_POWERBROADCAST ;218h
                jnz     PS_Exit


                cmp     dwParam, PBT_APMRESUMESUSPEND
                jz      PS_Resume

                cmp     dwParam, PBT_APMSUSPEND
                jz              PS_Suspend

                cmp     dwParam, PBT_APMRESUMESTANDBY
                jz      PS_Resume

                cmp     dwParam, PBT_APMSTANDBY
                jz              PS_Suspend

                jmp     PS_Exit

PS_Suspend:
                
                REG_RD08(NV_PRMCIO_CRX__COLOR)  ; Save Index
                mov ah, al

                mov al, 1Fh                                             ; Unlock Extended Regs
                REG_WR08(NV_PRMCIO_CRX__COLOR)
                mov al, 57h
                REG_WR08(NV_PRMCIO_CRE__COLOR)

                ; Determine what type of display is being driven                
                mov al,28h
                REG_WR08(NV_PRMCIO_CRX__COLOR)
                REG_RD08(NV_PRMCIO_CRE__COLOR)  
                test al,80h
                jz  PS_CRT
                
                mov al,33h
                REG_WR08(NV_PRMCIO_CRX__COLOR)
                REG_RD08(NV_PRMCIO_CRE__COLOR)  
                test al,1h
                jz  PS_TV      ; it's not a DFP, it's a TV
                
                ; It's a DFP                
                push eax
                REG_RD32(NV_PRAMDAC_FP_DEBUG_0)
                or  eax,010000000h                                      ; assert PWRDOWN_FPCLK
                REG_WR32(NV_PRAMDAC_FP_DEBUG_0)
                pop  eax
                jmp skip_nvt1

PS_TV:          ; We need to turn off the TV encoder. This is problematic, so unless we're asked
                ; to do so by a customer, just treat it like a CRT.
                                

PS_CRT:                
                ; If we disable syncs, turn off DAC also
                ; a signal on RGB with syncs off may confuse the CRT
                push eax
                REG_RD32(NV_PRAMDAC_TEST_CONTROL)
                or  eax,00010000h                                       ; assert PWRDWN_DAC
                REG_WR32(NV_PRAMDAC_TEST_CONTROL)
                pop  eax
                                                
                mov al, 1Ah
                REG_WR08(NV_PRMCIO_CRX__COLOR)
                REG_RD08(NV_PRMCIO_CRE__COLOR)  ; Turn Off Vert Sync
                or al, 40h

                ; Canopus/Toshiba workaround due to ACPI patents
                ;
                ; do this always
                ;
                ;test nvCustomer, NVCUSTOMER_TOSHIBA
                ;jnz  skip_nvt1
                or al, 0c0h

skip_nvt1:

                REG_WR08(NV_PRMCIO_CRE__COLOR)

                mov al, 1Fh                                             ; Lock Extended Regs
                REG_WR08(NV_PRMCIO_CRX__COLOR)
                mov al, 0
                REG_WR08(NV_PRMCIO_CRE__COLOR)

                mov al, ah
                REG_WR08(NV_PRMCIO_CRX__COLOR)  ; Restore Index

                jmp             PS_Exit

PS_Resume:
                REG_RD08(NV_PRMCIO_CRX__COLOR)  ; Save Index
                mov ah, al

                mov al, 1Fh                                             ; Unlock Extended Regs
                REG_WR08(NV_PRMCIO_CRX__COLOR)
                mov al, 57h
                REG_WR08(NV_PRMCIO_CRE__COLOR)
                
                ; Determine what type of display is being driven                
                mov al,28h
                REG_WR08(NV_PRMCIO_CRX__COLOR)
                REG_RD08(NV_PRMCIO_CRE__COLOR)  
                test al,80h
                jz  PSR_CRT
                
                mov al,33h
                REG_WR08(NV_PRMCIO_CRX__COLOR)
                REG_RD08(NV_PRMCIO_CRE__COLOR)  
                test al,1h
                jz  PSR_TV      ; it's not a DFP, it's a TV
                
                ; It's a DFP                
                push eax
                REG_RD32(NV_PRAMDAC_FP_DEBUG_0)
                and  eax,0EFFFFFFFh                                      ; deassert PWRDOWN_FPCLK
                REG_WR32(NV_PRAMDAC_FP_DEBUG_0)
                pop  eax
                jmp skip_nvt2

PSR_TV:         ; We need to turn off (in suspend) & on the TV encoder. This is problematic, so unless we're asked
                ; to do so by a customer, just treat it like a CRT.
                                

PSR_CRT:                
                ; power the DAC up
                push eax
                REG_RD32(NV_PRAMDAC_TEST_CONTROL)
                and  eax,0FFFEFFFFh                                     ; deassert PWRDWN_DAC
                REG_WR32(NV_PRAMDAC_TEST_CONTROL)
                pop  eax

                mov al, 1Ah
                REG_WR08(NV_PRMCIO_CRX__COLOR)
                REG_RD08(NV_PRMCIO_CRE__COLOR)
                and al, not 40h

                ; Canopus/Toshiba workaround due to ACPI patents
                ;
                ; do this always
                ;
                ;test nvCustomer, NVCUSTOMER_TOSHIBA
                ;jnz skip_nvt2
                and al, not 0c0h
skip_nvt2:

                REG_WR08(NV_PRMCIO_CRE__COLOR)

                mov al, 1Fh                                             ; Lock Extended Regs
                REG_WR08(NV_PRMCIO_CRX__COLOR)
                mov al, 0
                REG_WR08(NV_PRMCIO_CRE__COLOR)

                mov al, ah
                REG_WR08(NV_PRMCIO_CRX__COLOR)  ; Restore Index

PS_Exit:

                mov             eax, 1

                LeaveProc
                Return

EndProc         MiniVDD_BroadcastHandler

;----------------------------------------
public  MiniVDD_TurnVgaOff
BeginProc       MiniVDD_TurnVgaOff, DOSVM

                push    eax
                push    esi

                ;Disable VGA through the VGA Enable IO register.
                REG_RD08(NV_PRMVIO_VSE2)
                and al,0feh
                REG_WR08(NV_PRMVIO_VSE2)

                ; This comment is only here to fix a line too long compiler error.

                ;Disable NV PCI IO, bit0 = 0.
                REG_RD32(NV_PBUS_PCI_NV_1)
                and     al,0feh
                REG_WR32(NV_PBUS_PCI_NV_1)

                ;Disable NV interrupts.
;                xor     eax,eax
;                REG_WR32(NV_PMC_INTR_EN_0)


                pop     esi
                pop     eax

                ret
EndProc         MiniVDD_TurnVgaOff
;
;----------------------------------------
public  MiniVDD_TurnVgaOn
BeginProc       MiniVDD_TurnVgaOn, DOSVM

                push    eax
                push    esi

                ;Enable NV PCI IO, bit0 = 1.
                REG_RD32(NV_PBUS_PCI_NV_1)
                or      al,01h
                REG_WR32(NV_PBUS_PCI_NV_1)

                ;Enable VGA through the VGA Enable IO register.
                REG_RD08(NV_PRMVIO_VSE2)
                or al,01h
                REG_WR08(NV_PRMVIO_VSE2)

                ;Enable NV interrupts.
                xor     eax,eax
                mov     al,1
                REG_WR32(NV_PMC_INTR_EN_0)

                pop     esi
                pop     eax

                ret
EndProc         MiniVDD_TurnVgaOn

;----------------------------------------
;Entry: none
;Exit:  ax = number of heads (crtc's)
public MiniVDD_GetNumUnits
BeginProc       MiniVDD_GetNumUnits, DOSVM
                pushad
;               Ask the RM how many heads are supported
                mov     ebx, DEFAULT_PRIMARY_HDEV
                mov     eax, NVRM_API_NUM_HEADS     ; load up the function number
                call    CallRM                      ; go to RM's API procedure
                mov     eax,ebx                     ; return in eax
                mov     NumUnits,eax                ; save in static area

;               We cannot run dual heads in VGA mode. Find out if we are in 16 color mode.
                cmp     eax,2                   ; dual CRTC device?
                jl      NumUnitsGotten          ; no, then the mode doesn't matter

;               Get Display Info from VDD
                push    ecx
                push    edi
                mov     eax,OFFSET32 DisplayInfoStructure
                mov     ecx,SIZE DISPLAYINFO    ;pass size in ECX, address in EAX
                mov     [eax].diHdrSize,cx      ;fill in this entry
                push    eax                     ;save EAX --> DisplayInfoStructure
                VxDCall VDD_Get_DISPLAYINFO     ;get information from the VDD
                pop     edi                     ;restore EAX --> DisplayInfoStructure
                mov     VGAModeFlag,0
                cmp     [edi].diBpp,4           ;16 color?
                jne     @f
                mov     VGAModeFlag,0FFh
                mov     NumUnits,1              ;Don't allow dual head if VGA.DRV is running!
@@:
                pop     edi
                pop     ecx
NumUnitsGotten:

                popad
                mov     eax,NumUnits            ;restore eax
                ret
EndProc         MiniVDD_GetNumUnits
;
VxD_ICODE_ENDS
;
;**************************************************************************************************************************
subttl          Dispatch Table for VMM Calling This Mini-VDD
page +
VxD_LOCKED_CODE_SEG
;
;
Begin_Control_Dispatch  MiniVDD
        Control_Dispatch SYS_DYNAMIC_DEVICE_INIT, MiniVDD_Dynamic_Init  ;init function for dynamic VXD
        Control_Dispatch PnP_New_DevNode, MiniVDD_PnP_New_DevNode ;init function for new pnp devnode
;        Control_Dispatch DEVICE_INIT, MiniVDD_Device_Init                              ;init function for static VXD (not us!)
        Control_Dispatch SYSTEM_EXIT, MiniVDD_System_Exit
        Control_Dispatch SYS_VM_TERMINATE, MiniVDD_Sys_VM_Terminate             ;try to release traps here
        Control_Dispatch CREATE_VM, MiniVDD_CreateVM
        Control_Dispatch DESTROY_VM, MiniVDD_DestroyVM


IFDEF DIOC
            Control_Dispatch W32_DEVICEIOCONTROL, MiniVDD_W32_DIOC
ENDIF ;DIOC

End_Control_Dispatch MiniVDD
;

PUBLIC  MiniVDD_GetMonitorInfo
BeginProc       MiniVDD_GetMonitorInfo,CCALL
ArgVar  pDevNode, DWORD
ArgVar  nUnitNum, DWORD
ArgVar  pEdidBuf, DWORD

        EnterProc
        push    ebx
        push    ecx
        push    edx
        push    esi
        push    edi

        ; Stop enumeration if there is no heads anymore.
        mov     ecx,nUnitNum
        cmp     ecx,NumUnits
        mov     eax,CR_FAILURE
        jge     DoneGMI

        ; Use the logical unit number to get the physical head from
        ; the LogicalDevice table.
        lea     ebx,LogicalDevice
        shl     ecx,2
        mov     ecx,ds:[ebx + ecx]

        ; Let Windows gets EDID from the ZERO head only once.
        ; This allow Windows to show RRates list in
        ; the property page -> settings -> adapter tab.
        cmp     GetMonInfoCount,-1
        jne     @F

        ; Provide the head number for Int10Handler
        mov     GetMonInfoCount,ecx

        ; Force VESAReadEDID call
        mov     eax,CR_DEFAULT
        jmp     DoneGMI
@@:
        ; ecx = Head number
        push    pEdidBuf
        push    ecx
        push    pDevNode
        call    GetEdidAndRemapIt
        add     esp,0CH

DoneGMI:
        pop     edi
        pop     esi
        pop     edx
        pop     ecx
        pop     ebx
        LeaveProc
        Return
EndProc MiniVDD_GetMonitorInfo


PUBLIC  GetEdidAndRemapIt
BeginProc       GetEdidAndRemapIt,CCALL
ArgVar  pDevNode, DWORD
ArgVar  nPhysHeadNum, DWORD
ArgVar  pEdidBuf, DWORD

        EnterProc
        push    ebx
        push    ecx
        push    edx
        push    esi
        push    edi

        mov     eax,NVRM_API_READ_EDID
        mov     ebx,DEFAULT_PRIMARY_HDEV
        mov     ecx,nPhysHeadNum
        call    CallRM

        ; Returns a ptr to the EDID in eax. If NULL, no EDID
        or      eax,eax
        je      ZeroEdid

        push    pEdidBuf
        push    eax
        call    CopyEdidOrTranslate2To1
        add     esp,8
        cmp     eax,CR_SUCCESS
        jne     ZeroEdid

        ; If the AllowMightyModes key exists, then we munge the EDID.
        ; We keep the manufacturer, etc, but change the EDID so that
        ; pretty much any mode is OK.

        push    pDevNode
        call    BuildDisplayPathXXXX
        add     esp,4

        ; Copy the path "System\CurrentControlSet....\Display\000X"
        ; into szAndMore
        lea     edx,szLocalDisplayPath
        lea     ebx,szAndMore
@@:     mov     al,[edx]
        inc     edx
        mov     [ebx],al
        inc     ebx
        or      al,al
        jne     @B

        ; Now tack on the "Display" path
        dec     ebx
        mov     byte ptr ds:[ebx + 00],'\'
        mov     byte ptr ds:[ebx + 01],'N'
        mov     byte ptr ds:[ebx + 02],'V'
        mov     byte ptr ds:[ebx + 03],'i'
        mov     byte ptr ds:[ebx + 04],'d'
        mov     byte ptr ds:[ebx + 05],'i'
        mov     byte ptr ds:[ebx + 06],'a'
        mov     byte ptr ds:[ebx + 07],'\'
        mov     byte ptr ds:[ebx + 08],'D'
        mov     byte ptr ds:[ebx + 09],'i'
        mov     byte ptr ds:[ebx + 10],'s'
        mov     byte ptr ds:[ebx + 11],'p'
        mov     byte ptr ds:[ebx + 12],'l'
        mov     byte ptr ds:[ebx + 13],'a'
        mov     byte ptr ds:[ebx + 14],'y'
        mov     byte ptr ds:[ebx + 15],0

        mov     hKey,0
        mov     esi,OFFSET szAndMore
        mov     eax,OFFSET hkey
        VMMCall _RegOpenKey, <HKEY_LOCAL_MACHINE,esi,eax>
        or      eax,eax
        mov     eax,CR_SUCCESS
        jne     DoneGER

        ; Now Read the display sub path
        mov     dwAllowMightyModes,0
        mov     dwCBType,REG_BINARY
        mov     dwCBLen,4
        mov     eax,OFFSET dwCBType
        mov     ebx,OFFSET dwAllowMightyModes
        mov     ecx,OFFSET dwCBLen
        mov     edx,OFFSET szAllowMightyModes
        VMMCall _RegQueryValueEx, <hKey, edx, 0, eax, ebx, ecx>

        ; CLose the key and zero it out.
        VMMCall _RegCloseKey, <hKey>
        mov     hKey,0

        ; So did we get back something non-0?
        mov     eax,CR_SUCCESS
        cmp     dwAllowMightyModes,0
        je      DoneGER

        ; OK, to allow all modes, we must dummy up an EDID
        push    pEdidBuf
        call    BuildMightyVersion1Edid
        add     esp,4
        mov     eax,CR_SUCCESS
        jmp     DoneGER

ZeroEdid:
        ; OK, we didn't get and EDID for this head. Unfortunately,
        ; we can't return CR_FAILURE in this case since I have
        ; found that if we return CR_FAILURE for nUnitNum=0, then
        ; we don't even get called for nUnitNum=1 (even if we are
        ; on a multihead board.) So, zero out the EDID buffer and
        ; return CR_SUCCESS.
        mov     ecx,80H / 4
        sub     eax,eax
        mov     edi,pEdidBuf
        rep     stosd
        mov     eax,CR_SUCCESS

DoneGER:
        pop     edi
        pop     esi
        pop     edx
        pop     ecx
        pop     ebx
        LeaveProc
        Return
EndProc GetEdidAndRemapIt


PUBLIC  CopyEdidOrTranslate2To1
BeginProc CopyEdidOrTranslate2To1,CCALL
ArgVar  pSrcBuf, DWORD
ArgVar  pDstBuf, DWORD

        EnterProc
        push    esi
        push    edi

        ; We got an EDID. The main VDD can only handle Version 1
        ; EDIDs, though, so if this is a version 2, then convert
        ; it to a version 1.
        mov     esi,pSrcBuf
        lea     edi,EDID1_HEADER
        mov     edx,esi
        mov     ecx,8
        repe    cmpsb
        je      DO_CopyEdid1
        cmp     byte ptr [edx],2
        je      DO_XlatEdid2

        ; Neither kind so return failure.
        mov     eax,CR_FAILURE
        jmp     Done_COT

DO_CopyEdid1:
        ; Copy EDID from SrcBuf to Dst Buf
        mov     esi,pSrcBuf
        mov     edi,pDstBuf
        mov     ecx,80H
        rep     movsb
        mov     eax,CR_SUCCESS
        jmp     Done_COT

DO_XlatEdid2:
        push    pDstBuf
        push    pSrcBuf
        call    TranslateEdid2ToEdid1
        add     esp,8
        mov     eax,CR_SUCCESS

Done_COT:
        pop     edi
        pop     esi
        LeaveProc
        Return
EndProc CopyEdidOrTranslate2To1


PUBLIC  TranslateEdid2ToEdid1
BeginProc TranslateEdid2ToEdid1,CCALL
ArgVar  pSrcBuf, DWORD
ArgVar  pDstBuf, DWORD

        EnterProc
        push    esi
        push    edi

        ; For xlatting, do minimum work needed to make VDD happy.
        ; This includes the product/vendor ID and some detailed timings.

        ; copy template
        mov     edi,pDstBuf
        mov     esi,offset32 EdidTemp
        mov     ecx,EDID1_SIZE
        rep     movsb

        ; copy vendor/product ID
        mov     esi,pSrcBuf
        mov     edi,pDstBuf
        mov     ax,[esi+EDID2_VENDOR]
        mov     [edi+EDID1_VENDOR],ax

        ; Copy detailed timings.
        ; We have to parse a bunch of fields to find them first.
        ; map of timing info tells where to start

        mov     ax,[esi+EDID2_MAP]
        mov     Edid2Map,ax
        mov     ecx,EDID2_TIMING_START

        ; any lum tables?
        test    al, EDID2_LUM_TABLE_EXIST
        jz      AEdid_rl

        ; advance beyond lum table
        mov     ah,[esi+ecx]            ; get 1st byte of timing table
        mov     al,ah
        and     al,EDID2_LUM_ENTRIES    ; get # of lum tables entries
        test    ah,EDID2_LUMX3          ; triple lum tables?
        jz      @f
        mov     bl,3
        mul     bl                      ; triple entries
@@:     add     al,1                    ; bump index beyond lum table
        add     cl,al

AEdid_rl:
        mov     ax,Edid2Map
        and     al,EDID2_RL             ; any range limits?
        jz      AEdid_drl

        ; advance beyond range limits
        shr     al,EDID2_RL_SHIFT
        mov     bl,8
        mul     bl                      ; 8-byte range limits
        add     cl,al

AEdid_drl:
        mov     ax,Edid2Map
        test    al,EDID2_DRL            ; any detailed range limits?
        jz      AEdid_tc

        ; advance beyond detailed range limits
        and     al,EDID2_DRL
        mov     bl,27
        mul     bl                      ; 27-byte detailed range limits
        add     cl,al

AEdid_tc:
        mov     ax,Edid2Map             ; get 2nd byte of map
        and     ah,EDID2_TIMING_CODES
        jz      AEdid2_dt
        shr     ah,EDID2_TC_SHIFT
        mov     al,ah
        mov     bl,4
        mul     bl                      ; 4-byte timing codes
        add     cl,al

AEdid2_dt:
        ; now we are finally at the detailed timings
        mov     ax,Edid2Map
        and     ah,EDID2_DET_TIMINGS
        mov     al,ah
        mov     bl,18
        mul     bl                      ; 18-byte detailed timings
        mov     nDetTim,al
        mov     DetTimOff,cx            ; offset within edid2 struct
                                        ;   to detailed timings

        ; copy all detailed timings to edid1
        add     edi,EDID1_DET_TIMING    ; point to edid1 detailed timings
        add     esi,ecx                 ; point to edid2 detailed timings
        xor     ecx,ecx
        mov     cl,nDetTim
        rep     movsb

        ; generate 8 bit checksum
        mov     ecx,EDID1_SIZE
        mov     edi,pEdid1
        xor     ax,ax
AEdidCs:
        add     al,[edi+ecx-1]
        loop    AEdidCs
        neg     al
        mov     [edi+EDID1_SIZE-1],al

        pop     edi
        pop     esi
        LeaveProc
        Return
EndProc TranslateEdid2ToEdid1

; We currently have a version 1 EDID.
; Change it so that it says it can do pretty much any mode.
; Let's try making one of the timing descriptors handle anything.
PUBLIC  BuildMightyVersion1Edid
BeginProc BuildMightyVersion1Edid,CCALL
ArgVar  pEdidBuf, DWORD

        EnterProc
        push    ebx
        push    esi
        push    edi

        ; ebx should point to first of 4 detailed desc
        mov     ebx,pEdidBuf
        add     ebx,36H

        ; Change a detailed timing to something big
        ; We have to parse a bunch of fields to find them first.
        ; map of timing info tells where to start

        ; In Version 1 EDIDs, the detailed timing desc / Monitor desc
        ; begins at offset 36H.  There are 4 of them and each one is
        ; 12H bytes long.

        sub     ecx,ecx
        mov     edx,0FF00H

LoopOnDesc:
        ; if the desc is of type FD (monitor range limits),
        ; then replace with our MIGHTY range limits

        ; If this is a detailed timing and not a special desc
        ; then skip it.
        mov     eax,ds:[ebx]
        and     eax,0FFFFFFH
        je      CheckDescriptor

        ; Replace the detailed timing with a detailed timing for
        ; 2048x1536@60Hz. Please note this is a GTF timing.
        mov     byte ptr ds:[ebx + 00H], 047H
        mov     byte ptr ds:[ebx + 01H], 068H
        mov     byte ptr ds:[ebx + 02H], 000H
        mov     byte ptr ds:[ebx + 03H], 0F0H
        mov     byte ptr ds:[ebx + 04H], 082H
        mov     byte ptr ds:[ebx + 05H], 000H
        mov     byte ptr ds:[ebx + 06H], 035H
        mov     byte ptr ds:[ebx + 07H], 060H
        mov     byte ptr ds:[ebx + 08H], 013H
        mov     byte ptr ds:[ebx + 09H], 0E0H
        mov     byte ptr ds:[ebx + 0AH], 013H
        mov     byte ptr ds:[ebx + 0BH], 000H
        jmp     NextDesc

CheckDescriptor:
        ; Speical desc -- but what type?
        cmp     dword ptr ds:[ebx],0FD000000H
        jne     NotFD

        mov     byte ptr ds:[ebx + 00H], 000H
        mov     byte ptr ds:[ebx + 01H], 000H
        mov     byte ptr ds:[ebx + 02H], 000H
        mov     byte ptr ds:[ebx + 03H], 0FDH
        mov     byte ptr ds:[ebx + 04H], 000H
        mov     byte ptr ds:[ebx + 05H], 03CH ; min vert in hertz
        mov     byte ptr ds:[ebx + 06H], 0C8H ; max vert in hertz
        mov     byte ptr ds:[ebx + 07H], 018H ; min horz in KHZ
        mov     byte ptr ds:[ebx + 08H], 064H ; max horz in KHZ
        ; max pix clock in MHZ / 10 so 28H = 400MHZ
        mov      byte ptr ds:[ebx + 09H], 028H
        mov      byte ptr ds:[ebx + 0AH], 000H
        mov      byte ptr ds:[ebx + 0BH], 00AH
        mov      byte ptr ds:[ebx + 0CH], 020H
        mov      byte ptr ds:[ebx + 0DH], 020H
        mov      byte ptr ds:[ebx + 0EH], 020H
        mov      byte ptr ds:[ebx + 0FH], 020H
        mov      byte ptr ds:[ebx + 10H], 020H
        mov      byte ptr ds:[ebx + 11H], 020H
        mov     dl,1

NotFD:
        cmp     dword ptr ds:[ebx],00F900000H
        je      @F
        cmp     dword ptr ds:[ebx],00FB00000H
        jne     NextDesc
@@:     mov     dh,cl

NextDesc:
        add     ebx,12H
        inc     ecx
        cmp     ecx,4
        jb      LoopOnDesc

        ; Did we replace a range desc with the new one?
        or      dl,dl
        jne     DoneFD

        ; No, we didn't. We need to replace some other desc.
        ; Did we find one that we can replace?
        cmp     dh,0FFH
        je      DoneFD

        ; dh holds the index of the desc which we can use
        sub     ebx,4 * 12H
        movzx   edx,dl
        imul    edx,12H
        add     ebx,edx
        mov     byte ptr ds:[ebx + 00H], 000H
        mov     byte ptr ds:[ebx + 01H], 000H
        mov     byte ptr ds:[ebx + 02H], 000H
        mov     byte ptr ds:[ebx + 03H], 0FDH
        mov     byte ptr ds:[ebx + 04H], 000H
        mov     byte ptr ds:[ebx + 05H], 03CH ; min vert in hertz
        mov     byte ptr ds:[ebx + 06H], 0C8H ; max vert in hertz
        mov     byte ptr ds:[ebx + 07H], 018H ; min horz in KHZ
        mov     byte ptr ds:[ebx + 08H], 064H ; max horz in KHZ
        ; max pix clock in MHZ / 10 so 28H = 400MHZ
        mov      byte ptr ds:[ebx + 09H], 028H
        mov      byte ptr ds:[ebx + 0AH], 000H
        mov      byte ptr ds:[ebx + 0BH], 00AH
        mov      byte ptr ds:[ebx + 0CH], 020H
        mov      byte ptr ds:[ebx + 0DH], 020H
        mov      byte ptr ds:[ebx + 0EH], 020H
        mov      byte ptr ds:[ebx + 0FH], 020H
        mov      byte ptr ds:[ebx + 10H], 020H
        mov      byte ptr ds:[ebx + 11H], 020H

DoneFD:
        ; Now we need to checksum the EDID.
        mov     ebx,pEdidBuf
        mov     cx,7FH
        sub     al,al

ChecksumEdid:
        add     al,byte ptr ds:[ebx]
        inc     ebx
        loop    ChecksumEdid

        neg     al
        mov     byte ptr ds:[ebx],al

        pop     edi
        pop     esi
        pop     ebx
        LeaveProc
        Return

EndProc BuildMightyVersion1Edid


PUBLIC  BuildDisplayPathXXXX
BeginProc BuildDisplayPathXXXX,CCALL
ArgVar  pDevNode, DWORD

        EnterProc
        push    ebx
        push    esi
        push    edi
        mov     ebx,pDevNode

    ; Get the correct display path in the registry
    mov     eax,[ebx + 4]
    mov     esi,OFFSET szAndMore

    ; eax now points to a string that we concatenate onto
    ; "Enum\\".  We look up this path in HKEY_LOCAL_MACHINE
@@: mov     cl,[eax]
    inc     eax
    mov     [esi],cl
    inc     esi
    or      cl,cl
    jne     @B

    ; Now open the key
    mov     hKey,0
    mov     esi,OFFSET szEnumAndMore
    mov     eax,OFFSET hkey
    VMMCall _RegOpenKey, <HKEY_LOCAL_MACHINE,esi,eax>
    or      eax,eax
    jne     UseDefaultKey

    ; Now Read the display sub path
    mov     szDisplayEndPath,0
    mov     dwCBType,REG_SZ
    mov     dwCBLen,32
    mov     eax,OFFSET dwCBType
    mov     ebx,OFFSET szDisplayEndPath
    mov     ecx,OFFSET dwCBLen
    mov     edx,OFFSET szDriver
    VMMCall _RegQueryValueEx, <hKey, edx, 0, eax, ebx, ecx>

    ; CLose the key and zero it out.
    VMMCall _RegCloseKey, <hKey>
    mov     hKey,0

    ; Now, did we get a valid string (like "DISPLAY\0005")
    cmp     szDisplayEndPath,0
    je      UseDefaultKey

    ; Make the complete path
    mov     eax,OFFSET szDisplayEndPath
    mov     ebx,OFFSET szLocalDisplayPathEnd
@@:
    mov     cl,[eax]
    inc     eax
    mov     [ebx],cl
    inc     ebx
    or      cl,cl
    jne     @B
    jmp     GotRegPath

UseDefaultKey:
    mov     eax,OFFSET szLocalDisplayPathEnd
    mov     dword ptr [eax + 0],'PSID'
    mov     dword ptr [eax + 4],'\YAL'
    mov     dword ptr [eax + 8],'0000'
    mov     byte ptr [eax + 12],0

GotRegPath:
        pop     edi
        pop     esi
        pop     ebx
        LeaveProc
        Return
EndProc BuildDisplayPathXXXX


PUBLIC  MiniVDD_CreateVM
BeginProc MiniVDD_CreateVM
        mov     eax,pfnLockOffscreen
        mov     pfnCurrentCall,eax
        call    NestedCallBack
        ret
EndProc MiniVDD_CreateVM

PUBLIC  MiniVDD_DestroyVM
BeginProc MiniVDD_DestroyVM
        mov     eax,pfnUnlockOffscreen
        mov     pfnCurrentCall,eax
        call    NestedCallBack
        ret
EndProc MiniVDD_DestroyVM


;==============================================================================
;
; Function:     DisplayDriverPowerUp
;
; Purpose:      This function call GN_PowerOn routine of display driver
;
; Arguments:    None
;
; Returns:      None
;==============================================================================
PUBLIC  DisplayDriverPowerUp
BeginProc DisplayDriverPowerUp
        mov     eax,pfnPowerOn
        mov     pfnCurrentCall,eax
        call    NestedCallBack
        ret
EndProc DisplayDriverPowerUp


;==============================================================================
;
; Function:     DisplayDriverPowerDown
;
; Purpose:      This function call GN_PowerOff routine of display driver
;
; Arguments:    None
;
; Returns:      None
;==============================================================================
PUBLIC  DisplayDriverPowerDown
BeginProc DisplayDriverPowerDown
        mov     eax,pfnPowerOff
        mov     pfnCurrentCall,eax
        call    NestedCallBack
        ret
EndProc DisplayDriverPowerDown


;==============================================================================
;
; Function:     FlashOffscreenBitmaps
;
; Purpose:      This function moves offscreen bitmaps into system memory
;
; Arguments:    None
;
; Returns:      None
;==============================================================================
PUBLIC  FlashOffscreenBitmaps
BeginProc FlashOffscreenBitmaps
        mov     eax,pfnLockOffscreen
        mov     pfnCurrentCall,eax
        call    NestedCallBack
        ret
EndProc FlashOffscreenBitmaps



; Function:     NestedCallBack
;
; Purpose:      This function simulates a far jump in a nested
;               execution block.
;
; Arguments:    None
;
; Returns:      None
;==============================================================================
PUBLIC NestedCallBack
BeginProc NestedCallBack
        pushad

        ; If we are not in the system VM, then we cannot do this!
        ; Unfortunately, then the offscreen allocations will not be
        ; flushed and there may be problems. However, I have never
        ; seen this occur. It appears that whenever we get a CreateVM
        ; or DestroyVM message and this routine gets called, that
        ; we are always in the system VM, so everything should be cool.

        VMMCall Get_Cur_VM_Handle
        push    ebx

        VMMCall Get_Sys_VM_Handle
        pop     eax

        cmp     ebx,eax
        jne     DoneNC
        cmp     dwCallbacksSelector,0
        je      DoneNC
        cmp     pfnCurrentCall,0
        je      DoneNC

        ; Save the client state and unlock all critical sections
        ; so we can get back into ring-3 code
        Push_Client_State
        VMMCall Begin_Nest_Exec

        ; Call the lock or unlock routine
        mov     ecx,dwCallbacksSelector
        mov     edx,pfnCurrentCall
        VMMCall Simulate_Far_Call
        VMMCall Resume_Exec

        ; Restore the critical section status and the execution state
        VMMCall End_Nest_Exec
        Pop_Client_State

DoneNC:
        popad
        clc
        ret

EndProc NestedCallBack


;******************************************************************************
;
;   GetBusDeviceAndFunctionNumber
;
;   DESCRIPTION:
;       Locates the device on the PCI Bus and returns the Bus, Device and Function Numbers.
;
;   ENTRY:
;       EBX = nvPhys
;       ECX = fbPhys
;       EDX = nvIRQ
;
;   EXIT:
;       EAX = EDX will now contain the needed info.
;         EDX xxxxxxxx xxxxxxxx xxxxx  xxx  xxxxxxxx
;             00000000    Bus # Device Func        IRQ # 
;
;   USES:
;       Can use all registers and flags
;
;==============================================================================
BASE0_OFFSET EQU 10h
BASE1_OFFSET EQU 14h
IRQ_OFFSET       EQU 3ch
BeginProc GetBusDeviceAndFunctionNumber

  local bus_number:BYTE
  local device_number:BYTE
  local function_number:BYTE
  local base0:DWORD
  local base1:DWORD
  local irq:BYTE
  local return_val:DWORD

  pushad

  mov   base0, ebx
  mov   base1, ecx
  mov   irq, dl
  ; Check all buses devices and functions for the memory windows and IRQ input.
  mov   bus_number,0
  .repeat
    mov   device_number,0
    .repeat
      mov   function_number,0
      .repeat
        ; Read the PCI bus and check if we have a match.
        xor   eax,eax
        mov   al, bus_number
        shl   eax,16
        mov   ah, device_number
        shl   ah,3
        or    ah, function_number
        mov   al, BASE0_OFFSET
        or    eax, 80000000h           ; eax will now contain the configuration address for the PCI read.
        ReadPCI                                ; Returns the Dword read from the PCI Config space in edx.
        and   dl,0
        .if(edx == base0)
          mov   al, BASE1_OFFSET
          ReadPCI                                  ; Returns the Dword read from the PCI Config space in edx.
          and   dl,0
          .if(edx == base1)
            mov   al, IRQ_OFFSET
            ReadPCI                                ; Returns the Dword read from the PCI Config space in edx.
            .if(dl == irq)
              ; WOW ! It works. Lets get out and return this stuff
              and   eax,00FFFF00h          ; AND off the config bit and offset.
              mov   al, irq                        ; OR in the irq
              mov   return_val, eax
              jmp   we_gots_a_match
            .endif
          .endif
        .endif
        inc   function_number
      .until function_number == 08h
      inc   device_number
    .until device_number == 01fh
    inc   bus_number
  .until bus_number == 0ffh

  mov  return_val,-1

  we_gots_a_match:
  exit_out:

  popad
  mov  edx, return_val
  ret

EndProc   GetBusDeviceAndFunctionNumber

;==============================================================================
;   DoConfigStart
;
;   DESCRIPTION:
;       Handles the CONFIG_START message.
;
;   ENTRY:
;       EBX = Devnode handle
;
;   EXIT:
;       EAX = CR_RESULT
;
;   USES:
;       Can use all registers and flags
;
;==============================================================================

BeginProc DoConfigStart

    .ERRNZ  SIZE Config_Buff_s MOD 4

    sub     esp, SIZE Config_Buff_s
    mov     edi, esp                ; alloc buffer on stack

    xor eax, eax
    cmp ConfigStartDone, 0
    jne DoConfigStartDone

    mov     dwDisplayDevnodeHandle,ebx

;   call the Configuration Manager to get the device config.
    
    VxDcall _CONFIGMG_Get_Alloc_Log_Conf, <edi, ebx, CM_GET_ALLOC_LOG_CONF_ALLOC>
    test    eax, eax
    jz      @F
    Debug_Out "MiniVDD:  Unexpected config manager error #EAX"
    jmp     DoConfigStartDone

@@:
    push        ebx
    call        BuildDisplayPathXXXX
    add         esp,4

;   We got the device config; now parse the info and call the resource manager to map it.

    ;mov    esi, [dwRefData]        ; ESI -> adapter reference data

    ;
    ; Our device should be given four or five memory windows
    ;
    ;   two for VGA (A0000 and B0000)
    ;   two for the PCI Bars (NV and FB)
    ;   one for AGP aperture/ROM (optional)
    ;
    ; We should find NV at index 2 and FB at index 3, but let's
    ; parse to make sure.
    ;
    xor             ebx,ebx
start_1:    
    ; starting with NV 4.5, we may optionally have a 32 MB fb 
    ; NV10 goes up to 128MB, so we'll check for that size too
    cmp     [edi.dMemLength][ebx*4], 08000000h      ; don't expect to find fb first, but just in case
    je      found_fb
    cmp     [edi.dMemLength][ebx*4], 02000000h      ; don't expect to find fb first, but just in case
    je      found_fb
    cmp     [edi.dMemLength][ebx*4], 01000000h
    je      @F
    inc     ebx
    cmp     bx, [edi.wNumMemWindows]
    jl      start_1
    mov     eax, CR_DEVICE_NOT_THERE
    jmp     DoConfigStartDone

@@:
    ;
    ; Found a 16meg window.  Which one is it?
    ; We should always find nv first and fb second--this is the order in the PCI config
    ; The config manager doesn't always return attrib = 5 (prefetchable) for fb, although this is set in PCI space,
    ; so we won't depend on it.
    ; We will test which window is which by reading some nv register in InitMapping (in the resource manager).
;   cmp     [edi.wMemAttrib][ebx*2], 0005h
    mov     eax, [edi.dMemBase][ebx*4]
;   je      @F
    mov     nvPhys, eax                ; nv has attrib of 1
    jmp     short start_2

; 32 or 128MB window -- must be fb
found_fb:
    mov     eax, [edi.dMemBase][ebx*4]
    mov     fbPhys, eax                ; fb has attrib of 5 (PF)
    mov     eax, [edi.dMemLength][ebx*4]
    mov     fbLength, eax
    
start_2:
    ;
    ; Find the next nv window
    ;
    inc     ebx
    cmp     bx, [edi.wNumMemWindows]    ; at end?
    jl      @F
    mov     eax, CR_DEVICE_NOT_THERE    ; fail
    jmp     DoConfigStartDone
@@:
    cmp     [edi.dMemLength][ebx*4], 08000000h      ; NV10
    je      @f
    cmp     [edi.dMemLength][ebx*4], 04000000h      ; NV20
    je      @f
    cmp     [edi.dMemLength][ebx*4], 02000000h      ; NV5
    je      @f
    cmp     [edi.dMemLength][ebx*4], 01000000h      ; NV4
    jne     start_2
    ;
    ; Found another 16meg window.  Which one is it?
    ;
@@:
; Don't count on attrib = 5! (might be fixed in Win98 final)
;    cmp     [edi.wMemAttrib][ebx*2], 0005h
    mov     eax, [edi.dMemBase][ebx*4]
;    je      @F
;       jne             @f                                                      ; yes, it must be fb
;    mov     _nvPhys, eax                ; nv has attrib of 1
;    jmp     short start_3
    cmp     fbPhys, 0
    je      @f
    mov     nvPhys, eax                 ; fb first!
    jmp     start_3
;   fb second (expected)
@@:
    mov     fbPhys, eax
    mov     eax, [edi.dMemLength][ebx*4]
    mov     fbLength, eax
        
start_3:
    ;
    ; We now have our two memory windows.  Let's look for the IRQ.
    ;
    cmp     [edi.wNumIRQs], 1
    je      @F
    mov     eax, CR_DEVICE_NOT_THERE    ; more than one irq?  ooops.
    jmp     DoConfigStartDone
@@:
    xor     eax, eax
    mov     al, [edi.bIRQRegisters][0]
    mov     nvIRQ, eax

;       check that we got something (shouldn't ever be 0 unless PCI error)
    mov     eax, CR_DEVICE_NOT_THERE    ; assume failure
    cmp     nvPhys, 0
    jz      DoConfigStartDone
    cmp     fbPhys, 0
    jz      DoConfigStartDone
    cmp     nvIRQ, 0
    jz      DoConfigStartDone

;
;   Map the physical addresses to linear addresses and install interrupt
;   Addresses should be in correct order, but we'll check in InitMapping.
map_config:

;   make a c-type call: ResManAPI(func, addr1, addr2, irq)
    push    ebx
    push    ecx
    push    edx
    push    edi
    push    esi
    mov     esi, offset32 MiniVDD_PostCRTCModeChange
    mov     edx, nvIRQ
    mov     ecx, fbPhys
    mov     ebx, nvPhys                                     ; pass physical config to RM
    ; Before we initialize in the RM, Lets pass in the Bus, Device and Function numbers along with the IRQ.
    ; This will be helpful later when we may need to turn on the device.
    ; This function will fill edx with the PCI bus, device and function info along with the IRQ.
    call    GetBusDeviceAndFunctionNumber
    mov     eax, fbLength
    shr     eax, 16
    or      ecx, eax                    ; put the upper word of the length (ie # of 64k blocks) in the lower word
    
    mov     eax, esi
    mov     esi, offset callrm_struct
    mov     dword ptr [esi].minivdd_RM_Parameter_Struct.callrm_device_handle, 1
    mov     dword ptr [esi].minivdd_RM_Parameter_Struct.callrm_modechange_callback, eax
    mov     dword ptr [esi].minivdd_RM_Parameter_Struct.callrm_irq_bus, edx
    mov     dword ptr [esi].minivdd_RM_Parameter_Struct.callrm_fbphys, ecx
    mov     dword ptr [esi].minivdd_RM_Parameter_Struct.callrm_nvphys, ebx
    lea     eax, szLocalDisplayPath
    mov     dword ptr [esi].minivdd_RM_Parameter_Struct.callrm_registry_path, eax

    mov     nvAddr, ebx                                     ; return with logical address to NV
    mov     hDev, ecx                   ; and a RM handle to the device.
    mov     fbAddr, edx                                     ; and a logical address to framebuffer
    mov     nvCustomer, edi             ; and a bitmask of customers
            
    mov     ebx, DEFAULT_PRIMARY_HDEV
    mov     eax, NVRM_API_INIT          ; load up the function number
    call    CallRM                      ; go to RM's API procedure
                                        ; do mapping to logical addresses and installing interrupt      
    mov     nvAddr, ebx                 ; return with logical address to NV
    mov     hDev, ecx                   ; and a RM handle to the device.
    mov     fbAddr, edx                 ; and a logical address to framebuffer
    mov     nvCustomer, edi             ; and a bitmask of customers
    mov     fpDDC, esi                  ; and the location of the flat panel's DDC port
    inc     numDevice                   ; track the number of times called
    pop     esi
    pop     edi
    pop     edx
    pop     ecx
    pop     ebx

    cmp     eax, RM_OK                                      
    je      @F                          ; Success.
    
    mov     eax, CR_INVALID_LOG_CONF
    jmp     DoConfigStartDone
    
@@:
    ;
    ; Everything is as it should be!!
    ;

        ; Leave comment in to handle assembler problmem

    REG_RD32(NV_PMC_BOOT_0)
    ; Decide what type of chip this is
    shr     ax, 12          ; no equates for NV4 in include yet
    cmp     ax, 4           ; is it NV4?
    jne     @f
    mov     ChipType,4      ; this won't be right for NV10, but it also doesn't look used
@@:
;
; CANOPUS TV Programming Change -- only use if customer is Canopus
;
;;   We switching off the INACTIVE bit off the "our" TV_FLAG_REGISTER in the BIOS
;;       because in VGA mode the bios should initialize (or switch off) the Chrontel
;;       It seems that if the driver does this, this will be to be to late...
;
        test nvCustomer, NVCUSTOMER_CANOPUS
        jz   PHRTV_NoCanopus01

        mov     al, bCanopusTVReg       ;-- first check, if the BIOS supports Canopus TV
        or      al, al                  
        jz      PHRTV_NoCanopus01       ; no, not supported

        call    GetCRTCPort             ;-- first unlock the registers
        mov     ax, 0571fh              ; (nobody knows what the heck the RM does...:-)
        out     dx, ax
        call    GetCRTCPort             ;-- next read TV Flag register
        mov     edi,ebx                 ;get pointer to our CB data area
        add     edi,OurCBDataPointer    ;EDI --> our CB data area for this VM
        mov     ah,[edi].PerVMData.EXT_CanopusTVReg
        test    ah, 040h                ; already initialized ???
        jnz @F                          ; yes, go on

        mov al, bCanopusTVReg           ; else get the current register contents
        out dx, al
        inc dx          
        in      al, dx
        dec dx
        mov ah, al                      ; and modify this one...
@@:
        and ah, 07fh                    ; clear the INACTIVE flag (TV_FLAG_REGISTER)
        mov al, bCanopusTVReg                   
        out dx, ax                      ; and write the new value back...
        jmp short PHRTV_NoCanopus02
        
PHRTV_NoCanopus01:
;
PHRTV_NoCanopus02:     

        ; Initialize LogicalDevice structure.
        ; LPL - pretty sure these regs aren't in use at this point,
        ; but I'm gonna push/pop 'em anyway
        push    eax
        push    ebx
        push    ecx
        push    edx

        lea     edi,LogicalDevice
        sub     ecx,ecx

@@:
IF 0
        mov     [edi],ecx       ;old way: just initialize with index
ELSE
        mov     eax, NVRM_API_DISPLAY_GET_BOOT_PHYS_MAP
        mov     ebx, DEFAULT_PRIMARY_HDEV
        push    ecx                                                     ; use counter as lookup index
        push    edi
        call    CallRM                      ; go to RM's API procedure
        pop             edi
        pop             ecx
        mov     [edi],eax                   ; return in eax
ENDIF
        inc     ecx
        add     edi,4
        cmp     ecx,MAX_CRTCS
        jb      @B

        pop             edx
        pop             ecx
        pop             ebx
        pop             eax


;We might never get the SaveMessageModeState call if running Win98, because of a bug. We should save registers here,
;because the current mode will correspond to message mode. Is this true for far east versions as well? (mode 12).
    push    ebx
    mov     ebx, WindowsVMHandle        ;save regs to system VM CB data
    call    MiniVDD_SaveRegisters
    call    MiniVDD_SaveMessageModeState ;copy to message mode VM CB data
    pop     ebx
    
    mov ConfigStartDone, 1
    mov eax, CR_SUCCESS
    
;       end up here after success or fail
DoConfigStartDone:
    add     esp, SIZE Config_Buff_s                 ; adjust stack
    cmp     eax, CR_SUCCESS
    je      DoConfigStartExit

DoConfigStartError:
    mov nvPhys, 0
    mov fbPhys, 0
    mov nvIRQ,  0
    Debug_Out "MiniVDD:  MiniVDD PnP_New_Devnode failed"
    stc
DoConfigStartExit:
    ret

EndProc DoConfigStart

;******************************************************************************
;
;   MiniVDD_PnP_New_DevNode
;
;   DESCRIPTION:
;       Handles system control calls for PnP_NEW_DEVNODE.  This routine
;       allocates the reference data for the adapter, and registers as the
;       driver for the devnode.
;
;   ENTRY:
;       EBX = Devnode handle
;       EDX = Subfunction (should always be LOAD_DRIVER)
;
;   EXIT:
;       EAX = CR_RESULT
;
;   USES:
;       Can use all registers and flags
;
;==============================================================================

BeginProc MiniVDD_PnP_New_DevNode

        cmp     edx, DLVXD_LOAD_DRIVER  ; Q: Is this the driver?
        jne     SSND_Error              ;    N: Strange!!!

;       it seems CM_Register_Device_Driver causes a problem in the Win95 VDD. The VDD won't do the VESA DDC call (4F15).
;       Avoid doing it (CM_Register_Device_Driver) in Win95.

IF 0
;   Well. It does not work on Win98 also! So Just do it the old way. The code to register for
;   config manager messages is left here commented out. Maybe someday Microsoft will fix this
;   and we can do it the documented way :-)
    VMMcall     Get_VMM_Version
    .if (!(carry?) && (ax == 040ah))
       ; This is win98. Register to get config messages.
       VxDcall _CONFIGMG_Register_Device_Driver, <ebx, OFFSET32 MiniVDD_Config_Handler, 0, CM_REGISTER_DEVICE_DRIVER_STATIC>
           .ERRNZ       CR_SUCCESS
           test eax, eax
           jnz  SSND_Couldnt_Reg_Driver
       ; Register succeeded. Clear carry and return
           clc
           jmp MiniVDD_new_devnode_Exit
    .endif
    
    ; This is win95. Can't register for config messages. So just do the config_start here.
ENDIF

    ; Just do the init here for both win95 and win98.
    call DoConfigStart
    cmp eax, CR_SUCCESS
    jne SSND_Error
    jmp MiniVDD_new_devnode_Exit
    
;   Unable to register driver.
SSND_Couldnt_Reg_Driver:
        Debug_Out "MiniVDD:  Register device driver failed for devnode #EDI"

SSND_Error:
        Debug_Out "MiniVDD:  MiniVDD PnP_New_Devnode failed"
        mov     eax, CR_FAILURE
        stc
MiniVDD_new_devnode_Exit:
        ret

EndProc MiniVDD_PnP_New_Devnode

;******************************************************************************
;
;   MiniVDD_Config_Handler
;
;   DESCRIPTION:
;       This is the plug and play driver entry point for the MiniVDD.
;       This routine is called by the config manager to notify this driver
;       of configuration related actions.
;
;   THIS PROC IS NOT USED NOW. To enable this procedure, uncomment the code
;   to register for config manager messages in MiniVDD_PnP_New_Devnode.
;
;   ENTRY:
;       cfFuncName = The function to perform.
;       sbfSubFuncName = The subfunction to perform.
;       dnToDevNode = Handle of the devnode being called.
;       dnAboutDevNode = Handle of the subject of the event.
;       ulFlags = Flags value.
;
;   EXIT:
;       EAX = CR_RESULT
;
;   USES:
;       EAX, ECX, EDX
;
;==============================================================================

BeginProc MiniVDD_Config_Handler, CCALL

ArgVar  cfFuncName, DWORD
ArgVar  scfSubFuncName, DWORD
ArgVar  dnDevNode, DWORD
ArgVar  dwRefData, DWORD
ArgVar  ulFlags, DWORD

        EnterProc
        push    ebx
        push    esi
        push    edi

        .IF ([cfFuncName] == CONFIG_FILTER)

           ;> Filter logical configurations for controller.
           ;> This is called before start and may not be required.

           mov eax, CR_SUCCESS

        .ELSEIF ([cfFuncName] == CONFIG_START)

           Debug_Out "MiniVDD:  PnP Start"
       ; We get called twice with CONFIG_START. Once with a subfunction of CONFIG_START_FIRST_START
       ; and once with a subfunction of CONFIG_START_DYNAMIC_START. We will only pay attention
       ; to CONFIG_STAR_FIRST_START.
       .IF ([scfSubFuncName] == CONFIG_START_FIRST_START)
          mov ebx, [dnDevNode]
          call DoConfigStart
       .ENDIF

        .ELSEIF ([cfFuncName] == CONFIG_STOP)

       Debug_Out "MiniVDD:  PnP Stop"
       ; need to add code to handle this.
       mov eax, CR_SUCCESS
       
        .ELSEIF ([cfFuncName] == CONFIG_TEST)

           Debug_Out "MiniVDD:  PnP Test"
       ; need to add code to handle this.
           mov  eax, CR_REMOVE_VETOED           ; if we are primary display, we can't be removed now
    
        .ELSEIF ([cfFuncName] == CONFIG_REMOVE)

       Debug_Out "MiniVDD:  PnP Remove"
           ;> The controller devnode is being removed, this driver must stop
           ;> using the allocated configuration.  Any allocated data for this
           ;> devnode should be freed.  If the driver is dynamically loaded it
           ;> will be unloaded by the config manager.  This driver will not be
           ;> called again after this call.

           ; If the user removes the device from the registry via the Device Manager,
           ; and we are the primary display, we can't just unload. We should keep displaying and the Config Manager should 
           ; take care of the registry and ask if we want to restart.
       ;        call    _rmConfigStop
           ;VMMcall _HeapFree, <dwRefData, 0>
       ;        jmp     MiniVDDPnP_Success
       ;        mov     eax, CR_REMOVE_VETOED           ; if we are primary display, we can't be removed now
       ;        jmp MiniVDDPnP_Exit
       
       ; need to add code to handle this.
           mov  eax, CR_FAILURE         ; don't allow removal

    .ELSE
       mov eax, CR_DEFAULT
    
    .ENDIF

        .ERRNZ CR_SUCCESS

; Exit with eax = status
        pop     edi
        pop     esi
        pop     ebx
        LeaveProc
        Return

EndProc MiniVDD_Config_Handler

;******************************************************************************
;
;   MiniVDD_System Exit
;
;   DESCRIPTION:        Windows is shutting down. The resource manager left the VGA
;           in an unsatisfactory state, so we should do a mode set to clean it up.
;           This is important if we are doing an exit to DOS (as opposed to a 
;           shutdown or restart).
;
;   ENTRY:
;
;   EXIT:
;       EAX = CR_RESULT
;
;   USES:
;       EAX, ECX, EDX
;
;==============================================================================

public  MiniVDD_System_Exit
BeginProc MiniVDD_System_Exit
;Entry:
;       EBX contains the VM handle of the Windows VM.
;Exit:
;
; CANOPUS TV Programming Changes -- only use if customer is Canopus
;
;;   We switching off the INACTIVE bit off the "our" TV_FLAG_REGISTER in the BIOS
;;       because in VGA mode the bios should initialize (or switch off) the Chrontel
;;       It seems that if the driver does this, this will be to be to late...
        test nvCustomer, NVCUSTOMER_CANOPUS
        jz   PHRTV_NoCanopus04
            
        push    dx
        mov     al, bCanopusTVReg       ;-- first check, if the BIOS supports Canopus TV 
        or          al, al
        jz          PHRTV_NoCanopus03   ; no, not supported

        call    GetCRTCPort             ;-- first unlock the registers
        mov     ax, 0571fh              ; (nobody knows what the heck the RM does...:-)
        out     dx, ax
        call    GetCRTCPort             ;-- next read TV Flag register
        mov         edi,ebx                     ;get pointer to our CB data area
        add         edi,OurCBDataPointer        ;EDI --> our CB data area for this VM
        mov         ah,[edi].PerVMData.EXT_CanopusTVReg
        test    ah, 040h                ; already initialized ???
        jnz     @F                      ; yes, go on

        mov     al, bCanopusTVReg       ; else get the current register contents
        out     dx, al
        inc     dx
        in          al, dx
        dec     dx
        mov     ah, al                  ; and modify this one...
@@:
        and     ah, 07fh                ; clear the INACTIVE flag (TV_FLAG_REGISTER)
        mov     al, bCanopusTVReg
        out     dx, ax                  ; and write the new value back...
PHRTV_NoCanopus03:
        pop     dx
        jmp short PHRTV_NoCanopus05
PHRTV_NoCanopus04:

;   tell the BIOS to program the TV encoder
        call    TellBIOSProgramTV
PHRTV_NoCanopus05:

        cmp             ACPI_state,0                    ; in power-down state?
        jne             @f                                              ; then don't call BIOS (chip may be disabled)

        cmp     OSVersion, VERS_MILLENNIUM  ; leave Millennium in current mode
        jge     @f

        Push_Client_State
        VMMcall Begin_Nest_V86_Exec

        ; Set mode 3 via VESA in case the Japanese language driver is running and trapping int 10.
        ; We need to do a modeset to get back to a state in which the DOS mouse driver will not try to display a cursor,
        ; and if the Japanese driver traps int 10, it won't happen, and the mouse driver will be activated and cause screen corruption.
        mov     ax,4f02h
        mov     [ebp].Client_Word_Reg_Struc.Client_AX,ax
        mov     ax,3
        mov     [ebp].Client_Word_Reg_Struc.Client_BX,ax
        ; do an int 10
        mov     eax,010h
        VMMCall Exec_Int
        
        ; set mode 3 by standard int10 to get Japanese language driver into proper state
        mov     ax,03h
        mov     [ebp].Client_Word_Reg_Struc.Client_AX,ax
        ; do an int 10
        mov     eax,010h
        VMMCall Exec_Int

        VMMCall End_Nest_Exec
        Pop_Client_State
@@:
        ret
EndProc MiniVDD_System_Exit
;

;******************************************************************************
;
;   MiniVDD_Sys_VM_Terminate
;
;   DESCRIPTION:        Windows is shutting down. We set a mode 3 to prepare for the Windows shutting down message
;
;   ENTRY:
;
;   EXIT:
;       EAX = CR_RESULT
;
;   USES:
;       EAX, ECX, EDX
;
;==============================================================================

public  MiniVDD_Sys_VM_Terminate
BeginProc MiniVDD_Sys_VM_Terminate
;We are leaving Windows and going to text mode
;Entry:
;       EBX contains the VM handle of the Windows VM.
;Exit:
        
;       Set DoNotSimulate flag to TRUE
        mov     DoNotSimulate,1         ; signal i/o trap routine that even though this is the system VM
                                        ; we should not simulate, but do I/O, so BIOS can write to DAC and CONFIG regs

        ; Unhook the Int 10 handler
        mov     eax, 10h
        mov     esi, OFFSET32 MiniVDD_Int10Handler
        VxDcall Unhook_V86_Int_Chain
        
        cmp     ACPI_state,0            ; in power-down state?
        jne     @f                      ; then don't call BIOS (chip may be disabled)

        cmp     OSVersion, VERS_MILLENNIUM  ; leave Millennium in current mode
        jge     @f

        Push_Client_State
        VMMcall Begin_Nest_V86_Exec

        ; set mode 3
        mov     ax,03h
        mov     [ebp].Client_Word_Reg_Struc.Client_AX,ax
        ; do an int 10
        mov     eax,010h
        VMMCall Exec_Int

        VMMCall End_Nest_Exec
        Pop_Client_State
@@:
        ret
EndProc MiniVDD_Sys_VM_Terminate
;
;******************************************************************************
;
;   MiniVDD_Device_Reboot_Notify
;
;   DESCRIPTION:        Windows 98 is shutting down. We set a mode 3 to prepare for the Windows shutting down message
;
;   ENTRY:
;
;   EXIT:
;       EAX = CR_RESULT
;
;   USES:
;       EAX, ECX, EDX
;
;==============================================================================

public  MiniVDD_Device_Reboot_Notify
BeginProc MiniVDD_Device_Reboot_Notify
;We are leaving Windows and going to text mode
;Entry:
;       EBX contains the VM handle of the Windows VM.
;Exit:
        
;       Set DoNotSimulate flag to TRUE
        mov     DoNotSimulate,1         ; signal i/o trap routine that even though this is the system VM
                                        ; we should not simulate, but do I/O, so BIOS can write to DAC and CONFIG regs

        cmp     ACPI_state,0            ; in power-down state?
        jne     @f                      ; then don't call BIOS (chip may be disabled)

        cmp     OSVersion, VERS_MILLENNIUM  ; leave Millennium in current mode
        jge     @f

        Push_Client_State
        VMMcall Begin_Nest_V86_Exec

        ; set mode 3
        mov     ax,03h
        mov     [ebp].Client_Word_Reg_Struc.Client_AX,ax
        ; do an int 10
        mov     eax,010h
        VMMCall Exec_Int

        VMMCall End_Nest_Exec
        Pop_Client_State
@@:
        ret
EndProc MiniVDD_Device_Reboot_Notify

subttl          Utility routines
page +
IFDEF DEBUG_LOG
public  DumpRegisters
BeginProc DumpRegisters
        pushf
        pushad
        mov     edx,MISC_INPUT
        xor     eax,eax
        in      al,dx
        Debug_Printf    "    MISC:%02lX\n\r", eax, DEBLEVELMAX
        mov     edx,FC_INPUT
        xor     eax,eax
        in      al,dx
        Debug_Printf    "    FC:%02lX\n\r", eax, DEBLEVELMAX
        mov     edx,FEAT_STATUS
        xor     eax,eax
        in      al,dx
        Debug_Printf    "    FEAT:%02lX\n\r", eax, DEBLEVELMAX
        mov     edx,INPUT_STATUS_COLOR
        xor     eax,eax
        in      al,dx
        Debug_Printf    "    INPUT_STATUS:%02lX\n\r", eax, DEBLEVELMAX
        ;
        ; DUMP Sequencer
        Debug_Printf    "    SEQ:", eax, DEBLEVELMAX
        xor     ecx,ecx
        xor     eax,eax
        mov     edx,SEQ_INDEX
        in      al,dx           ;save sequencer index
        push    eax
@@:
        mov     al,cl
        out     dx,al
        inc     edx             ;edx --> SEQ Data
        in      al,dx
        dec     edx             ;edx --> SEQ Index
        Debug_Printf    "%02lX ", eax, DEBLEVELMAX
        inc     ecx
        cmp     ecx,6
        jbe     @b
        pop     eax             ;restore sequencer index
        out     dx,al
        Debug_Printf    "\n\r", DEBLEVELMAX
        ;
        ; DUMP CRTC
        xor     ecx,ecx
        xor     eax,eax
        call    GetCRTCPort
        in      al,dx           ;save CRTC index
        push    eax
        ;
        Debug_Printf    "    CRTC:", eax, DEBLEVELMAX
@@:
        mov     al,cl
        out     dx,al
        inc     edx             ;edx --> SEQ Data
        in      al,dx
        dec     edx             ;edx --> SEQ Index
        Debug_Printf    "%02lX ", eax, DEBLEVELMAX
        inc     ecx
        cmp     ecx,00Fh
        jbe     @b
        Debug_Printf    "\n\r", DEBLEVELMAX
        ;
        Debug_Printf    "         ", eax, DEBLEVELMAX
@@:
        mov     al,cl
        out     dx,al
        inc     edx             ;edx --> SEQ Data
        in      al,dx
        dec     edx             ;edx --> SEQ Index
        Debug_Printf    "%02lX ", eax, DEBLEVELMAX
        inc     ecx
        cmp     ecx,01Fh
        jbe     @b
        Debug_Printf    "\n\r", DEBLEVELMAX
        ;
        Debug_Printf    "         ", eax, DEBLEVELMAX
@@:
        mov     al,cl
        out     dx,al
        inc     edx             ;edx --> SEQ Data
        in      al,dx
        dec     edx             ;edx --> SEQ Index
        Debug_Printf    "%02lX ", eax, DEBLEVELMAX
        inc     ecx
        cmp     ecx,02Fh
        jbe     @b
        Debug_Printf    "\n\r", DEBLEVELMAX
        ;
        Debug_Printf    "         ", eax, DEBLEVELMAX
@@:
        mov     al,cl
        out     dx,al
        inc     edx             ;edx --> SEQ Data
        in      al,dx
        dec     edx             ;edx --> SEQ Index
        Debug_Printf    "%02lX ", eax, DEBLEVELMAX
        inc     ecx
        cmp     ecx,03Fh
        jbe     @b
        Debug_Printf    "\n\r", DEBLEVELMAX
        ;
        pop     eax             ;restore CRTC index
        out     dx,al
        ;
        ; Attribute controller
        Debug_Printf    "    AC:", eax, DEBLEVELMAX
        xor     ecx,ecx
        xor     eax,eax
        call    GetCRTCPort
        in      al,dx
        push    eax             ;save CRTC index
        mov     al,024h         ;AT flip-flop register
        out     dx,al
        inc     edx             ;edx --> CRTC data
        in      al,dx
        dec     edx             ;edx --> CRTC index
        push    eax             ;save AT flip flop
        mov     al,026h         ;AT index register
        out     dx,al
        inc     edx             ;edx --> CRTC data
        in      al,dx
        dec     edx             ;edx --> CRTC index
        push    eax             ;save AT index
        ;
@@:
        mov     edx,INPUT_STATUS_COLOR
        in      al,dx           ;clear the flip-flop
        mov     edx,ATC_INDEX
        mov     al,cl
        out     dx,al
        inc     edx             ;edx --> ATC read
        in      al,dx
        dec     edx             ;edx --> ATC write
        Debug_Printf    "%02lX ", eax, DEBLEVELMAX
        inc     ecx
        cmp     ecx,014h
        jbe     @b
        ;
        mov     edx,INPUT_STATUS_COLOR
        in      al,dx           ;clear the flip-flop
        pop     eax             ;restore attribute index
        mov     edx,ATC_INDEX
        out     dx,al           ;restores index and sets flip-flop to data
        pop     eax             ;restore attribute flip-flop
        or      al,al           ;if al is zero, go back to address
        jnz     @f
        mov     edx,INPUT_STATUS_COLOR
        in      al,dx           ;clear the flip-flop
@@:
        pop     eax             ;restore CRTC index
        call    GetCRTCPort
        out     dx,al
        Debug_Printf    "\n\r", DEBLEVELMAX
        ;
        ; Graphics controller
        Debug_Printf    "    GC:", eax, DEBLEVELMAX
        xor     ecx,ecx
        xor     eax,eax
        mov     edx,GDC_INDEX
        in      al,dx           ;save sequencer index
        push    eax
@@:
        mov     al,cl
        out     dx,al
        inc     edx             ;edx --> SEQ Data
        in      al,dx
        dec     edx             ;edx --> SEQ Index
        Debug_Printf    "%02lX ", eax, DEBLEVELMAX
        inc     ecx
        cmp     ecx,8
        jbe     @b
        pop     eax             ;restore sequencer index
        out     dx,al
        Debug_Printf    "\n\r", DEBLEVELMAX
        ;
IFDEF NVIDIA_SIMULATE
        call    NVDumpSimulate
ENDIF ; NVIDIA_SIMULATE
        popad
        popf
        ret
EndProc DumpRegisters
;
;       
ENDIF ; DEBUG_LOG
;
;

public  GetCRTCPort
BeginProc GetCRTCPort
;
;       GetCRTCPort - Get the actual address of the CRTC (independent of BIOS vars)
;
;       Entry:  None
;       Exit:   DX = Address of CRTC (3D4h = color, 3B4h = mono)
;
;       Assume the VGA is awake.
;
;
        push    ax
        mov     dx,MISC_INPUT
        in      al,dx
        mov     edx,CRTC_INDEX_MONO             ; Assume mono CRTC
        test    al,1                            ; Is CRTC mono?
        jz      GetCRTCAddr_exit                ;  Yes: Go exit
        mov     edx,CRTC_INDEX_COLOR            ;  No: Return color CRTC
GetCRTCAddr_exit:
        pop     ax
        ret
EndProc GetCRTCPort
;
VxD_LOCKED_CODE_ENDS

;**************************************************************************************************************************
VxD_DATA_SEG

VDDBank                 db      ?               ;init'd at GetVDDBank
;;VDDBankControl          db      ?               ;init'd at GetVDDBank
BankRegSaveLow          db      0ffh            ;this flag must be init'd!
BankRegSaveHigh         db      0ffh            ;this flag must be init'd!
VDDPageOffsetFromBank   db      ?               ;
LatchSaveLow            db      ?               ;
LatchSaveHigh           db      ?               ;
;
LastByteInAddr                  dw              0                               ;save address of 3d0-3d3 for byte->word integration
LastByteOutAddr                 dw              0                               ;save address of 3d0-3d3 for byte->word integration
LastByteOut                             db              0                               ;save the data to output
rmState                                 db              0
rmArray                                 label   word
NvPtr                                   dd              0
NvData                                  dd              0

VxD_DATA_ENDS

;**************************************************************************************************************************
VXD_LOCKED_CODE_SEG
;
subttl          Return ChipID To Main VDD
page +
Public  MiniVDD_GetChipID
BeginProc MiniVDD_GetChipID
;
;Entry:
;       Nothing assumed.
;Exit:
;       EAX contains the ChipID.
;       Preserve ALL other registers.
;
;This routine is used by the Main VDD's Plug&Play code to determine whether
;a card has been changed since the last time that Windows was booted.  We
;are called to return to ChipID.  This assures us that Plug&Play will detect
;a different card, even if both cards use this same MiniVDD.  If the ChipID
;has changed, Plug&Play will get wind of it and will take appropriate action.
;
        push    esi
        REG_RD32(NV_PMC_BOOT_0)
        pop     esi
        ret                             ;
EndProc MiniVDD_GetChipID

public  MiniVdd_GetMonitorPowerStateCaps
BeginProc MiniVdd_GetMonitorPowerStateCaps, RARE
;
;Entry:
;       DevNode.
;Exit:
;       The CAPS of adapter
        ArgVar  DevNode, DWORD          ;message number
        EnterProc

        ; We have to support D2 because in case monitor timeout = 1 min, screensaver = 15min
        ; Windows would try to set monitor to D2 state after 1 min so we would observe
        ; screen saver if we won't support D2 (see the bug #34277).
        mov     eax, (CM_POWERSTATE_D0 or CM_POWERSTATE_D2 or CM_POWERSTATE_D3)
        LeaveProc
        Return
EndProc MiniVdd_GetMonitorPowerStateCaps

public  MiniVdd_SetMonitorPowerState
BeginProc MiniVdd_SetMonitorPowerState, RARE
;Entry:
;       DevNode.
;       PowerState.
;Exit:
;       CR_DEFAULT  - OS should POST the device
;   CR_SUCCESS  - OS should do nothing
        ArgVar  DevNode, DWORD
        ArgVar  PowerState, DWORD

        EnterProc
        push    ebx
        push    ecx
        push    edx
        
        mov     ebx,PowerState
;
;
; state n = bit n
        test    ebx,CM_POWERSTATE_D0
        jz      SMPS_D23

SMPS_D0:
                
        ; Top bit of 0 indicates that we are in a fullscreen
        ; DOS box, or in a state were DDraw shouldn't touch the HW.
        ;
        ; Top bit of 1 indicates that we are in the Windows VM. The
        ; low 31bits are individual 'enable' bits that D3D will clear
        ; as each sub-system reinits itself on returning to the Windows
        ; VM from fullscreen DOS.
        mov     eax,pDDrawFullScreenDOSActive
        or      eax,eax
        je      @F
        or      dword ptr [eax],80000000H
@@:

;       call RM to start up (use API)
        mov     eax, NVRM_API_SET_MONITOR_POWER
        mov     ebx, DEFAULT_PRIMARY_HDEV              ; device = primary
        mov     ecx,0
        call    CallRM

        jmp     SMPS_Ret

SMPS_D23:

        ; After the RM-EnableVGA, the RM has forced GET=PUT and
        ; all channels are idle. To make sure that no one renders
        ; anything or attempts to touch the HW, set some shared
        ; flags that say 'We are in a fullscreen DOS BOX -- don't
        ; do any rendering.'
        ;
        ; Top bit of 0 indicates that we are in a fullscreen
        ; DOS box. Top bit of 1 indicates that we are in
        ; the Windows VM. The low 31bits are individual 'enable'
        ; bits that D3D will clear as each sub-system reinits
        ; itself on returning to the Windows VM from fullscreen DOS.
        mov     eax,pDDrawFullScreenDOSActive
        or      eax,eax
        je      @F
        mov     dword ptr [eax],7FFFFFFFH
@@:

;       call RM to shut down (use API)
        mov     eax, NVRM_API_SET_MONITOR_POWER
        mov     ebx, DEFAULT_PRIMARY_HDEV              ; device = primary
        mov     ecx,3
        call    CallRM
        
SMPS_Ret:
        pop     edx
        pop     ecx
        pop     ebx
        mov     eax,CR_SUCCESS
        LeaveProc
        Return
EndProc MiniVdd_SetMonitorPowerState

public  MiniVdd_GetAdapterPowerStateCaps
BeginProc MiniVdd_GetAdapterPowerStateCaps, RARE
;
;Entry:
;       DevNode.
;Exit:
;       The CAPS of adapter
        ArgVar  DevNode, DWORD          ;message number
        EnterProc

;       Notify the RM that ACPI is supported on the adapter
;       And that we can expect ACPI traffic (we'll ignore APM)
        mov     ebx, DEFAULT_PRIMARY_HDEV
        mov     eax, NVRM_API_ACPI_ENABLED  ; load up the function number
        call    CallRM                      ; go to RM's API procedure

        cmp     OSVersion,VERS_MILLENNIUM
        jb      ACPI_Win98              ;Millennium or Win98?
        mov     eax, (CM_POWERSTATE_D0 or CM_POWERSTATE_D3 or CM_POWERSTATE_D1 or CM_POWERSTATE_HIBERNATE)
        jmp     GAPSC_Done
ACPI_Win98:
        mov     eax, (CM_POWERSTATE_D0 or CM_POWERSTATE_D3 or CM_POWERSTATE_D1)
GAPSC_Done:
        LeaveProc
        Return
EndProc MiniVdd_GetAdapterPowerStateCaps

subttl          Set adapter Power State
page +

public  MiniVdd_SetAdapterPowerState
BeginProc MiniVdd_SetAdapterPowerState, RARE
;Entry:
;       DevNode.
;       PowerState.
;Exit:
;       CR_DEFAULT  - OS should POST the device
;   CR_SUCCESS  - OS should do nothing
        ArgVar  DevNode, DWORD
        ArgVar  PowerState, DWORD

        EnterProc
        push    ebx
        push    ecx
        push    edx

        mov     ebx,PowerState
;       cmp     ebx,AdapterState                ; Are we already in this mode?
;       jz      SAPS_Success                    ; Yes, do nothing
;
; Check for restoring to D0, if not we must be going to D1, D2, or D3.
;
; state n = bit n
        test    ebx,CM_POWERSTATE_D3
        jnz     SAPS_D3
        test    ebx,CM_POWERSTATE_D2
        jnz     SAPS_D2
        test    ebx,CM_POWERSTATE_D1
        jnz     SAPS_D1
        test    ebx,CM_POWERSTATE_HIBERNATE
        jnz     SAPS_HIBERNATE

;   if we are going to state 3, we shut down.
;   if we are coming back to state 0, we must start up.
SAPS_D0:
        cmp     ACPI_state,0                           ; already here?
        jz      SAPS_Success
        mov     ACPI_state,0
                
;       call RM to start up (use API)
        mov     eax, NVRM_API_POWER_UP
        mov     ebx, DEFAULT_PRIMARY_HDEV              ; device = primary
        call    CallRM

        call    DisplayDriverPowerUp
        jmp     SAPS_Success

SAPS_HIBERNATE:
        call    DisplayDriverPowerDown

        mov     eax, NVRM_API_HIBERNATE
        mov     ebx, DEFAULT_PRIMARY_HDEV
        call    CallRM
        mov     ACPI_state,3

        jmp     SAPS_Success
SAPS_D3:
        cmp     ACPI_state,3        ; already here?
        jz      SAPS_Success
        mov     ACPI_state,3

        call    DisplayDriverPowerDown

;       point the real mode access at PBUS_DEBUG_1 in case the BIOS gets called to start up
        call    unlock_ext
        mov     dx,3d4h
        mov     ax,338h         ; address mode
        out     dx,ax
        mov     dx,3d0h
        mov     ax,1084h        ; lsw PBUS_DEBUG_1
        out     dx,ax
        mov     ax,0            ; msw PBUS_DEBUG_1
        mov     dx,3d2h
        out     dx,ax
        mov     dx,3d4h
        mov     ax,538h         ; data mode
        out     dx,ax
        
;       call RM to shut down (use API)
        mov     eax, NVRM_API_POWER_DOWN
        mov     ebx, DEFAULT_PRIMARY_HDEV              ; device = primary
        call    CallRM

        jmp     SAPS_Success

SAPS_D2:
;   not supported
if 0
        cmp     ACPI_state,2
        jz      SAPS_Success
        mov     ACPI_state,2
        mov     eax, NVRM_API_POWER_D2
        mov     ebx, DEFAULT_PRIMARY_HDEV              ; device = primary
        call    CallRM
        jmp     SAPS_Success
endif
        mov     eax,CR_DEFAULT
        jmp     SAPS_Ret
SAPS_D1:
        cmp     ACPI_state,1
        jz      SAPS_Success
        mov     ACPI_state,1

        call    DisplayDriverPowerDown

        mov     eax, NVRM_API_POWER_D1
        mov     ebx, DEFAULT_PRIMARY_HDEV              ; device = primary
        call    CallRM
        
SAPS_Success:
        mov     eax,CR_SUCCESS

SAPS_Ret:
        pop     edx
        pop     ecx
        pop     ebx
        LeaveProc
        Return
EndProc MiniVdd_SetAdapterPowerState

page +
public  MiniVDD_RegisterDisplayDriver
BeginProc MiniVDD_RegisterDisplayDriver, RARE
;Called from VDD's REGISTER_DISPLAY_DRIVER_INFO function
;
;Oft-times, the display driver must set flags whenever it is doing
;certain things to a hardware BLTer (such as "I'm in the middle of
;transferring a source bitmap").  This routine is called to allow
;this mini-VDD to get data (usually containing addresses inside the
;display driver's Data segment) directly from the display driver.
subttl          Register Display Driver Dependent Data

;We can also save appropriately needed states here.
;
;       The only client registers that are reserved (and cannot be used
;to pass data in) are EAX (which contains the function code which the
;display driver uses to call the "main" VDD) and EBX (which contains the
;Windows VM handle).  When we get called by the "main" VDD, we'll be
;passed a flag in Client_AL which will be set to non-zero if the VFLATD
;VxD is being used for banked support or zero if VFLATD is NOT involved in
;this session.
;
;Entry:
;       EBP --> the Client Register Structure (documented in VMM.INC)
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_RegisterDisplayDriver", DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG

        mov     InFullScreen, 0h        ; I believe, we're no longer in full screen dos mode ;-)  CANOPUS

        ; The new architecture display driver needs some functions
        ; which can only be performed at the VxD level. I made a
        ; simple interface for these services out of the minivdd
        ; function RegisterDisplayDriver. The Client_EAX register
        ; is used up because it must hold the special code
        ; VDD_REGISTER_DISPLAY_DRIVER_INFO in order to get here,
        ; and Client_EBX is used up holding the system VM handle.
        ; The other registers are all free, so:
        ; CLIENT_ecx    - sub-function
        ; All other registers are sub-function specific.
        ;
        ; I placed the sub-function constants in nvrmarch at
        ; the time I wrote this code.
        mov     eax,[ebp].Client_Reg_Struc.Client_ECX
        cmp     eax,MVDD_SET_LOCK_AND_UNLOCK_OFFSCREEN_FUNCS
        je      SetLockAndUnlockFuncs
        cmp     eax,MVDD_REENUMERATE_DEVNODE
        je      ReenumerateDevNode
        cmp     eax,MVDD_SET_POWER_MANAGEMENT_CALLBACKS
        je      SetPowerManagementCallbacks
        jmp     MRDDExit

SetLockAndUnlockFuncs:
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; MVDD_SET_POWER_MANAGEMENT_CALLBACKS -- this service sets
        ; the routine that should be called when a power state is changed.
        ; Parameters:
        ; Client_ECX = MVDD_SET_LOCK_AND_UNLOCK_OFFSCREEN_FUNCS
        ; Client_EDX = selector for both the lock and unlock routine
        ; Client_ESI = offset of the lock routine (called on VM_Create)
        ; Client_EDI = offset of the unlock routine (called on VM_Destroy)
        ;
        ; Returns:      None

        mov     eax,[ebp].Client_Reg_Struc.Client_EDX
        mov     dwCallbacksSelector,eax
        mov     eax,[ebp].Client_Reg_Struc.Client_ESI
        mov     pfnLockOffscreen,eax
        mov     eax,[ebp].Client_Reg_Struc.Client_EDI
        mov     pfnUnlockOffscreen,eax
        jmp     MRDDExit

SetPowerManagementCallbacks:
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; MVDD_SET_LOCK_AND_UNLOCK_OFFSCREEN_FUNCS -- this service sets
        ; the routine that should be called when a DOS box is created
        ; and destroyed.
        ; Parameters:
        ; Client_ECX = MVDD_SET_POWER_MANAGEMENT_CALLBACKS
        ; Client_EDX = selector for both the PowerOn and PowerOff routine
        ; Client_ESI = offset of the PowerOn routine (called on S0)
        ; Client_EDI = offset of the PowerOff routine (called on S1,S3,S4)
        ;
        ; Returns:      None

        mov     eax,[ebp].Client_Reg_Struc.Client_EDX
        mov     dwCallbacksSelector,eax
        mov     eax,[ebp].Client_Reg_Struc.Client_ESI
        mov     pfnPowerOn,eax
        mov     eax,[ebp].Client_Reg_Struc.Client_EDI
        mov     pfnPowerOff,eax
        jmp     MRDDExit

ReenumerateDevNode:
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; MVDD_REENUMERATE_DEVNODE -- This service sets the physical
        ; head into the array LogicalDevice using the logical device
        ; as an index into the array. It then calls Windows to
        ; reenumerate the DevNode. This service is called everytime
        ; the display driver receives an Enable call.
        ; Client_ECX = MVDD_REENUMERATE_DEVNODE
        ; Client_EDX = physical head
        ; Client_ESI = logical device index

        push    ebx
        push    ecx

        mov     edx,[ebp].Client_Reg_Struc.Client_EDX   ; physical head
        mov     eax,edx                                 ; if high bit set,
        and     eax,NOT 80000000H                       ; then call reenum

        mov     ecx,[ebp].Client_Reg_Struc.Client_ESI   ; logical index
        shl     ecx,2                                   ; convert to dwords
        lea     ebx,LogicalDevice

        ; This routine realized for MAX_CRTCS == 2 case only!!!!
        mov     ds:[ebx + ecx],eax
        xor     eax,MAX_CRTCS - 1
        xor     ecx,(MAX_CRTCS-1)*4
        mov     ds:[ebx + ecx],eax

        test    edx,80000000H
        jz      @F
        VxDcall _CONFIGMG_Reenumerate_DevNode, <dwDisplayDevnodeHandle, 0>
@@:
        pop     ecx
        pop     ebx
        jmp     MRDDExit

MRDDExit:
IFDEF DEBUG_LOG
        pushf
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "\n\r", DEBLEVELMAX
                pop     eax
        .endif
        popf
ENDIF ; DEBUG_LOG
        ret                             ;
EndProc MiniVDD_RegisterDisplayDriver
;
;
subttl          Calculate and Save Banking Register Values
page +
public  MiniVDD_GetVDDBank
BeginProc MiniVDD_GetVDDBank, DOSVM
;Called from VDD's REGISTER_DISPLAY_DRIVER function
;
;In order to virtualize VGA graphics mode applications in a window on the
;Windows desktop, the VDD requires you to reserve at least 32K of off-screen
;video memory for the exclusive use of the VDD.  Although it's best to
;allocate a full 64K of off-screen video memory, the VDD can work with a
;minimum of 32K.  This function is called by the "main" VDD when the
;display driver registers with it.  This function must calculate the
;correct bank of the off-screen memory and the offset within that bank of
;the VDD reserved memory.  Note that it's best if the offset value returned
;is zero (that is, you start on a bank boundry).
;
;The mini-VDD saves the banking register values locally for later
;use during VGA virtualization.
;
;Note that the "main" VDD assumes that the hardware banks are 64K in length.
;
;Entry:
;       EBX contains the Windows VM handle (which must be preserved).
;       ECX contains the byte offset of where in video memory the VDD
;           memory is to be placed (this will be the first byte of
;           off-screen memory).
;Exit:
;       AH contains the page offset from start of bank of virtualization area.
;       EBX must still contain the Windows VM handle.
;       ECX contains the starting address of the VDD virtualization area
;       EDX contains the amount of memory that we allocated to
;       the VDD virtualization area.  We set EDX == ECX if we are in
;       a "memory shy" configuration.  That is, to tell the "main"
;       VDD that we cannot support VGA 4 plane graphics in the background.
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_GetVDDBank", DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        mov     DisplayEnabledFlag,0ffh ;flag that we're in HiRes mode
        mov     SuperVGAModeFlag,0ffh   ;indicate that display driver is not VGA
        mov     BankRegSaveLow,0ffh     ;re-init this to "no banking"

;               return memory shy config
                mov             edx,0
                mov             ecx,edx

IF 0
;We won't use the following strategy. It's not worth sacrificing hi resolution 32 bit modes on a 2 Meg card just so we
;can virtualize 4 plane modes (a pretty useless exercise). The display driver will declare that we don't support 4 plane
;modes. This seems to have no effect, so we return memory-shy configuration here to tell VDD we are not supporting planar 
;emulation.
;There is also a question about the resolution of the window into the bank. The page registers seem to open a 256k window,
;so we may not be able to place the buffer on the 64k boundary which we want, effectively wasting 128k (265k - 64k instance 
; - 64k VDD buffer).

;For NV3 we are going to ignore the starting address passed by the VDD and use the space
;at the end of the framebuffer, just before the instance memory. This is because the display
;driver doesn't know how much memory is available yet, and it wants to see contiguous
;display memory, without this emulation buffer in the way.
;When we are running on a TV we do not allow planar modes, so we should never have both VDD buffer and TV filter buffer.
;               0--------------------------Framebuffer--------------------------------------- 4 Meg
;               |                       |                                                       |                               |                       |                  |
;        display buf   other bufs (direct draw)          TV bufs           VDD buf        Instance
;johnh
                pushad
                mov             eax,2                                                   ; subfunction 2
                push    eax
                VXDCall NVRM_GetAddress                                 ; return offset to VDD planar mode emulation buffer
                mov             PlanarBuf,eax
                pop             eax
                popad    
                mov             ecx,PlanarBuf                                   ; get address (already 64k aligned)
        cmp             cx,0                                                    ; well, lets make sure
        jz              @f
        xor             cx,cx                                                   ; move DOWN to 64k align
;               we are assured of 64k of aligned memory for the planar mode buffer
;               we return to the VDD the bank offset (64k) of the buffer, and save the bank number for the SetVDDBank routine.
@@:             mov             eax,ecx
                shr             eax,16                                                  ; addr/64k = bank number
                mov             VddBank,al                                              ; save bank #0
                xchg    ah,al                                                   ; return bank in ah
                mov             edx,10000h                                              ; return 64k buffer size
;               should be all there is to it
ENDIF   ; 0
                
;               this is the way to do it if we let the display driver tell us where the buffer starts (just after the display buffer).
IFDEF   OLD_BANK_STRATEGY
;
;Let's find out in which 64K bank the off-screen memory starts:
;
; MSK - TODO - DEBUG!!!!
;        mov     ecx,0001C0000h          ;Force memory available to 64KB*4planes for debugging
; MSK - TODO - DEBUG!!!!
        mov     eax,ecx                 ;get start address of off-screen memory
        shr     eax,16                  ;divide by 64K per bank -- AL has bank #
;
;At this point:
;       AL contains the bank number of the start of off-screen memory
;       CX contains the offset within the bank of the start of
;          off-screen memory.
;
;It is desirable for us to start the VDD memory area on an even bank
;boundry.  This is possible if we have at least one full 64K bank
;of video memory remaining.  To determine this, we must calculate
;the total number of banks available in video memory.  If there's
;at least one more than what's in AL, we can start on an even bank
;boundry!
;
        or      cx,cx                   ;are we already on an even bank boundry?
        jz      MGVBCalcAmountToUse     ;yes, go see if we can alloc 64K
        mov     edx,TotalMemorySize     ;get total amount of video memory
        shr     edx,16                  ;now DL has total banks on system
        dec     dl                      ;now DL has last possible bank nbr
IFNDEF ALLOW_32K_VIRTUALIZATION
        cmp     al,dl                   ;can we start on an even bank boundry?
        jae     MGVBMemoryShy           ;nope, turn off VGA virtualization
        inc     al                      ;no, put ourselves at next bank boundry
        xor     cx,cx                   ;zero the offset in low word of ECX
        add     ecx,10000h              ;and set ECX = new start of VDD area
ELSE ; ALLOW_32K_VIRTUALIZATION
        cmp     al,dl                   ;do we have any room at all?
        ja      MGVBMemoryShy           ;nope, turn off VGA virtualization
        jne     MGVBEvenBank            ;we can start on an even bank boundry.
        cmp     cx,08000h               ;do we have at least 32K left
        ja      MGVBMemoryShy           ;start above 32K, so less than 32K
        mov     cx,08000h               ;start at 32K offset
        jmp     @f
MGVBEvenBank:
        inc     al                      ;no, put ourselves at next bank boundry
        xor     cx,cx                   ;zero the offset in low word of ECX
        add     ecx,10000h              ;and set ECX = new start of VDD area
@@:
ENDIF ; ALLOW_32K_VIRTUALIZATION
;
public  MGVBCalcAmountToUse
MGVBCalcAmountToUse:
;
;At this point:
;       AL contains the bank number for VDD use.
;       ECX contains the 32 bit address of the start of this memory.
;
        mov     edx,TotalMemorySize     ;get total amount of video memory
        sub     edx,ecx                 ;EDX = amount of memory from start
                                        ;of VDD bank till end of video memory
; MSK - I added this apparently missing check for no memory left.
        jz      MGVBMemoryShy           ;do we have any memory left?
        cmp     edx,64*1024             ;do we have more than 64K left?
        mov     edx,64*1024             ;(assume we do have more than 64K left)
; MSK - I changed this to jae from ja because exactly 64K should be just fine.
; MSK - TODO - DEBUG - change to ja to debug 32K setup!!!
        jae      MGVBGetBankingValues   ;we can use an entire 64K bank for VDD!
        mov     edx,32*1024             ;we can only use 32K for the VDD!
;
public  MGVBGetBankingValues
MGVBGetBankingValues:
;
;At this point:
;       AL contains the bank number for the VDD virtualization bank.
;       ECX contains the 32 bit start address of the VDD virtualization area.
;       EDX contains the size of the VDD virtualization area (either 32K,
;           64K, or -1 indicating a memory shy configuration).
;
;We should setup the values for the NVidia banking registers so that we can set
;them quickly when called upon by the "main" VDD to do so:
;
        push    edx                     ;save size of VDD area for now
        push    ebx                     ;we need this as a work register
        mov     BankRegSaveLow,0ffh     ;make sure this wasn't messed up
                                        ;by board initialization
;        
;When the MemC is in 4 plane mode (such as when virtualizing 4 plane
;VGA apps in a window), we must actually divide the bank number that
;we calculated above (currently in AL) by 4.  If our bank number isn't
;easily divisible by 4, we must return the odd number to the main VDD
;so it can adjust accordingly:
;
        mov     ah,al                   ;copy bank number to AH for odd calc
        shr     al,2                    ;this is the physical bank that we use
        and     ah,03h                  ;this is page offset from bank's start
        shl     ah,2                    ;convert from 64K bank offset to
                                        ;number of pages (4Kx4planes=16K)
IFDEF ALLOW_32K_VIRTUALIZATION
        mov     ebx,ecx                   ;get offset into 64K bank (16Kx4planes)
        shr     ebx,14                   ;convert from bytes to pages (4Kx4planes=16K=2^14)
        add     ah,bl                   ;add to page offset
ENDIF ; ALLOW_32K_VIRTUALIZATION
        mov     VDDPageOffsetFromBank,ah
                                        ;save this for SetVDDBank
        mov     bl,al                   ;copy bank number to BL & BH for now
        shl     bl,1                    ;get bank bits in place
        mov     VDDBank,bl              ;save this for use in virtualization
        pop     ebx                     ;restore saved registers
        pop     edx                     ;
        jmp     MGVBExit                ;
;
public  MGVBMemoryShy
MGVBMemoryShy:
;
;If we reach this point, it means that the Windows visible screen overlaps
;into the very last bank of available video memory.  This creates a
;"memory-shy" configuration which prohibits us from running windowed
;and background EGA/VGA graphics mode apps.
;
;At this point:
;       ECX contains the value passed in at the beginning of the routine.
;
        mov     edx,ecx                 ;indicate a "memory-shy" configuration
;
ENDIF   ;OLD_BANK_STRATEGY

MGVBExit:
IFDEF DEBUG_LOG
        pushf
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "\n\r", DEBLEVELMAX
                pop     eax
        .endif
        popf
ENDIF ; DEBUG_LOG
        ret
EndProc MiniVDD_GetVDDBank
;
;
subttl          Banking Handling Code for VGA Virtualization
page +
public  MiniVDD_SetVDDBank
BeginProc MiniVDD_SetVDDBank, DOSVM
;
;This routine is called when we need to virtualize something in the
;off-screen region of the video memory.  You should save the current
;state of the banking registers and then set your banking registers to
;the off-screen memory region.
;
;Entry:
;       EBX contains the MemC owner's VM handle.
;Exit:
;       Save any registers that you use.
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_SetVDDBank", DEBLEVELMAX
                Debug_Printf    ":MemC:%08lX", ebx, DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        cmp     BankRegSaveLow,0ffh     ;are we already set to the VDD bank?
        jne     MSTVExit                ;yes! don't do it again!
        cmp     SuperVGAModeFlag,0      ;running in 4 plane VGA mode?
        je      MSTVExit                ;yes, don't do anything here
        push    eax                     ;
        push    edx                     ;
;
        call    GetCRTCPort             ;EDX --> CRTC index register
        in      al,dx                   ;get current CRTC index
        ror     eax,8                   ;save it in top byte of EAX
;
;Let's make sure that the NVidia extended registers are unlocked.  This is
;probably not necessary when our CRTC VM is the Windows VM but could happen
;when the CRTC VM is not the Windows VM:
;
;        unlock_extension_regs
        call    unlock_ext

        mov     al,01Dh                 ;set to banking register
        out     dx,al                   ;
        inc     edx                     ;
        in      al,dx                   ;now AL has current bank state
        mov     BankRegSaveLow,al       ;save this for later restore
;
        mov     al,VDDBank              ;now, set the VDD bank
        out     dx,al                   ;
        dec     edx                     ;EDX --> CRTC index register
;
        mov     al,01Eh                 ;set to other banking register
        out     dx,al
        inc     edx                     ;
        in      al,dx                   ;now AL has current bank state
        mov     BankRegSaveHigh,al      ;save this for later restore
;
        mov     al,VDDBank              ;now, set the VDD bank
        out     dx,al                   ;
        dec     edx                     ;EDX --> CRTC index register
;
        rol     eax,8                   ;AL now contains saved CRTC index value
        out     dx,al                   ;

                call    restore_lock
        pop     edx                     ;restore saved registers
        pop     eax                     ;
;
MSTVExit:
        ret                             ;
EndProc MiniVDD_SetVDDBank
;
;
public  MiniVDD_ResetBank
BeginProc MiniVDD_ResetBank, DOSVM
;
;This routine is called when the VDD is done using the off-screen memory
;and we want to restore to the bank that we were in before we started using
;the off-screen memory.  Note that if the bank that's currently set in the
;hardware's banking registers is NOT the VDD bank, that we do not wish to
;reset the banking since someone else purposely changed it and we don't
;want to override those purposeful changes.
;
;Entry:
;       EBX contains the VM handle.
;Exit:
;       Save anything that you use.
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_ResetBank", DEBLEVELMAX
                Debug_Printf    ":VM:%08lX", ebx, DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        cmp     BankRegSaveLow,0ffh     ;is there any banking to restore?
        je      MRBExit                 ;nope, skip this!
;
;We may need to do something.  Save off the current CRTC index register state:
;
        push    eax                     ;
        push    edx                     ;
;
        call    GetCRTCPort             ;EDX --> CRTC index register
        in      al,dx                   ;get current CRTC index
        ror     eax,8                   ;save it in top byte of EAX
;
;Probably not necessary when our CRTC VM is the Windows VM but most likely
;is when the CRTC VM is not the Windows VM:
;
;        unlock_extension_regs
        call    unlock_ext
;
;Get the values of the banking register so we can see if its still
;set to "our" bank.  If it isn't, then Windows has already switched
;it to something for its own purposes and we'd best not restore it!
;
        mov     al,01Eh                 ;this is the NVidia banking register
        out     dx,al                   ;
        inc     edx                     ;EDX --> CRTC data register
        in      al,dx                   ;
        dec     edx                     ;EDX --> CRTC index register
;
        cmp     al,VDDBank              ;are we still set to VDD bank?
        jne     MRBResetBankSaveFlags   ;nope, don't physically reset bank regs
;
        mov     al,01Dh                 ;this is the NVidia banking register
        out     dx,al                   ;
        inc     edx                     ;EDX --> CRTC data register
        in      al,dx                   ;
        dec     edx                     ;EDX --> CRTC index register
;
        cmp     al,VDDBank              ;are we still set to VDD bank?
        jne     MRBResetBankSaveFlags   ;nope, don't physically reset bank regs
;
;It's safe to restore the banking registers!
;
;At this point:
;       EDX -> CRTC Data Register
;
        mov     al,01Dh                 ;this is the NVidia banking register
        mov     ah,BankRegSaveLow       ;get bank to restore
        out     dx,ax                   ;
;
        mov     al,01Eh                 ;set to other banking register
        mov     ah,BankRegSaveHigh      ;get bank to restore
        out     dx,ax                   ;
;
public  MRBResetBankSaveFlags
MRBResetBankSaveFlags:
        mov     BankRegSaveLow,0ffh     ;flag that we're not set to VDD bank
        mov     BankRegSaveHigh,0ffh     ;flag that we're not set to VDD bank
;
                call    restore_lock
;Lastly, restore the CRTC index register that we saved earlier.
        rol     eax,8                   ;AL now contains saved CRTC index value
        out     dx,al                   ;
        pop     edx                     ;restore saved registers
        pop     eax                     ;
;
MRBExit:
        ret                             ;
EndProc MiniVDD_ResetBank
;
;
subttl          Set To Latch Scratchpad Bank
page +
public  MiniVDD_SetLatchBank
BeginProc MiniVDD_SetLatchBank, DOSVM
;
;When virtualizing the VGA 4 plane mode, we have to save and restore the
;latches occasionally.  This routine allows you to set to an off-screen
;bank (in this case and in most cases, the VDD bank) in order to prepare
;for restoring the VGA latches.  This routine is NOT called for saving
;the latches since this is done by simply using the standard VGA CRTC
;register 22H which all super-VGA's possess (we hope).
;
;Entry:
;       Nothing assumed.
;Exit:
;       Save anything that you use.
;
;;IFDEF DEBUG_LOG
;;        .if (DebugOn != 0)
;;                push    eax
;;                Debug_Printf    "MiniVDD_SetLatchBank", DEBLEVELMAX
;;                pop     eax
;;        .endif
;;ENDIF ; DEBUG_LOG
        push    eax                     ;save registers that we use
        push    edx                     ;
        cmp     SuperVGAModeFlag,0      ;running in 4 plane VGA mode?
        je      MSLBExit                ;yes, don't do anything here
;
        call    GetCRTCPort             ;EDX --> CRTC index register
        in      al,dx                   ;get current CRTC index
        ror     eax,8                   ;save it in top byte of EAX
;
;Let's make sure that the NVidia extended registers are unlocked.  This is
;probably not necessary when our CRTC VM is the Windows VM but most likely
;is when the CRTC VM is not the Windows VM:
;
;        unlock_extension_regs
        call    unlock_ext
;
        mov     al,01Dh                 ;set to banking register
        out     dx,al                   ;
        inc     edx                     ;
        in      al,dx                   ;now AL has current bank state
        mov     LatchSaveLow,al         ;save this for later restore
;
        mov     al,VDDBank              ;now, set the VDD bank
        out     dx,al                   ;
        dec     edx                     ;EDX --> CRTC index register
;
        mov     al,01Eh                 ;set to other banking register
        out     dx,al
        inc     edx                     ;
        in      al,dx                   ;now AL has current bank state
        mov     LatchSaveHigh,al        ;save this for later restore
;
        mov     al,VDDBank              ;now, set the VDD bank
        out     dx,al                   ;
        dec     edx                     ;EDX --> CRTC index register
;
                call    restore_lock
        rol     eax,8                   ;AL now contains saved CRTC index value
        out     dx,al                   ;

;
MSLBExit:
        pop     edx                     ;restore saved registers
        pop     eax                     ;
        ret                             ;
EndProc MiniVDD_SetLatchBank
;
;
subttl          Reset Banking After Latch Operations
page +
public  MiniVDD_ResetLatchBank
BeginProc MiniVDD_ResetLatchBank, DOSVM
;
;This routine reverses the latch save that we did prior to restoring the
;latches.  Just restore the states that you saved.
;
;Entry:
;       Nothing assumed.
;Exit:
;       Save anything that you use.
;
;;IFDEF DEBUG_LOG
;;        .if (DebugOn != 0)
;;                push    eax
;;                Debug_Printf    "MiniVDD_ResetLatchBank", DEBLEVELMAX
;;                pop     eax
;;        .endif
;;ENDIF ; DEBUG_LOG
        push    eax                     ;save registers that we use
        push    edx                     ;
        cmp     SuperVGAModeFlag,0      ;are we running NVIDIA.DRV?
        je      MRLBExit                ;nope, don't do anything here
;
        call    GetCRTCPort             ;EDX --> CRTC index register
        in      al,dx                   ;get and save CRTC index value
        ror     eax,8                   ;

;Let's make sure that the NVidia extended registers are unlocked.  This is
;probably not necessary when our CRTC VM is the Windows VM but most likely
;is when the CRTC VM is not the Windows VM:
;
;        unlock_extension_regs
        call    unlock_ext
;
;Restore banking-enabling register:
;
        mov     al,01Dh                 ;set to new banking register
        mov     ah,LatchSaveLow         ;get bank to restore
        out     dx,ax                   ;
;
        mov     al,01Eh                 ;set to other banking register
        mov     ah,LatchSaveHigh        ;get bank to restore
        out     dx,ax

                call    restore_lock
;
;Restore the CRTC index register:
;
        rol     eax,8                   ;
        out     dx,al                   ;
;
MRLBExit:
        pop     edx                     ;restore saved registers
        pop     eax                     ;
        ret                             ;
EndProc MiniVDD_ResetLatchBank
;
;
subttl          Prepare to Enter a Standard VGA Mode from HiRes Mode
page +
public  MiniVDD_PreHiResToVGA
BeginProc MiniVDD_PreHiResToVGA, DOSVM
;
;When the VDD is about to switch from Windows HiRes mode to any of the
;standard VGA modes (for real -- not virtualized), this routine will be
;called.  You need to determine exactly what your hardware requires in
;order to accomplish this task.  For example, you should disable trapping
;on registers that the mini-VDD is specifically handling (such as 4AE8H
;in the case of the S3 chipset), make sure that the hardware is "ready"
;to undergo a mode transition (make sure that your hardware's graphics
;engine isn't in the middle of an operation that can't be interrupted)
;etc.  If your hardware does not return to a standard VGA mode via
;a call to INT 10H, function 0, you should also make sure to do whatever
;it takes to restore your hardware to a standard VGA mode at this time.
;Try not to touch video memory during your transition to standard VGA as
;this will disturb the reliability of the system.
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
          push    eax
          Debug_Printf    "MiniVDD_PreHiResToVGA", DEBLEVELMAX
          pop     eax
        .endif
ENDIF ; DEBUG_LOG
        or      ModeChangeFlags,GOING_TO_VGA_MODE
        mov     DosBoxActive,1          ; DOS box active, let int 10 go thru in dual head mode

    ;
    ; CANOPUS Programming changes -- only use if customer == CANOPUS
    ;
    test nvCustomer, NVCUSTOMER_CANOPUS
    jz   dos_can1

        ; We flush OffScreen cache at this point.
        ; Our modified display driver ignores notify from CreateVM/DestroyVM.
        ; It should not disable OffScreen for windowed dos prompt.
DISABLE_OFF_SCREEN  equ 4050h
        pushad
        VMMcall Get_Cur_VM_Handle
        xchg    eax,ebx
        VMMCall Get_Sys_VM_Handle
        cmp     eax,ebx
        jne     @f

        mov     ebp,[ebx.CB_Client_Pointer]         ; EBP = Windows VM client regs ptr
        Push_Client_State                           ; allocate client regs area
        VMMcall Begin_Nest_Exec                     ; prepare to execute INT2Fh notification
        mov     [ebp.Client_AX],DISABLE_OFF_SCREEN  ; AX = high-res to VGA mode
        mov     eax,2Fh                             ; EAX = INT2Fh interrupt call
        VMMcall Exec_Int                            ; notify driver of entering VGA mode
        VMMcall End_Nest_Exec                       ;
        Pop_Client_State                            ; deallocate client regs area
@@:
        popad
dos_can1:

;
;       call RM to enable VGA (use API)

;       LPL: call below occured before flags had been set indicating
;       a switch to DOS mode, which caused race conditions (specifically,
;       when using hardware DVD players we have seen the system lock up
;       because FIFO activity continues after this disable of context switching,
;       and the system then hangs waiting for the FIFOs to empty (see bug 20000601-184547)).
;       There is a call to this same routine later in the switch to DOS.
;       We believe it's safe to remove this one.
;
;        push    ebx 
;        mov     ebx, DEFAULT_PRIMARY_HDEV
;        mov     eax, NVRM_API_ENABLEVGA
;        call    CallRM
;        pop     ebx
        
; Blank the secondary display on a dual-head adapter in case this is message mode
        push    ebx 
        mov     ebx, DEFAULT_PRIMARY_HDEV
        mov     eax, NVRM_API_BLANK_SECONDARY
        call    CallRM
        pop     ebx

        ; After the RM-EnableVGA, the RM has forced GET=PUT and
        ; all channels are idle. To make sure that no one renders
        ; anything, set some shared flags that say 'We are in a
        ; fullscreen DOS BOX -- don't do any rendering.'
        ; Top bit of 0 indicates that we are in a fullscreen
        ; DOS box. Top bit of 1 indicates that we are in
        ; the Windows VM. The low 31bits are individual 'enable'
        ; bits that D3D will clear as each sub-system reinits
        ; itself on returning to the Windows VM from fullscreen DOS.
        mov     eax,pDDrawFullScreenDOSActive
        or      eax,eax
        je      @F
        mov     dword ptr [eax],7FFFFFFFH
@@:

;
; CANOPUS TV Programming -- only use if customer is CANOPUS
;
;;   We switching off the INACTIVE bit off the "our" TV_FLAG_REGISTER in the BIOS
;;       because in VGA mode the bios should initialize (or switch off) the Chrontel
;;       It seems that if the driver does this, this will be to be to late...
;
        test    nvCustomer, NVCUSTOMER_CANOPUS
        jz      PHRTV_NoCanopus13

        mov     al, bCanopusTVReg       ;-- first check, if the BIOS supports Canopus TV 
        or          al, al                      
        jz          PHRTV_NoCanopus14   ; no, not supported

        call    GetCRTCPort             ;-- first unlock the registers
        mov     ax, 0571fh              ; (nobody knows what the heck the RM does...:-)
        out     dx, ax
        call    GetCRTCPort             ;-- next read TV Flag register
        mov         edi,ebx                     ;get pointer to our CB data area
        add         edi,OurCBDataPointer        ;EDI --> our CB data area for this VM
        mov         ah,[edi].PerVMData.EXT_CanopusTVReg
        test    ah, 040h                ; already initialized ???
        jnz     @F                      ; yes, go on

        mov     al, bCanopusTVReg       ; else get the current register contents
        out     dx, al
        inc     dx              
        in          al, dx
        dec     dx
        mov     ah, al                  ; and modify this one...
@@:
        and     ah, 07fh                ; clear the INACTIVE flag (TV_FLAG_REGISTER)
        mov     al, bCanopusTVReg                       
        out     dx, ax                  ; and write the new value back...
        jmp     short PHRTV_NoCanopus14
PHRTV_NoCanopus13:
;   tell the BIOS to program the TV encoder
        call    TellBIOSProgramTV
;
PHRTV_NoCanopus14:

;
MHTVExit:
        ret
EndProc MiniVDD_PreHiResToVGA
;
;
public  MiniVDD_PostHiResToVGA
BeginProc MiniVDD_PostHiResToVGA, DOSVM
;
;Entry:
;       EBX contains the VM handle of the new CRTC owner.
;
;This routine will be called if we're running VGA.DRV, SUPERVGA.DRV, or
;NVIDIA.DRV and applies to all drivers.
;
;This routine is called after the ROM BIOS call is made to place the hardware
;back in the standard VGA state.  You should reenable trapping and do any
;other post-processing that your hardware might need:
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_PostHiResToVGA", DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        mov     ModeChangeFlags,0       ;flag that we're done with mode change
        mov     InFullScreen, 0ffh      ; mark that we're now in full screen mode  CANOPUS

        call    unlock_ext
        call    GetCRTCPort             ; EDX --> CRTC index register

;   MOVED TO PREVGATOHIRES to allow mode switches to take effect in full screen DOS.
;   tell the BIOS NOT to program the TV encoder
;        call    GetCRTCPort
;        mov     al,BIOS_SCRATCH1          ; BIOS scratch reg
;        out     dx,al
;        inc     dx
;        in      al,dx
;        or      al,BIOS_PGRM_TV           ; set bit 1 (do not program TV encoder)
;        out     dx,al

;   Switch to VGA-compatible timing (RM modeset sets non-VGA timing for DirectX compatibility)
        mov     al,21h
        out     dx,al
        inc     dx
        in      al,dx
        and     al,0feh
        out     dx,al

        push    ebx
        add     ebx, OurCBDataPointer
        mov     [ebx].PerVMData.GoingFullscreen, 1
        pop     ebx

        ;
        ; Refresh MessageModeCBData
        ;
        ; save real mode window state
        push    eax
        push    ebx
        push    esi
        push    edx
        call    SaveNVAccessState
        mov     ebx,OFFSET32 MessageModeCBData
        mov     [ebx].PerVMData.EXT_RealModeAccess,al
        mov     [ebx].PerVMData.EXT_RealModeAddress,esi
        mov     [ebx].PerVMData.EXT_RealModeData32,dx
        ; save dac
        REG_RD32(NV_PRAMDAC_VPLL_COEFF)
        mov     [ebx].PerVMData.EXT_NV_VPLL_COEFF,eax
        REG_RD32(NV_PRAMDAC_VPLL2_COEFF)
        mov     [ebx].PerVMData.EXT_NV_VPLL2_COEFF,eax
        ; save VCLK/2
        REG_RD32(NV_PRAMDAC_PLL_COEFF_SELECT)
        mov     [ebx].PerVMData.EXT_NV_PRAMDAC,eax
        ; Save DAC General Control
        REG_RD32(NV_PRAMDAC_GENERAL_CONTROL)
        mov     [ebx].PerVMData.EXT_NV_PDAC_GEN_CTRL,eax
        ;
        pop     edx
        pop     esi
        pop     ebx
        pop     eax

;ifdef DISPLAY_SWITCH
                cmp             DisplayChanged,0                ;set in PostCRTCModeChange
                je              DispNC
                mov             DisplayChanged,0
;If display type changed, save the standard crtc regs;
;The BIOS was called to set the mode for this display, but the VDD will mess things up,
;so we'll save the CRTC's here and restore them in RestoreRegisters.
                mov             RestoreStdCRTC,1                        ; set flag for RestoreRegisters

        mov     edi,ebx                 ;get pointer to our CB data area
        add     edi,OurCBDataPointer    ;EDI --> our CB data area for this VM
                push    ebx

;;;             mov             dx,3c4h                                 ;save sequencer 1
;;;             mov             al,1
;;;             out             dx,al
;;;             inc     dx
;;;             in              al,dx
;;;             mov             [edi].PerVMData.SR1,al

                mov             dx,3d4h
                xor             ebx,ebx

;RYAN@TV: We want to save the timing regs, not the VGA regs.
;(Subtle but important difference.)  To that end, enable reading of
;the true CRTC registers
                mov             ax, 013Dh
                out             dx, ax

;       save 0-18h
savstd:
                mov             al,bl
                out             dx,al
                inc             dx
                in              al,dx
                dec             dx
                mov             [edi+ebx].PerVMData.StdCRTC,al
                inc             bx
                cmp             bx,19h
                jne             savstd

;RYAN@TV: Now, re-enable reading of the "fake" CRTC registers.
                mov             ax, 003Dh
                out             dx, ax

                pop             ebx
DispNC:
;endif ; DISPLAY_SWITCH


        call    restore_lock
;
;We have just entered a full screen VGA DOS box and none of the CRTC registers
;were trapped.  We need to get a snapshot of the NV extended registers in
;this new CRTC mode since we may have inappropriate states saved.
;
                cmp         ebx,MessageModeID   ;are we switching to Message Mode?
                je          @f                                  ;yes, don't do the save!
                call    MiniVDD_SaveRegisters   ;go save new state of registers
@@:

;IFDEF SUPER_VGA_FIX
;       may need to copy framebuffer from our save buffer
                cmp             fbBuffer,0
                jz              copyfb_done

                mov             esi,fbBuffer
                mov             edi,fbAddr
                mov             ecx,(08000h/4 - 1)
                rep     movsd
                VMMCall _HeapFree, <fbBuffer, 0>
                mov             fbBuffer,0
copyfb_done:
;ENDIF ;SUPER_VGA_FIX

MPHVExit:
        ret                             ;
EndProc MiniVDD_PostHiResToVGA
;
;
subttl          Prepare to Enter HiRes Mode From a Standard VGA Mode
page +
public  MiniVDD_PreVGAToHiRes
BeginProc MiniVDD_PreVGAToHiRes, DOSVM
;
;We are notified that the VDD is about to call the display driver to
;switch into HiRes mode from a full screen VGA DOS box.  We can do
;anything necessary to prepare for this.  In the case of the NVIDIA VDD,
;we simply set a flag telling us that we're about to change modes.
;
;Entry:
;       EBX contains the Windows VM handle.
;Exit:
;       Nothing assumed.
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_PreVGAToHiRes", DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        or      ModeChangeFlags,GOING_TO_WINDOWS_MODE
        mov     DosBoxActive,0  ; back to Windows, trap int 10 in dual head mode

;
; CANOPUS TV PROGRAMMING -- only use if customer is CANOPUS
;
;;   We switching off the INACTIVE bit off the "our" TV_FLAG_REGISTER in the BIOS
;;       because in VGA mode the bios should initialize (or switch off) the Chrontel
;;       It seems that if the driver does this, this will be to be to late...
        test    nvCustomer, NVCUSTOMER_CANOPUS
        jz      PHRTV_NoCanopus23
        mov     al, bCanopusTVReg               ;-- first check, if the BIOS supports Canopus TV 
        or          al, al                      
        jz          PHRTV_NoCanopus24   ; no, not supported

        call    GetCRTCPort             ;-- first unlock the registers
        mov     ax, 0571fh              ; (nobody knows what the heck the RM does...:-)
        out     dx, ax
        call    GetCRTCPort             ;-- next read TV Flag register
        mov         edi,ebx                     ;get pointer to our CB data area
        add         edi,OurCBDataPointer        ;EDI --> our CB data area for this VM
        mov         ah,[edi].PerVMData.EXT_CanopusTVReg
        test    ah, 040h                ; already initialized ???
        jnz     @F                      ; yes, go on

        mov     al, bCanopusTVReg       ; else get the current register contents
        out     dx, al
        inc     dx              
        in          al, dx
        dec     dx
        mov     ah, al                  ; and modify this one...
@@:
        and     ah, 07fh                ; clear the INACTIVE flag (TV_FLAG_REGISTER)
        mov     al, bCanopusTVReg                       
        out     dx, ax                  ; and write the new value back...
PHRTV_NoCanopus23:
;
;   tell the BIOS NOT to program the TV encoder
        call    TellBIOSNotProgramTV
PHRTV_NoCanopus24:

        mov     InFullScreen, 0h            ; mark that we're leaving full screen mode  CANOPUS

;IFDEF SUPER_VGA_FIX
;When Super VGA modes get windowed, the VDD can't handle it. When the user returns to full screen,
;the fb content is lost. We can fix this by copying the frame buffer and restoring it when we
;return to full screen. The only problem is that the cursor position will be wrong.
                
;Find out what mode we are in
                mov             dx,3d4h
                xor             al,al                   ; read CR00
                out             dx,al
                inc             dx
                in              al,dx
                cmp             al,5fh                  ; greater than 640?
                jbe             save_not_needed ; no, VDD can handle

;In some modes, the Grabber won't correctly save and restore memory.
; We'll do it ourselves here.
                VMMCall _HeapAllocate, <8000h, 0>
                cmp             eax,0
                jz              @f

;Copy 32k
                mov             esi, fbAddr
                mov             fbBuffer,eax
                mov             edi, eax
                mov             ecx, (08000h/4 - 1)
                rep movsd
@@:
                mov             fbBuffer,eax

save_not_needed:
;ENDIF SUPER_VGA_FIX

;For NVidia, tell the resource manager we are returing to HiRes mode so it
;can restore all the contexts.

;       call RM to enable VGA (use API)
                push    ebx
                mov     ebx, DEFAULT_PRIMARY_HDEV
                mov     eax, NVRM_API_ENABLEHIRES
                call    CallRM
                pop     ebx 

;
MSVHExit:
        ret                             ;
EndProc MiniVDD_PreVGAToHiRes
;
;
public  MiniVDD_PostVGAToHiRes
BeginProc MiniVDD_PostVGAToHiRes, DOSVM
;
;We are notified that the VDD is done setting the hardware state back
;to HiRes mode.  We simply unset our ModeChangeFlags in this case.
;
;Entry:
;       EBX contains the Windows VM handle.
;Exit:
;       Nothing assumed.
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_PostVGAToHiRes", DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG

        mov    ModeChangeFlags,0      ;

        ; Top bit of 0 indicates that we are in a fullscreen
        ; DOS box. Top bit of 1 indicates that we are in
        ; the Windows VM. The low 31bits are individual 'enable'
        ; bits that D3D will clear as each sub-system reinits
        ; itself on returning to the Windows VM from fullscreen DOS.
        mov     eax,pDDrawFullScreenDOSActive
        or      eax,eax
        je      @F
        or      dword ptr [eax],80000000H
@@:


;
; CANOPUS TV Programming -- only use if customer is CANOPUS
;
;;   We switching off the INACTIVE bit off the "our" TV_FLAG_REGISTER in the BIOS
;;       because in VGA mode the bios should initialize (or switch off) the Chrontel
;;       It seems that if the driver does this, this will be to be to late...
;
    test    nvCustomer, NVCUSTOMER_CANOPUS
    jz      skip_MPVTHR_Canopus01
    
        pusha

        mov     al, bCanopusTVReg       ;-- first check, if the BIOS supports Canopus TV 
        or      al, al                  
        jz      @F                      ; no, not supported

        call    GetCRTCPort             ;-- first unlock the registers
        mov     ax, 0571fh              ; (nobody knows what the heck the RM does...:-)
        out     dx, ax
        call    GetCRTCPort             ;-- next read Canopus TV register
        mov     al, bCanopusTVReg
        out     dx, al
        inc     dx              
        in      al, dx
        dec     dx
        or      al, TVF_INACTIVE        ; set the INACTIVE flag (TV_FLAG_REGISTER)
        mov     ah, al
        mov     al, bCanopusTVReg                       
        out     dx, ax                  ; and write the new value back...
@@:
        popa
skip_MPVTHR_Canopus01:
;
MPVHExit:
        ret                             ;
EndProc MiniVDD_PostVGAToHiRes
;
;
subttl          Save and Restore Routines for Extension Registers
page +
public  MiniVDD_SaveRegisters
BeginProc MiniVDD_SaveRegisters, DOSVM
;
;This routine is called whenever the "main" VDD is called upon to save
;the register state.  The "main" VDD will save all of the states of the
;"normal" VGA registers (CRTC, Sequencer, GCR, Attribute etc.) and will
;then call this routine to allow the mini-VDD to save register states
;that are hardware dependent.  These registers will be restored during the
;routine MiniVDD_RestoreRegisterState.  Typically, only a few registers
;relating to the memory access mode of the board are necessary to save
;and restore.  Specific registers that control the hardware BLTer probably
;need not be saved.  The register state is saved in the mini-VDD's
;"CB data area" which is a per-VM state saving area.  The mini-VDD's
;CB data area was allocated at Device_Init time.
;
;Entry:
;       EBX contains the VM handle for which these registers are being saved.
;Exit:
;       You must preserve EBX, EDX, EDI, and ESI.
;
; MSK - TODO - Why do other VDD's only do a few registers and why does comment
; above say only registers relating to memory access mode are needed to be saved
; and restored.
; One possible explination is that set modes are always done for switching to full
; screen dos boxes, and thus this is only needed for the MemC support for windowed
; DOS boxes.  What about message mode?  Does it do a setmode?
; idea, use protected mode interface to call the BIOS to save the state into a buffer
; Remember case of CRTC being the foreground full screen DOS box, and
; MemC being a different background DOS box.
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_SaveRegisters", DEBLEVELMAX
                Debug_Printf    ":VM:%08lX", ebx, DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG

        cmp     nvAddr,0      ;running NVidia drivers?
        je      MSRSExit                ;nope, don't do this

        push    edx                     ;save required registers
        push    edi                     ;
        mov     edi,ebx                 ;get pointer to our CB data area
        add     edi,OurCBDataPointer    ;EDI --> our CB data area for this VM

        call    GetCRTCPort             ;EDX --> CRTC index register
        in      al,dx                   ;get and save current CRTC index ...
        ror     eax,8                   ;in high byte of EAX

        call    ReadCr44                ;Read Cr44        
        mov     [edi].PerVMData.EXT_HeadOwner,al

        .if (al == 04)
                xor     ax,ax        ;Clear ax
                call    WriteCr44    ;Set CR44 to Head A
        .endif

;
;        unlock_extension_regs
        call    unlock_ext
;
        mov     al, 19h                 ;set to CRTC index 019h
        out     dx,al                   ;
        inc     edx                     ;EDX --> CRTC data register
        in      al,dx                   ;get data from CRTC register 019h
        dec     edx                     ;EDX --> CRTC index register
                                        ;save the data in our CB data structure
        mov     [edi].PerVMData.EXT_Repaint0NV,al
;
        mov     al, 1Ah                 ;set to CRTC index 01Ah
        out     dx,al                   ;
        inc     edx                     ;EDX --> CRTC data register
        in      al,dx                   ;get data from CRTC register 01Ah
        dec     edx                     ;EDX --> CRTC index register
                                        ;save the data in our CB data structure
        mov     [edi].PerVMData.EXT_Repaint1NV,al
                                        ;signal that this register is valid
        mov     [edi].PerVMData.EXT_Repaint1NVSet,0FFh
;
        mov     al, 1Bh                 ;set to CRTC index 01Bh
        out     dx,al                   ;
        inc     edx                     ;EDX --> CRTC data register
        in      al,dx                   ;get data from CRTC register 01Bh
        dec     edx                     ;EDX --> CRTC index register
                                        ;save the data in our CB data structure
        mov     [edi].PerVMData.EXT_FifoBurst,al
;
        mov     al, 1Ch                 ;set to CRTC index 01Ch
        out     dx,al                   ;
        inc     edx                     ;EDX --> CRTC data register
        in      al,dx                   ;get data from CRTC register 01Ch
        dec     edx                     ;EDX --> CRTC index register
                                        ;save the data in our CB data structure
        mov     [edi].PerVMData.EXT_Repaint3NV,al
;
        mov     al, 1Dh                 ;set to CRTC index 01Dh
        out     dx,al                   ;
        inc     edx                     ;EDX --> CRTC data register
        in      al,dx                   ;get data from CRTC register 01Dh
        dec     edx                     ;EDX --> CRTC index register
                                        ;save the data in our CB data structure
        mov     [edi].PerVMData.EXT_WriteBank,al
;
        mov     al, 1Eh                 ;set to CRTC index 01Eh
        out     dx,al                   ;
        inc     edx                     ;EDX --> CRTC data register
        in      al,dx                   ;get data from CRTC register 01Eh
        dec     edx                     ;EDX --> CRTC index register
                                        ;save the data in our CB data structure
        mov     [edi].PerVMData.EXT_ReadBank,al
;
        mov     al, 20h                 ;set to CRTC index 020h
        out     dx,al                   ;
        inc     edx                     ;EDX --> CRTC data register
        in      al,dx                   ;get data from CRTC register 020h
        dec     edx                     ;EDX --> CRTC index register
                                        ;save the data in our CB data structure
        mov     [edi].PerVMData.EXT_FifoLowWaterMark,al
;
        mov     al, 25h                 ;set to CRTC index 025h
        out     dx,al                   ;
        inc     edx                     ;EDX --> CRTC data register
        in      al,dx                   ;get data from CRTC register 025h
        dec     edx                     ;EDX --> CRTC index register
                                        ;save the data in our CB data structure
        mov     [edi].PerVMData.EXT_ExtraBits,al
;
        mov     al, 28h                 ;set to CRTC index 028h
        out     dx,al                   ;
        inc     edx                     ;EDX --> CRTC data register
        in      al,dx                   ;get data from CRTC register 028h
        dec     edx                     ;EDX --> CRTC index register
                                        ;save the data in our CB data structure
        mov     [edi].PerVMData.EXT_PixelFormat,al
;
        mov     al, 29h                 ;set to CRTC index 029h
        out     dx,al                   ;
        inc     edx                     ;EDX --> CRTC data register
        in      al,dx                   ;get data from CRTC register 029h
        dec     edx                     ;EDX --> CRTC index register
                                        ;save the data in our CB data structure
        mov     [edi].PerVMData.EXT_TVDecimation,al
;
; CANOPUS TV Programming
;
        test    nvCustomer, NVCUSTOMER_CANOPUS
        jz      @f
CANOPUS_SaveRegisters:
        mov         al, bCanopusTVReg   ;set to CRTC index CanopusTVReg
        or          al, al                      ; Canopus TV supported ?
        jz          @F                  ; No, go on

        out         dx,al                       ;
        inc         edx                 ;EDX --> CRTC data register
        in          al,dx                       ;get data from Canopus TV register 
        dec         edx                 ;EDX --> CRTC index register
;; For Canopus TV we use this register as Flag register and won't like 
;; the VDD to touch bit 7
        and         al, NOT TVF_INACTIVE        ; don't touch bit 7 !!!
                                        ;save the data in our CB data structure
        mov         [edi].PerVMData.EXT_CanopusTVReg,al
@@:


        mov     al, 2Ah                 ;set to CRTC index 02Ah
        out     dx,al                   ;
        inc     edx                     ;EDX --> CRTC data register
        in      al,dx                   ;get data from CRTC register 02Ah
        dec     edx                     ;EDX --> CRTC index register
                                        ;save the data in our CB data structure
        mov     [edi].PerVMData.EXT_OverscanHigh,al
;
        mov     al, 2Dh                 ;set to CRTC index 02Dh
        out     dx,al                   ;
        inc     edx                     ;EDX --> CRTC data register
        in      al,dx                   ;get data from CRTC register 02Dh
        dec     edx                     ;EDX --> CRTC index register
                                        ;save the data in our CB data structure
        mov     [edi].PerVMData.EXT_HorizontalExtra,al
;
        mov     al, 30h                 ;set to CRTC index 030h
        out     dx,al                   ;
        inc     edx                     ;EDX --> CRTC data register
        in      al,dx                   ;get data from CRTC register 030h
        dec     edx                     ;EDX --> CRTC index register
                                        ;save the data in our CB data structure
        mov     [edi].PerVMData.EXT_HWCursorAddress0,al
;
        mov     al, 31h                 ;set to CRTC index 031h
        out     dx,al                   ;
        inc     edx                     ;EDX --> CRTC data register
        in      al,dx                   ;get data from CRTC register 031h
        dec     edx                     ;EDX --> CRTC index register
                                        ;save the data in our CB data structure
        mov     [edi].PerVMData.EXT_HWCursorAddress1,al
;
        mov     al, 32h                 ;set to CRTC index 032h
        out     dx,al                   ;
        inc     edx                     ;EDX --> CRTC data register
        in      al,dx                   ;get data from CRTC register 032h
        dec     edx                     ;EDX --> CRTC index register
                                        ;save the data in our CB data structure
        mov     [edi].PerVMData.EXT_VideoWindow0,al
;
        mov     al, 33h                 ;set to CRTC index 033h
        out     dx,al                   ;
        inc     edx                     ;EDX --> CRTC data register
        in      al,dx                   ;get data from CRTC register 033h
        dec     edx                     ;EDX --> CRTC index register
                                        ;save the data in our CB data structure
        mov     [edi].PerVMData.EXT_VideoWindow1,al
;
        mov     al, 39h                 ;set to CRTC index 039h
        out     dx,al                   ;
        inc     edx                     ;EDX --> CRTC data register
        in      al,dx                   ;get data from CRTC register 039h
        dec     edx                     ;EDX --> CRTC index register
                                        ;save the data in our CB data structure
        mov     [edi].PerVMData.EXT_Interlace,al
;
; save real mode window state
        push    eax
        push    esi
        push    edx
        call    SaveNVAccessState
        mov     [edi].PerVMData.EXT_RealModeAccess,al
        mov     [edi].PerVMData.EXT_RealModeAddress,esi
        mov     [edi].PerVMData.EXT_RealModeData32,dx
IF 1
; save dac
        REG_RD32(NV_PRAMDAC_VPLL_COEFF)
        mov     [edi].PerVMData.EXT_NV_VPLL_COEFF,eax
; save VCLK/2
        REG_RD32(NV_PRAMDAC_PLL_COEFF_SELECT)
        mov     [edi].PerVMData.EXT_NV_PRAMDAC,eax
; Save DAC General Control
        REG_RD32(NV_PRAMDAC_GENERAL_CONTROL)
        mov     [edi].PerVMData.EXT_NV_PDAC_GEN_CTRL,eax
ENDIF
        ;
        pop     edx
        pop     esi
        pop     eax

                call    restore_lock

        .if ([edi].PerVMData.EXT_HeadOwner == 04)
                mov     al,04h        ;Set CR44 back to broadcast mode
                call    WriteCr44     ;Do the write thing
        .endif

;Restore the CRTC index register saved in the high byte of EAX:
;
        rol     eax,8                   ;
        out     dx,al                   ;
;
        pop     edi                     ;restore saved registers
        pop     edx                     ;
;
MSRSExit:
        ret
EndProc MiniVDD_SaveRegisters
;
;
subttl          Save and Restore Routines for Extension Registers
page +
public  MiniVDD_RestoreRegisters
BeginProc MiniVDD_RestoreRegisters, DOSVM
;
;This routine is called whenever the "main" VDD is called upon to restore
;the register state.  The "main" VDD will restore all of the states of the
;"normal" VGA registers (CRTC, Sequencer, GCR, Attribute etc.) and will
;then call this routine to allow the mini-VDD to restore register states
;that are hardware dependent.  These registers were saved during the
;routine MiniVDD_SaveRegisterState.  Typically, only a few registers
;relating to the memory access mode of the board are necessary to save
;and restore.  Specific registers that control the hardware BLTer probably
;need not be saved.  The register state is saved in the mini-VDD's
;"CB data area" which is a per-VM state saving area.  The mini-VDD's
;CB data area was allocated at Device_Init time.
;
;Entry:
;       ESI contains the VM handle for the MemC owner VM.
;       ECX contains the VM handle for the CRTC owner VM.
;Exit:
;       You must preserve EBX and EDX.  The caller preserves everything else.
;
;A short explanation of the terms "CRTC owner" and "MemC owner" is in order.
;The CRTC owner VM is the VM that owns the screen mode.  If you're running
;on the Windows desktop, then the Windows VM is the CRTC owner.  If you're
;running a full-screen DOS box, then that DOS box's VM is the CRTC owner.
;If you're running a DOS box in a window, then the CRTC owner is Windows
;but the MemC owner is the DOS VM.  What significance does this have?
;Well, when you restore the register state of a DOS VM running in a
;Window, it means that you're getting ready to VIRTUALIZE the VGA by
;using the off-screen memory.  Your VGA hardware must be setup to write
;to this memory in EXACTLY THE SAME WAY AS IF THE VGA WAS RUNNING IN
;NATIVE VGA MODE.  But...  you also must preserve the appearance of the
;Windows screen which is being displayed on the VISIBLE screen.  Thus,
;we have the screen looking like it's running in Windows HiRes packed
;pixel mode from the user's perspective, but the CPU sees the video
;memory as a 4 plane VGA.  Thus, we present this routine with both
;the CRTC owner and the MemC owner's VM handles.  Therefore, you can
;restore those states from the CRTC owner that preserve the appearance
;of the screen while restoring those states from the MemC owner that
;control how the CPU sees the video memory.
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_RestoreRegisters", DEBLEVELMAX
                Debug_Printf    ":VM:%08lX", ebx, DEBLEVELMAX
                Debug_Printf    ":CRTC:%08lX", ecx, DEBLEVELMAX
                Debug_Printf    ":MemC:%08lX", esi, DEBLEVELMAX
                Debug_Printf    "\n\r", DEBLEVELMAX
                call    DumpRegisters
                pop     eax
        .endif
ENDIF ; DEBUG_LOG

        push    ebx
        push    ecx
        push    edx                     ;save caller's EDX
        push    esi


        cmp     DisplayEnabledFlag,0    ;is display in HiRes mode yet?
        je      MRRSExit                ;nope, don't do anything yet
        cmp     nvAddr,0                            ;running NVidia drivers?
        je      MRRSExit                ;nope, don't do this
;
        test    ModeChangeFlags,GOING_TO_WINDOWS_MODE OR GOING_TO_VGA_MODE
        jnz     MRRSExit                ;in a mode change, don't restore now
;
        cmp     ecx,WindowsVMHandle     ;is it the system VM?
        jz      MRRSExit                ;there are no registers which need to be restored
        
        .if (esi == MessageModeID)                      ;Does message mode own the MemC
                mov     esi,OFFSET32 MessageModeCBData  ;ESI --> Forced Message Mode CB Data
        .elseif (esi == PlanarStateID)                  ;Does planar state own the MemC
                mov     esi,OFFSET32 ForcedPlanarCBData ;ESI --> Forced Planar CB data
        .else
                add     esi,OurCBDataPointer            ;ESI --> MemC's CB data
        .endif
;
        .if (ecx == MessageModeID)                      ;Does message mode own the CRTC
                mov     ecx,OFFSET32 MessageModeCBData  ;ECX --> Forced Message Mode CB Data
        .else
                add     ecx,OurCBDataPointer            ;ECX --> CRTC's CB data

if 0   ;ifdef DISPLAY_SWITCH
; If the display device changes while a window'd DOS VM was active, we need to let the BIOS
; program the standard and extended CRTC regs, since the main VDD may have saved timings 
; for the previous device, and our saved copy of the extended CRTCs is probably stale, too.

                ;is this the VM that's about to go fullscreen?
                cmp     [ecx].PerVMData.GoingFullscreen, 1
                jne     noBiosRestore
                mov     [ecx].PerVMData.GoingFullscreen, 0

                ;is this an alphanumeric mode?
                mov             dx,     3CEh
                mov             al,     6h
                out             dx,     al
                in              ax,     dx
                and             ah,     1
                jnz             noBiosRestore

                ;did a head change occur prior to this?
                cmp             DisplayChanged,0
                jz              noBiosRestore
                mov             DisplayChanged,0

                ;let the BIOS reconfigure the CRTCs for the new active head

                ;save text cursor position
                mov             dx,     3D4h
                mov             al,     0Eh
                out             dx,     al
                in              ax,     dx
                push            eax
                inc             al
                out             dx,     al
                in              ax,     dx
                push            eax

                ;get MSL
                mov             al,     9h
                out             dx,     al
                in              ax,     dx
                movzx           bx,     ah
                and             bx,     1Fh
                inc             bx

                ;get VDE
                mov             ax,     7h
                out             dx,     al
                in              ax,     dx
                and             ax,     200h
                shl             eax,    7
                mov             al,     12h
                out             dx,     al
                in              ax,     dx
                shr             eax,    8
                inc             ax

                ;compute VDE/MSL
                xor             dx,     dx
                idiv            bx
                mov             cx,     ax      ;number of text rows on the screen

                ;set the mode 
                mov             ax,     0083h   ;nondestructive mode 3
                push            10h
                VMMCall         Exec_VxD_Int
                mov             ax,     1201h   ;350 scanlines
                cmp             cx,     43
                je              @F
                mov             ax,     1202h   ;400 scanlines
@@:             mov             bl,     30h
                push            10h
                VMMCall         Exec_VxD_Int
                mov             ax,     0083h   ;nondestructive mode 3
                push            10h
                VMMCall         Exec_VxD_Int
                mov             ax,     1112h   ;load 8x8 font (43/50 lines)
                cmp             cx,     25
                jne             @F
                mov             ax,     1114h   ;load 8x16 font (25 lines)
@@:             mov             bl,     0
                push            10h             ;the BIOS infers dot clock and sync
                VMMCall         Exec_VxD_Int    ;polarities from this and the above

                ;restore cursor position
                mov             dx,     3D4h
                pop             eax
                out             dx,     ax
                pop             eax
                out             dx,     ax

                jmp             MRRSExit

noBiosRestore:
endif ;endif ; DISPLAY_SWITCH

        .endif
;
MRRSGotAddr:

        call    GetCRTCPort             ;EDX --> CRTC index register
        in      al,dx                   ;get and save current CRTC index ...
        ror     eax,8                   ;in high byte of EAX

; Broadcast mode support
; If we intend to support broadcast mode, we need to save either
; both heads or one head data here.  Either way, we need to turn off
; broadcast mode if it's set so we don't override
; Here's the current decision tree
; save current_mode on stack
; if (current_mode == broadcast)
;     restore previous head only and return to broadcast mode
; else
;     restore without changing head at all
;
; Old code was not broadcast mode aware.  It just assumed that CR44
; pointed to the active head.  So we don't want to change that.
;
        call    ReadCr44        ; GetCr44 in al
        
        .if (al == 04)
                ; currently we're in broadcast
                or      al,80h                           ;flag that we need to restore CR44
                ror     eax,8                            ;store al in highest byte
                                                         ;original index now in next highest byte
                mov     al,[ecx].PerVMData.EXT_HeadOwner ;retrieve stored CR44
                call    WriteCr44
        .else
                ror     eax,8                            ;not needed, but for consistency
                                                         ;original index now in next highest byte
        .endif

;        unlock_extension_regs
        call    unlock_ext    
;
;We need to restore the state of the saved CRTC and Sequencer registers:
;
; MSK - NOTE: SetVDDBank does not change banking control in 01Ah
; it depends on things being write after RESTORE_REGISTERS because
; that is what the Windows 95 DDK documentation under GET_VDD_BANK
; says to do.
        mov     al,19h                  ;set to CRTC index 19h
                                        ;get CRTC owner's value for this reg
        mov     ah,[ecx].PerVMData.EXT_Repaint0NV
        out     dx,ax                   ;
;
        mov     al,1Ah                  ;set to CRTC index 1Ah
        mov     ah,[ecx].PerVMData.EXT_Repaint1NV ;get CRTC owner's value for this reg
        .if (ecx == OFFSET32 MessageModeCBData)   ;Does message mode own the CRTC?
                and     ah,3fh                    ;we can enable syncs; we may have saved wrong setting if we loaded on another device
        .else
                in al,dx                ; get current value
                and al,0c0h
                and ah,3fh
                or  ah,al               ; use current sync settings
                mov al,1Ah
        .endif
        out     dx,ax                   ;
;
        mov     al,1Bh                  ;set to CRTC index 1Bh
                                        ;get CRTC owner's value for this reg
        mov     ah,[ecx].PerVMData.EXT_FifoBurst
        out     dx,ax                   ;
;
        ; We have to be a little careful with index 1C, since it holds the
        ; FIFO Burst Mode (bit 5), which indicates how the value in the FIFO
        ; Burst register (1B) should be interpreted (NV11 arbitration sets it
        ; to 0x1). Take everything, but bit 5, from MemC owner's (esi) ptr.

        push    ebx
        mov     al,1Ch                  ;set to CRTC index 1Ch
                                        ;get MemC owner's value for this reg
        mov     ah,[esi].PerVMData.EXT_Repaint3NV
        and     ah,NOT 20h              ;clear Fifo Burst Mode Bit
        mov     bh,[ecx].PerVMData.EXT_Repaint3NV
        and     bh,20h                  ;get CRTC owner's value for Fifo Burst Mode
        or      ah,bh                   ;combine the values
        out     dx,ax                   ;
        pop     ebx        
;
        cmp     esi,ecx                 ;Only restore banking if MemC owns the CRTC
                                        ;(also try using CRTC, but only if not the Windows VM)
        jne     @f
        mov     al,1Dh                  ;set to CRTC index 1Dh
                                        ;get MemC owner's value for this reg
        mov     ah,[esi].PerVMData.EXT_WriteBank
        out     dx,ax                   ;
;
        mov     al,1Eh                  ;set to CRTC index 1Eh
                                        ;get MemC owner's value for this reg
        mov     ah,[esi].PerVMData.EXT_ReadBank
        out     dx,ax                   ;
@@:
;
        mov     al,20h                  ;set to CRTC index 20h
                                        ;get CRTC owner's value for this reg
        mov     ah,[ecx].PerVMData.EXT_FifoLowWaterMark
        out     dx,ax                   ;
;
        mov     al,25h                  ;set to CRTC index 25h
                                        ;get CRTC owner's value for this reg
        mov     ah,[ecx].PerVMData.EXT_ExtraBits
        out     dx,ax                   ;
;
        mov     al,28h                  ;set to CRTC index 28h
                                        ;get CRTC owner's value for this reg
        mov     ah,[ecx].PerVMData.EXT_PixelFormat
        out     dx,ax                   ;
;
        mov     al,29h                  ;set to CRTC index 29h
                                        ;get CRTC owner's value for this reg
        mov     ah,[ecx].PerVMData.EXT_TVDecimation
        out     dx,ax                   ;

        ; CANOPUS TV Programming
        ;
        test    nvCustomer, NVCUSTOMER_CANOPUS
        jz      @f
                ;; for Canopus TV we use this register as Flag register and won't like 
                ;;       the VDD to touch bit 7 !!!
CANOPUS_RestoreRegisters:
        mov         al, bCanopusTVReg   ;set to CRTC index Canopus TV register
        or          al, al                          ; Canopus TV supported ?
        jz          @F                          ; No, go on

        out         dx, al
        inc         dx
        in          al, dx                          ; get the current value of the register
        dec         dx
        and         al, TVF_INACTIVE    ; mask out the bit we won't touch..
        mov         ah, al                          ; move value to high byte
                                                    ;get CRTC owner's value for this reg
        or          ah,[ecx].PerVMData.EXT_CanopusTVReg
        mov         al, bCanopusTVReg   ;set to canopus Tv register
        out         dx,ax                           ;
@@:
        
;
        mov     al,2Ah                  ;set to CRTC index 2Ah
                                        ;get CRTC owner's value for this reg
        mov     ah,[ecx].PerVMData.EXT_OverscanHigh
        out     dx,ax                   ;
;
        mov     al,2Dh                  ;set to CRTC index 2Dh
                                        ;get CRTC owner's value for this reg
        mov     ah,[ecx].PerVMData.EXT_HorizontalExtra
        out     dx,ax                   ;
;
; JJV - Don't bother restoring the HW cursor address.
;;;;;        mov     al,30h                  ;set to CRTC index 30h
;;;;;                                        ;get CRTC owner's value for this reg
;;;;;        mov     ah,[ecx].PerVMData.EXT_HWCursorAddress0
;;;;;        out     dx,ax                   ;
;;;;;;
;;;;;        mov     al,31h                  ;set to CRTC index 31h
;;;;;                                        ;get CRTC owner's value for this reg
;;;;;        mov     ah,[ecx].PerVMData.EXT_HWCursorAddress1
;;;;;        out     dx,ax                   ;
        mov     al,32h                  ;set to CRTC index 32h
                                        ;get CRTC owner's value for this reg
        mov     ah,[ecx].PerVMData.EXT_VideoWindow0
        out     dx,ax

; read current CRTC to get device bits
        mov     al,33h                  ;set to CRTC index 33h
        out     dx,al                   ;get current value for this reg
        inc     dx
        in      al,dx
        and     al,11h                  ;get slave bit
        dec     dx
        mov     ah,[ecx].PerVMData.EXT_VideoWindow1 ;get CRTC owner's value for this reg
        and     ah,0eeh                 ;mask slave bit and FP data bit
        or      ah,al                   ;add slave bit
        mov     al,33h
        out     dx,ax                   ;
;
        mov     al,39h                  ;set to CRTC index 39h
                                        ;get CRTC owner's value for this reg
        mov     ah,[ecx].PerVMData.EXT_Interlace
        out     dx,ax                   ;
;
        ; Restore DAC clock
        push    eax
        push    esi
        push    edx
        ;
        mov     eax,[ecx].PerVMData.EXT_NV_VPLL_COEFF
        REG_WR32(NV_PRAMDAC_VPLL_COEFF)

;
        ; Restore VCLK/2
        mov     eax,[ecx].PerVMData.EXT_NV_PRAMDAC
        REG_WR32(NV_PRAMDAC_PLL_COEFF_SELECT)

; Restore DAC General Control
        mov     eax,[ecx].PerVMData.EXT_NV_PDAC_GEN_CTRL
;comment
        REG_WR32(NV_PRAMDAC_GENERAL_CONTROL)
        ;
        ; restore real mode window state
        mov     al,[ecx].PerVMData.EXT_RealModeAccess
        mov     esi,[ecx].PerVMData.EXT_RealModeAddress
        mov     dx,[ecx].PerVMData.EXT_RealModeData32
        call    RestoreNVAccessState

;ifdef DISPLAY_SWITCH
; If we allow the display device to change while a DOS session is active, we also need to
; restore the standard CRTC regs, since the main VDD may have saved timings for the previous
; device. We save std crtc's in postHiResToVga in this case.
                cmp             RestoreStdCrtc,0
                jz              noStdRestore

                mov             RestoreStdCrtc,0
                push    ebx
                mov             dx,3d4h
                xor             ebx,ebx

                mov             al,21h          ;unshadow
                out             dx,al
                inc             dx
                in              al,dx
                dec             dx
                shl             eax,16          ;save shadow bits in eax upper word
                mov             ax,0ff21h       ;enable all
                out             dx,ax
                
                mov             al,11h          ;write enable 0-7
                out             dx,al
                inc             dx
                in              al,dx
                and             al,07fh
                out             dx,al
                dec             dx                              
stdlp:
                mov             al,bl
                mov             ah,[ecx+ebx].PerVMData.StdCRTC
                out             dx,ax           
                inc             bx
                cmp             bx,0eh          ;skip e and f
                jnz             @f
                add             bx,2
@@:             cmp             bx,19h
                jne             stdlp           
                
                pop             ebx
                shr             eax,8           ;restore shadow bits
                mov             al,21h
                out             dx,ax           

                mov             al,11h          ;restore 0-7 write protect
                out             dx,al
                inc             dx
                in              al,dx
                or              al,80h
                out             dx,al

;;;             mov             ah,[ecx].PerVMData.SR1  ; restore SR1
;;;             mov             dx,3c4h
;;;             mov             al,1
;;;             out             dx,ax
noStdRestore:
;endif ; DISPLAY_SWITCH

        ;
        pop     edx
        pop     esi
        pop     eax

                call    restore_lock
                
        rol     eax,8   ;restore eax to determine if CR44 needs resetting
        
        ; Restore Head owner if needed
        .if (al & 80h)            ;if saved_mode needs to be restored
                and     al,7fh    ;remove flag
                call    WriteCr44 ;Write it back
        .endif

;
;Restore the CRTC index register saved in the high byte of EAX:
;
        rol     eax,8                   ;
        out     dx,al                   ;
;
MRRSExit:
        pop     esi
        pop     edx
        pop     ecx                     ;
        pop     ebx
        ret                             ;
EndProc MiniVDD_RestoreRegisters
;
;
subttl          Save and Restore Latches
page +
public  MiniVDD_SaveLatches
BeginProc MiniVDD_SaveLatches, DOSVM
;
;When virtualizing the VGA 4 plane mode, we have to save and restore the
;latches occasionally.  This routine is called for saving
;the latches by simply using the standard VGA CRTC
;register 22H which all super-VGA's possess (we hope).
;
;Entry:
;       EBX contains a Windows VM handle (which must be preserved).
;       EBP --> VM's Client Registers.
;Exit:
;       Save anything that you use.
;
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_SaveLatches", DEBLEVELMAX
                Debug_Printf    ":VM:%08lX\n\r", ebx, DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        push    eax
        push    ebx
        push    ecx
        push    edx
        add     ebx,OurCBDataPointer    ;EBX --> VM's CB data area


        mov     edx,GDC_INDEX           ;EDX --> GC index register
        in      al,dx
        ror     eax,8                   ;save index

        mov     al,004h
        out     dx,al
        inc     edx                     ;EDX --> GC data register
        in      al,dx
        mov     cl,al                   ;save original
        ror     ecx,8                   ;save it in high word

        mov     al,0                    ;set plane 0
        out     dx,al                   ;

        mov     cx,dx                   ;save GC address

        call    GetCRTCPort             ;EDX --> CRTC index register

        in      al,dx
        ror     eax,8                   ;save index

        ; MSK - NOTE: Cirrus docs say that a read from 022h will force read mode 0
        mov     al,022h
        out     dx,al
        inc     edx                     ;EDX --> CRTC data register

        in      al,dx                   ;get latch 0
        mov     [ebx].Latch0,al         ;save in CB structure

        xchg    dx,cx                   ;EDX --> GC data register

        mov     al,1                    ;set plane 1
        out     dx,al

        xchg    dx,cx                   ;EDX --> CRTC data register
        in      al,dx                   ;get latch 1
        mov     [ebx].Latch1,al         ;save in CB structure

        xchg    dx,cx                   ;EDX --> GC data register

        mov     al,2                    ;set plane 2
        out     dx,al

        xchg    dx,cx                   ;EDX --> CRTC data register
        in      al,dx                   ;get latch 2
        mov     [ebx].Latch2,al         ;save in CB structure

        xchg    dx,cx                   ;EDX --> GC data register

        mov     al,3                    ;set plane 3
        out     dx,al

        xchg    dx,cx                   ;EDX --> CRTC data register
        in      al,dx                   ;get latch 3
        mov     [ebx].Latch3,al         ;save in CB structure

        dec     edx                     ;EDX --> CRTC index register
        rol     eax,8                   ; 
        out     dx,al                   ;restore index

        xchg    dx,cx                   ;EDX --> GC data register

        rol     ecx,8                   ;get saved GC[4] value
        mov     al,cl
        out     dx,al                   ;restore GR[4]

        dec     edx                     ;EDX --> GC index register
        rol     eax,8                   ; 
        out     dx,al                   ;restore index

        pop     edx
        pop     ecx
        pop     ebx
        pop     eax
IFDEF DEBUG_LOG
        pushf
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "\n\r", DEBLEVELMAX
                pop     eax
        .endif
        popf
ENDIF ; DEBUG_LOG
        ret                             ;
EndProc MiniVDD_SaveLatches
;
;
public  MiniVDD_RestoreLatches
BeginProc MiniVDD_RestoreLatches, DOSVM
;
;This routine reverses the latch save that we did prior to restoring the
;latches.  Just restore the states that you saved.
;
;Entry:
;       EBX contains a Windows VM handle (which must be preserved).
;       EBP --> VM's Client Registers.
;Exit:
;       Save anything that you use.
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_RestoreLatches", DEBLEVELMAX
                Debug_Printf    ":VM:%08lX", ebx, DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        push    eax
        push    ebx
        push    ecx
        push    edx
        add     ebx,OurCBDataPointer    ;EBX --> VM's CB data area

        call    MiniVDD_SetLatchBank

        mov     edx,GDC_INDEX           ;EDX --> GC index register
        in      al,dx
        ror     eax,8                   ;save index

        mov     al,004h
        out     dx,al
        inc     edx                     ;EDX --> GC data register
        in      al,dx
        ror     eax,8                   ;save it in high word

        mov     ecx,Vid_PhysA0000

        mov     al,0                    ;set plane 0
        out     dx,al                   ;

        mov     al,[ebx].Latch0         ;Latch 0 value
        mov     [ecx],al

        mov     al,1                    ;set plane 1
        out     dx,al                   ;

        mov     al,[ebx].Latch1         ;Latch 1 value
        mov     [ecx],al

        mov     al,2                    ;set plane 2
        out     dx,al                   ;

        mov     al,[ebx].Latch2         ;Latch 2 value
        mov     [ecx],al

        mov     al,3                    ;set plane 3
        out     dx,al                   ;

        mov     al,[ebx].Latch3         ;Latch 3 value
        mov     [ecx],al

        mov     al,[ecx]                ;load the latches!

        rol     eax,8                   ;get saved GC[4] value
        out     dx,al                   ;restore GR[4]

        dec     edx                     ;EDX --> GC index register
        rol     eax,8                   ; 
        out     dx,al                   ;restore index

        call    MiniVDD_ResetLatchBank

        pop     edx
        pop     ecx
        pop     ebx
        pop     eax
IFDEF DEBUG_LOG
        pushf
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "\n\r", DEBLEVELMAX
                pop     eax
        .endif
        popf
ENDIF ; DEBUG_LOG
        ret                             ;
EndProc MiniVDD_RestoreLatches
;
;
subttl          Enable and Disable BLTer Register Trapping
page +
public  MiniVDD_EnableTraps
BeginProc MiniVDD_EnableTraps, DOSVM
;
;As stated elsewhere, the VDD needs to set traps on the BLTer registers used
;by the display driver whenever it is using the off-screen memory to
;virtualize VGA graphics mode in the background or in a window.  The reason
;the VDD does this is to receive notification on the first access to a
;BLTer register AFTER returning to the Windows VM.  Then, the VDD switches
;the state of the hardware back to that appropriate for running Windows
;HiRes mode.  In this routine, all you need to do is call the VMM service
;Enable_Global_Trapping for each of the ports that you registered at
;MiniVDD_Device_Init.  Then, the VDD will receive notification at the
;proper time and will switch states properly.
;
;Entry:
;       Nothing assumed.
;Exit:
;       Just Preserve EBX, and ESI.
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_EnableTraps", DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        ret                             ;
EndProc MiniVDD_EnableTraps
;
;
public  MiniVDD_DisableTraps
BeginProc MiniVDD_DisableTraps, DOSVM
;
;See comment at EnableTraps.
;
;Entry:
;       Nothing assumed.
;Exit:
;       Just Preserve EBX and ESI.
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_DisableTraps", DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        ret                             ;
EndProc MiniVDD_DisableTraps
;
;
subttl          Set Hardware to a Not Busy State
page +
public  MiniVDD_MakeHardwareNotBusy
BeginProc MiniVDD_MakeHardwareNotBusy, DOSVM
;
;Quite often, we need to make sure that the hardware state is not busy
;before changing the MemC mode from the Windows HiRes state to VGA state
;or vice-versa.  This routine allows you to do this (to the best of your
;ability).  You should try to return a state where the hardware BLTer
;isn't busy.
;
;Entry:
;       EAX contains the CRTC owner's VM handle.
;       EBX contains the currently running VM handle.
;       ECX contains the MemC owner's VM handle.
;       EDX contains the CRTC index register.
;Exit:
;       You must save all registers that you destroy except for EAX & ECX.
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_MakeHardwareNotBusy", DEBLEVELMAX
                Debug_Printf    ":VM:%08lX", ebx, DEBLEVELMAX
                Debug_Printf    ":CRTC:%08lX", eax, DEBLEVELMAX
                Debug_Printf    ":MemC:%08lX", ecx, DEBLEVELMAX
                Debug_Printf    ":I:%02lX", edx, DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        push    edx                     ;save registers that we use for test
        cmp     eax,WindowsVMHandle     ;is CRTC VM Windows?
        jne     MHNBBoardNotBusy        ;nope, skip this entire mess!
;For NVidia, the MemC state does not affect the accelerator, so we never have
;to wait!!
; MSK - TODO - Remove this whole routine!!!!??
;
public  MHNBBoardNotBusy
MHNBBoardNotBusy:
        pop     edx                     ;restore CRTC port number
;
MHNBExit:
        ret                             ;
EndProc MiniVDD_MakeHardwareNotBusy
;
;
subttl          Display Driver Is Being Disabled Notification
page +
public  MiniVDD_DisplayDriverDisabling
BeginProc       MiniVDD_DisplayDriverDisabling, RARE
;
;The display driver is in its Disable routine and is about to set the
;hardware back into VGA text mode.  Since this could either mean that
;the Windows session is ending or that some Windows application is switching
;to a VGA mode to display something full screen (such as MediaPlayer), we
;need to disable our MiniVDD_RestoreRegisters code because we're liable
;to restore a Windows HiRes state when we shouldn't!  Thus, clear the
;DisplayEnabledFlag to prevent this:
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_DisplayDriverDisabling", DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        mov     DisplayEnabledFlag,0    ;don't do a RestoreRegState
        push    ax
        push    dx
;
;   tell the BIOS to program the TV encoder
        call    TellBIOSProgramTV
        pop     ax
        pop     dx       
;
;       if we are about to exit Windows to restart in DOS mode, we need to stop
;       trapping real mode access registers so the BIOS can do a mode set.

MDDDExit:
        ret                             ;
EndProc MiniVDD_DisplayDriverDisabling
;
;
subttl          Virtualize Sequencer Register Extensions
page +
public  MiniVDD_VirtSeqOut
BeginProc MiniVDD_VirtSeqOut, DOSVM
;
;This routine is called when the Sequencer or data register (3C5H) is trapped
;when a VM is being virtualized.  It gives you the opportunity to special
;case virtualization of the Sequencer registers for your particular
;device's needs.
;
;Entry:
;       AL contains the byte to output to port.
;       EBX contains the VM Handle for this Sequencer output.
;       ECX contains the Sequencer index of the port to virtualize.
;       EDX contains the physical register to write or virtualize.
;Exit:
;       AL contains the byte to output to port.
;       Set CY to tell caller that WE handled this Sequencer output.
;       Set NC to tell caller (Main VDD) to handle this Sequencer output
;               in whatever way it normally does
;       EBX, ECX, and EDX should be preserved.
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_VirtSeqOut", DEBLEVELMAX
                Debug_Printf    ":VM:%08lX", ebx, DEBLEVELMAX
                ;
                push    esi
                push    edi
                VxDCall VDD_Get_VM_Info         ;get MemC owner VM handle in ESI for debugging!!!!
                Debug_Printf    ":CRTC:%08lX", edi, DEBLEVELMAX
                Debug_Printf    ":MemC:%08lX", esi, DEBLEVELMAX
                pop     edi
                pop     esi
                ;
                Debug_Printf    ":P:%04lX", edx, DEBLEVELMAX
                Debug_Printf    ":I:%02lX", ecx, DEBLEVELMAX
                pop     eax
                ;
                push    eax
                and     eax,0FFh
                Debug_Printf    ":D:%02lX", eax, DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        cmp     cl,006h                 ;is it Sequencer register 6?
        jne     VSOExit                 ;nope, let the main VDD handle it
        push    eax
        push    esi
        push    edi
;
; MSK - TODO - Which way???!!!!
IF 0
        ; Why did Cirrus do this?  Shouldn't we use the current VM?
        VxDCall VDD_Get_VM_Info         ;get MemC owner VM handle in ESI
ELSE ; 0
        mov     esi,ebx
ENDIF ; 0
;
;Save the new state of SR06 here.
;
        add     esi,OurCBDataPointer    ;
        .if (al != 057h)              ;is this the unlock value?
                xor     al,al           ;signal locked
        .endif
        mov     [esi].SeqReg06,al       ;save this state
        pop     edi
        pop     esi
        pop     eax
        
        ; CANOPUS Code
        test    nvCustomer, NVCUSTOMER_CANOPUS
        jz      @f
            cmp     InFullScreen, 0     ; Full screen mode ?
            jne     VSOExit                         ; yes, let VDD do I/O
@@:        
        
;JohnH
                cmp             DoNotSimulate,1                 ;if Windows exit, we should go to hardware
        jz              VSOExit                                 ;let VDD do I/O
; check VM; if we are in Windows, don't bother to do output
; else, we are in DOS, so let VDD update register

                VMMCall Test_Sys_VM_Handle              ;is it the system VM?
        jnz             VSOExit                                 ;no, let VDD do update
;JohnH
        stc                             ;we did the virtualization
        jmp     VSOExit2
;
VSOExit:
        clc                             ;tell Main VDD to handle these normally
VSOExit2:
        ret                             ;
EndProc MiniVDD_VirtSeqOut

page +
public  MiniVDD_VirtSeqIn
BeginProc MiniVDD_VirtSeqIn, DOSVM
;
;This routine is called when the Sequencer or data register (3C5H) is trapped
;when a VM is being virtualized.  It gives you the opportunity to special
;case virtualization of the Sequencer registers for your particular
;device's needs.
;
;Entry:
;       EBX contains the VM Handle for this Sequencer input.
;       ECX contains the Sequencer index of the port to virtualize.
;       EDX contains the physical register to write or virtualize.
;Exit:
;       Set CY to tell caller that we virtualized the port and AL has the value.
;       EBX, ECX, and EDX should be preserved.
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_VirtSeqIn", DEBLEVELMAX
                Debug_Printf    ":VM:%08lX", ebx, DEBLEVELMAX
                ;
                push    esi
                push    edi
                VxDCall VDD_Get_VM_Info         ;get MemC owner VM handle in ESI for debugging!!!!
                Debug_Printf    ":CRTC:%08lX", edi, DEBLEVELMAX
                Debug_Printf    ":MemC:%08lX", esi, DEBLEVELMAX
                pop     edi
                pop     esi
                ;
                Debug_Printf    ":P:%04lX", edx, DEBLEVELMAX
                Debug_Printf    ":I:%02lX", ecx, DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        cmp     cl,006h                 ;is it Sequencer register 6?
        jne     VSIExit2                ;nope, let the main VDD handle it
        push    esi
        push    edi
;
; MSK - TODO - Which way???!!!!
IF 0
        ; Why did Cirrus do this?  Shouldn't we use the current VM?
        VxDCall VDD_Get_VM_Info         ;get MemC owner VM handle in ESI
ELSE ; 0
        mov     esi,ebx
ENDIF ; 0
;
;Save the new state of SR06 here.
;
        add     esi,OurCBDataPointer    ;
        mov     al,[esi].SeqReg06       ;get this state
        .if (al != 057h)              ;is this the unlock value?
                mov     al,1            ;signal unlocked
        .else
                xor     al,al           ;signal locked
        .endif
        stc                             ;we did the virtualization        
        pop     edi
        pop     esi
        jmp     VSIExit
VSIExit2:
        clc                             ;we did not do virtualization
VSIExit:
        ret                             ;
EndProc MiniVDD_VirtSeqIn
;
;
subttl          Virtualize CRTC Register Extensions
page +
public  MiniVDD_VirtCRTCOut
BeginProc MiniVDD_VirtCRTCOut, DOSVM
;
;This routine is called when the CRTC or data register (3C5H) is trapped
;when a VM is being virtualized.  It gives you the opportunity to special
;case virtualization of the CRTC registers for your particular
;device's needs.
;
;Entry:
;       AL contains the byte to output to port.
;       EBX contains the VM Handle for this CRTC output.
;       ECX contains the CRTC index of the port to virtualize.
;       EDX contains the physical register to write or virtualize.
;Exit:
;       AL contains the byte to output to port.
;       Set CY to tell caller that WE handled this CRTC output.
;       Set NC to tell caller (Main VDD) to handle this CRTC output
;               in whatever way it normally does
;       EBX, ECX, and EDX should be preserved.
;
; MSK - TODO - We should perhaps perform the I/O instead if the current VM is
; the CRTC owner from some registers, or if the current VM is the MemC owner
; for other registers.
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_VirtCRTCOut", DEBLEVELMAX
                Debug_Printf    ":VM:%08lX", ebx, DEBLEVELMAX
                ;
                push    esi
                push    edi
                VxDCall VDD_Get_VM_Info         ;get MemC owner VM handle in ESI for debugging!!!!
                Debug_Printf    ":CRTC:%08lX", edi, DEBLEVELMAX
                Debug_Printf    ":MemC:%08lX", esi, DEBLEVELMAX
                pop     edi
                pop     esi
                ;
                Debug_Printf    ":P:%04lX", edx, DEBLEVELMAX
                Debug_Printf    ":I:%02lX", ecx, DEBLEVELMAX
                pop     eax
                ;
                push    eax
                and     eax,0FFh
                Debug_Printf    ":D:%02lX", eax, DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        push    ebx                     ; save EBX for later
        cmp     cl,19h                  ; CRTC extension register?
        jb      VCO_NotHandled          ; No, do normal processing

        add     ebx,OurCBDataPointer    ; EBX --> VM's CB data area

        cmp     cl,19h                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;save current value over save/restore
        mov     [ebx].PerVMData.EXT_Repaint0NV,al
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,1Ah                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;save current value over save/restore
        mov     [ebx].PerVMData.EXT_Repaint1NV,al
                                        ;signal that this register is valid
        mov     [ebx].PerVMData.EXT_Repaint1NVSet,0FFh
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,1Bh                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;save current value over save/restore
        mov     [ebx].PerVMData.EXT_FifoBurst,al
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,1Ch                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;save current value over save/restore
        mov     [ebx].PerVMData.EXT_Repaint3NV,al
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,1Dh                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;save current value over save/restore
        mov     [ebx].PerVMData.EXT_WriteBank,al
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,1Eh                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;save current value over save/restore
        mov     [ebx].PerVMData.EXT_ReadBank,al
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,20h                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;save current value over save/restore
        mov     [ebx].PerVMData.EXT_FifoLowWaterMark,al
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,25h                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;save current value over save/restore
        mov     [ebx].PerVMData.EXT_ExtraBits,al
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,28h                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;save current value over save/restore
        mov     [ebx].PerVMData.EXT_PixelFormat,al
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,29h                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;save current value over save/restore
        mov     [ebx].PerVMData.EXT_TVDecimation,al
        jmp     VCO_SpecialExit         ;signal we handled it
;

        ; CANOPUS TV Code
@@:
        test    nvCustomer, NVCUSTOMER_CANOPUS
        jz      skip_canopus_vco1
CANOPUS_VirtCRTCOut:
        cmp     cl, bCanopusTVReg       ; Shadow register?
        jnz     @F                      ; no, check next register
        and     al, NOT TVF_INACTIVE    ; we won't save/restore bit 7 (inactive bit)
                                        ;save current value over save/restore
        mov     [ebx].PerVMData.EXT_CanopusTVReg, al
        jmp     VCO_SpecialExit         ;signal we handled it
skip_canopus_vco1:    

@@:
        cmp     cl,2Ah                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;save current value over save/restore
        mov     [ebx].PerVMData.EXT_OverscanHigh,al
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,2Dh                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;save current value over save/restore
        mov     [ebx].PerVMData.EXT_HorizontalExtra,al
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,30h                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;save current value over save/restore
        mov     [ebx].PerVMData.EXT_HWCursorAddress0,al
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,31h                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;save current value over save/restore
        mov     [ebx].PerVMData.EXT_HWCursorAddress1,al
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,32h                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;save current value over save/restore
        mov     [ebx].PerVMData.EXT_VideoWindow0,al
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,33h                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;save current value over save/restore
        mov     [ebx].PerVMData.EXT_VideoWindow1,al
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,39h                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;save current value over save/restore
        mov     [ebx].PerVMData.EXT_Interlace,al
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,38h                  ; Is this the real mode control register?
        jnz     @F

        mov     [ebx].PerVMData.EXT_RealModeAccess,al
        jmp     VCO_SpecialExit         ;signal we handled it
@@:
;
; all other extended registers come here
;
        push    eax                     ; save original eax
        xchg    ah,al                   ; Save value to write in ah
        dec     edx                     ; EDX --> CRTC index register
        in      al,dx
        ror     eax,8                   ; save index, data to output moves to al

        mov     ah,al                   ; data to output to AH
        mov     al,cl                   ; index to AL for output
        out     dx,ax                   ; output the data

        rol     eax,8                   ; this puts the result in AH, AL=index
        out     dx,al                   ; restore index
        inc     edx                     ; EDX --> CRTC data register
        pop     eax                     ; restore original eax
VCO_SpecialExit:

; CANOPUS
    test nvCustomer, NVCUSTOMER_CANOPUS
    jz   VCO_Can01
;; When in full screen, always let the VDD output
        cmp     InFullScreen, 0
        jne     VCO_NotHandled

;; If Windows exit, we should go to hardware too...
        cmp     DoNotSimulate,1         
        je      VCO_NotHandled
    
; check VM; if we are in Windows, don't bother to do output
; else, let VDD update register
    VMMCall Test_Sys_VM_Handle              ;is it the system VM?
    jz             VCO_NotHandled           ;yes, let VDD do update (NOTE THIS IS OPPOSITE LOGIC FROM BELOW)
    jmp VCO_Can02    
VCO_Can01:

;JohnH
; check VM; if we are in Windows, don't bother to do output
; else, let VDD update register
                VMMCall Test_Sys_VM_Handle              ;is it the system VM?
        jnz             VCO_NotHandled                  ;no, let VDD do update
;JohnH
VCO_Can02:
        stc                             ; say we did it, so the output isn't done
        jmp     VCOExit

VCO_NotHandled:
        clc                             ;tell caller we didn't do output
VCOExit:
        pop     ebx
IFDEF DEBUG_LOG
        pushf
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "\n\r", DEBLEVELMAX
                pop     eax
        .endif
        popf
ENDIF ; DEBUG_LOG
        ret                             ;
EndProc MiniVDD_VirtCRTCOut
;
;
page +
public  MiniVDD_VirtCRTCIn
BeginProc MiniVDD_VirtCRTCIn, DOSVM
;
;This routine is called when the CRTC or data register (3C5H) is trapped
;when a VM is being virtualized.  It gives you the opportunity to special
;case virtualization of the CRTC registers for your particular
;device's needs.
;
;Entry:
;       EBX contains the VM Handle for this CRTC input.
;       ECX contains the CRTC index of the port to virtualize.
;       EDX contains the physical register to write or virtualize.
;Exit:
;       Set CY to tell caller that we virtualized the port and AL has the value.
;       EBX, ECX, and EDX should be preserved.
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_VirtCRTCIn", DEBLEVELMAX
                Debug_Printf    ":VM:%08lX", ebx, DEBLEVELMAX
                ;
                push    esi
                push    edi
                VxDCall VDD_Get_VM_Info         ;get MemC owner VM handle in ESI for debugging!!!!
                Debug_Printf    ":CRTC:%08lX", edi, DEBLEVELMAX
                Debug_Printf    ":MemC:%08lX", esi, DEBLEVELMAX
                pop     edi
                pop     esi
                ;
                Debug_Printf    ":P:%04lX", edx, DEBLEVELMAX
                Debug_Printf    ":I:%02lX", ecx, DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        push    ebx                     ; save EBX for later
        cmp     cl,19h                  ; CRTC extension register?
        jb      VCI_NotHandled          ; No, do normal processing

        add     ebx,OurCBDataPointer    ; EBX --> VM's CB data area

        cmp     cl,19h                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;read saved value
        mov     al,[ebx].PerVMData.EXT_Repaint0NV
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,1Ah                  ; Shadow register?
        jnz     @F                      ; no, check next register
;During a set mode, the NVidia BIOS first reads 01Ah, and then only changes
;some of the bits. If this is a new VM, then this saved value is 0, which
;will cause the compatible text mode bit to be cleared.  To tell if this
;is a non-initialized value, we have a flag that we set in MiniVDD_VirtCRTCOut
;and in MiniVDD_SaveRegisters.
                                        ; see if value was ever set or saved
        mov     al,[ebx].PerVMData.EXT_Repaint1NVSet
        .if (al == 0)
                mov     al,03Fh                 ; return power on value
        .else
                                                ;read saved value
                mov     al,[ebx].PerVMData.EXT_Repaint1NV
        .endif
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,1Bh                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;read saved value
        mov     al,[ebx].PerVMData.EXT_FifoBurst
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,1Ch                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;read saved value
        mov     al,[ebx].PerVMData.EXT_Repaint3NV
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,1Dh                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;read saved value
        mov     al,[ebx].PerVMData.EXT_WriteBank
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,1Eh                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;read saved value
        mov     al,[ebx].PerVMData.EXT_ReadBank
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,20h                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;read saved value
        mov     al,[ebx].PerVMData.EXT_FifoLowWaterMark
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,25h                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;read saved value
        mov     al,[ebx].PerVMData.EXT_ExtraBits
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,28h                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;read saved value
        mov     al,[ebx].PerVMData.EXT_PixelFormat
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,29h                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;read saved value
        mov     al,[ebx].PerVMData.EXT_TVDecimation
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:

;
; CANOPUS TV Code
    test    nvCustomer, NVCUSTOMER_CANOPUS
    jz      VCO_can50
CANOPUS_VirtCRTCIn:
        cmp     cl, bCanopusTVReg       ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;read saved value
;;   One big problem is, that the boot value initial value for a VM is always zero,
;;       and the bios only reads this register!!!
;;       So we use the bit 6 to mark if we have this bit already initialized 
;;       for the current VM or not...
        dec     dx                      ;-- first get bit 7  (inactive bit)
        mov     al, cl
        out     dx, al                  ; set index register (perhaps it's not done now)
        inc     dx                      ; restore dx
        in      al, dx                  ; 
        test    [ebx].PerVMData.EXT_CanopusTVReg, TVF_WINDOWS
        jz      VCI_TvReg               ; is an initial value, use current register state

        and     al, TVF_INACTIVE        ; because we won't save/restore it
                                        ;read saved value
        or      al, [ebx].PerVMData.EXT_CanopusTVReg
        jmp     VCI_SpecialExit         ;signal we handled it

VCI_TvReg:                              ; The VM is new, so we need to initialize the value...
        or      al, TVF_WINDOWS         ; mark value initialized
        push    ax
        and     al, NOT TVF_INACTIVE
        mov     [ebx].PerVMData.EXT_CanopusTVReg, al    ; save and return
        pop     ax
        jmp     VCI_SpecialExit         ;signal we handled it
VCO_can50:
@@:
        cmp     cl,2Ah                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;read saved value
        mov     al,[ebx].PerVMData.EXT_OverscanHigh
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,2Dh                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;read saved value
        mov     al,[ebx].PerVMData.EXT_HorizontalExtra
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,30h                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;read saved value
        mov     al,[ebx].PerVMData.EXT_HWCursorAddress0
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,31h                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;read saved value
        mov     al,[ebx].PerVMData.EXT_HWCursorAddress1
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,32h                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;read saved value
        mov     al,[ebx].PerVMData.EXT_VideoWindow0
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,33h                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;read saved value
        mov     al,[ebx].PerVMData.EXT_VideoWindow1
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,39h                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;read saved value
        mov     al,[ebx].PerVMData.EXT_Interlace
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,38h                  ; Is this the real mode control register?
        jnz     @F

        mov     al,[ebx].PerVMData.EXT_RealModeAccess
        jmp     VCO_SpecialExit         ;signal we handled it
@@:
;
; all other extended registers come here
;
VCI_Physical:
        push    ecx
        push    eax
        dec     edx                     ; EDX --> CRTC index register
        in      al,dx
        ror     eax,8                   ; save index

        mov     al,cl                   ; index to AL for output
        out     dx,al                   ; set the index
        inc     edx                     ; EDX --> CRTC data register
        in      al,dx                   ; get the data register
        mov     ch,al                   ; save value we read
        dec     edx                     ; EDX --> CRTC index register

        rol     eax,8                   ; this puts the result in AH, AL=index
        out     dx,al                   ; restore index
        inc     edx                     ; EDX --> CRTC data register
        pop     eax
        mov     al,ch                   ; restore value we read
        pop     ecx
VCI_SpecialExit:
;JohnH
;               VMMCall Test_Sys_VM_Handle              ;is it the system VM?
;        jnz            VCI_NotHandled                  ;no, let VDD update
;JohnH
        stc                             ; tell caller WE did the input
        jmp     VCOExit

VCI_NotHandled:
        clc                             ;tell caller we didn't do input
VCI_Exit:
        pop     ebx
IFDEF DEBUG_LOG
        pushf
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "\n\r", DEBLEVELMAX
                pop     eax
        .endif
        popf
ENDIF ; DEBUG_LOG
        ret                             ;
EndProc MiniVDD_VirtCRTCIn
;
;
IFDEF NVIDIA_COMMON
subttl          Virtualize I/O To Ports 003D0h-003D3h
page +
public  SimulateNVRead
BeginProc SimulateNVRead
; ebx = OurCBDataPointer
; eax = NV address
; returns
; eax = data
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "SimulateNVRead", DEBLEVELMAX
                pop     eax
                ;
                push    eax
                Debug_Printf    ":NV Address:%08lX", eax, DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        .if (eax == NV_PRAMDAC_PLL_COEFF_SELECT)
                mov     eax,[ebx].PerVMData.EXT_NV_PRAMDAC
        .elseif (eax == NV_PRAMDAC_VPLL_COEFF)
                mov     eax,[ebx].PerVMData.EXT_NV_VPLL_COEFF
        .elseif (eax == NV_PRAMDAC_GENERAL_CONTROL)
                mov     eax,[ebx].PerVMData.EXT_NV_PDAC_GEN_CTRL
        .elseif (eax == NV_PFB_CONFIG_0)
                mov     eax,[ebx].PerVMData.EXT_NV_PFB_CONFIG_0
        .else
                ; MSK - TODO - for debugging, we should record what
                ; the hell we were trying to read
                call    Beep
                push    esi
                                        ; if we don't know what it is
                REG_RD32(eax)           ; read the real thing
                pop     esi
        .endif
IFDEF DEBUG_LOG
        pushf
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "\n\r", DEBLEVELMAX
                pop     eax
        .endif
        popf
ENDIF ; DEBUG_LOG
        ret                             ;
EndProc SimulateNVRead
;
;
public  SimulateNVWrite
BeginProc SimulateNVWrite
; ebx = OurCBDataPointer
; eax = NV address
; ecx = data
        ; Write Data to NV register
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "SimulateNVRead", DEBLEVELMAX
                pop     eax
                ;
                push    eax
                Debug_Printf    ":NV Address:%08lX", eax, DEBLEVELMAX
                Debug_Printf    ":Data:%08lX", ecx, DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        .if (eax == NV_PRAMDAC_PLL_COEFF_SELECT)
                mov     [ebx].EXT_NV_PRAMDAC,ecx
        .elseif (eax == NV_PRAMDAC_VPLL_COEFF)
                mov     [ebx].PerVMData.EXT_NV_VPLL_COEFF,ecx
        .elseif (eax == NV_PRAMDAC_GENERAL_CONTROL)
                mov     [ebx].PerVMData.EXT_NV_PDAC_GEN_CTRL,ecx
        .elseif (eax == NV_PFB_CONFIG_0)
                mov     [ebx].PerVMData.EXT_NV_PFB_CONFIG_0,ecx
        .else
                ; MSK - TODO - for debugging, we should record what
                ; the hell we were trying to write
                call    Beep
                push    esi
                mov     esi,eax         ; put address to write in esi
                                        ; if we don't know what it is
                REG_WR32(esi,ecx)       ; write the real thing
                pop     esi
        .endif
IFDEF DEBUG_LOG
        pushf
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "\n\r", DEBLEVELMAX
                pop     eax
        .endif
        popf
ENDIF ; DEBUG_LOG
        ret                             ;
EndProc SimulateNVWrite
;
;
public  SimulateNVInByte
BeginProc SimulateNVInByte
; ebx = vm handle
; edx = port to read
; returns
; al = data
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "SimulateNVInByte", DEBLEVELMAX
                Debug_Printf    ":VM:%08lX", ebx, DEBLEVELMAX
                Debug_Printf    ":Port:%08lX", edx, DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        push    ebx
        push    ecx
        add     ebx,OurCBDataPointer    ; EBX --> VM's CB data area
        mov     cl,[ebx].PerVMData.EXT_RealModeAccess

        test    cl,NVRM_ACCESS_MASK     ; Test if windows are open
        .if (zero?)
;                xor     al,al
;                call    Beep
                        mov     al, 0ffh        ; Don't Beep!!  CANOPUS

        .else
                ;now read the proper register
                and     cl,NVRM_SELECT_MASK
                .if (cl == NVRM_ADDRESS)
                        mov     eax,[ebx].EXT_RealModeAddress
                .elseif (cl == NVRM_DATA)
                        mov     eax,[ebx].EXT_RealModeAddress
                        call    SimulateNVRead
                .elseif (cl == NVRM_DATA32)
                        .if (dx < 003D2h)
                                xor     eax,eax                 ;read 0
                                mov     ax,[ebx].EXT_RealModeData32     ; load latched LSW
                        .else
;                                xor     eax,eax                 ;read 0
;                                call    Beep                    ;only low word works
                                        mov     ax, 0ffh                    ; Don't Beep!!  CANOPUS
                        .endif
                .else
                        mov     eax,02B16D065h          ; return the identifier
                .endif
                mov     cl,dl
                and     cl,003h         ; Do decode of which byte
                shl     cl,3            ; * 8
                shr     eax,cl          ; Put into lower byte
                and     eax,0FFh        ; mask        
        .endif
        pop     ecx
        pop     ebx
IFDEF DEBUG_LOG
        pushf
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "\n\r", DEBLEVELMAX
                pop     eax
        .endif
        popf
ENDIF ; DEBUG_LOG
        ret                             ;
EndProc SimulateNVInByte
;
;
public  SimulateNVInWord
BeginProc SimulateNVInWord
; Seperate SimulateNVInWord exists to allow atomic word reads to occur
; note that atomic dword reads can not occur because Windows 95 splits up
; dword i/o into word accesses.
; ebx = vm handle
; edx = port to read
; returns
; al = data
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "SimulateNVInWord", DEBLEVELMAX
                Debug_Printf    ":VM:%08lX", ebx, DEBLEVELMAX
                Debug_Printf    ":Port:%08lX", edx, DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        push    ebx
        push    ecx
        add     ebx,OurCBDataPointer    ; EBX --> VM's CB data area
        mov     cl,[ebx].PerVMData.EXT_RealModeAccess

        test    cl,NVRM_ACCESS_MASK     ; Test if windows are open
        .if (zero?)
                xor     al,al
                call    Beep
        .else
                ;now read the proper register
                and     cl,NVRM_SELECT_MASK
                .if (cl == NVRM_ADDRESS)
                        mov     eax,[ebx].EXT_RealModeAddress
                .elseif (cl == NVRM_DATA)
                        mov     eax,[ebx].EXT_RealModeAddress
                        call    SimulateNVRead
                .elseif (cl == NVRM_DATA32)
                        .if (dx == 003D0h)
                                mov     ax,[ebx].EXT_RealModeData32     ; load latched LSW
                        .else
                                xor     eax,eax                 ;read 0
                                call    Beep                    ;only word reads from 3D0 work
                        .endif
                .else
                        mov     eax,02B16D065h          ; return the identifier
                .endif
                mov     cl,dl
                and     cl,003h         ; Do decode of which word
                shl     cl,3            ; * 8
                shr     eax,cl          ; Put into lower word
                and     eax,0FFFFh      ; mask out word
        .endif
        pop     ecx
        pop     ebx
IFDEF DEBUG_LOG
        pushf
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "\n\r", DEBLEVELMAX
                pop     eax
        .endif
        popf
ENDIF ; DEBUG_LOG
        ret                             ;
EndProc SimulateNVInWord
;
;
public  SimulateNVOutByte
BeginProc SimulateNVOutByte
; ebx = vm handle
; eax = value to be written
; edx = port to write
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "SimulateNVOutByte", DEBLEVELMAX
                Debug_Printf    ":VM:%08lX:Port:%08lX:Data:%08lX", ebx, DEBLEVELMAX
                Debug_Printf    ":Port:%08lX:Data:%08lX", edx, DEBLEVELMAX
                pop     eax
                ;
                push    eax
                Debug_Printf    ":Data:%08lX", eax, DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        pushad
        add     ebx,OurCBDataPointer    ; EBX --> VM's CB data area
        mov     cl,[ebx].PerVMData.EXT_RealModeAccess

        test    cl,NVRM_ACCESS_MASK     ; Test if windows are open
        .if (!zero?)
                ;now write the proper register
                and     cl,NVRM_SELECT_MASK
                .if (cl == NVRM_ADDRESS)
                                                ; Get the dword value into eax
                        mov     edi,[ebx].EXT_RealModeAddress
                        mov     cl, dl
                        and     cl, 003h        ; Do decode of which byte
                        shl     cl, 3           ; * 8
                        mov     esi, 0FFh       ; make mask
                        and     eax, esi        ; make sure we only have a byte
                        shl     esi, cl
                        not     esi
                        and     edi, esi        ; Mask out value
                        shl     eax, cl         ; Put byte into proper place
                        or      eax, edi        ; Insert new byte
                                                ; Store new dword value
                        mov     [ebx].EXT_RealModeAddress,eax
                .elseif (cl == NVRM_DATA)
                        call    Beep            ; BIOS should not be writing here
                        ; but it should still write the byte if it is done
                        ; in ax = byte to write
                        ; edx = port addresss
                        ; ebx = OurCBPointer
                        push    eax             ; save byte to write
                        mov     eax,[ebx].EXT_RealModeAddress
                        call    SimulateNVRead
                        mov     edi,eax         ; put original in edi
                        pop     eax             ; restore byte to write

                        mov     cl, dl
                        and     cl, 003h        ; Do decode of which byte
                        shl     cl, 3           ; * 8
                        mov     esi, 0FFh       ; make mask
                        and     eax, esi        ; make sure we only have a word
                        shl     esi, cl
                        not     esi
                        and     edi, esi        ; Mask out value
                        shl     eax, cl         ; Put byte into proper place
                        or      eax, edi        ; Insert new byte

                        ; Write Data to NV register
                        mov     ecx,eax
                        mov     eax,[ebx].EXT_RealModeAddress
                        call    SimulateNVWrite
                .elseif (cl == NVRM_DATA32)
                        ; in al = byte to write
                        ; edx = port addresss
                        ; ebx = OurCBPointer
                        push    eax             ; save byte to write
                        mov     eax,[ebx].EXT_RealModeAddress
                        call    SimulateNVRead
                        mov     edi,eax         ; put original in edi
                        pop     eax             ; restore byte to write

                        mov     di,[ebx].EXT_RealModeData32     ; load latched LSW

                        mov     cl, dl
                        and     cl, 003h        ; Do decode of which byte
                        shl     cl, 3           ; * 8
                        mov     esi, 0FFh       ; make mask
                        and     eax, esi        ; make sure we only have a word
                        shl     esi, cl
                        not     esi
                        and     edi, esi        ; Mask out value
                        shl     eax, cl         ; Put byte into proper place
                        or      eax, edi        ; Insert new byte

                        .if (dx < 003D2h)
                                mov     [ebx].EXT_RealModeData32,ax     ; save latched LSW
                        .else
                                ; Write Data to NV register
                                mov     ecx,eax
                                mov     eax,[ebx].EXT_RealModeAddress
                                call    SimulateNVWrite
                        .endif
                .else                   ; identifier register
                        call    Beep    ; Should not be writing here
                .endif
        .endif
        popad
IFDEF DEBUG_LOG
        pushf
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "\n\r", DEBLEVELMAX
                pop     eax
        .endif
        popf
ENDIF ; DEBUG_LOG
        ret                             ;
EndProc SimulateNVOutByte
;
;
public  SimulateNVOutWord
BeginProc SimulateNVOutWord
; ebx = vm handle
; eax = value to be written
; edx = port to write
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "SimulateNVOutWord", DEBLEVELMAX
                Debug_Printf    ":VM:%08lX:Port:%08lX:Data:%08lX", ebx, DEBLEVELMAX
                Debug_Printf    ":Port:%08lX:Data:%08lX", edx, DEBLEVELMAX
                pop     eax
                ;
                push    eax
                Debug_Printf    ":Data:%08lX", eax, DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        pushad
        add     ebx,OurCBDataPointer    ; EBX --> VM's CB data area
        mov     cl,[ebx].PerVMData.EXT_RealModeAccess

        test    cl,NVRM_ACCESS_MASK     ; Test if windows are open
        .if (!zero?)
                ;now write the proper register
                and     cl,NVRM_SELECT_MASK
                .if (cl == NVRM_ADDRESS)
                                                ; Get the dword value into eax
                        mov     edi,[ebx].EXT_RealModeAddress
                        mov     cl, dl
                        and     cl, 003h        ; Do decode of which word
                        shl     cl, 3           ; * 8
                        mov     esi, 0FFFFh     ; make mask
                        and     eax, esi        ; make sure we only have a word
                        shl     esi, cl
                        not     esi
                        and     edi, esi        ; Mask out value
                        shl     eax, cl         ; Put byte into proper place
                        or      eax, edi        ; Insert new word
                                                ; Store new dword value
                        mov     [ebx].EXT_RealModeAddress,eax

                .elseif (cl == NVRM_DATA)
                        call    Beep            ; BIOS should not be writing here
                        ; but it should still write the word if it is done
                        ; in ax = byte to write
                        ; edx = port addresss
                        ; ebx = OurCBPointer
                        push    eax             ; save word to write
                        mov     eax,[ebx].EXT_RealModeAddress
                        call    SimulateNVRead
                        mov     edi,eax         ; put original in edi
                        pop     eax             ; restore word to write

                        mov     cl, dl
                        and     cl, 003h        ; Do decode of which word
                        shl     cl, 3           ; * 8
                        mov     esi, 0FFFFh     ; make mask
                        and     eax, esi        ; make sure we only have a word
                        shl     esi, cl
                        not     esi
                        and     edi, esi        ; Mask out value
                        shl     eax, cl         ; Put byte into proper place
                        or      eax, edi        ; Insert new byte

                        ; Write Data to NV register
                        mov     ecx,eax
                        mov     eax,[ebx].EXT_RealModeAddress
                        call    SimulateNVWrite
                .elseif (cl == NVRM_DATA32)
                        ; in ax = word to write
                        ; edx = port addresss
                        ; ebx = OurCBPointer
                        .if ((dx == 003D1h) || (dx == 003D3h))
                                call    Beep            ; only aligned accesses do anything!
                        .elseif (dx == 003D0h)
                                mov     [ebx].EXT_RealModeData32,ax     ; save latched LSW
                        .else
                                mov     cx,ax
                                shl     ecx,16          ; put word into upper half
                                mov     cx,[ebx].EXT_RealModeData32     ; load latched LSW

                                ; Write Data to NV register
                                mov     eax,[ebx].EXT_RealModeAddress
                                call    SimulateNVWrite
                        .endif
                .else                   ; identifier register
                        call    Beep    ; Should not be writing here
                .endif
        .endif
        popad
IFDEF DEBUG_LOG
        pushf
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "\n\r", DEBLEVELMAX
                pop     eax
        .endif
        popf
ENDIF ; DEBUG_LOG
        ret                             ;
EndProc SimulateNVOutWord
;
;
public  MiniVDD_VirtualRealModeAccess
BeginProc MiniVDD_VirtualRealModeAccess
;
;NVidia has a 32-bit wide port at 003D0h that allows access to the NV register
;space.  This routine virtualizes access to that port.
;NOTE:  The VDD chops up all accesses into bytes. Since our ports support word access,
;               we must remember the first byte until we get the second byte, and put them
;               together to do the actual I/O.
;
;Entry:
;       EAX contains value to be written to port.
;       EBX contains the VM Handle for which this I/O is being done.
;       ECX contains the I/O type flags (see VMM.INC for details).
;       EDX contains the port number.
;Exit:
;       CY clear means that we didn't handle the I/O (let caller do it).
;               -- All registers MUST be preserved in this case.
;       CY set means that we handled the I/O completely.
;               -- Preserve EBX only in this case.
;       EAX contains result of an IN operation.
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "SimulateNVOutByte", DEBLEVELMAX
                Debug_Printf    ":VM:%08lX", ebx, DEBLEVELMAX
                Debug_Printf    ":Port:%08lX", edx, DEBLEVELMAX
                pop     eax
                ;
                push    eax
                Debug_Printf    ":Data:%08lX", eax, DEBLEVELMAX
                Debug_Printf    ":Type:%08lX", ecx, DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        cmp     edx,03D0h               ;are we interested?
        jb      MVBINotInterested       ;below 03D0h, so no
        cmp     edx,03D3h               ;are we interested?
        ja      MVBINotInterested       ;above 03D3h, so no
        cmp     ecx,BYTE_OUTPUT         ;doing an OUT from a byte?
        je      MVBIByteOutput          ;yes! go handle it!
        cmp     ecx,WORD_OUTPUT         ;doing an OUT from a word?
        je      MVBIWordOutput          ;yes! go handle it!
        cmp     ecx,BYTE_INPUT          ;doing an IN from a byte?
        je      MVBIByteInput           ;yes! go handle it!
        cmp     ecx,WORD_INPUT          ;doing an IN from a word?
        jne     MVBINotInterested       ;nope, we're not interested!
;
public  MVBIWordInput
MVBIWordInput:
        cmp     edx,003D2h              ;do we do the full word
        jle     MVBIWordInputTotal
        call    SimulateNVInByte        ;simulate in byte
        jmp     MVBIWeHandledIt         ;done, (003D4h gets ignored)
public  MVBIWordInputTotal                
MVBIWordInputTotal:
        call    SimulateNVInWord        ;simulate in word
        jmp     MVBIWeHandledIt         ;and pretend that we handled it
;
public  MVBIWordOutput
MVBIWordOutput:
        cmp     edx,003D2h
        jle     MVBIInRange
        call    SimulateNVOutByte       ;only do the byte at 003D3h
        jmp     MVBIWeHandledIt         ;done, (003D4h gets ignored)
MVBIInRange:
        call    SimulateNVOutWord       ;simulate out word
        jmp     MVBIWeHandledIt         ;and pretend that we handled it

;--------------------------------------------------------------------------------------------
;BYTE INPUT of real mode access register (3d0-3d3)
;the VDD splits up our word accesses into bytes.
;input word and return the appropriate byte.
;JohnH
public  MVBIByteInput
MVBIByteInput:

; CANOPUS Check for TV fullscreen
        test    nvCustomer, NVCUSTOMER_CANOPUS
        jz      MVBIBI_can01
        
            cmp InFullScreen, 0         ; Full screen mode ?
            jne @f

        ;If we are not windowed, we may need to do actual I/O
        VMMCall Test_Sys_VM_Handle              ;is it the system VM?
        jnz     SimNvInByte             ;No, simulate (we are windowed)
        jmp @f
MVBIBI_can01:        

        cmp             DoNotSimulate,1                 ;if Windows exit, we should go to hardware
        je              @f              
;If we are not windowed, we may need to do actual I/O
        VMMCall Test_Sys_VM_Handle              ;is it the system VM?
        jz              SimNvInByte                             ;yes, simulate (we are windowed)
@@:     push    dx
;do the input and return the byte referenced
                push    dx
        and             dl,0feh                                 ;input word (from even port)
        in              ax,dx
        pop             dx
        bt              dx,0                                    ;high or low byte?
        jnc             ByteInDone
        shr             ax,8
ByteInDone:
                pop             dx
        jmp             MVBIWeHandledIt                 ;return with word in ax if second byte
SimNvInByte:
        call    SimulateNVInByte        ;simulate in byte
        jmp             MVBIWeHandledIt
        
;--------------------------------------------------------------------------------------------
;BYTE OUTPUT of real mode access register (3d0-3d3)
;the VDD splits up our word accesses into bytes.
;We need to check for consecutive accesses to a word register and put the bytes back together.
;We also need to save valid real-mode access sequences to the per-VM data area.
;The sequence is: 
;       write access mode (address) at CRTC 38.
;       write NV ptr at 3d2, 3d0. 
;       write access mode (data) at CRTC 38
;       write NV data at 3d2, 3d0. 
;We must save the address and data so we can check for interesting addresses
;and write the data to the per-VM data area.
public  MVBIByteOutput
MVBIByteOutput:

        ; CANOPUS TV Check
        test    nvCustomer, NVCUSTOMER_CANOPUS
        jz      MVBIBO_can01

            cmp     InFullScreen, 0             ; Full screen mode ?
            jne     @f
        cmp     DoNotSimulate,1     ;if Windows exit, we should go to hardware
        je      @f              
        VMMCall Test_Sys_VM_Handle  ;is it the system VM?
            jnz     SimNvOutByte                ;No, simulate (we are windowed)
        jmp     @f

MVBIBO_can01:
        cmp             DoNotSimulate,1                 ;if Windows exit, we should go to hardware
        je              @f              
        VMMCall         Test_Sys_VM_Handle              ;is it the system VM?
        jz              SimNvOutByte                    ;yes, simulate (we are windowed)
;If we are not windowed, we may need to do actual I/O
@@:     push    ax
        push    cx
        push    dx
        bt              dx,0                                    ;second byte (possibly)
        jnc             FirstByteOut                    ;jmp if even
        cmp             dx,LastByteOutAddr              ;second byte of same register?
        jnz             ByteOutDone                             ;no, operation is useless                

;ODD address. second byte of the word
                shl             ax,8
        mov             al,LastByteOut
                dec             dx                                              ;back to even addr
        out             dx,ax                                   ;do I/O
;save data in temp array until we have address and data
                push    ebx
                xor             ebx,ebx
                mov             bl,rmState
                cmp             bl,3
        ja              @f                                              ;something is wrong
                shl             bx,1                                    ;word index
                mov             word ptr rmArray[ebx],ax        ;save it, address in low dword, data in high dword
                shr             bx,1
@@:             pop             ebx
        cmp             rmState,3                               ;all 4 words done? (data must be after address)
        jne             ByteOutDone                             ;no, wait for more

;we have all 8 bytes of address/data. save data in register data area
        mov             rmState,0                               ;start over
                ; bx = vm handle
                call    SaveNVPrivReg                   ;sort it out and write it to per VM data area
                xor             ax,ax
        mov             LastByteOutAddr,ax              ;clear out address to end cycle
        mov             LastByteOut,al
                jmp             ByteOutDone        

FirstByteOut:
;EVEN address. check for address/data sequence
;set state: 0=lsw of address, 1=msw of address, 2=lsw of data, 3=msw of data
        call    getAccessState
                cmp             cl,3                                    ;NV ptr?
                jne             @f
        mov             rmState,0                               ;flag address sequence
                jmp             mswlsw                                  ;first or second word?
@@:             cmp             cl,7
                je              @f
                cmp             cl,5
                jne     ignore
@@:             mov             rmState,2                               ;flag data sequence
                jmp             mswlsw
ignore:
                mov             rmState,4                               ;ignore
                jmp             SaveEven

;check MSW or LSW                        
;we're assuming LSW comes first. Can this get us in trouble? rmState is used to index into the array where we save it.
mswlsw: cmp             dx,3d0h                                 ;lsw?
        jz              SaveEven
                inc             rmState                                 ;msw, bump state

;save data and port until next byte comes thru
SaveEven:
                inc     dx
                mov             LastByteOutAddr,dx
        mov             LastByteOut,al
ByteOutDone:
                pop             dx
                pop             cx
        pop             ax
        jmp             MVBIWeHandledIt
        
SimNvOutByte:
        call    SimulateNVOutByte       ;simulate out byte
;
public  MVBIWeHandledIt
MVBIWeHandledIt:
        stc                             ;return that we handled it
        jmp     MVBIExit                ;and return IN data in AL/AX to caller
;
public  MVBINotInterested
MVBINotInterested:
        clc                             ;return to let caller handle it!
;
MVBIExit:
IFDEF DEBUG_LOG
        pushf
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "\n\r", DEBLEVELMAX
                pop     eax
        .endif
        popf
ENDIF ; DEBUG_LOG
        ret                             ;
EndProc MiniVDD_VirtualRealModeAccess
;--------------------------------------------------------------------------------------------
;
;               get the access state bits for realmode access registers
;EXIT:  cl = access state
BeginProc               GetAccessState
                push    dx
                push    ax
        ;
        ; CANOPUS TV Check
        test    nvCustomer, NVCUSTOMER_CANOPUS
        jz      GAS_direct                
         
        VMMCall Test_Sys_VM_Handle      ;is it the system VM?
        jz      GAS_direct              ;yes, get the current state

;// We also need to virtualize this register... ;)
GAS_virtual:
        push    ebx
        add     ebx,OurCBDataPointer    ; EBX --> VM's CB data area
        mov     cl, [ebx].PerVMData.EXT_RealModeAccess
        pop     ebx
        and     cl, 07h
        jmp     GAS_end

GAS_direct:
                
        call    GetCRTCPort
        in              al,dx           ;read crtc index
        mov             ch,al
        mov             al,38h          ;access bits in reg 38h
        out             dx,al
        inc             dx
        in              al,dx           ;read access state
                and             al,7
                mov             cl,al           ;save access state for return
        mov             al,ch           ;restore crtc index
        dec             dx
        out             dx,al           ;restore crtc index
        
GAS_end:        
        pop             ax
        pop             dx
        ret        
EndProc                 GetAccessState

;--------------------------------------------------------------------------------------------
;               save data written to critical NV register in the per-VM CB
;Entry: EBX = VM handle
BeginProc               SaveNVPrivReg
                push    ebx
        add     ebx,OurCBDataPointer            ;EBX --> CRTC's CB data
;if the address is one of our 4 interesting registers, save the data
                mov             eax, dword ptr NvData
                cmp             dword ptr NvPtr,NV_PRAMDAC_VPLL_COEFF
        jne             @f
        mov     [ebx].PerVMData.EXT_NV_VPLL_COEFF,eax
                jmp             nv_save_done
@@:             cmp             dword ptr NvPtr,NV_PRAMDAC_PLL_COEFF_SELECT
                jne             @f
        mov     [ebx].PerVMData.EXT_NV_PRAMDAC,eax
                jmp             nv_save_done
@@:             cmp             dword ptr NvPtr,NV_PRAMDAC_GENERAL_CONTROL
                jne             @f
        mov     [ebx].PerVMData.EXT_NV_PDAC_GEN_CTRL,eax
                jmp             nv_save_done
@@:             cmp             dword ptr NvPtr,NV_PFB_CONFIG_0
                jne             nv_save_done
        mov     [ebx].PerVMData.EXT_NV_PFB_CONFIG_0,eax
      
nv_save_done:
                pop             ebx
                ret
EndProc                 SaveNVPrivReg

;
ENDIF ; NVIDIA_COMMON
subttl          Save Message Mode State For NVidia Extended Registers
page +
public  MiniVDD_SaveMessageModeState
BeginProc MiniVDD_SaveMessageModeState, RARE
;
;This routine allows the MiniVDD to copy virtualized states and save them in
;a special Message Mode state structure.  When this routine is called, the
;Main VDD has executed a totally virtualized mode change to the blue-screen
;Message Mode state (ie: Mode 3 in SBCS Windows and Mode 12H in Far East
;Windows).  Therefore, no screen changes are evident but the states have
;been saved in the CB data structure for the Windows VM (since the virtualized
;mode change was done when the Windows VM was the "Currently executing VM".
;Thus, when this routine is called, we have the Message Mode state for all
;of the NVidia Extension Registers saved in the CB data structure for the
;Windows VM.  We simply copy this state into the special Message Mode state
;data structure.
;
;Entry:
;       EBX --> Windows VM.
;       DS --> Windows VM's BIOS data area.
;Exit:
;       Save everything that you use!
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_SaveMessageModeState", DEBLEVELMAX
                Debug_Printf    ":VM:%08lX", ebx, DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        push    eax                     ;
        push    ebx                     ;
        push    ecx                     ;
        push    edx                     ;
;       push    edi                     ;

        cld                             ;make sure direction is set forward
        add     ebx,OurCBDataPointer    ; EBX --> VM's CB data area
        VMMCall _lmemcpy, <OFFSET32 MessageModeCBData, ebx, size PerVMData>

        mov     MsgModeInitDone,0ffh    ;flag that we're done collecting states
;
SMMSExit:
;       pop     edi                     ;restore saved registers
        pop     edx                     ;
        pop     ecx                     ;
        pop     ebx                     ;
        pop     eax                     ;
IFDEF DEBUG_LOG
        pushf
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "\n\r", DEBLEVELMAX
                pop     eax
        .endif
        popf
ENDIF ; DEBUG_LOG
        ret                             ;we're done
EndProc MiniVDD_SaveMessageModeState
;
;
subttl          Save Forced Planar State For NVidia Extended Registers
page +
public  MiniVDD_SaveForcedPlanarState
BeginProc MiniVDD_SaveForcedPlanarState, RARE
;
;This routine allows the MiniVDD to copy virtualized states and save them in
;a special Forced Planar state structure.  When this routine is called, the
;Main VDD has executed a totally virtualized mode change to the planar state
;(ie: Mode 12H).  Therefore, no screen changes are evident but the states have
;been saved in the CB data structure for the Windows VM (since the virtualized
;mode change was done when the Windows VM was the "Currently executing VM".
;Thus, when this routine is called, we have the planar state for all
;of the NVidia Extension Registers saved in the CB data structure for the
;Windows VM.  We simply copy this state into the special Planar State
;data structure.
;
;Entry:
;       Nothing assumed.
;Exit:
;       Save everything that you use!
;
;The source of our state save copy is the Windows VM's CB data structure:
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_SaveForcedPlanarState", DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        push    eax                     ;
        push    ebx                     ;
        push    ecx                     ;
        push    edx                     ;
;       push    edi                     ;

        cld                             ;make sure direction is set forward
        add     ebx,OurCBDataPointer    ; EBX --> VM's CB data area
        VMMCall _lmemcpy, <OFFSET32 ForcedPlanarCBData, ebx, size PerVMData>

;       pop     edi                     ;restore saved registers
        pop     edx                     ;
        pop     ecx                     ;
        pop     ebx                     ;
        pop     eax                     ;
IFDEF DEBUG_LOG
        pushf
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "\n\r", DEBLEVELMAX
                pop     eax
        .endif
        popf
ENDIF ; DEBUG_LOG
        ret                             ;we're done
EndProc MiniVDD_SaveForcedPlanarState
;
;
subttl          Return Total Memory Size on Card
page +
public  MiniVDD_GetTotalVRAMSize
BeginProc MiniVDD_GetTotalVRAMSize, DOSVM
;
;Entry:
;       EBX contains the Current VM Handle (which is also the CRTC owner's
;       VM Handle).
;       EBP --> VM's Client Registers.
;Exit:
;       CY is returned upon success.
;       All registers (except ECX) must be preserved over the call.
;       ECX will contain the total VRAM size in bytes.
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_GetTotalVRAMSize", DEBLEVELMAX
                Debug_Printf    ":VM:%08lX", ebx, DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        push    eax
        push    esi                     ; Uses REG_RD32 macros

        mov     ecx,800000h             ; default = 8M

        REG_RD32(NV_PFB_BOOT_0)  
        test    ax,40h
        jnz     @f        
        shr     ecx,1                   ; 4M?
        test    ax,4
        jnz     @f
        shr     ecx,1                   ; must be 2M
@@:     mov     TotalMemorySize,ecx     ; probably won't use this
        stc                             ;
        pop     esi
        pop     eax
        ret                             ;return to caller
EndProc MiniVDD_GetTotalVRAMSize
;
;
subttl          Return The Current Write Bank
page +
public  MiniVDD_GetCurrentBankWrite
BeginProc MiniVDD_GetCurrentBankWrite, DOSVM
;
;Entry:
;       EBX contains the VM Handle (Always the "CurrentVM").
;       EBP --> Client Register structure for VM
;Exit:
;       CY is returned upon success.
;       All registers (except EDX & EAX) must be preserved over the call.
;       EDX will contain the current write bank (bank A) set in hardware.
;
;NOTE: We really don't care whether these banks are configured as write or
;      read banks.  The reason that we use this terminology is because the
;      VESA standard defines two "windows" that can be set separately.
;      This routine gives back the first window.
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_GetCurrentBankWrite", DEBLEVELMAX
                Debug_Printf    ":VM:%08lX", ebx, DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
IFDEF FAST_HIRES_SAVE_RESTORE
        xor     edx,edx
ELSE ; FAST_HIRES_SAVE_RESTORE
        call    GetCRTCPort             ;EDX --> CRTC index register
        in      al,dx                   ;get current index register value
        ror     eax,8                   ;save it in top byte of EAX
        mov     al,01Dh                 ;this is index for bank register A
        out     dx,al                   ;
        inc     dl                      ;EDX --> CRTC data register
        in      al,dx                   ;
        dec     dl                      ;EDX --> CRTC index register
        shr     al,1                    ;convert from 32KB banks to 64KB banks
        rol     eax,8                   ;restore previous contents of CRTC index
        out     dx,al                   ;
        movzx   edx,ah                  ;return bank in EDX register
ENDIF ; FAST_HIRES_SAVE_RESTORE
;
MGBWExit:
        stc                             ;return success to caller
IFDEF DEBUG_LOG
        pushf
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "\n\r", DEBLEVELMAX
                pop     eax
        .endif
        popf
ENDIF ; DEBUG_LOG
        ret                             ;
EndProc MiniVDD_GetCurrentBankWrite
;
;
subttl          Return The Current Read Bank
page +
public  MiniVDD_GetCurrentBankRead
BeginProc MiniVDD_GetCurrentBankRead, DOSVM
;
;Entry:
;       EBX contains the VM Handle (Always the "CurrentVM").
;       EBP --> Client Register structure for VM
;Exit:
;       CY is returned upon success.
;       All registers (except EDX & EAX) must be preserved over the call.
;       EDX will contain the current read bank (bank A) set in hardware.
;
;NOTE: We really don't care whether these banks are configured as write or
;      read banks.  The reason that we use this terminology is because the
;      VESA standard defines two "windows" that can be set separately.
;      This routine gives back the second window.
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_GetCurrentBankRead", DEBLEVELMAX
                Debug_Printf    ":VM:%08lX", ebx, DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
IFDEF FAST_HIRES_SAVE_RESTORE
        xor     edx,edx
ELSE ; FAST_HIRES_SAVE_RESTORE
        call    GetCRTCPort             ;EDX --> CRTC index register
        in      al,dx                   ;get current index register value
        ror     eax,8                   ;save it in top byte of EAX
        mov     al,01Eh                 ;set to extensions register index
        out     dx,al                   ;
        inc     dl                      ;EDX --> CRTC data register
        in      al,dx                   ;get banking register
        dec     dl                      ;EDX --> CRTC index register
        shr     al,1                    ;convert from 32KB banks to 64KB banks
        rol     eax,8                   ;restore previous contents of CRTC index
        out     dx,al                   ;
        movzx   edx,ah                  ;return bank value in EDX
ENDIF ; FAST_HIRES_SAVE_RESTORE
;
MGBRExit:
        stc                             ;return success to caller
IFDEF DEBUG_LOG
        pushf
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "\n\r", DEBLEVELMAX
                pop     eax
        .endif
        popf
ENDIF ; DEBUG_LOG
        ret                             ;
EndProc MiniVDD_GetCurrentBankRead
;
;
subttl          Return the Bank Size
page +
public  MiniVDD_GetBankSize
BeginProc MiniVDD_GetBankSize, DOSVM
;
;Entry:
;       EBX contains the VM Handle (Always the "CurrentVM").
;       ECX contains the BIOS mode number that we're currently in.
;       EBP --> Client Register structure for VM
;Exit:
;       CY is returned upon success.
;       All registers (except EDX & EAX) must be preserved over the call.
;       EDX will contain the current bank size.
;       EAX will contain the physical address of the memory aperture or
;               zero to indicate VRAM at A000H.
;
;Our bank size (for HiRes save/restore purposes) is 64K.
;
; MSK - TODO - should we instead return the linear address with a size that is huge?!!!
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_GetBankSize", DEBLEVELMAX
                Debug_Printf    ":VM:%08lX", ebx, DEBLEVELMAX
                Debug_Printf    ":Mode:%08lX", ecx, DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
IFDEF FAST_HIRES_SAVE_RESTORE
        mov     edx,TotalMemorySize
;        call    GetLinearAddress        ;indicate where linear frame buffer is
        mov     eax,_fbAddr
ELSE ; FAST_HIRES_SAVE_RESTORE
        mov     edx,64*1024             ;assume 4K banks
        xor     eax,eax                 ;indicate VRAM is at A000H
ENDIF ; FAST_HIRES_SAVE_RESTORE
;
MGBSExit:
        stc                             ;return success to caller
IFDEF DEBUG_LOG
        pushf
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "\n\r", DEBLEVELMAX
                pop     eax
        .endif
        popf
ENDIF ; DEBUG_LOG
        ret                             ;
EndProc MiniVDD_GetBankSize
;
;
subttl          Prepare For a HiRes Screen Save/Restore
page +
public  MiniVDD_CheckScreenSwitchOK
BeginProc MiniVDD_CheckScreenSwitchOK, DOSVM
;
;Entry:
;       EBX contains the VM Handle (Always the "CurrentVM").
;       ECX contains the BIOS mode number that we're currently in.
;       EBP --> Client Register structure for VM
;Exit:
;       CY is returned if mode can not be switched.
;       All registers must be preserved over the call.
;
;Our bank size (for HiRes save/restore purposes) is 64K.
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_CheckScreenSwitchOK", DEBLEVELMAX
                pop     eax
                push    eax
                Debug_Printf    ":VESA:%08lX", eax, DEBLEVELMAX
                Debug_Printf    ":VM:%08lX", ebx, DEBLEVELMAX
                Debug_Printf    ":Mode:%08lX", ecx, DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
                clc                     ; return OK

        ret                            
EndProc MiniVDD_CheckScreenSwitchOK
;
;
public  MiniVDD_PreHiResSaveRestore
BeginProc MiniVDD_PreHiResSaveRestore, DOSVM
;
;Entry:
;       EBX contains the VM Handle (Always the "CurrentVM").
;       ECX contains the BIOS mode number that we're currently in.
;       EBP --> Client Register structure for VM
;Exit:
;       CY is returned upon success.
;       All registers must be preserved over the call.
;
;Our bank size (for HiRes save/restore purposes) is 64K.
;
; MSK - TODO - eliminate?
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_PreHiResSaveRestore", DEBLEVELMAX
                Debug_Printf    ":VM:%08lX", ebx, DEBLEVELMAX
                Debug_Printf    ":Mode:%08lX", ecx, DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
; MSK - TODO - we probably need to call save registers here and restore registers in PostHiResSaveRestore if
; they aren't called automatically.  Even if the VDD sets the VBE mode again for the DOS box, it will not
; be able to do the refresh rate.  This only maters if the app forced its own refresh rate!
        stc                             ;return success to caller
IFDEF DEBUG_LOG
        pushf
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "\n\r", DEBLEVELMAX
                pop     eax
        .endif
        popf
ENDIF ; DEBUG_LOG
        ret                             ;
EndProc MiniVDD_PreHiResSaveRestore
;
;
subttl          Clean Up After a HiRes Screen Save/Restore
page +
public  MiniVDD_PostHiResSaveRestore
BeginProc MiniVDD_PostHiResSaveRestore, DOSVM
;
;Entry:
;       EBX contains the VM Handle (Always the "CurrentVM").
;       ECX contains the BIOS mode number that we're currently in.
;       EBP --> Client Register structure for VM
;Exit:
;       CY is returned upon success.
;       All registers must be preserved over the call.
;
;Our bank size (for HiRes save/restore purposes) is 64K.
;
; MSK - TODO - eliminate?
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_PostHiResSaveRestore", DEBLEVELMAX
                Debug_Printf    ":VM:%08lX", ebx, DEBLEVELMAX
                Debug_Printf    ":Mode:%08lX", ecx, DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        stc                             ;return success to caller
IFDEF DEBUG_LOG
        pushf
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "\n\r", DEBLEVELMAX
                pop     eax
        .endif
        popf
ENDIF ; DEBUG_LOG
        ret                             ;
EndProc MiniVDD_PostHiResSaveRestore
;
;
subttl          Set the Bank During a HiRes Save/Restore
page +
public  MiniVDD_SetBank
BeginProc MiniVDD_SetBank, DOSVM
;
;Entry:
;       EAX contains the read bank to set.
;       EDX contains the write bank to set.
;       EBX contains the VM Handle (Always the "CurrentVM").
;       EBP --> Client Register structure for VM
;Exit:
;       CY is returned upon success.
;       All registers must be preserved over the call.
;       EDX will contain the current write bank (bank A) set in hardware.
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_SetBank", DEBLEVELMAX
                Debug_Printf    ":VM:%08lX", ebx, DEBLEVELMAX
                Debug_Printf    ":RBank:%08lX", eax, DEBLEVELMAX
                Debug_Printf    ":WBank:%08lX", edx, DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
IFNDEF FAST_HIRES_SAVE_RESTORE
        push    ecx                     ;save this over call
        push    edx                     ;
        push    eax                     ;
;JohnH - need to unlock or we can't change banks!
        mov     cl,al                   ;get read bank to set into CL
        mov     ch,dl                   ;get write bank value in CH
        call    GetCRTCPort             ;EDX --> CRTC index register
        in      al,dx                   ;get current index register value
        ror     eax,8                   ;save it in top byte of EAX

;               unlock_extension_regs
                call    unlock_ext
                
;
        mov     ah,ch                   ;get write bank value into AH
        shl     ah,1                    ;convert from 64KB banks to 32KB banks
        mov     al,01Dh                 ;set CRTC index to register 01Dh
        out     dx,ax                   ;set the write bank

        mov     ah,cl                   ;get read bank value into AH
        shl     ah,1                    ;convert from 64KB banks to 32KB banks
        mov     al,01Eh                 ;set CRTC index to register 01Eh
        out     dx,ax                   ;set the read bank
;
                call    restore_lock

        rol     eax,8                   ;restore GCR index register
        out     dx,al                   ;
        pop     eax                     ;
        pop     edx                     ;
        pop     ecx                     ;restore saved ECX
ENDIF ; FAST_HIRES_SAVE_RESTORE
        stc                             ;return success to caller
        ret                             ;
EndProc MiniVDD_SetBank
;
;
subttl          Temperary debug routines
page +
public  MiniVDD_PreCRTCModeChange
BeginProc MiniVDD_PreCRTCModeChange, DOSVM
;
;Entry:
;Exit:
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_PreCRTCModeChange", DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG

IFDEF DEBUG_LOG
        pushf
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "\n\r", DEBLEVELMAX
                pop     eax
        .endif
        popf
ENDIF ; DEBUG_LOG
        ret
EndProc MiniVDD_PreCRTCModeChange
;
;
;       RM callback after a mode switch
;Entry: parameter on stack. If non-zero, the display has changed (e.g. from CRT to TV)
public  MiniVDD_PostCRTCModeChange
BeginProc MiniVDD_PostCRTCModeChange, DOSVM
;
;Entry:
;Exit:
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_PostCRTCModeChange", DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG

;       We need to indicate the NVIDIA drivers are running, not VGA.DRV.
        mov     DisplayEnabledFlag,0ffh

        mov     eax,[esp+4]
        cmp     eax,1                   ; check parameter for display change
        jne     @f
        mov     DisplayChanged,1 ; flag it for PostHiresToVga
@@:
        ; signal BIOS not to change encoder while in hires
        call    TellBIOSNotProgramTV

;       We need to save registers after the resource manager does a mode change.
;       or else the VDD will restore the wrong registers (i.e., our extended registers). This can happen when closing
;       a windowed DOS box, or ending a full-srcreen app such as an AVI player.
;       This wasn't a problem when we used the BIOS for mode sets, because the I/O got trapped and the VDD called SaveRegisters.
        push    ebx
        mov     ebx,WindowsVMHandle
        call    MiniVDD_SaveRegisters
        pop     ebx
        
        ret
EndProc MiniVDD_PostCRTCModeChange
;
;
subttl          Handle refresh rate support for VESA setmode calls
page +
public MiniVDD_VESASupport
BeginProc MiniVDD_VESASupport
;
;
; MiniVDD_VESASupport
;       Our VBE handler. It processes non-refresh set mode calls and turns them
;       into refresh rate calls.
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_VESASupport", DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        pushad
IFDEF INCLUDE_REFRESH

; MSK - TODO - Add support for doing VESA calls in protected mode using VBE 3.0!!!
        mov     ax,[ebp].Client_Word_Reg_Struc.Client_AX
        cmp     ax,VESA_SET_MODE        ; Is this a Set Mode call?
        je      VESASupportSetMode
ifdef VESA_DDC
        cmp     ax,4F15h                ; Is this a VBE/DDC call?
        je      VESADDC
endif ; VESA_DDC
        jmp     VESASupportPassDown    ; Pass call on down

VESASupportSetMode:
        mov     al,InRefreshSetMode     ; check if we are already doing this
        or      al,al
        jnz     VESASupportPassDown     ; just pass it down if we are

;NVidia uses VBE 3.0 to set the refresh rate.
;First see if this is a refresh rate aware set mode and just pass it on if it is.
        mov     ax,[ebp].Client_Word_Reg_Struc.Client_BX
        test    ax,00800h
        jnz     VESASupportPassDown

;Is this the Windows VM or a DOS VM?
        cmp     ebx,WindowsVMHandle
        jne     VESASupportVM

        ;Determine current windows refresh rate setting
;The Main VDD has already retrieved the Refresh_Rate= and X_Resolution entries
;from SYSTEM.INI and will return those values if the registry has nothing
;better to offer.
;
; MSK - TODO - Add DDC/EDID refresh rate support!!!
; MSK - TODO - Add GTF refresh rate support!!!!
        mov     eax,OFFSET32 DisplayInfoStructure
        mov     ecx,SIZE DISPLAYINFO    ;pass size in ECX, address in EAX
        mov     [eax].diHdrSize,cx      ;fill in this entry
        push    eax                     ;save EAX --> DisplayInfoStructure
        VxDCall VDD_Get_DISPLAYINFO     ;get information from the VDD
        pop     edi                     ;restore EAX --> DisplayInfoStructure
        test    [edi].diInfoFlags,MONITOR_INFO_DISABLED_BY_USER OR \
                        MONITOR_INFO_NOT_VALID OR REGISTRY_RESOLUTION_NOT_VALID

; until BIOS correctly supports refresh, bypass this
IFDEF SUPPORT_VESA_REFRESH
        jnz     VESASupportPassDown     ;we are not to set the refresh rate!
ELSE
                jmp             VESASupportPassDown
ENDIF

;
;Since this is a normal setmode, tack on the refresh rate info
;
; MSK - TODO - make sure that we handle the fact that we can't call this until after
; DeviceInit, any set modes before then should just be regular
;
;First, dispatch to the correct resolution handler:
;
        movzx   edx,[edi].diYRes        ;
        or      edx,edx                 ;any Y-resolution in the structure?
        jz      VESASupportPassDown     ;nope, blow out of here!

; Determine if match between resolution and color depth with mode being set
        Push_Client_State
        VMMcall Begin_Nest_V86_Exec

        ; load new values
        mov     ax,[ebp].Client_Word_Reg_Struc.Client_SP
        sub     ax,size VBE_ModeInfoBlock
        mov     [ebp].Client_Word_Reg_Struc.Client_SP,ax
        mov     [ebp].Client_Word_Reg_Struc.Client_DI,ax
        mov     ax,[ebp].Client_Reg_Struc.Client_SS
        mov     [ebp].Client_Word_Reg_Struc.Client_ES,ax
        mov     ax,04F01h
        mov     [ebp].Client_Word_Reg_Struc.Client_AX,ax
        ; copy mode number to cx
        mov     ax,[ebp].Client_Word_Reg_Struc.Client_BX
        and     ax,001FFh
        mov     [ebp].Client_Word_Reg_Struc.Client_CX,ax

        ; copy block to VM stack
        Client_Ptr_Flat esi, ES, DI, USES_EAX

        .if (esi == -1)         ; -1 if error
                mov     ax, TRUE                ; assume its GUI as default in this case
        .else
                ; get the mode info
                mov     eax,010h
                VMMCall Exec_Int

                mov     ax,FALSE                ;assume no match?
                movzx   edx,[edi].diYRes        ;load y resolution
                .if (dx == [esi].VBE_ModeInfoBlock.YResolution)
                        movzx   edx,[edi].diXRes        ;load x resolution
                        .if (dx == [esi].VBE_ModeInfoBlock.XResolution)
                                movzx   edx,[edi].diBpp         ;load bpp
                                .if (dl == [esi].VBE_ModeInfoBlock.BitsPerPixel)
                                        mov     ax,TRUE                 ; do we match?
                                .endif
                        .endif
                .endif
        .endif

        VMMCall End_Nest_Exec
        Pop_Client_State

        cmp     ax,TRUE
        jne     VESASupportPassDown

        movzx   edx,[edi].diYRes        ;reload y resolution
        mov     eax,0                   ;start at 480
        cmp     edx,480                 ;running 640x480?
        je      MVS_Common              ;yes, go handle it
        inc     eax
        cmp     edx,600                 ;running 800x600?
        je      MVS_Common              ;yes, go handle it
        inc     eax
        cmp     edx,768                 ;running 1024x768?
        je      MVS_Common              ;yes, go handle it
        inc     eax
;
public  MVS_Common
MVS_Common:
        shl     eax,2
        mov     edx,refreshRates[eax]
        mov     eax,[edx].RefreshRateStruct.VetricalRefreshRate
MVS_Loop:
        movzx   esi,[edi].diRefreshRateMax
        cmp     eax,esi
        jg      MVS_NextRate
        test    [edi].diInfoFlags,REFRESH_RATE_MAX_ONLY
                                        ;did we not get horizontal rate data?
        jnz     MVS_MaxOnly             ;nope, do simplied method
        movzx   eax,[edi].diHighHorz    ;get high horizontal value into EAX
        jz      MVS_SkipTest
        cmp     [edx].RefreshRateStruct.HorizontalRefreshRate,eax
        jg      MVS_NextRate
MVS_SkipTest:
        movzx   eax,[edi].diLowHorz     ;get low horizontal value into EAX
        jz      MVS_MaxOnly
        cmp     [edx].RefreshRateStruct.HorizontalRefreshRate,eax
        jl      MVS_NextRate
MVS_MaxOnly:
        jmp     MVS_Found
;
MVS_NextRate:
        add     edx,size RefreshRateStruct
        mov     eax,[edx].RefreshRateStruct.VetricalRefreshRate
        jnz     MVS_Loop
;
        sub     edx,size RefreshRateStruct
;
MVS_Found:
        lea     esi,[edx].RefreshRateStruct.crtcInfoBlockForced
        ;
        jmp     VESASupportCommon

VESASupportVM:
        
IFDEF DOS_REFRESH
        ; scan for mode
        mov     edi,OFFSET32 DefaultRefreshModes
        ; load mode number
        mov     ax,[ebp].Client_Word_Reg_Struc.Client_BX
        mov     ecx,DefaultRefreshCount
        or      ecx,ecx
        jz      VESASupportPassDown
        repne   scasw
        jne     VESASupportPassDown
        inc     ecx                     ; Back up one
        mov     edi,DefaultRefreshCount
        sub     edi,ecx                 ; Convert to index
        mov     eax,TYPE CRTCInfoBlock
        mul     edi
        mov     esi,eax
        add     esi,OFFSET32 DefaultRefreshTable
ELSE ; DOS_REFRESH
        jmp     VESASupportPassDown    ; Pass call on down
ENDIF ; DOS_REFRESH
       

VESASupportCommon:
IFDEF OLD_VESA30_REFRESH
        ; Find closest match of a frequency
        mov     edi,OFFSET32 ClockFrequencies
        mov     ax,word ptr [edi]
        mov     dx,ax                   ; initialize dx in case of empty list
        mov     cx,07FFFh               ; biggest possible distance
        .while   (ax != 0FFFFh)
                sub     ax,[esi].CRTCInfoBlock.PhysDotClock
                .if (SWORD PTR ax < 0)
                        neg     ax
                .endif
                .if (ax < cx)
                        mov     cx,ax
                        mov     dx,word ptr [edi]
                .endif
                inc     edi
                inc     edi
                mov     ax,word ptr [edi]
        .endw

        ; Did we find the closest clock?
        cmp     dx,0FFFFh
        je      VESASupportPassDown
ELSE ; OLD_VESA30_REFRESH
        ; Call VESA function 0C to get closest clock frequency to what we want
        Push_Client_State
        VMMcall Begin_Nest_V86_Exec

        ; load new values
        mov     ax,04F0Ch
        mov     [ebp].Client_Word_Reg_Struc.Client_AX,ax
        xor     ax,ax
        mov     [ebp].Client_Word_Reg_Struc.Client_BX,ax
        mov     ax,[esi].CRTCInfoBlock.PhysDotClock
        mov     [ebp].Client_Word_Reg_Struc.Client_CX,ax

        ; do the setmode
        mov     eax,010h
        VMMCall Exec_Int

        mov     dx,[ebp].Client_Word_Reg_Struc.Client_CX
        mov     cx,[ebp].Client_Word_Reg_Struc.Client_AX
        VMMCall End_Nest_Exec
        Pop_Client_State

        cmp     cx,0004Fh               ; did we do the clock call?
        jne     VESASupportPassDown     ; no, pass it down
ENDIF ; OLD_VESA30_REFRESH
        ;
        Push_Client_State
        VMMcall Begin_Nest_V86_Exec

        ; load new values
        mov     ax,[ebp].Client_Word_Reg_Struc.Client_SP
        sub     ax,((size CRTCInfoBlock + 1)/ 2) * 2
        mov     [ebp].Client_Word_Reg_Struc.Client_SP,ax
        mov     [ebp].Client_Word_Reg_Struc.Client_DI,ax
        mov     ax,[ebp].Client_Reg_Struc.Client_SS
        mov     [ebp].Client_Word_Reg_Struc.Client_ES,ax
        mov     ax,[ebp].Client_Word_Reg_Struc.Client_BX
        or      ax,00800h               ;set refresh rate flag
        mov     [ebp].Client_Word_Reg_Struc.Client_BX,ax

        ; copy block to VM stack
        Client_Ptr_Flat eax, SS, SP, USES_EAX

        .if (eax == -1)         ; -1 if error
                mov     ax, FALSE
        .else
                ;
                push    edx
                cld
                VMMcall _lmemcpy, <eax, esi, size CRTCInfoBlock>
                pop     edx

                ; Replace dot clock with the closest one found in the BIOS
                mov     edi,eax
                mov     [edi].CRTCInfoBlock.PhysDotClock,dx

                mov     InRefreshSetMode,0FFh

                ; do the setmode
                mov     eax,010h
                VMMCall Exec_Int
                ;push    10h
                ;VMMCall Exec_VxD_Int

                mov     InRefreshSetMode,000h

                mov     ax,TRUE                 ; did we do the setmode?
        .endif

        mov     cx,[ebp].Client_Word_Reg_Struc.Client_AX
        VMMCall End_Nest_Exec
        Pop_Client_State
        mov     [ebp].Client_Word_Reg_Struc.Client_AX,cx

        cmp     ax,TRUE                 ; did we do the setmode?
        jne     VESASupportPassDown     ; no, pass it down
;
VESASupportComplete:
        stc                             ; We completely handled the call
        mov     ax,VESA_SUCCESS         ; Return success
        jmp     VESASupportExit

ENDIF ; INCLUDE_REFRESH
        ;
        ; Hook out all VBE/DDC calls.  If we are currently running on a flat panel
        ; through the second I2C port, force the CX to 1.  Since the BIOS supports
        ; DDC3 it will accept the Monitor port # parameter (CX).
        ;
ifdef VESA_DDC
VESADDC:
        cmp     DontRecurse, 0          ;if we did an exec_int 10 4f15, we'll come right back here
        jne     VESASupportPassDown

;       Win98 does not recognize devices at address > A0.
;       It also does not recognize EDID 2.0.
;       We'll hack around these limitations.

        call    GetCRTCPort             ;EDX --> CRTC index register
        in      al,dx                   ;get and save current CRTC index ...
        ror     eax,8                   ;in high byte of EAX

;        unlock_extension_regs
        call    unlock_ext
;
        mov     al, 33h                 ;set to CRTC index 033h
        out     dx,al                   ;
        inc     edx                     ;EDX --> CRTC data register
        in      al,dx                   ;get data from CRTC register 033h
        dec     edx                     ;EDX --> CRTC index register

        test    al, 02h                 ;Check bit1, the current fp/crt bit
        jz      VESAMonitorActive       ;If 1, we are running a fp

;       if we are on DFP, what DDC port is it using?
        cmp             fpDDC,0
        je              VESAMonitorActive

        mov     [ebp].Client_Word_Reg_Struc.Client_CX, 1 ; Force to Monitor Port 1

VESAMonitorActive:
        call    restore_lock

;Restore the CRTC index register saved in the high byte of EAX:
;
        rol     eax,8                   ;
        out     dx,al                   ;

if VESA20   ; This code intercepts the VESA DDC calls to handle EDID 2.0 
            ; and device addresses other than A0, two cases which Win98 doesn't handle.
            ; We'll have to see if Millennium does this correctly, and bypass this if so.

        mov     bx,[ebp].Client_Word_Reg_Struc.Client_BX
        cmp     bl,0
        jz      VESAGetCaps
        cmp     bl,1
        jz      VESAReadEDID
        jmp     VESASupportPassDown
                
VESAGetCaps:
; Call into the BIOS, and check the return. If the device uses address > A0,
; change the return value to indicate A0, and set a flag to indicate we are tricking
; the OS and we should intercept the EDID read to get the correct device.
; No, we will always read the EDID, because we can't know if it is a version 2.
        mov     DontRecurse, 0ffh       ; we'll come right back to VESADDCSupport, pass it down
        
        Push_Client_State
        VMMcall Begin_Nest_V86_Exec
        mov     eax,010h
        VMMCall Exec_Int
        VMMCall End_Nest_Exec

        mov     DontRecurse, 0
        mov     DDCAddrFake,0          
        mov     bx,[ebp].Client_Word_Reg_Struc.Client_BX ; check the device address
        Pop_Client_State
        mov     [ebp].Client_Word_Reg_Struc.Client_BX,bx
        mov     DDCAddrFake,bx          ; save the DDC address map
        mov     [ebp].Client_Word_Reg_Struc.Client_AX,04fh

        test    bx,DDC_ADDR_A0          ; address A0 is OK, A2 & A6 Win98 can't handle
        jnz     VESASupportDone
        mov     bl,2                    ; make address A0
        mov     [ebp].Client_Word_Reg_Struc.Client_BX,bx
        jmp     VESASupportDone
        
VESAReadEDID:
; If we changed the previous GetCaps call to look like it was address A0 when it was actually 
; A2, we need to change the call to subfunction 3 -- Read EDID at A2.
; Because the monitor may have a version 2.0 EDID, we must always do the EDID read ourselves.
;        cmp     DDCAddrFake,0           ; are we tricking Windows?
;        jz      VESASupportPassDown

; save the caller's buffer pointer (possibly only 128 byte buffer)
        mov     ax,[ebp].Client_Word_Reg_Struc.Client_DI
        mov     BuffOff,ax
        mov     ax,[ebp].Client_Word_Reg_Struc.Client_ES
        mov     BuffSeg,ax

; alloc a 256 byte V86 buffer 
        VMMcall Get_Cur_VM_Handle       ; get the current vm handle into ebx
        mov     ecx, EDID2_SIZE         ; EDID 2 buffer size
        clc                             ; set carry flag to copy, clear otherwise
        VxDcall V86MMGR_Allocate_Buffer
        mov     eax,edi                 ; edi = (16 bits of seg, 16 bits of off)
        xor     ax,ax
        shr     eax,12
        or      ax,di
        mov     pEdid2,eax
                                        
        cmp     ecx, EDID2_SIZE
        jz      @f
        mov     ax,4f15h
        jmp     VESASupportPassDown

@@:     mov     eax, edi                ; Break the v86 address into ax:di
        and     edi, 0FFFFh
        shr     eax, 16

        mov     TempEdidBufOff,di
        mov     TempEdidBufSeg,ax
        
; Call into the BIOS, and check the return

; Set the device address, based on what we got from the Get DDC Caps call
; What is the proper address to use in the case of multiple addresses?
; A 256 byte device may indicate it supports A0, but the call will fail, since it returns
; the first 128 bytes, and the block will not checksum. (Seen on Gateway flat panel.)
; A 128 byte device will never indicate it supports A2 or A6.
; Therefore, if the device indicates it supports A2 or A6, use one of these, not A0.
        mov     EdidAddress, DDC_SUBF_4         ; read at A6
        test    DDCAddrFake,DDC_ADDR_A6
        jnz     DDC_Read_Exec_Int               ; use A6
EdidA2:        
        mov     EdidAddress, DDC_SUBF_3         ; read at A2
        test    DDCAddrFake,DDC_ADDR_A2
        jnz     DDC_Read_Exec_Int               ; use A2
EdidA0:        
        mov     EdidAddress, DDC_SUBF_1         ; read at A0
        
DDC_Read_Exec_Int:
        Push_Client_State                       ; preserve original state while we alter client register struct
; Insert our buffer pointer into the client state
        mov     ax,TempEdidBufOff
        mov     [ebp].Client_Word_Reg_Struc.Client_DI, ax
        mov     ax,TempEdidBufSeg
        mov     [ebp].Client_Word_Reg_Struc.Client_ES, ax
       
        mov     al,EdidAddress
        mov     [ebp].Client_Word_Reg_Struc.Client_BL,al
        mov     DontRecurse, 0ffh
        mov     [ebp].Client_Word_Reg_Struc.Client_AX, 4f15h
        
        VMMcall Begin_Nest_V86_Exec
        
        mov     eax,010h
        VMMCall Exec_Int
        VMMCall End_Nest_Exec
        mov     DontRecurse, 0
        mov     ax,[ebp].Client_Word_Reg_Struc.Client_AX        ; get return
        Pop_Client_State                        ; restore original state

        mov     [ebp].Client_Word_Reg_Struc.Client_AX, ax
        cmp     ax,04fh                                         ; put back return val
        jnz     Next_Edid_Addr

; Verify the function really succeeded
; In some cases, the monitor will respond to an address (ACK) but not return an EDID. The BIOS
; will then return Caps which are not true, and also report the EDID read succeeded when it did not.
; We will test the header data, and if it's not valid, retry using the next available address.
        mov     esi,pEdid2
        lea     edi,EDID1_HEADER
        mov     ecx,8
        repe    cmpsb           ; EDID 1?
        jz      Xlat_Edid_Buffer
        mov     esi,pEdid2
        cmp     byte ptr [esi],2 ; EDID 2?
        jz      Xlat_Edid_Buffer

; Try next address
Next_Edid_Addr:        
        cmp     EdidAddress,DDC_SUBF_1
        je      EdidDone
        cmp     EdidAddress,DDC_SUBF_4
        je      EdidA2
        cmp     EdidAddress,DDC_SUBF_3
        je      EdidA0
        jmp     DDC_Read_Exec_Int
                 
Xlat_Edid_Buffer:
; Get flat address for the caller's buffer
        xor     eax,eax
        mov     ax,BuffSeg
        shl     eax,4
        xor     ecx,ecx
        mov     cx,BuffOff
        add     eax,ecx
        mov     pEdid1,eax
                
; If it was a version 2.0 EDID, make up a fake version 1.x
        mov     esi,pEdid2
        mov     al,[esi]
        cmp     al,20h      ; version 2.0?
        je      Edid2

; Copy version 1 EDID into caller's buffer
        mov     cx,EDID1_SIZE
        mov     edi,pEdid1
        mov     esi,pEdid2
        rep movsb                
        jmp     EdidDone    

; We have a version 2 EDID. Translate into version 1 and return to caller.
; We do the minimum work required to make the VDD happy.
; This includes the product/vendor ID and some detailed timings.
Edid2:
        ; copy template
        mov     edi,pEdid1
        mov     esi,offset32 EdidTemp
        mov     ecx,EDID1_SIZE
        rep movsb
        ; copy vendor/product ID
        mov     esi,pEdid2
        mov     edi,pEdid1
        mov     ax,[esi+EDID2_VENDOR]
        mov     [edi+EDID1_VENDOR],ax

        ; Copy detailed timings. We have to parse a bunch of fields to find them first.
        mov     ax,[esi+EDID2_MAP]      ; map of timing info tells where to start
        mov     Edid2Map,ax
        mov     ecx,EDID2_TIMING_START   
        test    al, EDID2_LUM_TABLE_EXIST ; any lum tables?
        jz      Edid_rl
        ; advance beyond lum table
        mov     ah,[esi+ecx]            ; get 1st byte of timing table
        mov     al,ah
        and     al,EDID2_LUM_ENTRIES    ; get # of lum tables entries
        test    ah,EDID2_LUMX3          ; triple lum tables?
        jz      @f
        mov     bl,3
        mul     bl                      ; triple entries
@@:     add     al,1                    ; bump index beyond lum table
        add     cl,al                
Edid_rl:
        mov     ax,Edid2Map
        and     al,EDID2_RL             ; any range limits?
        jz      Edid_drl
        ; advance beyond range limits        
        shr     al,EDID2_RL_SHIFT
        mov     bl,8
        mul     bl                      ; 8-byte range limits
        add     cl,al
Edid_drl:
        mov     ax,Edid2Map
        test    al,EDID2_DRL            ; any detailed range limits?
        jz      Edid_tc
        ; advance beyond detailed range limits
        and     al,EDID2_DRL
        mov     bl,27
        mul     bl                      ; 27-byte detailed range limits
        add     cl,al
Edid_tc:
        mov     ax,Edid2Map             ; get 2nd byte of map
        and     ah,EDID2_TIMING_CODES
        jz      Edid2_dt
        shr     ah,EDID2_TC_SHIFT
        mov     al,ah
        mov     bl,4
        mul     bl                      ; 4-byte timing codes
        add     cl,al
        ; now we are finally at the detailed timings
Edid2_dt:
        mov     ax,Edid2Map
        and     ah,EDID2_DET_TIMINGS
        mov     al,ah
        mov     bl,18
        mul     bl                      ; 18-byte detailed timings
        mov     nDetTim,al
        mov     DetTimOff,cx            ; offset within edid2 struct to detailed timings
        ; copy all detailed timings to edid1
        add     edi,EDID1_DET_TIMING    ; point to edid1 detailed timings
        add     esi,ecx                 ; point to edid2 detailed timings
        xor     ecx,ecx
        mov     cl,nDetTim
        rep movsb
        
        ; generate 8 bit checksum
        mov     ecx,EDID1_SIZE
        mov     edi,pEdid1
        xor     ax,ax
EdidCs: add     al,[edi+ecx-1]
        loop    EdidCs
        neg     al
        mov     [edi+EDID1_SIZE-1],al
;debug - fail the call to see if the system hangs
;        mov     [ebp].Client_Word_Reg_Struc.Client_AX,014fh

EdidDone:
; Free the V86 buffer
        VMMcall Get_Cur_VM_Handle       ; get the current vm handle into ebx
        mov     ecx,EDID2_SIZE
        clc                             ; no copy back required
        VxDcall V86MMGR_Free_Buffer
        jmp     VESASupportDone
endif ; VESA_DDC

VESASupportDone:
        stc                             ; we handled it
        jmp     VESASupportExit

endif ; VESA20

VESASupportPassDown:
        clc                             ; We didn't completely handle the call, pass down to BIOS

VESASupportExit:
        popad
IFDEF DEBUG_LOG
        pushf
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "\n\r", DEBLEVELMAX
                pop     eax
        .endif
        popf
ENDIF ; DEBUG_LOG
        ret
EndProc MiniVDD_VESASupport
;
;


;       Hook Int 10
;       Check for VESA DDC function and direct it to the appropriate controller
BeginProc    MiniVDD_Int10Handler
        pushad
      
        mov     ax,[ebp].Client_Word_Reg_Struc.Client_AX
        
        ; Don't let VGA.DRV on secondary do a modeset when our driver is running on primary
        cmp     NumUnits,2              ; TwinView?
        jne     @f                      ; no, act normally
        cmp     DisplayEnabledFlag,0    ; display driver up?
        jz      @f                      ; no, it's not a problem
        cmp     DosBoxActive,0          ; running FS DOS?
        jne     @f                      ; yes, let it go thru
        cmp     ax,12h                  ; VGA driver modeset?
        jnz     @f                      ; yes, this is what we want to prevent

        ; We should skip modeset call from Windows VM only. This is workaround of Windows bug
        ; when VGA display driver on the secondary device (Display settings tab multimon) calls
        ; INT10 because it thinks we are in VGA mode but it does not assume it executes
        ; on the secondary device. VBIOS INT10 always executes on primary device so we'll change
        ; timings on primary by mistake.
        VMMCall Get_Cur_VM_Handle
        push    ebx
        VMMCall Get_Sys_VM_Handle
        pop     edx
        cmp     ebx,edx                 ; Bug #33723
        jne     @F                      ; Do not skip modeset if not Windows WM

        ; This may be a problem for Asian language DOS, which uses mode 12.
        ; Does a virtualized DOS session do a mode 12, and if we swallow it, what happens?
        jmp     Int10_Handled            ; Then swallow the interrupt

@@:
        ; Check for DDC functions
        cmp     ax,4F15h                ; Is this a VBE/DDC call?
        jne     Int10_Not_Handled

        ; We'll let the BIOS handle the report DDC caps call (BL = 0),
        ; and we'll handle the read EDID (BL = 1),

ifndef RM_GET_DDC_CAPS
        ; if we let the RM handle GET_DDC_CAPS, we don't need to do this
        ; Make sure that CRTC "A" owns I2C, since that is the head the BIOS will use to do DDC.
        ; unlock_extension_regs
        call    unlock_ext
        mov     dx,3d4h
        mov     ax,044h                 ; point to head A
        out     dx,ax
        mov     al,49h                  ; Engine Control reg
        out     dx,al
        inc     dx
        in      al,dx
        or      al,04h                 ; head A claims I2C (takes precedence over head B claiming it, so no need to set the other CR49)
        out     dx,al
        call    restore_lock
endif

        mov     bx,[ebp].Client_Word_Reg_Struc.Client_BX

        cmp     bl,01h                  ; Read Edid ?
        je      VESA_Read_EDID

ifndef  RM_GET_DDC_CAPS
        jmp     Int10_Not_Handled       ; let BIOS do it
else
        cmp     bl, 0
        jne     Int10_Not_Handled
                                        ; let RM do it
        mov     eax, NVRM_API_GET_DDC_CAPS
        mov     ebx, DEFAULT_PRIMARY_HDEV ; primary device
        call    CallRM                  ; returns status in ax
        mov     [ebp].Client_Word_Reg_Struc.Client_BX, bx
        mov     [ebp].Client_Word_Reg_Struc.Client_AX, 4fh
        jmp     Int10_Handled
endif

VESA_Read_EDID:
        ; This is a trick. Windows enabled EDID PNP support
        ; if it read EDID by the VESA int10 call AND it
        ; receives a valid EDID. Just let it go through
        ; here until it gets one good EDID and then we will
        ; stop punting to here from GetMonitorInfo.

        ; If GetMonInfoCount < 0 then that is either SBIOS call
        ; or that some DOS app is issuing the VESA call
        ; and not the main VDD I suppose.
        cmp     GetMonInfoCount,0
        js      Int10_Not_Handled

        ; Get flat address for the caller's buffer
        xor     edi,edi
        mov     di,[ebp].Client_Word_Reg_Struc.Client_ES
        shl     edi,4
        xor     eax,eax
        mov     ax,[ebp].Client_Word_Reg_Struc.Client_DI
        add     edi,eax

        ; ecx = Head number
        inc     dwInt10EntryCount
        jne     Int10_Entry_Count_Not_Handled

        push    edi
        push    GetMonInfoCount
        push    dwDisplayDevnodeHandle
        call    GetEdidAndRemapIt
        add     esp,0CH

        dec     dwInt10EntryCount

        ; Assume that there was an EDID
        mov     GetMonInfoCount,-2
        mov     eax,[edi]
        or      eax,eax
        jne     @F

        ; Reset GetMonInfoCount because it might be non DDC
        ; monitor on the head 0. Windows will not enable EDID
        ; PNP support unless it uses the int10 call AND it
        ; receives a valid EDID.
        mov     GetMonInfoCount,-1

        ; if fail, return VESA DDC fail status
        mov     [ebp].Client_Word_Reg_Struc.Client_AX,014Fh
        jmp     Int10_Handled

@@:
        mov     [ebp].Client_Word_Reg_Struc.Client_AX,004Fh

Int10_Handled:
        clc                            ; clear carry to show we handled it
        jmp     Int10_Done

Int10_Entry_Count_Not_Handled:
        dec     dwInt10EntryCount      ; fallthrough to stc
Int10_Not_Handled:
        stc                            ; set carry to show we didn't handle it
Int10_Done:
        popad
        ret
EndProc MiniVDD_Int10Handler


public  SaveNVAccessState
BeginProc SaveNVAccessState
;
;       SaveNVAccessState - Save the state of the NV real mode access registers
;
;       Entry:  Extended CRTC registers unlocked
;       Exit:   esi = 32-bit NV address
;               al  = real mode access control bits
;               dx  = LSW of 32-bit data register
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "SaveNVAccessState", DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        push    ecx
        push    eax
        push    edx
        ;
        call    GetCRTCPort
        mov     al, NVRM_ACCESS
        SIM_NO  dx,al
        inc     edx                                     ; edx -> CRTC data
        SIM_NI  al,dx
        ror     eax,8                                   ; Save access bits in high byte of eax
        dec     edx                                     ; edx -> CRTC index
        mov     al, NVRM_ACCESS
        mov     ah, NVRM_ACCESS_MASK OR NVRM_DATA32     ; Get LSW of 32-bit write
        SIM_NO  dx, ax
        ror     edx,16                                  ; save CRTC index in upper word of edx
        mov     dx,003D0h
        SIM_NI  ax,dx
        push    ax                                      ; Save LSW of 32-bit write
        mov     al, NVRM_ACCESS
        mov     ah, NVRM_ACCESS_MASK OR NVRM_ADDRESS
        rol     edx,16                                  ; restore CRTC index
        SIM_NO  dx, ax
        ror     edx,16                                  ; save CRTC index in upper word of edx
        mov     dx, 003D0h
        SIM_NI  ax,dx
        push    ax                                      ; Save LSW of address
        inc     dx
        inc     dx
        SIM_NI  ax,dx
        mov     si,ax                                   ; move MSW of address into si
        shl     esi, 16
        pop     si                                      ; now ESI has whole address
        rol     edx,16                                  ; restore CRTC index
        rol     eax,8                                   ; restore access bits
        inc     edx                                     ; DX -> CRTC data register
        SIM_NO  dx,al
        ;
        pop     cx                                      ; restore LSW of 32-bit write
        pop     edx                                     ; restore original edx
        mov     dx,cx                                   ; now edx is all set
        ;
        mov     cl,al                                   ; save control bits into cl
        pop     eax                                     ; restore original eax
        mov     al,cl                                   ; now eax is all set
        ;
        pop     ecx                                     ; restore original ecx
IFDEF DEBUG_LOG
        pushf
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "\n\r", DEBLEVELMAX
                pop     eax
        .endif
        popf
ENDIF ; DEBUG_LOG
        ret
EndProc SaveNVAccessState
;
;
public  RestoreNVAccessState
BeginProc RestoreNVAccessState
;
;       RestoreNVAccessState - Restore the state of the NV real mode access registers
;
;       Entry:  Extended CRTC registers unlocked
;               esi = 32-bit NV address
;               al  = real mode access control bits
;               dx  = LSW of 32-bit data register
;       Exit:   none
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf "RestoreNVAccessState", DEBLEVELMAX
                push    ecx
                and     ecx,0FFFFh
                Debug_Printf ":CRTC:%04X", ecx, DEBLEVELMAX
                pop     ecx
                pop     eax
                ;
                push    eax
                Debug_Printf ":NV Address:%08lX:RM Control:%04X:RM Reg:%04X:LSW Data32:%04X", eax, DEBLEVELMAX
                push    ebx
                mov     bl,bh
                and     ebx,0FFh
                Debug_Printf ":RM Control:%04X:RM Reg:%04X:LSW Data32:%04X", ebx, DEBLEVELMAX
                pop     ebx
                push    ebx
                and     ebx,0FFh
                Debug_Printf ":RM Reg:%04X:LSW Data32:%04X", ebx, DEBLEVELMAX
                pop     ebx
                push    edx
                and     edx,0FFFFh
                Debug_Printf ":LSW Data32:%04X", edx, DEBLEVELMAX
                pop     edx
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        push    eax
        push    edx
        ;
        push    ax                                      ; we need to use these
        push    dx
        ;
        call    GetCRTCPort
        mov     al, NVRM_ACCESS
        mov     ah, NVRM_ACCESS_MASK OR NVRM_ADDRESS
        SIM_NO  dx, ax
        ror     edx,16                                  ; save CRTC index in upper word of edx
        mov     dx, 003D2h                              ; Write MSW of address first
        mov     eax, esi
        shr     eax, 16
        SIM_NO  dx, ax
        dec     dx                                      ; Now write LSW of address
        dec     dx
        mov     ax, si
        SIM_NO  dx, ax
        mov     al, NVRM_ACCESS
        mov     ah, NVRM_ACCESS_MASK OR NVRM_DATA32     ; LSW of 32-bit write
        rol     edx,16                                  ; restore CRTC index
        SIM_NO  dx, ax
        ror     edx,16                                  ; save CRTC index in upper word of edx
        mov     dx,003D0h
        pop     ax                                      ; Restore LSW of 32-bit write
        SIM_NO  dx, ax
        rol     edx,16                                  ; restore CRTC index
        pop     ax                                      ; Restore access bits
        mov     ah, al
        mov     al, NVRM_ACCESS
        SIM_NO  dx, ax
        ;
        pop     edx
        pop     eax
IFDEF DEBUG_LOG
        pushf
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "\n\r", DEBLEVELMAX
                pop     eax
        .endif
        popf
ENDIF ; DEBUG_LOG
        ret
EndProc RestoreNVAccessState
;
;
IFDEF DOS_REFRESH
subttl          Handle refresh rate support for PM OEM VESA calls
page +
public MiniVDD_Xlat_Int10
BeginProc MiniVDD_Xlat_Int10
;BeginProc MiniVDD_Xlat_Int10, VMCREATE
;
;
;* need to map pm to real mode int 10, 4f14,41
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_PMHandler", DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        VMMcall Simulate_Iret                   ; Eat the int right now

        mov     eax, [ebp.Client_EAX]           ; Get entry EAX

        cmp     ax, 4F14h                       ; Q: Get/Set palette?
        jne     SHORT MVXI10_Reflect_Int_EDX    ;    N: Just reflect it now

        mov     ax,[ebp].Client_Word_Reg_Struc.Client_BX
        cmp     al,041h                         ; OEM set default refresh rate
        jne     SHORT MVXI10_Reflect_Int_EDX    ;    N: Just reflect it now

        mov     edx, OFFSET32 MiniVDD_OEM_Refresh_API
        VxDjmp  V86MMGR_Xlat_API

public MVXI10_Reflect_Int_EDX
MVXI10_Reflect_Int_EDX:
        mov     edx, OFFSET32 MiniVDD_Default_API
        VxDjmp  V86MMGR_Xlat_API

IFDEF DEBUG_LOG
        pushf
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "\n\r", DEBLEVELMAX
                pop     eax
        .endif
        popf
ENDIF ; DEBUG_LOG
        ret
EndProc MiniVDD_Xlat_Int10
ENDIF ; DOS_REFRESH

IFDEF   I2C
;       I2COpen
;
;Entry: args on stack (stdcall)
;
;Exit:  status
public  MiniVDD_I2COpen
BeginProc       MiniVDD_I2COpen, DOSVM
;       args are passed to us on the stack as stdcall
        call    _vddI2COpen
        ret 12
EndProc         MiniVDD_I2COpen

;       I2CAccess
;
;Entry: args on stack (stdcall)
;
;Exit:  status
;
public  MiniVDD_I2CAccess
BeginProc       MiniVDD_I2CAccess, DOSVM
;       args are passed to us on the stack as stdcall
        call    _vddI2cAccess
        ret 8
EndProc         MiniVDD_I2CAccess

ENDIF   ;I2C

IFDEF   DIOC
subttl      WIN32 Device IO Control
page +
public  MiniVDD_W32_DIOC

BeginProc MiniVDD_W32_DIOC
;-----------------------------------------------------------------
;       D E V I C E I O C O N T R O L   I N T E R F A C E
;-----------------------------------------------------------------
;  ENTRY :
;        ESI -> address of DIOC structure

        pushad
        mov  ecx, [ esi ].dwIoControlCode

        cmp  ecx,20000700H
        je   DevCtl_SetFSDOSPtr

        cmp  ecx, DIOC_CLOSEHANDLE
        je   DevCtl_CloseHandle

        cmp  ecx, DIOC_GETVERSION
        je   DevCtl_GetVersion

        cmp  ecx, VDD_IOCTL_NV_GETSETCALLBACK
        jnz  Next0
        call NVGetSetCallback
        jmp  MiniVDDDone

Next0:
        cmp  ecx, VDD_IOCTL_NV_FILLTABLE
        jnz  Next1
        call NvFillTable
        jmp  MiniVDDDone
Next1:
        cmp  ecx, VDD_IOCTL_GET_DDHAL
        jnz  Next2
        call GetDDHAL
        jmp  MiniVDDDone
Next2:
        cmp  ecx, VDD_IOCTL_NV_SETVIDTEXSURF
        jnz  Next3
        call NVSetVidTexSuf
        jmp  MiniVDDDone
Next3:
IFDEF NVPE
        cmp  ecx, VDD_IOCTL_NVPE_COMMAND
        jnz  MiniVDDDone
        push esi
        call _nvpeVDDCmdHandler
        pop  esi
ENDIF

MiniVDDDone:
        cmp  eax,1
        jae  DevCtl_Fails

;----------------------------------------------------------------
;
;  ECX = -1 ( DIOC_CLOSEHANDLE )
;
;----------------------------------------------------------------

DevCtl_CloseHandle      :

        jmp  DevCtl_OKey

DevCtl_SetFSDOSPtr:
        mov  eax,[esi].lpvInBuffer
        mov  pDDrawFullScreenDOSActive,eax
        jmp  DevCtl_OKey

;----------------------------------------------------------------
;
;  ECX = 0 ( DIOC_GETVERSION )
;
;----------------------------------------------------------------
DevCtl_GetVersion :

        jmp  DevCtl_OKey

DevCtl_Fails :

        mov DevCtlRet, 50    ; ERROR_NOT_SUPPORTED
        stc                  ; indicate error
        jmp DevCtl_Exit

DevCtl_OKey :

        mov DevCtlRet, 0
        clc
        jmp DevCtl_Exit

DevCtl_Exit :

        popad
        mov eax, DevCtlRet
        ret
EndProc MiniVDD_W32_DIOC
endif   ;DIOC


public  WaitTicks
BeginProc WaitTicks
;
;       WaitTicks - Wait a given number of timer ticks
;
;       Entry:  CX = Number of ticks to wait
;       Exit:   None
;
;       All registers are preserved
;
        pushad
;
        VMMCall Get_System_Time
        mov     ebx,eax
@@:
        VMMCall Get_System_Time
        sub     eax,ebx
        cmp     ax,cx
        jl      @b
;
        popad
        ret
EndProc WaitTicks
;
;
public  Beep
BeginProc Beep
;
;       Beep - Beep the speaker once
;
;       Entry:  None
;       Exit:   None
;
;       All registers are preserved.
;
;
IFDEF   DEBUG_BEEP
        pushad
;
        mov     al,0B6h
        out     43h,al
        mov     al,033h
        out     42h,al
        mov     al,005h
        out     42h,al
        in      al,061h
        push    ax
        or      al,003h
        out     61h,al
        mov     cx,4*18
        call    WaitTicks
        pop     ax
        out     61h,al
;
        popad
ENDIF   ; DEBUG_BEEP
        ret
EndProc Beep
;
;
; Call the resource manager.
;

BeginProc       CALLRM          
;               push everything onto stack so we have the top of a client reg struct. (see VMM.H)

        push    esi
        mov     esi, offset callrm_rmusrapi
        mov     dword ptr [esi].minivdd_CALLRM_rmusrapi_Struct.rmusrapi_function, eax
        dec     ebx
        mov     dword ptr [esi].minivdd_CALLRM_rmusrapi_Struct.rmusrapi_device, ebx
        mov     eax,esi
        pop     esi 

        
        push    eax
        push    ecx
        push    edx
        push    ebx
        push    eax                             ; res0, documented as "ESP at pushall"
        push    ebp
        push    esi
        push    edi
        
        mov     ebp, esp                ; point ebp to client reg struct 
        call    DWORD PTR ResManAPI
        pop     edi
        pop     esi
        pop             ebp
        pop             eax                             ; res0
        pop     ebx
        pop     edx
        pop     ecx
        pop     eax
        ret     
EndProc CALLRM

;               save lock value and unlock chip
;               we must save lock value. CRTC index should be saved in calling routine
BeginProc       unlock_ext
        push    eax
        push    edx
        call    GetCRTCPort             ;EDX --> CRTC index register
                mov             al,1fh
                out             dx,al
                inc             dx
                in              al,dx
                mov             LockValue,al
                mov             al,57h
                out             dx,al
sl_exit:
        pop     edx
        pop     eax
        ret
                                
EndProc unlock_ext






;               restore lock state
BeginProc       restore_lock
        push    eax
        push    edx
        call    GetCRTCPort             ;EDX --> CRTC index register
;       NV4 - locked, unlocked, or read-only
                mov             ah,57h
                cmp             LockValue,3             ;read 1 if unlocked
                je              @f
                mov             ah,75h
                cmp             LockValue,1             ;read 1 if read-only (NV4 or later)
                je              @f
                mov             ah,99h                  ;must be locked
@@:         ;NV4
                mov             al,1fh
                out             dx,ax                   ;restore lock
rl_exit:
        pop     edx
        pop     eax
        ret
EndProc         restore_lock


;; ReadCr44 - BIOS copied script for reading CR44
;; INPUTS
;;    DX - CRTC access (3d4)
;; OUTPUT
;;    AL - Cr44 read value
;;    DX - restored
BeginProc       ReadCr44
        ; TODO: We probably should read the Resman copy
        ; since I'm not sure if this io read works
        ;
        ; Read Cr44 using 8 bit IO - Output will be in AL
        mov     al,44h          ; Address CR44/0 AH for default
        out     dx,al           ; send 44 as index
        inc     edx             ; set to 3d5
        in      al,dx
        dec     edx             ; set back to 3d4
        
        ; Read the mirror bit. If this is on, we know we're in Broadcast mode
;        push    ebx
;        xchg    eax,ebx         ; store eax in ebx for now
        ; get the mirror bit (28)
;        REG_RD32(NV_PBUS_DEBUG_1)
;        xchg    eax,ebx         ; restore eax, PBUS_DEBUG_1 is in ebx
        ; is the mirror bit set
;        .if (ebx & 10000000h)
;                mov     al,04h  ; return Broadcast mode
;        .endif
;        pop     ebx
        
        ret
EndProc         ReadCr44
        
;;
;; WriteCr44 - BIOS copied script for writing CR44
;; INPUTS
;;    DX - CRTC access (3d4)
;;    AL - Cr44 write value value
;; OUTPUT
;;    DX - restored
BeginProc       WriteCr44
        ; Using MMIO to write CR44
        ; This works for the Resman!
        push    eax
        mov     al,44h
        REG_WR08(NV_PRMCIO_CRX__COLOR)
        pop     eax
        REG_WR08(NV_PRMCIO_CRE__COLOR)

        ret
EndProc         WriteCr44





; Procedures for setting BIOS TV programming flag
; Use memory mapped access because we can assure access to head A on multihead devices, without having to switch CR44.
BeginProc TellBIOSProgramTV
;   tell the BIOS to program the TV encoder
        push    eax
        push    edx
        push    ecx
        push    esi                     ; used in REG_RD/REG_WR macros

            ; unlock
        mov al, 1Fh                     ; Get current CR1F
        REG_WR08(NV_PRMCIO_CRX__COLOR)
        REG_RD08(NV_PRMCIO_CRE__COLOR)  ; Save it
        mov cl, al
        mov al,57h
        REG_WR08(NV_PRMCIO_CRE__COLOR)  ; unlock

        mov al, BIOS_SCRATCH1
        REG_WR08(NV_PRMCIO_CRX__COLOR)  
        REG_RD08(NV_PRMCIO_CRE__COLOR)  
        and al,NOT BIOS_PGRM_TV         ; clear bit 1 (OK to program TV encoder)
        REG_WR08(NV_PRMCIO_CRE__COLOR)  

        mov al, 1Fh                     ; Get current CR1F
        REG_WR08(NV_PRMCIO_CRX__COLOR)  
        ; restore lock
        mov             al,57h
        cmp             cl,3             ;read 1 if unlocked
        je              @f
        mov             al,75h
        cmp             cl,1             ;read 1 if read-only (NV4 or later)
        je              @f
        mov             al,99h           ;must be locked
@@:     
        REG_WR08(NV_PRMCIO_CRE__COLOR)  

        pop     esi                     ; used in REG_RD/REG_WR macros
        pop     ecx
        pop     edx
        pop     eax
        ret
EndProc TellBIOSProgramTV


BeginProc TellBIOSNotProgramTV
;   tell the BIOS to not program the TV encoder
        push    eax
        push    edx
        push    ecx
        push    esi                     ; used in REG_RD/REG_WR macros

        ; unlock
        mov al, 1Fh                     ; Get current CR1F
        REG_WR08(NV_PRMCIO_CRX__COLOR)  
        REG_RD08(NV_PRMCIO_CRE__COLOR)  ; Save it
        mov cl, al
        mov al,57h
        REG_WR08(NV_PRMCIO_CRE__COLOR)  ; unlock

        mov al, BIOS_SCRATCH1
        REG_WR08(NV_PRMCIO_CRX__COLOR)  
        REG_RD08(NV_PRMCIO_CRE__COLOR)  
        or  al, BIOS_PGRM_TV            ; set bit 1 (not OK to program TV encoder)
        REG_WR08(NV_PRMCIO_CRE__COLOR)  

        mov al, 1Fh                     ; Get current CR1F
        REG_WR08(NV_PRMCIO_CRX__COLOR)  
        ; restore lock
        mov             al,57h
        cmp             cl,3             ;read 1 if unlocked
        je              @f
        mov             al,75h
        cmp             cl,1             ;read 1 if read-only (NV4 or later)
        je              @f
        mov             al,99h           ;must be locked
@@:     
        REG_WR08(NV_PRMCIO_CRE__COLOR)  
        
        pop     esi                     ; used in REG_RD/REG_WR macros
        pop     ecx
        pop     edx
        pop     eax
        ret
EndProc TellBIOSNotProgramTV
;
VxD_LOCKED_CODE_ENDS
;
;
end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vdd\common\nvpeos.c ===
/*----------------------------------------------------------------------------*/
/*
 * nvpeos.c
 *
 *  NVPE miniVDD code.
 *
 */

/*----------------------------------------------------------------------------*/
/*
 * include files
 */

// MS includes
#define WANTVXDWRAPS
#include <basedef.h>
#include <vmm.h>
#include <vxdwraps.h>
#include <vwin32.h>

// NV includes 
#include <nv32.h>
#include <nvtypes.h>
#include <nvmacros.h>
#include <nvwin32.h>
#include <nvos.h>
#include <nvrmr0api.h>

#include "ddkmmini.h"
#include "nvpeos.h"

//
// prototypes
//
VP_STATUS   NVPEProcessCommand      (PVOID, PVIDEO_REQUEST_PACKET);
VP_STATUS   NVPProcessState         (PHW_DEVICE_EXTENSION, int, BOOL);
DWORD       NVPCompleteTransfer     (PVOID);
VOID        _vwin32ResetWin32Event  (PVOID);
VOID        _vwin32SetWin32Event    (PVOID);


/*----------------------------------------------------------------------------*/
/*
 * globals
 */
struct _HW_DEVICE_EXTENSION nvpeDevExtension;
struct _VIDEO_REQUEST_PACKET nvpeRequestPacket;
#ifdef DEBUG
int cur_debuglevel = DBG_LEVEL_DEFAULTS;    // all modules set to warning level
#endif

/*----------------------------------------------------------------------------*/
/*
 * nvpeVDDCmdHandler()
 *
 *      Initial NVPE_COMMAND IOCTL handler.  Called from nvmini.asm.
 */

DWORD nvpeVDDCmdHandler(
    PDIOCPARAMETERS  pDIOC)
{

    /*
     * repackage IOCTL parameters and call the real NVPE handler
     */
    nvpeRequestPacket.IoControlCode = pDIOC->dwIoControlCode;
    nvpeRequestPacket.StatusBlock = 0;
    nvpeRequestPacket.InputBuffer = (PVOID)(pDIOC->lpvInBuffer);
    nvpeRequestPacket.InputBufferLength = pDIOC->cbInBuffer;
    nvpeRequestPacket.OutputBuffer = (PVOID)(pDIOC->lpvOutBuffer);
    nvpeRequestPacket.OutputBufferLength = pDIOC->cbOutBuffer;

    NVPEProcessCommand(&nvpeDevExtension, &nvpeRequestPacket);

    /*
     * nvmini.asm uses a return value of 1 to signal failure
     */
    if (nvpeRequestPacket.StatusBlock == 0) {
        return 0;
    }
    else {
        return 1;
    }

}

/*----------------------------------------------------------------------------*/
/*
 * VideoField0Notify()
 *
 *      Callback function for Field 0 capture.  Called by the RM.
 */

void VideoField0Notify()
{

    NVPProcessState(&nvpeDevExtension, 0, FALSE);

}

/*----------------------------------------------------------------------------*/
/*
 * VideoField1Notify()
 *
 *      Callback function for Field 1 capture.  Called by the RM.
 */

void VideoField1Notify()
{

    NVPProcessState(&nvpeDevExtension, 1, FALSE);

}

/*----------------------------------------------------------------------------*/
/*
 * VBIField0Notify()
 *
 *      Callback function for VBI Field 0 capture.  Called by the RM.
 */

void VBIField0Notify()
{

    NVPProcessState(&nvpeDevExtension, 0, TRUE);

}

/*----------------------------------------------------------------------------*/
/*
 * VBIField1Notify()
 *
 *      Callback function for VBI Field 1 capture.  Called by the RM.
 */

void VBIField1Notify()
{

    NVPProcessState(&nvpeDevExtension, 1, TRUE);

}

/*----------------------------------------------------------------------------*/
/*
 * NVPTransferNotify()
 *
 *      Callback function VBI/Video Transfer code.  Called by the RM.
 */

void NVPTransferNotify()
{
    NVPCompleteTransfer(&nvpeDevExtension);
}

/*----------------------------------------------------------------------------*/
/*
 * Misc os dependent utility functions.
 *
 */

U032 osNVPAllocDmaBuffer(
    PVOID pContext, 
    DWORD dwSize, 
    PVOID *pBuffer)
{

    *pBuffer = _HeapAllocate(dwSize, 0);
    if (*pBuffer == NULL) {
        return 1;
    }
    else {
        return 0;
    }

}

void osNVPReleaseDmaBuffer(
    PVOID pContext, 
    PVOID pBuffer)
{
    _HeapFree((BYTE *)pBuffer, 0);
}

void osNVPClearEvent(void* hEvent)
{
    _vwin32ResetWin32Event(hEvent);
}

U032 osNVPSetEvent(void *hEvent)
{
    _vwin32SetWin32Event(hEvent);
    return 0;
}

U032 rmNVPAllocContextDma(
    U032 hClient,
    U032 hDma,
    U032 hClass,
    U032 flags,
    U032 selector,
    U032 base,
    U032 limit)
{

    return NvRmR0AllocContextDma(hClient, hDma, hClass, flags, (PVOID) base, limit);

}

U032 rmNVPAllocChannelDma(
    U032 hClient,
    U032 hDevice,
    U032 hDmaChannel,
    U032 hClass,
    U032 hErrorContext,
    U032 hDataContext,
    U032 offset,
    U032 *ppControl)
{

    return NvRmR0AllocChannelDma(hClient, hDevice, hDmaChannel, hClass, hErrorContext, hDataContext, offset, (PVOID) ppControl);

}

U032 rmNVPAllocObject(
    U032 hClient,
    U032 hChannel,
    U032 hObject,
    U032 hClass)
{

    return NvRmR0AllocObject(hClient, hChannel, hObject, hClass);

}

U032 rmNVPAlloc(
    U032 hClient,
    U032 hChannel,
    U032 hObject,
    U032 hClass,
    PVOID pAllocParms)
{

    return NvRmR0Alloc(hClient, hChannel, hObject, hClass, pAllocParms);

}

U032 rmNVPFree(
    U032 hClient,
    U032 hParent,
    U032 hObject)
{

    return NvRmR0Free(hClient, hParent, hObject);

}

U032 rmNVPAllocEvent(
    NVOS10_PARAMETERS *pEvent)
{
    return NvRmR0AllocEvent(pEvent->hRoot, 
                            pEvent->hObjectParent, 
                            pEvent->hObjectNew, 
                            pEvent->hClass, 
                            pEvent->index, 
                            (PVOID)(pEvent->hEvent.low));
}

U032 rmNVPInterrupt(
    U032 hClient,
    U032 hDevice)
{
    return NvRmR0Interrupt(hClient, hDevice);
}

void nvpeVDDClearState()
{
    DWORD   i;
    unsigned char *pBuf;

    // clear our global HwDevExt manually since we can't use bzero()
    pBuf = (unsigned char*) &nvpeDevExtension;
    for (i = 0; i < sizeof(nvpeDevExtension); i++ ) {
        pBuf[i] = 0;
    }
}

#if DEBUG

//---------------------------------------------------------------------------
//
//  Debugging support.
//
//---------------------------------------------------------------------------

VOID osDbgPrintf_va(
    int     module,
    int     debuglevel,
    const char *printf_format,
    va_list arglist)
{
    int     moduleValue = cur_debuglevel;
    char    nv_error_string[MAX_ERROR_STRING];
    char    *p = nv_error_string;
    int     chars_written;

    // get the module
    // put the module we want in the first 2 bits
    moduleValue = moduleValue >> (module * 2);

    // get the value of those two bits
    // mask off the last 30 bits
    moduleValue = moduleValue & 0x00000003;

   if (debuglevel >= moduleValue)
   {
        chars_written = nvDbgSprintf(p, printf_format, arglist);

        _Debug_Printf_Service(p);
   }
}

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vdd\common\dtrace.h ===
//
// low overhead tracing facility
//

// add "#define DEFINE_GLOBALS" in only 1 file!
#ifdef DEFINE_GLOBALS
#define	GLOBAL
#define	INIT(_x_)	= _x_
#else
#define	GLOBAL	extern
#define	INIT(_x_)
#endif

#define DTRACE	1

#ifdef DTRACE

#undef DTRACE
#define DTRACE(val)	do_dtrace((unsigned int) val, 0)
#define	DTRACE_CC(val)	do_dtrace((unsigned int) val, 1)
#define	DTRACE_RC(rc)	if ( (rc) != 0 ) { DTRACE_CC('EEEE'); DTRACE(rc); }
#define DTRACE_CYCLE_DELTA()  dtraceCycleDelta()
#define DTRACE_CYCLE_COUNT_AND_DELTA()  dtraceCycleCountAndDelta()
#define	DTRACING

#else // no trace support

#define DTRACE(val)
#define	DTRACE_CC(val)
#define	DTRACE_RC(rc)
#define DTRACE_CYCLE_DELTA()
#define DTRACE_CYCLE_COUNT_AND_DELTA()
#undef	DTRACING

#endif

#ifdef DTRACING

#define DTRACE_ENTRIES	1024	// must be power of two
GLOBAL unsigned int	dtrace_buf[DTRACE_ENTRIES+1];
GLOBAL int          dtrace_idx INIT(0);

static void
do_dtrace( unsigned int val, int char_const )
{

    /*
     * Some compilers "reverse" long character constants from their
     * readable forms.  Detect and fix that here.
     */

    if ( char_const && ('\0\0\0\1' != 1) )
	val = ((val & 0xff) << 24) +
	      (((val >> 8) & 0xff) << 16) +
	      (((val >> 16) & 0xff) << 8) +
	      ((val >> 24) & 0xff);

    /* XXX enter critical section */

    dtrace_buf[dtrace_idx++] = val;
    dtrace_idx &= (DTRACE_ENTRIES - 1);
    dtrace_buf[dtrace_idx] = '***\0';

    /* XXX exit critical section */

    return;

}

#endif /* DTRACING */

//
// cycle count stuff
//

GLOBAL unsigned int prevHi INIT(0);
GLOBAL unsigned int prevLo INIT(0);

static unsigned int getCycleCount( unsigned int* pHi, unsigned int* pLo )
{

    unsigned int        hi, lo;

    /* emit RDTSC instruction to get clock count */
    __asm
    {
        _emit   0x0f 
        _emit   0x31
        mov         hi, edx
        mov         lo, eax
    }

    *pHi = hi;
    *pLo = lo;

    return(lo);

}

static unsigned int getDeltaCycles( 
    unsigned int endHi, 
    unsigned int endLo, 
    unsigned int startHi, 
    unsigned int startLo)
{

    unsigned int resultHi, resultLo;

    if ( endLo > startLo ) {
        resultLo = endLo - startLo;
    }
    else {
        resultLo = 4294967295 - (startLo-endLo);
        endHi--;
    }

    // resultHi = endHi - endLo;
    
    return(resultLo);

}

static void dtraceCycleDelta()
{
    unsigned int    currentHi, currentLo, deltaLo;
    
    getCycleCount(&currentHi,&currentLo);
    deltaLo = getDeltaCycles(currentHi, currentLo, prevHi, prevLo);
    
    DTRACE(deltaLo);

    prevHi = currentHi;
    prevLo = currentLo;
    
}

static void dtraceCycleCountAndDelta()
{
    unsigned int    currentHi, currentLo, deltaLo;
    
    getCycleCount(&currentHi,&currentLo);
    deltaLo = getDeltaCycles(currentHi, currentLo, prevHi, prevLo);
    
    DTRACE(currentLo);
    DTRACE(deltaLo);

    prevHi = currentHi;
    prevLo = currentLo;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vdd\common\nvpeos.h ===
/*----------------------------------------------------------------------------*/
/*
 * nvpeos.h
 *
 * Include file for miniVDD side of NVPE
 */

#ifndef _NVPEOS_H
#define _NVPEOS_H

#define NVPE_WIN9X  1

#include "nvpecntx.h"

// debug levels and modules
#include <nv_dbg.h>


//
// prototypes
//
U032 osNVPAllocDmaBuffer    (VOID *pContext,U032 dwSize,VOID **pBuffer);
VOID osNVPReleaseDmaBuffer  (VOID *pContext,VOID *pBuffer);
VOID osNVPClearEvent        (VOID *hEvent);
U032 osNVPSetEvent          (VOID *hEvent);
U032 rmNVPAllocContextDma   (U032 hClient,U032 hDma,U032 hClass,U032 flags,U032 selector,U032 base,U032 limit);
U032 rmNVPAllocChannelDma   (U032 hClient,U032 hDevice,U032 hDmaChannel,U032 hClass,U032 hErrorContext,U032 hDataContext,U032 offset,U032 *ppControl);
U032 rmNVPAllocObject       (U032 hClient,U032 hChannel,U032 hObject,U032 hClass);
U032 rmNVPAllocEvent        (NVOS10_PARAMETERS *pEvent);
U032 rmNVPAlloc             (U032 hClient,U032 hChannel,U032 hObject,U032 hClass,PVOID pAllocParms);
U032 rmNVPFree              (U032 hClient,U032 hParent,U032 hObject);
U032 rmNVPInterrupt         (U032 hClient, U032 hDevice);

/* 
 * primary NVPE command IOCTL (must mirror ioctl define in nvpeos.inc) 
 *
 * XXX - need to move this define to a higher level shared include file (jsun) 
 */ 
     
#define VDD_IOCTL_NVPE_COMMAND      0x300CAFE0
 
/*
 * Win9x equivalents for some typedefs used in Win2K
 */
 
typedef struct _HW_DEVICE_EXTENSION {

    PVOID       IRQCallback;
    PVOID       pIRQData;
	ULONG		dwIRQSources;
	ULONG		dwIRQContext;

	NVP_CONTEXT	avpContexts[NVP_MAX_VPORTS];

} HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;

typedef struct _VIDEO_REQUEST_PACKET {

    ULONG IoControlCode;
    ULONG StatusBlock;      // really a PSTATUS_BLOCK
    PVOID InputBuffer;
    ULONG InputBufferLength;
    PVOID OutputBuffer;
    ULONG OutputBufferLength;

} VIDEO_REQUEST_PACKET, *PVIDEO_REQUEST_PACKET;


/*
 * XXX misc things that might need to be put elsewhere
 */
 
typedef LONG VP_STATUS;

#ifndef NO_ERROR
#define	NO_ERROR			0	/* Success */
#endif

#ifndef ERROR_INVALID_PARAMETER
#define ERROR_INVALID_PARAMETER     87
#endif

// 
// XXX taken from NT's dxmini.h and ddraw.h
// 
#define DX_OK                                   0x0
#define DXERR_UNSUPPORTED                       0x80004001
#define DXERR_GENERIC                           0x80004005
#define DXERR_OUTOFCAPS                         0x88760168

#define DDOVER_AUTOFLIP                       	0x00100000l
#define DDOVER_BOB                       	0x00200000l
#define DDOVER_OVERRIDEBOBWEAVE			0x00400000l
#define DDOVER_INTERLEAVED			0x00800000l

//
// silly typedef because microsoft can't name things the same between NT and Win9x
//
typedef DDVIDEOPORTDATA            * PNVP_DDVIDEOPORTDATA;
typedef DDSKIPINFO                 * PNVP_DDSKIPNEXTFIELDINFO;
typedef DDBOBINFO                  * PNVP_DDBOBNEXTFIELDINFO;
typedef DDSTATEININFO              * PNVP_DDSETSTATEININFO;
typedef DDSTATEOUTINFO             * PNVP_DDSETSTATEOUTINFO;
typedef DDLOCKININFO               * PNVP_DDLOCKININFO;
typedef DDLOCKOUTINFO              * PNVP_DDLOCKOUTINFO;
typedef DDFLIPOVERLAYINFO          * PNVP_DDFLIPOVERLAYINFO;
typedef DDFLIPVIDEOPORTINFO        * PNVP_DDFLIPVIDEOPORTINFO;
typedef DDPOLARITYININFO           * PNVP_DDGETPOLARITYININFO;
typedef DDPOLARITYOUTINFO          * PNVP_DDGETPOLARITYOUTINFO;
typedef DDGETAUTOFLIPININFO        * PNVP_DDGETCURRENTAUTOFLIPININFO;
typedef DDGETAUTOFLIPOUTINFO       * PNVP_DDGETCURRENTAUTOFLIPOUTINFO;
typedef DDGETAUTOFLIPININFO        * PNVP_DDGETPREVIOUSAUTOFLIPININFO;
typedef DDGETAUTOFLIPOUTINFO       * PNVP_DDGETPREVIOUSAUTOFLIPOUTINFO;
typedef DDTRANSFERININFO           * PNVP_DDTRANSFERININFO;
typedef DDTRANSFEROUTINFO          * PNVP_DDTRANSFEROUTINFO;
typedef DDGETTRANSFERSTATUSOUTINFO * PNVP_DDGETTRANSFEROUTINFO;

typedef VOID (*PNVP_DX_IRQCALLBACK)(void);

#endif  /* _NVPEOS_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vdd\common\kmvtdisp.asm ===
page            ,132
title		Mini VDD Kernel Mode Video Transport (VPE ring 0) dispatch 
.386p
;
;
.xlist
include	VMM.INC
include	VMMREG.INC
include	VWIN32.INC
include 	MINIVDD.INC
include	DDKMMINI.INC
include  DEBUG.INC
include  SURFACES.INC
.list

extrn _vddGetIRQInfo:near
extrn _vddEnableIRQ:near
extrn _vddIsOurIRQ:near
extrn _vddFlipVideoPort:near
extrn _vddFlipOverlay:near
extrn _vddBobNextField:near
extrn _vddSetState:near
extrn _vddLock:near
extrn _vddSkipNextField:near
extrn _vddGetFieldPolarity:near
extrn _vddSetSkipPattern:near
extrn _vddGetCurrentAutoFlip:near
extrn _vddGetPreviousAutoFlip:near
;  these are the nvidia specific functions
extrn _vddgetStoragePointer:near
extrn _vddhandleBufferInterrupts:near
extrn _vddSetCallback:near
extrn _vddTransfer:near
extrn _vddGetTransferStatus:near
IFDEF   NV4_HW
extrn _vddSetVidTexSuf:near
ENDIF    ;NV4_HW

VxD_LOCKED_DATA_SEG
;
; Many of these functions are called at interrupt time
; So all data must be allocated in a locked (non-swappable) segment
;


;CODE
; until we have use for the context..... ignore
;extrn MMIOLinearAddrBase:dword
                   
VxD_LOCKED_DATA_ENDS

VxD_DATA_SEG
VxD_DATA_ENDS

VxD_LOCKED_CODE_SEG

;****************************************************************************
;
;   GetDDHAL
;
;   DESCRIPTION: This function fills in the function table supplied
;	by DDRAW with functions that their VxD can call fro kernel mode
;	DirectDraw support.  The MiniVDD can fill in the dwContext field
;	with a value that will always be passed back when called.
;
;   ENTRY:
;	   ESI  Ptr to DIOCParams
;		ESI+18h  Ptr to output buffer
;		ESI+1Ch  Size of output buffer
;		ESI+20h  Amount of data we write into output buffer
;
;   EXIT:
;          EAX	0 = success
;
;****************************************************************************

public  GetDDHAL
BeginProc GetDDHAL

	; get the size of the DDMINIVDDTABLE from the OutBuffer
	; compare with known size and error if there is a problem
	mov	ebx, [esi.DIOCParams.cbOutBuffer]
	cmp	ebx, SIZE _DDMINIVDDTABLE
	jl	GetDDHAL_Error

	; confirm that the input buffer has size of 4 bytes
	mov	ebx, [esi.DIOCParams.cbInBuffer]
	cmp	ebx, 4
	jl	GetDDHAL_Error


	; put address of output buffer in ebx
	mov	ebx, [esi.DIOCParams.lpvOutBuffer]

	;load context... and then the offset addresses of the various functions

	; load address of InBuffer
	mov   eax, [esi.DIOCParams.lpvInBuffer]
	; grab first U032 of InBuffer
	mov	eax,[eax]
	; store that as the context
	mov	[ebx._DDMINIVDDTABLE.dwMiniVDDContext], eax
	
	
	; load up the various function offsets
	mov	eax, OFFSET32 DDGetIRQInfo
	mov	[ebx._DDMINIVDDTABLE.vddGetIRQInfo], eax
	mov	eax, OFFSET32 DDIsOurIRQ
	mov	[ebx._DDMINIVDDTABLE.vddIsOurIRQ], eax
	mov	eax, OFFSET32 DDEnableIRQ
	mov	[ebx._DDMINIVDDTABLE.vddEnableIRQ], eax
	mov	eax, OFFSET32 DDSkipNextField
	mov	[ebx._DDMINIVDDTABLE.vddSkipNextField], eax
	mov	eax, OFFSET32 DDBobNextField
	mov	[ebx._DDMINIVDDTABLE.vddBobNextField], eax
	mov	eax, OFFSET32 DDSetState
	mov	[ebx._DDMINIVDDTABLE.vddSetState], eax
	mov	eax, OFFSET32 DDLock
	mov	[ebx._DDMINIVDDTABLE.vddLock], eax
	mov	eax, OFFSET32 DDFlipOverlay
	mov	[ebx._DDMINIVDDTABLE.vddFlipOverlay], eax
	mov	eax, OFFSET32 DDFlipVideoPort
	mov	[ebx._DDMINIVDDTABLE.vddFlipVideoPort], eax
	mov	eax, OFFSET32 DDGetFieldPolarity
	mov	[ebx._DDMINIVDDTABLE.vddGetPolarity], eax
	mov	eax, OFFSET32 DDSetSkipPattern
	mov	[ebx._DDMINIVDDTABLE.vddReserved1], eax
	mov	eax, OFFSET32 DDGetCurrentAutoflipSurface
	mov	[ebx._DDMINIVDDTABLE.vddGetCurrentAutoflip], eax
	
	mov	eax, OFFSET32 DDGetPreviousAutoflipSurface
	mov	[ebx._DDMINIVDDTABLE.vddGetPreviousAutoflip], eax
	
	mov	eax, OFFSET32 DDTransfer
	mov	[ebx._DDMINIVDDTABLE.vddTransfer], eax
	
	mov	eax, OFFSET32 DDGetTransferStatus
	mov	[ebx._DDMINIVDDTABLE.vddGetTransferStatus], eax
	
	mov	ebx, [esi.DIOCParams.lpcbBytesReturned]
	mov	eax, SIZE _DDMINIVDDTABLE
	mov	[ebx], eax

	Debug_Printf    "XXXXXXXXXXXXXXXXXXXXXX  Calling Fill the DD HAL table\n\r", eax, DEBLEVELMAX
        
; zero out the return value are return
	sub	eax, eax
	ret

GetDDHAL_Error:
;    this next one is probably left over from debugging
;    INT3
	mov	eax, 1
	ret
 
EndProc GetDDHAL

;****************************************************************************
;
;   NvFillTable
;
;   DESCRIPTION: This function will fill in a table with all of the Nvidia 
;   specific functions which allow us to work between ring3 and ring0 VPE stuff
;
;   ENTRY:
;	   ESI  Ptr to DIOCParams
;		ESI+18h  Ptr to output buffer
;		ESI+1Ch  Size of output buffer
;		ESI+20h  Amount of data we write into output buffer
;
;   EXIT:
;          EAX	0 = success
;
;****************************************************************************

public  NvFillTable
BeginProc NvFillTable

	; get the size of the NVVDDPROCTABLE from the OutBuffer
	; compare with known size and error if there is a problem
	
	mov	ebx, [esi.DIOCParams.cbOutBuffer]
	cmp	ebx, SIZE _NVVDDPROCTABLE
	jl	NvFillTable_Error

	; confirm that the input buffer has size of 4 bytes
	mov	ebx, [esi.DIOCParams.cbInBuffer]
	cmp	ebx, 4
	jl	NvFillTable_Error

	; put address of output buffer in ebx
	mov	ebx, [esi.DIOCParams.lpvOutBuffer]

	;load context... and then the offset addresses of the various functions

	; load address of InBuffer
	mov   eax, [esi.DIOCParams.lpvInBuffer]

	; grab first U032 of InBuffer  this is the pointer to the direct draw drivers
	mov	eax,[eax]

	; store that as the context
	mov	[ebx._NVVDDPROCTABLE.dwPDDDriver], eax
	
	
	; load up the various function offsets
	mov	eax, OFFSET32 VDhandleBufferInterrupts
	mov	[ebx._NVVDDPROCTABLE.handleBufferInterrupts], eax

	mov	eax, OFFSET32 VDgetStoragePointer
	mov	[ebx._NVVDDPROCTABLE.getStoragePointer], eax

; zero out the return value are return
	sub	eax, eax
	ret

NvFillTable_Error:
	mov	eax, 1
	ret
 

EndProc NvFillTable

;****************************************************************************
;
;   NVSetVidTexSuf
;
;   DESCRIPTION: This function records a pointer passed in from an APP.  Pointer points to some surface data
;
;   ENTRY:
;	   ESI  Ptr to DIOCParams
;		ESI+18h  Ptr to output buffer
;		ESI+1Ch  Size of output buffer
;		ESI+20h  Amount of data we write into output buffer
;
;   EXIT:
;          EAX	0 = success
;
;****************************************************************************

public  NVSetVidTexSuf
BeginProc NVSetVidTexSuf
	
	mov	ebx, [esi.DIOCParams.cbOutBuffer]
	cmp	ebx, 4
	jl	NVSetVidTexSuf_Error

	; confirm that the input buffer has size of 4 bytes
	mov	ebx, [esi.DIOCParams.cbInBuffer]
	cmp	ebx, 4
	jl	NVSetVidTexSuf_Error

	; put address of output buffer in ebx
	mov	ebx, [esi.DIOCParams.lpvOutBuffer]

	; load address of InBuffer
	mov   eax, [esi.DIOCParams.lpvInBuffer]

IFDEF   NV4_HW
    push    ebx		; preserve
    push    ecx		; preserve
    push    edx		; preserve	
    push    eax	; struct pointer
    push    ebx    ; vmm context
;    call    _vddSetVidTexSuf
    pop    ebx    ; vmm context
    pop    ebx    ; vmm context
    
	 pop     edx		; preserve
    pop     ecx		; preserve
    pop     ebx		; preserve

	; eax contain return value... no big deal we already filled output buffer
	 
; zero out the return value are return
	sub	eax, eax
	ret
ENDIF  ;  NV4_HW


NVSetVidTexSuf_Error:
	mov	eax, 1
	ret
 
EndProc NVSetVidTexSuf


;****************************************************************************
;
;   NVGetSetCallback
;
;   DESCRIPTION: This function fills in a record about callbacks
;
;   ENTRY:
;	   ESI  Ptr to DIOCParams
;		ESI+18h  Ptr to output buffer
;		ESI+1Ch  Size of output buffer
;		ESI+20h  Amount of data we write into output buffer
;
;   EXIT:
;          EAX	0 = success
;
;****************************************************************************

public  NVGetSetCallback
BeginProc NVGetSetCallback
	
	mov	ebx, [esi.DIOCParams.cbOutBuffer]
	cmp	ebx, 4
	jl	NvGetSetCallBack_Error

	; confirm that the input buffer has size of 4 bytes
	mov	ebx, [esi.DIOCParams.cbInBuffer]
	cmp	ebx, 4
	jl	NvGetSetCallBack_Error

	; put address of output buffer in ebx
	mov	ebx, [esi.DIOCParams.lpvOutBuffer]

	; load address of InBuffer
	mov   eax, [esi.DIOCParams.lpvInBuffer]

	mov	eax,  OFFSET32 _vddSetCallback
	mov	[ebx], eax

	; load address of InBuffer
	mov   eax, [esi.DIOCParams.lpvInBuffer]
    
	; eax contain return value... no big deal we already filled output buffer
	 
; zero out the return value are return
	sub	eax, eax
	ret

NvGetSetCallBack_Error:
	mov	eax, 1
	ret
 
EndProc NVGetSetCallback

public  NVSetCallback

BeginProc NVSetCallback
	
    call    _vddSetCallback
    ret

EndProc NVSetCallback

BeginProc VDhandleBufferInterrupts, RARE
    push    ebx		; preserve
    push    ecx		; preserve
    push    edx		; preserve	
    push    edi	; struct pointer
    push    esi	; struct pointer
    push    eax    ; vmm context
    call    _vddhandleBufferInterrupts
    pop     edi	; balance eax
    pop     esi	; struct pointer
    pop     edi	; struct pointer	
    pop     edx		; preserve
    pop     ecx		; preserve
    pop     ebx		; preserve
    ret

EndProc VDhandleBufferInterrupts

BeginProc VDgetStoragePointer, RARE
    push    ebx		; preserve
    push    ecx		; preserve
    push    edx		; preserve	
    push    edi	; struct pointer
    push    esi	; struct pointer
    push    eax    ; vmm context
    call    _vddgetStoragePointer
    pop     edi	; balance eax
    pop     esi	; struct pointer
    pop     edi	; struct pointer	
    pop     edx		; preserve
    pop     ecx		; preserve
    pop     ebx		; preserve
    ret

EndProc VDgetStoragePointer

;****************************************************************************
;
;   DDGetIRQInfo
;
;   DESCRIPTION: If the Mini VDD is already managing the IRQ, this
;          function returns that information; otherwise, it returns the
;          IRQ number assigned to the device so DDraw can manage the IRQ.
;
;          The returning the IRQ number, it is important that it get the
;          value assigned by the Config Manager rather than simply get
;          the value from the hardware (since it can be remapped by PCI).
;
;   ENTRY:
;	   ESI	NULL
;	   EDI  LPDDGETIRQINFO
;		    DWORD dwSize;
;		    DWORD dwFlags;
;		    DWORD dwIRQNum;
;
;   EXIT:
;          EAX	0 = success, 1 = error
;
;****************************************************************************
BeginProc DDGetIRQInfo, RARE
    push    ebx		; preserve
    push    ecx		; preserve
    push    edx		; preserve	
    push    edi	; struct pointer
    push    esi	; struct pointer
    push    eax    ; vmm context
    call    _vddGetIRQInfo
    pop     edi	; balance eax
    pop     esi	; struct pointer
    pop     edi	; struct pointer	
    pop     edx		; preserve
    pop     ecx		; preserve
    pop     ebx		; preserve
    ret

EndProc DDGetIRQInfo



;****************************************************************************
;
;   DDEnableIRQ
;
;   DESCRIPTION: Notifies the Mini VDD which IRQs should be enabled.  If
;          a previously enabled IRQ is not specified in this call,
;          it should be disabled.
;
;   ENTRY:
;	   ESI	LPDDENABLEIRQINFO
;		    DWORD dwSize
;		    DWORD dwIRQSources
;		    DWORD dwLine
;		    DWORD IRQCallback
;		    DWORD dwContext
;	   EDI  NULL
;
;   EXIT:
;          EAX	0 = success, 1 = error
;
;****************************************************************************
BeginProc DDEnableIRQ, RARE
    push    ebx		; preserve
    push    ecx		; preserve
    push    edx		; preserve	
    push    edi	; struct pointer
    push    esi	; struct pointer
    push    eax    ; vmm context
    call    _vddEnableIRQ
    pop     edi	; balance eax
    pop     esi	; struct pointer
    pop     edi	; struct pointer	
    pop     edx		; preserve
    pop     ecx		; preserve
    pop     ebx		; preserve
    ret

EndProc DDEnableIRQ

;****************************************************************************
;
;   DDIsOurIRQ
;
;   DESCRIPTION: Called when the VDD's IRQ handled is triggered.  This
;          determines if the IRQ was caused by our VGA and if so, it
;          clears the IRQ and returns which event(s) generated the IRQ.
;
;   ENTRY:
;	   ESI	NULL
;
;   EXIT:
;	   EDI  IRQ source flags
;          EAX	0 = success, 1 = error
;
;****************************************************************************
BeginProc DDIsOurIRQ, High_Freq
    push    ebx		; preserve
    push    ecx		; preserve
    push    edx		; preserve	
    push    edi	; struct pointer
    push    esi	; struct pointer
    push    eax    ; vmm context
    call    _vddIsOurIRQ
    pop     edi	; balance eax
    pop     esi	; struct pointer
    pop     edi	; struct pointer	
    pop     edx		; preserve
    pop     ecx		; preserve
    pop     ebx		; preserve
    ret

EndProc DDIsOurIRQ


;****************************************************************************
;
;   DDFlipVideoPort
;
;   DESCRIPTION: Flips the video port to the target surface.
;
;   ENTRY:
;	   ESI	LPDDFLIPVIDEOPORTINFO
;		    DWORD dwSize
;		    LPDDVIDEOPORTDATA video port info
;		    LPDDSURFACEDATA current surface
;		    LPDDSURFACEDATA target surface
;		    DWORD dwFlipVPFlags
;	   EDI  NULL
;
;   EXIT:
;          EAX	0 = success, 1 = error
;
;****************************************************************************

BeginProc DDFlipVideoPort, High_Freq
    push    ebx		; preserve
    push    ecx		; preserve
    push    edx		; preserve	
    push    edi	; struct pointer
    push    esi	; struct pointer
    push    eax    ; vmm context
    call    _vddFlipVideoPort
    pop     edi	; balance eax
    pop     esi	; struct pointer
    pop     edi	; struct pointer	
    pop     edx		; preserve
    pop     ecx		; preserve
    pop     ebx		; preserve
    ret

EndProc DDFlipVideoPort

;****************************************************************************
;
;   DDFlipOverlay
;
;   DESCRIPTION: Flips the overlay to the target surface.
;  
;   ENTRY:
;	   ESI	LPDDFLIPOVERLAYINFO
;		    DWORD dwSize
;		    LPDDSURFACEDATA current surface
;		    LPDDSURFACEDATA target surface
;		    DWORD flags
;	   EDI  NULL
;
;   EXIT:
;          EAX	0 = success, 1 = error
;
;****************************************************************************
BeginProc DDFlipOverlay, High_Freq
    push    ebx		; preserve
    push    ecx		; preserve
    push    edx		; preserve	
    push    edi	; dummy
    push    esi	; struct pointer
    push    eax    ; vmm context
    call    _vddFlipOverlay
    pop     edi	; balance eax
    pop     esi	; struct pointer
    pop     edi	; dummy	
    pop     edx		; preserve
    pop     ecx		; preserve
    pop     ebx		; preserve
    ret

EndProc DDFlipOverlay


;****************************************************************************
;
;   DDBobNextInterleavedEvenOverlayField
;
;   DESCRIPTION: Called when "bob" is used and a VPORT VSYNC occurs that does
;       not cause a flip to occur (e.g. bobbing while interleaved).  When
;       bobbing, the overlay must adjust itself on every VSYNC, so this
;       function notifies it of the VSYNCs that it doesn't already know
;       about (e.g. VSYNCs that trigger a flip to occur).
;
;   ENTRY:
;	   ESI	LPDDBOBINFO
;		    DWORD dwSize
;		    LPDDSURFACE lpSurface
;	   EDI  NULL
;
;   EXIT:
;          EAX	0 = success, 1 = error
;
;****************************************************************************
BeginProc DDBobNextField, High_Freq
    push    ebx		; preserve
    push    ecx		; preserve
    push    edx		; preserve	
    push    edi	; dummy
    push    esi	; struct pointer
    push    eax    ; vmm context
    call    _vddBobNextField
    pop     edi	; balance eax
    pop     esi	; struct pointer
    pop     edi	; dummy	
    pop     edx		; preserve
    pop     ecx		; preserve
    pop     ebx		; preserve
    ret

EndProc DDBobNextField


;****************************************************************************
;
;   DDSetState
;
;   DESCRIPTION: Called when the client wants to switch from bob to weave.
;	The overlay flags indicate which state to use. Only called for interleaved
;   surfaces.
;
;	NOTE: When this is called, the specified surface may not be
;	displaying the overlay (due to a flip).  Instead of failing
;	the call, change the bob/weave state for the overlay that would
;	be used if the overlay was flipped again to the specified surface.
;
;   ENTRY:
;	   ESI	LPDDSTATEININFO
;		    DWORD dwSize
;		    LPDDSURFACEDATA overlay surface
;	   EDI  LPDDSTATEOUTINFO
;		    DWORD dwSize
;		    DWORD dwSoftwareAutoflip
;		    DWORD dwSurfaceIndex        ; Return Current hardware autoflip
;
;
;   EXIT:
;          EAX	0 = success, 1 = error
;
;****************************************************************************
BeginProc DDSetState, High_Freq
    push    ebx		; preserve
    push    ecx		; preserve
    push    edx		; preserve	
    push    edi	; struct pointer
    push    esi	; struct pointer
    push    eax    ; vmm context
    call    _vddSetState
    pop     edi	; balance eax
    pop     esi	; struct pointer
    pop     edi	; struct pointer	
    pop     edx		; preserve
    pop     ecx		; preserve
    pop     ebx		; preserve
    ret

EndProc DDSetState


;****************************************************************************
;
;   DDLock
;
;   DESCRIPTION: Called when the client wants to lock the surface to
;	access the frame buffer. The driver doens't have to do anything,
;       but it can if it needs to.
;
;   ENTRY:
;	   ESI	LPDDLOCKININFO
;		    DWORD dwSize
;		    LPDDSURFACEDATA surface
;	   EDI  LPDDLOCKOUTINFO
;		    DWORD dwSize
;		    DWORD Pointer to a pointer to the surface
;
;   EXIT:
;          EAX	0 = success, 1 = error
;
;****************************************************************************

BeginProc DDLock, High_Freq
    push    ebx		; preserve
    push    ecx		; preserve
    push    edx		; preserve	
    push    edi	; struct pointer
    push    esi	; struct pointer
    push    eax    ; vmm context
    call    _vddLock
    pop     edi	; balance eax
    pop     esi	; struct pointer
    pop     edi	; struct pointer	
    pop     edx		; preserve
    pop     ecx		; preserve
    pop     ebx		; preserve
    ret

EndProc DDLock


;****************************************************************************
;
;   DDSkipNextVideoPortField
;
;   DESCRIPTION: Called when they want to skip the next field, usually
;       to undo a 3:2 pulldown but also for decreasing the frame rate.
;       The driver should not lose the VBI lines if dwVBIHeight contains
;       a valid value.
;
;   ENTRY:
;	   ESI	LPDDSKIPINFO
;		    DWORD dwSize
;		    LPDDVIDEOPORTDATA video port
;	   EDI  NULL
;
;   EXIT:
;          EAX	0 = success, 1 = error
;
;****************************************************************************
BeginProc DDSkipNextField, High_Freq
    push    ebx		; preserve
    push    ecx		; preserve
    push    edx		; preserve	
    push    edi	; struct pointer
    push    esi	; struct pointer
    push    eax    ; vmm context
    call    _vddSkipNextField
    pop     edi	; balance eax
    pop     esi	; struct pointer
    pop     edi	; struct pointer	
    pop     edx		; preserve
    pop     ecx		; preserve
    pop     ebx		; preserve
    ret

EndProc DDSkipNextField

;****************************************************************************
;
;   DDGetFieldPolarity
;
;   DESCRIPTION: Returns the polarity of the current field being written
;	to the specified video port.
;
;   ENTRY:
;	   ESI	LPDDPOLARITYININFO
;		    DWORD dwSize
;		    LPDDVIDEOPORTDATA
;	   EDI  LPDDPOLARITYOUTINFO
;		    DWORD dwSize
;		    DWORD bPolority (even field = TRUE, odd field = FALSE)
;
;   EXIT:
;          EAX	0 = success, 1 = error
;          ECX  0 = odd,     1 = even
;
;****************************************************************************

BeginProc DDGetFieldPolarity, High_Freq
    push    ebx		; preserve
    push    ecx		; preserve
    push    edx		; preserve	
    push    edi	; struct pointer
    push    esi	; struct pointer
    push    eax    ; vmm context
    call    _vddGetFieldPolarity
    pop     edi	; balance eax
    pop     esi	; struct pointer
    pop     edi	; struct pointer	
    pop     edx		; preserve
    pop     ecx		; preserve
    pop     ebx		; preserve
	 mov		ecx,eax	;  more the value to ECX
	 xor     eax,eax	;  zero out the return value since we always return sucess
	 ret

EndProc DDGetFieldPolarity

;****************************************************************************
;
;   DDSetSkipPattern
;
;   DESCRIPTION: Sets the skip pattern in hardware
;
;   ENTRY:
;	   ESI	LPDDSETSKIPINFO
;		    DWORD 		dwSize
;		    LPDDVIDEOPORTDATA	lpVideoPortData
;		    DWORD		dwPattern
;		    DWORD		dwPatternSize
;	   EDI  LPDDPOLARITYOUTINFO
;
;   EXIT:
;          EAX	0 = success, 1 = error
;
;****************************************************************************

BeginProc DDSetSkipPattern, High_Freq
    push    ebx		; preserve
    push    ecx		; preserve
    push    edx		; preserve	
    push    edi	; struct pointer
    push    esi	; struct pointer
    push    eax    ; vmm context
    call    _vddSetSkipPattern
    pop     edi	; balance eax
    pop     esi	; struct pointer
    pop     edi	; struct pointer	
    pop     edx		; preserve
    pop     ecx		; preserve
    pop     ebx		; preserve
    ret

EndProc DDSetSkipPattern



;****************************************************************************
;
;   DDGetCurrentAutoflipSurface
;
;   DESCRIPTION: Returns the current surface receiving data from the
;	video port while autoflipping is taking palce.  Only called when
;   hardware autoflipping.
;
;   ENTRY:
;	   ESI	LPDDGETAUTOFLIPINFO
;		    DWORD 		dwSize
;	   EDI	LPDDGETAUTOFLIPINFO
;		    DWORD 		dwSize
;		    DWORD		dwSurfaceIndex
;
;   EXIT:
;          EAX	0 = success, 1 = error
;
;****************************************************************************

BeginProc DDGetCurrentAutoflipSurface, High_Freq
    push    ebx		; preserve
    push    ecx		; preserve
    push    edx		; preserve	
    push    edi	; struct pointer
    push    esi	; struct pointer
    push    eax    ; vmm context
    call    _vddGetCurrentAutoflip
    pop     edi	; balance eax
    pop     esi	; struct pointer
    pop     edi	; struct pointer	
    pop     edx		; preserve
    pop     ecx		; preserve
    pop     ebx		; preserve
    ret

EndProc DDGetCurrentAutoflipSurface
;****************************************************************************
;
;   DDGetPreviousAutoflipSurface
;
;   DESCRIPTION: Returns the surface that received the data from the
;	previous field of video port while autoflipping is taking palce. Only
;   called for hardware autoflipping.
;
;   ENTRY:
;	   ESI	LPDDGETAUTOFLIPINFO
;		    DWORD 		dwSize
;	   EDI	LPDDGETAUTOFLIPINFO
;		    DWORD 		dwSize
;		    DWORD		dwSurfaceIndex
;
;   EXIT:
;          EAX	0 = success, 1 = error
;
;****************************************************************************

BeginProc DDGetPreviousAutoflipSurface, High_Freq
    push    ebx		; preserve
    push    ecx		; preserve
    push    edx		; preserve	
    push    edi	; struct pointer
    push    esi	; struct pointer
    push    eax    ; vmm context
    call    _vddGetPreviousAutoFlip
    pop     edi	; balance eax
    pop     esi	; struct pointer
    pop     edi	; struct pointer	
    pop     edx		; preserve
    pop     ecx		; preserve
    pop     ebx		; preserve
    ret

EndProc DDGetPreviousAutoflipSurface

;****************************************************************************
;
;   DDTransfer
;
;   DESCRIPTION: Returns the surface that received the data from the
;	previous field of video port while autoflipping is taking palce. Only
;   called for hardware autoflipping.
;
;   ENTRY:
;	   ESI	DDTRANSFERININFO
;
;	   EDI	DDTRANSFEROUTINFO
;
;   EXIT:
;          EAX	0 = success, 1 = error
;
;****************************************************************************

BeginProc DDTransfer, High_Freq
    push    ebx		; preserve
    push    ecx		; preserve
    push    edx		; preserve	
    push    edi	; struct pointer
    push    esi	; struct pointer
    push    eax    ; vmm context
    call    _vddTransfer
    pop     edi	; balance eax
    pop     esi	; struct pointer
    pop     edi	; struct pointer	
    pop     edx		; preserve
    pop     ecx		; preserve
    pop     ebx		; preserve
    ret

EndProc DDTransfer


;****************************************************************************
;
;   DDGetTransferStatus
;
;
;   ENTRY:
;	   ESI	DDGETTRANSFERSTATUSOUTINFO
;
;	   EDI  NULL
;
;   EXIT:
;          EAX	0 = success, 1 = error
;
;****************************************************************************

BeginProc DDGetTransferStatus, High_Freq
    push    ebx		; preserve
    push    ecx		; preserve
    push    edx		; preserve	
    push    edi	; struct pointer
    push    esi	; struct pointer
    push    eax    ; vmm context
    call    _vddGetTransferStatus
    pop     edi	; balance eax
    pop     esi	; struct pointer
    pop     edi	; struct pointer	
    pop     edx		; preserve
    pop     ecx		; preserve
    pop     ebx		; preserve
    ret

EndProc DDGetTransferStatus


public _vwin32SetWin32Event
public _vwin32ResetWin32Event
public _vwin32WaitSingleObject
public _vwin32TimeSliceSleep

BeginProc _vwin32SetWin32Event, CCALL, PUBLIC

ArgVar hEvent, DWORD

		EnterProc

    
    VMMCall Test_Sys_VM_Handle              ;is it the system VM?
    ; if not the system vm don't call this func
    jnz    NotGoingtoHappen
    
    ; 
		pushad
    
		mov		eax, [hEvent]

		VxDCall _VWIN32_SetWin32Event 

		popad

NotGoingtoHappen:
		LeaveProc
		return

EndProc _vwin32SetWin32Event


BeginProc _vwin32ResetWin32Event, CCALL, PUBLIC

ArgVar hEvent, DWORD

		EnterProc

		pushad
    
		; It already comes in EAX
        ;mov		eax, [hEvent]

		VxDCall _VWIN32_ResetWin32Event 

		popad

		LeaveProc
		return

EndProc _vwin32ResetWin32Event

BeginProc _vwin32WaitSingleObject, CCALL, PUBLIC

ArgVar hEvent, DWORD
ArgVar timeOut, DWORD
ArgVar dwFlag, DWORD

		EnterProc

		pushad
    
    mov		eax, [dwFlag]
    mov		edx, [timeOut]
    mov		ebx, [hEvent]

		VxDCall _VWIN32_WaitSingleObject 
    
    popad

		LeaveProc
		return

EndProc _vwin32WaitSingleObject

BeginProc _vwin32TimeSliceSleep, CCALL, PUBLIC

ArgVar dwTimeOut, DWORD

		EnterProc

		pushad
    
    mov		eax, [dwTimeOut]
    
		VMMCall Time_Slice_Sleep 
    
    popad

		LeaveProc
		return

EndProc _vwin32TimeSliceSleep


VxD_LOCKED_CODE_ENDS
end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vdd\common\nvpekmvt.c ===
/*----------------------------------------------------------------------------*/
/*
 * nvpekmvt.c
 *
 *      NVPE Kernel Mode Video Transport code for the miniVDD.  These functions 
 *      are called from kmvtdisp.asm.
 *
 */

/*----------------------------------------------------------------------------*/
/*
 * include files
 */

// MS includes
#include "windows.h"
#include "ddraw.h"
#include "ddrawi.h"
// #include "nvPusher.h"
#include "ddmini.h"
#include "dvp.h"
#include "dmemmgr.h"
#include "minivdd.h"
#include "ddkmmini.h"

// NV includes 
#include <nv32.h>
#include <nvtypes.h>
#include <nvmacros.h>
#include <nvwin32.h>
#include <nvos.h>
#include "nvrmr0api.h"
#include "nvpeos.h"

//
// prototypes
//
DWORD   SkipNextField   (PVOID, PNVP_DDSKIPNEXTFIELDINFO, PVOID);
DWORD   BobNextField    (PVOID, PNVP_DDBOBNEXTFIELDINFO, PVOID);
DWORD   SetState        (PVOID, PNVP_DDSETSTATEININFO, PNVP_DDSETSTATEOUTINFO);
DWORD   LockSurface     (PVOID, PNVP_DDLOCKININFO, PNVP_DDLOCKOUTINFO);
DWORD   FlipOverlay     (PVOID, PNVP_DDFLIPOVERLAYINFO, PVOID);
DWORD   FlipVideoPort   (PVOID, PNVP_DDFLIPVIDEOPORTINFO, PVOID);
DWORD   GetPolarity     (PVOID, PNVP_DDGETPOLARITYININFO, PNVP_DDGETPOLARITYOUTINFO);
DWORD   GetCurrentAutoflip(PVOID, PNVP_DDGETCURRENTAUTOFLIPININFO, PNVP_DDGETCURRENTAUTOFLIPOUTINFO);
DWORD   GetPreviousAutoflip(PVOID, PNVP_DDGETPREVIOUSAUTOFLIPININFO, PNVP_DDGETPREVIOUSAUTOFLIPOUTINFO);
DWORD   NVPTransfer     (PVOID, PNVP_DDTRANSFERININFO, PNVP_DDTRANSFEROUTINFO);
DWORD   NVPGetTransferStatus(PVOID, PVOID, PNVP_DDGETTRANSFEROUTINFO);

extern struct _HW_DEVICE_EXTENSION nvpeDevExtension;

/*
;   DESCRIPTION: If the Mini VDD is already managing the IRQ, this
;          function returns that information; otherwise, it returns the
;          IRQ number assigned to the device so DDraw can manage the IRQ.
;
;          The returning the IRQ number, it is important that it get the
;          value assigned by the Config Manager rather than simply get
;          the value from the hardware (since it can be remapped by PCI).
*/
U032 vddGetIRQInfo(
    U032 dwMiniVDDContext, 
    U032 dummy, 
    DDGETIRQINFO* pGetIrqInfo) 
{
    pGetIrqInfo->dwFlags = IRQINFO_HANDLED;
    return 0;
}

/*
;   DESCRIPTION: Called when the VDD's IRQ handled is triggered.  This
;          determines if the IRQ was caused by our VGA and if so, it
;          clears the IRQ and returns which event(s) generated the IRQ.
*/
U032 vddIsOurIRQ(
    U032 dwMiniVDDContext, 
    U032 dummy) 
{
    return 1;
}

U032 vddEnableIRQ(
    U032 dwMiniVDDContext, 
    DDENABLEIRQINFO* pEnableIrqInfo, 
    U032 dummy) 
{

    nvpeDevExtension.dwIRQSources = pEnableIrqInfo->dwIRQSources;
    nvpeDevExtension.IRQCallback = (PVOID) (pEnableIrqInfo->IRQCallback);
    nvpeDevExtension.dwIRQContext = pEnableIrqInfo->dwContext;

    return 0;
}

U032 vddSkipNextField(
    U032 dwMiniVDDContext, 
    DDSKIPINFO* pSkipInfo, 
    U032 dummy) 
{
    return SkipNextField(&nvpeDevExtension, pSkipInfo, NULL);
}


U032 vddBobNextField(
    U032 dwMiniVDDContext, 
    DDBOBINFO* pBobInfo, 
    U032 dummy) 
{
    return BobNextField(&nvpeDevExtension, pBobInfo, NULL);
}

U032 vddSetState(
    U032 dwMiniVDDContext, 
    DDSTATEININFO* pSetStateInfoIn, 
    DDSTATEOUTINFO* pSetStateInfoOut) 
{
    return SetState(&nvpeDevExtension, pSetStateInfoIn, pSetStateInfoOut);
}

U032 vddLock(
    U032 dwMiniVDDContext, 
    DDLOCKININFO* pLockInfoIn, 
    DDLOCKOUTINFO* pLockInfoOut) 
{
    return LockSurface(&nvpeDevExtension, pLockInfoIn, pLockInfoOut);
}

U032 vddFlipOverlay(
    U032 dwMiniVDDContext, 
    DDFLIPOVERLAYINFO* pFlipOverlayInfo, 
    U032 dummy) 
{
    return FlipOverlay(&nvpeDevExtension, pFlipOverlayInfo, NULL);
}

U032 vddFlipVideoPort(
    U032 dwMiniVDDContext, 
    U032* pFlipVideoPort, 
    U032 dummy) 
{
    return FlipVideoPort(&nvpeDevExtension, (PNVP_DDFLIPVIDEOPORTINFO) pFlipVideoPort, NULL);
}

U032 vddGetFieldPolarity(
    U032 dwMiniVDDContext, 
    DDPOLARITYININFO* pGetPolarityInInfo, 
    DDPOLARITYOUTINFO* pGetPolarityOutInfo) 
{
    return GetPolarity(&nvpeDevExtension, pGetPolarityInInfo, pGetPolarityOutInfo);
}

U032 vddSetSkipPattern(
    U032 dwMiniVDDContext, 
    DDSETSKIPINFO* pSetSkipInfo, 
    U032 dummy) 
{
	return 1;
}

U032 vddGetCurrentAutoFlip(
    U032 dwMiniVDDContext, 
    DDGETAUTOFLIPININFO* pGetAutoFlipInfoIn, 
    DDGETAUTOFLIPOUTINFO* pGetAutoFlipInfoOut) 
{
    return GetCurrentAutoflip(&nvpeDevExtension, pGetAutoFlipInfoIn, pGetAutoFlipInfoOut);
}

U032 vddGetPreviousAutoFlip(
    U032 dwMiniVDDContext, 
    DDGETAUTOFLIPININFO* pGetAutoFlipInfoIn, 
    DDGETAUTOFLIPOUTINFO* pGetAutoFlipInfoOut) 
{
    return GetPreviousAutoflip(&nvpeDevExtension, pGetAutoFlipInfoIn, pGetAutoFlipInfoOut);
}

U032 vddTransfer(
    U032 dwMiniVddContext, 
    DDTRANSFERININFO* pTransferInInfo, 
    DDTRANSFEROUTINFO* pTransferOutInfo ) 
{
    return NVPTransfer(&nvpeDevExtension, pTransferInInfo, pTransferOutInfo);
}

U032 vddGetTransferStatus(
    U032 dwMiniVddContext, 
    U032 dummy, 
    DDGETTRANSFERSTATUSOUTINFO* pGetTransStatusInfo ) 
{
    return NVPGetTransferStatus(&nvpeDevExtension, NULL, pGetTransStatusInfo);
} 


U032 kmvtNVPCallbackDxApi(void *pContext, U032 dwIRQSource)
{
    HW_DEVICE_EXTENSION *pHwDevCtx = (HW_DEVICE_EXTENSION *) pContext;
    U032 dwIRQContext;

    // can we pass on the interrupt !
    if (pHwDevCtx->IRQCallback)
    {
        dwIRQContext = (U032)(pHwDevCtx->dwIRQContext);
        _asm mov eax, dwIRQSource
        _asm mov ebx, dwIRQContext
        ((PNVP_DX_IRQCALLBACK)(pHwDevCtx->IRQCallback))();
    }
    
    return 0;
}

// A mechanism to populate the WDM prescale values
// This is a back door mechanism and should not really be in this module.
U032 vddWriteVPEPrescale(U032 ulX, U032 ulY, U032 ulCap, U032 ulVPNotUseOverlay, U032 ulFlag)
{
	PNVP_CONTEXT pVPEContext;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "nvpekmvt: vddWriteVPEPrescale()\n");

    // get a pointer to the appropriate VPE context (BUGBUG: use index 0 for now !!!)
    pVPEContext = &(nvpeDevExtension.avpContexts[0]);
	
	if(ulFlag & 0x8){
		pVPEContext->ulVPECapturePrescaleXFactor=ulX;
	}

	if(ulFlag & 0x4){
		pVPEContext->ulVPECapturePrescaleYFactor=ulY;
	}

	if(ulFlag & 0x2){
		pVPEContext->ulVPECaptureFlag=ulCap;
	}

	if(ulFlag & 0x1){
		pVPEContext->ulVPNotUseOverSurf=ulVPNotUseOverlay;
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vdd\common\nvpeos.inc ===
;
; nvpeos.inc
;
; Include file for miniVDD side of NVPE.
;

ifndef _NVPEVDD_INC
_NVPEVDD_INC   EQU     1

;
; IOCTL defines (must mirror ioctl defines in nvpeos.h
;
VDD_IOCTL_NVPE_COMMAND     EQU     300CAFE0H

endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vdd\common\texsurf.c ===
/***************************************************************************\
* Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.            *
* THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO       *
* NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY  *
* IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.                *
*                                                                           *
* Module: texsurf.c                                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       schaefer           11/16/98                                          *
*                                                                           *
\***************************************************************************/

#ifdef NV4_HW
#define NV4
#endif
#ifdef NV10_HW
#define NV4
#endif

// to make the references to channel data cool here in ring0
#define INVDDCODE



// MS includes
#include "windows.h"
#include "ddraw.h"
#include "Ddrawp.h"
#include "ddrawi.h"
// #include "nvPusher.h"
#include "ddmini.h"
#include "dvp.h"
#include "dmemmgr.h"
//  vdd specific MS includes
#include "minivdd.h"
#include "ddkmmini.h"
#include "nvos.h"

// NV includes
#include "nvwin32.h"
#include "nvhw.h"
#include <nv_ref.h>
#include "nvrmr0api.h"
#include "nvrmarch.inc"

#include "surfaces.h"
#include "VidTex.h"

// unit specific includes
#define RESMANSIDE

#define USERING0LIBRARY
#ifndef  USERING0LIBRARY
//
//
//
#include "nvkrmapi.c"

#endif //USERING0LIBRARY

extern  vpSurfaces 			MySurfaces;		
extern  NvNotification		nvMyVPNotifiers[NUMVPNOTIFIERS];


U032 vddSetVidTexSuf(U032 pInputPtr, U032 pOutputPtr ) {
	
	VidTexSurf* daPtr = (VidTexSurf*)pInputPtr;
	if(daPtr != NULL )
		//if(daPtr->frameBufferOffsetConv <  32*1024*1024 ) 
			if(daPtr->frameBufferOffsetSwiz <  32*1024*1024 ) 
			  if((daPtr->width <= 2048) && (daPtr->width > 0));
				if((daPtr->height <= 2048) && (daPtr->height > 0));
					if(daPtr->pitch <= 2048 )
						if(daPtr->format    ) {
							daPtr->dwFrameCount = 0;
							MySurfaces.pVidTexSurf = daPtr;
							(MySurfaces.pVidTexSurf)->bUpdateSystem = TRUE;
							return 0;
						}
	return 1;
}

void fillVidTexSurface(DWORD surface ) {
	Nv04ChannelPio* pMyNvChan = (Nv04ChannelPio*)MySurfaces.pVPChanPtr; 
	if(MySurfaces.pVidTexSurf == NULL ) {
		return;
	}
	// the pointer has been created.... start filling

	while (NvGetFreeCount(MySurfaces.pVPChanPtr, 4) < (17)*4)	 {
		NvRmR0Interrupt ((GLOBDATAPTR)->ROOTHANDLE, NV_WIN_DEVICE);	
	};
	// Allocate the intermediate buffer context DMA
	pMyNvChan->subchannel[4].nv04ContextSurfaceSwizzled.SetContextDmaImage = MY_IMAGE0_BUFFER_CONTEXT;
	pMyNvChan->subchannel[4].nv04ContextSurfaceSwizzled.SetFormat = (MySurfaces.pVidTexSurf)->format;
	pMyNvChan->subchannel[4].nv04ContextSurfaceSwizzled.SetOffset = (MySurfaces.pVidTexSurf)->frameBufferOffsetSwiz;
	
	pMyNvChan->subchannel[3].nv04ScaledImageFromMemory.SetContextDmaImage = MY_IMAGE0_BUFFER_CONTEXT;
	
	
	pMyNvChan->subchannel[3].nv04ScaledImageFromMemory.SetContextDmaImage = MY_IMAGE0_BUFFER_CONTEXT;
	pMyNvChan->subchannel[3].nv04ScaledImageFromMemory.SetColorFormat = NV077_SET_COLOR_FORMAT_LE_YB8V8YA8U8;
	pMyNvChan->subchannel[3].nv04ScaledImageFromMemory.ClipPoint = 0;
	
	pMyNvChan->subchannel[3].nv04ScaledImageFromMemory.ClipPoint = 0;
	pMyNvChan->subchannel[3].nv04ScaledImageFromMemory.ClipSize = 0xFFFFFFFF;		//mega big clip
	pMyNvChan->subchannel[3].nv04ScaledImageFromMemory.ImageOutPoint = 0;
	pMyNvChan->subchannel[3].nv04ScaledImageFromMemory.ImageOutSize = ((MySurfaces.pVidTexSurf)->height << 16) ||
																							(MySurfaces.pVidTexSurf)->width ;;
	pMyNvChan->subchannel[3].nv04ScaledImageFromMemory.DeltaDuDx = ((MySurfaces.Surfaces[surface]->dwWidth ) << 20 )/((MySurfaces.pVidTexSurf)->width);
	pMyNvChan->subchannel[3].nv04ScaledImageFromMemory.DeltaDvDy = ((MySurfaces.Surfaces[surface]->dwHeight ) << 20 )/((MySurfaces.pVidTexSurf)->height);
	
	pMyNvChan->subchannel[3].nv04ScaledImageFromMemory.ImageInSize = ((MySurfaces.Surfaces[surface]->dwHeight ) < 16 )  ||
																							((MySurfaces.Surfaces[surface]->dwWidth )   );
		
	pMyNvChan->subchannel[3].nv04ScaledImageFromMemory.ImageInFormat = (MySurfaces.Surfaces[surface]->dwWidth && 0x0FFFF) ||
																							( 1 << 24 );
	pMyNvChan->subchannel[3].nv04ScaledImageFromMemory.ImageInOffset = MySurfaces.Surfaces[surface]->dwOffset;
	pMyNvChan->subchannel[3].nv04ScaledImageFromMemory.ImageInPoint = 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vdd\common\timing.c ===
/***************************************************************************\
* Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.            *
* THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO       *
* NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY  *
* IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.                *
*                                                                           *
* Module: timing.c                                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       schaefer           9/23/98                                          *
*                                                                           *
\***************************************************************************/
#define RESMANSIDE
#define INVDDCODE

#ifdef NV4_HW
#define NV4
#endif
#ifdef NV10_HW
#define NV4
#endif

// MS includes
#include "windows.h"
#include "ddraw.h"
#include "Ddrawp.h"
#include "ddrawi.h"
// #include "nvPusher.h"
#include "ddmini.h"
#include "dvp.h"
#include "dmemmgr.h"
//  vdd specific MS includes
#include "minivdd.h"
#include "ddkmmini.h"

#include "vmm.h"

// NV includes
#include "nvwin32.h"
#include "nvhw.h"
#include <nv_ref.h>
#include "nvrmr0api.h"

// unit specific includes
#include "surfaces.h"
#include "vddsurfs.h"
#include "vpvdd.h"

#include "timing.h"

#ifndef DPF
#define  DPF(a) _Debug_Printf_Service(a)
#endif

extern vpSurfaces 			MySurfaces;

void InitTiming() {

	
}

U032 CheckExclude(TIMINGTYPES timingType) {
  // when this function returns TRUE then this timing mark is NOT recorded...

  switch (timingType) {
		case TRANSFERLAUNCH :
		case NOTIFYTRAN :
//		case NOTIFYIMG :
//		case OVFLIPREQ :
//  	case OVFLIPNOT :
		case TRANSFERRECRE :
		case TRANSBUFTYPE :
//		case OVERLAYFAIL :
		case PROGRAMVBI :
//		case PROGRAMIMG :
		case NOTIFYVBI :
		case CHECKCURBUF :
		case CHECKLASTBUF :
		case CHECKCURFLD :
		case ENTERCOLORCTL :
		case LEAVECOLORCTL :
		case WAITOCCCOLORCTL :
		case WAITCHROMAARRIVE :
		case WAITCHROMARETURN :
		case WAITLUMAARIVE :
		case WAITLUMARETURN :
        return 1;
  		default:		
  			break;
  }
  

  return 0;
}

//#define NOLOOPTIMING

void MarkTimingNot(TIMINGTYPES timingType,NvNotification*  pNot, U032 pSurf, U032 Indices) {

	U032 Time0;
	U032 Time1;
	U032 count;
	
  if (CheckExclude(timingType)) return;

	Time0 =	pNot->timeStamp.nanoseconds[0];
	Time1 =	pNot->timeStamp.nanoseconds[1];
			
	count = MySurfaces.Timings.LoopCount;
	MySurfaces.Timings.Time0[count] = Time0;
	MySurfaces.Timings.Time1[count] = Time1;
	MySurfaces.Timings.SurfDat[count] = timingType;
	MySurfaces.Timings.SurfIndex[count] = Indices;
	MySurfaces.Timings.SurfPtr[count] = pSurf;
	
	count++;
	if(count >= MAXDATASTORE ) {
#ifdef NOLOOPTIMING
		count = MAXDATASTORE-1;
#else 
		count = 0;
#endif
	}

	MySurfaces.Timings.LoopCount = count;

	return;
}
			

void	MarkTiming(TIMINGTYPES timingType,U032 pSurf, U032 Indices) {
	U032 Time0;
	U032 Time1;
	U032 count;
	
	if (CheckExclude(timingType)) return;

	if(MySurfaces.pNvTimer != NULL) {
		Time0 = *(MySurfaces.pNvTimer);
		Time1 = *((U032*)(((U032)(MySurfaces.pNvTimer))+0x10));
	} else {
		Time0 = 0;
		Time1 = 0;
	}
	
	count = MySurfaces.Timings.LoopCount;
	MySurfaces.Timings.Time0[count] = Time0;
	MySurfaces.Timings.Time1[count] = Time1;
	MySurfaces.Timings.SurfDat[count] = timingType;
	MySurfaces.Timings.SurfIndex[count] = Indices;
	MySurfaces.Timings.SurfPtr[count] = pSurf;
	
	count++;
	if(count >= MAXDATASTORE ) {
#ifdef NOLOOPTIMING
		count = MAXDATASTORE-1;
#else 
		count = 0;
#endif
	}

	MySurfaces.Timings.LoopCount = count;

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vdd\common\vpvdd.h ===
#ifndef _VP_VDD_H_
#define _VP_VDD_H_


U032	vddGetIRQInfo(U032 dwMiniVDDContext, U032 dummy, DDGETIRQINFO* pGetIrgInfo);
U032	vddIsOurIRQ(U032 dwMiniVDDContext, U032 dummy);
U032	vddEnableIRQ(U032 dwMiniVDDContext, DDENABLEIRQINFO* pEnableIrqInfo, U032 dummy);
U032	vddSkipNextField(U032 dwMiniVDDContext, DDSKIPINFO* pSkipInfo, U032 dummy);
U032	vddBobNextField(U032 dwMiniVDDContext, DDBOBINFO* pBobInfo, U032 dummy);
U032	vddSetState(U032 dwMiniVDDContext, DDSTATEININFO* pSetStateInfo, DDSTATEOUTINFO* pSetStateInfoOut);
U032	vddLock(U032 dwMiniVDDContext, DDLOCKININFO* pLockInfoIn, DDLOCKOUTINFO* pLockInfoOut);
U032	vddFlipOverlay(U032 dwMiniVDDContext, DDFLIPOVERLAYINFO* pFlipOverlayInfo, U032 dummy);


U032	vddGetFieldPolarity(U032 dwMiniVDDContext, DDPOLARITYININFO* pGetPolarityInInfo, DDPOLARITYOUTINFO* pGetPolarityOutInfo);



// for whatever reason the "real" definition won't work here so no big deal since we don't
// really USE this function, but it goes to show that MS headers are CRAP
//U032	vddFlipVideoPort(U032 dwMiniVDDContext, DDFLIPVIDEOPORT* pFlipVideoPort,U032 dummy);
U032	vddFlipVideoPort(U032 dwMiniVDDContext, U032* pFlipVideoPort, U032 dummy);


U032	vddSetSkipPattern(U032 dwMiniVDDContext, DDSETSKIPINFO* pSetSkipInfo, U032 dummy);
U032	vddGetCurrentAutoFlip(U032 dwMiniVDDContext, DDGETAUTOFLIPININFO* pGetAutoFlipInfoIn, DDGETAUTOFLIPOUTINFO* pGetAutoFlipInfoOut);
U032	vddGetPreviousAutoFlip(U032 dwMiniVDDContext, DDGETAUTOFLIPININFO* pGetAutoFlipInfoIn, DDGETAUTOFLIPOUTINFO* pGetAutoFlipInfoOut);


U032	vddTransfer(U032 dwMiniVddContext, DDTRANSFERININFO* pTransferInInfo, DDTRANSFEROUTINFO* pTransferOutInfo );

U032 vddGetTransferStatus(U032 dwMiniVddContext, U032 dummy, DDGETTRANSFERSTATUSOUTINFO* pGetTransStatusInfo );


#endif //_VP_VDD_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vdd\common\vddsurfs.h ===
/***************************************************************************\
* (C) Copyright NVIDIA Corporation Inc.,                                    *
*  1996,1997, 1998. All rights reserved.                                    *
* THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO       *
* NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY  *
* IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.                *
*                                                                           *
* Module: vddsurfs.h                                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       schaefer           8/21/98                                          *
*                                                                           *
\***************************************************************************/

#ifndef VDDSURFS_H
#define VDDSURFS_H

#define  MYCHECKFREECOUNT(a,b)								\
	ASSERT(b < NV06A_FIFO_GUARANTEED_SIZE );			\
	while (MySurfaces.myFreeCount < b)								\
		MySurfaces.myFreeCount = NvGetFreeCount(a, 0);			\
	MySurfaces.myFreeCount -= b;										


typedef VOID (*ACALLBACKTYPEPROC)(void);


U032 vddhandleBufferInterrupts(U032 dummy1, U032 dummy2, U032 dummy3);

U032 startSurfaces(U032	bInterleave, VPSTATE*	pVideoPortStatus );

U032 	scheduleFlipToSurface(DDSURFACEDATA* pCurSurf,FIELDTYPE	fieldType);

void Overlay0NotifyProc(void);
void Overlay1NotifyProc(void);

void    reportError(U032 interruptingBuffer,U032 oldSurface);


#define NV_VFM_FORMAT_CONTROL_FLIP_BY_MEDIAPORT_0 (0x04000000)
#define NV_VFM_FORMAT_CONTROL_FLIP_BY_MEDIAPORT_1 (0x02000000)
#define NV_VFM_FORMAT_BOBFROMINTERLEAVE           (0x08000000)

#endif // VDDSURFS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vdd\common\vddVP.c ===
/***************************************************************************\
* (C) Copyright NVIDIA Corporation Inc.,                                    *
*  1996,1997, 1998. All rights reserved.                                    *
* THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO       *
* NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY  *
* IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.                *
*                                                                           *
* Module: vddsurfs.c                                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       schaefer           5/22/98                                          *
*                                                                           *
\***************************************************************************/

#define RESMANSIDE
#define INVDDCODE

#ifdef NV4_HW
#define NV4
#endif
#ifdef NV10_HW
#define NV4
#endif

#include "windows.h"
#include "ddraw.h"
#include "Ddrawp.h"
#include "ddrawi.h"
// #include "nvPusher.h"
#include "ddmini.h"
#include "dvp.h"
#include "dmemmgr.h"
//  vdd specific MS includes
#include "minivdd.h"
#include "ddkmmini.h"

#include "vmm.h"

// NV includes
#include "nvwin32.h"
#include "nvhw.h"
#include <nv_ref.h>
#include "nvrmr0api.h"

#include "nvddobj.h"

// This is here because it is defined in nvrmarch.inc. We can't include that file here.
#define NV_WIN_DEVICE                            0x00002002

// unit specific includes
#include "surfaces.h"
#include "vddsurfs.h"
#include "VPcallbk.h"

#ifdef NV4
#include "VidTex.h"
#endif

//#define  DPF(a)    /* a */
#ifndef DPF

#if 1
#define  DPF(a) _Debug_Printf_Service(a)
#else
#define START_STR  ("VDDSURF - ")
#define END_STR ("\n")

void __cdecl DPF(LPSTR szFormat, ...)
{
    char str[256];

    lstrcpy(str, START_STR);
    wvsprintf(str+lstrlen(str), szFormat, (LPVOID)(&szFormat+1));
    lstrcat(str, END_STR);
    OutputDebugString(str);
}
#endif  // if 1
#endif  // #ifndef DPF
//  things needing entry points
//        ProgramBufferWithSurface

#ifdef ASSERT
#undef ASSERT

#if 0
#define ASSERT(a)  NULL;
#else


#ifndef NV06A_FIFO_GUARANTEED_SIZE
#define NV06A_FIFO_GUARANTEED_SIZE  (NV_GUARANTEED_FIFO_SIZE)
#endif

#define ASSERT(a,b)   \
    if(a) {         \
    } else {        \
        DPF(b);   \
    }                
    
#endif  // 1

#endif  // ASSERT


#define NV3FBLIMIT  (0x3E8000)
void AssertFail(void) {
    DPF("AssertFail\n");
}

vpSurfaces             MySurfaces;
NvNotification        nvMyVPNotifiers[NUMVPNOTIFIERS];


FIELDTYPE    getFieldFromBuffer(U032 dwBuffIndex) {
    U032 daField;
    
    switch (MySurfaces.CurrentCaptureMode) {
            case EVENODD:
              if(dwBuffIndex == 0 ) {
                  daField = ODD;
                } else if(dwBuffIndex == 1 ) {
                  daField = EVEN;
                } else {
                  daField = UNKNOWN;
                }
                break;
            case EVENEVEN:
                daField = EVEN;
                break;
            case ODDODD:
                daField = ODD;
                break;
            default:
                ASSERT(MySurfaces.CurrentCaptureMode == ODDODD,"unknown field ASSERT failed\n" );
                daField = ODD;
    }
  return daField;
}
               
FIELDTYPE    getNextFieldType(FIELDTYPE lastFieldType,U032 dwBuffIndex) {

    switch (MySurfaces.CurrentCaptureMode) {
            case EVENODD:
// this is a fix which _SHOULD_ be benign for nv4 ( need to check it )
// but which protects us from NV10 behavior where field captures can start
// in the middle which can then set us into toxic behavior
// in which the buffer capture order is 0,0,1,1,0,0. and there are weird latency
// problems
#if 0

                if(lastFieldType ==EVEN ) {
                    return ODD;
                } else if( lastFieldType ==ODD ) {
                    return EVEN;
                } else {
                    return EVEN;
                }
                break;
#else
                if (dwBuffIndex == 0 ) {
                    return ODD;
                } else {
                    return EVEN;
                }
                break;
#endif
            case EVENEVEN:
                if(lastFieldType ==EVEN ) {
                    return EVEN;
                } else {
                    return EVEN;
                }    
                break;
            case ODDODD:
                if(lastFieldType ==ODD ) {
                    return ODD;
                } else {
                    return ODD;
                }    
                break;
            default:
                ASSERT(MySurfaces.CurrentCaptureMode == ODDODD,"unknown field ASSERT failed\n" );
                return ODD;
    }
}

U032  getSurfaceIndex(U032 pSurf ) {
    U032 i;
    // check for exact match
    for(i=0;i<MySurfaces.numberOfSurfaces;i++) {
        if((U032)(MySurfaces.Surfaces[i]->pVidMem) == ((U032) pSurf)) {
            return i;
        }
    }
    // check for something "within"
    for(i=0;i<MySurfaces.numberOfSurfaces;i++) {
        if( ((U032)(MySurfaces.Surfaces[i]->pVidMem) <= ((U032) pSurf))  &&
             ((U032)(MySurfaces.Surfaces[i]->pVidMem)+MySurfaces.Surfaces[i]->dwLength >= ((U032) pSurf)  )) {
                    return i;
        }
    }
    
    return 99;
}


U032    notifyIndexFromBuffer(U032 dwBuffer) {
    switch (dwBuffer) {
            case 0:
                return NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0);
                break;
            case 1:
                return NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1);
                break;
            case 2:
                return NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(0);
                break;
            case 3:
                return NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(1);
                break;
            default:
                {
                    DPF ("   Problem... trying get an index for an unknown buffer notify\n");
                    return UNKNOWNBUF;
                }
    }
}


U032    getNextSurface(U032 currentSurface, U032 bSingleAdvance) {
    U032    nextSurface;
    
    ASSERT(currentSurface < MAXVPSURFACES,"current surface to big ASSERT failed\n" );
    
    //Generally you are going to want to jump two surfaces ahead of the one you are on, but 
    // with a wrap around depending on what typeof surface you are
    // interleaved surface should only move ahead ONE buffer since both DMA engines are pointing
    // to the same surface
    if( currentSurface < MySurfaces.VBIstart ) {
        // we are an ImageSurface
        if(MySurfaces.CurrentScanMode == INTERLEAVBUF ) {
            if(bSingleAdvance) {
                // hopefully we don't get here....  this means our drop frame strategy for interelaved buffers is notworking
            }
            nextSurface = currentSurface + 1;
        } else {    
            if(bSingleAdvance) {
                nextSurface = currentSurface + 1;
            } else {
                nextSurface = currentSurface + 2;
            }
        }
        while(nextSurface >= MySurfaces.VBIstart) 
            nextSurface = nextSurface - MySurfaces.VBIstart;    
    } else {
        U032    temp;
        //we are a VBI surface
        nextSurface = currentSurface + 2 - MySurfaces.VBIstart;
        temp = MySurfaces.numberOfSurfaces - MySurfaces.VBIstart;
        while(nextSurface >= temp) 
            nextSurface = nextSurface - temp;
        nextSurface = nextSurface + MySurfaces.VBIstart;
    }
    return nextSurface;
}


U032    getPrevSurface(U032 currentSurface) {
    long    nextSurface;
    
    ASSERT(currentSurface < MAXVPSURFACES ,"current Surface to big ASSERT FAILED\n");
    
    //Generally you are going to want to jump two surfaces ahead of the one you are on, but 
    // with a wrap around depending on what typeof surface you are
    // interleaved surface should only move ahead ONE buffer since both DMA engines are pointing
    // to the same surface
    if( currentSurface < MySurfaces.VBIstart ) {
        // we are an ImageSurface
        if(MySurfaces.CurrentScanMode == INTERLEAVBUF ) {
            nextSurface = currentSurface - 1;
        } else {    
            nextSurface = currentSurface - 2;
        }
        while(nextSurface < 0) 
            nextSurface = nextSurface + MySurfaces.VBIstart;    
    } else {
        long    numVBI;
        //we are a VBI surface - never interleaved.. always subtract 2
        nextSurface = currentSurface - 2 - MySurfaces.VBIstart;
        numVBI = MySurfaces.numberOfSurfaces - MySurfaces.VBIstart;
        while(nextSurface < 0) 
            nextSurface = nextSurface + numVBI;
        nextSurface = nextSurface + MySurfaces.VBIstart;
    }
    return nextSurface;
}


U032    getPrevOverlaySurface(U032 currentSurface) {
    long    nextSurface;
    
    ASSERT(currentSurface < MAXVPSURFACES ,"ASSERT FAILED\n");
    
    //Generally you are going to want to jump two surfaces ahead of the one you are on, but 
    // with a wrap around depending on what typeof surface you are
    // interleaved surface should only move ahead ONE buffer since both DMA engines are pointing
    // to the same surface
    if( currentSurface < MySurfaces.VBIstart ) {
        // we are an ImageSurface
        nextSurface = currentSurface - 1;
        while(nextSurface < 0) 
            nextSurface = nextSurface + MySurfaces.VBIstart;    
    } else {
        ASSERT(1==0,"we should never try to flip the overlay on a VBI surface you numskull\n");
        DPF("we should never try to flip the overlay on a VBI surface you numskull\n");
    }
    return nextSurface;
}



BOOLEAN checkScalingOk(U032 in, U032 out ) {
    U032 xIn,yIn,xOut,yOut;
    U032    xRatio;
    /*  Scaling works like this... the output MUST be smaller than the input, and the X ratio must be an integer value
         there is no limit on the Y ratio since it's just a line dropping system
    */
    
    xIn  = in & 0xFFFF;
    yIn  = in >> 16;
    xOut = out & 0xFFFF;
    yOut = out >> 16;
    
    if( xOut <= 0 ) {
        return FALSE;
    }
    
    if( xIn < xOut ) {
        //DPF ("   In dimension X is SMALLER than out X dimension %d, %d",xIn,xOut);
        return FALSE;
    }
    if( yIn < yOut ) {
        //DPF ("   In dimension Y is SMALLER than out Y dimension %d, %d",xIn,xOut);
        return FALSE;
    }
    if( xIn % xOut != 0 ) {
        //DPF ("   X dimension In does not evenly divide by X out %d, %d",xIn,xOut);
        return FALSE;
    }    
    xRatio = xIn / xOut;
    
    switch (xRatio) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 6:
            case 8:
            case 12:
            case 16:
            case 24:
                break;
            default:
                {
                    //DPF ("   Not one of the good scale factors %d, %d, %d",xIn,xOut,xRatio);
                    return FALSE;
                }            
                break;
    }
    
    
    return TRUE;
}



U032    ProgramBufferWithSurface(U032    dwBufferIndex,U032    newSurfaceIndex, U032 bZeroLength) {
    // This function is responsible for programming up and then launching buffer/surface combination
    // This will finish Asyncronously, and either be relaunched in the case of auto-flip, or be able 
    // to report back usefully with the VPE functions
    U032    nextField;
    U032  nextVBIField;
    U032    dwInterleaveAddition;
    vpSurfaceInfo*        pSurface;
    NvChannel*    pMyNvChan = MySurfaces.pVPChanPtr;
    
    pSurface = MySurfaces.Surfaces[newSurfaceIndex];
    
        
    MySurfaces.myFreeCount = NvGetFreeCount(pMyNvChan, 0);
    
    ASSERT(dwBufferIndex < 4 ,"ASSERT FAILED\n");
    ASSERT(newSurfaceIndex < MAXVPSURFACES ,"ASSERT FAILED\n");
    //Update the surface structures
        // notify
    
    MySurfaces.Surfaces[newSurfaceIndex]->pNvNotify = &(nvMyVPNotifiers[notifyIndexFromBuffer(dwBufferIndex)]);
    MySurfaces.CurrentBufferSurface[dwBufferIndex] = newSurfaceIndex;    
    
    // Figure out the whole field thing
    if( dwBufferIndex < 2 ) {
        // this is image
        nextField = getNextFieldType(MySurfaces.lastField, dwBufferIndex);
        MySurfaces.Surfaces[newSurfaceIndex]->field = nextField;
        MySurfaces.lastField = nextField;

        // if we're interleaving AND we're on the EVEN field then move everything down a bit
        //   OOD field is on top
        if(( MySurfaces.CurrentScanMode == INTERLEAVBUF) && (nextField == EVEN ) ) {
            dwInterleaveAddition = MySurfaces.Surfaces[newSurfaceIndex]->dwPitch/2;
        } else {
            dwInterleaveAddition = 0;
        }

        MySurfaces.curImageSurf = newSurfaceIndex;
    } else {
        // this is VBI
        nextVBIField = getNextFieldType(MySurfaces.lastField,dwBufferIndex-2);
        MySurfaces.Surfaces[newSurfaceIndex]->field = nextVBIField;
        MySurfaces.lastVBIField = nextVBIField;
        MySurfaces.curVBISurf = newSurfaceIndex;
    }
    
    MySurfaces.curSurf = newSurfaceIndex;
    
    // choose which type of surface this is

        // Put decoder object into the channel
        

    ASSERT(2*4 < NV06A_FIFO_GUARANTEED_SIZE ,"ASSERT FAILED\n");            
               
    while (MySurfaces.myFreeCount < 2*4) {
        NvRmR0Interrupt ((GLOBDATAPTR)->ROOTHANDLE, NV_WIN_DEVICE);                            
        MySurfaces.myFreeCount = NvGetFreeCount(pMyNvChan, 0);
    }            
    MySurfaces.myFreeCount -= 2*4;                                        

        

    pMyNvChan->subchannel[0].SetObject = MY_EXTERNAL_DECODER_OBJECT;

        // these lines end up being the Y-Crop value.
        // therefore they're the deviding line between VBI and Image
    
        // check if VBI is running
    if(MySurfaces.VBIstart < MySurfaces.numberOfSurfaces ) {
        if( dwBufferIndex >= 2 ) {
        // VBI is running
            pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetImageStartLine = 
                (MySurfaces.Surfaces[newSurfaceIndex]->dwHeight) +
                (MySurfaces.Surfaces[newSurfaceIndex]->dwStartLine) + 2;
        }
    } else {
        if( dwBufferIndex < 2) {
            pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetImageStartLine = 
                MySurfaces.Surfaces[newSurfaceIndex]->dwStartLine;
        }
    }

    if( dwBufferIndex <2 ) {
        

        // Image surface
         // setup the field polarity, offset and fire it off

        // if prescale is not on 2:1 integer boundaries from output, then fail...
        {
            BOOL bScale = checkScalingOk((MySurfaces.Surfaces[newSurfaceIndex]->dwWidth) | 
                                                    (MySurfaces.Surfaces[newSurfaceIndex]->dwHeight << 16)
                            ,MySurfaces.Surfaces[newSurfaceIndex]->dwPreScaleSize);
            
            if(! bScale ) {
                DPF("   Invalid Scaling parameters in use...\n");
    
                return (-7);        
            }
        }
        

        ASSERT(5*4 < NV06A_FIFO_GUARANTEED_SIZE ,"ASSERT FAILED\n");            

        while (MySurfaces.myFreeCount < 5*4) {
            NvRmR0Interrupt ((GLOBDATAPTR)->ROOTHANDLE, NV_WIN_DEVICE);                            
            MySurfaces.myFreeCount = NvGetFreeCount(pMyNvChan, 0);
        }            
        MySurfaces.myFreeCount -= 5*4;                                        
        if( bZeroLength) {
          MarkTiming(PROGRAMIMG,MySurfaces.Surfaces[newSurfaceIndex]->pVidMem, makeInd2(0,INCNOTAP,dwBufferIndex,newSurfaceIndex,( ( nextField == ODD ) ? 0 : 1)));
        } else {
          MarkTiming(PROGRAMIMG,MySurfaces.Surfaces[newSurfaceIndex]->pVidMem, makeInd2(0 | 0x80,INCNOTAP,dwBufferIndex,newSurfaceIndex,( ( nextField == ODD ) ? 0 : 1)));
        }

        pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetImage[dwBufferIndex].sizeIn =
            (MySurfaces.dwInWidth) | (MySurfaces.dwInHeight << 16);
        if( bZeroLength ) {
            pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetImage[dwBufferIndex].sizeOut = 0;
        } else {
            pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetImage[dwBufferIndex].sizeOut = 
                MySurfaces.Surfaces[newSurfaceIndex]->dwPreScaleSize;        
        }
        
        pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetImage[dwBufferIndex].offset    =
                MySurfaces.Surfaces[newSurfaceIndex]->dwOffset + dwInterleaveAddition;
        // There is some sly behavior in the field statement...
        // since progressive fields are expected to be delivered in the EVEN fields we only check for ODD
        // and then everything else is considered to be even
        nvMyVPNotifiers[notifyIndexFromBuffer(dwBufferIndex)].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
        pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetImage[dwBufferIndex].format =        
                ( MySurfaces.Surfaces[newSurfaceIndex]->dwPitch & 0xFFFF )  |
                ((( ( nextField == ODD ) ? NV04D_SET_IMAGE_FORMAT_FIELD_ODD_FIELD : NV04D_SET_IMAGE_FORMAT_FIELD_EVEN_FIELD) << 16 ) & 0xFF0000 )  |
                ((NV_OS_WRITE_THEN_AWAKEN << 24 ) & 0xFF000000 ) ;
           

        
        
                
    } else {
        //MYCHECKFREECOUNT(pMyNvChan,4*4);
        

        ASSERT(4*4 < NV06A_FIFO_GUARANTEED_SIZE,"ASSERT FAILED\n" );            

        while (MySurfaces.myFreeCount < 4*4) {
            NvRmR0Interrupt ((GLOBDATAPTR)->ROOTHANDLE, NV_WIN_DEVICE);                            
            MySurfaces.myFreeCount = NvGetFreeCount(pMyNvChan, 0);
        }            
        MySurfaces.myFreeCount -= 4*4;                                        
        MarkTiming(PROGRAMVBI,MySurfaces.Surfaces[newSurfaceIndex]->pVidMem, makeInd(dwBufferIndex,newSurfaceIndex,INCNOTAP,INCNOTAP));

        // these lines end up being the Y-Crop value.
        // therefore they're the deviding line between VBI and Image
        
        

        // VBI surface    
        pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetVbi[dwBufferIndex-2].size    =
            ((MySurfaces.Surfaces[newSurfaceIndex]->dwHeight+1) << 16) | (MySurfaces.Surfaces[newSurfaceIndex]->dwStartLine) ;
        
        pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetVbi[dwBufferIndex-2].offset    =
            MySurfaces.Surfaces[newSurfaceIndex]->dwOffset;
        
        nvMyVPNotifiers[notifyIndexFromBuffer(dwBufferIndex)].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
        pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetVbi[dwBufferIndex-2].format =        
            ( MySurfaces.Surfaces[newSurfaceIndex]->dwPitch & 0xFFFF )  |
            ((( ( nextVBIField == ODD ) ? NV04D_SET_IMAGE_FORMAT_FIELD_ODD_FIELD : NV04D_SET_IMAGE_FORMAT_FIELD_EVEN_FIELD) << 16 ) & 0xFF0000 )  |
            ((NV_OS_WRITE_THEN_AWAKEN << 24 ) & 0xFF000000 ) ;

    }
    //Update the Capture Class
    // hopefully make sure stuff REALLY get to the registers
    NvRmR0Interrupt ((GLOBDATAPTR)->ROOTHANDLE, NV_WIN_DEVICE);                            
    
    return 0;
}

    
void CheckAndDoCallbacks(U032        interruptingBuffer, U032 oldsurface){
    U032 newSurface = getNextSurface(oldsurface,FALSE);
    
    if(interruptingBuffer < 2) {
        if(MySurfaces.ImageCallbackRoutine != NULL ) {
            if( MySurfaces.Surfaces[oldsurface]->field == EVEN )
                MySurfaces.myIMGCallbackInfo.dwFlags = USINGFLAGS | IMAGESURFACE | BUFFADRLIN | EVENFIELD;
            else
                MySurfaces.myIMGCallbackInfo.dwFlags = USINGFLAGS | IMAGESURFACE | BUFFADRLIN | ODDFIELD;

            MySurfaces.myIMGCallbackInfo.lastBufferAddr = MySurfaces.Surfaces[oldsurface]->pVidMem;    // address of just finished buffer ( the one the client should unload )
            MySurfaces.myIMGCallbackInfo.curBufferAddr = MySurfaces.Surfaces[newSurface]->pVidMem;    // address of current input buffer ( one that is now being written to by MP )
            MySurfaces.myIMGCallbackInfo.intCount++;
        
            MySurfaces.ImageCallbackRoutine(&MySurfaces.myIMGCallbackInfo);
        }
    } else {
        if(MySurfaces.VBICallbackRoutine != NULL ) {
            if( MySurfaces.Surfaces[oldsurface]->field == EVEN )
                MySurfaces.myVBICallbackInfo.dwFlags = USINGFLAGS | VBISURFACE | BUFFADRLIN | EVENFIELD;
            else
                MySurfaces.myVBICallbackInfo.dwFlags = USINGFLAGS | VBISURFACE | BUFFADRLIN | ODDFIELD;
            
            MySurfaces.myVBICallbackInfo.lastBufferAddr = MySurfaces.Surfaces[oldsurface]->pVidMem;;    // address of just finished buffer ( the one the client should unload )
            MySurfaces.myVBICallbackInfo.curBufferAddr = MySurfaces.Surfaces[newSurface]->pVidMem;    // address of current input buffer ( one that is now being written to by MP )
            MySurfaces.myVBICallbackInfo.intCount++;
            MySurfaces.VBICallbackRoutine(&MySurfaces.myVBICallbackInfo);
        }
    }
}



U032 startSurfaces(U032    bInterleave, VPSTATE*    pVideoPortStatus ) {
    U032    rValue = DD_OK;
    VPSTATE    myState = *pVideoPortStatus;
    // figure out which buffers to program up and launch them...

    // zero out the last overlay scaler size so we're sure it gets reprogrammed
    MySurfaces.bThreadRunning = TRUE;
            
    MySurfaces.DropSystem.dwTargetSurface = 0;
    MySurfaces.DropSystem.dwbIsBobFromInterleave = 0;
    MySurfaces.DropSystem.dwFieldType = 0;
    MySurfaces.DropSystem.dwFullBool = 0;
    MySurfaces.DropSystem.dwDropFields = 0;

    if(MySurfaces.bInvertedFields ) {    
        MySurfaces.lastVBIField = ODD;
        MySurfaces.lastField = ODD;    // this should be even so we'll always start on odd ( hopefully... :-)
    } else { 
        MySurfaces.lastField = EVEN;
        MySurfaces.lastVBIField = EVEN;
    }
    MySurfaces.lastsrcDeltaY = 0;
    MySurfaces.bStopVP = FALSE;    

    // start first vbi
    if( (MySurfaces.numberOfSurfaces - MySurfaces.VBIstart) > 0 ) {
        if( ProgramBufferWithSurface(2,MySurfaces.VBIstart,FALSE))
                rValue = DDERR_INVALIDPARAMS;
        myState |= VP_VBI_CAPTURING;
    }
    
    //start first image
    if( (MySurfaces.VBIstart > 0 ) ) {
        // there is at last one image surface
        if( ProgramBufferWithSurface(0,0,FALSE) )
                rValue = DDERR_INVALIDPARAMS;
            myState |= VP_IMAGE_CAPTURING;
    }
    // start second VBI
    if( (MySurfaces.numberOfSurfaces - MySurfaces.VBIstart) > 0 ) {
    
        // now check to see if we have another surface
        if( (MySurfaces.numberOfSurfaces - MySurfaces.VBIstart) > 1 ) {
            if( ProgramBufferWithSurface(3,MySurfaces.VBIstart+1,FALSE))
                    rValue = DDERR_INVALIDPARAMS;
        } else {
            // set second buffer to first surface
            if( ProgramBufferWithSurface(3,MySurfaces.VBIstart+0,FALSE))
                    rValue = DDERR_INVALIDPARAMS;
        }
    }    
    // start second image
    if( (MySurfaces.VBIstart > 0 ) ) {
        
        if( bInterleave) {
            // since this is interleave always start the second buffer with the first surface
            if( ProgramBufferWithSurface(1,0,FALSE) )
                rValue = DDERR_INVALIDPARAMS;
            myState |= VP_IMAGE_CAPTURING;
        } else {    
            if( MySurfaces.CurrentCaptureMode == EVENODD ) {
              // if we're odd/even and not interleaved then we're seperate bob, which is where the
              // potential problem occurs
              MySurfaces.bFirstTime = TRUE;
            }
            // check for another surface
            if( MySurfaces.VBIstart > 1 ) {
                if( ProgramBufferWithSurface(1,1,FALSE) )
                    rValue = DDERR_INVALIDPARAMS;
            } else {
                // fire up the second buffer at the first surface
                DPF("this is kinda odd, only one surface, but also non-interleaved...");
                if( ProgramBufferWithSurface(1,0,FALSE) )
                    rValue = DDERR_INVALIDPARAMS;
            }
        }
    }
                    
    *pVideoPortStatus = myState;
    
    return rValue;
}



#define NV04D_NOTIFICATION_INFO16_FIELD_VALID_OFFSET               (0x0001)


BOOL GetField(void) {
    BOOL    retvalue = TRUE;
    U032    whiletime = 0;
    FIELDTYPE aField = UNKNOWN;
    NvChannel*    pMyNvChan = MySurfaces.pVPChanPtr;
        
    // we're not hitting the channel
    //INIT_FREE_COUNT(0);

    

    ASSERT(3*4 < NV06A_FIFO_GUARANTEED_SIZE,"ASSERT FAILED\n" );            

    while (MySurfaces.myFreeCount < 3*4)    {    
        NvRmR0Interrupt ((GLOBDATAPTR)->ROOTHANDLE, NV_WIN_DEVICE);                            
        MySurfaces.myFreeCount = NvGetFreeCount(pMyNvChan, 0);    
    }        
    MySurfaces.myFreeCount -= 3*4;                                        

    // clear the notifiers
    nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(0)+NUM04DOFFSET].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
    nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(1)+NUM04DOFFSET].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
    // put the object into the channel
    pMyNvChan->subchannel[0].SetObject = MY_EXTERNAL_DECODER_OBJECT;

    // fire off the command
    pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.GetImageOffsetNotify[0] =  NV04D_GET_IMAGE_OFFSET_NOTIFY_WRITE_ONLY;
    pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.GetImageOffsetNotify[1] =  NV04D_GET_IMAGE_OFFSET_NOTIFY_WRITE_ONLY;
    
    // wait for completion

    while ( ((nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(0)+NUM04DOFFSET].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS) ||
                 (nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(1)+NUM04DOFFSET].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS))    &&
                (whiletime++ < WHILETIMEOUT) )
                NvRmR0Interrupt ((GLOBDATAPTR)->ROOTHANDLE, NV_WIN_DEVICE);                            
        ;
    
    // only one of these should be running right now....
    if( nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(0)+NUM04DOFFSET].info16 == NV04D_NOTIFICATION_INFO16_FIELD_VALID_OFFSET ) {
        aField = MySurfaces.Surfaces[MySurfaces.CurrentBufferSurface[0]]->field;
    }
    if( nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(1)+NUM04DOFFSET].info16 == NV04D_NOTIFICATION_INFO16_FIELD_VALID_OFFSET ) {
        aField = MySurfaces.Surfaces[MySurfaces.CurrentBufferSurface[1]]->field;
    }
    if(aField == EVEN ) {
        retvalue = TRUE;
    } else {
        retvalue = FALSE;
    }
    
    return retvalue;
}


BOOL GetCurrentBuffers(void) {
    BOOL    retvalue = TRUE;
    U032    whiletime = 0;
    FIELDTYPE aField = UNKNOWN;
    NvChannel*    pMyNvChan = MySurfaces.pVPChanPtr;
        
    // we're not hitting the channel
    //INIT_FREE_COUNT(0);

    
    ASSERT(5*4 < NV06A_FIFO_GUARANTEED_SIZE ,"ASSERT FAILED\n");            
    while (MySurfaces.myFreeCount < 5*4)    {    
        NvRmR0Interrupt ((GLOBDATAPTR)->ROOTHANDLE, NV_WIN_DEVICE);                            
        MySurfaces.myFreeCount = NvGetFreeCount(pMyNvChan, 0);    
    }        
    MySurfaces.myFreeCount -= 5*4;                                        

    // clear the notifiers
    nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(0)+NUM04DOFFSET].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
//    nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(1)+NUM04DOFFSET].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
    nvMyVPNotifiers[NV04D_NOTIFIERS_GET_VBI_OFFSET_NOTIFY(0)+NUM04DOFFSET].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
//    nvMyVPNotifiers[NV04D_NOTIFIERS_GET_VBI_OFFSET_NOTIFY(1)+NUM04DOFFSET].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
    // put the object into the channel
    pMyNvChan->subchannel[0].SetObject = MY_EXTERNAL_DECODER_OBJECT;

    // fire off the command

    // NOTE we only need half of these since they return the same data as it stands now

    pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.GetImageOffsetNotify[0] =  NV04D_GET_IMAGE_OFFSET_NOTIFY_WRITE_ONLY;
//    pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.GetImageOffsetNotify[1] =  NV04D_GET_IMAGE_OFFSET_NOTIFY_WRITE_ONLY;
    pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.GetVbiOffsetNotify[0] =  NV04D_GET_IMAGE_OFFSET_NOTIFY_WRITE_ONLY;
//    pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.GetVbiOffsetNotify[1] =  NV04D_GET_IMAGE_OFFSET_NOTIFY_WRITE_ONLY;
    
    // wait for completion

    while ( ((nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(0)+NUM04DOFFSET].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS) &&
                 (nvMyVPNotifiers[NV04D_NOTIFIERS_GET_VBI_OFFSET_NOTIFY(0)+NUM04DOFFSET].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS))    &&
                (whiletime++ < WHILETIMEOUT) )
                NvRmR0Interrupt ((GLOBDATAPTR)->ROOTHANDLE, NV_WIN_DEVICE);                            
        ;
    
    // only one of these should be running right now....
    if( nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(0)+NUM04DOFFSET].info16 == NV04D_NOTIFICATION_INFO16_FIELD_VALID_OFFSET ) {
        aField = MySurfaces.Surfaces[MySurfaces.CurrentBufferSurface[0]]->field;
    }
    if( nvMyVPNotifiers[NV04D_NOTIFIERS_GET_VBI_OFFSET_NOTIFY(0)+NUM04DOFFSET].info16 == NV04D_NOTIFICATION_INFO16_FIELD_VALID_OFFSET ) {
        aField = MySurfaces.Surfaces[MySurfaces.CurrentBufferSurface[1]]->field;
    }
    if(aField == EVEN ) {
        retvalue = TRUE;
    } else {
        retvalue = FALSE;
    }
    
    return retvalue;
}


U032 vddhandleBufferInterrupts(U032 whichBuffer, U032 dummy2, U032 dummy3) {


    U032    i;
    U032    foundSomething;
    U032    reprogram;
    U032 interruptingBuffer = STARTINGBUF;
    U032 oldSurface;
    U032 newSurface;
    
    MySurfaces.myFreeCount = 0;

    // 15 long words is a bit arbitrary, but is based on the number of long words pushed in 
    // a normal update ie a VP reprogram and an overlay flip
    if (MySurfaces.myFreeCount < 15*4)                                
        MySurfaces.myFreeCount = NvGetFreeCount(MySurfaces.pVPChanPtr, 0);            
    
    {
        U032 aCount=0;
        while( MySurfaces.myFreeCount < 15*4 ) {
            DPF("No room on fifo.. try NVR0interrupt\n");
            NvRmR0Interrupt ((GLOBDATAPTR)->ROOTHANDLE, NV_WIN_DEVICE);    
            MySurfaces.myFreeCount = NvGetFreeCount(MySurfaces.pVPChanPtr, 0);            
            aCount++;
            if(aCount > 5){
                DPF("STILL No room on fifo.. bail outta here... there's probably something wrong\n");
                return 0;
            }
        
        }
    }
    // I'm really NOT sure what sort of information I'm going to be getting at this point...
    // I need to determine which of the four possible buffers just finished...
    do  {
        U032    time0old = 0xFFFFFFFF;
        U032    time1old = 0xFFFFFFFF;
        U032  oldestBuffer = NOSURFACEPROGRAMED;
        
        reprogram = FALSE;
        foundSomething = FALSE;
        // check for GOOD completions and deal with these first

        // search for the oldest finished buffer
        for(i=0;i<4;i++) {
            
            if(( nvMyVPNotifiers[notifyIndexFromBuffer(i)].status != NV04D_NOTIFICATION_STATUS_IN_PROGRESS ) && 
                ( nvMyVPNotifiers[notifyIndexFromBuffer(i)].status != NV04D_NOTIFICATION_STATUS_NOT_LAUNCHED )  ) 
            {
                // ok we've found one of the notifiers which has finished
                // now check the completion times to find the "oldest" one to preserve order
                U032 time1 = nvMyVPNotifiers[notifyIndexFromBuffer(i)].timeStamp.nanoseconds[1];
                U032 time0 = nvMyVPNotifiers[notifyIndexFromBuffer(i)].timeStamp.nanoseconds[0];
                
                // if the new time is not greater than the old time
                if( time1 <= time1old ) {
                    if( (( time1 == time1old ) && (time0 < time0old)) || ( time1 < time1old)) {
                        // we have a new winner
                        time0old = time0;
                        time1old = time1;
                        oldestBuffer = i;
                    }
                }
            }
        }
        
        
        if( oldestBuffer != whichBuffer ) {
            //DPF("Buffer callbacks are out of order\n");
        };
// This is an experiment.  check the free count.  if we have room, then process this request.  otherwise return
// now and deal with this notifier next time we get to this routine...
// this is put in to prevent a dead-lock between programmbufferswithsurface which is spinning waiting for room
// and the software method which is supposed to be MAKING room.                    
        if( oldestBuffer != NOSURFACEPROGRAMED ) {
            if (MySurfaces.myFreeCount < 15*4)                                
                MySurfaces.myFreeCount = NvGetFreeCount(MySurfaces.pVPChanPtr, 0);            
            {
                U032 aCount=0;
                while( MySurfaces.myFreeCount < 15*4 ) {
                    DPF("No room on fifo.. try NVR0interrupt\n");
                    NvRmR0Interrupt ((GLOBDATAPTR)->ROOTHANDLE, NV_WIN_DEVICE);    
                    MySurfaces.myFreeCount = NvGetFreeCount(MySurfaces.pVPChanPtr, 0);            
                    aCount++;
                    if(aCount > 5){
                        DPF("STILL No room on fifo.. bail outta here... there's probably something wrong\n");
                        return 0;
                    }
                
                }
            }
            // now verify that it was completed successfully
            if( nvMyVPNotifiers[notifyIndexFromBuffer(oldestBuffer)].status == NV04D_NOTIFICATION_STATUS_DONE_SUCCESS ) 
            {
                                         
                interruptingBuffer = oldestBuffer;
                oldSurface = MySurfaces.CurrentBufferSurface[interruptingBuffer];
                if( oldSurface != NOSURFACEPROGRAMED ) {

                    if(interruptingBuffer < 2)  {
                        //MarkTiming(NOTIFYIMG,MySurfaces.Surfaces[oldSurface]->pVidMem,makeInd(INCNOTAP,INCNOTAP,interruptingBuffer,oldSurface));
                        //MarkTimingNot(RMIMGPROG,&(nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(oldestBuffer)]),
                        //              nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(oldestBuffer)].info32,
                        //              makeInd(INCNOTAP,INCNOTAP,interruptingBuffer,oldSurface));
                        MarkTimingNot(NOTIFYIMG,&(nvMyVPNotifiers[notifyIndexFromBuffer(oldestBuffer)]),MySurfaces.Surfaces[oldSurface]->pVidMem,makeInd(INCNOTAP,INCNOTAP,interruptingBuffer,oldSurface));
                        //RecordImageNotify(nvMyVPNotifiers[notifyIndexFromBuffer(oldestBuffer)].timeStamp.nanoseconds[0],
                        //                  nvMyVPNotifiers[notifyIndexFromBuffer(oldestBuffer)].timeStamp.nanoseconds[1] );
                        
                    } else {
                        //MarkTiming(NOTIFYVBI,MySurfaces.Surfaces[oldSurface]->pVidMem,makeInd(interruptingBuffer,oldSurface,INCNOTAP,INCNOTAP));
                        MarkTimingNot(NOTIFYVBI,&(nvMyVPNotifiers[notifyIndexFromBuffer(oldestBuffer)]),MySurfaces.Surfaces[oldSurface]->pVidMem,makeInd(interruptingBuffer,oldSurface,INCNOTAP,INCNOTAP));
                    }
                    // onward
                    if(oldSurface == NOSURFACEPROGRAMED) {
                        //DPF("... that buffer should have had a surface..buffer =%d",interruptingBuffer);
                    }
                    nvMyVPNotifiers[notifyIndexFromBuffer(interruptingBuffer)].status = NV04D_NOTIFICATION_STATUS_NOT_LAUNCHED;
                    foundSomething = TRUE;
                    if((oldSurface != NOSURFACEPROGRAMED ) & (!MySurfaces.bStopVP) )
                         reprogram = TRUE;
                } else {
                    DPF("spurious interrupt, with unrecognized surface");
                }
            } else {
                // completed with an error most likely
                oldSurface = MySurfaces.CurrentBufferSurface[oldestBuffer];
                reportError(interruptingBuffer,oldSurface);
                nvMyVPNotifiers[notifyIndexFromBuffer(oldestBuffer)].status = NV04D_NOTIFICATION_STATUS_NOT_LAUNCHED;
                if( MySurfaces.Surfaces[oldSurface] == NULL )
                        foundSomething = FALSE;
                    else 
                        foundSomething = TRUE;    
                // for now do nothing
            }
        }

        // on the NV10, the buffers don't have a fixed capture order because of a bug in the HW
        // since I WANT a particular buffer to finish first, the only way to ensure this is to see if
        // the WRONG buffer finished first and if so reprogram it with the SAME settings.
        
        if((MySurfaces.bFirstTime) && (interruptingBuffer == 1)) {
            MarkTiming(ALMEMRESTART,MySurfaces.Surfaces[oldSurface]->pVidMem, makeInd2(0,INCNOTAP,interruptingBuffer,7,0));

            if( MySurfaces.VBIstart > 1 ) {
                ProgramBufferWithSurface(1,1,FALSE);
            } else {
                // fire up the second buffer at the first surface
                DPF("this is kinda odd, only one surface, but also non-interleaved...");
                ProgramBufferWithSurface(1,0,FALSE);
            }
            MySurfaces.bFirstTime = FALSE;
            // since we're going to pretend that this _didn't_ occur, we'll just return right now!
            return 0;
        }
        
        MySurfaces.bFirstTime = FALSE;
        // no go on with life as usual.

        if( reprogram) {
            U032 overlayFlipError = 0;
            
            // check if we're an image buffer and see if we need to schedule an overlay flip
            if( interruptingBuffer < 2 ) {
                FIELDTYPE interruptingField = UNKNOWN;
                
                interruptingField = getFieldFromBuffer(interruptingBuffer);
                
                
                if( MySurfaces.CurrentScanMode == SEPERATEBUF ) {
                    // scheduele flip!
                    // overlayFlipError = scheduleOverlayFlip(oldSurface,FALSE, interruptingField);
                    
                } else {
                    // we're in interleaved mode... 
                    
                    // Check to see if we're doing "bob from interleaved"
                    if ((MySurfaces.pDriverData)->vpp.dwOverlayMode & NV_VFM_FORMAT_BOBFROMINTERLEAVE) {
                        //Bob from interleaved
                        // we don't want the overlay to follow the surface, instead the one just behind
                        // this surface
        //                scheduleOverlayFlip(getPrevSurface(oldSurface),TRUE, interruptingField);

                        // this is an odd situation where we should delay one field on our updates...
                        // this causes overlay flip to a surface to occur only after BOTH fields in the surface
                        // have been received.
                        if( MySurfaces.lastSurface != NOSURFACEPROGRAMED) {
                            //overlayFlipError = scheduleOverlayFlip(MySurfaces.lastSurface,TRUE, interruptingField);
                            //overlayFlipError = scheduleOverlayFlip(oldSurface,TRUE, interruptingField);
                        }
                        MySurfaces.lastSurface = oldSurface;
                        MySurfaces.lastBuffer = interruptingBuffer;

                        if ( overlayFlipError == 15 ) {
                           // this indicates that we need to go into DropFrame mode.
                           // we need to prevent the flipping of the NEXT field to complete
                           // and we need to reprogram the NEXT TWO fields to have lengths of zero
                           MySurfaces.DropSystem.dwDropFields = 2;
                           
                        }
                    } else {
                        // weave from interleaved
                        // Check to see if the other buffer is working on this surface, if it is then don't flip
                        // flip only when ODD field was the last programmed. which likey means this is an EVEN
                        // field which completed and therefore is the second field in the surface
                        if(  MySurfaces.lastField == ODD ) {
                            // overlayFlipError = scheduleOverlayFlip(oldSurface,FALSE, interruptingField);
                        } else {
                        }
                    }
                }
                
            // however smac@microsoft.com ( head VPE guru )
            // says that autoflip means we should continue capturing fields but they should end up in the SAME surface
            // so off we go to reprogram
        
                if( MySurfaces.DropSystem.dwDropFields > 0  ){
                    
                    // then call ProgramBuffer with Surface
                    // program up this buffer to send to a "null" surface
                    // reprogram the old surface, but with a zero length so nothing get written into
                    // the surface, and things can progress properly if needed
                    
                    //  I think this might be throwing out the field just following the field
                    // that we want to throw out, because I'm programming one field ahead...
                    ProgramBufferWithSurface(interruptingBuffer,oldSurface, TRUE);
                    
                    // we'll only drop two of these count them down
                    MySurfaces.DropSystem.dwDropFields--;
                    
                } else if( MySurfaces.bSkipNextField ) {
                    // then call getNextSurface
                    if( MySurfaces.Surfaces[oldSurface]->bAutoFlip ) {
                        newSurface = getNextSurface(oldSurface,FALSE);
                    } else {
                        MySurfaces.bFlipRequested = FALSE;
                        newSurface = oldSurface;
                    }
                    // then call ProgramBuffer with Surface
                    // program up this buffer to send to a "null" surface
                    // reprogram the old surface, but with a zero length so nothing get written into
                    // the surface, and things can progress properly if needed
                    
                    //  I think this might be throwing out the field just following the field
                    // that we want to throw out, because I'm programming one field ahead...
                    ProgramBufferWithSurface(interruptingBuffer,oldSurface, TRUE);
                    MySurfaces.bSkipNextField = FALSE;
                } else {
                  // this is the normal calm pathway
                  if( MySurfaces.Surfaces[oldSurface]->bAutoFlip ) {
                      newSurface = getNextSurface(oldSurface,FALSE);
                  } else {
                      MySurfaces.bFlipRequested = FALSE;
                      newSurface = oldSurface;
                  }// then call ProgramBuffer with Surface
                  ProgramBufferWithSurface(interruptingBuffer,newSurface, FALSE);
                    
                }
                 
                // Do Vid Texture now...  this will be purely field based. and only ODD field
                if(  MySurfaces.lastField == ODD ) {

                    // until this code is written
                }
                
            } else {
                // this is a VBI buffer... so just check if it's autoflip or not
                if( MySurfaces.Surfaces[oldSurface]->bAutoFlip ) {
                    newSurface = getNextSurface(oldSurface,FALSE);
                } else {
                    MySurfaces.bFlipRequested = FALSE;
                    newSurface = oldSurface;
                }
                // then call ProgramBuffer with Surface
                ProgramBufferWithSurface(interruptingBuffer,newSurface, FALSE);
            
            }
            CheckAndDoCallbacks(interruptingBuffer,oldSurface);
            
            
            // At this pointer we've checked and call the 3rd party callbacks.
            //   then we've flipped the overlay if we determined that to be important
            //   finally we've reprogrammed our hardware to go off and do whatever
            
            // now we'll call MS's callback to tell them that something has happened.
            
            // we should ONLY do this ONCE per field on the LAST of the two notifies.
            // So if it's VBI only then that's when the vbi is done
            // otherwise when IMAGE is done
            
            if( (( MySurfaces.VBIstart == 0 ) && ((whichBuffer == 2) || (whichBuffer == 3))) ||
                (( MySurfaces.VBIstart != 0 ) &&((whichBuffer == 0) || (whichBuffer == 1)))   ){
                if((void*)MySurfaces.pDXIRQCallback != NULL) {
                    if( MySurfaces.DXIRQCallbackSources & DDIRQ_VPORT0_VSYNC ) {
                        // basically since we're auto flipping, we're only going to tell them when this is done and nothing else
                            if(MySurfaces.pDXIRQCallback != 0) {
                                // here's the one line of docs that we have:
                                // When calling the IRQCallback, EAX should contain the DDIRQ_xxxx flags indicating 
                                // what caused the IRQ and EBX should contain the specified dwContext. 
                                
                                
                                U032 temp1 = MySurfaces.dwIrqContext;        //  the same context which dd gave me before
                                U032 temp2 = DDIRQ_VPORT0_VSYNC;                // at this point we only have an interrupt for ONE event
    
    // to allow chris's editor to deal with funky assembly code
#define SKIPOMPARSE
#ifdef SKIPOMPARSE        
                            
                                // push register values
                                _asm mov EAX, temp2
                                _asm mov EBX, temp1
#endif                            
                                // call the callback
                                ((ACALLBACKTYPEPROC)MySurfaces.pDXIRQCallback)();
                            };
    
                    }
                
                }
            }
        } else {
            if(interruptingBuffer == STARTINGBUF ) {
                //DPF ("   We got an interrupt but no buffer's were in state STATUS_DONE_SUCCESS \n");
            //    DPF ("           or had ERRORS.  We may be trying to terminate\n");
            }
            interruptingBuffer = UNKNOWNBUF;
            if(oldSurface == NOSURFACEPROGRAMED) {
                DPF ("   We got an event wherein the surface which we just claimed to  \n");
                DPF ("           have filled was invalid\n");
            }
        }
        
        
        
//    } while (foundSomething);
    } while (FALSE);
    
    return 0;
}



void timerNotifyProc(void) {
    // this gets called when we want to start the video on NV3
    // check for null channel pointer
    if( (MySurfaces.pDriverData)->dwGlobalStructSize != sizeof(GLOBALDATA) ) {
        U032 size = sizeof(GLOBALDATA);
        
        DPF("Warning Warning Warning  -  Globaldata structure compiled with different length prepare to die!");
        return;
    }
    
    if( (MySurfaces.pDriverData)->NvDevFlatVPE == (U032)NULL ) {
        // how do we indicate error here?  uh I don't know yet
        return ; 
    }

    if( (MySurfaces.pDriverData)->NvDevVideoFlatPio == (U032)NULL ) {
        // how do we indicate error here?  uh I don't know yet
        return ; 
    }
    
    startSurfaces(MySurfaces.dwVPFlags & DDVP_INTERLEAVE, &(MySurfaces.dwVideoPortStatus) );

    return;
}

void wrapperProcI0(void) {
    
    // check for null channel pointer
    if( (MySurfaces.pDriverData)->NvDevFlatVPE == (U032)NULL ) {
        // how do we indicate error here?  uh I don't know yet
        return ; 
    }
    if( (MySurfaces.pDriverData)->NvDevVideoFlatPio == (U032)NULL ) {
        // how do we indicate error here?  uh I don't know yet
        return ; 
    }
    
    // only do something here if we know that the "thread is running"
    if(MySurfaces.bThreadRunning)
        vddhandleBufferInterrupts(0,0,0);
    return;
}

void wrapperProcI1(void) {
    
    // check for null channel pointer
    if( (MySurfaces.pDriverData)->NvDevFlatVPE == (U032)NULL ) {
        // how do we indicate error here?  uh I don't know yet
        return ; 
    }
    if( (MySurfaces.pDriverData)->NvDevVideoFlatPio == (U032)NULL ) {
        // how do we indicate error here?  uh I don't know yet
        return ; 
    }
    
    // only do something here if we know that the "thread is running"
    if(MySurfaces.bThreadRunning)
        vddhandleBufferInterrupts(1,0,0);
    return;
}

void wrapperProcV0(void) {
    
    // check for null channel pointer
    if( (MySurfaces.pDriverData)->NvDevFlatVPE == (U032)NULL ) {
        // how do we indicate error here?  uh I don't know yet
        return ; 
    }
    if( (MySurfaces.pDriverData)->NvDevVideoFlatPio == (U032)NULL ) {
        // how do we indicate error here?  uh I don't know yet
        return ; 
    }
    
    // only do something here if we know that the "thread is running"
    if(MySurfaces.bThreadRunning)
        vddhandleBufferInterrupts(2,0,0);
    return;
}

void wrapperProcV1(void) {
    
    // check for null channel pointer
    if( (MySurfaces.pDriverData)->NvDevFlatVPE == (U032)NULL ) {
        // how do we indicate error here?  uh I don't know yet
        return ; 
    }
    if( (MySurfaces.pDriverData)->NvDevVideoFlatPio == (U032)NULL ) {
        // how do we indicate error here?  uh I don't know yet
        return ; 
    }
    
    // only do something here if we know that the "thread is running"
    if(MySurfaces.bThreadRunning)
        vddhandleBufferInterrupts(3,0,0);
    return;
}

void MTMNotifyProc(void) {
    if( (MySurfaces.pDriverData)->NvDevFlatVPE == (U032)NULL ) {
        // how do we indicate error here?  uh I don't know yet
        return ; 
    }
    // Uh... is there more to do here?  Probably we should check and update the status field...
    if( UpdateStatus() ) {
        // something completed... see if we want to launch another
        CheckForLaunch();
    } else {
        // it's still running this is a superflous interrupt!
    }
}


U032 vddSetCallback(inSCBStruct*    inbuffer, outSCBStruct* outbuffer) {

    // remember in  buffer is 4 bytes
    //          out buffer is 4 bytes

    
    // ignore incoming value
    
    // setout outgoing value to the function pointer
    
    
        

    if(((U032*)inbuffer)[0] == IMAGESURFACE ) {
        // this is the IMAGE callback
        if(MySurfaces.ImageCallbackRoutine == NULL ) {
            MySurfaces.ImageCallbackRoutine = (CALLBPROC) ((U032*)inbuffer)[1];
            ((U032*)outbuffer)[0] = 0;
        } else {
            ((U032*)outbuffer)[0] = 13;
        }
    } else if(((U032*)inbuffer)[0] == VBISURFACE  ) {
        // this is the VBI callback
        if(MySurfaces.VBICallbackRoutine == NULL ) {
            MySurfaces.VBICallbackRoutine = (CALLBPROC)  ((U032*)inbuffer)[1];
            ((U032*)outbuffer)[0] = 0;
        } else {
            ((U032*)outbuffer)[0] = 13;
        }
    } else {
        // we don't recognize the surface type... let's bail with an error
            ((U032*)outbuffer)[0] = 13;
    }
    
    return 0;
}



U032 GetFlatCodeSelector()
{
    DWORD    Selector;
// to allow chris's editor to deal with funky assembly code
#define SKIPOMPARSE
#ifdef SKIPOMPARSE        
    _asm xor eax, eax
    _asm mov ax, cs
    _asm mov Selector, eax
#endif
    return (Selector);
}



U032 vddgetStoragePointer(U032 dummy1, U032 dummy2, U032 dummy3) {
//    MySurfaces.marker = 0xDEADBEEF;
//    MySurfaces.storCount = MAXDATASTORE;
    MySurfaces.lastSurfaceFlippedTo = 1000;    // for the overlay
    
    MySurfaces.pTimerNotifyProc = (U032) timerNotifyProc;
    MySurfaces.pNotifyCallbackProcI0 = (U032) wrapperProcI0;
    MySurfaces.pNotifyCallbackProcI1 = (U032) wrapperProcI1;
    MySurfaces.pNotifyCallbackProcV0 = (U032) wrapperProcV0;
    MySurfaces.pNotifyCallbackProcV1 = (U032) wrapperProcV1;
    // MySurfaces.pNotifyOverlay0NotifyProc = (U032) Overlay0NotifyProc;
    // MySurfaces.pNotifyOverlay1NotifyProc = (U032) Overlay1NotifyProc;
    MySurfaces.CallbackSelector = GetFlatCodeSelector();
    MySurfaces.pTheNotifiers = nvMyVPNotifiers;
    MySurfaces.pMTMNotifyCallback = (U032) MTMNotifyProc;
    return ((U032)&MySurfaces);
}



void    reportError(U032 interruptingBuffer,U032 oldSurface) {
    V016    status;
    V032 info32;                  
     V016 info16;

    info32 = nvMyVPNotifiers[notifyIndexFromBuffer(interruptingBuffer)].info32;
    info16 = nvMyVPNotifiers[notifyIndexFromBuffer(interruptingBuffer)].info16;

    status = nvMyVPNotifiers[notifyIndexFromBuffer(interruptingBuffer)].status;

    if( NV04D_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT & status ) {
        DPF ("   ERROR DETECTED BY NOTIFICATION:              Error Type: ERROR_PROTECTION_FAULT\n");
    }
    if( NV04D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT & status ) {
        DPF ("   ERROR DETECTED BY NOTIFICATION:              Error Type: ERROR_BAD_ARGUMENT\n");
    }
    if( NV04D_NOTIFICATION_STATUS_ERROR_INVALID_STATE & status ) {
        DPF ("   ERROR DETECTED BY NOTIFICATION:              Error Type: ERROR_INVALID_STATE\n");
    }
    if( NV04D_NOTIFICATION_STATUS_ERROR_STATE_IN_USE & status ) {
        DPF ("   ERROR DETECTED BY NOTIFICATION:              Error Type: ERROR_STATE_IN_USE\n");
    }
    if( NV04D_NOTIFICATION_STATUS_WARNING_INVALID_DATA & status ) {
        DPF ("   ERROR DETECTED BY NOTIFICATION:              Error Type: WARNING_INVALID_DATA\n");
    }

    switch (info32) {
            case MY_EXTERNAL_DECODER_OBJECT:
                DPF ("   ERROR DETECTED BY NOTIFICATION:    Error Class Instance: MY_EXTERNAL_DECODER_OBJECT\n");    
                break;
            case MY_EXTERNAL_DECODER_NOTIFIER:
                DPF ("   ERROR DETECTED BY NOTIFICATION:    Error Class Instance: MY_EXTERNAL_DECODER_NOTIFIER\n");
                break;
            case MY_IMAGE0_BUFFER_CONTEXT:
                DPF ("   ERROR DETECTED BY NOTIFICATION:    Error Class Instance: MY_IMAGE0_BUFFER_CONTEXT\n");
                break;
            case MY_IMAGE1_BUFFER_CONTEXT:
                DPF ("   ERROR DETECTED BY NOTIFICATION:    Error Class Instance: MY_IMAGE1_BUFFER_CONTEXT\n");
                break;
            case MY_VBI0_BUFFER_CONTEXT:
                DPF ("   ERROR DETECTED BY NOTIFICATION:    Error Class Instance: MY_VBI0_BUFFER_CONTEXT\n");
                break;
            case MY_VBI1_BUFFER_CONTEXT:
                DPF ("   ERROR DETECTED BY NOTIFICATION:    Error Class Instance: MY_VBI1_BUFFER_CONTEXT\n");
                break;
            default:        
                //DPF ("   ERROR DETECTED BY NOTIFICATION:    Error Class Instance: Unknown Class Instance: %x",info32);        
                break;
    }
    
    //DPF ("   ERROR DETECTED BY NOTIFICATION:     Error Method Number: %x",info16);
    //DPF ("   ERROR DETECTED BY NOTIFICATION:     Interrupting Buffer: %x",interruptingBuffer);
    if( oldSurface == NOSURFACEPROGRAMED) {
        //DPF ("   ERROR DETECTED BY NOTIFICATION:       Surface Attempted: SURFACE NOT PROGRAMMED\n");
    } else {
        //DPF ("   ERROR DETECTED BY NOTIFICATION:       Surface Attempted: %x",oldSurface);
    }    

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vdd\nv4\vddi2c.c ===
/*----------------------------------------------------------------------------*/
/*
 * vddi2c.c
 *
 *  I2C functionality for the miniVDD
 *
 */

/*----------------------------------------------------------------------------*/
/*
 * include files
 */

#define WANTVXDWRAPS
#include <basedef.h>
#include <vmm.h>
#include <vxdwraps.h>

/* NV includes */
#include <nv32.h>
#include <nvtypes.h>
#include <nvmacros.h>
#include <nvwin32.h>
#include <nvos.h>

#include "nvmisc.h"
#include "nvrmr0api.h"
#include "vddi2c.h"

/*----------------------------------------------------------------------------*/
/*
 * misc defines and prototypes
 */

//
// prototypes
//
U032    vddWriteVPEPrescale     (U032, U032, U032, U032, U032);

#define VDD_I2C_UNINITIALIZED   0
#define VDD_I2C_INITIALIZED     1
#define VDD_I2C_ACQUIRED        2
#define VDD_I2C_BASE_INST       0x55a50001
#define WDM_TO_VPE_COMMAND_MASK 0xdead0000

// backdoor VPE command function
ULONG nvVPECommand ( ULONG, void*);

/*
 * globals
 */

ULONG       vddI2Cstate;
ULONG       ourRoot;
ULONG       ourDevice = VDD_I2C_BASE_INST;  // for lack of better device instance

NVRM_I2C_ACCESS_CONTROL rmI2CCtrl;

static oneTimeInit = 0;

/*----------------------------------------------------------------------------*/
/*
 * vddI2COpen() - NV version of I2COpen()
 */

NTSTATUS vddI2COpen (
    DWORD           dummyReturnPtr, 
    PDEVICE_OBJECT  pDev,
    UINT        acquire,
    PI2CControl     pI2CCtrl )
{

    UINT                    rc;
    NTSTATUS                result = STATUS_SUCCESS;
    char                    devName[32];

    /*
     * check for WDM backdoor to VPE request  (This is allow WDM drivers to set
     * some VPE parameters that aren't or can't be set by WDM's overlay mixer.)
     */

    if ( (pI2CCtrl->Command & 0xffff0000) == WDM_TO_VPE_COMMAND_MASK ) {
        rc = nvVPECommand ( (pI2CCtrl->Command & 0x0000ffff), (void*) pI2CCtrl );
        pI2CCtrl->Status = rc;
        return rc;
    }


    /*
     * acquire/release I2C service
     */

    if ( acquire == TRUE ) {

        if ( vddI2Cstate == VDD_I2C_ACQUIRED ) {

            /* 
             * I2C has already been acquired, return error 
             */

            pI2CCtrl->dwCookie = 0;
            pI2CCtrl->Status = I2C_STATUS_BUSY;

            result = STATUS_OPEN_FAILED;

        }
        else {

            /* 
             * I2C is available so acquire it 
             */

            if ( oneTimeInit == 0 ) {
                /* get root and device */
                rc = NvRmR0AllocRoot(&ourRoot);
                if ( rc != NVOS01_STATUS_SUCCESS ) {
                    pI2CCtrl->dwCookie = 0;
                    pI2CCtrl->Status = I2C_STATUS_ERROR;
                    result = STATUS_OPEN_FAILED;
                    return(result);
                }

                rc = NvRmR0AllocDevice(ourRoot, ourDevice, NV01_DEVICE_0, devName);
                if ( rc != NVOS06_STATUS_SUCCESS ) {
                    pI2CCtrl->dwCookie = 0;
                    pI2CCtrl->Status = I2C_STATUS_ERROR;
                    result = STATUS_OPEN_FAILED;
                    NvRmR0Free(ourRoot, ourRoot, ourRoot);
                    return(result);
                }

                oneTimeInit = 1;
            }

            rmI2CCtrl.cmd = NVRM_I2C_ACCESS_CMD_ACQUIRE;
            rmI2CCtrl.port = NVRM_I2C_ACCESS_PORT_SECONDARY;
            rmI2CCtrl.flags = 0;

            rc = NvRmR0I2CAccess ( ourRoot, ourDevice, &rmI2CCtrl );

            if ( rc != 0 ) {

                /* unable to get I2C service */
                pI2CCtrl->dwCookie = 0;
                pI2CCtrl->Status = I2C_STATUS_ERROR;
                result = STATUS_OPEN_FAILED;

            }
            else {

                /* I2C service was obtained */
                pI2CCtrl->dwCookie = VDD_I2C_BASE_INST; /* for lack of better cookie */
                pI2CCtrl->Status = I2C_STATUS_NOERROR;
                vddI2Cstate = VDD_I2C_ACQUIRED;
                result = STATUS_SUCCESS;

            }

        }

    }
    else {

        if ( (vddI2Cstate != VDD_I2C_ACQUIRED) || (pI2CCtrl->dwCookie != VDD_I2C_BASE_INST) ) {

            /* 
             * I2C has not been previously "acquired" or cookie is wrong 
             */

            pI2CCtrl->Status = I2C_STATUS_ERROR;
            result = STATUS_INVALID_HANDLE;

        }
        else {

            /* 
             * I2C was previously acquired and cookie is valid, so ok to "release" 
             */

            rmI2CCtrl.cmd = NVRM_I2C_ACCESS_CMD_RELEASE;
            rmI2CCtrl.port = NVRM_I2C_ACCESS_PORT_SECONDARY;
            rmI2CCtrl.flags = 0;

            rc = NvRmR0I2CAccess ( ourRoot, ourDevice, &rmI2CCtrl );

            if ( rc != 0 ) {

                /* error in releasing I2C */
                pI2CCtrl->dwCookie = 0;
                pI2CCtrl->Status = I2C_STATUS_ERROR;
                result = STATUS_OPEN_FAILED;

            }
            else {

                /* I2C released */
                pI2CCtrl->dwCookie = 0;
                pI2CCtrl->Status = I2C_STATUS_NOERROR;
                result = STATUS_SUCCESS;
                vddI2Cstate = VDD_I2C_INITIALIZED;  /* ready to be acquired again */

            }

        }

    }

    return(result);

}

/*----------------------------------------------------------------------------*/
/*
 * vddI2CAccess - NV version of I2CAccess()
 */

NTSTATUS vddI2CAccess (
    DWORD           dummyReturnPtr, 
    PDEVICE_OBJECT  pDev,
    PI2CControl     pI2CCtrl )
{

    UINT            rc;
    ULONG           startFlag;
    ULONG           stopFlag;
    ULONG           ackFlag;
    NTSTATUS        result = STATUS_SUCCESS;

    /*
     * make sure I2C has been acquired
     */

    if ( (vddI2Cstate == VDD_I2C_UNINITIALIZED) || 
         (vddI2Cstate == VDD_I2C_INITIALIZED) ||
         (pI2CCtrl->dwCookie != VDD_I2C_BASE_INST) ) {

        pI2CCtrl->Status = I2C_STATUS_ERROR;
        return(STATUS_INVALID_HANDLE);

    }

    /*
     * retrieve the flags we can deal with
     */

    startFlag = pI2CCtrl->Flags & I2C_FLAGS_START;
    stopFlag = pI2CCtrl->Flags & I2C_FLAGS_STOP;
    ackFlag = pI2CCtrl->Flags & I2C_FLAGS_ACK;

    rmI2CCtrl.flags = 0;

    if ( startFlag ) {
        rmI2CCtrl.flags |= NVRM_I2C_ACCESS_FLAG_START;
    }

    if ( stopFlag ) {
        rmI2CCtrl.flags |= NVRM_I2C_ACCESS_FLAG_STOP;
    }

    if ( ackFlag ) {
        rmI2CCtrl.flags |= NVRM_I2C_ACCESS_FLAG_ACK;
    }

    /*
     * handle the command
     */

    rmI2CCtrl.port = NVRM_I2C_ACCESS_PORT_SECONDARY;

    switch ( pI2CCtrl->Command ) {

      case I2C_COMMAND_WRITE:

        rmI2CCtrl.cmd = NVRM_I2C_ACCESS_CMD_WRITE_BYTE;
        rmI2CCtrl.data = pI2CCtrl->Data;
        rc = NvRmR0I2CAccess(ourRoot, ourDevice, &rmI2CCtrl);

        if ( rc == 0 ) {
            pI2CCtrl->Status = I2C_STATUS_NOERROR;
            result = STATUS_SUCCESS;
        }
        else {
            pI2CCtrl->Status = I2C_STATUS_ERROR;
            result = STATUS_ADAPTER_HARDWARE_ERROR;
        }

        break;

      case I2C_COMMAND_READ:

        rmI2CCtrl.cmd = NVRM_I2C_ACCESS_CMD_READ_BYTE;
        rmI2CCtrl.data = pI2CCtrl->Data;
        rc = NvRmR0I2CAccess(ourRoot, ourDevice, &rmI2CCtrl);

        if ( rc == 0 ) {
            pI2CCtrl->Data = (U008) rmI2CCtrl.data;
            pI2CCtrl->Status = I2C_STATUS_NOERROR;
            result = STATUS_SUCCESS;
        }
        else {
            pI2CCtrl->Status = I2C_STATUS_ERROR;
            result = STATUS_ADAPTER_HARDWARE_ERROR;
        }

        break;

      case I2C_COMMAND_NULL:

        rmI2CCtrl.cmd = NVRM_I2C_ACCESS_CMD_NULL;
        rmI2CCtrl.data = pI2CCtrl->Data;
        rc = NvRmR0I2CAccess(ourRoot, ourDevice, &rmI2CCtrl);

        if ( rc == 0 ) {
            pI2CCtrl->Status = I2C_STATUS_NOERROR;
            result = STATUS_SUCCESS;
        }
        else {
            pI2CCtrl->Status = I2C_STATUS_ERROR;
            result = STATUS_ADAPTER_HARDWARE_ERROR;
        }

        break;

      case I2C_COMMAND_STATUS:

        if ( vddI2Cstate == VDD_I2C_ACQUIRED ) {
            /* nothing is going on just return success */
            pI2CCtrl->Status = I2C_STATUS_NOERROR;
            result = STATUS_SUCCESS;
        }
        else {
            /* not applicable since we're synchronous but return something reasonable just in case */
            pI2CCtrl->Status = I2C_STATUS_BUSY;
            result = STATUS_DEVICE_BUSY;
        }

        break;

      case I2C_COMMAND_RESET:

        rmI2CCtrl.cmd = NVRM_I2C_ACCESS_CMD_NULL;
        rmI2CCtrl.data = pI2CCtrl->Data;
        rc = NvRmR0I2CAccess(ourRoot, ourDevice, &rmI2CCtrl);

        if ( rc == 0 ) {
            pI2CCtrl->Status = I2C_STATUS_NOERROR;
            result = STATUS_SUCCESS;
        }
        else {
            pI2CCtrl->Status = I2C_STATUS_ERROR;
            result = STATUS_ADAPTER_HARDWARE_ERROR;
        }

        break;

      default:
    
        pI2CCtrl->Status = I2C_STATUS_ERROR;
        result = STATUS_INVALID_PARAMETER;

        break;

    }

    return(result);

}

/*
 * nvVPECommand() is a backdoor function to allow other Ring0 programs (like WDM)
 * to change or request various VPE functions.
 */

#define NV_VPE_CMD_SET_PRESCALE_MODE    1
#define NV_VPE_CMD_SET_CROP_MODE        2

ULONG nvVPECommand (
    ULONG cmd,
    PVOID pData )
{

    switch ( cmd ) {

    case NV_VPE_CMD_SET_PRESCALE_MODE:

        /*
         * This command is to allow WDM drivers to tell VPE to prescale
         * as oppose to cropping.  This is because the overlay mixer does
         * not seem to pass on this information to us.
         */

        {
            PI2CControl pI2CCtrl = pData;

            /*
             * set prescale flag and size
             */
            //Data(lower nibble)    =   0   not capturing
            //                          1   capturing
            //Data(upper nibble)    =   2   X scale
            //                          4   Y scale
            //Status    =   prescale/height * 1000
            if((pI2CCtrl->Data)& 0x40){
                vddWriteVPEPrescale(0, 
                                    ((PI2CControl)pI2CCtrl)->Status,//set Y-prescale 
                                    ((PI2CControl)pI2CCtrl)->Data,  //capture flag
                                    0, 
                                    6);                             //prog. y-pre & cap. flag
            }else if((pI2CCtrl->Data)& 0x20){
                vddWriteVPEPrescale(((PI2CControl)pI2CCtrl)->Status,//set X-prescale
                                    0, 
                                    ((PI2CControl)pI2CCtrl)->Data,  //capture flag
                                    0, 
                                    0xa);                           //prog. x-pre & cap.flag
            }else if(!((pI2CCtrl->Data)& 0x1)){
                vddWriteVPEPrescale(0,
                                    0, 
                                    0,  //capture flag=0 (not capturing)
                                    0, 
                                    0x2);   
            }
        }
        break;

    case NV_VPE_CMD_SET_CROP_MODE:

        /*
         * This command is to allow WDM drivers to tell VPE to crop
         * as oppose to prescaling.  This is because the overlay mixer does
         * not seem to pass on this information to us.
         */

        {
            PI2CControl pI2CCtrl = pData;

            /*
             * turn off prescale flag
             */

        }
        break;

    default:
        return 1;   
    }

    return 0;
}

void nvpeVDDInit()
{
    //Initialize VPE capture hack for WDM
    vddWriteVPEPrescale(1000,   //setting ME X-prescale factor. 1000=no scale
                        1000,   //setting ME Y-prescale factor. 1000=no scale
                        0,      //set to not vpe capture mode
                        0,      //set default VP surf type = overlay  
                        0xf);   //use all values

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vdd\common\transfer.c ===
/***************************************************************************\
* (C) Copyright NVIDIA Corporation Inc.,                                    *
*  1996,1997, 1998. All rights reserved.                                    *
* THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO       *
* NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY  *
* IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.                *
*                                                                           *
* Module: transfer.c                                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       schaefer           8/17/98                                          *
*                                                                           *
\***************************************************************************/

#ifdef NV4_HW
#define NV4
#endif
#ifdef NV10_HW
#define NV4
#endif

// to make the references to channel data cool here in ring0
#define INVDDCODE

// MS includes
#include "windows.h"
#include "ddraw.h"
#include "Ddrawp.h"
#include "ddrawi.h"
#include "ddmini.h"
#include "dvp.h"
#include "dmemmgr.h"

//  vdd specific MS includes
#include "minivdd.h"
#include "ddkmmini.h"
#include "nvos.h"

// NV includes
#include "nvwin32.h"
#include "nvhw.h"
#include <nv_ref.h>
#include "nvrmr0api.h"

// This is here because it is defined in nvrmarch.inc. We can't include that file here.
#define NV_WIN_DEVICE                            0x00002002

// unit specific includes
#define RESMANSIDE
#include "surfaces.h"
#include "vddsurfs.h"
#include "vpvdd.h"

#include "transfer.h"
#include "timing.h"
#define USERING0LIBRARY
#ifndef  USERING0LIBRARY

#include "nvkrmapi.c"

#endif //USERING0LIBRARY

//
// prototypes
//
U032    getSurfaceIndex     (U032);

//#define  DPF(a) _Debug_Printf_Service(a)

//
// Use static storage for now.  assume no more than MAXTRANSFERS transfers queued.
//
extern  vpSurfaces 			MySurfaces;		
extern  NvNotification		nvMyVPNotifiers[NUMVPNOTIFIERS];

#ifndef DPF
#define DPF(a) NULL
#endif

U032 checkNvAllocArchError(U032 error) {
	// returns true if there IS an error
	// otherwise false
	switch (error) {
			case NVOS04_STATUS_SUCCESS:
				return 0;
//				DPF("NVOS04_STATUS_SUCCESS");
				break;
			case NVOS04_STATUS_ERROR_OPERATING_SYSTEM:
				DPF("NVOS04_STATUS_ERROR_OPERATING_SYSTEM");
				return error;
				break;
			case NVOS04_STATUS_ERROR_BAD_OBJECT_PARENT:
				DPF("NVOS04_STATUS_ERROR_BAD_OBJECT_PARENT");
				return error;
				break;
			case NVOS04_STATUS_ERROR_BAD_OBJECT_NEW:
				DPF("NVOS04_STATUS_ERROR_BAD_OBJECT_NEW");
				return error;
				break;
			case NVOS04_STATUS_ERROR_BAD_CLASS:
				DPF("NVOS04_STATUS_ERROR_BAD_CLASS");
				return error;
				break;
			case NVOS04_STATUS_ERROR_BAD_OBJECT_ERROR:
				DPF("NVOS04_STATUS_ERROR_BAD_OBJECT_ERROR");
				return error;
				break;
			case NVOS04_STATUS_ERROR_BAD_FLAGS:
				DPF("NVOS04_STATUS_ERROR_BAD_FLAGS");
				return error;
				break;
			case NVOS04_STATUS_ERROR_INSUFFICIENT_RESOURCES:
				DPF("NVOS04_STATUS_ERROR_INSUFFICIENT_RESOURCES");
				return error;
				break;
			default:
					DPF("UNKNOWN ERROR");
					return 1;
	}
	
	return 0;
}


pTransfer AddTransfer(U032 TransferID) {
	pTransfer	pMyTransfer;
	U032 i;
	// check for duplicate transfer ID
	for(i=0;i<MAXTRANSFERS;i++) {
		if(MySurfaces.MyTransfers[i].TransferID == TransferID) {
			DPF("That ID already in use!");
			return NULL;
		}
	}
	
	// check for room in queue?
	
	if(MySurfaces.dwNextEmpty == MySurfaces.dwLastEmpty ) {
		return NULL;
	}
	
	
	pMyTransfer = &(MySurfaces.MyTransfers[MySurfaces.dwNextEmpty]);
	pMyTransfer->TransferID = TransferID;
	
	MySurfaces.dwNextEmpty = MySurfaces.dwNextEmpty+1;
	if(MySurfaces.dwNextEmpty >= MAXTRANSFERS )
		MySurfaces.dwNextEmpty = 0;
		
	return pMyTransfer;
#if 0	
	for(i=0;i<MAXTRANSFERS;i++) {
		if(MySurfaces.MyTransfers[i].TransferID == TRANSFERNOTINUSE ) {
			U032 temp =i +1;
			pMyTransfer = &(MySurfaces.MyTransfers[i]);
			pMyTransfer->TransferID = TransferID;
			
			if(temp >= MAXTRANSFERS ) {
				temp = 0;
			}
			pMyTransfer->pNextTransfer = (U032*) &(MySurfaces.MyTransfers[temp]);
			return pMyTransfer;
		}
	}
#endif
	// couldn't find an empty Transfer to use
	DPF("couldn't find an empty Transfer to use");
	return NULL;	
}


U032 DeleteTransfer(pTransfer pTrans) {
	U032	temp;
	// theoretically the one we're deleting here should be the same as the "last full"
	// unless we're the first 
	// find the transfer that's one ahead of the nextEmpty zone
	temp = MySurfaces.dwLastEmpty +1;
	if(temp >= MAXTRANSFERS ) {
		temp = 0;
	}
	// make sure it's the one we want to delete;
	if(pTrans != &(MySurfaces.MyTransfers[temp]) ) {
		DPF("Major error here. the one we're trying to delete is NOT in order ");
	}
	// delete it!
	pTrans->TransferID = TRANSFERNOTINUSE;
	pTrans->SurfaceData = 0;
	pTrans->StartLine =0;
	pTrans->EndLine = 0;
	pTrans->DestMDL = NULL;
	pTrans->TransferFlags = 0;
	pTrans->pNextTransfer = NULL;
	MySurfaces.dwLastEmpty = temp;
	
	
	return 0	;
}


pTransfer GetNextTransfer() {
	pTransfer pRetValue;
	U032	temp;
	
	// find the transfer that's one ahead of the nextEmpty zone
	temp = MySurfaces.dwLastEmpty +1;
	if(temp >= MAXTRANSFERS ) {
		temp = 0;
	}
	// get a pointer to it
	pRetValue = &MySurfaces.MyTransfers[temp];
	// make sure it's QUEUED
	if(pRetValue->transferStatus != QUEUED) { 
		// if not return NULL;
		return NULL;
	}
	// else return that one!
	MySurfaces.pCurrentTransfer = pRetValue;
	return pRetValue;
	
}


void ReCreateContext(PMDL aDestMDL) {
	U032	error;
	U032	start;
	U032	limit;
	NvChannel*	pMyNvChan = MySurfaces.pVPChanPtr;
	
	// first check to see if we can reuse the OLD context... since context creation is expensive.
	start = (U032)(aDestMDL->lpMappedSystemVa);
	limit = (aDestMDL->ByteCount  ) -1;
	
	if(MySurfaces.bContextCreated) {
		if((start == MySurfaces.savedStart) && (limit == MySurfaces.savedLimit) ) {
			// no problem this is the same thing, so don't recreate
			return;
		}
	}
	ASSERT(4*4 < NV06A_FIFO_GUARANTEED_SIZE );			
	while (NvGetFreeCount(pMyNvChan, 5) < 4*4 )	{
			NvRmR0Interrupt ((GLOBDATAPTR)->ROOTHANDLE, NV_WIN_DEVICE);	
	}					
	
	if(MySurfaces.bContextCreated) {
		// set context on MTM to NULLOBJECT
		
#ifdef NV3_HW
		pMyNvChan->subchannel[5].control.object = MY_MTM_OBJECT;
#else 
		pMyNvChan->subchannel[5].SetObject  = MY_MTM_OBJECT;
#endif // NV3_HW

#ifdef NV3_HW
		pMyNvChan->subchannel[5].memoryToMemoryFormat.SetBufferOutCtxDma = 0;
#else
		pMyNvChan->subchannel[5].nv03MemoryToMemoryFormat.SetContextDmaBufferOut = 0;
#endif
		// FREE the context first
		//   DO A SOFTWARE METHOD FLUSH HERE
		
#ifdef NV3_HW
		while (NvGetFreeCount(pMyNvChan, 5) < NV_GUARANTEED_FIFO_SIZE )	{
#else
		while (NvGetFreeCount(pMyNvChan, 5) < NV06A_FIFO_GUARANTEED_SIZE )	{
#endif
				NvRmR0Interrupt ((GLOBDATAPTR)->ROOTHANDLE, NV_WIN_DEVICE);	
		}

		error = NvRmR0Free((GLOBDATAPTR)->ROOTHANDLE, (GLOBDATAPTR)->ROOTHANDLE, MY_MTM_TO_CONTEXT);

		checkNvAllocArchError(error);

		MySurfaces.bContextCreated = FALSE;
	}
	
	// ALLOC the context
	// allocate the TO context
//	DPF("ReCreateContext: Now creating a context which starts at %x",(U032)(aDestMDL->lpStartVa));
//	DPF("ReCreateContext:                            and runs to %x",(U032)((aDestMDL->ByteCount + aDestMDL->ByteOffset ) -1));
	
	
	error = NvRmR0AllocContextDma(  (GLOBDATAPTR)->ROOTHANDLE,
	                     		MY_MTM_TO_CONTEXT,
	                     		NV01_CONTEXT_DMA,		//NV_CONTEXT_DMA_FROM_MEMORY ?
	                     		(	NVOS03_FLAGS_ACCESS_READ_WRITE |
                        				NVOS03_FLAGS_COHERENCY_UNCACHED),
	                     		(PVOID)start,
	                     //		(aDestMDL->ByteCount + aDestMDL->ByteOffset ) -1
	                     		limit
	                     );

	if(checkNvAllocArchError(error )) {
		DPF("NVDD: Cannot re-allocate MTM TO context object ");
		MySurfaces.bContextCreated = FALSE;
	} else {
		// set context on MTM to real object

#ifdef NV3_HW
		pMyNvChan->subchannel[5].control.object = MY_MTM_OBJECT;
#else 
		pMyNvChan->subchannel[5].SetObject  = MY_MTM_OBJECT;
#endif // NV3_HW

#ifdef NV3_HW
	pMyNvChan->subchannel[5].memoryToMemoryFormat.SetBufferOutCtxDma = MY_MTM_TO_CONTEXT;
#else
	pMyNvChan->subchannel[5].nv03MemoryToMemoryFormat.SetContextDmaBufferOut = MY_MTM_TO_CONTEXT;
#endif // NV3_HW

		MySurfaces.bContextCreated = TRUE;
		
		//   DO A SOFTWARE METHOD FLUSH HERE
		NvRmR0Interrupt ((GLOBDATAPTR)->ROOTHANDLE, NV_WIN_DEVICE);	

	}

}

U032 UpdateStatus(void) {
	// check the notifiers and see if thing completed ok
	// then fill in the status field and be on your way
#ifdef NV3_HW
	if( nvMyVPNotifiers[NUM039OFFSET + 1].status == NV_STATUS_IN_PROGRESS ) {
#else
	if( nvMyVPNotifiers[NUM039OFFSET + NV039_NOTIFIERS_BUFFER_NOTIFY].status == NV039_NOTIFICATION_STATUS_IN_PROGRESS ) {
#endif
		// still in progress
		return FALSE;
	} else {
#ifdef NV3_HW
		if( nvMyVPNotifiers[NUM039OFFSET + 1].status == NV_STATUS_DONE_OK ) {
#else
		if( nvMyVPNotifiers[NUM039OFFSET + NV039_NOTIFIERS_BUFFER_NOTIFY].status == NV039_NOTIFICATION_STATUS_DONE_SUCCESS ) {
#endif
			// finished ok!
			if( MySurfaces.pCurrentTransfer->transferStatus == PROGRAMMED) { 
				U032 temp = ((LPDDSURFACEDATA)(MySurfaces.pCurrentTransfer->SurfaceData))->fpLockPtr;
				U032 surfIndex = getSurfaceIndex(temp);
				MySurfaces.pCurrentTransfer->transferStatus = FINISHED;
				if( surfIndex < MySurfaces.VBIstart ) 
					MarkTiming(NOTIFYTRAN,temp, makeInd(INCNOTAP,INCNOTAP,INCNOTAP,surfIndex));
				else
					MarkTiming(NOTIFYTRAN,temp, makeInd(INCNOTAP,surfIndex,INCNOTAP,INCNOTAP));
			}
			// Do the callback to MS here
			if(MySurfaces.pDXIRQCallback != 0) {
				//if( MySurfaces.DXIRQCallbackSources & DDIRQ_BUSMASTER ) {
				// BUG in MS code... they should have set this flag but didn't for some reason...
				if(1) {			
					// CODE  -  this is where we'd do the callback
					
					// for now let's just get STUCK here
					// is it a void fun(void)   function?	
					
					// here's the one line of docs that we have:
					// When calling the IRQCallback, EAX should contain the DDIRQ_xxxx flags indicating 
					// what caused the IRQ and EBX should contain the specified dwContext. 
					
					
					U032 temp1 = MySurfaces.dwIrqContext;		//  the same context which dd gave me before
					U032 temp2 = DDIRQ_BUSMASTER;				// at this point we only have an interrupt for ONE event
					MySurfaces.dwMostRecentFinishTransferId = MySurfaces.pCurrentTransfer->TransferID;
				
	// to allow chris's editor to deal with funky assembly code
#define SKIPOMPARSE
#ifdef SKIPOMPARSE		
			
					// push register values
					_asm mov EAX, temp2
					_asm mov EBX, temp1
#endif							
					// call the callback  --- this will call vddGetTransferStatus......talk about TWISTED!!!!
					((ACALLBACKTYPEPROC)MySurfaces.pDXIRQCallback)();
				}
			};

			
		} else {
			// probably finished with an error!
			if( MySurfaces.pCurrentTransfer->transferStatus == PROGRAMMED) { 
				U032 temp = ((LPDDSURFACEDATA)(MySurfaces.pCurrentTransfer->SurfaceData))->fpLockPtr;
				U032 surfIndex = getSurfaceIndex(temp);
				MySurfaces.pCurrentTransfer->transferStatus = ERRORED;
				if( surfIndex < MySurfaces.VBIstart ) 
					MarkTiming(NOTIFYTRAN,temp, makeInd(INCNOTAP,INCNOTAP,INCNOTAP,surfIndex));
				else
					MarkTiming(NOTIFYTRAN,temp, makeInd(INCNOTAP,surfIndex,INCNOTAP,INCNOTAP));
							
			}
			// Do the callback to MS here
			if(MySurfaces.pDXIRQCallback != 0) {
				//if( MySurfaces.DXIRQCallbackSources & DDIRQ_BUSMASTER ) {
				// BUG in MS code... they should have set this flag but didn't for some reason...
				if(1) {		
					// CODE  -  this is where we'd do the callback
					
					// for now let's just get STUCK here
					// is it a void fun(void)   function?	
					
					// here's the one line of docs that we have:
					// When calling the IRQCallback, EAX should contain the DDIRQ_xxxx flags indicating 
					// what caused the IRQ and EBX should contain the specified dwContext. 
					
					
					U032 temp1 = MySurfaces.dwIrqContext;		//  the same context which dd gave me before
					U032 temp2 = DDIRQ_BUSMASTER;				// at this point we only have an interrupt for ONE event
					MySurfaces.dwMostRecentFinishTransferId = MySurfaces.pCurrentTransfer->TransferID;
				
	// to allow chris's editor to deal with funky assembly code
#define SKIPOMPARSE
#ifdef SKIPOMPARSE		
			
					// push register values
					_asm mov EAX, temp2
					_asm mov EBX, temp1
#endif							
					// call the callback
					((ACALLBACKTYPEPROC)MySurfaces.pDXIRQCallback)();
				}
			};
		}
	
		return TRUE;
	}
	
}

U032 CancelTransfer(DDTRANSFERININFO* pTransferInInfo) {
	pTransfer pATransfer;
	
	pATransfer = FindTransfer(pTransferInInfo->dwTransferID);
	
	if( pATransfer == NULL ) {
		return 1;
	}
	
	if( pATransfer->transferStatus == QUEUED ) {
		
		DeleteTransfer(pATransfer);
		return 0;
	} 
	return 1;
	
}



void CheckForLaunch(void) {
	NvChannel*	pMyNvChan = MySurfaces.pVPChanPtr;
	pTransfer pTheTransfer;
	U032 offsetStartByte;
	U032 lineCount;
	U032 lineLength;
	long linePitch;
	LPDDSURFACEDATA pSurfaceData;
	U032 bVbiSurf = FALSE;
	
	// Determine if the MTM engine is free, and attempt to launch a transfer
	
	
	// check for free engine
#ifdef NV3_HW
	if( nvMyVPNotifiers[NUM039OFFSET + 1].status == NV_STATUS_IN_PROGRESS ) {
#else
	if( nvMyVPNotifiers[NUM039OFFSET + NV039_NOTIFIERS_BUFFER_NOTIFY].status == NV039_NOTIFICATION_STATUS_IN_PROGRESS ) {
#endif

		// no free engine to start transfer on...
		
		return;
	} else {
		//  program up the MTM
		pTheTransfer = GetNextTransfer();
		if(pTheTransfer != NULL ) {
			U032 surfIndex;
			pSurfaceData = ((LPDDSURFACEDATA)(pTheTransfer->SurfaceData));
			
			surfIndex = getSurfaceIndex(pSurfaceData->fpLockPtr);
			if( surfIndex < MySurfaces.VBIstart ) 
				MarkTiming(TRANSFERLAUNCH,(U032)pSurfaceData->fpLockPtr, makeInd(INCNOTAP,INCNOTAP,INCNOTAP,surfIndex));
			else
				MarkTiming(TRANSFERLAUNCH,(U032)pSurfaceData->fpLockPtr, makeInd(INCNOTAP,surfIndex,INCNOTAP,INCNOTAP));
						
			ReCreateContext(pTheTransfer->DestMDL);
			
			if(surfIndex < MySurfaces.VBIstart ) 
				MarkTiming(TRANSFERRECRE,(U032)pSurfaceData->fpLockPtr, makeInd(INCNOTAP,INCNOTAP,INCNOTAP,surfIndex));
			else if(surfIndex < MySurfaces.numberOfSurfaces ) 
				MarkTiming(TRANSFERRECRE,(U032)pSurfaceData->fpLockPtr, makeInd(INCNOTAP,INCNOTAP,INCNOTAP,surfIndex));
			else
				MarkTiming(TRANSFERRECRE,(U032)pSurfaceData->fpLockPtr, makeInd(INCNOTAP,surfIndex,INCNOTAP,INCNOTAP));
			
#ifdef NV3_HW
			nvMyVPNotifiers[NUM039OFFSET + 1].status = NV_STATUS_IN_PROGRESS;
#else
			nvMyVPNotifiers[NUM039OFFSET + NV039_NOTIFIERS_BUFFER_NOTIFY].status = NV039_NOTIFICATION_STATUS_IN_PROGRESS;
#endif
			
			
			MYCHECKFREECOUNT(pMyNvChan,9*4);
	
					
#ifdef NV3_HW
			pMyNvChan->subchannel[5].control.object = MY_MTM_OBJECT;
#else 
			pMyNvChan->subchannel[5].SetObject = MY_MTM_OBJECT;
#endif // NV3_HW
			
			
			if (pSurfaceData->dwFormatFourCC == mmioFOURCC('R','A','W','8') ) {
				bVbiSurf = TRUE;
			} else if (pSurfaceData->dwFormatFourCC == mmioFOURCC('U','Y','V','Y') ) {
				bVbiSurf = FALSE;
			} else {
				bVbiSurf = FALSE;
			}
			
//			offsetStartByte = pSurfaceData->dwSurfaceOffset
//					+ pSurfaceData->lPitch * pTheTransfer->StartLine;
			// assume 1 based numbering for now...
			if(!bVbiSurf) {
				offsetStartByte =  ( pSurfaceData->fpLockPtr - (U032)((GLOBALDATA*)(MySurfaces.pDriverData))->BaseAddress)
						+ pSurfaceData->lPitch * (pTheTransfer->StartLine );
			} else {
				offsetStartByte =  ( pSurfaceData->fpLockPtr - (U032)((GLOBALDATA*)(MySurfaces.pDriverData))->BaseAddress)
						+ pSurfaceData->lPitch * (pTheTransfer->StartLine - 1);
			}

			//lineLength = pSurfaceData->dwWidth * 2;
			// apparently this width is already in bytes
			lineLength = pSurfaceData->dwWidth;
			linePitch = pSurfaceData->lPitch;
			
// WARNING THIS IS A HACK HACK HACK...			

// after developing this emprically it looks like it's an anti-interleaved factor... 
// we should probably check to make sure that the surface is interleaved before we impose it!
			
			if( (surfIndex < MySurfaces.VBIstart ) && (MySurfaces.dwVPFlags & DDVP_INTERLEAVE ) ) {
				

			
				if( lineLength < 90 ) {
					// 80X60
					linePitch = linePitch *2;
				} else if( lineLength < 170 ) {
					// 160X120
					linePitch = linePitch *2 ;
				} else if( lineLength < 330 ) {
					// 320X240
					linePitch = linePitch * 2;
				} else if( lineLength < 650 ) {
					// 640X480
					linePitch = linePitch ;
				} else {
					// this is some weird 720 things... do the same as 640 for now
					// 720X480
					linePitch = linePitch ;
				} 
			
			}			
			lineCount = ( pTheTransfer->EndLine - pTheTransfer->StartLine + 1 );	
				// SMAC@microsoft.com  :  Yes, you should transfer the end line.  
				// Therefore, if we only wanted you to
				// transfer a single line, start line would equal end line.	
			if( pTheTransfer->TransferFlags & DDTRANSFER_INVERT ) {
				// if we want to invert things, then we should 
				// negate the pitch and put the start offset at the end.
				
				offsetStartByte = offsetStartByte + linePitch * (lineCount - 1 );
				linePitch = -linePitch;
			}
			if(!bVbiSurf) {
				if((pTheTransfer->DestMDL->ByteCount  )  < (lineLength * 2 * lineCount )  ) { 
					DPF("Destination memory is not large enough to hold this image, truncating line count");
				//	lineCount = (pTheTransfer->DestMDL->ByteCount + pTheTransfer->DestMDL->ByteOffset ) / 	lineLength; 
					lineCount = (pTheTransfer->DestMDL->ByteCount ) / 	(lineLength * 2); 
				}
			} else {			
				if((pTheTransfer->DestMDL->ByteCount  )  < (lineLength * lineCount )  ) { 
					DPF("Destination memory is not large enough to hold this image, truncating line count");
				//	lineCount = (pTheTransfer->DestMDL->ByteCount + pTheTransfer->DestMDL->ByteOffset ) / 	lineLength; 
					lineCount = (pTheTransfer->DestMDL->ByteCount ) / 	(lineLength ); 
				}
			}			
			
			ASSERT(8*4 < NV06A_FIFO_GUARANTEED_SIZE );			
			while (NvGetFreeCount(pMyNvChan, 5) < 8*4 )	{
				NvRmR0Interrupt ((GLOBDATAPTR)->ROOTHANDLE, NV_WIN_DEVICE);	
			}					
			
			
#ifdef NV3_HW
			pMyNvChan->subchannel[5].memoryToMemoryFormat.BufferTransfer.offsetin	= offsetStartByte;
			//pMyNvChan->subchannel[5].memoryToMemoryFormat.BufferTransfer.offsetout = (unsigned long)pTheTransfer->DestMDL->ByteOffset;
			pMyNvChan->subchannel[5].memoryToMemoryFormat.BufferTransfer.offsetout = 0;
			pMyNvChan->subchannel[5].memoryToMemoryFormat.BufferTransfer.pitchin	= linePitch;
			pMyNvChan->subchannel[5].memoryToMemoryFormat.BufferTransfer.pitchout	= lineLength * 2;
			pMyNvChan->subchannel[5].memoryToMemoryFormat.BufferTransfer.linelengthin = lineLength *2;
			pMyNvChan->subchannel[5].memoryToMemoryFormat.BufferTransfer.linecount = lineCount;
			pMyNvChan->subchannel[5].memoryToMemoryFormat.BufferTransfer.format	=  ( 1 | 1 << 8 );
			pMyNvChan->subchannel[5].memoryToMemoryFormat.BufferTransfer.notify	= NV_OS_WRITE_THEN_AWAKEN;
#else 


			pMyNvChan->subchannel[5].nv03MemoryToMemoryFormat.OffsetIn	= offsetStartByte;
			//pMyNvChan->subchannel[5].nv03MemoryToMemoryFormat.OffsetOut = (unsigned long)pTheTransfer->DestMDL->ByteOffset;
			pMyNvChan->subchannel[5].nv03MemoryToMemoryFormat.OffsetOut = 0;
			pMyNvChan->subchannel[5].nv03MemoryToMemoryFormat.PitchIn	= linePitch;	// use the pitch in so that we can do interleaved
			if(!bVbiSurf) {
				pMyNvChan->subchannel[5].nv03MemoryToMemoryFormat.PitchOut	= lineLength * 2;  // use line lenght on pitch out so that it squishes together
				pMyNvChan->subchannel[5].nv03MemoryToMemoryFormat.LineLengthIn = lineLength * 2;	// remember there are two bytes per pixel 
			} else {
				pMyNvChan->subchannel[5].nv03MemoryToMemoryFormat.PitchOut	= lineLength;  // use line lenght on pitch out so that it squishes together
				pMyNvChan->subchannel[5].nv03MemoryToMemoryFormat.LineLengthIn = lineLength;	// remember there are two bytes per pixel 
			} 
			pMyNvChan->subchannel[5].nv03MemoryToMemoryFormat.LineCount = lineCount;
			pMyNvChan->subchannel[5].nv03MemoryToMemoryFormat.Format	=  ( 1 | 1 << 8 );
			pMyNvChan->subchannel[5].nv03MemoryToMemoryFormat.BufferNotify	= NV039_NOTIFY_WRITE_THEN_AWAKEN_1;
#endif // NV3_HW
			
			pTheTransfer->transferStatus = PROGRAMMED;
		} else {
			// there are no more transfers in the queue. or something bad happened
		
		}
		return;
	}
}

pTransfer FindTransfer(U032 TransferID) {
	U032 i;
	for(i=0;i<MAXTRANSFERS;i++) {
		if(MySurfaces.MyTransfers[i].TransferID == TransferID ) {
			return &(MySurfaces.MyTransfers[i]);
		}
	}
	return NULL;
}

U032 RemoveTransfer(U032 TransferID) {
	U032 i;
	for(i=0;i<MAXTRANSFERS;i++) {
		if(MySurfaces.MyTransfers[i].TransferID == TransferID ) {
			DeleteTransfer(&MySurfaces.MyTransfers[i]);
			return 0;
		}
	}
	return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vdd\nv4\vddi2c.h ===
/*----------------------------------------------------------------------------*/
/*
 * vddi2c.h
 *
 */

/* 
 * common defines and typedefs so we don't have to include all the windows stuff 8
 */

#ifndef FALSE
#define	FALSE	0
#endif

#ifndef TRUE
#define	TRUE	1
#endif

typedef unsigned int	UINT;
typedef unsigned char	UCHAR;
typedef unsigned short	USHORT;
typedef unsigned long	ULONG;

typedef long		NTSTATUS;	/* from ntdef.h in Win98 DDK */
typedef void*		PDEVICE_OBJECT; /* since we don't use this object */

/* from ntstatus.h */
#define STATUS_SUCCESS                   ((NTSTATUS)0x00000000L) // ntsubauth
#define STATUS_OPEN_FAILED               ((NTSTATUS)0xC0000136L)
#define STATUS_INVALID_HANDLE            ((NTSTATUS)0xC0000008L)    // winnt
#define STATUS_ADAPTER_HARDWARE_ERROR    ((NTSTATUS)0xC00000C2L)
#define STATUS_INVALID_PARAMETER         ((NTSTATUS)0xC000000DL)
#define STATUS_DEVICE_BUSY               ((NTSTATUS)0x80000011L)


/*----------------------------------------------------------------------------*/
/*
 * XXX	The relevant portion of i2c.h (from either the nt5 ddk or win98 ddk) is 
 *	copied here so we don't have to include i2c.h explicitly.  This is not 
 *	good but including i2c.h is difficult.
 */

// used below if neccessary
#ifndef BYTE
#define BYTE UCHAR
#endif
#ifndef DWORD
#define DWORD ULONG
#endif

//
// I2C section
//
// I2C Commands
#define I2C_COMMAND_NULL         0X0000
#define I2C_COMMAND_READ         0X0001
#define I2C_COMMAND_WRITE        0X0002
#define I2C_COMMAND_STATUS       0X0004
#define I2C_COMMAND_RESET        0X0008

// The following flags are provided on a READ or WRITE command
#define I2C_FLAGS_START          0X0001 // START + addx
#define I2C_FLAGS_STOP           0X0002 // STOP
#define I2C_FLAGS_DATACHAINING   0X0004 // STOP, START + addx 
#define I2C_FLAGS_ACK            0X0010 // ACKNOWLEDGE (normally set)

// The following status flags are returned on completion of the operation
#define I2C_STATUS_NOERROR       0X0000  
#define I2C_STATUS_BUSY          0X0001
#define I2C_STATUS_ERROR         0X0002

typedef struct _I2CControl {
        ULONG Command;          // I2C_COMMAND_*
        DWORD dwCookie;         // Context identifier returned on Open
        BYTE  Data;             // Data to write, or returned byte
        BYTE  Reserved[3];      // Filler
        ULONG Flags;            // I2C_FLAGS_*
        ULONG Status;           // I2C_STATUS_*
        ULONG ClockRate;        // Bus clockrate in Hz.
} I2CControl, *PI2CControl;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vdd\common\vpvdd.c ===
/***************************************************************************\
* (C) Copyright NVIDIA Corporation Inc.,                                    *
*  1996,1997, 1998. All rights reserved.                                    *
* THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO       *
* NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY  *
* IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.                *
*                                                                           *
* Module: vpvdd.c                                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       schaefer           4/22/98                                          *
*                                                                           *
\***************************************************************************/

#ifdef NV4_HW
#define NV4
#endif
#ifdef NV10_HW
#define NV4
#endif

// MS includes
#include "windows.h"
#include "ddraw.h"
#include "Ddrawp.h"
#include "ddrawi.h"
#include "nvPusher.h"
#include "ddmini.h"
#include "dvp.h"
#include "dmemmgr.h"
//  vdd specific MS includes
#include "minivdd.h"
#include "ddkmmini.h"


// NV includes
#include "nvwin32.h"
#include "nvhw.h"
#include <nv_ref.h>
// unit specific includes
#define RESMANSIDE
#include "surfaces.h"
#include "vddsurfs.h"
#include "vpvdd.h"
#include "vddsurfs.h"
#include "transfer.h"
#include "nvrmr0api.h"


extern vpSurfaces 			MySurfaces;
extern NvNotification		nvMyVPNotifiers[NUMVPNOTIFIERS];

U032 vddWriteVPEPrescale(U032 ulX, U032 ulY, U032 ulCap, U032 ulVPUseOverlay, U032 ulFlag);

U032	vddGetIRQInfo(U032 dwMiniVDDContext, U032 dummy, DDGETIRQINFO* pGetIrgInfo) {
/*
;   DESCRIPTION: If the Mini VDD is already managing the IRQ, this
;          function returns that information; otherwise, it returns the
;          IRQ number assigned to the device so DDraw can manage the IRQ.
;
;          The returning the IRQ number, it is important that it get the
;          value assigned by the Config Manager rather than simply get
;          the value from the hardware (since it can be remapped by PCI).
*/
	// Not gonna do it.... 
	pGetIrgInfo->dwFlags =IRQINFO_HANDLED;
	
	return 0;
}

U032	vddIsOurIRQ(U032 dwMiniVDDContext, U032 dummy) {
/*
;   DESCRIPTION: Called when the VDD's IRQ handled is triggered.  This
;          determines if the IRQ was caused by our VGA and if so, it
;          clears the IRQ and returns which event(s) generated the IRQ.
*/

	return 1;
}

U032	vddEnableIRQ(U032 dwMiniVDDContext, DDENABLEIRQINFO* pEnableIrqInfo, U032 dummy) {
/*
;   DESCRIPTION: Notifies the Mini VDD which IRQs should be enabled.  If
;          a previously enabled IRQ is not specified in this call,
;          it should be disabled.
*/


  //  Here's where we're going to call NvRmR0interrupt()  
  // the purpose is so that the APIEntry variable will get filled
  // now instead of in the future where we're possibly inside an ISR
  #define NV_WIN_DEVICE                            0x00002002
  if(MySurfaces.pDriverData != 0 ) {
    if(MySurfaces.pDriverData->dwRootHandle != 0 ) { 
      NvRmR0Interrupt (MySurfaces.pDriverData->dwRootHandle, NV_WIN_DEVICE);   
    }
  }                         
  
	// just remember these guys, and check them AFTER we've done the real flips in vddsurfs
#define KMVTON
#ifdef KMVTON
	MySurfaces.DXIRQCallbackSources = pEnableIrqInfo->dwIRQSources;
	MySurfaces.pDXIRQCallback = pEnableIrqInfo->IRQCallback;
	MySurfaces.dwIrqContext = pEnableIrqInfo->dwContext;
	return 0;
#else
	return 1;
#endif

}

U032	vddSkipNextField(U032 dwMiniVDDContext, DDSKIPINFO* pSkipInfo, U032 dummy) {
/*
;   DESCRIPTION: Called when they want to skip the next field, usually
;       to undo a 3:2 pulldown but also for decreasing the frame rate.
;       The driver should not lose the VBI lines if dwVBIHeight contains
;       a valid value.
;
*/
	// heh this one is easy!
	if(pSkipInfo->dwSkipFlags & DDSKIP_SKIPNEXT )
		MySurfaces.bSkipNextField = TRUE;
	else if(pSkipInfo->dwSkipFlags & DDSKIP_ENABLENEXT )
		MySurfaces.bSkipNextField = FALSE;
	else 
		return 1;
	return 0;
}


U032	vddBobNextField(U032 dwMiniVDDContext, DDBOBINFO* pBobInfo, U032 dummy) {
/*
;   DESCRIPTION: Called when "bob" is used and a VPORT VSYNC occurs that does
;       not cause a flip to occur (e.g. bobbing while interleaved).  When
;       bobbing, the overlay must adjust itself on every VSYNC, so this
;       function notifies it of the VSYNCs that it doesn't already know
;       about (e.g. VSYNCs that trigger a flip to occur).
*/

	// this is used to change to the next bob in bob from interleaved...
	// however only really useful during software autoflipping.
	
	// we do hardware, so this does not have utility.

	return 1;
}

U032	vddSetState(U032 dwMiniVDDContext, DDSTATEININFO* pSetStateInfo, DDSTATEOUTINFO* pSetStateInfoOut) {
/*
;   DESCRIPTION: Called when the client wants to switch from bob to weave.
;	The overlay flags indicate which state to use. Only called for interleaved
;   surfaces.
;
;	NOTE: When this is called, the specified surface may not be
;	displaying the overlay (due to a flip).  Instead of failing
;	the call, change the bob/weave state for the overlay that would
;	be used if the overlay was flipped again to the specified surface.
*/
	U032	dwSrcHeight;
	U032	dwDstHeight;
	U032	dwDstWidth;
	U032	dwSrcWidth;
	U032	showInterleavedFields = 0;
	long	srcDeltaX;
	long	srcDeltaY;
	U032 	index;
	U032	dwFormat;
	
	
	DDSURFACEDATA* pCurSurf = (DDSURFACEDATA*) pSetStateInfo->lpSurfaceData;
	//pSetStateInfo->lpVideoPortData;

	pCurSurf->dwOverlayFlags;			// may change
	pCurSurf->dwOverlayOffset;				// what the hell is this?  X,Y  or offset from base, or it's it Precalced from X,Y
													// golly gee I love these docs!
	pCurSurf->lPitch;

	dwSrcHeight = pCurSurf->dwOverlaySrcHeight;
	dwDstHeight = pCurSurf->dwOverlayDestHeight;
	dwDstWidth = pCurSurf->dwOverlayDestWidth;
	dwSrcWidth = pCurSurf->dwOverlaySrcWidth;

	if (!(pCurSurf->dwOverlayFlags & DDOVER_AUTOFLIP)) {
		// we only work in auto flip mode so this is bad!
		
		return 0;
	}
	
	(MySurfaces.pDriverData)->dwOverlaySrcHeight = dwSrcHeight;
	(MySurfaces.pDriverData)->dwOverlayDstHeight = dwDstHeight;
	
	if (dwSrcHeight > dwDstHeight) {
		dwSrcHeight >>= 1; /* We only support vertical shrinking and it can't be by more than .5 */
		if (dwSrcHeight > dwDstHeight) {
 				return DDERR_UNSUPPORTED;
		}    
	}

	
	if ((pCurSurf->dwOverlayFlags & DDOVER_INTERLEAVED) &&
		(pCurSurf->dwOverlayFlags & DDOVER_BOB)) {
 				showInterleavedFields = 1;
 				dwSrcHeight >>= 1;
	}
	
	dwDstWidth = (dwDstWidth + 2) & ~1L;
	dwDstHeight = (dwDstHeight + 2) & ~1L;
	
	srcDeltaX = (dwSrcWidth - 1) << 16;
	srcDeltaX /= dwDstWidth - 1;
	srcDeltaX <<= 4;
	
	srcDeltaY = (dwSrcHeight - 1) << 16;
	srcDeltaY /= dwDstHeight - 1;
	srcDeltaY <<= 4;

	index = 0;

#define NV_VFM_FORMAT_CONTROL_FLIP_BY_MEDIAPORT_0 (0x04000000)
#define NV_VFM_FORMAT_CONTROL_FLIP_BY_MEDIAPORT_1 (0x02000000)
#define NV_VFM_FORMAT_BOBFROMINTERLEAVE           (0x08000000)
	
	dwFormat = NV_VFM_FORMAT_COLOR_LE_Y8V8Y8U8;

	if((pCurSurf->dwOverlayFlags & DDOVER_BOB) && (pCurSurf->dwOverlayFlags & DDOVER_INTERLEAVED) ){
		dwFormat = dwFormat | NV_VFM_FORMAT_BOBFROMINTERLEAVE;
	}

	if (pCurSurf->dwOverlayFlags & DDOVER_AUTOFLIP) {
		dwFormat |= (index ? NV_VFM_FORMAT_CONTROL_FLIP_BY_MEDIAPORT_1 : 
			NV_VFM_FORMAT_CONTROL_FLIP_BY_MEDIAPORT_0);
	}

	(MySurfaces.pDriverData)->OverlayFormat = dwFormat;

	// output
	/*
	typedef struct _DDSTATEOUTINFO {
    DWORD dwSize;
    DWORD dwSoftwareAutoflip;
    DWORD dwSurfaceIndex;
    DWORD dwVBISurfaceIndex;
	} DDSTATEOUTINFO;
	*/

	pSetStateInfoOut->dwSoftwareAutoflip = 0;
	pSetStateInfoOut->dwSurfaceIndex = 0;
	pSetStateInfoOut->dwVBISurfaceIndex = 0;

	// this is called to switch from bob to weave or back again
	return 0;
}

U032	vddLock(U032 dwMiniVDDContext, DDLOCKININFO* pLockInfoIn, DDLOCKOUTINFO* pLockInfoOut) {
/*
;   DESCRIPTION: Called when the client wants to lock the surface to
;	access the frame buffer. The driver doens't have to do anything,
;       but it can if it needs to.
*/

	// we don't need to do anything here because of the way we work
	return 0;
}

U032	vddFlipOverlay(U032 dwMiniVDDContext, DDFLIPOVERLAYINFO* pFlipOverlayInfo, U032 dummy) {
/*
;   DESCRIPTION: Flips the overlay to the target surface.
*/	
	vpSurfaces*	pTheSurfaces = (vpSurfaces*) dwMiniVDDContext;
	DDSURFACEDATA* pCurSurf =	(DDSURFACEDATA*) pFlipOverlayInfo->lpCurrentSurface;
	DDSURFACEDATA* pTargSurf =	(DDSURFACEDATA*) pFlipOverlayInfo->lpTargetSurface;
	DWORD daFlags = pFlipOverlayInfo->dwFlags;
	FIELDTYPE	fieldType = UNKNOWN;
/* 
	YIKES   Ok, until I can break throught the mind lock of BMAC and be able to modify some of his code to acheieve
	      a sharing of the overlay class object, I'm just going to hacks something together here which will hit registers
			to get this done.   First part will attempt to get 
			
			We might be able to use the infamous "reserved" fields to get things down into here
*/
	//  We do Autoflip pretty much exclusively!
	// but jonka says that dell's gonna want this for their cheesier bt 848 card.  so oh well.
	
	
	// we need to figure out which index the pCurSurf is, and then pass this in
	// also we need to determine if we're doing bob from Interleave
	//U032 	scheduleOverlayFlip(U032 oldSurface,  U032 bIsBobFromInterleave) {
	
	if(daFlags & DDFLIP_EVEN  ) fieldType = EVEN;
	else if(daFlags & DDFLIP_ODD  ) fieldType = ODD;
	
	return scheduleFlipToSurface( pTargSurf, fieldType);

}

U032	vddFlipVideoPort(U032 dwMiniVDDContext, U032* pFlipVideoPort, U032 dummy) {
/*
;   DESCRIPTION: Flips the video port to the target surface.
*/
	//  We do Autoflip pretty much exclusively!
	return 1;
}

U032	vddGetFieldPolarity(U032 dwMiniVDDContext, DDPOLARITYININFO* pGetPolarityInInfo, DDPOLARITYOUTINFO* pGetPolarityOutInfo) {
	U032	returnval;
	
/*
;
;   DESCRIPTION: Returns the polarity of the current field being written
;	to the specified video port.
*/	

//	DPF(" vvv  vddGetFieldPolarity ");
	
	
	
	// we think that EVEN should be true...
	if( GetField() ) {
		pGetPolarityOutInfo->bPolarity = TRUE;
		returnval = 0;
	} else {
		pGetPolarityOutInfo->bPolarity = FALSE;
		returnval = 0;
	}
	MarkTiming (CHECKCURFLD,0, makeInd(INCNOTAP,pGetPolarityOutInfo->bPolarity,INCNOTAP,MySurfaces.curImageSurf));

	return returnval;
}


U032	vddSetSkipPattern(U032 dwMiniVDDContext, DDSETSKIPINFO* pSetSkipInfo, U032 dummy) {
/*
;
;   DESCRIPTION: Sets the skip pattern in hardware
;
*/
	return 1;
}

U032	vddGetCurrentAutoFlip(U032 dwMiniVDDContext, DDGETAUTOFLIPININFO* pGetAutoFlipInfoIn, DDGETAUTOFLIPOUTINFO* pGetAutoFlipInfoOut) {
/*
;   DESCRIPTION: Returns the current surface receiving data from the
;	video port while autoflipping is taking palce.  Only called when
;   hardware autoflipping.
;
*/
#if 0
	pGetAutoFlipInfoOut->dwSurfaceIndex = MySurfaces.curImageSurf;
	pGetAutoFlipInfoOut->dwVBISurfaceIndex = MySurfaces.curVBISurf  - MySurfaces.VBIstart;
#endif //0

	// first count the number of buffers that we have "in progress"
	// there should always be at least one in progress, and possibly two.
	// if there are zero in progress, then we're not capturing at this moment
	// so it's ok to return a faulty value
	long curIMG;
	long curVBI;
	long countVBI = -1;
	long countIMG = -1;

#ifndef NV4
	if( nvMyVPNotifiers[notifyIndexFromBuffer(0)].status == NV_STATUS_IN_PROGRESS )
		countIMG++;
	if( nvMyVPNotifiers[notifyIndexFromBuffer(1)].status == NV_STATUS_IN_PROGRESS )
		countIMG++;
	if( nvMyVPNotifiers[notifyIndexFromBuffer(2)].status == NV_STATUS_IN_PROGRESS )
		countVBI++;
	if( nvMyVPNotifiers[notifyIndexFromBuffer(3)].status == NV_STATUS_IN_PROGRESS )
		countVBI++;
#else
	if( nvMyVPNotifiers[notifyIndexFromBuffer(0)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS )
		countIMG++;
	if( nvMyVPNotifiers[notifyIndexFromBuffer(1)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS )
		countIMG++;
	if( nvMyVPNotifiers[notifyIndexFromBuffer(2)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS )
		countVBI++;
	if( nvMyVPNotifiers[notifyIndexFromBuffer(3)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS )
		countVBI++;
#endif

	// now subtract this from 	the official current count, but add one since it's not the "next" buffer but the "current"
	curIMG = MySurfaces.curImageSurf - countIMG;
	curVBI = MySurfaces.curVBISurf - MySurfaces.VBIstart - countVBI;
	// now check for reverse wraparound
	if( MySurfaces.VBIstart > 0 )
		while(curIMG < 0 )
			curIMG = curIMG + MySurfaces.VBIstart;
	if( (MySurfaces.numberOfSurfaces - MySurfaces.VBIstart) > 0 )
		while(curVBI < 0 )
			curVBI = curVBI + (MySurfaces.numberOfSurfaces - MySurfaces.VBIstart);
		
	pGetAutoFlipInfoOut->dwSurfaceIndex = curIMG;
	pGetAutoFlipInfoOut->dwVBISurfaceIndex = curVBI;

	MarkTiming (CHECKCURBUF,0, makeInd(INCNOTAP,curVBI,INCNOTAP,curIMG));

	
	return 0;
}

U032	vddGetPreviousAutoFlip(U032 dwMiniVDDContext, DDGETAUTOFLIPININFO* pGetAutoFlipInfoIn, DDGETAUTOFLIPOUTINFO* pGetAutoFlipInfoOut) {
/*
;   DESCRIPTION: Returns the surface that received the data from the
;	previous field of video port while autoflipping is taking palce. Only
;   called for hardware autoflipping.
;
*/
	
	// This code is not quite working right....
	
	// first count the number of buffers that we have "in progress"
	// there should always be at least one in progress, and possibly two.
	// if there are zero in progress, then we're not capturing at this moment
	// so it's ok to return a faulty value
	long curIMG;
	long curVBI;
	long countVBI = -1;
	long countIMG = -1;
#ifndef NV4
	if( nvMyVPNotifiers[notifyIndexFromBuffer(0)].status == NV_STATUS_IN_PROGRESS )
		countIMG++;
	if( nvMyVPNotifiers[notifyIndexFromBuffer(1)].status == NV_STATUS_IN_PROGRESS )
		countIMG++;
	if( nvMyVPNotifiers[notifyIndexFromBuffer(2)].status == NV_STATUS_IN_PROGRESS )
		countVBI++;
	if( nvMyVPNotifiers[notifyIndexFromBuffer(3)].status == NV_STATUS_IN_PROGRESS )
		countVBI++;
#else
	if( nvMyVPNotifiers[notifyIndexFromBuffer(0)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS )
		countIMG++;
	if( nvMyVPNotifiers[notifyIndexFromBuffer(1)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS )
		countIMG++;
	if( nvMyVPNotifiers[notifyIndexFromBuffer(2)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS )
		countVBI++;
	if( nvMyVPNotifiers[notifyIndexFromBuffer(3)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS )
		countVBI++;
#endif
	// now subtract this from 	the official current count but subtract an additional since this is
	// the "previous" autoflip
	
	curIMG = MySurfaces.curImageSurf - countIMG -1;
	curVBI = MySurfaces.curImageSurf - MySurfaces.VBIstart - countVBI -1;
	// now check for reverse wraparound
	while(curIMG < 0 )
		curIMG = curIMG + MySurfaces.VBIstart;
	while(curVBI < 0 )
		curVBI = curVBI + (MySurfaces.numberOfSurfaces - MySurfaces.VBIstart);
		
	pGetAutoFlipInfoOut->dwSurfaceIndex = curIMG;
	pGetAutoFlipInfoOut->dwVBISurfaceIndex = curVBI;


	MarkTiming (CHECKLASTBUF,0, makeInd(INCNOTAP,curVBI,INCNOTAP,curIMG) );
	return 0;
}


		

U032	vddTransfer(U032 dwMiniVddContext, DDTRANSFERININFO* pTransferInInfo, DDTRANSFEROUTINFO* pTransferOutInfo ) {
	pTransfer	pNewTransfer;
	U032			surfIndex = 99;

	// we don't do AGP transfers
	if(DDTRANSFER_NONLOCALVIDMEM & pTransferInInfo->dwTransferFlags ) {
		return 1;
	}
	
	// we DO handle cancels for things not yet queued
	if(DDTRANSFER_CANCEL & pTransferInInfo->dwTransferFlags ) {
		return CancelTransfer(pTransferInInfo);
	}
	
	ASSERT(pTransferInInfo != NULL );
	ASSERT(pTransferInInfo->dwSize == sizeof(DDTRANSFERININFO));

	NULL;
	
	pNewTransfer = AddTransfer(pTransferInInfo->dwTransferID);
	if(pNewTransfer == NULL )
		return 1;
		
	NULL;
	

#ifndef DDTRANSFER_HALFLINES
#define DDTRANSFER_HALFLINES 0x00000100
#endif
	
	if(DDTRANSFER_HALFLINES & pTransferInInfo->dwTransferFlags ) {
		pNewTransfer->StartLine = pTransferInInfo->dwStartLine;
		pNewTransfer->EndLine = pTransferInInfo->dwEndLine;
	} else {
		pNewTransfer->StartLine = pTransferInInfo->dwStartLine+1;
		pNewTransfer->EndLine = pTransferInInfo->dwEndLine+1;
	}
	
	pNewTransfer->SurfaceData = pTransferInInfo->lpSurfaceData;
	pNewTransfer->TransferFlags = pTransferInInfo->dwTransferFlags;
	pNewTransfer->DestMDL = pTransferInInfo->lpDestMDL;
	pNewTransfer->transferStatus = QUEUED;
			
	CheckForLaunch();
	{
		surfIndex = getSurfaceIndex(((DDSURFACEDATA*) pTransferInInfo->lpSurfaceData)->fpLockPtr);
		
		if(surfIndex != 99 ) {
			if( MySurfaces.Surfaces[surfIndex]->field == EVEN ) {
				pTransferOutInfo->dwBufferPolarity = TRUE;
			} else {
				pTransferOutInfo->dwBufferPolarity = FALSE;
			}
		} else {
			// can't tell what surface we were on... just report one
			pTransferOutInfo->dwBufferPolarity = TRUE;
		}
		
		// Hack.... for whatever reason, then VBI surface polarities appear to be reversed... hack the fix in
		if (surfIndex < MySurfaces.VBIstart) {
			// do nothing... 'tho these may be reversed as well
		} else {
			if( pTransferOutInfo->dwBufferPolarity )
				pTransferOutInfo->dwBufferPolarity = FALSE;
			else 
				pTransferOutInfo->dwBufferPolarity = TRUE;
		}
		
	}
	//pTransferOutInfo->dwBufferPolarity = 0;
	if (surfIndex < MySurfaces.VBIstart) {
		MarkTiming(TRANSBUFTYPE,(U032)pTransferInInfo->lpDestMDL->lpMappedSystemVa,makeInd2(INCNOTAP,INCNOTAP, INCNOTAP,surfIndex,MySurfaces.Surfaces[surfIndex]->field) );
	} else if(surfIndex < MySurfaces.numberOfSurfaces){
		MarkTiming(TRANSBUFTYPE,(U032)pTransferInInfo->lpDestMDL->lpMappedSystemVa,makeInd2(INCNOTAP,surfIndex,INCNOTAP,INCNOTAP, MySurfaces.Surfaces[surfIndex]->field,) );
	} else {
		MarkTiming(TRANSBUFTYPE,(U032)pTransferInInfo->lpDestMDL->lpMappedSystemVa,makeInd2(INCNOTAP,surfIndex,INCNOTAP,INCNOTAP,UNKNOWN) );
	}
	
	return 0;
}

U032 vddGetTransferStatus(U032 dwMiniVddContext, U032 dummy, DDGETTRANSFERSTATUSOUTINFO* pGetTransStatusInfo ) {
	U032 retValue;
	// return 0 means everything ok  1 means not good.

#if 0
// Input to vddGetTransferStatus
typedef struct _DDGETTRANSFERSTATUSOUTINFO {
    DWORD dwSize;
    DWORD dwTransferID;
} DDGETTRANSFERSTATUSOUTINFO;

	
#endif
	pTransfer pTheTransfer;
	pTheTransfer = FindTransfer(MySurfaces.dwMostRecentFinishTransferId);
	retValue = 1;
	if(pTheTransfer != NULL ) {
		switch (pTheTransfer->transferStatus) {
				case QUEUED:	
					pGetTransStatusInfo->dwTransferID = MySurfaces.dwMostRecentFinishTransferId;			
					retValue = 1;
				case PROGRAMMED:				
					pGetTransStatusInfo->dwTransferID = MySurfaces.dwMostRecentFinishTransferId;			
					retValue = 1;
				case FINISHED:	
					pGetTransStatusInfo->dwTransferID = MySurfaces.dwMostRecentFinishTransferId;			
					retValue = 0;
					
		}
		RemoveTransfer(MySurfaces.dwMostRecentFinishTransferId);
		MySurfaces.dwMostRecentFinishTransferId = TRANSFERNOTINUSE;
	} else {
		retValue = 1;
	}
	
	// this should error as well
	return retValue;
} 


/*
 * nvVPECommand() is a backdoor function to allow other Ring0 programs (like WDM)
 * to change or request various VPE functions.
 */

#define NV_VPE_CMD_SET_PRESCALE_MODE    1
#define NV_VPE_CMD_SET_CROP_MODE        2

ULONG nvVPECommand (
    ULONG cmd,
    PVOID pData )
{

    switch ( cmd ) {

    case NV_VPE_CMD_SET_PRESCALE_MODE:

        /*
         * This command is to allow WDM drivers to tell VPE to prescale
         * as oppose to cropping.  This is because the overlay mixer does
         * not seem to pass on this information to us.
         */

        {
            PI2CControl	pI2CCtrl = pData;

            /*
             * set prescale flag and size
             */
			//Data(lower nibble)	=	0	not capturing
			//							1	capturing
			//Data(upper nibble)	=	2	X scale
			//							4	Y scale
			//Status	=	prescale/height * 1000
			if((pI2CCtrl->Data)& 0x40){
				vddWriteVPEPrescale(0, 
									((PI2CControl)pI2CCtrl)->Status,//set Y-prescale 
									((PI2CControl)pI2CCtrl)->Data,	//capture flag
									0, 
									6);								//prog. y-pre & cap. flag
			}else if((pI2CCtrl->Data)& 0x20){
				vddWriteVPEPrescale(((PI2CControl)pI2CCtrl)->Status,//set X-prescale
									0, 
									((PI2CControl)pI2CCtrl)->Data,	//capture flag
									0, 
									0xa);							//prog. x-pre & cap.flag
			}else{
				//error
			}
        }
        break;

    case NV_VPE_CMD_SET_CROP_MODE:

        /*
         * This command is to allow WDM drivers to tell VPE to crop
         * as oppose to prescaling.  This is because the overlay mixer does
         * not seem to pass on this information to us.
         */

        {
            PI2CControl	pI2CCtrl = pData;

            /*
             * turn off prescale flag
             */

        }
        break;

    default:
        return 1;   
    }

    return 0;
}

void vddVPEInit()
{
	//Initialize VPE capture hack for WDM
	vddWriteVPEPrescale(1000,	//setting ME X-prescale factor. 1000=no scale
						1000,	//setting ME Y-prescale factor. 1000=no scale
						0,		//set default VP surf type = overlay  
						1,		//set to not vpe capture mode
						0xf);	//use all values

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vxd\AVXDSTUB.ASM ===
;
;  (C) Copyright NVIDIA Corporation Inc., 1995,1996. All rights reserved.
;
;********* Operating System Interface for NVidia Resource Manager **********;
;                                                                           ;
; Module: VXDSTUB.ASM                                                       ;
;       These routines provide an operating system independent layer        ;
;       between the Resource Manager and the underlying OS APIs.            ;
;                                                                           ;
;---------------------------------------------------------------------------;
;                                                                           ;
; History:                                                                  ;
;        David Schmenk (dschmenk)     11/17/93 - wrote it                   ;
;        David Schmenk (dschmenk)     06/15/94 - rewrote for real RM        ;
;        JohnH                        10/3/97 - rewrote for MS tools--      ;
;                                     include DDB and service table here    ;
;*********************** Copyright 1993 NVidia, Inc. ***********************;

.386p

INCLUDE BASEDEF.INC
INCLUDE VMM.INC
INCLUDE VWIN32.INC
INCLUDE VPICD.INC
INCLUDE V86MMGR.INC
INCLUDE VNVRMD.INC
INCLUDE DEBUG.INC
;include         ..\..\..\..\..\sdk\nvidia\inc\rddapi.inc


VxD_LOCKED_DATA_SEG
PUBLIC  dwSrcLinearPageNum, dwDstLinearPageNum, dwLinearRegionSizeInPages, dwPageDirectoryBaseRegLinear
dwSrcLinearPageNum              DD      0
dwDstLinearPageNum              DD      0
dwLinearRegionSizeInPages       DD      0
dwPageDirectoryBaseRegLinear    DD      0

PUBLIC  dwPageTableEntry
dwPageTableEntry                DD      0
PUBLIC	dwGotNulPTE, dwNulPTE
dwGotNulPTE			DD	0
dwNulPTE			DD	0
VxD_LOCKED_DATA_ENDS


VxD_LOCKED_CODE_SEG

;   The Device Declartation Block

;Declare_Virtual_Device MACRO Name, Major_Ver, Minor_Ver, Ctrl_Proc, Device_Num, Init_Order, V86_Proc, PM_Proc, Reference_Data
;    LOCAL   V86_API_Offset, PM_API_Offset, Serv_Tab_Offset, Serv_Tab_Len, Ref_Data_Offset

Declare_Virtual_Device  NVACORE, NVRM_Major_Version, NVRM_Minor_Version, rmControlEntry, UNDEFINED_DEVICE_ID, UNDEFINED_INIT_ORDER, \
                        ,                    \
                        ,					\
                        ,

;---------------------------------------------------------------------------
;
;  VxD Control entrypoints.
;
;---------------------------------------------------------------------------
EXTRN   _rmAuControl : NEAR
public  rmControlEntry
BeginProc rmControlEntry
;       ebp points to the Client_Regiser_Structure
;       rmControl expects two args: msg, VMh
        push    ebx             ; VMh
        push    eax             ; msg
        call    _rmAuControl
        add     esp,2*4
        or      eax, eax
        stc
        jnz     @F
        clc
@@:     ret
EndProc rmControlEntry

VxD_LOCKED_CODE_ENDS

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vxd\nv_diag.c ===
//
// (C) Copyright NVIDIA Corporation Inc., 1995,1996. All rights reserved.
//
/******************* Operating System Interface Routines *******************\
*                                                                           *
* Module: NV_DIAG.C                                                         *
*         Support module for NV Diagnostic Utility.                         *
*****************************************************************************
*                                                                           *
* History:  Jim Vito (jvito) 3/2/98 - Created.                              *
\***************************************************************************/
#include "basedef.h"
#include "vmmtypes.h"
#include "vmm.h"        // put this first. we redefine macro SF_BIT in nvrm.h
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <dma.h>
#include <fifo.h>
#include <gr.h>
#include <dac.h>
#include <os.h>
#include "nvrmwin.h"
#include "nvhw.h"
#include "vpicd.h"
#include "vdd.h"
#include "vnvrmd.h"
#include "oswin.h"
#include "vmm2.h"       // more vmm services
#include "vwin32.h"

typedef struct _def_NvDumpStruct
{
    V032 nvdump_nvAddr;
    V032 nvdump_romAddr;
    V032 nvdump_fbAddr;
    V032 nvdump_agpAddr;
    V032 nvdump_nvPhys;
    V032 nvdump_fbPhys;
    V032 nvdump_nvIRQ;  
    V032 nvdump_hDev; 
} NV_DUMP_STRUCT;

VOID NvDumpNvData(NV_DUMP_STRUCT *buffer)
{
//////  buffer->nvdump_nvAddr = (U032) nvAddr;
//////  buffer->nvdump_romAddr = (U032) romAddr;
//////  buffer->nvdump_fbAddr = (U032) fbAddr;
//////  buffer->nvdump_agpAddr = (U032) agpAddr;
//////  buffer->nvdump_nvPhys = (U032) nvPhys;
//////  buffer->nvdump_fbPhys = (U032) fbPhys;
//////  buffer->nvdump_nvIRQ = (U032) nvIRQ;  
//////  buffer->nvdump_hDev = (U032) hDev; 
}

VOID NvGetCrtcRegisters(BYTE *buffer)
{
//////  BYTE save_index;
//////  BYTE save_lock_value;
//////  BYTE i;
//////
//////
//////  // Save this register.
//////  _asm mov  dx,0x3c4  
//////  _asm in   al,dx
//////  _asm mov  save_index,al
//////
//////  // Save the lock value.
//////  _asm mov  al,6
//////  _asm out  dx,al
//////  _asm inc  dx
//////  _asm in   al,dx
//////  _asm dec  dx  
//////  _asm mov  save_lock_value,al  
//////
//////  // Unlock the extended registers.
//////  _asm mov  ax,0x5706
//////  _asm out  dx,ax
//////
//////  _asm mov  esi, buffer
//////
//////  for(i=0;i<0x40;i++)
//////  {
//////    _asm mov  al,i
//////    _asm out  dx,al
//////    _asm inc  dx
//////    _asm in   al,dx
//////    _asm dec  dx
//////    _asm mov  [esi], al
//////    _asm inc  esi
//////  }
//////
//////  // Restore the lock value.
//////  _asm mov  al,6
//////  _asm mov  ah,save_lock_value
//////  _asm out  dx,ax
//////
//////  // Restore the CRTC Index.
//////  _asm mov  al,save_index
//////  _asm out  dx,al
//////   
}

VOID NvSetCrtcRegisters(BYTE *buffer)
{
//////  BYTE save_index;
//////  BYTE save_lock_value;
//////  BYTE i;
//////
//////
//////  // Save this register.
//////  _asm mov  dx,0x3c4  
//////  _asm in   al,dx
//////  _asm mov  save_index,al
//////
//////  // Save the lock value.
//////  _asm mov  al,6
//////  _asm out  dx,al
//////  _asm inc  dx
//////  _asm in   al,dx
//////  _asm dec  dx  
//////  _asm mov  save_lock_value,al  
//////
//////  // Unlock the extended registers.
//////  _asm mov  ax,0x5706
//////  _asm out  dx,ax
//////
//////  _asm mov  esi, buffer
//////
//////  for(i=0;i<0x40;i++)
//////  {
//////    // Don't lock these registers
//////    if(i != 6){
//////      _asm mov  al,i
//////      _asm out  dx,al
//////      _asm inc  dx
//////      _asm mov  al,[esi]
//////      _asm out  dx,al
//////      _asm dec  dx
//////      _asm inc  esi
//////    }else
//////      _asm inc  esi
//////  }
//////
//////  // Restore the lock value.
//////  _asm mov  al,6
//////  _asm mov  ah,save_lock_value
//////  _asm out  dx,ax
//////
//////  // Restore the CRTC Index.
//////  _asm mov  al,save_index
//////  _asm out  dx,al
//////   
}

//////DWORD NvIoctlRead(DWORD offset)
//////{
//////
//////  BYTE  *temp1_ptr;
//////  DWORD *temp2_ptr;
//////
//////  temp1_ptr = (BYTE *) nvAddr; 
//////  temp1_ptr += offset;   
//////  temp2_ptr = (DWORD *) temp1_ptr;  
//////  return((DWORD) *temp2_ptr);
//////
//////}

VOID NvIoctlWrite(DWORD offset, DWORD data)
{
//////  BYTE  *temp1_ptr;
//////  DWORD *temp2_ptr;
//////
//////  temp1_ptr = (BYTE *) nvAddr; 
//////  temp1_ptr += offset;   
//////  temp2_ptr = (DWORD *) temp1_ptr;  
//////  *temp2_ptr = data;
}

DWORD OnW32DeviceIoControl(PDIOCPARAMETERS p)
{

//////    switch (p->dwIoControlCode)
//////    {
//////    case 0: 
//////      return 0;
//////    case NVRM_IOCTL_CRTC_GET:   
//////      NvGetCrtcRegisters((BYTE *) p->lpvInBuffer);
//////      return 0;
//////    case NVRM_IOCTL_CRTC_SET:   
//////      NvSetCrtcRegisters((BYTE *) p->lpvInBuffer);
//////      return 0;
//////    case NVRM_IOCTL_DUMPNVDATA:
//////      NvDumpNvData((NV_DUMP_STRUCT *) p->lpvInBuffer);
//////      return 0;
//////    case NVRM_IOCTL_NV_READ:
//////      {
//////        DWORD *tptr;
//////        tptr = (DWORD *) p->cbOutBuffer; 
//////        *tptr = NvIoctlRead(p->cbInBuffer);
//////      }
//////      return 0;
//////    case NVRM_IOCTL_NV_WRITE:
//////      NvIoctlWrite(p->cbInBuffer,p->cbOutBuffer);
//////      return 0;
//////      
//////    case NVRM_IOCTL_CRTC_TEST:
//////      dacEnableCursor(NvDBPtr_Table[0]);
//////    return 0;
//////
//////    default:
//////      return -1;
//////    }

    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vxd\nvdsptch.c ===
//
// (C) Copyright NVIDIA Corporation Inc., 1995,1996. All rights reserved.
//
/******************* Operating System Interface Routines *******************\
*                                                                           *
* Module: NVDSPTCH.C                                                        *
*         This is the VxD Dispatcher for the NvArchitecture                 *  
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Jim Vito (jvito)    03/04/98 - wrote it.                            *
*                                    - and stole from JeffW :)  			*
\***************************************************************************/
#include "basedef.h"
#include "vmmtypes.h"
#include "vmm.h"		// put this first. we redefine macro SF_BIT in nvrm.h
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <dma.h>
#include <fifo.h>
#include <gr.h>
#include <dac.h>
#include <os.h>
#include "nvrmwin.h"
#include "nvhw.h"
#include "vpicd.h"
#include "vdd.h"
#include "vnvrmd.h"
#include "oswin.h"
#include "vmm2.h"		// more vmm services
#include "vwin32.h"
//#include "tempnvos.h"

#include "nvos.h"
#include "nvarch.h"
#include "nv32.h"
#include "nvwin32.h"
#include "nvhw.h"

// Prototypes for WinNT functions added.
// extern CLASS classTable[NUM_CLASSES];

VOID NvArchRMDispatch
(
   U032  function,
   PVOID paramPtr
)
{
  switch (function){
    case NVRM_ARCH_NV01FREE:
	{
      Nv01Free((NVOS00_PARAMETERS *) paramPtr);
	}
    break;
    
    case NVRM_ARCH_NV04ALLOC:
	{
      Nv04Alloc((NVOS21_PARAMETERS *)paramPtr);
	}
    break;
    
    case NVRM_ARCH_NV01ALLOCROOT:
	{
      Nv01AllocRoot((NVOS01_PARAMETERS *)paramPtr);
	}
    break;
    
    case NVRM_ARCH_NV01ALLOCMEMORY:
	{
      Nv01AllocMemory((NVOS02_PARAMETERS *)paramPtr);
	}
    break;

    case NVRM_ARCH_NV01ALLOCCONTEXTDMA:
	{
	  NVOS03_PARAMETERS *parameters;

	  parameters = (NVOS03_PARAMETERS *) paramPtr;
      
      Nv01AllocContextDma(parameters);
	}
    break;

	// For each dispatch to the architecture there should be a methodic process.
    // First add the objects to the architecture object structure.
    case NVRM_ARCH_NV01ALLOCCHANNELPIO:
	{
      Nv01AllocChannelPio((NVOS04_PARAMETERS *)paramPtr);
	}
    break;

    case NVRM_ARCH_NV01ALLOCOBJECT:
	{
	  Nv01AllocObject((NVOS05_PARAMETERS *) paramPtr);
	}
    break;

    case NVRM_ARCH_NV01ALLOCDEVICE:
	{
      Nv01AllocDevice((NVOS06_PARAMETERS *)paramPtr);
	}
    break;

    case NVRM_ARCH_NV03ALLOCCHANNELDMA:
	{
      Nv03AllocChannelDma((NVOS07_PARAMETERS *)paramPtr);
	}
    break;

    case NVRM_ARCH_NV03DMAFLOWCONTROL:
	{
      Nv03DmaFlowControl((NVOS08_PARAMETERS *)paramPtr);
	}
    break;


    case NVRM_ARCH_NV01INTERRUPT:
	{
      Nv01Interrupt((NVOS09_PARAMETERS *)paramPtr);
	}
    break;

    case NVRM_ARCH_NV01ALLOCEVENT:
	{
	  Nv01AllocEvent((NVOS10_PARAMETERS *) paramPtr);
	}
    break;

    case NVRM_ARCH_NV03HEAP:
	{
	  Nv03ArchHeap((NVOS11_PARAMETERS *) paramPtr);
	}
    break;

    case NVRM_ARCH_CONFIG_VERSION:
	{
      Nv01ConfigVersion((NVOS12_PARAMETERS *)paramPtr);
	}
    break;

    case NVRM_ARCH_CONFIG_GET:
	{
      Nv01ConfigGet((NVOS13_PARAMETERS *)paramPtr);
	}
    break;

    case NVRM_ARCH_CONFIG_SET:
	{
      Nv01ConfigSet((NVOS14_PARAMETERS *)paramPtr);
	}
    break;

    case NVRM_ARCH_CONFIG_UPDATE:
	{
      Nv01ConfigUpdate((NVOS15_PARAMETERS *)paramPtr);
	}
    break;

    case NVRM_ARCH_RING0CALLBACK:
	{
      NvRing0Callback((NVRM_RING0CALLBACK_PARAMS *)paramPtr);
	}
    break;

    case NVRM_ARCH_CONFIG_GET_EX:
    {
      Nv04ConfigGetEx((NVOS_CONFIG_GET_EX_PARAMS *)paramPtr);
    }
    break;

    case NVRM_ARCH_CONFIG_SET_EX:
    {
      Nv04ConfigSetEx((NVOS_CONFIG_SET_EX_PARAMS *)paramPtr);
    }
    break;

    case NVRM_ARCH_I2C_ACCESS:
    {
      Nv04I2CAccess((NVOS_I2C_ACCESS_PARAMS *)paramPtr);
    }
    break;

    default:
    break;
  }
} // end of NvArchRMDispatch
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vxd\OS.C ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/
/******************* Operating System Interface Routines *******************\
*                                                                           *
* Module: OS.C                                                              *
*   This is the OS interface module.  All operating system transactions     *
*   pass through these routines.  No other operating system specific code   *
*   or data should exist in the source.                                     *
*                                                                           *
\***************************************************************************/
//
// Another great undocumented feature of windows.  You must including these
// defines to be able to include configmg.h
//
#define CAT_HELPER(x, y)    x##y
#define CAT(x, y)       CAT_HELPER(x, y)
#define MAKE_HEADER(RetType, DecType, Function, Parameters)

#include "basedef.h"
#include "vmm.h"
#include "vmmreg.h"
#include "vpicd.h"
#include "configmg.h"
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <dma.h>
#include <gr.h>
#include <mc.h>
#include <os.h>
#include <vga.h>
#include <tv.h>
#include <dac.h>
#include "nvrmwin.h"
#include "nvhw.h"
#include "vnvrmd.h"
#include "oswin.h"
#include "vdd.h"
#include "vmmtypes.h"
#include "vmm2.h"       // more vmm services
#include "nvwin32.h"
#include "nvos.h"
#include "vesadata.h"
#include "nvcm.h"
#include "edid.h"

#ifdef DEBUG
#include <vcomm.h>
#include "osdbg.h"
#include "serial.h"
#endif

#ifdef DEBUG
U032 thread_watcher;
#endif

//
// OS names.
//
char nameVideoSink[]        = "CON:";
char nameImageVideo[]       = "WND";
char nameLeft[]             = "\\LEFT";
char nameRight[]            = "\\RIGHT";
char nameSysMem[]           = "SYSMEM:";
char nameLVidMem[]          = "LOCALVIDMEM:";
char nameSVidMem[]          = "NONLOCALVIDMEM:";

//
// Define registry keys for timing parameters.
//
#ifdef OBSOLETE_FUNCTIONS
char strTimingParm0[]    = "TimingParm0";
char strTimingParm1[]    = "TimingParm1";
char strTimingChecksum[] = "TimingChecksum";
char strPBUSOverride[]   = "PBUSOverride";
char strUnderscanXOverride[]  = "UnderscanX";
char strUnderscanYOverride[]  = "UnderscanY";
#endif // OBSOLETE_FUNCTIONS
char strRefreshOverride[] = "RefreshOverride";
char strTilingOverride[] = "TilingOverride";
char strMemoryOverride[] = "MemoryOverride";
char strRTLOverride[]    = "RTLOverride";
char strFetchTriggerOverride[] = "FetchTrigger";
char strFetchSizeOverride[]    = "FetchSize";
char strFetchMaxReqsOverride[] = "FetchMaxReqs";
char strGraphicsDebug0[]        = "GRDEBUG0";
char strGraphicsDebug1[]        = "GRDEBUG1";
char strGraphicsDebug2[]        = "GRDEBUG2";
char strGraphicsDebug3[]        = "GRDEBUG3";

extern char strDevNodeRM[];
extern char strMaxRefreshRate[];
extern char strMaxOptimalRefreshRate[];
extern char strOptimalNotFromEDID[];
extern char strDMTOverride[];
extern char strMonitorTiming[];
extern char strCursorCacheOverride[];
extern char strDisplayType[];
extern char strDisplay2Type[];
extern char strTVtype[];
extern char strStartUp[];
extern char strTVOutType[];
extern char strNewModeSet[];
extern char strFpMode[];


#ifdef ON_NOW
extern U008 PowerOff;
#endif
//
// Service stack.
//
U032 *rmStack;
U032 *rmStackBase;
U032 vmmStack;
U032 tempStack;
//
// Hack
//
static U008 NopMask;


#ifdef DEBUG_TIMING

#define DEBUG_FRAMES 16

U032 dbgFrame ;
U032 dbgStart ;
U032 dbgStartInt[DEBUG_FRAMES][20];
U032 dbgEndInt[DEBUG_FRAMES][20];
U032 dbgCountInt[DEBUG_FRAMES];
#endif // DEBUG_TIMING

//
// Some quick and dirty library functions.
// This is an OS function because some operating systems supply their
// own version of this function that they require you to use instead
// of the C library function.  And some OS code developers may decide to
// use the actual C library function instead of this code.  In this case,
// just replace the code within osStringCopy with a call to the C library
// function strcpy.
//
char *osStringCopy
(
    char *dst,
    const char *src
)
{
    char *dstptr = dst;
    
    while (*dstptr++ = *src++);
    return (dst);
}

U032 osStringLength(const char * str)
{
    U032 i = 0;
    while (str[i++] != '\0');
    return i - 1;
}

S032 osStringCompare
(
    const char *s1,
    const char *s2
)
{
    while (*s1 && *s2)
    {
        if (*s1++ != *s2++)
            return (0);
    }
    return (!(*s1 || *s2));
}

/*****************************************************************************
 * fastish memcopy code - begin
 *
 *  osMemCopy 
 *   - optimal performance will have src and dst 4-byte aligned
 *   - the compiler does not even TRY to optimize this code... bad switch?
 */
void __declspec(naked) __stdcall __osMemCopy4
(
    U032 dst,
    U032 src,
    U032 len4   // u032 count
)
{
/*
    while (len4)
    {
        *(U032*)dst = *(U032*)src;
        src  += 4;
        dst  += 4;
        len4 -= 4;
    }
*/
    __asm
    {
        push esi
        push edi

        mov ecx,[esp + 20]
        mov esi,[esp + 16]
        shr ecx,2
        mov edi,[esp + 12]

        rep movsd

        pop edi
        pop esi
        ret 12
    }
}

void __declspec(naked) __stdcall  __osMemCopy1
(
    U032 dst,
    U032 src,
    U032 len    // u008 count
)
{
/*
    while (len)
    {
        *(U008*)dst = *(U008*)src;
        src ++;
        dst ++;
        len --;
    }
*/
    __asm
    {
        push esi
        push edi

        mov ecx,[esp + 20]
        mov esi,[esp + 16]
        mov edi,[esp + 12]

        rep movsb

        pop edi
        pop esi
        ret 12
    }
}

unsigned char * osMemCopy
(
          unsigned char *dst,
    const unsigned char *src,
          U032           len    // u008 count
)
{
    if (len >= 16)
    {
        __osMemCopy4 ((U032)dst,(U032)src,len & ~3);
        src += len & ~3;
        dst += len & ~3;
        __osMemCopy1 ((U032)dst,(U032)src,len &  3);
    }
    else
    {
        __osMemCopy1 ((U032)dst,(U032)src,len);
    }

    return dst;
}
/*
 * fastish memcopy code - end
 *****************************************************************************/

RM_STATUS osReleaseFifoSemaphore()
{
    return RM_OK;
}

RM_STATUS osRequestFifoSemaphore()
{
    return RM_OK;
}

//---------------------------------------------------------------------------
//
//  Operating System Memory functions.
//
//---------------------------------------------------------------------------

#ifdef OBSOLETE_FUNCTIONS
U032 osSetContext
(
    U032 ProcContext
)
{
    U032 CurrContext;

    CurrContext = (U032)vmmGetCurrentContext();
    if ((ProcContext) && (CurrContext != ProcContext))
    {
        DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "osSetContext: Current Context  = ",CurrContext);
        DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "              Process Context  = ",ProcContext);
        return ((U032)vmmContextSwitch((DWORD) ProcContext));
    }
    //
    // No context switch required.
    //    
    return (0);
}
RM_STATUS osResetContext
(
    U032 OriginalContext
)
{
    if (OriginalContext)
        vmmContextSwitch((DWORD) OriginalContext);
    return (RM_OK);
}
#endif // OBSOLETE_FUNCTIONS

RM_STATUS  osCopyIn
(
	U008 *src, 
	U008 *target,
	U032 count
)
{
	//*target = src;

	osMemCopy(target, src, count);

	return(RM_OK);
}

RM_STATUS  osCopyOut
(
	U008 *src,
	U008 *target,
	U032 count
)
{
	osMemCopy(target, src, count);

	return(RM_OK);
}

RM_STATUS osAllocMem
(
    VOID **pAddress,
    U032   Size
)
{
    RM_STATUS status = RM_OK;

#ifdef DEBUG
    U008     *pMem;
#endif // DEBUG

#ifndef DEBUG
//    *pAddress = vmmHeapAllocate(Size + 4, 0);
    *pAddress = _HeapAllocate(Size + 4, 0);
    if (*pAddress != NULL)
    {
        **(U032 **)pAddress           = Size;
        *(U032 *)pAddress            += 4;
#else
    Size += 12;
//    *pAddress = vmmHeapAllocate(Size, 0);
    *pAddress = _HeapAllocate(Size + 4, 0);
    if (*pAddress != NULL)
    {
        **(U032 **)pAddress                     = Size;
        *(U032 *)(*(U032 *)pAddress + 4)        = NV_MARKER1;
        *(U032 *)(*(U032 *)pAddress + Size - 4) = NV_MARKER2;
        *(U032 *)pAddress += 8;
        pMem = (U008 *)*pAddress;
        Size -= 12;
        while (Size--)
            *pMem++ = 0x69;
#endif // DEBUG
    }
    else
    {
        status = RM_ERR_NO_FREE_MEM;
    }
    return (status);
}
RM_STATUS osFreeMem
(
    VOID *pAddress
)
{
    RM_STATUS status;
    U032      Size;
    
    if(!pAddress)
    {
#ifdef DEBUG
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Error: Null pointer called to osFreeMem.\n\r");
#endif // DEBUG    
        return (RM_OK);
    }    
    
#ifndef DEBUG
    pAddress = (VOID *)((U032)pAddress - 4);
    Size     = *(U032 *)pAddress;
#else
    pAddress = (VOID *)((U032)pAddress - 8);
    Size     = *(U032 *)pAddress;
    if (*(U032 *)((U032)pAddress + 4) != NV_MARKER1)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM:Invalid address to osFreeMem.\n\r");
        DBG_BREAKPOINT();
    }
    if (*(U032 *)((U032)pAddress + Size - 4) != NV_MARKER2)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM:Memory overrun in structure to osFreeMem.\n\r");
        DBG_BREAKPOINT();
        return (RM_ERR_MEM_NOT_FREED);
    }
    *(U032 *)((U032)pAddress + 4)        = 'DAED';
    *(U032 *)((U032)pAddress + Size - 4) = 'DEAD';
    Size -= 12;
#endif // DEBUG    
//    if (vmmHeapFree((BYTE *)pAddress, 0) == 0)
    if (_HeapFree((BYTE *)pAddress, 0) == 0)
      {
        status = RM_ERR_MEM_NOT_FREED;
    }
    else
    {
        status = RM_OK;
    }
    return (status);
}

#define CPUID   __asm _emit 0x0F __asm _emit 0xA2
#define RDMSR   __asm _emit 0x0F __asm _emit 0x32

#define AGP_APERTURE_SIZE               0x2000000       // 32 MB

//
// osUpdateAGPLimit - determine the write-combined AGP limit
//
// This routine is now called not only at boot time, but anytime a client
// does a ConfigGet for the AGP limit, in case it's changed.
//
RM_STATUS osUpdateAGPLimit
(
    PHWINFO pDev
)
{
	PRMINFO pRmInfo = (PRMINFO) pDev->pRmInfo;

    U032 AGPBase, AGPLimit;
    U032 i, mtrrAddr, numRanges = 0;
    U032 BaseHi, BaseLo, MaskHi, MaskLo;
    RM_STATUS status;
        
    // If the aperture limit/size was established at boot time, just return
    if (pRmInfo->AGP.AGPLimit != 0)
        return RM_OK;

    CLI
    // Get the AGP base and limit from the chipset
    status = NvGetAGPBaseLimit(pDev, &AGPBase, &AGPLimit);
    STI

    if (status != RM_OK)
    {
        pRmInfo->AGP.AGPLimit = AGP_APERTURE_SIZE - 1;     // set to 32MB, by default
        return status;
    }

    // First, check if this processor supports the CPUID inst and MTRRs.
    __asm
    {
        ; save state
        push	eax
        push	ebx
        push	ecx
        push	edx

        pushfd
        pop     eax
        mov     ebx, eax
        xor     eax, 0x00200000
        push    eax
        popfd
        pushfd
        pop     eax
        cmp     eax, ebx
        je      Exit                // CPUID inst not supported

        mov     eax, 1
        CPUID
        and     edx, 0x1000         // check for MTRR support
        jz      Exit

        mov     ecx, 254            // read the MTRRcap MSR to determine number of ranges.
        RDMSR
        test    eax, 0x400          // check that WC as a type is supported (should be 1).
        jz      Exit

        and     eax, 0xFF           // save number of ranges
        mov     numRanges, eax
Exit:    
        pop     edx
        pop     ecx
        pop     ebx
        pop     eax
    }

    if (!numRanges)
    {
        pRmInfo->AGP.AGPLimit = AGPLimit;   // default to the aperture limit
        return RM_ERROR;
    }

    //
    // Now, determine if we find a Write Combined match in the MTRRs. We want
    // the AGP limit to only reflect the WC portion of the AGP aperture.
    //
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Valid MTRRs:\n");
    for (i = 0, mtrrAddr = 512; i < numRanges; i++, mtrrAddr += 2)
    {
        __asm {

            push    eax
            push    ebx
            push    ecx
            push    edx

            mov     ecx, mtrrAddr
            RDMSR

            mov     BaseHi, edx
            mov     BaseLo, eax

            mov     ecx, mtrrAddr
            add     ecx, 1
            RDMSR

            mov     MaskHi, edx
            mov     MaskLo, eax

            pop     edx
            pop     ecx
            pop     ebx
            pop     eax
        }

        if (!(MaskLo & 0x800))
            continue;               // not a valid range

        MaskLo &= ~0xFFF;           // mask off the valid bit

        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Range ", i);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:      Base ", BaseLo);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:    Length ", ~MaskLo + 1);

        // We only care about a Write-Combined range
        if ((BaseLo & 0xFF) != 0x1)
            continue;

        BaseLo &= ~0xFF;           // mask off the type bits

        if ((BaseLo >= AGPBase) && ((BaseLo + ~MaskLo) <= (AGPBase + AGPLimit)))
            pRmInfo->AGP.AGPLimit = ~MaskLo;  // the WC MTRR is within the aperture
    }

    return RM_OK;
}

//
// osAllocPages - Allocate a number of aligned memory pages
//  
//  **pAddress - handle to the linear address
//  PageCount  - number of pages to allocate
//  MemoryType - memory pool
//  Contiguous - contiguous pages?
//  Cache      - cacheing request
//  clientClass- is this a kernel/user allocation??
//  **pMemData - any per-allocation data (useful during a free)
//
RM_STATUS osAllocPages
(
    PHWINFO pDev,
    VOID    **pAddress,
    U032    PageCount,
    U032    MemoryType,
    U032    Contiguous,
    U032    Cache,
    U032    clientClass,
    VOID    **pMemData
)
{
	PRMINFO pRmInfo = (PRMINFO) pDev->pRmInfo;

    RM_STATUS       status;
    DESCRIPTOR      desc;

    status = RM_OK;
    *pMemData = NULL;   // no associated per-alloc data
    
    switch (MemoryType)
    {
    
        case NV_MEMORY_TYPE_SYSTEM:
        
            //
            // Perform VMM page allocation.  System memory arena, system VM, no alignment
            // restrictions, no min/max phys restrictions, no need for the physical address
            // (no fixed request), and no need for contiguous or fixed flags
            //
            if (Contiguous == NV_MEMORY_NONCONTIGUOUS)
            {            
                vmmGetCritSectionStatus();      // complete delayed releases of critical section
                                                // is this really necessary in Win 95?
            
                vmmPageAllocate(PageCount, PG_SYS, 0, 0, 0, 0, 0, 0, &desc.Desc64);
                *pAddress = (VOID *)desc.Desc32[0];
                
                /* MTRR work
                if (Cache == NV_MEMORY_WRITECOMBINED)
                ...
                */
            }                
            else
            {
                *pAddress = NULL;
                status = RM_ERROR;
            }                
            
            break;
            
        case NV_MEMORY_TYPE_AGP:
            
            if ((pDev->Chip.Bus == BUS_AGP) && pRmInfo->AGP.AGPLimit && pRmInfo->AGP.AGPPhysStart &&
                 (pDev->Chip.ReqAGPRate != 0))
            {
                // Need to verify availability of VM services for AGP
                if (Get_VMM_Version() < 0x40A)
                {
                    *pAddress = NULL;
                    return RM_ERROR;
                }                    
                
                //
                // Perform VGARTD (VMM) AGP page reservation.  This device, no alignment
                // restrictions, custom cacheing
                //
                if (Cache == NV_MEMORY_UNCACHED)                    
                    *pAddress = (VOID *)vmmGARTReserve(pDev->Mapping.hDev, PageCount, 0, 0, PG_UNCACHED);
                else if (Cache == NV_MEMORY_WRITECOMBINED) {
                    *pAddress = (VOID *)vmmGARTReserve(pDev->Mapping.hDev, PageCount, 0, 0, PG_WRITECOMBINED);
                } else {
                    *pAddress = NULL;       // unknown Cache type
                    status = RM_ERROR;
                }

                if (*pAddress)
                {
                    // Perform VGARTD (VMM) AGP page commit.  No page offset, no init value
                    if (!vmmGARTCommit((U032)*pAddress, 0, PageCount, 0, 0))
                    {
                        // oops, that didn't work...
                        status = RM_ERROR;
                        vmmGARTFree((U032)*pAddress);
                    } else {
                        U032 i, *bufp = (U032 *)*pAddress;

                        // let's be considerate and zero the just allocated memory
                        for (i = 0; i < ((PageCount * RM_PAGE_SIZE) / sizeof(U032)); i++)
                            *bufp++ = 0x0;

                        // update our notion of how much persistent AGP has been alloced
                        if (Cache == NV_MEMORY_WRITECOMBINED)
                            pRmInfo->AGP.AGPHeapFree += (PageCount << RM_PAGE_SHIFT);
                    }
                }
                else
                {
                    // Out of memory. For persistent AGP allocs, this can happen when not enough was
                    // taken out of DDraw's pool. Just return error status (*pAddress is already NULL).
                    status = RM_ERR_NO_FREE_MEM;
                }
            }
            else
            {
                *pAddress = NULL;
                status = RM_ERROR;
            }
            
            break;
            
    }
    
    return (status);
}

//
// osFreePages - Free a number of aligned memory pages
//  
//  **pAddress - handle to the linear address
//  MemoryType - memory pool
//
RM_STATUS osFreePages
(
    PHWINFO pDev,
    VOID    **pAddress,
    U032    MemoryType,
    U032    PageCount,
    VOID    *pMemData,
    BOOL    IsWriteCombined
)
{
	PRMINFO pRmInfo = (PRMINFO) pDev->pRmInfo;
    RM_STATUS   status = RM_OK;
    
    switch (MemoryType)
    {
    
        case NV_MEMORY_TYPE_SYSTEM:
        
            //
            // Perform VMM page free.
            //
            vmmGetCritSectionStatus();
            //
            // KJK: Not really necessary to unlock before free
            //
            //PageCount = vmmPageGetSizeAddr(*pAddress, 0, &desc.Desc64);
            //vmmPageUnLock(*pAddress,
            //              desc.Desc32[0],
            //              0,
            //              0);
            if (!vmmPageFree((U032)*pAddress, 0))
                status = RM_ERROR;
            
            break;
            
        case NV_MEMORY_TYPE_AGP:

            if ((pDev->Chip.Bus == BUS_AGP) && (pDev->Chip.ReqAGPRate != 0))
            {
                //
                // Not sure if the Free below covers both the underlying pages and the
                // aperture addresses, so to be sure, we'll uncommit the pages and free.
                //
                vmmGARTUnCommit((U032)*pAddress, 0, PageCount);

                //
                // Perform VGARTD (VMM) AGP page free.
                //
                vmmGARTFree((U032)*pAddress);                   // for uncached AGP, free it all

                if (IsWriteCombined)
                {
                    // update our notion of how much persistent AGP has been alloced
                    pRmInfo->AGP.AGPHeapFree -= (PageCount << RM_PAGE_SHIFT);
                }
            }
            else
            {
                status = RM_ERROR;
            }
            
            break;
    }
    
    return (status);
}

// Translate a Virtual to Physical addr (used to provide the AGP aperture offset)
RM_STATUS osVirtualToPhysicalAddr
(
    VOID* virtaddr,
    VOID** physaddr
)
{
    U032 PageBase = (U032)virtaddr >> PAGESHIFT;
    U032 BaseAddr;

    // check that we've got a page (only need to succeed for one page translate the base)
    if (vmmPageCheckLinRange(PageBase, 1, 0) != 1)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM:Linear range not valid.\n\r");
        DBG_BREAKPOINT();
        return (RM_ERR_PAGE_TABLE_NOT_AVAIL);
    }

    // Get the first entry.
    if (!vmmCopyPageTable(PageBase, 1, (U032)&BaseAddr, 0))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM:Unable to copy page table.\n\r");
        return (RM_ERR_PAGE_TABLE_NOT_AVAIL);
    }

    (U032)*physaddr = (BaseAddr & ~RM_PAGE_MASK) | ((U032)virtaddr & RM_PAGE_MASK);
    return RM_OK;
}

RM_STATUS osCalculatePteAdjust
(
    PHWINFO pDev,
    U032    AddressSpace,
    VOID*   Address,
    U032 *  pPteAdjust
)
{
    *pPteAdjust = (U032)Address & RM_PAGE_MASK;

    return RM_OK;
}

// Get address information from the selector:offset address combination
RM_STATUS osGetAddressInfo
(
    PHWINFO pDev,
    U032  ChID,
    U032  Selector,
    VOID** pOffset,
    U032  Length,
    VOID** pAddress,
    NV_ADDRESS_SPACE *pAddressSpace
)
{
	PRMINFO pRmInfo = (PRMINFO) pDev->pRmInfo;

    DESCRIPTOR  desc;
    U032        SelectorBase, SelectorLimit;
    U032        LinAddr, PageBase, PageArray;

#ifdef DEBUG
    U032        Page;
#endif // DEBUG

    // Default set the address type to system. 
    *pAddressSpace = ADDR_SYSMEM;

    vmmGetDescriptor(Selector, vmmGetSysVMHandle(), 0, &desc.Desc64);
    if ((desc.Desc32[0] == 0) && (desc.Desc32[1] == 0))       
    {
        return (RM_ERR_BAD_ADDRESS);
    }
    SelectorBase = ((U032)desc.Desc16[1]) |
                   ((U032)desc.Desc8[4] << 16) |
                   ((U032)desc.Desc8[7] << 24);
    SelectorLimit    = ((U032)desc.Desc16[0]) |
                       ((U032)(desc.Desc8[6] & 0x0F) << 16);
    if (desc.Desc8[6] & D_GRAN_PAGE)
    {
        //
        // Page granularity.
        //
        SelectorLimit = (SelectorLimit << 12) | 0x0FFF;
    }
    //
    // Gotta check all them bits for WIN95!!!
    //
    if (desc.Desc8[5] & D_ED)
    {
        //
        // Expand Down Segment.
        //
        // Check the "B" bit to determine maximum offset.
        //
        if (desc.Desc8[6] & D_DEF32)
            SelectorLimit = 0xFFFFFFFF;
        else
            SelectorLimit = 0x0000FFFF;
    }

    // Check to see if we have an address space conflict
    if ((*pAddressSpace != ADDR_UNKNOWN) && (*pAddressSpace != ADDR_SYSMEM) && (*pAddressSpace != ADDR_AGPMEM) && (*pAddressSpace != ADDR_FBMEM)) {
       return(RM_ERR_BAD_ADDRESS);
    }
    // Check to see if the transfer is in bounds
    if (((U032)*pOffset + Length) > SelectorLimit) {
       return(RM_ERR_BAD_ADDRESS);
    }

    // The address space is always system memory
    //KJK *pAddressSpace = ADDR_SYSMEM;
    // The returned address is the selector base + selector offset
    (U032)*pAddress = SelectorBase + (U032)*pOffset;

    //
    // We need to see if the address space matches any of our known ranges, such
    // as the framebuffer.  Override the memory type as necessary.  In most cases
    // this is done by the app when it names the context instance, but sometimes
    // he might not.
    //
    // For now, only check the framebuffer.  Need to add AGP GART aperture.
    //
    if (*pAddressSpace == ADDR_AGPMEM)
    {    
       return(RM_OK);
    }       
    
    //
    // Create the linear address of the buffer.
    //
    LinAddr = vmmSelectorMapFlat(vmmGetSysVMHandle(), Selector, 0) + (U032)*pOffset;
    //
    // Create the page base
    //
    PageBase = LinAddr >> PAGESHIFT;
    //
    // Linear Address is already in the shared or system memory arena.
    // Lock memory as was done under Win31...no need to change
    // memory contexts
    //
    if (vmmPageCheckLinRange(PageBase, 1, 0) != 1)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM:Linear page not valid.\n\r");
        //DBG_BREAKPOINT();
        return (RM_ERR_PAGE_TABLE_NOT_AVAIL);
    }
    //
    // Grab the first page and see if it falls within our known range
    //
    if (!vmmLinPageLock(PageBase, 1, 0))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM:Unable to lock detection page.\n\r");
        //return (RM_ERR_DMA_MEM_NOT_LOCKED);
        return (RM_OK);     // not fatal
    }
    if (!vmmCopyPageTable(PageBase, 1, (U032)&PageArray, 0))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM:Unable to copy detection page table.\n\r");
        //return (RM_ERR_PAGE_TABLE_NOT_AVAIL);
        return (RM_OK);     // not fatal
    }
    if (!(PageArray & P_PRES))
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Unable to lock page :LinAddr = ", (PageBase + Page) << 12);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "                          :PTE     = ", PageArray);
        //DBG_BREAKPOINT();
        //return (RM_ERR_PAGE_TABLE_NOT_AVAIL);
        return (RM_OK);     // not fatal
    }
    if (!vmmLinPageUnLock(PageBase, 1, 0))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM:Unable to unlock detection page.\n\r");
        //return (RM_ERR_DMA_MEM_NOT_LOCKED);
        return (RM_OK);     // not fatal
    }
    //
    // 4k page alignment
    //
    PageArray &= 0xFFFFF000;    
    //
    // If we're in FB space, we need to change the dma pte over to PNVM rather than PCI/AGP
    //
    if ((PageArray >= pDev->Mapping.PhysFbAddr) && (PageArray < (pDev->Mapping.PhysFbAddr + pDev->Framebuffer.HalInfo.RamSize)))
    {
        if ((PageArray+Length) >= (pDev->Mapping.PhysFbAddr + pDev->Framebuffer.HalInfo.RamSize))
        {
            //
            // We're straddling fb mem...bomb.
            //
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: osGetAddressInfo: buffer crosses fbmem boundary ", PageArray);
            DBG_BREAKPOINT();
            return (RM_ERR_MULTIPLE_MEMORY_TYPES);
        }

        //
        // Subtract off the start of the framebuffer
        //
        (U032)*pAddress = (U032)*pOffset = (PageArray - pDev->Mapping.PhysFbAddr) + 
                               (LinAddr  & RM_PAGE_MASK); // The offset within a page            
        //
        // Turn this into a PNVM dma structure
        //
        *pAddressSpace = ADDR_FBMEM;  
    }
    
    //
    // If we're in AGP space, we need to change the dma pte over to AGP rather than PCI
    //
    if ((pDev->Chip.Bus == BUS_AGP) && (pRmInfo->AGP.AGPLimit) && (pRmInfo->AGP.AGPPhysStart) &&
        (pDev->Chip.ReqAGPRate != 0))
    {
        if ((PageArray >= pRmInfo->AGP.AGPPhysStart) && (PageArray < (pRmInfo->AGP.AGPPhysStart + pRmInfo->AGP.AGPLimit)))
        {
            if ((PageArray+Length) > (pRmInfo->AGP.AGPPhysStart + pRmInfo->AGP.AGPLimit))
            {
                //
                // We're straddling agp mem...bomb.
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: osGetAddressInfo: buffer crosses agp aperture boundary ", PageArray);
                DBG_BREAKPOINT();
                return (RM_ERR_MULTIPLE_MEMORY_TYPES);
            }

            //
            // Turn this into an AGP dma structure
            //
            *pAddressSpace = ADDR_AGPMEM;
        }
    }
    
    return (RM_OK);
}

RM_STATUS osLockUserMem
(
    PHWINFO          pDev, 
    U032             ChID,
    U032             Selector,
    VOID*            Offset,
    VOID*            DmaAddress,
    NV_ADDRESS_SPACE *DmaAddressSpace,
    U032             DmaLength,
    U032             PageCount,
    U032            *PageArray,
    VOID**           pLinAddr,
    VOID**           LockHandle
)
{
    U032 LinAddr;
    U032 PageBase;
    U032 Page;
    U032 temp;
    
    
    //
    // If we're asking to lock video memory, let's just build up the PTE's and assume
    // that the caller has real control over video memory (such as DirectDraw or the
    // display driver).
    //
    if (*DmaAddressSpace == ADDR_FBMEM)
    {
        
        LinAddr = (U032)*pLinAddr = (U032)*LockHandle = (U032)Offset;   // 0-based selector!!

        //
        // Should probably make sure the start+limit are within the available
        // video memory!!
        //
        
        //
        // This is hardcoded assuming zero = start of fb
        //
        PageBase = LinAddr >> PAGESHIFT;
        for (Page = 0; Page < PageCount; Page++)  {
            PageArray[Page] = ((PageBase + Page)<<12) | 3;
        }
        
        return (RM_OK);
    }

    //
    // Map the buffer.
    //
    LinAddr = (U032)*pLinAddr = vmmSelectorMapFlat(vmmGetSysVMHandle(), Selector, 0) + (U032)Offset;
    //
    // Validate the parameters.
    //
    PageBase = LinAddr >> PAGESHIFT;
    //
    // Use original linear address as the lock handle.
    //
    (U032)*LockHandle = (U032)*pLinAddr;

    if (*DmaAddressSpace == ADDR_AGPMEM)
    {
        U032 AGPBaseAddr;

        //
        // For AGP, just xlate the first page and derive the remaining pages knowing
        // this memory appears linear to the processor/bus master.
        //
        // Avoiding probing invalid GART entries fixes a problem seen on Compaq Aspen
        // systems (AMD 751/Via combo chipset). This occurs when OGL allocs a 16MB AGP
        // texture context DMA that's larger than what's been allocated so far.
        //

        // Get the first entry.
        if (!vmmCopyPageTable(PageBase, 1, (U032)&AGPBaseAddr, 0))
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM:Unable to copy page table.\n\r");
            return (RM_ERR_PAGE_TABLE_NOT_AVAIL);
        }

        // Fill in the rest of the entries (though instmem only needs one entry).
        for (Page = 0; Page < PageCount; Page++)
        {
            PageArray[Page] = (AGPBaseAddr + (Page << RM_PAGE_SHIFT)) | 3;
        }

        return (RM_OK);
    }

    if (((LinAddr >= MINSHAREDLADDR) && (LinAddr <= MAXSHAREDLADDR)) ||
        ((LinAddr >= MINSYSTEMLADDR) && (LinAddr <= MAXSYSTEMLADDR)))
    {   
        //
        // Linear Address is already in the shared or system memory arena.
        // Lock memory as was done under Win31...no need to change
        // memory contexts
        //
        if (vmmPageCheckLinRange(PageBase, PageCount, 0) != PageCount)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM:Linear range not valid.\n\r");
            DBG_BREAKPOINT();
            return (RM_ERR_PAGE_TABLE_NOT_AVAIL);
        }
        //
        // Scatter/gather lock the pages.
        //
        for (Page = 0; Page < PageCount; Page++)
        {
            //
            // Touch page to make sure it is in memory.  Win32s doesn't like
            // to play nicely with the VMMs memory manager.
            //
            NopMask |= *(volatile U008 *)LinAddr;
            LinAddr += PAGESIZE;
            //
            // If this is a standard AGP memory context (not an NV AGP context),
            // there is no need to relock the memory.  DirectDraw has already done
            // it for us, so we can just peer at the PTEs.
            //
            if (*DmaAddressSpace != ADDR_AGPMEM)
                if (!vmmLinPageLock(PageBase + Page, 1, 0))
                {
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM:Unable to lock pages.\n\r");
                    return (RM_ERR_DMA_MEM_NOT_LOCKED);
                }
            if (!vmmCopyPageTable(PageBase + Page, 1, (U032)&PageArray[Page], 0))
            {
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM:Unable to copy page table.\n\r");
                return (RM_ERR_PAGE_TABLE_NOT_AVAIL);
            }
            if (!(PageArray[Page] & P_PRES))
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Unable to lock page :LinAddr = ", (PageBase + Page) << 12);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "                          :PTE     = ", PageArray[Page]);
                DBG_BREAKPOINT();
                return (RM_ERR_PAGE_TABLE_NOT_AVAIL);
            }
        }
    }
    else
    {
        //
        // Linear Address is in the private memory arena.
        // Lock memory and map linear address the the system memory arena.
        // Memory Context switch may be required.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "osLockUserMem: Original Linear Address = ",(U032)*pLinAddr);
        temp = vmmPageCheckLinRange(PageBase, PageCount, 0);
        if (temp != PageCount)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_USERERRORS, "NVRM:Linear range not valid.\n\r");
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS, "Page Base            = ", PageBase);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS, "Requested Page Count = ", PageCount);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS, "Actual Page Count    = ", temp);
            DBG_BREAKPOINT();
            return (RM_ERR_PAGE_TABLE_NOT_AVAIL);
        }
        for (Page = 0; Page < PageCount; Page++)
        {
            //
            // Touch page to make sure it is in memory.  Win32s doesn't like
            // to play nicely with the VMMs memory manager.
            //
            NopMask |= *(volatile U008 *)LinAddr;
            LinAddr += PAGESIZE;
        }
        //
        // Lock all pages at once and map to system memory arena.
        //
        if (*DmaAddressSpace != ADDR_AGPMEM)
            LinAddr = (U032)vmmLinPageLock(PageBase, PageCount, PAGEMAPGLOBAL);
        else    
            LinAddr = (U032)*pLinAddr;    // agp doesn't need a lock, so restore the original linaddr            
        if (!LinAddr)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM:Unable to lock pages.\n\r");
            return (RM_ERR_DMA_MEM_NOT_LOCKED);
        }
        if (!vmmCopyPageTable(LinAddr >> PAGESHIFT, PageCount, (U032)&PageArray[0], 0))
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM:Unable to copy page table.\n\r");
            return (RM_ERR_PAGE_TABLE_NOT_AVAIL);
        }
        LinAddr += ((U032)*pLinAddr & 0xFFF);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "               New Linear Address      = ",LinAddr);
        (U032)*pLinAddr = LinAddr;
    }
    return (RM_OK);    
}
RM_STATUS osUnlockUserMem
(
    PHWINFO          pDev, 
    U032             ChID,
    VOID*            LinAddr,
    VOID*            DmaAddress,
    NV_ADDRESS_SPACE DmaAddressSpace,
    U032             DmaLength,
    U032             PageCount,
    VOID*            LockHandle,
    U032             DirtyFlag
)
{
    RM_STATUS status;
    U032      PageBase;
    U032      Page;
    U032      UnlockFlags;

    //
    // If we're asking to unlock video memory, we're assuming the caller (probably
    // direct draw)  has complete control of video memory, and therefore knows what
    // is locked/unlocked.  No need to do anything.
    //
    if (DmaAddressSpace == ADDR_FBMEM)
        return (RM_OK);    

    //
    // As a convenience to the drivers, we allow an AGP Context DMA to be setup that's
    // larger than the underlying alloced pages (setup to map the whole aperture).
    // Since we avoided a call to CheckLinRange in osLockUserMem, we can't do it here
    // either. And, besides, we don't lock/unlock AGP memory anyways.
    //
    if (DmaAddressSpace == ADDR_AGPMEM)
        return (RM_OK);    

    PageBase = (U032)LinAddr >> 12;
    UnlockFlags = 0;
    if ((U032)LockHandle != (U032)LinAddr)
    {
        UnlockFlags = PAGEMAPGLOBAL;
    }
    //
    // KJK Allow a twice-deleted dma context.  Windows will return an error to CheckLinRange
    // if the context has already been unlocked by someone else, so don't go try talking
    // to the memory.
    //
//#ifdef DEBUG
    if (vmmPageCheckLinRange((U032)LinAddr >> PAGESHIFT, PageCount, 0) != PageCount)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Unlocking invalid memory range!\n\r");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "     Address: ", (U032)LinAddr);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "   PageCount: ", PageCount);
        DBG_BREAKPOINT();
        DirtyFlag = 0;
    }
//#endif // DEBUG
    if (DirtyFlag)
    {
        NopMask  = 0xFF;
        for (Page = 0; Page < PageCount; Page++)
        {
            *(volatile U008 *)LinAddr &= NopMask;
            (U032)LinAddr += PAGESIZE;
        }
    }
    //
    // Unlock pages and restore the memory context if neccessary.
    //
    if (DmaAddressSpace != ADDR_AGPMEM)
        status = !vmmLinPageUnLock(PageBase, PageCount, UnlockFlags) ? RM_ERR_DMA_MEM_NOT_UNLOCKED : RM_OK;
    return (status);
}

RM_STATUS osMapFifo
(
    PHWINFO pDev, 
    U032 clientClass, 
    U032 ChannelID,
    VOID **ppAddress
)
{
    *ppAddress = (VOID *) ((U032)pDev->DBnvAddr + FIFO_USER_BASE(pDev) + (ChannelID << 16));
    return RM_OK;
}

RM_STATUS osMapFrameBuffer
(
    PHWINFO pDev, 
    U032 clientClass, 
    U032 fbOffset,
    U032 length,
    VOID **ppAddress
)
{
    *ppAddress = (VOID *) ((U032)pDev->DBfbAddr + fbOffset);
    return RM_OK;

}

RM_STATUS osMapInstanceMemory
(
    PHWINFO pDev, 
    U032 clientClass, 
    U032 instanceOffset,
    U032 length,
    VOID **ppAddress
)
{
    *ppAddress = (VOID *) ((U032)INSTANCE_MEMORY_BASE + instanceOffset);
    return RM_OK;
}

// This procedure undoes the work of osMapFifo, osMapFrameBuffer and osMapInstanceMemory
RM_STATUS osUnmapMemory
(
    PHWINFO pDev,
    U032    clientClass,
    VOID   *address,
    U032    length
)
{
    // There is nothing to unmap in win9x.
    return RM_OK;
}

RM_STATUS osSetFifoDmaParams
(
    PHWINFO pDev,
    U032   *pFetchTrigger,
    U032   *pFetchSize,
    U032   *pFetchRequests
)
{
    U032 data32;

    //
    // Default win9x DMA channel fetch parameters are optimized for
    // for the D3D driver.
    //

    //
    // The registry overrides are specified in values that can be
    // plugged directly into the hardware.  We need to convert them
    // to the appropriate units so they'll continue to work.
    //

    //
    // If there's a dma fifo fetch trigger override, use it now.
    //
    if (osReadRegistryDword(pDev,strDevNodeRM, strFetchTriggerOverride, &data32) == RM_OK)
        *pFetchTrigger = (data32+1) * 8;
    else
        *pFetchTrigger = 128;           // 128 bytes

    //
    // If there's a dma fifo fetch size override, use it now.
    //
    if (osReadRegistryDword(pDev,strDevNodeRM, strFetchSizeOverride, &data32) == RM_OK)
        *pFetchSize = (data32+1) * 32;
    else
        *pFetchSize = 32;               // 32 bytes

    //
    // If there's a dma fifo fetch max reqs override, use it now.
    //
    if (osReadRegistryDword(pDev,strDevNodeRM, strFetchMaxReqsOverride, &data32) == RM_OK)
        *pFetchRequests = data32;
    else
        *pFetchRequests = 15;           // 15 outstanding read requests

    return RM_OK;
}

//---------------------------------------------------------------------------
//
//  OS specific time of day.
//
//---------------------------------------------------------------------------

RM_STATUS osGetCurrentTime
(
    U032 *year,
    U032 *month,
    U032 *day,
    U032 *hour,
    U032 *min,
    U032 *sec,
    U032 *msec
)
{
    U032 bcd;
    CLIENT_STRUCT  crs;
    U032 i;
    
    //
    // Sorry, no msec accuracy.
    //
    *msec = 0;
    //
    // Read the real time clock chip. Convert BCD to integer.
    //
    /*
    outp(0x70, 0x00); bcd = inp(0x71);
    *sec = (bcd & 0x0F) + (bcd >> 4) * 10;
    outp(0x70, 0x02); bcd = inp(0x71);
    *min = (bcd & 0x0F) + (bcd >> 4) * 10;
    outp(0x70, 0x04); bcd = inp(0x71);
    *hour = (bcd & 0x0F) + (bcd >> 4) * 10;
    outp(0x70, 0x07); bcd = inp(0x71);
    *day = (bcd & 0x0F) + (bcd >> 4) * 10;
    outp(0x70, 0x08); bcd = inp(0x71);
    *month = (bcd & 0x0F) + (bcd >> 4) * 10;
    outp(0x70, 0x09); bcd = inp(0x71);
    *year = (bcd & 0x0F) + (bcd >> 4) * 10 + 1900;
    if (*year < 1995)
        *year += 100;
    */
    
    //
    // To make sure we get a valid time, ask the BIOS to recover the data
    // instead of going directly to the hardware.
    //
    // Wait for success, but don't wait too long
    //
    crs.CWRS.Client_Flags = BIT(CF_BIT);
    i = 0;
    while ((crs.CWRS.Client_Flags & BIT(CF_BIT)) && --i)
    {
        crs.CBRS.Client_AH  = 0x02;    // READ_CMOS_TIME
        TIMER(&crs);
    }
    
    //
    // Convert from BCD.  Also make sure the time is "somewhat" valid
    //
    bcd = crs.CBRS.Client_DH;
    *sec = (bcd & 0x0F) + (bcd >> 4) * 10;
    if (*sec > 60)
        *sec = 60;
    bcd = crs.CBRS.Client_CL;
    *min = (bcd & 0x0F) + (bcd >> 4) * 10;
    if (*min > 60)
        *min = 60;
    bcd = crs.CBRS.Client_CH;
    *hour = (bcd & 0x0F) + (bcd >> 4) * 10;
    if (*hour > 24)
        *month = 24;
    
    //
    // Now get the date.
    //
    // Wait for success, but don't wait too long
    //
    crs.CWRS.Client_Flags = BIT(CF_BIT);
    i = 0;
    while ((crs.CWRS.Client_Flags & BIT(CF_BIT)) && --i)
    {
        crs.CBRS.Client_AH  = 0x04;    // READ_CMOS_DATE
        TIMER(&crs);
    }
    
    //
    // Convert from BCD.  Also make sure the time is "somewhat" valid
    //
    bcd = crs.CBRS.Client_DL;
    *day = (bcd & 0x0F) + (bcd >> 4) * 10;
    if (*day > 31)
        *day = 31;
    bcd = crs.CBRS.Client_DH;
    *month = (bcd & 0x0F) + (bcd >> 4) * 10;
    if (*month > 12)
        *month = 12;
    bcd = crs.CBRS.Client_CL;
    *year = (bcd & 0x0F) + (bcd >> 4) * 10 + 1900;
    if (*year < 1995)
        *year += 100;
    
    return (RM_OK);
}

//---------------------------------------------------------------------------
//
//  OS specific IPC, notifications and error callbacks.
//
//---------------------------------------------------------------------------
extern DWORD vwin32SetWin32Event( DWORD );
extern DWORD vwin32CloseVxdHandle( DWORD );

RM_STATUS osNotifyEvent
(
    PHWINFO   pDev,
    POBJECT   Object,
    U032      Notifier,    
    U032      Method,
    U032      Data,
    RM_STATUS Status,
    U032      Action
)
{
    PEVENTNOTIFICATION NotifyEvent;
    
    //
    // Check for the correct actions
    //
    if (Action == NV_OS_WRITE_THEN_AWAKEN)
    {
        //
        // Walk this object's event list and find any matches for this
        // specific notify
        //
        NotifyEvent = Object->NotifyEvent;
        while (NotifyEvent)
        {
            //
            // Check for a notify index match
            //
            if (NotifyEvent->NotifyIndex == Notifier)
            {
                // 
                // Match!!
                //
                switch (NotifyEvent->NotifyType)                
                {
                    case NV01_EVENT_WIN32_EVENT:
#ifndef IKOS
                        //
                        // Attempt to trigger the event
                        //
                        if (vwin32SetWin32Event((U032)(NotifyEvent->Data.low)) == 0)
                        {
                            //
                            // Failed, so lose this event so we don't try again
                            //
                            vwin32CloseVxdHandle((U032)(NotifyEvent->Data.low));
                            NotifyEvent->NotifyType = 0;
                        }
#endif
                        break;
                        
                    /*
                    case NV_OS_EVENT_VM_EVENT:
                        //
                        // Schedule event servicing.  Do this in the system VM.
                        //
                        vmmCallPriorityVMEvent(HIGH_PRI_DEVICE_BOOST,
                                               vmmGetSysVMHandle(),
                                               0,
                                               0,
                                               (U032)(NotifyEvent->Data.low),
                                               0);
                    
                        break;
                    */
                        
                    case NV01_EVENT_KERNEL_CALLBACK:
                        //
                        // Perform a direct callback.  This is assumed to be a Ring0->Ring0
                        // transfer.
                        //
                        {
                        CRS       SavedCRS;
                        U032      SysVM = vmmGetSysVMHandle();
                        
                        //
                        // Just in case the callback is ill behaved
                        //
                        vmmSaveClientState(&SavedCRS);
                        
                     
                        //
                        // Schedule RM servicing.
                        //
                        vmmCallPriorityVMEvent(TIME_CRITICAL_BOOST,
                                               SysVM,
                                               0,
                                               (U032)Status,
                                               (U032)(NotifyEvent->Data.low),
                                               0);
                        
                        //
                        // Restore our state.
                        //
                        vmmRestoreClientState(&SavedCRS);
                        
                        }
                        break;
                                                
                    default:
                        break;
                }                                                
            }
            
            // 
            // On to the next one
            //
            NotifyEvent = NotifyEvent->Next;
        }
    
    }
    //
    // The rest of these actions are legacy channel-based notifies
    //
    else
    {    
        return NVOS10_STATUS_ERROR_BAD_EVENT;
    }    
}

RM_STATUS osError
(
    POBJECT   Object,
    U032      Method,
    V032      Data,
    RM_STATUS Error
)
{
    PHWINFO pDev;
	PWIN9XHWINFO pOsHwInfo;
    POBJECT *ppObject;
    int i;

    for(i=0;i<MAX_INSTANCE;i++){
        pDev = NvDBPtr_Table[i];
        if(pDev != NULL){
			pOsHwInfo = (PWIN9XHWINFO) pDev->pOsHwInfo;

            // Search the fifo object tree for an object with the same name.
            fifoSearchObject(pDev,Object->Name,Object->ChID,ppObject);
            if(ppObject != NULL){
              if(*ppObject == Object){
                  break;
              }else{
                  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: ERROR in osError (Object not found)\n\r");
                  return (RM_ERROR);
              }
            }
        }
    }

    //
    // Only call back on errors, not warnings.
    //
    if (Error & 0xFFFF)
    {
        if (pOsHwInfo->dllNotifySelector + pOsHwInfo->dllNotifyOffset == 0)    
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: ERROR - Notify callback invalid!\n\r");
            return (RM_ERROR);
        }
        if (Object)
            return (osScheduleCallback(pDev,
                                       (U016)pOsHwInfo->dllNotifySelector,
                                       (U016)pOsHwInfo->dllNotifyOffset,
                                       6,
                                       Object->ChID,
                                       Object->Name, 
                                       Method,
                                       Data,
                                       Error,
                                       0));
        else       
            return (osScheduleCallback(pDev,
                                       (U016)pOsHwInfo->dllNotifySelector,
                                       (U016)pOsHwInfo->dllNotifyOffset,
                                       6,
                                       Data,
                                       0, 
                                       Method,
                                       0,
                                       Error,
                                       0));
    }
    return (RM_OK);
}

RM_STATUS osExit
(
    char *errstr
)
{
    vmmFatalErrorHandler((DWORD)errstr, 0);
    return (RM_OK);
}
//---------------------------------------------------------------------------
//
//  Misc services.
//
//---------------------------------------------------------------------------

RM_STATUS osDelay
(
    U032 MilliSeconds
)
{
    U032 Start;

    Start = vmmGetSystemTime();
    while ((vmmGetSystemTime() - Start) < MilliSeconds);
    return (RM_OK);
}

RM_STATUS osDelayUs
(
    U032 MicroSeconds
)
{
    U032 Start;

    //
    // TEMPORARY WORKAROUND
    //
    // The BIP language spec calls for a usec delay, yet win9x can only
    // handle msec delays.  So, floor us at 1ms and pre-convert all other 
    // timing requests
    //
    if (MicroSeconds < 1000)
        MicroSeconds = 1;
    else
        MicroSeconds = MicroSeconds / 1000;

    Start = vmmGetSystemTime();
    while ((vmmGetSystemTime() - Start) < MicroSeconds);
    return (RM_OK);
}
//---------------------------------------------------------------------------
//
//  PCI config space read/write routines.
//
//---------------------------------------------------------------------------
#define PCI_FUNCTION_ID         0xB1
#define READ_CONFIG_BYTE        0x08
#define READ_CONFIG_WORD        0x09
#define READ_CONFIG_DWORD       0x0A
#define WRITE_CONFIG_BYTE       0x0B
#define WRITE_CONFIG_WORD       0x0C
#define WRITE_CONFIG_DWORD      0x0D

U032
osPciReadDword(VOID *handle, U032 offset)
{
    CLIENT_STRUCT *pcrs = (CLIENT_STRUCT *)handle;

    pcrs->CBRS.Client_AH  = PCI_FUNCTION_ID;
    pcrs->CBRS.Client_AL  = READ_CONFIG_DWORD;
    pcrs->CWRS.Client_DI  = (U016) offset;
    PCI(pcrs);

    return pcrs->CRS.Client_ECX;
}

U016
osPciReadWord(VOID *handle, U032 offset)
{
    CLIENT_STRUCT *pcrs = (CLIENT_STRUCT *)handle;

    pcrs->CBRS.Client_AH  = PCI_FUNCTION_ID;
    pcrs->CBRS.Client_AL  = READ_CONFIG_WORD;
    pcrs->CWRS.Client_DI  = (U016) offset;
    PCI(pcrs);

    return pcrs->CBRS.Client_CL;
}

U008
osPciReadByte(VOID *handle, U032 offset)
{
    CLIENT_STRUCT *pcrs = (CLIENT_STRUCT *)handle;

    pcrs->CBRS.Client_AH  = PCI_FUNCTION_ID;
    pcrs->CBRS.Client_AL  = READ_CONFIG_BYTE;
    pcrs->CWRS.Client_DI  = (U016) offset;
    PCI(pcrs);

    return pcrs->CBRS.Client_CL;
}

VOID
osPciWriteDword(VOID *handle, U032 offset, U032 value)
{
    CLIENT_STRUCT *pcrs = (CLIENT_STRUCT *)handle;

    pcrs->CBRS.Client_AH  = PCI_FUNCTION_ID;
    pcrs->CBRS.Client_AL  = WRITE_CONFIG_DWORD;
    pcrs->CWRS.Client_DI  = (U016) offset;
    pcrs->CRS.Client_ECX  = value;
    PCI(pcrs);
}

VOID
osPciWriteWord(VOID *handle, U032 offset, U016 value)
{
    CLIENT_STRUCT *pcrs = (CLIENT_STRUCT *)handle;

    pcrs->CBRS.Client_AH  = PCI_FUNCTION_ID;
    pcrs->CBRS.Client_AL  = WRITE_CONFIG_WORD;
    pcrs->CWRS.Client_DI  = (U016) offset;
    pcrs->CBRS.Client_CL  = (U008) value;
    PCI(pcrs);
}

VOID
osPciWriteByte(VOID *handle, U032 offset, U008 value)
{
    CLIENT_STRUCT *pcrs = (CLIENT_STRUCT *)handle;

    pcrs->CBRS.Client_AH  = PCI_FUNCTION_ID;
    pcrs->CBRS.Client_AL  = WRITE_CONFIG_BYTE;
    pcrs->CWRS.Client_DI  = (U016) offset;
    pcrs->CBRS.Client_CL  = value;
    PCI(pcrs);
}

VOID *
osPciInitHandle(U008 bus, U008 device, U008 func, U016 *pVendorId, U016 *pDeviceId)
{
    U016 venID, devID;
    static CLIENT_STRUCT crs;

    // get vendor/device id at offset 0
    _asm {
        push    eax
        push	edx

        // build up bus/device/func config addr
        movzx   eax, bus
        shl     eax, 10h
        movzx   edx, device
        shl     edx, 0Bh
        or      dh,  func

        or      eax, edx
        or      eax, 80000000h

        mov     edx, 0cf8h
        out     dx,eax
        mov     edx, 0cfch
        in      eax, dx

        // vendor/device from config data
        mov     venID, ax
        shr     eax, 16
        mov     devID, ax

        pop     edx
        pop     eax
    }

    // return these to the caller
    if (pVendorId)
        *pVendorId = venID;
    if (pDeviceId)
        *pDeviceId = devID;

    // initialize the CLIENT_STRUCT state
    crs.CBRS.Client_AH  = PCI_FUNCTION_ID;  // PCI_FUNCTION_ID
    crs.CBRS.Client_AL  = 0x02;             // FIND_PCI_DEVICE
    crs.CWRS.Client_CX  = devID;            // Device ID
    crs.CWRS.Client_DX  = venID;            // Vendor ID
    crs.CWRS.Client_SI  = 0;                // Index
    PCI(&crs);

    return &crs;
}


#ifdef OBSOLETE_FUNCTIONS
RM_STATUS osRedrawScreen
(
    VOID
)
{
    osIPC(NVRM_WM_REDRAW_SCREEN, 0, 0);
    return (RM_OK);
}
RM_STATUS osRedrawCanvas
(
    U032 hwnd
)
{
    if (hwnd != 0)
        osIPC(NVRM_WM_REDRAW_HWND, (U016)hwnd, 0);
    return (RM_OK);
}
RM_STATUS osBeginWatchCanvas
(
    U032 hwnd
)
{
    if (hwnd != 0)
        osIPC(NVRM_WM_OPEN_HWND, (U016)hwnd, 0);
    return (RM_OK);
}
RM_STATUS osEndWatchCanvas
(
    U032 hwnd
)
{
    if (hwnd != 0)
        osIPC(NVRM_WM_CLOSE_HWND, (U016)hwnd, 0);
    return (RM_OK);
}
#endif // OBSOLETE_FUNCTIONS

// New semaphore functions for Multi-Mon support.
RM_STATUS mmWaitSemaphore
(
    VOID
)
{
//    vmmWaitSemaphore(mmSemaphore, 0);
    return (RM_OK);
}
RM_STATUS mmSignalSemaphore
(
    VOID
)
{
//    vmmSignalSemaphore(mmSemaphore);
    return (RM_OK);
}

//---------------------------------------------------------------------------
//
//  OS name validation.
//
//---------------------------------------------------------------------------
#ifdef OBSOLETE_FUNCTIONS
RM_STATUS osValidateVideoSink
(
    char *OsName
)
{
    U032 i;
    
    for (i = 0; i < 4; i++)
        if (OsName[i] != nameVideoSink[i])
            return (RM_ERR_INVALID_OS_NAME);
    return (RM_OK);
}
RM_STATUS osValidateImageVideo
(
    char *OsName,
    U032 *CanvasID
)
{
    U032 i;
    
    *CanvasID = 0;
    for (i = 0; i < 3; i++)
        if (*OsName++ != nameImageVideo[i])
            return (RM_ERR_INVALID_OS_NAME);
    while (*OsName >= '0' && *OsName <= '9')
        *CanvasID = *CanvasID * 10 + *OsName++ - '0';
    return (*OsName == ':' ? RM_OK : RM_ERROR);
}


// Validate the DMA address space name from the app
// A DMA object with no name is treated as System Memory space
// The DMA direction does not matter for system memory space
RM_STATUS osValidateDMAObject(
    char *OsName,
    U032 DmaObjectName,
    NV_ADDRESS_SPACE *AddressSpace
)
{
    U032 i;
    RM_STATUS status;

    if (OsName[0] == '\0') {
        *AddressSpace = ADDR_SYSMEM;
        return(RM_OK);
    }

    if (osStringCompare(OsName, nameSysMem))
    {
       *AddressSpace = ADDR_SYSMEM;
       return(RM_OK);
    }

    if (osStringCompare(OsName, nameLVidMem))
    {
       *AddressSpace = ADDR_FBMEM;
       return(RM_OK);
    }
    
    if (osStringCompare(OsName, nameSVidMem))
    {
        //
        // Only allow true AGP on AGP systems!!  
        //
        if (pDev->Chip.Bus == BUS_AGP)
            //
            // When we attempt to lock this context we need to verify it falls within
            // the AGP space.  If not, it is really a PCI memory block and needs to be
            // treated as such.
            //
            *AddressSpace = ADDR_AGPMEM;
        else    
            *AddressSpace = ADDR_SYSMEM;
        return(RM_OK);
    }
    
    *AddressSpace = ADDR_SYSMEM;
    
    return(RM_ERR_INVALID_OS_NAME);
    
}
#endif // OBSOLETE_FUNCTIONS

//---------------------------------------------------------------------------
//
//  Interrupt time stuff.
//
//---------------------------------------------------------------------------

CARRY osInterrupt
(
    U032 hIRQ,
    U032 hVM
)
{
    PHWINFO   pDev;
    U032 status;

    //
    // Need to do this within a routine with no local variables to make
    // sure we can return the carry flag correctly without the compiler
    // stomping on it.
    //
    //int  saved_DeviceInstance; 
    // Save the DeviceInstance of the current executing RM thread.
    //saved_DeviceInstance = DeviceInstance; 

    status = osInterruptProcess(&pDev,hIRQ, hVM);
    
    //_asm push eax
    //DeviceInstance = saved_DeviceInstance; 
    //_asm pop  eax
        
    //
    // Of course, the Microsoft compiler handles things differently from
    // the Watcom compiler.  We need to exit this routine with the
    // carry flag denoting if we handled this interrupt ourselves.
    // But the return value from vmmCallBackExit() is in EAX and will
    // destroy any carry flag.  So, let's set the carry flag according
    // to EAX.
    //
    // CY=1 if ok to share since we didn't process
    // CY=0 if we processed our own interrupt (w/ EOI)
    //        
    _asm {   
        clc        
        cmp eax, 0
        je notus
        stc
        notus:
    }

}

BOOL CDECL osServiceHandler
(
    VOID
)
{
    PHWINFO   pDev;
    U032      hDevice;
	PWIN9XHWINFO pOsHwInfo;

    _asm mov hDevice, edx
    pDev = (PHWINFO) hDevice;
	pOsHwInfo = (PWIN9XHWINFO) pDev->pOsHwInfo;

    if (pDev->DeviceDisabled)
    {
        U032 we_are_mapped;
        U032 pci_address;
    
        // Check if the device has become unmapped. If so stop servicing.
        // Read the 1st base register.
        pci_address = pDev->Mapping.nvBusDeviceFunc;
        _asm mov  dx, 0xcf8
        _asm in   eax, dx
        _asm push eax
        _asm mov  eax, pci_address  
        _asm or   eax, 0x80000010 
        _asm out  dx, eax
        _asm mov  dx, 0xcfc
        _asm in   eax,dx
        _asm mov  we_are_mapped,eax
        _asm pop  eax
        _asm mov  dx, 0xcf8
        _asm out  dx, eax
    
        if(!we_are_mapped)
        {
            // The device is disabled. Just ignore this interrupt.
            return(TRUE);
        }  
    }

    //See if we are still lineraly mapped
    if (nvAddr->Reg032[0] == 0xFFFFFFFF)
    {
		  return(1);
	 }
 
    if (pOsHwInfo->osScheduled)
    {    
        pOsHwInfo->osScheduled--;
        osEnsureDeviceEnabled(pDev);

        {
            BOOL x;
            U032 t1,t2;

            t1=(U032) pOsHwInfo->NvIsrStackFrame;
            osSwapStack(t1, t2);
            pOsHwInfo->NvSaveVmmStack = (U032 *) t2;

            x=osService(pDev);

            t1=(U032) pOsHwInfo->NvSaveVmmStack;
            osSwapStack(t1, t2);
            pOsHwInfo->NvIsrStackFrame = (U032 *) t2;

            return(x);        
        }
    }
}

U032 osInterruptProcess
(
    PHWINFO *ppDev,
    U032 hIRQ,
    U032 hVM
)
{
    PHWINFO pDev;
	PWIN9XHWINFO pOsHwInfo;

    V032 pmc;
    V032 pmce;
#ifdef RM_STATS
    U032 EnterTimeLo;
    U032 EnterTimeHi;
    U032 ExitTimeLo;
    U032 ExitTimeHi;
    U032 IntTimeLo;
    U032 IntTimeHi;
#endif
//  int  saved_DeviceInstance; 
#ifdef TIMER_OVERRIDE
    V032 ptimer;
#endif
    VOID VBlank(PHWINFO);

    CLI

//
  // Let's just walk the devices and find the one that is
  // associated with this hIRQ.  The IRQ handle was saved away
  // when each particular device hooked its interrupt routine
  // with the VPICD.
  //
  // We should get called for every handle, independent of
  // actual IRQ sharing in the system.
  //
  // For all possible devices in the system
  //
  {
    U032 i;
    
    for (i=0;i<MAX_INSTANCE;i++)
    {
        // Check if this device exists.
        if (NvDBPtr_Table[i] != NULL)
        {
            pDev = NvDBPtr_Table[i];
			pOsHwInfo = (PWIN9XHWINFO) pDev->pOsHwInfo;
            //DeviceInstance = i;
            
            if (pDev->Mapping.hpicIRQ != NULL && pDev->Mapping.hpicIRQ == hIRQ)
            {
                // Make sure this device has not been disabled by Windows98.
                // If it has been disabled then re-enable it.
                osEnsureDeviceEnabled(pDev);

                // This may or may not be our interrupt, but we have established our
                // pDev (osInterrupt needs it setup, so we can chain the interrupt).
                *ppDev = pDev;

                // This code is in place for MultiMonitor support during a shutdown.
                // If the system is shutting down Win98 will zero out the pci base registers.
                // If this happens ... just return as if it was not meant for us.
                if (pDev->DeviceDisabled)
                {
                    U032 we_are_mapped;
                    U032 pci_address;
                  
                    // Check if the device has become unmapped. If so stop servicing.
                    // Read the 1st base register.
                    pci_address = pDev->Mapping.nvBusDeviceFunc;
                    _asm mov  eax, pci_address  
                    _asm or   eax, 0x80000010 
                    _asm mov  dx, 0xcf8
                    _asm out  dx, eax
                    _asm mov  dx, 0xcfc
                    _asm in   eax,dx
                    _asm mov  we_are_mapped,eax
                  
                    if(!we_are_mapped)
                        return(1);
                }

                //See if we are still linearaly mapped
                if (nvAddr->Reg032[0] == 0xFFFFFFFF)
                {
                    return(1);
                }
                
                //
                // Windows thought this IRQ was meant for us...
                //
                // Check if this device's interrupt has been asserted.
                //
                pmc  = REG_RD32(NV_PMC_INTR_0);
                pmce = REG_RD32(NV_PMC_INTR_EN_0);
                if (pmc && pmce)
                {
                    // 
                    // Hey, it was us!  Break out.
                    //
                    i = MAX_INSTANCE;
                }     
                else
                {
                    //
                    // It was our IRQ, but it wasn't our device
                    // Restore the DeviceInstance of the current executing RM thread.
                    // Let it chain
                    //
                    // JIM !!!! DON'T RESTORE THIS YET !!!!!
                    //DeviceInstance = saved_DeviceInstance; 
                    return(1);
                }                    
            }                    
        } 
        else
        {
            //
            // No more devices to check !
            // Let it chain to other ISR's
            // Restore the DeviceInstance of the current executing RM thread.
            //
            return(1);
        }
    } 
  }

    if (pmc && pmce)
    {
        //
        // Turn off interrupts here to avoid glitching the PIC on cheap
        // PCI chipsets.
        //
        REG_WR32(NV_PMC_INTR_EN_0, 0x00000000);
#ifdef RM_STATS
        //
        // Profile the interrupt execution time.
        //
        tmrGetCurrentTime(pDev, &EnterTimeHi, &EnterTimeLo);
        //
        // 12/20/95 - msk - get time right away to do accurate timings for
        // new emulation method
        //
        pDev->Chip.osStartInterrupt = EnterTimeLo;
#endif
        //
        // EOI the PIC.
        //
        VPICD_Phys_EOI(pDev->Mapping.hpicIRQ);

#ifdef DEBUG_TIMING
        if (dbgCountInt[dbgFrame] < 20)
           dbgStartInt[dbgFrame][dbgCountInt[dbgFrame]] = REG_RD32(NV_PTIMER_TIME_0) - dbgStart ;
        dbgCountInt[dbgFrame]++;
#endif // DEBUG_TIMING

        //
        // Call any high priority service routines and schedule low priority 
        // service routines if service still required.
        //
        if (pmc & (DRF_DEF(_PMC, _INTR_0, _PCRTC, _PENDING) |
                   DRF_DEF(_PMC, _INTR_0, _PCRTC2, _PENDING)))
        {
            if (!pDev->Vga.Enabled)   // no need for vblank service in NV3
                                        // DOS prgms which poll 3DA for vblank status
                                        // may not see it because of latency
            {
            //
            // Do any VBlank servicing.
            //    
                VBlank(pDev);
            }
        }

        //
        // check if need to service any high priority Mediaport tasks
        //
        //mpService(pDev);

#ifdef NV_VGA
#ifdef TIMER_OVERRIDE // Note: TIMER_OVERRIDE should usually not be defined!
        //
        // Usually stop the timer interrupt from being serviced
        //
        if (pDev->Vga.Enabled)
        {
           if (pmc & DRF_DEF(_PMC, _INTR_0, _PTIMER, _PENDING))
           {
               REG_WR_DRF_DEF(_PTIMER, _INTR_0, _ALARM, _RESET);
               ptimer = REG_RD32(NV_PTIMER_INTR_0);
               vgaTimer();
           }
        }
#endif // TIMER_OVERRIDE
#endif // NV_VGA
#ifdef RM_STATS
        //
        // Add time spent in service routines to accumulated time.
        //
        tmrGetCurrentTime(pDev, &ExitTimeHi, &ExitTimeLo);
        IntTimeLo = ExitTimeLo - EnterTimeLo;
        IntTimeHi = ExitTimeHi - EnterTimeHi;
        if (IntTimeLo > ExitTimeLo)
            IntTimeHi--;
        pDev->Chip.ExceptionTimeLo += IntTimeLo;
        if (pDev->Chip.ExceptionTimeLo < IntTimeLo)
            IntTimeHi++;
        pDev->Chip.ExceptionTimeHi += IntTimeHi;    
#endif
        // BUG_BM_OFF();
        pmc = REG_RD32(NV_PMC_INTR_0);
        // BUG_BM_ON();
        if (pmc)
        {
        
            if (!pOsHwInfo->osScheduled)
            {   
            
                U032    VMh = vmmGetSysVMHandle();
                     
                //
                // Schedule RM servicing.
                //
                pOsHwInfo->osScheduled = 1;
                vmmCallPriorityVMEvent(TIME_CRITICAL_BOOST,
                                       VMh,
                                       0,
                                       (DWORD)pDev,
                                       (U032)osServiceHandler,
                                       0);
            }                                       
        }
        else
        {
            //
            // Reenable chip interrupts.
            // Only if the device was NOT DISABLED.
            if (!pDev->DeviceDisabled){
                REG_WR32(NV_PMC_INTR_EN_0, pDev->Chip.IntrEn0);
            }
        }
#ifdef DEBUG_TIMING
        if (dbgCountInt[dbgFrame] - 1 < 20)
            dbgEndInt[dbgFrame][dbgCountInt[dbgFrame]-1] = REG_RD32(NV_PTIMER_TIME_0) - dbgStart ;
#endif // DEBUG_TIMING
        //vmmCallBackExit(0);
        // Restore the DeviceInstance of the current executing RM thread.
        //DeviceInstance = saved_DeviceInstance; 
        return(0);
    }
    else
    {
        //
        // This interrupt is not for us, chain to next handler.
        //
        // Restore the DeviceInstance of the current executing RM thread.
        //DeviceInstance = saved_DeviceInstance; 
        return(1);
    }
}


VOID CDECL rmService
(
    VOID
)
{
    PHWINFO pDev=NULL;
	PWIN9XHWINFO pOsHwInfo;
    V032 pmc;
    V032 pmce;
#ifdef RM_STATS
    U032 EnterTimeLo;
    U032 EnterTimeHi;
    U032 ExitTimeLo;
    U032 ExitTimeHi;
    U032 IntTimeLo;
    U032 IntTimeHi;
#endif
    CRS  SavedCRS;
    VOID VBlank(PHWINFO);

    //
    // Turn off interrupts to keep real interrupt routine from interfering.
    //
    CLI
    // BUG_BM_OFF();
    pmc  = REG_RD32(NV_PMC_INTR_0);
    pmce = REG_RD32(NV_PMC_INTR_EN_0);
    // BUG_BM_ON();
    //
    // Turn off chip interrupt here to avoid re-entrancy issues.
    //
    REG_WR32(NV_PMC_INTR_EN_0, 0x00000000);
    if (pmc && pmce)
    {
#ifdef RM_STATS
        //
        // Profile the interrupt execution time.
        //
        tmrGetCurrentTime(&EnterTimeHi, &EnterTimeLo);
#endif
        //
        // EOI the PIC.
        //
        VPICD_Phys_EOI(pDev->Mapping.hpicIRQ);
        //
        // Call all service routines requiring attention.
        //
        if (pmc & DRF_DEF(_PMC, _INTR_0, _PCRTC, _PENDING))
        {
            //
            // Do any VBlank servicing.
            //    
            VBlank(pDev);
        }
#ifdef RM_STATS
        //
        // Add time spent in service routines to accumulated time.
        //
        tmrGetCurrentTime(&ExitTimeHi, &ExitTimeLo);
        IntTimeLo = ExitTimeLo - EnterTimeLo;
        IntTimeHi = ExitTimeHi - EnterTimeHi;
        if (IntTimeLo > ExitTimeLo)
            IntTimeHi--;
        pDev->Chip.ExceptionTimeLo += IntTimeLo;
        if (pDev->Chip.ExceptionTimeLo < IntTimeLo)
            IntTimeHi++;
        pDev->Chip.ExceptionTimeHi += IntTimeHi;    
#endif
        // BUG_BM_OFF();
        pmc = REG_RD32(NV_PMC_INTR_0);
        // BUG_BM_ON();
    }
    if (pmc)
    {
        //
        // Service chip right now.
        //
        //
        // The only sure way to make sure that we don't deadlock if we get a second
        // flush fifo call from DirectAudio or DirectInput while we are currently
        // servicing a previous flush fifo is to protect the calls with a real
        // blocking semaphore.
        //
        vmmWaitSemaphore(osSemaphore, 0);
        if (!osService(pDev))
        {
            //
            // The RM is currently in service.  To allow the InService event
            // to complete, a dummy call to the 16 bit NVSYS.DLL will be made
            // to force the VMM to reschedule its events.  Maybe next time
            // through we will actually be able to call the RM.
            //
			pOsHwInfo = (PWIN9XHWINFO) pDev->pOsHwInfo;

            vmmSaveClientState(&SavedCRS);
            vmmBeginNestExecution();
            vmmSimulatePush(0);
            vmmSimulatePush(0);
            vmmSimulatePush(0);
            vmmSimulatePush(0);
            vmmSimulatePush(0);
            vmmSimulatePush(0);
            vmmSimulatePush(0);
            vmmSimulatePush(0);
            vmmSimulatePush(0);
            vmmSimulatePush(0);
            vmmSimulatePush(0xFFFF);
            vmmSimulatePush(0xFFFF);
            vmmSimulateFarCall(pOsHwInfo->dllNotifySelector, pOsHwInfo->dllNotifyOffset);
            vmmResumeExec();
            vmmEndNestExecution();
            vmmRestoreClientState(&SavedCRS);
        }
        vmmSignalSemaphore(osSemaphore);
    }
    else
    {
        //
        // Reenable chip interrupts.
        //
        REG_WR32(NV_PMC_INTR_EN_0, pmce);
    }
    //
    // Re-enable interrupts.
    //
    STI
}
BOOL CDECL osService
(
    PHWINFO pDev
)
{
    //
    // Make sure interrupts are enabled.
    //
    STI
    //
    // Service all chip functions.
    //
    mcService(pDev);
    //
    // Try scheduling callbacks here.
    //
    if (osCallbackList && !rmInCallback)
    {
        rmInCallback++;
        vmmCallPriorityVMEvent(HIGH_PRI_DEVICE_BOOST,
                               vmmGetSysVMHandle(),
                               (PEF_WAIT_FOR_STI | PEF_ALWAYS_SCHED),
                               (DWORD)pDev,
                               (DWORD)osCallback,
                               0);
    }
    //
    // Reenable chip interrupts.
    // Only if the device was NOT DISABLED.
    if (!pDev->DeviceDisabled){
        REG_WR32(NV_PMC_INTR_EN_0, pDev->Chip.IntrEn0);
    }

    return (TRUE);
}

VOID osNopInt
(
    U032 hIRQ,
    U032 hVM
)
{
    return;
}

RM_STATUS CDECL osScheduleCallback
(
    PHWINFO pDev,
    U016    dllSelector,
    U016    dllOffset,
    U032    Count,
    U032    Params,
    ...
)
{
    U032      i;
    U032      *ParamList;
    PCALLBACK CallbackInfo;
    PCALLBACK SearchCallback;
    
    if (dllSelector == 0 && dllOffset == 0)    
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: ERROR - schedule callback invalid!\n\r");
        return (RM_ERROR);
    }
    //
    // Schedule the callback at a nice time.
    //
    CLI
    CallbackInfo = osCallbackFreeList;
    if (CallbackInfo == NULL)
    {
        STI
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Unable to allocate callback structure!\n\r");
        return (RM_ERR_NO_FREE_MEM);
    }
    osCallbackFreeList     = osCallbackFreeList->Next;
    CallbackInfo->Next     = NULL;
    CallbackInfo->Selector = dllSelector;
    CallbackInfo->Offset   = dllOffset;
    CallbackInfo->Count    = Count;
    ParamList              = &Params;
    for (i = 0; i < Count; i++)
        CallbackInfo->Params[i] = *ParamList++;
    if (osCallbackList)
    {
        //
        // Insert into linked list of callbacks.
        //
        SearchCallback = osCallbackList;
        while (SearchCallback->Next)
            SearchCallback = SearchCallback->Next;
        SearchCallback->Next = CallbackInfo;
    }
    else
    {
        //
        // Schedule a callback.
        //
        osCallbackList = CallbackInfo;
    }
    STI
    return (RM_OK);
}

//
// Some customers are still using these legacy callback mechanisms.  Do not remove
//
extern CallBackDef mpCallback, mpImageCallback;
extern DWORD rmmpInCallback;
VOID osmpVbiCallback( U032 );
VOID osmpImageCallback( U032 );

VOID osmpCheckCallbacks(
    PHWINFO pDev,
    U032 dwCallbackSelect
)
{
    if (!(pDev->Video.HalInfo.CustomizationCode & CUSTOMER_CANOPUS))
        return;
// select VBI callback
if (dwCallbackSelect==0)
    {
    if (((mpCallback.Selector+mpCallback.Offset)!=0) && !rmmpInCallback)
    {
       rmmpInCallback++;
       vmmCallPriorityVMEvent(HIGH_PRI_DEVICE_BOOST,
                                   vmmGetSysVMHandle(),
                                   (PEF_WAIT_FOR_STI | PEF_ALWAYS_SCHED),
                                   (DWORD)pDev,
                                   (DWORD)osmpVbiCallback,
                                   0);
    }
    }                                      

// select image callback
if (dwCallbackSelect==1)
    {
    if (((mpImageCallback.Selector+mpImageCallback.Offset)!=0) && !rmmpInCallback)
    {
       rmmpInCallback++;
       vmmCallPriorityVMEvent(HIGH_PRI_DEVICE_BOOST,
                                   vmmGetSysVMHandle(),
                                   (PEF_WAIT_FOR_STI | PEF_ALWAYS_SCHED),
                                   (DWORD)pDev,
                                   (DWORD)osmpImageCallback,
                                   0);
    }


    }

}
extern DWORD mpImageInstalledCallback;
extern DWORD mpInstalledCallback;

VOID osmpVbiCallback
(
    // The parameter passing must be done via registers as seen below.
    U032 hVM
)
{
    CRS       SavedCRS;
    PHWINFO   pDev;

    // Load the device instance for this callback.
    _asm mov pDev, edx

    if (mpInstalledCallback)
        {
        vmmCallBackEntry();
        CLI
        vmmSaveClientState(&SavedCRS);
        vmmBeginNestExecution();
        STI
        // why do these have to be 16 bit pushes ?
        //vmmSimulatePush(dwVbiBufferNumber >> 16 );
        //vmmSimulatePush(dwVbiBufferNumber & 0xFFFF);
        vmmSimulatePush(0 >> 16 );
        vmmSimulatePush(0 & 0xFFFF);
        vmmSimulateFarCall(mpCallback.Selector, mpCallback.Offset & 0xFFFF);
        vmmResumeExec();
        CLI

        vmmEndNestExecution();
        vmmRestoreClientState(&SavedCRS);
        rmmpInCallback--;
        STI
        vmmCallBackExit(TRUE);
        }
}

VOID osmpImageCallback
(
    // The parameter passing must be done via registers as seen below.
    U032 hVM
)
{
    CRS       SavedCRS;
    PHWINFO   pDev;
    U032      DeviceInstance;

    // Load the device instance for this callback.
    _asm mov pDev, edx
    // Grab the device instance #
    DeviceInstance = pDev->DBdevInstance;

    if (mpImageInstalledCallback)
        {
        vmmCallBackEntry();
        CLI
        vmmSaveClientState(&SavedCRS);
        vmmBeginNestExecution();
        STI
        
        vmmSimulatePush(DeviceInstance >> 16);      // keyed for Canopus client
        vmmSimulatePush(DeviceInstance & 0xFFFF);
        
        // why do these have to be 16 bit pushes ?
        vmmSimulatePush(pDev->MediaPort.ImageBufferNumber >> 16 );
        vmmSimulatePush(pDev->MediaPort.ImageBufferNumber & 0xFFFF);

        vmmSimulateFarCall((U032) mpImageCallback.Selector, 
                            (U032) (mpImageCallback.Offset & 0xFFFF));
        vmmResumeExec();
        CLI

        vmmEndNestExecution();
        vmmRestoreClientState(&SavedCRS);
        rmmpInCallback--;
        STI
        vmmCallBackExit(TRUE);
        }
}


#define rdtsc __asm _emit 0x0f __asm _emit 0x31 
extern U032 vmmGetSystemTime();

// Return frequency value in MHz
U032 osGetCpuFrequency()
{
    U032 t1, t2;
    U032 tsc1, tsc2;

    // wait for timer to roll the first time
    t2 = vmmGetSystemTime();
    do {
        t1 = vmmGetSystemTime();
    } while (t1 == t2);

    // read the tsc
    _asm {
        push    eax
        push    edx
        rdtsc
        mov     DWORD PTR [tsc1], eax
        pop     edx
        pop     eax
    }

    t1 += 100;              // add 1/10 second
    while(t2 < t1) {        // wait 1/10 second
        t2 = vmmGetSystemTime();
    }

    // read the tsc again
    _asm {
        push    eax
        push    edx
        rdtsc
        mov     DWORD PTR [tsc2], eax
        pop     edx
        pop     eax
    }

    // multiply returned value by 10 since we timed 1/10th second
    // and divide the result to convert from Hz to MHz
    return (U032) ((tsc2-tsc1) * 10) / (1000000);
}

VOID osCallback
(
    // The parameter passing must be done via registers as seen below.
    U032 hVM
)
{
    U032      i;
    CRS       SavedCRS;
    PCALLBACK OldCallback;
    U032      hDevice;
    PHWINFO   pDev;

    // Load the device instance for this callback.
    _asm mov hDevice, edx

    pDev = NvDBPtr_Table[hDevice];
    //DeviceInstance = hDevice;

    vmmCallBackEntry();    
    CLI
//    rmInCallback = TRUE;
#if DEBUG
    if (osCallbackList == NULL)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: NULL Callback Callback List!\n\r");
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      Add more structures.\n\r");
    }
#endif    
    vmmSaveClientState(&SavedCRS);
    vmmBeginNestExecution();
    while (osCallbackList)
    {
        U032 Selector = osCallbackList->Selector;
        U032 Offset = osCallbackList->Offset;
    
        STI
        for (i = 0; i < osCallbackList->Count; i++)
        {
            vmmSimulatePush(osCallbackList->Params[i] >> 16);
            vmmSimulatePush(osCallbackList->Params[i] & 0xFFFF);
        }
//        vmmSimulateFarCall(osCallbackList->Selector, osCallbackList->Offset);
        vmmSimulateFarCall(Selector, Offset);
        vmmResumeExec();
        CLI
        //
        // Move to next callback in the pending list.
        //
        OldCallback    = osCallbackList;
        osCallbackList = osCallbackList->Next;
        //
        // Stick the old callback structure back on the free list.
        //
        OldCallback->Next  = osCallbackFreeList;
        osCallbackFreeList = OldCallback;
    }
    vmmEndNestExecution();
    vmmRestoreClientState(&SavedCRS);
    rmInCallback--;
    STI
    vmmCallBackExit(TRUE);
}

// 
//
VOID osDisplayModeHook
(
    PHWINFO pDev,
    U032    msg
)
{
    //
    // If the Win9X display driver has asked for state change
    // notification, call him now
    //
    if (pDev->DBdisplayModeHook)
    {
        // This needed to be modified due to the incomplete 
        // _asm support in MS tools.
        //(*pDev->DBdisplayModeHook)(msg);
        VOID *x;
        x = pDev->DBdisplayModeHook;
        __asm {
            push    edi
            mov     eax, msg
            mov     edi, x
            call    edi
            pop     edi
        } 
    }
} // end of osDisplayModeHook

//
// Perform any os-specific DAC state updates that need to occur
// when the DAC/CRTC has been updated.
//
VOID osStateDacEx
(
    PHWINFO pDev,
    U032    msg
)
{
#if 0   // this should be in osPostModeSet
	PWIN9XHWINFO pOsHwInfo = (PWIN9XHWINFO) pDev->pOsHwInfo;

    //
    // Notify the Win9X minivdd that a mode change has probably occurred.  This allows
    // it to save any new register states
    //
    if (pOsHwInfo->miniVDDPostModeChange)  // if primary display, we got callback at init
        (*pOsHwInfo->miniVDDPostModeChange)();
#endif
}

//  Set the FilterEnable value for TV flicker filtering
//  This checks the registry for an override 
//
VOID osStateFbEx
(
    PHWINFO pDev
)
{
U032    data32;
// To Do:
// we probably want to return a value (0,1, or 2) representing the amount of filtering.
// for now we just check for the string.
// we should be able to override on as well as off. This means don't check monitor.type, just check range
// on data32 and copy 0,1, or 2 to FilterEnable.
    if (osReadRegistryDword(pDev,strDevNodeRM, "FilterOverride", &data32) == RM_OK)  // TV filter?
    {
        if (GETMONITORTYPE(pDev, 0) != MONITOR_TYPE_VGA)
            pDev->Framebuffer.FilterEnable = 2;
    } 
    else 
    {
        //
        // Otherwise, make sure we get a default value in during initialization
        //
        if (GETMONITORTYPE(pDev, 0) == MONITOR_TYPE_VGA)
            pDev->Framebuffer.FilterEnable = 0;
        else
            pDev->Framebuffer.FilterEnable = 2;
    }

    // Tiling is automatically done in the RM for most modes. This key allows us
    // to disable the auto tiling feature. Once enabled or disabled, it stays that way
    // till this registry key is changed. There is also a programmatic way of 
    // enabling and disabling auto tiling (ConfigSetEx). Right now, these two methods
    // can be freely mixed. i.e, the operation performed by the programmatic interface
    // can be undone by the registry flag and vice versa.
    if (osReadRegistryDword(pDev,strDevNodeRM, "AutoTilingOverride", &data32) == RM_OK) 
    {
        if (data32 == 0)
        {
            // Disable auto tiling.
            nvHalFbControl(pDev, FB_CONTROL_TILING_DISABLE);
        }
        else
        {
            // Enable tiling.
            nvHalFbControl(pDev, FB_CONTROL_TILING_ENABLE);
        }
    } // Auto tiling override
}

// Prepare the pDev for the new style mode set.
// This should be called by the legacy mode set flow only.
//
VOID osSetupForNewStyleModeSet(PHWINFO pDev)
{
#if 0 // this is an archaic, non-architectural function
	PWIN9XHWINFO pOsHwInfo = (PWIN9XHWINFO) pDev->pOsHwInfo;
    RM_STATUS status;
    DISPLAYINFO tmpDisplayInfo;
    BOOL    optimalRefreshSelected;
    U032    monitorTimingMode;
    U032    UseDMTFlag;
    U032    tmpDMTFlag;
    BOOL    monitorIsGTF;
    U032    data32;
    MODE_TIMING_VALUES timingValues;
    unsigned int vesaStatus;
    BOOL arbitrationValidated;
    U032 numRefreshRates;
    U032 nextLower;
    int i;

    REG_WR08(NV_PRMCIO_CRX__COLOR, 0x571F & 0xFF); 
    REG_WR08(NV_PRMCIO_CRX__COLOR+1, (0x571F >> 8) & 0xFF);
    ////OEMEnableExtensions();          // Unlock the registers before DDC
    EDIDRead(pDev, 0, GETDISPLAYTYPE(pDev, 0));
    REG_WR08(NV_PRMCIO_CRX__COLOR, 0x991F & 0xFF); 
    REG_WR08(NV_PRMCIO_CRX__COLOR+1, (0x991F >> 8) & 0xFF);
    ////OEMDisableExtensions();         // Lock the registers

    // Figure out what monitor timing mode we want. It is controlled by a registry flag "MonitorTiming".
    monitorTimingMode = 0; // By default, read the EDID of the monitor.
    if (osReadRegistryDword(pDev,pDev->Registry.DBstrDevNodeDisplay, strMonitorTiming, &data32) == RM_OK)
    {
        monitorTimingMode = data32;
    }
    switch (monitorTimingMode)
    {
        case 1:
            // Use DMT.
            UseDMTFlag = TRUE;
            break;
        case 2:
            // Use GTF.
            UseDMTFlag = FALSE;
            break;
        case 3:
            // Legacy mode.
            // Read the legacy DMT Override flag to see if we should use DMT. Otherwise use GTF.
            UseDMTFlag = FALSE;
            if (osReadRegistryDword(pDev,pDev->Registry.DBstrDevNodeDisplay, strDMTOverride, &data32) == RM_OK)
            {
                if (data32 == 1)
                    UseDMTFlag = TRUE;
            }
            break;
        default:
            // Automatically set it by reading the EDID.
            UseDMTFlag = TRUE; // default to DMT
            if (EDIDIsMonitorGTF(pDev, &monitorIsGTF) == RM_OK)
            {
                UseDMTFlag = (monitorIsGTF) ? FALSE : TRUE;
            }
            break;
            // 
    }

    //
    // If there's an override setting for the refresh rate, use it instead
    //
    if (osReadRegistryDword(pDev,strDevNodeRM, strRefreshOverride, &data32) == RM_OK)
        pDev->Framebuffer.HalInfo.RefreshRate = data32;

    //
    // The GTF timings for 640x400 at 70Hz and 72Hz are drastically different than
    // the original VGA timings (which officially only list 85Hz as a support rate
    // at this resolution).  Therefore, when we attempt to set the GTF rates the
    // monitors just aren't happy.
    //
    // We have two choices.  Tweak our 70Hz and 72Hz GTF numbers to mimic VGA, or
    // just use IBM VGA (70Hz) for these two rates.  Since we're doing it right, and
    // the monitors just aren't happy, I vote for the latter.
    //
    // Remember that IBM VGA 640x400 starts at 70Hz, not 60Hz.
    //
    if ((pDev->Framebuffer.HalInfo.HorizDisplayWidth == 640) && (pDev->Framebuffer.HalInfo.VertDisplayWidth == 400)
        && (pDev->Framebuffer.HalInfo.RefreshRate < 75))
            pDev->Framebuffer.HalInfo.RefreshRate = 60; // this will kick in BIOS default values (70Hz)

    //
    // NV4 limits for hires modes at 32bpp.  Windows will still send down optimal values larger
    // than the limits we placed in our INF.  Don't let them through.
    //
    if (!IsNV5orBetter(pDev))
    {    
        if ((pDev->Framebuffer.HalInfo.HorizDisplayWidth == 1280) && (pDev->Framebuffer.HalInfo.VertDisplayWidth == 1024)
            && (pDev->Dac.HalInfo.Depth >= 24)
            && (pDev->Framebuffer.HalInfo.RefreshRate > 100))
                pDev->Framebuffer.HalInfo.RefreshRate = 100; 
        
        if ((pDev->Framebuffer.HalInfo.HorizDisplayWidth == 1600) && (pDev->Framebuffer.HalInfo.VertDisplayWidth == 1200)
            && (pDev->Dac.HalInfo.Depth >= 24)
            && (pDev->Framebuffer.HalInfo.RefreshRate > 75))
                pDev->Framebuffer.HalInfo.RefreshRate = 75; 
        
        if ((pDev->Framebuffer.HalInfo.HorizDisplayWidth == 1920) && (pDev->Framebuffer.HalInfo.VertDisplayWidth == 1080)
            && (pDev->Dac.HalInfo.Depth >= 24)
            && (pDev->Framebuffer.HalInfo.RefreshRate > 72))
                pDev->Framebuffer.HalInfo.RefreshRate = 72; 
        
        if ((pDev->Framebuffer.HalInfo.HorizDisplayWidth == 1920) && (pDev->Framebuffer.HalInfo.VertDisplayWidth == 1200)
            && (pDev->Dac.HalInfo.Depth >= 24)
            && (pDev->Framebuffer.HalInfo.RefreshRate > 60))
                pDev->Framebuffer.HalInfo.RefreshRate = 60; 
    }                
            
    //
    // There is a hardware bug in NV4's arbitration hardware having to do with memory refresh and
    // page misses.  This shows its ugly head during 64bit operation (8meg SDRAM).  If we see
    // a pixelclock setting above ~160Hz in 32bpp, drop it down to 60Hz.
    //
    // The user may have selected a different refresh rate (since the INF allows it), but they're
    // going to get 60Hz.  Sorry.
    //            
    // The highest resolution in 8meg is 1600x1200x32bpp, so just watch for that
    //
    if ((pDev->Chip.HalInfo.MaskRevision == NV_PMC_BOOT_0_MASK_REVISION_A)
        && (pDev->Dac.HalInfo.InputWidth == 64)
        && (pDev->Framebuffer.HalInfo.RamSizeMb == 8)
        && (pDev->Framebuffer.HalInfo.HorizDisplayWidth == 1600) 
        && (pDev->Framebuffer.HalInfo.VertDisplayWidth == 1200)
        && (pDev->Dac.HalInfo.Depth >= 24)
        && (pDev->Framebuffer.HalInfo.RefreshRate > 60))
            pDev->Framebuffer.HalInfo.RefreshRate = 60; 

    //
    // Check if "optimal" refresh rate was chosen. 
    // When "optimal" is chosen, both min and max refresh rates in DISPLAYINFO will have non-zero values. 
    // When a specific refresh rate is chosen, max will have that value and the min will have zero. 
    // When "default" is chosen, both min and max will be zero.
    //    
    tmpDisplayInfo.HdrSize = sizeof(DISPLAYINFO);
    vddGetDisplayInfo(pOsHwInfo->osDeviceHandle, &tmpDisplayInfo, sizeof(DISPLAYINFO));
    pDev->Framebuffer.RefreshRateType = NV_CFG_REFRESH_FLAG_SPECIFIC; // assume specific 
    if ((tmpDisplayInfo.RefreshRateMax != 0) && (tmpDisplayInfo.RefreshRateMin != 0))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "OPTIMAL REFRESH!!\n\r");

        // Save the fact that its optimal so we can inform the control panel
        pDev->Framebuffer.RefreshRateType = NV_CFG_REFRESH_FLAG_OPTIMAL; 
        // Try to get the max frequency for this mode from the EDID. 
        // If we get a refresh rate that is less than what we have now,
        // we will use the lower value.
        if (osReadRegistryDword(pDev,pDev->Registry.DBstrDevNodeDisplay, strOptimalNotFromEDID, &data32) != RM_OK)
        {
            // No registry entry that prohibits us from looking in the EDID.
            status = EDIDGetMaxRefreshRate(pDev, pDev->Framebuffer.HalInfo.HorizDisplayWidth, 
                                           pDev->Framebuffer.HalInfo.VertDisplayWidth,
                                           &data32);
            if (status == RM_OK     && 
                data32 != 0 &&
                data32 < pDev->Framebuffer.HalInfo.RefreshRate)
            {
                pDev->Framebuffer.HalInfo.RefreshRate = data32;
            }
        } // Get optimal from EDID

        // Read the registry to see if there is a limit for the "optimal" refresh rate.
        if (osReadRegistryDword(pDev,pDev->Registry.DBstrDevNodeDisplay, strMaxOptimalRefreshRate, &data32) == RM_OK)
        {
            // Ignore the value read if it is less than 60Hz.
            if (data32 >= 60 &&
                data32 < pDev->Framebuffer.HalInfo.RefreshRate)
            {
                pDev->Framebuffer.HalInfo.RefreshRate = data32;
            }
        }
        
    } // else check if "default" refresh rate chosen
    else if ((tmpDisplayInfo.RefreshRateMax == 0) && (tmpDisplayInfo.RefreshRateMin == 0))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "ADAPTER DEFAULT REFRESH!!\n\r");
        
        // Save the fact that its default so we can inform the control panel
        pDev->Framebuffer.RefreshRateType = NV_CFG_REFRESH_FLAG_ADAPTER_DEFAULT; 
        pDev->Framebuffer.HalInfo.RefreshRate = 60;
    }        

    //
    // Attempt to workaround a Win95 bug with OPTIMAL and some Plug-n-Play monitors.
    //
    // When the user selects OPTIMAL from the control panel, the call to the VDD returns values to
    // the driver that look similar to a specific rate request (max != 0, min == 0) rather than 
    // looking like an OPTIMAL selection (max != 0, min != 0).
    //
    // Because of this misidentification of OPTIMAL, the MaxOptimalRefresh registry flag is ignored
    // and the rate goes higher than we want.   
    //
    // First check if we're on Win95 (CONFIG_MGR version 0x400)
    //
    if (CONFIGMG_Get_Version() < 0x40A)
    {
        U032 foundRate = 0;
        U032 optimalflag = 0;
        char config_settings[] = "CONFIG\\0000\\Display\\Settings";
        char config_key[] = "RefreshRate";
        U032 i;
        
        //
        // For safety, only check for this condition if there is a MaxOptimalRefresh flag present
        //
        if (osReadRegistryDword(pDev,pDev->Registry.DBstrDevNodeDisplay, strMaxOptimalRefreshRate, &data32) == RM_OK)
        {
            //
            // This is ugly, but look for the RefreshRate key in the HKLM\Config\000X\Display\...
            //
            // Remember, since this is Win95, we don't have to worry about multimonitor
            //
            for (i = 0; (i <= 9) && !foundRate; i++)
            {
                config_settings[10] = '0' + i;
            
                if (osReadRegistryDword(pDev,config_settings, config_key, &optimalflag) == RM_OK)
                    foundRate = 1;
            }                    
            
            //
            // We found a RefreshRate key in the display config.  Check if -1 (OPTIMAL)
            //
            if ((foundRate) && (((optimalflag & 0xFF) == '-') && (((optimalflag >> 8) & 0xFF) == '1')))
            {
                pDev->Framebuffer.RefreshRateType = NV_CFG_REFRESH_FLAG_OPTIMAL; 
                // Ignore the value read if it is less than 60Hz.
                if (data32 >= 60 &&
                    data32 < pDev->Framebuffer.HalInfo.RefreshRate)
                {
                    pDev->Framebuffer.HalInfo.RefreshRate = data32;
                }
            }
            
            //
            // VX700 workaround.  The Win95 PlugNPlay monitor INF incorrectly believes this particular
            // monitor can support up to 85Hz at 16x12.  Therefore the user is given the choice of
            // all possible rates up to 85.  The problem is that the monitor only supports up to
            // 65Hz.  Attempt to manually detect this specific monitor (by name, by detailed 16x12 timing)
            // and limit 16x12 to 60Hz in all cases. 
            //
            {
                U032 offset;
                
                offset = EDID_V1_DETAILED_TIMINGS_START_INDEX + (18 * 2); // DETAILED BLOCK3
                
                // Look for VX700 descriptor
                if ((pDev->EDIDBuffer[offset+5] == 'V') &&
                    (pDev->EDIDBuffer[offset+6] == 'X') &&
                    (pDev->EDIDBuffer[offset+7] == '7') &&
                    (pDev->EDIDBuffer[offset+8] == '0') &&
                    (pDev->EDIDBuffer[offset+9] == '0'))
                {
             
                    offset = EDID_V1_DETAILED_TIMINGS_START_INDEX; // DETAILED BLOCK1
                
                    // Look for 173.0 MHz timing at 1600x1200
                    if ((pDev->EDIDBuffer[offset+0] == 0x94) &&   // here's the MHz
                        (pDev->EDIDBuffer[offset+1] == 0x43) &&
                        (pDev->EDIDBuffer[offset+2] == 0x40) &&   // here's the active horiz
                        (pDev->EDIDBuffer[offset+4] == 0x62))
                    {
                    
                        // Look for 1600x1200 requested resolution
                        if ((pDev->Framebuffer.HalInfo.HorizDisplayWidth == 1600) && 
                            (pDev->Framebuffer.HalInfo.VertDisplayWidth == 1200))
                            pDev->Framebuffer.HalInfo.RefreshRate = 60; 
                    
                    }
                }
            }
             
            //
            // VX900 workaround.  The Win95 PlugNPlay monitor INF incorrectly believes this particular
            // monitor can support up to 85Hz at 16x12.  Therefore the user is given the choice of
            // all possible rates up to 85.  The problem is that the monitor only supports up to
            // 75Hz.  Attempt to manually detect this specific monitor (by name, by detailed 16x12 timing)
            // and limit 16x12 to 75Hz in all cases. 
            //
            {
                U032 offset;
                
                offset = EDID_V1_DETAILED_TIMINGS_START_INDEX + (18 * 2); // DETAILED BLOCK3
                
                // Look for VX900 descriptor
                if ((pDev->EDIDBuffer[offset+13] == 'V') &&
                    (pDev->EDIDBuffer[offset+14] == 'X') &&
                    (pDev->EDIDBuffer[offset+15] == '9') &&
                    (pDev->EDIDBuffer[offset+16] == '0') &&
                    (pDev->EDIDBuffer[offset+17] == '0'))
                {
             
                    offset = EDID_V1_DETAILED_TIMINGS_START_INDEX; // DETAILED BLOCK1
                
                    // Look for 202.50 MHz timing at 1600x1200
                    if ((pDev->EDIDBuffer[offset+0] == 0x1A) &&   // here's the MHz
                        (pDev->EDIDBuffer[offset+1] == 0x4F) &&
                        (pDev->EDIDBuffer[offset+2] == 0x40) &&   // here's the active horiz
                        (pDev->EDIDBuffer[offset+4] == 0x62))
                    {
                    
                        // Look for 1600x1200 requested resolution
                        if ((pDev->Framebuffer.HalInfo.HorizDisplayWidth == 1600) && 
                            (pDev->Framebuffer.HalInfo.VertDisplayWidth == 1200) &&
                            (pDev->Framebuffer.HalInfo.RefreshRate > 75))
                            pDev->Framebuffer.HalInfo.RefreshRate = 75; 
                    
                    }
                }
            }
             
            //
            // EV500/EV700 workaround.  The Win95 PlugNPlay monitor INF incorrectly believes this particular
            // monitor can support up to 100Hz at 10x7.  Therefore the user is given the choice of
            // all possible rates up to 100.  The problem is that the monitor only supports up to
            // 85Hz.  Attempt to manually detect this specific monitor (by name, by detailed 10x7 timing)
            // and limit 10x7 to 85Hz in all cases. 
            //
            {
                U032 offset;
                U032 block;
                
                offset = 0;
                
                // Look for the Gateway mfg descriptor
                if ((pDev->EDIDBuffer[offset+8] == 0x1E) &&
                    (pDev->EDIDBuffer[offset+9] == 0xF9))
                {
             
                    for (block = 0; block < 4; block++)
                    {
                        offset = EDID_V1_DETAILED_TIMINGS_START_INDEX + (18 * block); // DETAILED BLOCK N
                
                        // Look for 94.50 MHz timing at 1024x768; this translates to 85Hz
                        if ((pDev->EDIDBuffer[offset+0] == 0xEA) &&   // here's the MHz
                            (pDev->EDIDBuffer[offset+1] == 0x24) &&
                            (pDev->EDIDBuffer[offset+2] == 0x00) &&   // here's the active horiz
                            (pDev->EDIDBuffer[offset+4] == 0x41))
                        {
                        
                            // Look for 1024x768 requested resolution, cap to 85Hz
                            if ((pDev->Framebuffer.HalInfo.HorizDisplayWidth == 1024) && 
                                (pDev->Framebuffer.HalInfo.VertDisplayWidth == 768) &&
                                (pDev->Framebuffer.HalInfo.RefreshRate > 85))
                                pDev->Framebuffer.HalInfo.RefreshRate = 85; 
                        
                        }
                    }                        
                }
            }
            
        }
    }        
    
    //
    // Safety: make sure we aren't working off a bogus refresh rate.  Cap us to some silly limit.
    //
    if (pDev->Framebuffer.HalInfo.RefreshRate > 1000)
        pDev->Framebuffer.HalInfo.RefreshRate = 60;
    
    //
    // If there's max refresh rate, make sure we don't exceed that.
    //
    if (osReadRegistryDword(pDev,pDev->Registry.DBstrDevNodeDisplay, strMaxRefreshRate, &data32) == RM_OK)
    {
        // Ignore the value read if it is less than 60Hz.
        if (data32 >= 60 &&
            pDev->Framebuffer.HalInfo.RefreshRate > data32)
        {
            pDev->Framebuffer.HalInfo.RefreshRate = data32;
        }
    }

    //
    // Most monitors can support the vert range of 800x600x150Hz but cannot support the
    // horiz range.  We removed 150Hz from the INF, but in case Windows tries it anyway,
    // override with one lower rate.
    //
    if ((pDev->Framebuffer.HalInfo.HorizDisplayWidth == 800) && (pDev->Framebuffer.HalInfo.VertDisplayWidth == 600) 
        && (pDev->Framebuffer.HalInfo.RefreshRate > 144) && (pDev->Framebuffer.HalInfo.RefreshRate < 170))
    {
        pDev->Framebuffer.HalInfo.RefreshRate = 144;
    }                


    //
    // The documented method for Windows to select refresh rates for a display/monitor
    // combination is to take the intersection of the monitor INF entries (EDID) and
    // the display device's INF values.  This will then dictate the rates that are
    // valid for both devices.
    //
    // Unfortunately, it seems Microsoft didn't follow their own documentation in all
    // cases.  If a user selects OPTIMAL from the refresh rate menu, Windows will ask
    // us to set a refresh rate that matches the monitor information.  It doesn't matter
    // if the rate is beyond the display device's INF entries.
    //
    // Due to clocking differences between all of our shipping chips, we need to
    // validate all attempted refresh rates.  If a rate is beyond our device's limits
    // based on memory and clock variables, we need to attempt one refresh rate lower.
    // Luckily, the user has selected OPTIMAL and doesn't know exactly what rate she
    // is choosing.  If we drop it by one or two values, it doesn't really matter.
    //

    if (pDev->Framebuffer.HalInfo.RefreshRate == 0) // we'll be here an awfully long time if 
        pDev->Framebuffer.HalInfo.RefreshRate = 60; // refresh is set to 0

    arbitrationValidated = FALSE;
    while (!arbitrationValidated)
    {
        tmpDMTFlag = UseDMTFlag;
        if ((pDev->Framebuffer.HalInfo.HorizDisplayWidth == 640) && 
            (pDev->Framebuffer.HalInfo.VertDisplayWidth == 480)  &&
            (pDev->Framebuffer.HalInfo.RefreshRate == 60))
        {
            // force 640x480 @60Hz into DMT mode.
            tmpDMTFlag = UseDMTFlag = TRUE;
        }

        if (tmpDMTFlag)
        {
            // Get DMT timings for this mode. 
            vesaStatus = vesaGetDMTTimings(pDev->Framebuffer.HalInfo.HorizDisplayWidth, 
                                           pDev->Framebuffer.HalInfo.VertDisplayWidth, 
                                           pDev->Framebuffer.HalInfo.RefreshRate,
                                           &timingValues);
            // If we failed to get DMT timings for this mode, force GTF
            if (vesaStatus != 0)
            {
                tmpDMTFlag = FALSE;
            }
        }

        if (!tmpDMTFlag)
        {
            // Get the GTF timings
            vesaStatus = vesaGetGTFTimings(pDev->Framebuffer.HalInfo.HorizDisplayWidth, 
                                           pDev->Framebuffer.HalInfo.VertDisplayWidth, 
                                           pDev->Framebuffer.HalInfo.RefreshRate,
                                           &timingValues);
        }

        if (!vesaStatus)        
        {
            //
            // We found a rate match, so check if we can set valid arbitration for a clean screen
            //
            nvHalDacValidateArbSettings(pDev, 
                                        pDev->Dac.HalInfo.Depth, 
                                        0, 0, 
                                        (U032)(timingValues.PixelClock * 10000),
                                        0, &arbitrationValidated);
        }
        
        //
        // If both DMT and GTF lookups failed, we don't have a rate that matches the request.  Drop the
        // rate by one and try again.  Don't go below some really low number (say 45).
        //
        // Same thing goes for a rate that doesn't pass arbitration.  Drop on down.
        //
        if (!arbitrationValidated || vesaStatus)
        {
            //
            // Drop it, but don't go too low
            //
            if (--pDev->Framebuffer.HalInfo.RefreshRate < 45)
            {
                pDev->Framebuffer.HalInfo.RefreshRate = 60;     // just assume 60Hz on a total failure
                pDev->Framebuffer.HalInfo.HorizDisplayWidth = 640;
                pDev->Framebuffer.HalInfo.VertDisplayWidth = 480;
                
                vesaStatus = vesaGetDMTTimings(pDev->Framebuffer.HalInfo.HorizDisplayWidth, 
                                               pDev->Framebuffer.HalInfo.VertDisplayWidth, 
                                               pDev->Framebuffer.HalInfo.RefreshRate,
                                               &timingValues);
                                               
                arbitrationValidated = TRUE;            //  and get out of here
            }
        
        
        }

    } // while arbitration is not validated.

    // Save off the timing values in the pDev.
    pDev->Dac.HorizontalVisible       = timingValues.HorizontalVisible;
    pDev->Dac.HorizontalBlankStart    = timingValues.HorizontalBlankStart;
    pDev->Dac.HorizontalRetraceStart  = timingValues.HorizontalRetraceStart;
    pDev->Dac.HorizontalRetraceEnd    = timingValues.HorizontalRetraceEnd;
    pDev->Dac.HorizontalBlankEnd      = timingValues.HorizontalBlankEnd;
    pDev->Dac.HorizontalTotal         = timingValues.HorizontalTotal;
    pDev->Dac.VerticalVisible         = timingValues.VerticalVisible;
    pDev->Dac.VerticalBlankStart      = timingValues.VerticalBlankStart;
    pDev->Dac.VerticalRetraceStart    = timingValues.VerticalRetraceStart;
    pDev->Dac.VerticalRetraceEnd      = timingValues.VerticalRetraceEnd;
    pDev->Dac.VerticalBlankEnd        = timingValues.VerticalBlankEnd;
    pDev->Dac.VerticalTotal           = timingValues.VerticalTotal;
    pDev->Dac.PixelDepth              = pDev->Dac.HalInfo.Depth;
    pDev->Dac.HalInfo.PixelClock      = timingValues.PixelClock;
    pDev->Dac.HorizontalSyncPolarity  = timingValues.HSyncpolarity;
    pDev->Dac.VerticalSyncPolarity    = timingValues.VSyncpolarity;
    pDev->Dac.DoubleScannedMode       = (pDev->Framebuffer.HalInfo.VertDisplayWidth < 400) ? TRUE : FALSE;
#endif
} // end of osSetupForNewStyleModeSet

// Os Specifix pre mode set actions.
VOID osPreModeSet(PHWINFO pDev, U032 Head)
{
    U032 DisplayType, data32;
    U032 PrimaryHead;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

    // Check for registry override for display type (TV/MONITOR/FLAT_PANEL)
    // Then check that the device is actually connected. If not, find one that is.

    // Get current display type for this head.
    DisplayType = GETDISPLAYTYPE(pDev, Head);

    // Determine which Head is the PrimaryDevice
    for (PrimaryHead = 0; PrimaryHead < pDev->Dac.HalInfo.NumCrtcs; PrimaryHead++)
    {
        if (pDev->Dac.CrtcInfo[PrimaryHead].PrimaryDevice == TRUE)
        {
            break;
        }
    }

    //
    // Canopus-specific code
    //
    if (pDev->Video.HalInfo.CustomizationCode & CUSTOMER_CANOPUS)
    {
        if (DisplayType==DISPLAY_TYPE_MONITOR) {
            //if(!dacMonitorConnectStatus(pDev)&&dacFlatPanelConnectStatus(pDev))
            //  DisplayType = DISPLAY_TYPE_FLAT_PANEL;
        }
        else {
            if (dacMonitorConnectStatus(pDev, Head)&&!dacFlatPanelConnectStatus(pDev, Head)) {
                DisplayType = DISPLAY_TYPE_MONITOR;
                SETDISPLAYTYPE(pDev, Head, DisplayType);
            }
        }
    }            

    //
    // Reset TV output format value from registry.
    //
    if (dacReadTVOutFromRegistry(pDev, Head, &data32) == RM_OK)
        pDev->Dac.TVoutput = data32;

    // Set the DisplayChanged flag so we can signal the miniVDD that we are no longer on the same display.
    if (Head == PrimaryHead)    // only need to signal for primary
    {                           // if the display type in the object is different from the current display type (in HalInfo)
        pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT) pDev->Dac.CrtcInfo[Head].pVidLutCurDac;
        if (GETDISPLAYTYPE(pDev, Head) != pVidLutCurDac->DisplayType)
            pDev->Dac.DisplayChanged = 1;
        pDev->Dac.CurrentDisplay = GETDISPLAYTYPE(pDev, Head);
    }
}

// Os Specifix post mode set actions.
VOID osPostModeSet(PHWINFO pDev, U032 Head)
{
    PWIN9XHWINFO pOsHwInfo = (PWIN9XHWINFO) pDev->pOsHwInfo;
    RM_STATUS status;
    U032      data32;
    U032      PrimaryHead;

    // Determine which Head is the PrimaryDevice
    for (PrimaryHead = 0; PrimaryHead < pDev->Dac.HalInfo.NumCrtcs; PrimaryHead++)
    {
        if (pDev->Dac.CrtcInfo[PrimaryHead].PrimaryDevice == TRUE)
        {
            break;
        }
    }

    if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_TV)
        dacSetBiosDefaultTVType(pDev, pDev->Dac.TVStandard);

    //
    // Notify the Win9X minivdd that a mode change has probably occurred. This allows
    // it to save any new register states. This is only done for the PrimaryDevice.
    //
    if (Head == PrimaryHead)
    {
        if (pOsHwInfo->miniVDDPostModeChange)  // if primary display, we got callback at init
            if (pDev->Dac.DisplayChanged)
                (*pOsHwInfo->miniVDDPostModeChange)(1);    // signal display change
            else
                (*pOsHwInfo->miniVDDPostModeChange)(0);
        pDev->Dac.DisplayChanged = 0;

        //
        // At the completetion of this modeset, check if there's been a modeset
        // on the other head, if not, call dacDisableDac on that head.
        //
        if (pDev->Dac.CrtcInfo[Head^1].pVidLutCurDac == (VOID_PTR)NULL)
            dacDisableDac(pDev, Head^1);
    }

    // See if there are any registry overrides for the desktop positioning.
    if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_MONITOR)
    {
        U032 cbLen;
        NV_CFGEX_SET_DESKTOP_POSITION_MONITOR_PARAMS position;

        cbLen = 4 * sizeof(U032);
        status = dacReadDesktopPositionFromRegistry(pDev, Head,
                                                    TRUE,  // isMonitor
                                                    (U008 *) &(position.HRetraceStart),
                                                    &cbLen);
        if (status == RM_OK)
        {
            // Program the new values.
            dacSetMonitorPosition(pDev, Head, 
                                  position.HRetraceStart, position.HRetraceEnd,
                                  position.VRetraceStart, position.VRetraceEnd);
        }
    }
    // See if there are any registry overrides for the monitor timing.
    if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_MONITOR)
    {
        NV_CFGEX_CRTC_TIMING_PARAMS timings;

        //
        // First check if there are timings available in the registry for this mode
        //
        timings.Head = Head;
        timings.Reg = NV_CFGEX_CRTC_TIMING_REGISTRY;
        status = dacGetCRTCTiming(pDev, Head, &timings);

        if (status == RM_OK)
        {
            //
            // Program the new values
            //
            timings.Reg = NV_CFGEX_CRTC_TIMING_REGISTER;
            status = dacSetCRTCTiming(pDev, Head, &timings);
        }

    }
    // See if there are any registry overrides for the TV desktop positioning.
    if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_TV) 
    {
        U032 cbLen;
        NV_CFGEX_DESKTOP_POSITION_TV_MULTI_PARAMS Params;

        // Read the registry to get any updates to the default setting.
        // This should be done after dacAdjustCRTCForTV because it involves changes to CRTC.
        cbLen = sizeof(NV_CFGEX_DESKTOP_POSITION_TV_MULTI_PARAMS);
        status = dacReadTVDesktopPositionFromRegistry(pDev, Head, (U008 *) &Params, &cbLen);

        // Make sure data is valid for the current encoder.
        if ((status == RM_OK) && (Params.Encoder_ID == pDev->Dac.EncoderType))
        {
            // Write the saved settings
            dacSetTVPosition(pDev, Head, (U032 *) &Params);
        }
        if (!pDev->Power.MobileOperation)
        {
            dacWriteTVStandardToRegistry(pDev, pDev->Dac.TVStandard);   // save TV standard in registry
        }

    }
    
    // Check/Set any PFB overrides
    if (osReadRegistryDword(pDev,strDevNodeRM, strMemoryOverride, &data32) == RM_OK)
    {
        nvHalFbLoadOverride(pDev, FB_LOAD_OVERRIDE_MEMORY, data32);
    }
    if (osReadRegistryDword(pDev,strDevNodeRM, strRTLOverride, &data32) == RM_OK)
    {
        nvHalFbLoadOverride(pDev, FB_LOAD_OVERRIDE_RTL, data32);
    }
    else
    {
        nvHalFbLoadOverride(pDev, FB_LOAD_OVERRIDE_RTL, 0);
    }

    //
    // If there are graphics debug overrides, use them now
    //
    if (osReadRegistryDword(pDev,strDevNodeRM, strGraphicsDebug0, &data32) == RM_OK)
    {
        nvHalGrLoadOverride(pDev, GR_LOAD_OVERRIDE_DEBUG0, data32);
    }
    if (osReadRegistryDword(pDev,strDevNodeRM, strGraphicsDebug1, &data32) == RM_OK)
    {
        nvHalGrLoadOverride(pDev, GR_LOAD_OVERRIDE_DEBUG1, data32);
    }
    if (osReadRegistryDword(pDev,strDevNodeRM, strGraphicsDebug2, &data32) == RM_OK)
    {
        nvHalGrLoadOverride(pDev, GR_LOAD_OVERRIDE_DEBUG2, data32);
    }
    if (osReadRegistryDword(pDev,strDevNodeRM, strGraphicsDebug3, &data32) == RM_OK)
    {
        nvHalGrLoadOverride(pDev, GR_LOAD_OVERRIDE_DEBUG3, data32);
    }
    
    //
    // Use the display cursor cache override if available
    //
    if (osReadRegistryDword(pDev,pDev->Registry.DBstrDevNodeDisplay, strCursorCacheOverride, &data32) == RM_OK)
    {
        if (data32 == 0)
            pDev->Dac.CursorCacheEnable = 0;
        else            
            pDev->Dac.CursorCacheEnable = 1;
    }
} // end of osPostModeSet

// Registry access functions.
RM_STATUS osReadRegistryBinary
(
    PHWINFO pDev,
    char *regDevNode,
    char *regParmStr,
    U008 *Data,
    U032 *cbLen
)
{
    U032 cbType;
    U032 hkSW;
    U032 ret;

    //
    // Get access to specified Device Node in the registry.
    //
    if (VMM_RegOpenKey(HKEY_LOCAL_MACHINE, regDevNode, (PVMMHKEY)&hkSW) != 0)
        return (RM_ERROR);

    if (hkSW)
    {
        cbType = REG_BINARY;

        // Is this a request to read Global Data ?
        if(regDevNode == strDevNodeRM){
            // Then just read from the global location.
            ret = VMM_RegQueryValueEx(hkSW, regParmStr, NULL, &cbType, (PBYTE)Data, cbLen);
            if (ret != 0L){
                VMM_RegCloseKey(hkSW);
                return (RM_ERROR);
            }
        }else{
            // First attempt to read the data value from the Global area.
            // Then go to the device specific location.
            ret = VMM_RegQueryValueEx(hkSW, strDevNodeRM, NULL, &cbType, (PBYTE)Data, cbLen);
            if (ret != 0L){
                ret = VMM_RegQueryValueEx(hkSW, regParmStr, NULL, &cbType, (PBYTE)Data, cbLen);
                if (ret != 0L){
                    VMM_RegCloseKey(hkSW);
                    return (RM_ERROR);
                }
            }

        }

        VMM_RegCloseKey(hkSW);
    }
    return (RM_OK);
} // end of osReadRegistryBinary

RM_STATUS osWriteRegistryBinary
(
    PHWINFO pDev,
    char *regDevNode,
    char *regParmStr,
    U008 *Data,
    U032 cbLen
)
{
    U032 cbType;
    U032 hkSW;
    U032 ret;

    //
    // Get access to specified Device Node in the registry.
    //
    if (VMM_RegCreateKey(HKEY_LOCAL_MACHINE, regDevNode, (PVMMHKEY)&hkSW) != 0)
        return (RM_ERROR);
    if (hkSW)
    {
        //
        // Write the specified parameter to the registry. (REG_DWORD = 4)
        //
        cbType = REG_BINARY;
        ret = VMM_RegSetValueEx(hkSW, regParmStr, NULL, cbType, Data, cbLen);
        VMM_RegCloseKey(hkSW);
        if (ret != 0L)
            return (RM_ERROR);
    }
    return (RM_OK);
} // end of osWriteRegistryBinary

RM_STATUS osReadRegistryDword
(
    PHWINFO pDev,
    char *regDevNode,
    char *regParmStr,
    U032 *Data
)
{
    U032 cbLen;

    cbLen = 4;
    return osReadRegistryBinary(pDev,regDevNode, regParmStr, (U008 *)Data, &cbLen);
} // end of osReadRegistryDword

RM_STATUS osWriteRegistryDword
(
    PHWINFO pDev,
    char *regDevNode,
    char *regParmStr,
    U032 Data
)
{
    U032 cbLen = 4;
    return osWriteRegistryBinary(pDev,regDevNode, regParmStr, (U008 *)&Data, cbLen);
}

RM_STATUS osDeleteRegistryValue
(
    char *regDevNode,
    char *regParmStr
)
{
    U032 hkSW;
    RM_STATUS status;

    if (VMM_RegOpenKey(HKEY_LOCAL_MACHINE, regDevNode, (PVMMHKEY)&hkSW) != 0)
        return (RM_ERROR);

    if (hkSW) {
        status = VMM_RegDeleteValue(hkSW, regParmStr);
        VMM_RegCloseKey(hkSW);
        return status;
    }
}
    
// We have found that during shutdown (and other instances) Win98 disables the memory mapping
// of the device. This procedure is a workaround for this problem. 
// It is assumed that the global DeviceInstance is set to indicate the desired device.
VOID osEnsureDeviceEnabled(PHWINFO pDev)
{
    U032 bar0_address, pci_address, pci_reg, i;

    //Check if we're in powerdown otherwise we would hang.
    if (pDev->Power.State == MC_POWER_LEVEL_2)
    {
        DBG_BREAKPOINT();
        return;
    }

    bar0_address = pDev->Chip.HalInfo.PciBars[0];
    pci_address = pDev->Mapping.nvBusDeviceFunc;

    if(pDev != NULL && nvAddr->Reg032[0]==0xffffffff)
    {   // The device is disabled.
            
        _asm mov  dx, 0xcf8
        _asm in   eax, dx
        _asm push eax
        _asm mov  eax, pci_address  
        _asm or   eax, 0x80000004 
        _asm out  dx, eax
        _asm mov  dx, 0xcfc
        _asm in   al,dx
        // Enable the memory decode and BusmasterEnable of the PCIO device.
        _asm or   al,6
        _asm out  dx,al
        _asm pop  eax
        _asm mov  dx, 0xcf8
        _asm out  dx, eax
    }

    //Make sure our PCI BAR addresses is what we expect it to be.
    //In some cases we may be moved (which we should not be)
    //or Windows may fail to restore our address. 

    if ((pDev != NULL) && (bar0_address != REG_RD32(NV_PBUS_PCI_NV_4))) 
    {
        for (i = 0, pci_reg = 0x80000010; i < pDev->Chip.HalInfo.TotalPciBars; i++, pci_reg += 4)
        {
            U032 barN_address = pDev->Chip.HalInfo.PciBars[i];

            _asm mov  dx, 0xcf8
            _asm in   eax, dx
            _asm push eax
            _asm mov  eax, pci_address  
            _asm or   eax, pci_reg
            _asm out  dx, eax
            _asm mov  dx, 0xcfc
            _asm mov  eax, barN_address
            _asm out  dx, eax 
            _asm pop  eax
            _asm mov  dx, 0xcf8
            _asm out  dx, eax
        }
    }
}

RM_STATUS osDeviceNameToDeviceClass
(
    char * deviceName,
    U032 * deviceClass
)
{
    RM_STATUS rmStatus = RM_OK;
    U032      deviceIndex;
    U032      deviceNameLen;
    
    switch (*deviceClass) 
    {
        case NV01_DEVICE_0:
        case NV01_DEVICE_1:
        case NV01_DEVICE_2:
        case NV01_DEVICE_3:
        case NV01_DEVICE_4:
        case NV01_DEVICE_5:
        case NV01_DEVICE_6:
        case NV01_DEVICE_7:
            // Nothing to do.
            return RM_OK;
            
        case NV03_DEVICE_XX:
            // Search all the nvinfo structures for a match on device name.
            // All secondary displays will have a non null string in pDev.
            deviceNameLen = osStringLength(deviceName);
            if ((deviceName[deviceNameLen - 1] == '1')  ||
                (deviceName[deviceNameLen - 1] == 'y')  ||
                (deviceName[deviceNameLen - 1] == 'Y'))
            {
                // This must be the Primary display.
                *deviceClass = NV01_DEVICE_0;
                return RM_OK;
            }
            
            for (deviceIndex = 0; deviceIndex < MAX_INSTANCE; deviceIndex++)
            {
                if (NvDBPtr_Table[deviceIndex] != 0)
                {
					PWIN9XHWINFO pOsHwInfo = (PWIN9XHWINFO) &NvDBPtr_Table[deviceIndex];

                    // This device is allocated. 
                    if ((pOsHwInfo->osDeviceName != 0)  &&
                        (osStringCompare(pOsHwInfo->osDeviceName, deviceName)))
                    {
                        // found a match.
                        *deviceClass = deviceIndex + NV01_DEVICE_0;
                        return RM_OK;   
                    }
                } // Device is allocated
            }
            
            // Could not find a match
            return RM_ERROR;
                
        default:
            // invalid device class.
            return RM_ERROR;
    }
}

//
// Read a data word from Priveledged IO
//
// Entry: U032 addr                // Address of controller register
//        U008 reg                 // CR/GR/SR register to read
//
// Exit:  index/data pair
//
U016 ReadIndexedpDev(PHWINFO pDev, U032 addr, U008 reg)
{      
    U016 datum;
              
    //
    // Return the data in the upper byte, index in the lower
    //
    REG_WR08(addr, reg);
    datum = (REG_RD08(addr+1) << 8) & 0xFF00;
    datum |= reg;
    
    return(datum);
}                          


//
// Function call entry to reach the video (VGA) BIOS for various needs.  In general you
// should not rely on, or attempt to call, the BIOS for any support.  Many systems do
// not even carry a copy of the video BIOS in memory.
//
// Be very very sure you need to make such calls, even if they are possible.
//
RM_STATUS osCallVideoBIOS
(
    PHWINFO pDev,
    U032    *pEAX,
    U032    *pEBX,
    U032    *pECX,
    U032    *pEDX,
    VOID    *pBuffer
)
{

    CLIENT_STRUCT     crs;

    // 
    // If no buffer data to pass, use standard Int10h interface
    //
    if (pBuffer == NULL)
    {
        // only care about the lower 16bits
        crs.CWRS.Client_AX = (U016)*pEAX;
        crs.CWRS.Client_BX = (U016)*pEBX;
        crs.CWRS.Client_CX = (U016)*pECX;
        crs.CWRS.Client_DX = (U016)*pEDX;
        VBE(&crs);
        *pEAX = (U032)crs.CWRS.Client_AX;
        *pEBX = (U032)crs.CWRS.Client_BX;
        *pECX = (U032)crs.CWRS.Client_CX;
        *pEDX = (U032)crs.CWRS.Client_DX;
    } 
    else
    {
        //
        // Otherwise construct data-passing interface
        //
        crs.CWRS.Client_AX = (U016)*pEAX;
        crs.CWRS.Client_BX = (U016)*pEBX;
        crs.CWRS.Client_CX = (U016)*pECX;
        crs.CWRS.Client_DX = (U016)*pEDX;
        crs.CRS.Client_ES = 0x0000;         // flat for now
        crs.CRS.Client_EDI = (U032)pBuffer;
        readToshibaEDID(&crs);              // special case call for EDID; really should
                                            // convert to common call!!!
        *pEAX = (U032)crs.CWRS.Client_AX;
        *pEBX = (U032)crs.CWRS.Client_BX;
        *pECX = (U032)crs.CWRS.Client_CX;
        *pEDX = (U032)crs.CWRS.Client_DX;
    }
                            

    if (crs.CWRS.Client_AX == 0x004F)
        return RM_OK;
    else
        return (RM_STATUS)(crs.CWRS.Client_AX);

}

/*

// KEEP AROUND FOR JUST A BIT LONGER

U008 convToToshibaDispMask(PHWINFO pDev, U032 disptype)
{
    if (disptype == DISPLAY_TYPE_FLAT_PANEL) return 1;
    else if (disptype == DISPLAY_TYPE_MONITOR) return 2;
    else if (disptype == DISPLAY_TYPE_TV) return 4;

    return 0;
}


// Function: osGenerateInt10h
//
// Generalized mechanism to pass parameters to VGA BIOS with an int10h call.
// Added to allow communication with the System BIOS (using VGA BIOS as a
// pass-through) in (Toshiba) mobile systems.
// 
// The creation of the display masks loaded into Dl and DH for the DEV_CTRL
// events has not yet been tested, though the other parameters for those calls
// have been.
//
// This function in currently only using the EDID read.  Note that this is
// a Win9x only mechanism -- the most likely final implementation will be
// a custom int10h that causes our BIOS to put the EDID somewhere in our
// frame buffer memory.
//
// Parameters:  pDev
//              event: an event code (defined in os.h)
//              Head: head (0 or 1) -- ignored for EDID read
//              param1: event-specific parameter
//                  (for TOSHIBA_DEV_CTRL_BEGIN, the display this head is switching to
//                   -- 0 if it is being disabled)
//              pEDID: pointer to a 128 byte buffer to copy the EDID into
//
RM_STATUS  osGenerateInt10h(PHWINFO pDev, U032 event, U032 Head, U032 param1, VOID* pEDID)
{
    CLIENT_STRUCT     crs;

    if (!pDev->Power.MobileOperation) return RM_OK;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: making int10h call for event:", event);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: making int10h call for head:", Head);

    crs.CRS.Client_ES = 0x0000;
    crs.CWRS.Client_CX = 0x0000;
    crs.CWRS.Client_DX = 0x0000;

    switch(event) {
    case TOSHIBA_READ_EDID:
        crs.CWRS.Client_AX = 0x4F15;
        crs.CWRS.Client_BX = 0x0001;
        crs.CWRS.Client_CX = 0;  //(U016)Head;  //'controller number' == head, or is primary always 0?
        crs.CWRS.Client_DX = 0x0000;    //EDID block number?
        crs.CRS.Client_EDI = (U032)pEDID;
//        VBE(&crs);
        readToshibaEDID(&crs);
        break;
    case TOSHIBA_DEV_CTRL_BEGIN:
        crs.CWRS.Client_AX = 0x4F14;
        crs.CWRS.Client_BX = 0x028F;
//        crs.CWRS.Client_DX = 0x0202;    //temp
        crs.CBRS.Client_DL = convToToshibaDispMask(pDev, GETDISPLAYTYPE(pDev, Head))
            | convToToshibaDispMask(pDev, GETDISPLAYTYPE(pDev, Head^1));
        crs.CBRS.Client_DH = convToToshibaDispMask(pDev, param1)
            | convToToshibaDispMask(pDev, GETDISPLAYTYPE(pDev, Head^1));
        VBE(&crs);
        break;
    case TOSHIBA_DEV_CTRL_END:
        crs.CWRS.Client_AX = 0x4F14;
        crs.CWRS.Client_BX = 0x038F;
        crs.CBRS.Client_DL = convToToshibaDispMask(pDev, GETDISPLAYTYPE(pDev, Head))
            | convToToshibaDispMask(pDev, GETDISPLAYTYPE(pDev, Head^1));
        crs.CBRS.Client_DH = 0;
        VBE(&crs);
        break;
    }

    if (crs.CWRS.Client_AX == 0x004F)
        return RM_OK;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: int10h call returned error:", crs.CWRS.Client_AX);

    return RM_ERROR;
}
*/


#if DEBUG
//---------------------------------------------------------------------------
//
//  Debugging support.
//
//---------------------------------------------------------------------------

// The current debug display level 
//
// Best to leave it above setup and trace messages, but below warnings and error messages
//
int cur_debuglevel = DBG_LEVEL_DEFAULTS;    // all modules set to warning level

int dbgObject_inuse = DBG_OBJECT_OS; 
   
DBGOBJECT DbgObject[] = { 
    {dbgConfigNull, dbgInitNull, dbgOpenNull, vmmOutDebugString, dbgCloseNull},     // Standard Debug
    {dbgConfigNull, dbgInitSerial, dbgOpenNull, dbgDisplaySerial, dbgCloseNull},    // Serial
    {dbgConfigNull, dbgInitNull, dbgOpenNull, vmmOutDebugString, dbgCloseNull},     // Parallel
    {dbgConfigNull, dbgInitNull, dbgOpenNull, vmmOutDebugString, dbgCloseNull},     // Infrared
    {dbgConfigNull, dbgInitNull, dbgOpenNull, vmmOutDebugString, dbgCloseNull},     // USB
    {dbgConfigNull, dbgInitNull, dbgOpenNull, vmmOutDebugString, dbgCloseNull},     // I2C
};

VOID osDbgBreakPoint
(
    void
)
{
    dbgBreakPoint();
}

VOID osDbgPrintf_va(
    int     module,
    int     debuglevel,
    const char *printf_format,
    va_list arglist)
{
    int     moduleValue = cur_debuglevel;
    char    nv_error_string[MAX_ERROR_STRING];
    char    *p = nv_error_string;
    int     chars_written;

    // get the module
    // put the module we want in the first 2 bits
    moduleValue = moduleValue >> (module * 2);

    // get the value of those two bits
    // mask off the last 30 bits
    moduleValue = moduleValue & 0x00000003;

   if (debuglevel >= moduleValue)
   {
        chars_written = nvDbgSprintf(p, printf_format, arglist);

        DbgObject[dbgObject_inuse].pDisplay(p);
   }
}

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vxd\OSAPI.C ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/
/******************* Operating System Interface Routines *******************\
*                                                                           *
* Module: OSAPI.C                                                           *
*   This is the OS interface module.  All operating system transactions     *
*   pass through these routines.  No other operating system specific code   *
*   or data should exist in the source.                                     *
*                                                                           *
\***************************************************************************/
#ifdef DEBUG
#define CAT_HELPER(x, y)    x##y
#define CAT(x, y)       CAT_HELPER(x, y)
#define MAKE_HEADER(RetType, DecType, Function, Parameters)
#endif
#include "basedef.h"
#include "vmm.h"        // put this first. we redefine macro SF_BIT in nvrm.h
#include "vmmreg.h"
#include "vpicd.h"
#ifdef DEBUG
#include "configmg.h"
#endif
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <dma.h>
#include <fifo.h>
#include <gr.h>
#include <dac.h>
#include <devinit.h>
#include <mc.h>
#include <os.h>
#include <edid.h>
#include <dac.h>
#include "nvrmwin.h"
#include "nvhw.h"
#include "vdd.h"
#include "vnvrmd.h"
#include "oswin.h"
#include "vmmtypes.h"
#include "vmm2.h"       // more vmm services
#include "vwin32.h"
#include "nvcm.h"
#include "nvReg.h"
#include "nvmisc.h"
#include "files.h"
#ifdef DEBUG
#include <vcomm.h>
#include "osdbg.h"
#endif
  
// number of bytes of Instance Memory to save 
#define INST_COPY   (pDev->Pram.HalInfo.TotalInstSize)

//
// prototypes
//
RM_STATUS   EDIDDetect                  (PHWINFO, U032, U032);
VOID CDECL  rmService                   (VOID);
U032 CDECL  rmSetConfig                 (U032*);
RM_STATUS   RmAllocDeviceInstance       (U032*);
RM_STATUS   EDIDRead                    (PHWINFO, U032, U032);
DWORD       OnW32DeviceIoControl        (PDIOCPARAMETERS);
int         osGetNextAvailableInstance  (VOID);

#ifdef DEBUG
U032        vmmTestDebugInstalled       (VOID);
#endif

// wrapper functions in vxdstub
VOID rmUsrAPIEntry(VOID);
VOID rmControlEntry(VOID);

// Prototype of the architecture dispatch function
VOID NvArchRMDispatch(U032 /*function*/, PVOID /*paramPtr*/);

U032   NvInfoSelectors[MAX_INSTANCE] = {0,0,0,0,0,0,0,0};
U032   NvInfoSelectorsSelector;

char strDevNodeRM[128] = NV4_REG_GLOBAL_BASE_PATH "\\" NV4_REG_RESOURCE_MANAGER_SUBKEY;
char strRegistryGlobalParameters[128] = NV4_REG_GLOBAL_BASE_PATH;
char strRmCoreName[] = STR_RM_CORE_NAME;
char strRmCoreVxd[] = NV4_RM_KERNEL_BINARY;

char strMaxRefreshRate[128]               = MAXREFRESHRATE;           
char strMaxOptimalRefreshRate[128]        = MAXOPTIMALREFRESHRATE;    
char strOptimalNotFromEDID[128]           = OPTIMALREFRESHNOTFROMEDID;
char strDMTOverride[128]                  = DMTOVERRIDE;              
char strMonitorTiming[128]                = MONITORTIMING;            
char strCursorCacheOverride[128]          = CURSORCACHE;              
char strDisplayType[128]                  = DISPLAY_TYPE;             
char strDisplay2Type[128]                 = DISPLAY2_TYPE;
char strTVtype[128]                       = TV_TYPE;                  
char strStartUp[128]                      = POWERUPFLAGS;             
char strTVOutType[128]                    = TV_OUT;                   
char strNewModeSet[128]                   = NEWSTYLEMODESET;          
char strFpMode[128]                       = FLATPANELMODE;            


typedef struct MiniVDD_ParameterStruct {
  DWORD  callrm_device_handle;       
  DWORD  callrm_modechange_callback; 
  DWORD  callrm_irq_bus;             
  DWORD  callrm_fbphys;              
  DWORD  callrm_nvphys;              
  DWORD  callrm_registry_path;       
} MiniVDD_ParameterStruct;

//---------------------------------------------------------------------------
//
//  Global variables used thoughout the OS specific module.
//
//---------------------------------------------------------------------------

int global_clientID;

//---------------------------------------------------------------------------
//
//  Global variables used by the OS specific calls.
//
//---------------------------------------------------------------------------
U032        rmInit              = 0;
U032        osPhase             = 0;
U032        *inst_sv;
BOOL        InstanceMemSaved    = FALSE;
BOOL        FirstDynamicInit    = TRUE;

//
// These globals are used by the mediaport callback mechanism; used by Canopus
//
CallBackDef mpCallback, mpImageCallback;
DWORD mpInstalledCallback = FALSE;
DWORD mpImageInstalledCallback = FALSE;
DWORD rmmpInCallback = 0;

#define MVDD_COPY_PTES_FOR_LINEAR_RANGE 0x87650002
U032        p_agp_dummy_page;

U032        ResourceManagerGlobalToken=0;
extern U032        nvInfoSelector;
extern U032        clientInfoSelector;
extern U032        rmInService;
extern U032        osInService;
extern U032        rmInSafeService;
extern U032        rmInCallback;

U032 deviceInstanceSelector;
U032 the16bitProcessDSselector;
U032 the16bitProcessDS;

U032        rmSemaphore;
U032        osSemaphore;

PCALLBACK   osCallbackTable;
PCALLBACK   osCallbackList;
PCALLBACK   osCallbackFreeList;

DISPLAYINFO osDisplayInfo;

// Global semaphore for multi-monitor implementation.
U032        mmSemaphore;
// Used by the MiniVDD to monitor mode changes
U032        mode_changed_after_save = 0;
// Signal cursor re-enable after ACPI resume
U032        resume;

#ifdef DEBUG
extern char * DotN_help;
extern void DotN_cmd_asm();
#endif
extern void RegisterDisplayDriver(PCS  x);

extern WIN9XHWINFO  win9xHwInfo[MAX_INSTANCE];

#ifdef DEBUG
extern int dbgObject_inuse;
extern DBGOBJECT DbgObject[];
extern DBGPORT DbgPort;
#endif

//---------------------------------------------------------------------------
//
//  Resource Manager VxD control function.
//
//---------------------------------------------------------------------------

RM_STATUS rmControl
(
    U032 Msg,
    U032 hVM
//    U032 flags
)
{
    RM_STATUS status;
    U032      i,event;
    CLIENT_STRUCT     crs;
    PHWINFO   pDev = NULL;  // Initialize the pDev to Null.
    PWIN9XHWINFO pOsHwInfo = NULL;

    status = RM_OK;
    //
    // WARNING: Remember that there are no devices initialized during early sections of POST (DEVICE_INIT),
    // so don't attempt to access any pDev structures or fields.  They haven't been built yet.
    //
    switch (Msg)
    {
    //
    // IOCTL Control Interface.
    //
    case W32_DEVICEIOCONTROL:
        {
            PDIOCPARAMETERS ptemp;
            _asm  mov ptemp, esi
            if (ptemp->dwIoControlCode == NVRM_IOCTL_NV_ARCH)
            {
                //
                // Architectural IOCTL.
                //
                U032                  hVM = 0;
                NV_IOCTL_ARCH_STRUCT *ptr = (NV_IOCTL_ARCH_STRUCT *)ptemp->lpvInBuffer;
              
                if (ptr->nvarchFunction <= NVRM_ARCH_MAX_IOCTL)
                    NvArchRMDispatch(ptr->nvarchFunction, (PVOID)ptr->nvarchParameters);
                    //rmArchDispatchTable[ptr->nvarchFunction](hVM, (U032)vmmGetCurrentContext(), (PVOID)ptr->nvarchParameters);
            }
            else
            {
                //
                // Diag stuff.
                //
                OnW32DeviceIoControl(ptemp);
            }
            status = RM_OK;
        }
        break;
        
    case SYS_DYNAMIC_DEVICE_INIT:    
       // We get this message when the primary or the Secondary mini VDD loads nv4rm.vxd using
       // VXDLDR_LoadDevice.
       // I have noticed that we get this message only the first time. Just in case we get called 
       // more than once, we have a global to tell us not to initialize ourselves more than once.
       if (FirstDynamicInit)
       {
#ifdef DEBUG
          DbgObject[dbgObject_inuse].pConfig(NULL);          
          DbgObject[dbgObject_inuse].pInit(&DbgPort);          
          DbgObject[dbgObject_inuse].pOpen(NULL);          
#endif            
          // This is the first dynamic init we have ever got. Initialize global data structures.
          if (!status) status = initSemaphore();
          if (!status) status = initCallbackFreeList();
          if (!status) status = initClientInfo();
          
          if (!status)
          {
              rmInCallback = 0;
              rmInService  = 0;
              osInService  = 0;
              rmInit = DEVICE_INIT; // show we've init'd, thus can be uninit'd
              FirstDynamicInit = FALSE;
          }
       }
       break;
       
    //
    // We now init as a Plug and Play device, but for the time being we'll terminate on these system messages
    // We may want to move the termination code into the Plug and Play handler later.
    case INIT_COMPLETE:
#ifdef DEBUG
        dbgEnableDevice2(&DbgPort);
#endif
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Init_Complete\n\r");
        osPhase = INIT_COMPLETE;
        break;
    case SYS_VM_INIT:
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Sys_VM_Init\n\r");
        osPhase = SYS_VM_INIT;

        // VBE SetMode
        // We'll do a mode set here because the VDD wants to see one, possibly so it will have a chance to save CRTC
        // registers. If we don't do this, the VDD may set a mode 3 later, at a bad time (when a high res display is
        // running) in response to some VGA-type activity (this happens when Winbench 97 starts and tries to find out
        // what type of display is being used).
        crs.CWRS.Client_AX = 0x4F02;
        crs.CWRS.Client_BX = 0x4003;
        VBE(&crs);
    
#ifdef DEBUG
        if(vmmTestDebugInstalled())
        {
          
          // Hook the .dot commands for the winice debugger.
          _asm {
            mov   ax,0070h
            mov   bl,'T'            
            mov   esi, offset DotN_cmd_asm
            mov   edi, offset DotN_help
            int   41h
          }
          DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Soft-Ice/w Extension Installed\n\r");
        }
#endif  
     
        break;
    case POWER_EVENT:   // Win 3.1 style power event (display driver will not handle)
        _asm mov event,esi

        {
            int max_device,DeviceInstance;
            U032 Head = 0;  // TO DO: for all heads
            
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Control: PowerEvent=", event);

            max_device = osGetNextAvailableInstance();
            for(DeviceInstance=0;DeviceInstance<max_device;DeviceInstance++){
                // Make sure the memory window for the device is enabled.
                pDev = NvDBPtr_Table[DeviceInstance];

                // Ignore old-style event if PM supported.
                if(pDev->Power.Flags & DAC_PM_SUPPORTED)
                    break;
            
                     pOsHwInfo = (PWIN9XHWINFO) pDev->pOsHwInfo;
                osEnsureDeviceEnabled(pDev);
                REG_WR08(NV_PRMCIO_CRX__COLOR, 0x571F & 0xFF); 
                REG_WR08(NV_PRMCIO_CRX__COLOR+1, (0x571F >> 8) & 0xFF);
                ////OEMEnableExtensions();
                switch (event)
                {
                    case 1:     // suspend
                        if (pDev->Power.State == MC_POWER_LEVEL_0)
                        {
                            // turn off the monitor
                                       if(pDev->Power.Flags & DAC_POWER_PENDING)
                                       {
                                             //Reset global power_pending flag
                                             pDev->Power.Flags &= ~DAC_POWER_PENDING;

                                             // Bug 29711: if you hibernate on CRT, unplug CRT, boot back up
                                             // on LCD, the LCD blooms. When we get to this function, we do
                                             // a modeset on the CRT because the pVidLutCurDacs are setup for
                                             // head A = CRT and head B = Nothing.  If we reset the chip in 
                                             // mcPowerState, we turn off the flat panel clocks.  When we call 
                                             // Wake Up in this function, the LCD turns on, but the clocks
                                             // do not. This causes blooming.  
                                             // So to fix this, if we've reset the chip, and we've boot to  
                                             // an LCD, don't power on the panel!  The Reset flag is turned
                                             // off at the end of dacSetFlatPanelMode in dacfp.c.
                                             if(pDev->Dac.DevicesEnabled & DAC_PANEL_CLK_RESET)
                                             {
                                                     if(pDev->Dac.BootDevicesBitMap & DAC_DD_MASK_IN_MAP)
                                                     {
                                                             DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Set Monitor Power called after chip reset without panel clocks setup!\n");
                                                             break;
                                                     }
                                             }

                                             for(Head = 0; Head < MAX_CRTCS; Head++)
                                             {
                                                     if ((GETDISPLAYTYPE(pDev, Head) != DISPLAY_TYPE_NONE))
                                                     {
                                                             // Enable display
                                                             dacEnableDac(pDev, Head);

                                                             // also make sure the cursor image is updated
                                                             pDev->Dac.CrtcInfo[Head].UpdateFlags &= (~UPDATE_HWINFO_DAC_CURSOR_ENABLE);
                                                             pDev->Dac.CrtcInfo[Head].UpdateFlags |= (UPDATE_HWINFO_DAC_CURSOR_IMAGE_NEW |
                                                                                                                                       UPDATE_HWINFO_DAC_CURSOR_DISABLE);
                                                     }
                                             }

                                             //Toshiba specefic call (DPMS, hotkeys)
                                             //Backlight enabled inside dacEnableDac for other mobiles
                                             if (pDev->Power.MobileOperation == 2)
                                             { 
                                                     U032    EAX, EBX, ECX, EDX;
                                                     EAX = 0x4F10;
                                                     EBX = 0x0001; //wake up
                                                     EDX = 0x0000;
                                                     ECX = 0x0000;
                                                     status = osCallVideoBIOS(pDev, &EAX, &EBX, &ECX, &EDX, NULL);
                                             }
                                       }
                            // enter power level
                            mcPowerState(pDev, MC_POWER_LEVEL_4, 0);
                        }                
                        break;
                    // suspend-resume or critical-resume
                    case 2:
                    case 3:
                        if (pDev->Power.State == MC_POWER_LEVEL_4)
                        {
                            // leave power level
                            mcPowerState(pDev, MC_POWER_LEVEL_0, 0);
                            //
                            //  Windows 98 will only trigger a modeset if you are at the
                            //  desktop .. so if you're at the login screen we're SOL
                            //  going to force a modeset.
                            //
                            if (pDev->Power.MobileOperation) 
                            {
                                pDev->Vga.Enabled = TRUE;   // We actually are already in HiRes
                                rmEnableHiRes(pDev, TRUE);                          
                            }
                            // turn monitor back on

                           // Bug 29711: if you hibernate on CRT, unplug CRT, boot back up
                                       // on LCD, the LCD blooms. When we get to this function, we do
                                       // a modeset on the CRT because the pVidLutCurDacs are setup for
                                       // head A = CRT and head B = Nothing.  If we reset the chip in 
                                       // mcPowerState, we turn off the flat panel clocks.  When we call 
                                       // Wake Up in this function, the LCD turns on, but the clocks
                                       // do not. This causes blooming.  
                                       // So to fix this, if we've reset the chip, and we've boot to  
                                       // an LCD, don't power on the panel!  The Reset flag is turned
                                       // off at the end of dacSetFlatPanelMode in dacfp.c.
                                       if(pDev->Dac.DevicesEnabled & DAC_PANEL_CLK_RESET)
                                       {
                                             if(pDev->Dac.BootDevicesBitMap & DAC_DD_MASK_IN_MAP)
                                             {
                                                     DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Set Monitor Power called after chip reset without panel clocks setup!\n");
                                                     break;
                                             }
                                       }

                                       for(Head = 0; Head < MAX_CRTCS; Head++)
                                       {
                                             if ((GETDISPLAYTYPE(pDev, Head) != DISPLAY_TYPE_NONE))
                                             {
                                                   // Enable display
                                                   dacEnableDac(pDev, Head);

                                                   // also make sure the cursor image is updated
                                                   pDev->Dac.CrtcInfo[Head].UpdateFlags &= (~UPDATE_HWINFO_DAC_CURSOR_ENABLE);
                                                   pDev->Dac.CrtcInfo[Head].UpdateFlags |= (UPDATE_HWINFO_DAC_CURSOR_IMAGE_NEW |
                                                                                                                               UPDATE_HWINFO_DAC_CURSOR_DISABLE);
                                             }
                                       }

                                       //Toshiba specefic call (DPMS, hotkeys)
                                       //Backlight enabled inside dacEnableDac for other mobiles
                                       if (pDev->Power.MobileOperation == 2)
                                       { 
                                             U032    EAX, EBX, ECX, EDX;
                                             EAX = 0x4F10;
                                             EBX = 0x0001; //wake up
                                             EDX = 0x0000;
                                             ECX = 0x0000;
                                             status = osCallVideoBIOS(pDev, &EAX, &EBX, &ECX, &EDX, NULL);
                                       }
                        }
                        break;
                }
                REG_WR08(NV_PRMCIO_CRX__COLOR, 0x991F & 0xFF); 
                REG_WR08(NV_PRMCIO_CRX__COLOR+1, (0x991F >> 8) & 0xFF);
                ////OEMDisableExtensions();
            }
        }
        // return status = RM_OK, this will ensure carry clear (must do)
        break;
     case CRIT_REBOOT_NOTIFY2:
        // Disable interrupts
        pDev = NvDBPtr_Table[0];
        pOsHwInfo = (PWIN9XHWINFO) pDev->pOsHwInfo;
        REG_WR32(NV_PMC_INTR_EN_0, 0);
        //
        // There is a bug in the current mobile BIOS where it does not explicitly program
        // the FP clock routing register.  It relies on the fact that it resets to 0, which
        // means the FP should be using HeadA.  Since the OS uses HeadB, a restart of the
        // system (warm) results in a bloom screen.  Until the BIOS fixes this, force
        // it back to HeadA as we leave the OS.
        //
        // REMOVE REMOVE REMOVE 
        //
        if (pDev->Power.MobileOperation)
        {
            // Check the BIOS rev
            if ((pDev->Chip.BiosRevision & 0xFF00FFFF) < 0x03000020)
            {
                // Not a multi-head BIOS
                dacDisableDac(pDev, 1);             // clear HeadB's device in case the BIOS doesn't
                REG_WR32(NV_PRAMDAC_SEL_CLK, 0);    // force the DFP back to HeadA
            }
        }
        else
           // turn on scaling mode for Windows reboot screen--BIOS won't reprogram FP regs
            DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _MODE, _SCALE, 0); // desktop BIOS uses head A

        break;
     case KERNEL32_SHUTDOWN:
     case SYS_VM_TERMINATE:
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Sys_VM_Terminate\n\r");
        if (osPhase == SYS_VM_TERMINATE)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Sys_VM_Terminate again!\n\r");
            //DBG_BREAKPOINT();
        }
        osPhase = SYS_VM_TERMINATE;

        //
        // Terminate all active devices
        //        
        for (i=0;i<MAX_INSTANCE;i++)
        {
          // Check if this device exists.
          if (NvDBPtr_Table[i] != NULL)
          {
            pDev = NvDBPtr_Table[i];
            pOsHwInfo = (PWIN9XHWINFO) pDev->pOsHwInfo;
          
            osEnsureDeviceEnabled(pDev);
            // Make sure the device is enabled for this. During a shutdown I have found Win98 disabling the memory
            // map of the device.
            // How about if Win98 decides to unmap us. Huh?
            // Just unhook the interrupt and avoid the stateNv(STATE_DESTROY) in that case.
            {
              U032 we_are_mapped;
              U032 pci_address;
              
              // Check if the device has become unmapped. If so stop servicing.
              // Read the 1st base register.
              pci_address = pDev->Mapping.nvBusDeviceFunc;
              _asm mov  eax, pci_address  
              _asm or   eax, 0x80000010 
              _asm mov  dx, 0xcf8
              _asm out  dx, eax
              _asm mov  dx, 0xcfc
              _asm in   eax,dx
              _asm mov  we_are_mapped,eax
              
              DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Disable and Unhook interrupt on device ", i);
              if(we_are_mapped)
              {
                  if (rmInit == DEVICE_INIT)  // only if we were init'd should we have anything to do
                  {
                      //
                      // Nothing to callback to.
                      //
                      pOsHwInfo->dllIpcOffset = 0;
                      pOsHwInfo->dllIpcSelector    = 0;
                      pOsHwInfo->dllNotifyOffset   = 0;
                      pOsHwInfo->dllNotifySelector = 0;
                      osCallbackList    = NULL;
                  }
                
                  stateNv(pDev, STATE_DESTROY);
                  if (pDev->Mapping.hpicIRQ)
                     VPICD_Force_Default_Behavior(pDev->Mapping.hpicIRQ);
                  pDev->Mapping.hpicIRQ = NULL;
                  pDev->DeviceDisabled = TRUE;

                  // Turn off other devices for shutdown
                  if (pDev->Power.MobileOperation)
                  {
                  U032 Broadcast;
                  U032 VGAHead;
                  U032 i;
                  U032 CR3B;
                  U008 Lock0;
                  U008 Lock1;
               
                     Lock0 = UnlockCRTC(pDev, 0x0);
                     Lock1 = UnlockCRTC(pDev, 0x1);
                     CRTC_RD(0x3C, Broadcast, 0); 
                     Broadcast &= 0x02;
//                     if (!Broadcast)
                     {
                        // Determine which head is the Primary device
                        for (i = 0, VGAHead = 0; i < pDev->Dac.HalInfo.NumCrtcs; i++)
                        {
                           if (pDev->Dac.CrtcInfo[i].PrimaryDevice == TRUE)
                           {
                              VGAHead = i;
                              break;
                           }
                        }
                     CRTC_RD(0x3B, CR3B, VGAHead^0x01);
                     CRTC_WR(0x3B, CR3B & 0x0F, VGAHead^0x01);
                     } 
                     RestoreLock(pDev, 0x0, Lock0);
                     RestoreLock(pDev, 0x1, Lock1);
                  }
              }
              else
              {
                  if (pDev->Mapping.hpicIRQ)
                     VPICD_Force_Default_Behavior(pDev->Mapping.hpicIRQ);
                  pDev->Mapping.hpicIRQ = NULL;
                  pDev->DeviceDisabled = TRUE;
              } 
            }
            
            //
            // Clear the device structure
            //
            NvDBPtr_Table[i] = NULL;
          } // This device exists.
        } // for all devices
               
        break;
    case SYSTEM_EXIT:
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: System_Exit\n\r");
        // nothing to do here.
        break;
    case SYS_CRITICAL_EXIT:
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Sys_Critical_Exit\n\r");
#ifdef DEBUG
        DbgObject[dbgObject_inuse].pClose(NULL);          
#endif            
        osPhase = SYS_CRITICAL_EXIT;
        rmInit = 0;
        break;
    default:
        // DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Unhandled rmControl msg: ", Msg);
        break;
    }
    return (status);
}

//---------------------------------------------------------------------------
//
//  Function to determine if Windows is terminating.
//
//---------------------------------------------------------------------------
BOOL osTerminating (VOID)
{
   return((osPhase == SYS_CRITICAL_EXIT) ||
      (osPhase == SYSTEM_EXIT) ||
      (osPhase == SYS_VM_TERMINATE));
}

//---------------------------------------------------------------------------
//
//  Resource Manager service functions.
//  These are called from the miniVDD
//
//---------------------------------------------------------------------------

//  response to PreHiResToVga. We are going to full screen DOS.
U032 CDECL rmEnableVga
(
    PHWINFO pDev,
    BOOL PrimaryDevice
)
{
    U032 page;
    U032 size;
    U032 i, VGAHead;
    U032 status;
    U032 *fb_sv;
    U008 data8;
    
    // Indicate that we are going to a DOS Box.
    pDev->Vga.DOSBox = TRUE;
    
    rmInService++;
    stateNv(pDev, STATE_UNLOAD);
    
//  clear the screen: if we're shutting down after an re-install, we don't want to leave a mess on the screen 
//  between now and when Windows puts up the "Windows is restarting" message.
    page = pDev->Framebuffer.HalInfo.Start[pDev->Framebuffer.Current] / 4;
    size = (pDev->Dac.HalInfo.Depth / 8) * pDev->Framebuffer.HalInfo.HorizDisplayWidth * pDev->Framebuffer.HalInfo.VertDisplayWidth / 4;
    for (i = 0; i < size; i++)
    {
        fbAddr->Reg032[page + i] = 0;
    }
    pDev->Vga.Enabled = TRUE;
    stateNv(pDev, STATE_LOAD);
    
    // In VGA mode, set flag for BIOS to program TV encoder
    REG_WR08(NV_PRMCIO_CRX__COLOR, 0x571F & 0xFF); 
    REG_WR08(NV_PRMCIO_CRX__COLOR+1, (0x571F >> 8) & 0xFF);
    CRTC_RD(NV_CIO_CRE_SCRATCH1__INDEX, data8, 0);
    CRTC_WR(NV_CIO_CRE_SCRATCH1__INDEX, data8 & ~0x02, 0);  // clear bit 1 (OK to program TV encoder)
    REG_WR08(NV_PRMCIO_CRX__COLOR, 0x991F & 0xFF); 
    REG_WR08(NV_PRMCIO_CRX__COLOR+1, (0x991F >> 8) & 0xFF);
    
    if (PrimaryDevice && pDev->Vga.Enabled)
    {
            // Copy instance memory to save area.
            // The first 64k is BIOS image (looking backwards from the top). If the BIOS does
            // not get POSTed after standby (BIOS POST can be turned off in BIOS SETUP), 
            // we need to have a copy to use to re-init the device (we use the BIOS init tables),
            // so we'll copy the BIOS image into our save buffer.
            status = osAllocMem((VOID **)&inst_sv, INST_COPY);
            fb_sv = inst_sv;
            if (!status)
            {
                for(i=0; i < INST_COPY/4; i++)
                {
                    *fb_sv++ = REG_RD32(NV_PRAMIN_DATA032(i)); // from the top
                                                               // this actually decrements from the top
                }            
                InstanceMemSaved = TRUE;    // let rmEnableHires restore it
            }
            nvHalFbControl(pDev, FB_CONTROL_INSTWR_DISABLE);
    }
    else
    {
        // For the secondary displays, disable the interrupts.
        REG_WR32(NV_PMC_INTR_EN_0, 0);
        pDev->DeviceDisabled = 1;
    }

//    pDev->Dac.DeviceProperties.InferAuxDev = TRUE;
    pDev->Dac.DeviceProperties.LastSwitchEvent = SWITCH_FROM_FS_DOS;

    DisableMobileHotkeyHandling(pDev);

    // Determine which head is the Primary device
    for (i = 0, VGAHead = 0; i < pDev->Dac.HalInfo.NumCrtcs; i++)
    {
        if (pDev->Dac.CrtcInfo[i].PrimaryDevice == TRUE)
        {
            VGAHead = i;
            break;
        }
    }

    pDev->Dac.CrtcInfo[0].MonitorPowerSetMode = FALSE;
    pDev->Dac.CrtcInfo[1].MonitorPowerSetMode = FALSE;

    // Check the BIOS type: multihead or single head
    // Currently mobile is multihead and desktop is single head.
    // Sometimes Cr44 gets switched to "3" without Head2RegOwner getting update,
    // and the update of the register is skipped. We can't let this happen, so set to UNKNOWN.
    pDev->Dac.HalInfo.Head2RegOwner = HEAD2_OWNER_UNKNOWN; 
    if (!pDev->Power.MobileOperation)
    {
        // Not a multi-head BIOS
        if (pDev->Dac.CrtcInfo[0].pVidLutCurDac != NULL)
        {
            // if going to DOS FS, the BIOS has already set mode. Doing this will kill the TV encoder.
//            dacDisableDac(pDev, 1);    // blank display on the other head
            EnableHead(pDev, 0);       // but leave pointing to head 0
        }
    }
    else
    {
        // Is a multi-head BIOS
        if (pDev->Dac.CrtcInfo[VGAHead].pVidLutCurDac != NULL)
        {
            U008 lockA, lockB, Cr3B[2];
            
            // Read both Cr3B registers
            lockA = UnlockCRTC(pDev, 0);
            lockB = UnlockCRTC(pDev, 1);
            CRTC_RD(0x3B, Cr3B[0], 0);
            CRTC_RD(0x3B, Cr3B[1], 1);

            RestoreLock(pDev, 0, lockA);
            RestoreLock(pDev, 1, lockB);
            
            // check to see if we need to disable second head
            if (!pDev->Dac.BroadcastSupport)  // BIOS/chip revision does not support broadcast mode
            {
                U032 SecondaryHead = VGAHead^1;

                // only turn on TV flag if we intend to disable TV in dacDisableDac().
                if(((PVIDEO_LUT_CURSOR_DAC_OBJECT)pDev->Dac.CrtcInfo[SecondaryHead].pVidLutCurDac)->DisplayType == DISPLAY_TYPE_TV)
                {
                    pDev->Dac.DevicesEnabled |= (DAC_TV_ENABLED); // force disabling of TV in case we already
                                                                  // disabled, but BIOS reenabled during detection.
                }
                
                dacDisableDac(pDev, VGAHead^1);    // blank display on the other head
                EnableHead(pDev, VGAHead);         // should be unnecessary, but just in case

                // Clear out the secondary head nibble
                lockA = UnlockCRTC(pDev, SecondaryHead);
                CRTC_WR(0x3B, (Cr3B[SecondaryHead]&0x0F), SecondaryHead);
                RestoreLock(pDev, SecondaryHead, lockA);
            }
            else
            {
                // We do have a Broadcast aware VBIOS/Chip.  
                // We need to make sure to set Broadcast mode here if not set.
                // Do both heads have active displays?
                if((Cr3B[0]&0xF0) && (Cr3B[1]&0xF0))
                {
                    // 
                    // Both displays are active, so enable broadcast mode
                    lockA = UnlockCRTC(pDev, 0);
                    CRTC_WR(NV_CIO_CRE_H2OWNS, 0x4, 0);
                    RestoreLock(pDev, 0, lockA);
                    pDev->Dac.HalInfo.Head2RegOwner = HEAD2_OWNER_UNKNOWN;
                }
  
            }
            
            
            // Save off this information here for rmEnableHires
            if(pDev->Dac.DeviceProperties.Spanning)
            {
                pDev->Dac.NonBroadcastModeStoredCr3B[0] = Cr3B[0]&0xF0;
                pDev->Dac.NonBroadcastModeStoredCr3B[1] = Cr3B[1]&0xF0;
            }
        }
    }

    rmInService--;
    return (RM_OK);
} // end of rmEnableVga


//  Called from mini-VDD PreVgaToHiRes. We are returning to Windows from full screen DOS.
//  Or called from NVRM_API_CONFIG_VGA. The display driver is asking us to go to hires.
//  Note: we should probably only call this from the mini-VDD, meaning the display driver should do the VDD call instead
//  of calling us directly.
U032 CDECL rmEnableHiRes
(
    PHWINFO pDev,
    BOOL PrimaryDevice
)
{
    PWIN9XHWINFO pOsHwInfo = (PWIN9XHWINFO) pDev->pOsHwInfo;
    U032 page;
    U032 size;
    U032 i;
    U032 data;
    U032 *fb_sv;
    U032 new_config = 0;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U008 lockA, lockB, Cr3B[2];


    if (!pDev->Vga.Enabled)
    {
        //
        // We're already in graphics mode or VGA is Windows display,
        // so do nothing.
        //
        return (RM_OK);
    }

    // Clear up CR44 if Broadcast mode was set.
    // The cached state, Head2RegOwner, can be incorrect if
    // display switch to Broadcast mode happens in VBIOS/rmEnableVGA().
    if (REG_RD_DRF(_PBUS, _DEBUG_1, _DISP_MIRROR))
    {
        // Determine which head is the Primary device
        for (i = 0; i < pDev->Dac.HalInfo.NumCrtcs; i++)
        {
            if (pDev->Dac.CrtcInfo[i].PrimaryDevice == TRUE)
            {
                break;
            }
        }
        
        pDev->Dac.HalInfo.Head2RegOwner = HEAD2_OWNER_UNKNOWN;
        EnableHead(pDev, i);
    }

    // restore the displays for both Cr3B registers
    lockA = UnlockCRTC(pDev, 0);
    lockB = UnlockCRTC(pDev, 1);
    CRTC_RD(0x3B, Cr3B[0], 0);
    CRTC_RD(0x3B, Cr3B[1], 1);
    
    // Restore Cr3B information if we were in extended mode
    if(pDev->Dac.DeviceProperties.Spanning)
    {
        CRTC_WR(0x3B, (pDev->Dac.NonBroadcastModeStoredCr3B[0] | (Cr3B[0]&0x0F)), 0);
        CRTC_WR(0x3B, (pDev->Dac.NonBroadcastModeStoredCr3B[1] | (Cr3B[1]&0x0F)), 1);
    }

    RestoreLock(pDev, 0, lockA);
    RestoreLock(pDev, 1, lockB);

    // Update DeviceEnabled Flags if we're switching back from DOS.
    // If we're switching back from a power save state, the 
    // DevicesEnabled will be updated in mcPowerState().
    if ((pDev->Power.MobileOperation) && 
        (pDev->Dac.DeviceProperties.LastSwitchEvent == SWITCH_FROM_FS_DOS))
    {
        //Set startup display options based on BIOS CR3B settings.
        pDev->Dac.DevicesEnabled &= ~(DAC_ALL_DEVICES_ENABLED);
        if (Cr3B[0] & 0x20) 
        {
            // CRT tracking is not used yet.
            //pDev->Dac.DevicesEnabled |= DAC_CRT_ENABLED;
        }
        else if (Cr3B[0] & 0x40) 
        {
            pDev->Dac.DevicesEnabled |= DAC_TV_ENABLED;
        } 
        
        if (Cr3B[1] & 0x10) 
        {
            pDev->Dac.DevicesEnabled |= DAC_PANEL_ENABLED;
        }
    }

//    dacDetectDevices(pDev, FALSE, pDev->Dac.DeviceProperties.OverrideSBIOSDevs);
    dacDetectDevices(pDev, FALSE, TRUE);

    if (PrimaryDevice)
    {
        //
        // Reenable access to instance memory
        //
        nvHalFbControl(pDev, FB_CONTROL_INSTWR_ENABLE);

        if (InstanceMemSaved)
        {
            // Copy from save area to framebuffer instance memory
            // The first 64k is BIOS image (looking backwards from the top). If the BIOS does
            // not get POSTed after standby (BIOS POST can be turned off in BIOS SETUP), 
            // we need to have a copy to use to re-init the device (we use the BIOS init tables),
            // so we'll copy the BIOS image into our save buffer.
            fb_sv = inst_sv;
            for(i=0; i < INST_COPY/4; i++)
            {
                 data = *fb_sv++;
                 REG_WR32(NV_PRAMIN_DATA032(i), data);
            }            
            osFreeMem((VOID *)inst_sv);
            InstanceMemSaved = FALSE;
        }
    }
    else
    {
        // For secondary devices, enable interrupts.
        REG_WR32(NV_PMC_INTR_EN_0, pDev->Chip.IntrEn0);
        pDev->DeviceDisabled = 0;
    }
    
    //
    // Save/Reload state info.
    //
    rmInService++;
    
    // mcPowerState will call stateNv during ACPI resume. Don't do it twice.
    // (rmUsrApi will also set back to Vga.Enabled, even tho mcPowerState it clears it to load Hires state; 
    // this is so Win2k can avoid making a second call to load state.)
    if (resume == 0) 
    {
        stateNv(pDev, STATE_UNLOAD);
        pDev->Vga.Enabled = FALSE;
        
        // clear display memory (in case we lost power in standby)
        page = pDev->Framebuffer.HalInfo.Start[pDev->Framebuffer.Current] / 4;
        size = (pDev->Dac.HalInfo.Depth / 8) * pDev->Framebuffer.HalInfo.HorizDisplayWidth * pDev->Framebuffer.HalInfo.VertDisplayWidth / 4;
        for (i = 0; i < size; i++)
        {
            fbAddr->Reg032[page + i] = 0;
        }

        stateNv(pDev, STATE_LOAD);
    }

    //Check global powerup pending flag. Win9x display driver will do the modeset
    //call right after this call so we can bypass extraneous modeset call here.
//!!! Commented this out because there was no display on LCD after monitor poweroff from clone
//!!!    if(!(pDev->Power.Flags & DAC_POWER_PENDING))
    {
        //
        // Check if the we need to do the modesets here or not. It's possible the
        // monitor power routines have already done it. Also, if we're setting the
        // panel call the dacSetModeStart/dacSetModeEnd which control the backlight.
        //
        pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)pDev->Dac.CrtcInfo[0].pVidLutCurDac;
        if (pVidLutCurDac && (pDev->Dac.CrtcInfo[0].MonitorPowerSetMode == FALSE))
        {
            switch (pVidLutCurDac->DisplayType)
            {
                case DISPLAY_TYPE_MONITOR:
                    new_config |= 0x00000001; break;
                case DISPLAY_TYPE_TV:
                    new_config |= 0x00000100; break;
                case DISPLAY_TYPE_FLAT_PANEL:
                    new_config |= 0x00010000; break;
            }
        }
        pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)pDev->Dac.CrtcInfo[1].pVidLutCurDac;
        if (pVidLutCurDac && (pDev->Dac.CrtcInfo[1].MonitorPowerSetMode == FALSE))
        {
            switch (pVidLutCurDac->DisplayType)
            {
                case DISPLAY_TYPE_MONITOR:
                    new_config |= 0x00000001; break;
                case DISPLAY_TYPE_TV:
                    new_config |= 0x00000100; break;
                case DISPLAY_TYPE_FLAT_PANEL:
                    new_config |= 0x00010000; break;
            }
        }

        // If a flat panel is involved, start the modeset
        if (new_config & 0x00010000)
            dacSetModeStart(pDev, (new_config | NV_CFGEX_DISPLAY_CHANGE_BRACKETS_MODESET));

        // Do modesets on active heads (if SET_MONITOR_POWER hasn't already)
        if (pDev->Dac.CrtcInfo[0].MonitorPowerSetMode == FALSE)
        {
            pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)pDev->Dac.CrtcInfo[0].pVidLutCurDac;
            if (pVidLutCurDac && (pVidLutCurDac->DisplayType != DISPLAY_TYPE_NONE))
            {
                dacSetModeFromObjectInfo(pDev, pVidLutCurDac);
                pDev->Dac.CrtcInfo[0].MonitorPowerSetMode = TRUE;
            }
        }
        if (pDev->Dac.CrtcInfo[1].MonitorPowerSetMode == FALSE)
        {
            pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)pDev->Dac.CrtcInfo[1].pVidLutCurDac;
            if (pVidLutCurDac && (pVidLutCurDac->DisplayType != DISPLAY_TYPE_NONE))
            {
                dacSetModeFromObjectInfo(pDev, pVidLutCurDac);
                pDev->Dac.CrtcInfo[1].MonitorPowerSetMode = TRUE;
            }
        }

        // If a flat panel was involved, end the modeset
        if (new_config & 0x00010000)
            dacSetModeEnd(pDev, (new_config | NV_CFGEX_DISPLAY_CHANGE_BRACKETS_MODESET));
    }

    EnableMobileHotkeyHandling(pDev);

    rmInService--;

    // If we resumed from power save, the cursor is disabled. Normally we expect Windows to re-enable.
    if (resume)
    {
        pDev->Dac.CrtcInfo[0].CursorType = DAC_CURSOR_TWO_COLOR_XOR;   // Enable cursor, because Windows won't.
        resume = 0;
    }                        

    pDev->Vga.Enabled = FALSE;
    pDev->Vga.DOSBox = FALSE;
    // Now Vga.Enable = FALSE. If we are resuming from power management, it would have been TRUE, and we might have processed
    // an IRQ, in which case the IRQ process would have returned with interrupts disabled, so we should now reenable.
    REG_WR32(NV_PMC_INTR_EN_0, pDev->Chip.IntrEn0);

    // BIOS uses legacy readback, RM uses standard readback
    if (pDev->Dac.EncoderType == NV_ENCODER_BROOKTREE_871) 
    {
        dacTV871Readback(pDev, 0, 1);  // set non-legacy readback mode
    }

    return (RM_OK);
} // end of rmEnableHiRes

VOID RmEnableInterrupts(
    PHWINFO pDev
)
{
    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVGFX: Enabling NV interrupts...\n");
    REG_WR32(NV_PMC_INTR_EN_0, pDev->Chip.IntrEn0);

} // end of RmEnableInterrupts();

//---------------------------------------------------------------------------
//  rmConfigStart
//  Response to Plug and Play handler's ConfigStart message.
//  Perform physical to linear address translation and init the resource manager
//  This function takes globals nvPhys and fbPhys and translates addresses to nvAddr and fbAddr,
//  and translates nvIRQ to pDev->Mapping.Intline.
//
//---------------------------------------------------------------------------
U032 CDECL rmConfigStart(PHWINFO pDev)
{
    PWIN9XHWINFO pOsHwInfo = (PWIN9XHWINFO) pDev->pOsHwInfo;
    RM_STATUS status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: ConfigStart\n\r");
    
    //
    // Remap address of NV (16meg) ?
    //
    if (pDev->Mapping.nvPhys != pDev->Mapping.PhysAddr)
    {
        (U032)pDev->Mapping.PhysAddr = pDev->Mapping.nvPhys;
//  the mapping will take place in nvState(state_init)
//        nvAddr = vmmMapPhysToLinear(pDev->Mapping.PhysAddr, 0x01000000, 0);
    }
        
    //
    // Remap address of NV framebuffer (16meg)
    //
    if (pDev->Mapping.fbPhys != pDev->Mapping.PhysFbAddr)
    {
        pDev->Mapping.PhysFbAddr = pDev->Mapping.fbPhys;
//  the mapping will take place in nvState(state_init)
//        fbAddr = vmmMapPhysToLinear(pDev->Mapping.PhysFbAddr, 0x01000000, 0);
    }        
    //
    // Rehook IRQ?
    //
    if (pDev->Mapping.nvIRQ != pDev->Mapping.IntLine)
    {
        pDev->Mapping.IntLine = pDev->Mapping.nvIRQ;
    }
    
    status = RM_OK;
    
    //
    // Grab state of the display first.
    // 
    osDisplayInfo.HdrSize = sizeof(DISPLAYINFO);
    vddGetDisplayInfo(pOsHwInfo->osDeviceHandle, &osDisplayInfo, sizeof(DISPLAYINFO));
#ifdef RM_STATS
    //
    // Init all per device data structures.
    //
    pDev->Statistics.MemAlloced = 0;
    pDev->Statistics.MemLocked  = 0;
#endif    
    status = stateNv(pDev, STATE_INIT);
    //
    // For Windows, come up as VGA until display drivers
    // disables it thus enabling high-res.
    //
    pDev->Vga.Enabled = TRUE;
    if (!status) status = stateNv(pDev, STATE_LOAD);
    
    return (status);
    
}

//---------------------------------------------------------------------------
//  rmConfigStop 
//  Currently used when we get an ACPI D3 message.
//---------------------------------------------------------------------------
U032 CDECL rmConfigStop(PHWINFO pDev)
{
    PWIN9XHWINFO pOsHwInfo = (PWIN9XHWINFO) pDev->pOsHwInfo;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: ConfigStop\n\r");
    //
    // Nothing to callback to.
    //
    pOsHwInfo->dllIpcOffset      = 0;
    pOsHwInfo->dllIpcSelector    = 0;
    pOsHwInfo->dllNotifyOffset   = 0;
    pOsHwInfo->dllNotifySelector = 0;
    osCallbackList    = NULL;
    
    //
    // Are we still mapped? If secondary display, probably not.
    // Fifo interrupts are still enabled. This is bad, but not too bad, as long as the chip doesn't interrupt.
    //
    if (REG_RD32(NV_PMC_BOOT_0) != -1)
    {
        stateNv(pDev, STATE_UNLOAD);  
        stateNv(pDev, STATE_DESTROY);
    }
    // unhook interrupt
    if (pDev->Mapping.hpicIRQ)
      VPICD_Force_Default_Behavior(pDev->Mapping.hpicIRQ);
    pDev->Mapping.hpicIRQ = NULL;

    // Free per device RM memory if any.
    return (RM_OK);
}

//---------------------------------------------------------------------------
//
//  Resource Manager API for VxDs and user mode clients. (e.g. display driver)
//
//---------------------------------------------------------------------------

//
// System level API for other VxDs.
//
RM_STATUS CDECL rmSysAPI
(
    U032 hReg,
    U032 Msg,
    V032 Param1,
    V032 Param2
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: System Service to Resource Manager\n\r");
    return (RM_OK);
}

int osGetNextAvailableInstance
(
  VOID
)
{
  int i;

  for(i=0;i<MAX_INSTANCE;i++)
    if(NvDBPtr_Table[i] == NULL)
      return (i);
  // If there are no NULL entries available ... return -1
  return (-1);
}

//
// User mode client API.
//
// pcs->CRS.Client_EAX will have a pointer to the RM_STRUCT containing the function and device.
RM_STATUS __fastcall rmUsrAPI
(
    U032 hVM,
    PCS  pcs
)
{
    PWIN9XHWINFO pOsHwInfo = NULL;

    U032          i;
    DESCRIPTOR    desc;
    U032          LinAddr;
    U032          PageBase;
    U032          Page;
    U032          PageCount;
    U032          PTE;
    static U032   grCanvasID;
    static U032   grClipCount;
    static U008   NopMask;
    PDMAPUSH_ADDRESS_INFO pDmaPushInfo=NULL;
    U032          status;
    U032          data;
    U032          data32;
    U032          *fb_sv;
//#ifdef BX_FIX
    CLIENT_STRUCT crs;          // another client_reg struct for internal use
//#endif
    MiniVDD_ParameterStruct *pMiniVDD_parameters;
    PHWINFO pDev;
    PRMUSRAPI_STRUCT rm_tempp;

    U032 Head = 0;  // need to pass this as a parameter?
    static U016   BxDev, Bx50, BxA8;   // BX bus & dev #, AGP enables
#ifdef DEBUG
    extern NvU32 dbgPowerSysState;
#endif


    extern U032           DmaPushOperation(U032, PDMAPUSH_ADDRESS_INFO);
    extern U032           DmaPushLock(U032, PDMAPUSH_ADDRESS_INFO);

    
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: User Service to Resource Manager: VM handle = ", hVM);

    rm_tempp = (PRMUSRAPI_STRUCT) pcs->CRS.Client_EAX;
    pDev = NvDBPtr_Table[rm_tempp->device];
    pcs->CRS.Client_EAX = rm_tempp->function;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,     "                                        Service   = ", rm_tempp->function);
    if((rm_tempp->function == NVRM_API_ARCHITECTURE_32)||(rm_tempp->function==NVRM_API_ARCHITECTURE_16)){
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,       "                                        Device not valid for NVARCH FUNCTION\n");
    }else{
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "                                        Device    = ", rm_tempp->device);
    }

    //This is really happens every time when RM started (NVRM_API_INIT).
    //I don't have any idea why our driver even worked before this fix.
    if( pDev != 0 )
    {
        pOsHwInfo = (PWIN9XHWINFO) pDev->pOsHwInfo;

        // It appears that Windows likes to disable our memory decode at random.
        // So ... we have to re-enable in this case.
        // Check if this device exists.
        if(pcs->CRS.Client_EAX != NVRM_API_POWER_UP)
            osEnsureDeviceEnabled(pDev);
    }

    //
    // Handle requested service.
    //
    switch (pcs->CRS.Client_EAX)
    {
        //*************************************************
        // Architecture "IOCTL" calls.
        //*************************************************
        case NVRM_API_ARCHITECTURE_32:
        case NVRM_API_ARCHITECTURE_16:
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "                                        ioctl    = ", pcs->CRS.Client_EDX);
              if (pcs->CRS.Client_EDX <= NVRM_ARCH_MAX_IOCTL)
                NvArchRMDispatch(pcs->CRS.Client_EDX, (PVOID)pcs->CRS.Client_EBX);
            }  
            break;
        //*************************************************
        // These first functions are called by the mini-VDD
        //*************************************************
        //
        // Map NV addresses. 
        //
        case NVRM_API_INIT:

        {
          PHWINFO pDev;
          int     dev_instance;
          U032    physAddr;          
          // This macro will produce a divide by 0 error at compile time if the sizeof HWINFO
          // struct is not a multiple of 4. However, it does not help if some sub struct of
          // HWINFO is not aligned properly.
          ASSERT_NVINFO_SIZE;

          // See if the device has already been init'd (i.e. the secondary miniVDD is loaded for the 2nd head of a single device.
          pMiniVDD_parameters = (MiniVDD_ParameterStruct *)pcs->CRS.Client_ESI;
          physAddr = pMiniVDD_parameters->callrm_nvphys;
          for (i=0; i < MAX_INSTANCE; i++) // Check all entries in the table of devices
          {
              if (NvDBPtr_Table[i] == 0)
                  break;
              else
              {
                if (physAddr == NvDBPtr_Table[i]->Mapping.PhysAddr) // Have we already init'd this device?
                {
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: API_INIT for secondary head\n");
                    return (RM_OK);     // We don't need to do anything
                }
                else
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: API_INIT for secondary device\n");
              }
          }
          // This is a new device
          if (! (RmAllocDeviceInstance(&dev_instance)==RM_OK) )
          {
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Cannot initialize device database\n");
          }else{

            pDev = NvDBPtr_Table[dev_instance];

            // setup the ptr to the OS Hw info
            pDev->pOsHwInfo = (VOID_PTR) &win9xHwInfo[dev_instance];
            pOsHwInfo = (PWIN9XHWINFO) pDev->pOsHwInfo;

            initStack_frame(pDev);
              
            // Delete the registry override for startup, so Control Panel will know we loaded.
            osDeleteRegistryValue(pDev->Registry.DBstrDevNodeDisplay, strStartUp);
            // Same goes for TV format
            osDeleteRegistryValue(pDev->Registry.DBstrDevNodeDisplay, strTVtype); 

            pMiniVDD_parameters = (MiniVDD_ParameterStruct *)pcs->CRS.Client_ESI;

            pDev->Mapping.nvPhys = pMiniVDD_parameters->callrm_nvphys;
            pDev->Mapping.fbPhys = (pMiniVDD_parameters->callrm_fbphys & 0xFFFF0000);
            pDev->Mapping.nvIRQ = pMiniVDD_parameters->callrm_irq_bus & 0xFF;
            pDev->Mapping.fbLength =(pMiniVDD_parameters->callrm_fbphys & 0xFFFF) << 16;
            pDev->Mapping.nvBusDeviceFunc = pMiniVDD_parameters->callrm_irq_bus & 0xFFFFFF00;

            //
            // This is actually a macro into a device's pDev
            //
            pOsHwInfo->osScheduled = 0;
            
            // This is only necessary for the primary display device. The secondary minivdd will step on this otherwise.
            if(pDev == NvDBPtr_Table[0])
               pOsHwInfo->miniVDDPostModeChange = (VOID *)pMiniVDD_parameters->callrm_modechange_callback;   // save callback address
   
            {
              int  char_count,string_size;
              char stringt[128]=NV4_REG_RESOURCE_MANAGER_SUBKEY;
              char stringt1[128]=RESOURCE_MANAGER_SUBKEY_ADDITION;
              
              osStringCopy(pDev->Registry.DBstrDevNodeDisplayNumber, (char *)pMiniVDD_parameters->callrm_registry_path);
              //osStringCopy(pDev->Registry.DBstrDevNodeDisplay, (char *)pMiniVDD_parameters->callrm_registry_path);
              //osStringCopy(pDev->Registry.DBstrRegistryDeviceParameters, (char *)pMiniVDD_parameters->callrm_registry_path); 
              //string_ptr = (U008 *) pcs->CRS.Client_EBX;
              //for(char_count=0;char_count<128;char_count++){
              //  pDev->Registry.DBstrDevNodeDisplayNumber[char_count] = (U008) *(string_ptr+char_count);
              //  pDev->Registry.DBstrDevNodeDisplay[char_count] = (U008) *(string_ptr+char_count);
              //}

              string_size = osStringLength(pDev->Registry.DBstrDevNodeDisplayNumber);
              pDev->Registry.DBstrDevNodeDisplayNumber[string_size] = '\\';
              string_size++;
              for(char_count=string_size;char_count < (128-string_size);char_count++){
                pDev->Registry.DBstrDevNodeDisplayNumber[char_count]=stringt1[char_count-string_size];
              }
              // Append the Resource Manager subkey string.("System")
              string_size = osStringLength(pDev->Registry.DBstrDevNodeDisplayNumber);
              pDev->Registry.DBstrDevNodeDisplayNumber[string_size] = '\\';
              string_size++;
              for(char_count=string_size;char_count < (128-string_size);char_count++){
                pDev->Registry.DBstrDevNodeDisplayNumber[char_count]=stringt[char_count-string_size];
              }
              osStringCopy(pDev->Registry.DBstrDevNodeDisplay,pDev->Registry.DBstrDevNodeDisplayNumber);
            }

            // Initialize these parameters.
            pDev->Dac.MobileEDID[0] = 1;    //Indicate that the buffer initialization hasn't happened yet.
            pDev->Dac.DevicesEnabled = 0;

            pDev->Dac.CrtcInfo[0].CursorHeight=32;
            pDev->Dac.CrtcInfo[0].CursorWidth=32;
            // This is called by the mini-VDD, so we must put the return values in the client-reg-struct so they'll be popped
            // back into the registers
            pcs->CRS.Client_EAX = rmConfigStart(pDev);                 // function return value
            pcs->CRS.Client_EBX = (U032) nvAddr; // return the address of NV in ebx
            pcs->CRS.Client_ECX = dev_instance + 1; // Return a 1 based handle to this device for the miniVDD.
            pcs->CRS.Client_EDX = (U032) fbAddr;    // return fb address
            pcs->CRS.Client_ESI = (U032) pDev->Dac.DFPPortID; // return DFP port ID
            pcs->CRS.Client_EDI = (U032) pDev->Video.HalInfo.CustomizationCode; // return customer mask
            
            pDev->fb_save = 0;    // JohnH
            //pDev->DBbiosAddr = 0; // JohnH
            pDev->DBdisplayModeHook = NULL;   

            /*KYH
            dmaPushPutOffset        = 0;
            dmaPushGetOffset        = 0;
            dmaPushGetOffsetRead    = 0;
            dmaPushJumpOffset       = 0;
            dmaPushJumpOffsetSet    = 0;
            KYH*/

            pDev->Dac.flickertoggle = 0;
            pDev->DBclass63VBlankList[0] = NULL;
            pDev->DBclass63VBlankList[1] = NULL;
            pDev->Dac.I2cIniFlag = FALSE;

            {
                DESCRIPTOR  desc;
                U032        pAddress;

                // alloc a locked page to be reloaded when the GART has been cleared
                vmmPageAllocate(0x1, PG_SYS, 0, 0, 0, 0, 0, 0, &desc.Desc64);
                pAddress = (U032)desc.Desc32[0];

                if (!vmmLinPageLock(pAddress >> RM_PAGE_SHIFT, 1, 0))
                {
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM:Unable to lock detection page.\n\r");
                    //return (RM_ERR_DMA_MEM_NOT_LOCKED);
                    return (RM_OK);     // not fatal
                }
                p_agp_dummy_page = pAddress;
            }
    
            pDev->MediaPort.ImageBufferNumber = 0;    // used by canopus mediaport callback mechanism

          }//else
            // Abort Hard ....
          
        }
        break;

        // This supplies the miniVDD callback funtion with the number of heads on this device
        case NVRM_API_NUM_HEADS:
        {
            char tempString[256];
            U032 size,i;

            // Switch to the last pDev first
            for(i=0; i<MAX_INSTANCE; i++)
            {
              if(NvDBPtr_Table[i]==0)
                break;
              pDev = NvDBPtr_Table[i];
            }

            //Return DeviceInstance in EAX
            pcs->CRS.Client_EAX = i;

            //
            // Ugly but necessary.  We need to strip off the SYSTEM portion of our registry key
            // to look in the correct location for this DualView config setting.  Please revisit
            // this code and explicitly create a separate string for this registry location
            //
            osStringCopy(tempString, pDev->Registry.DBstrDevNodeDisplay);
            size = osStringLength(tempString);
            i = 2;
            while (tempString[size-i] != '\\') 
                   i++;
            tempString[size-i] = 0x00;  // truncate back to NVIDIA

            //
            // Only enable multiple CRTC's when the hardware supports more than one and the system
            // is configured to deal with it.
            //
            if (pDev->Dac.HalInfo.NumCrtcs > 1)
                pcs->CRS.Client_EBX = pDev->Dac.HalInfo.NumCrtcs;    // and get number of heads from HAL info
            else
                pcs->CRS.Client_EBX = 1;
        }
        break;

        // Remove the device specified in EBX
        case NVRM_API_EXIT:
        {
            BYTE  *x;

            pDev = NvDBPtr_Table[pcs->CRS.Client_EBX];
            rmConfigStop(pDev); 
            if (pOsHwInfo->osDeviceName != 0)
            {
                _HeapFree(pOsHwInfo->osDeviceName, 0);
                pOsHwInfo->osDeviceName = 0;
            }
            if (pDev->EDIDBuffer != 0)
            {
                osFreeMem((VOID *)pDev->EDIDBuffer);
                pDev->EDIDBuffer = 0;
            }

            x = (BYTE *) pDev;
            _HeapFree(x, 0);
            pDev = NULL;
            break;    
        }
            
        //
        //  Enable VGA
        //
        case NVRM_API_ENABLEVGA:
            // Set the context to the primary device.(This will always be the case).
            pDev = NvDBPtr_Table[0];
            rmEnableVga(pDev,TRUE /* is primary device */);
            pcs->CRS.Client_EAX = RM_OK;            // function return value
            break;

        //
        //  Disable VGA
        //
        case NVRM_API_ENABLEHIRES:
            // Set the context to the primary device.(This will always be the case).
            pDev = NvDBPtr_Table[0];
            rmEnableHiRes(pDev, TRUE /* is primary device */);
            pcs->CRS.Client_EAX = RM_OK;            // function return value
            
            break;
        
        //
        //  MiniVDD notifier that ACPI is enabled
        //
        case NVRM_API_ACPI_ENABLED:
            // Set DAC_PM_SUPPORTED bit to prevent mix with old style management.
            pDev->Power.Flags |= DAC_PM_SUPPORTED;

            break;

        //
        //  Map ACPI states into NV power states
        //
        
        //  ACPI D0 state
        case NVRM_API_POWER_UP:
            DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: ACPI D0 state\n");
#ifdef DEBUG
            dbgPowerSysState = 2;
#endif
            resume = 1;                                         // Signal resume has occurred, reenable cursor

            // What state are we powering up from?
            switch (pDev->Power.State)
            {
                case MC_POWER_LEVEL_1:
                    mcPowerState(pDev, MC_POWER_LEVEL_0, Head);
                    break;
                case MC_POWER_LEVEL_2:
                    mcPowerState(pDev, MC_POWER_LEVEL_0, Head);
                    break;
                case MC_POWER_LEVEL_3:
                    mcPowerState(pDev, MC_POWER_LEVEL_0, Head);
                    // Hack to fix the system BIOS (440BX only)-- restore AGP access
                    if (BxA8 != 0) // If AGP was enabled before power down, restore it
                    {
                        crs.CWRS.Client_BX  = BxDev;
                        crs.CWRS.Client_CX  = Bx50;       // Aperture Access Global Enable
                        crs.CWRS.Client_CX |= 0x20; // enable MDA
                        crs.CBRS.Client_AH  = 0xB1;       // PCI_FUNCTION_ID
                        crs.CBRS.Client_AL  = 0x0c;       // WRITE_CONFIG_WORD
                        crs.CWRS.Client_DI  = 0x50;       // NBX config reg      
                        PCI(&crs);
                        crs.CWRS.Client_CX  = BxA8;       // AGP, sideband enable; 2x
                        crs.CBRS.Client_AH  = 0xB1;       // PCI_FUNCTION_ID
                        crs.CBRS.Client_AL  = 0x0c;       // WRITE_CONFIG_WORD
                        crs.CWRS.Client_DI  = 0xA8;       // NBX config reg      
                        PCI(&crs);
                    }
                    pOsHwInfo->osScheduled = 0;         // this might have been set before we shut down
                    break;
            }

            //Return MobileOperation to VDD
            pcs->CRS.Client_EAX = pDev->Power.MobileOperation;

            pDev->Vga.Enabled = TRUE;   // set back to VGA (mcPowerState called stateNv(LOAD) for hires)
                                        // so that rmEnableHires will execute addition transition code.
            break;
        //  ACPI D3 state
        case NVRM_API_POWER_DOWN:
            DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: ACPI D3 state\n");
#ifdef DEBUG
            dbgPowerSysState = 1;
#endif
            if (pDev->Power.MobileOperation)
            {
                if (pDev->Power.MobileOperation == 2)// ||
                    //pDev->Power.MobileOperation == 4) // Toshiba or Compal?
                {
                    mcPowerState(pDev, MC_POWER_LEVEL_3, Head);
                }
                else
                {
                    mcPowerState(pDev, MC_POWER_LEVEL_2, Head);
                }
            }
            else
            {
                mcPowerState(pDev, MC_POWER_LEVEL_3, Head);

                // This gets called for all devices. We don't need to do it multiple times, but it shouldn't matter.
                // This only needs to happen if we have an AGP device.
                Bx50 = 0;
                BxA8 = 0;
                // Hack for 440BX system BIOS bug: save AGP enables on 440BX
                // Find the 440BX Bridge
                crs.CBRS.Client_AH  = 0xB1;           // PCI_FUNCTION_ID
                crs.CBRS.Client_AL  = 0x02;           // FIND_PCI_DEVICE
                crs.CWRS.Client_CX = 0x7190;          // Device ID
                crs.CWRS.Client_DX = 0x8086;          // Vendor ID
                crs.CWRS.Client_SI = 0;               // Index
                PCI(&crs);                              // return BH = bus, BL = dev num
                BxDev = crs.CWRS.Client_BX;
                if (crs.CBRS.Client_AH == 0x00)       // found? if not, nothing to do
                {
                    crs.CBRS.Client_AH  = 0xB1;       // PCI_FUNCTION_ID
                    crs.CBRS.Client_AL  = 0x09;       // READ_CONFIG_WORD
                    crs.CWRS.Client_DI  = 0x50;       // NBX config reg      
                    PCI(&crs);
                    Bx50 = crs.CWRS.Client_CX;
                    crs.CBRS.Client_AH  = 0xB1;       // PCI_FUNCTION_ID
                    crs.CBRS.Client_AL  = 0x09;       // READ_CONFIG_WORD
                    crs.CWRS.Client_DI  = 0xA8;       // NBX config reg      
                    PCI(&crs);
                    BxA8 = crs.CWRS.Client_CX;
            
                }
            }
            break;

        //  ACPI D1 state
        case NVRM_API_POWER_D1:
            DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: ACPI D1 state\n");
#ifdef DEBUG
            dbgPowerSysState = 1;
#endif
            if (pDev->Power.MobileOperation)
                mcPowerState(pDev, MC_POWER_LEVEL_1, Head);
            else
                mcPowerState(pDev, MC_POWER_LEVEL_1, Head);
            break;            
                                                
        // ACPI Hibernate
        case NVRM_API_HIBERNATE:
            DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: ACPI Hibernate\n");
#ifdef DEBUG
            dbgPowerSysState = 1;
#endif
            mcPowerState(pDev, MC_POWER_LEVEL_3, Head);
#ifdef DEBUG
            dbgDisableDevice2(&DbgPort);
#endif
            break;            
                                                
            
        //**************************************************************************
        // The remaining functions are called by "users", such as the display driver
        //**************************************************************************
        // Allocate page aligned DMA buffer.
        //
        case NVRM_API_ALLOC_PAGES:
            vmmGetCritSectionStatus();      // complete delayed releases of critical section
                                            // is this necessary in Win 95?
            vmmPageAllocate(pcs->CRS.Client_ECX, PG_SYS, 0, 0, 0, 0, 0, PAGELOCKED, &desc.Desc64);
            pcs->CRS.Client_EAX = desc.Desc32[0];
            pcs->CRS.Client_EDX = desc.Desc32[1];
            break;
        //
        // Free DMA buffer.
        //
        case NVRM_API_FREE_PAGES:
            vmmGetCritSectionStatus();
            vmmPageGetSizeAddr(pcs->CRS.Client_ECX, 0, &desc.Desc64);
            vmmPageUnLock(pcs->CRS.Client_ECX,
                          desc.Desc32[0],
                          0,
                          0);
            pcs->CRS.Client_EAX = vmmPageFree(pcs->CRS.Client_ECX, 0);
            break;
        //
        // Lock memory pages.
        //
        case NVRM_API_LOCK_PAGES:
            //
            // Map the buffer
            //
            vmmGetCritSectionStatus();
            LinAddr = vmmSelectorMapFlat(vmmGetSysVMHandle(), pcs->CRS.Client_EBX, 0)
                    + pcs->CRS.Client_ECX;
            PageCount = ((LinAddr & PAGEMASK) + pcs->CRS.Client_EDX + PAGESIZE - 2) >> PAGESHIFT;
            PageBase = PAGE(LinAddr);
            pcs->CRS.Client_EAX = TRUE;
            //
            // Scatter/gather lock the pages.
            //
            if (vmmPageCheckLinRange(PageBase, PageCount, 0) != PageCount)
            {
                pcs->CRS.Client_EAX = FALSE;
                break;
            }
            for (Page = 0; Page < PageCount; Page++)
            {
                //
                // Touch page to make sure it is in memory.  Win32s doesn't like
                // to play nicely with the VMMs memory manager.
                //
                NopMask |= *(volatile U008 *)LinAddr;
                LinAddr += PAGESIZE;
                if (!vmmLinPageLock(PageBase + Page, 1, 0))
                {
                    pcs->CRS.Client_EAX = FALSE;
                    break;
                }
                if (!vmmCopyPageTable(PageBase + Page, 1, (U032)&PTE, 0))
                {
                    pcs->CRS.Client_EAX = FALSE;
                    break;
                }
                if (!(PTE & P_PRES))
                {
                    pcs->CRS.Client_EAX = FALSE;
                    break;
                }
            }
            break;
        //
        // Unlock memory pages.
        //
        case NVRM_API_UNLOCK_PAGES:
            //
            // Unlock memory pages.
            //
            vmmGetCritSectionStatus();
            LinAddr   = vmmSelectorMapFlat(vmmGetSysVMHandle(), pcs->CRS.Client_EBX, 0)
                      + pcs->CRS.Client_ECX;
            PageCount = ((LinAddr & PAGEMASK) + pcs->CRS.Client_EDX + PAGESIZE - 2) >> PAGESHIFT;
            PageBase  = PAGE(LinAddr);
            //
            // Make sure the linear address range is valid.
            //
            PageCount = vmmPageCheckLinRange(PageBase, PageCount, 0);
            NopMask   = 0xFF;
            for (Page = 0; Page < PageCount; Page++)
            {
                *(volatile U008 *)LinAddr &= NopMask;
                LinAddr += PAGESIZE;
            }
            pcs->CRS.Client_EAX = vmmLinPageUnLock(PageBase, PageCount, 0) ? TRUE : FALSE;
            break;
        //
        // Map selector to linear address.
        //
        case NVRM_API_MAP_SELECTOR:
            pcs->CRS.Client_EAX = 0;
            if (pcs->CRS.Client_ECX == 0)
                break;
            //
            // Allocate a selector to map this buffer.
            //
            PageCount = ((pcs->CRS.Client_ECX + 0xFFF) & 0xFFFFF000) / 0x1000;
            vmmBuildDescriptorDWORDs(pcs->CRS.Client_EBX,
                                     PageCount,
                                     RW_DATA_TYPE,
                                     D_PAGE32,
                                     0,
                                     &desc.Desc64);
            if (pcs->CWRS.Client_DX == 0)
            {
                pcs->CRS.Client_EAX =
                    vmmAllocateGDTSelector(desc.Desc32[1],
                                           desc.Desc32[0],
                                           0);
            }
            else
            {
                pcs->CRS.Client_EAX =
                    vmmSetDescriptor(pcs->CWRS.Client_DX,
                                     hVM,
                                     desc.Desc32[1],
                                     desc.Desc32[0],
                                     0);
            }
            break;
        //
        // Register Windows Resource Manager callback routines.
        //
        case NVRM_API_IPC_CALLBACK:
            pOsHwInfo->dllIpcOffset   = pcs->CRS.Client_ECX;
            pOsHwInfo->dllIpcSelector = pcs->CWRS.Client_DX;
            break;
        case NVRM_API_NOTIFY_CALLBACK:
            pOsHwInfo->dllNotifyOffset   = pcs->CRS.Client_ECX;
            pOsHwInfo->dllNotifySelector = pcs->CWRS.Client_DX;
            break;
        //
        // Return far pointers to Resource Manager information structures.
        //
        case NVRM_API_MULTIDEVICE_MAP_RM_INFO:
          //
          // Map the DevInfo, channelInfo, & ClientInfo structures.
          //
          pcs->CRS.Client_EAX = RM_ERROR;
          {
            // Use this global to reflect whether this function has been called yet.
            // You must re-allocate sectors for the pDev's because they can be disabled and re-allocated
            // during dynamic enable/disables.
            //if (NvInfoSelectorsSelector == 0)
            {
              int device_count;
              int pDev_count=0;
              // Allocate selectors for each of the Devices.
              device_count = osGetNextAvailableInstance();
              // Set the global context to the first device.
              pDev = NvDBPtr_Table[pDev_count];
              
              // Allocate selectors for each of the device NvInfo structures.
              while(device_count != 0)
              {
                vmmBuildDescriptorDWORDs((DWORD)pDev,
                                         sizeof(HWINFO),
                                         RW_DATA_TYPE,
                                         D_DEF16,
                                         0,
                                         &desc.Desc64);
                NvInfoSelectors[pDev_count] =                         
                    vmmAllocateLDTSelector(hVM,
                                           desc.Desc32[1],
                                           desc.Desc32[0],
                                           1,
                                           0);
                device_count--;    
                pDev_count++;
                pDev = NvDBPtr_Table[pDev_count];
              }                             
            }
            // Allocate selectors for the array of NvInfo pointers.
            vmmBuildDescriptorDWORDs((DWORD)&NvInfoSelectors[0],
                                     (MAX_INSTANCE * sizeof(U032)),
                                     RW_DATA_TYPE,
                                     D_DEF16,
                                     0,
                                     &desc.Desc64);
            NvInfoSelectorsSelector =                         
                vmmAllocateLDTSelector(hVM,
                                       desc.Desc32[1],
                                       desc.Desc32[0],
                                       1,
                                       0);
            
            // Flag that this is done and send back a pointer to the array of selectors. 
            //nvInfoSelector = 0;
            pcs->CRS.Client_EAX = NvInfoSelectorsSelector;
            
            if (clientInfoSelector == 0)
            {
              //
              // Allocate a selector to map this buffer.
              //
              vmmBuildDescriptorDWORDs((DWORD)clientInfo,
                                       sizeof(CLIENTINFO) * NUM_CLIENTS,
                                       RW_DATA_TYPE,
                                       D_DEF16,
                                       0,
                                       &desc.Desc64);
              clientInfoSelector =
                  vmmAllocateLDTSelector(hVM,
                                         desc.Desc32[1],
                                         desc.Desc32[0],
                                         1,
                                         0);
            }
            pcs->CRS.Client_ECX = clientInfoSelector;
            
          }
          
          break;
        
        //
        // Configuration APIs.
        //
        case NVRM_API_GET_VERSION:
            pcs->CRS.Client_EAX = NVRM_VERSION;
            pcs->CRS.Client_EDX = NVRM_VERSION >> 16;
            break;
        case NVRM_API_UPDATE_CONFIGURATION:
        {
            rmInService++;
            if (pDev->Framebuffer.UpdateFlags & UPDATE_HWINFO_BUFFER_PARAMS)
            {
                //
                // Check for invalid resolution setting - use registry.
                //
                //
                //  we want to change the way resolutions are passed to RM:
                //  the display driver or control applet should call nvsys to 
                //  set display width and height and pixel depth
                //  and set flag ResolutionValid. When this function sees 
                //  Resolution Valid, it uses the values in pDev and resets
                //  ResolutionValid. Otherwise, it calls the VDD to get the 
                //  resolution (from the registry).
                //  Until the display driver is changed, always get resolution from the VDD.

                //
                // KJK If the client doesn't know his resolution, go out to the vdd and get it.
                // If he thinks he knows his resolution, just set that.
                //
                if (pDev->Framebuffer.Resolution == -1)
                {
                    //
                    // Get screen resolution and framebuffer configuration from registry.
                    //
                    vddGetDisplayInfo(pOsHwInfo->osDeviceHandle, &osDisplayInfo, sizeof(DISPLAYINFO));
                    pDev->Dac.HalInfo.Depth = (osDisplayInfo.InfoFlags & REGISTRY_BPP_NOT_VALID) ? 8 : osDisplayInfo.Bpp;
                    //
                    // BUG WORKAROUND: If the user has set a specific refresh rate via the Win95 OSR2+ control
                    // panel, the resulting refresh rate will always return MONITOR_INFO_NOT_VALID.  But the
                    // refresh value is correct!  Huh???
                    //
                    // So until we can find the VDD (?) bug, if the refresh value is valid (>60,<250) for our
                    // known refresh settings, let it through.
                    //
                    // Microsoft has admitted to a bug in this area of the VDD which will be fixed
                    // in Memphis (of course).
                    //
                    if ((osDisplayInfo.InfoFlags & MONITOR_INFO_NOT_VALID) &&
                        (osDisplayInfo.InfoFlags & REFRESH_RATE_MAX_ONLY) &&
                        (osDisplayInfo.RefreshRateMax >= 60) &&
                        (osDisplayInfo.RefreshRateMax <= 250))
                            osDisplayInfo.InfoFlags &= ~MONITOR_INFO_NOT_VALID;
                    //
                    // Only go out to the registry for the refresh rate if the DDK has not preset
                    // a different rate manually sometime before this ConfigUpdate().
                    //
                    if (pDev->Framebuffer.UpdateFlags & UPDATE_HWINFO_REFRESH_PARAMS)                
                        pDev->Framebuffer.UpdateFlags &= ~UPDATE_HWINFO_REFRESH_PARAMS;
                    else    
                        if ((osDisplayInfo.InfoFlags & (MONITOR_INFO_NOT_VALID | MONITOR_INFO_DISABLED_BY_USER))
                         || (osDisplayInfo.RefreshRateMax == 0xFFFFFFFF)
                         || (osDisplayInfo.RefreshRateMax == 0))
                        {
                            pDev->Framebuffer.HalInfo.RefreshRate   = 60;
                            pDev->Framebuffer.HSyncPolarity = BUFFER_HSYNC_NEGATIVE;
                            pDev->Framebuffer.VSyncPolarity = BUFFER_HSYNC_NEGATIVE;
                        }
                        else
                        {
                            pDev->Framebuffer.HalInfo.RefreshRate = osDisplayInfo.RefreshRateMax;
                            pDev->Framebuffer.HSyncPolarity = osDisplayInfo.HorzSyncPolarity;
                            pDev->Framebuffer.VSyncPolarity = osDisplayInfo.VertSyncPolarity;
                        }
                        
                    pDev->Framebuffer.HalInfo.HorizDisplayWidth = osDisplayInfo.XRes;
                    pDev->Framebuffer.HalInfo.VertDisplayWidth  = osDisplayInfo.YRes;
                }
                else
                {
                    //
                    // For now, assume that all pDev data is set correctly by the client
                    //
                    //      pDev->Framebuffer.Resolution != -1
                    //      pDev->Framebuffer.HorizDisplayWidth
                    //      pDev->Framebuffer.VertDisplayWidth
                    //      pDev->Framebuffer.Depth
                    //      pDev->Framebuffer.RefreshRate
                    //
                }
                    
                //
                // BUG WORKAROUND: There is another problem with the refresh information
                // returned by the VDD.  If a low-res DDraw mode is selected (ones below 640x400)
                // and there is no refresh information in the registry (since its not a std
                // desktop resolution), the VDD seems to return the rate information that
                // it has for 640x480.  But that is wrong.  Due to line doubling, the max
                // rates for the lower modes is actually determined by the max rate of the
                // doubled mode.
                //
                // For example, the max refresh rate of 512x384 is the same as the max rate
                // for 1024x768.  But that's not the info we're given.  Figures.
                //
                // If we believe the VDD, we may end up setting a refresh rate that is too
                // high for the monitor and will end up losing sync.                    
                //
                // Monitors that appear to show the problem most often actually have invalid
                // EDID information (such as the NANAO T-20), so the blame may actually
                // fall upon the monitor manufacturer.  But ours is not to blame, ours is
                // to fix.
                //
                // Anyway, we need to limit the refresh rate of all modes below 640x400 to
                // a safe/known value.  This restriction can be removed when either
                //
                // 1) the EDID/VDD bug is fixed
                // 2) a board vendor provides explicit support for setting ddraw refresh rates
                //    and we're sure we're given a valid rate.
                //
                // I hate restricting functionality, but until then let's limit all low-res 
                // line-doubled modes to 75Hz.
                //
                if ((pDev->Framebuffer.HalInfo.VertDisplayWidth < 400) 
                    && (pDev->Framebuffer.HalInfo.RefreshRate > 75))
                        pDev->Framebuffer.HalInfo.RefreshRate = 75;    // hardcode to 75Hz
                
                pDev->Framebuffer.HorizFrontPorch = 0;
                pDev->Framebuffer.HorizSyncWidth  = 0;
                pDev->Framebuffer.HorizBackPorch  = 0;
                pDev->Framebuffer.VertFrontPorch  = 0;
                pDev->Framebuffer.VertSyncWidth   = 0;
                pDev->Framebuffer.VertBackPorch   = 0;
                pDev->Framebuffer.CSync           = BUFFER_CSYNC_DISABLED;
                pDev->Dac.HalInfo.VClk            = 0;
                
                //
                // Only enable double buffering if enough memory available.
                //
                pDev->Framebuffer.Count = 1;

                //
                // Before collecting all of the pertinent display timing data and
                // setting the mode, verify that we don't need to limit our
                // timings due to a specific display device
                //
                // This display device check will be called again later, but we
                // need a glimpse of the settings before we generate the
                // first set of timings
                //
                osPreModeSet(pDev, Head);
                //
                // If we are running on a TV, be sure to limit our refresh rate
                // to the adapter default (60Hz).  The clocks are generated by
                // the external TV encoder device, but we must be sure our CRTC
                // timings are not programmed too high for the TV encoder.
                //
                if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_TV)
                    pDev->Framebuffer.HalInfo.RefreshRate = 60;
                // Flat panels CRTC timing should always work at 60 Hz. If the FP
                // supports higher refresh rates, the DAC timings will be set higher,
                // and the CRTC running at 60 Hz should still be OK (the blank period is
                // set by the DAC, not the CRTC).
                if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_FLAT_PANEL)
                    pDev->Framebuffer.HalInfo.RefreshRate = 60;
                                    
                
                // Setup the timing information for this mode in pDev.
                osSetupForNewStyleModeSet(pDev);

                // set the new mode.
                stateSetMode(pDev);
            }
            //
            // Update any new configuration.
            //
            i = stateNv(pDev, STATE_UPDATE);
            pcs->CRS.Client_EAX = i;
            rmInService--;
            break;
        }
        case NVRM_API_CONFIG_VGA:
        {
            // The Display Driver gets call to do a Disable and then calls us
            // to switch to VGA.  If we are in MC_POWER_LEVEL_2 this is not a 
            // good thing to do
            if (MC_POWER_LEVEL_2 == pDev->Power.State)
            {
               // there is a problem with this code
               // what happens is that there are a couple of mode switches calls
               // as we power down. Mode 3 & Mode 93 --> 13 without memory
               // change.  After these mode switch the screen is corrupted instead of
               // the correct windows bitmap.  The timing of the corruption varies, with it
               // sometimes happening after mode 3 and sometimes mode 13.
               // ok corruption is better then a hang anyday....
#if 1
               U032 bar0_address, pci_address, pci_reg, i;

               bar0_address = pDev->Chip.HalInfo.PciBars[0];
               pci_address = pDev->Mapping.nvBusDeviceFunc;

               // make sure ACPI is off
               _asm mov  dx, 0xcf8
               _asm in   eax, dx
               _asm push eax
               _asm mov  eax, pci_address  
               _asm or   eax, 0x80000064
               _asm out  dx, eax
               _asm mov  dx, 0xcfc
               _asm xor  eax, eax
               _asm out  dx, eax

               // set up pci space
               for (i = 0, pci_reg = 0x80000010; i < pDev->Chip.HalInfo.TotalPciBars; i++, pci_reg += 4)
               {
                  U032 barN_address = pDev->Chip.HalInfo.PciBars[i];

                  _asm mov  dx, 0xcf8
                  _asm mov  eax, pci_address  
                  _asm or   eax, pci_reg
                  _asm out  dx, eax
                  _asm mov  dx, 0xcfc
                  _asm mov  eax, barN_address
                  _asm out  dx, eax 
               }

               // turn us on after we are mapped in
               _asm mov  eax, pci_address  
               _asm mov  dx, 0xcf8
               _asm or   eax, 0x80000004 
               _asm out  dx, eax
               _asm mov  dx, 0xcfc
               _asm in   al,dx

               // Enable the memory decode and BusmasterEnable of the PCIO device.
               _asm or   al,6
               _asm out  dx,al
               _asm pop  eax
               _asm mov  dx, 0xcf8
               _asm out  dx, eax
#else
               break;
#endif
           }

            //
            // It appears we can get a CONFIG_VGA before you've gotten the POWER_EVENT
            // to resume and trying to rmEnableHiRes with the lower power settings hangs
            // the HW, so make sure we've restored the settings first.
            //
            if (pDev->Power.State != MC_POWER_LEVEL_0)
            {
                mcPowerState(pDev, MC_POWER_LEVEL_0, Head);
                pDev->Vga.Enabled = TRUE;
                resume = 1;
            }
            
            if (pcs->CRS.Client_EBX)
                rmEnableVga(pDev, pOsHwInfo->osDeviceHandle == 1);
            else
            {
                if (pDev->fb_save)
                {
                    // copy from save area to framebuffer instance memory
                    // the first 64k is BIOS image (looking backwards from the top)
                    // the BIOS will be POSTed, so it gets copied into instance mem without our help
                    fb_sv = pDev->fb_save;

                    for(i=0; i < INST_COPY/4; i++)
                    {
                         data = *fb_sv++;
                         REG_WR32(NV_PRAMIN_DATA032(i), data);
                    }            
                    osFreeMem((VOID *)pDev->fb_save);
                    pDev->fb_save = 0;
                }
                rmEnableHiRes(pDev, pOsHwInfo->osDeviceHandle == 1);
            }
            break;
        }
        case NVRM_API_MODE_HOOK:
            pDev->DBdisplayModeHook = (U032 (*)(U032))pcs->CRS.Client_EBX;
            break;
        //
        // Return Linear address of hardware.
        //
        case NVRM_API_GET_NV_ADDRESS:
            pcs->CRS.Client_EAX = (U032)nvAddr;
            break;
        //
        // Return Linear address of framebuffer.
        //
        case NVRM_API_GET_FB_ADDRESS:
            pcs->CRS.Client_EAX = (U032)fbAddr;
            break;
        //
        // Return Linear address of AGP aperture.
        //
        case NVRM_API_GET_AGP_ADDRESS:
            pcs->CRS.Client_EAX = (U032)pDev->DBagpAddr;
            break;
        //
        // Return Linear address of Gamma table
        //
        case NVRM_API_GET_GAMMA_ADDRESS:
            pcs->CRS.Client_EAX = (U032)pDev->Dac.Gamma;
            break;
        //
        // Return framebuffer offset of priviliged vdd memory
        //
        case NVRM_API_GET_VDD_PRIV_ADDRESS:
            pcs->CRS.Client_EAX = (U032)pDev->Pram.PrivBase;
            break;
            
        //
        // Mediaport callback mechanism still used by Canopus
        //            
        case NVRM_API_VPE_MISC:
            // decode subfunction
            pcs->CRS.Client_EAX = -1; // so far success

            switch (pcs->CRS.Client_EBX)
            {
            // 16 bit accesses only !!
            case IMAGE_INSTALL_16CALLBACK:
                    mpImageCallback.Selector = (U032) (pcs->CRS.Client_EDX & 0xFFFF);
                    mpImageCallback.Offset   = pcs->CRS.Client_ECX  & 0xFFFF;
                    mpImageInstalledCallback = TRUE; // for time being, debug reasons only
                    break;

            case IMAGE_UNINSTALL_16CALLBACK:
                    mpImageCallback.Selector = 0;
                    mpImageCallback.Offset   = 0;
                    mpImageInstalledCallback = FALSE;
                    break;

            default:
                // undefined subfunction, error alert
                pcs->CRS.Client_EAX = 0;
                break;
            }
            break;
            
        //
        // Don't call system DLL anymore.
        //
        case NVRM_API_UNLOAD_DLL:
            pOsHwInfo->dllIpcOffset      = 0;
            pOsHwInfo->dllIpcSelector    = 0;
            pOsHwInfo->dllNotifyOffset   = 0;
            pOsHwInfo->dllNotifySelector = 0;
            osCallbackList    = NULL;
            break;

        case NVRM_API_SEMAPHORE:
            {
            // Maybe this code should be executed when there are > 1 NV chips in the system,
            // as it could cause a performance hit.
              if (pcs->CRS.Client_ECX == SEMAPHORE_WAIT)
                mmWaitSemaphore();
              if (pcs->CRS.Client_ECX == SEMAPHORE_SIGNAL)
                mmSignalSemaphore();
            }
            break;
            
        case NVRM_API_DRIVER_CONNECT:
            {
              // Check all devices to find out which MiniVDD is calling.
              int temp_counter;
              char * tmpPtr;
              
              for(temp_counter=0;temp_counter<MAX_INSTANCE;temp_counter++){
                pDev = NvDBPtr_Table[temp_counter];

                if(pDev==0)
                {
                  DBG_BREAKPOINT();
                  pcs->CRS.Client_EAX = 0;
                  break;
                }

                pOsHwInfo = (PWIN9XHWINFO) pDev->pOsHwInfo;
                if(pOsHwInfo->osDeviceHandle == pcs->CRS.Client_EBX){
                  pcs->CRS.Client_EAX = temp_counter + 1;            // Return a 1-based device number.
                  temp_counter = MAX_INSTANCE;                       // terminate for loop.
                } // osDeviceHandle matches
                else{
                  if(pOsHwInfo->osDeviceHandle == 0){
                    pOsHwInfo->osDeviceHandle = pcs->CRS.Client_EBX; // Set the os value to nvinfo
                    
                    if (pcs->CRS.Client_ECX != 0) {
                        // Make space for the device name string and copy it.
                        tmpPtr = _HeapAllocate(osStringLength((char *)pcs->CRS.Client_ECX), 0);
                        if (tmpPtr != 0) {
                           osStringCopy(tmpPtr, (char *)pcs->CRS.Client_ECX);
                           pOsHwInfo->osDeviceName = tmpPtr;
                        }
                    }

                    if (!pDev->DBfbInstBitmap)
                    {            
                        status = fbInitializeInstMemBitMap(pDev);
                        if (status)
                        {
                            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Cannot allocate InstMemBitMap!");
                            DBG_BREAKPOINT();
                        }
                    }

                    // Now that we have the osDeviceHandle for this device, 
                    // update the mode we are supposed to be in by reading the registry
                    osDisplayInfo.HdrSize = sizeof(DISPLAYINFO);
                    vddGetDisplayInfo(pOsHwInfo->osDeviceHandle, &osDisplayInfo, sizeof(DISPLAYINFO));
                    initFbEx(pDev);
                    
                    pcs->CRS.Client_EAX = temp_counter + 1;              // Return a 1-based device number.
                    temp_counter = MAX_INSTANCE;                         // terminate for loop.
                  } // osDeviceHandle == 0
                  else{
                    if(temp_counter == MAX_INSTANCE-1){
                      DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Too many devices detected !");
                      DBG_BREAKPOINT();
                    }
                  } // osDeviceHandle is not zero
                } // osDeviceHandle is does not match
              } // loop for all devices
            }  
            break;
            
        case NVRM_API_DRIVER_DISCONNECT:
            {
                // Disconnect the device specified. Note that this is different than API_EXIT. 
                // All we do here is to undo what DRIVER_CONNECT did and throw away the instance memory
                // allocation. There should be no activity on this device. The driver calls this after
                // calling CONFIG_VGA to put the device in VGA mode. Also, this is never called for the
                // primary device.

                // don't do anything if the device is not disabled and in VGA mode.
                if (pDev->Vga.Enabled &&
                    pDev->DeviceDisabled)
                {
                    if(pOsHwInfo->osDeviceHandle != 0)
                    {
                        pOsHwInfo->osDeviceHandle = 0;
                        if (pOsHwInfo->osDeviceName != 0)
                        {
                            _HeapFree(pOsHwInfo->osDeviceName, 0);
                            pOsHwInfo->osDeviceName = NULL;
                        }
                
                        if (pDev->DBfbInstBitmap != 0)
                        {
                            osFreeMem(pDev->DBfbInstBitmap);
                            pDev->DBfbInstBitmap = 0;
                        }
                    } // osDeviceHandle is not 0
                } // device is in VGA and is disabled
            }
            break;
        case NVRM_API_DISPLAY:
            
            switch (pcs->CRS.Client_EBX)
            {
                
                case NVRM_API_DISPLAY_GET_MONITOR_TYPE:
                
                    data32 = GETDISPLAYTYPE(pDev, Head);
                    {
                        switch (data32)
                        {
                            case DISPLAY_TYPE_MONITOR:
                                SETMONITORTYPE(pDev, Head, MONITOR_TYPE_VGA);
                                break;
                            case DISPLAY_TYPE_TV:
                                switch (pDev->Dac.TVStandard)
                                {
                                    case NTSC_M:
                                    case NTSC_J:
                                        SETMONITORTYPE(pDev, Head, MONITOR_TYPE_NTSC);
                                        break;
                                    case PAL_A:
                                    case PAL_M:
                                    case PAL_N:
                                    case PAL_NC:
                                        SETMONITORTYPE(pDev, Head, MONITOR_TYPE_PAL);
                                        break;
                                }
                                break;
                            case DISPLAY_TYPE_FLAT_PANEL:        
                                SETMONITORTYPE(pDev, Head, MONITOR_TYPE_FLAT_PANEL);
                                break;
                            default:
                                // Set display type to the BIOS display type
                                switch (dacGetBiosDisplayType(pDev, Head))
                                {
                                    case DISPLAY_TYPE_MONITOR:
                                        SETMONITORTYPE(pDev, Head, MONITOR_TYPE_VGA);
                                        break;
                                    case DISPLAY_TYPE_TV:
                                        SETMONITORTYPE(pDev, Head, MONITOR_TYPE_NTSC);
                                        break;
                                    case DISPLAY_TYPE_FLAT_PANEL:
                                        SETMONITORTYPE(pDev, Head, MONITOR_TYPE_FLAT_PANEL);
                                        break;
                                }
                        }
                    }
                    pcs->CRS.Client_EAX = (U032)GETMONITORTYPE(pDev, Head);
                    // I'm tacking on this additional info for the mini-VDD. 
                    pcs->CRS.Client_EBX = (U032)pDev->Dac.DisplayChanged;
                    pDev->Dac.DisplayChanged = 0;
                    break;
                    
                case NVRM_API_DISPLAY_GET_DISPLAY_TYPE:
                    pcs->CRS.Client_EAX = GETDISPLAYTYPE(pDev, Head);
                    break;
                
                case NVRM_API_DISPLAY_SET_DISPLAY_TYPE:
                    SETDISPLAYTYPE(pDev, Head, pcs->CRS.Client_EBX);
                    break;
                
                case NVRM_API_DISPLAY_GET_FP_CONNECT_STATUS:
                    pcs->CRS.Client_EAX = dacFlatPanelConnectStatus(pDev, Head);
                    data32 = GETDISPLAYTYPE(pDev, Head);
                    if((data32==DISPLAY_TYPE_FLAT_PANEL)&&(!pcs->CRS.Client_EAX)){
                        if(dacMonitorConnectStatus(pDev, Head))
                            data32 = DISPLAY_TYPE_MONITOR;
                    }
                    SETDISPLAYTYPE(pDev, Head, data32);
                    break;
                
                case NVRM_API_DISPLAY_GET_FP_CONFIG:
                    pcs->CRS.Client_EAX = dacGetFlatPanelConfig(pDev, Head);
                    break;
                
                case NVRM_API_DISPLAY_SET_FP_CONFIG:
                    // KJK
                    // Need to revisit and add search for current dac object using this Head, then pass
                    // that object directly into this call.
                    // KJK 
                    // pcs->CRS.Client_EAX = dacSetFlatPanelMode(pDev, Head, pcs->CRS.Client_ECX, TRUE);
                    break;
                                
                //
                // Handle the incoming display change notifications from the 16bit driver
                //
                case NVRM_API_DISPLAY_CHANGE_CONFIG:
                    pcs->CRS.Client_EAX = dacSetSpanning(pDev, pcs->CRS.Client_ECX);
                    break;
                case NVRM_API_DISPLAY_CHANGE_START:
                    pcs->CRS.Client_EAX = dacSetModeStart(pDev, pcs->CRS.Client_ECX);
                    break;
                
                case NVRM_API_DISPLAY_CHANGE_END:
                    pcs->CRS.Client_EAX = dacSetModeEnd(pDev, pcs->CRS.Client_ECX);
                    break;

            }
                                    
            break;
        case NVRM_API_RM_TOKEN:
          switch(pcs->CRS.Client_EBX){
            case QUERY_TOKEN:
              pcs->CRS.Client_EAX = ResourceManagerGlobalToken;
              break;
            case RETURN_TOKEN:
              if(!ResourceManagerGlobalToken){
                DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: TOKEN ERROR ! TOKEN=0 on RETURN_TOKEN call\n\r");
                DBG_BREAKPOINT();
              }else
                DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: RELEASED THE TOKEN !\n\r");
                ResourceManagerGlobalToken = 0; 
              break;
            case AQUIRE_TOKEN:
              if(!ResourceManagerGlobalToken){
                ResourceManagerGlobalToken = 1; 
                pcs->CRS.Client_EAX = 1;
                DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: AQUIRED THE TOKEN !\n\r");
              }else{
                pcs->CRS.Client_EAX = 0;
                DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: WAITING FOR RM TOKEN ...\n\r");
              }
              break;
            default:
              DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: TOKEN ERROR ! Subfunction UNKOWN !\n\r");
              DBG_BREAKPOINT();
              break;
          }
          break;

        case NVRM_API_GET_DEVICE_TYPE:
            pcs->CRS.Client_EAX = REG_RD32(NV_PBUS_PCI_NV_0);
            break;
        case NVRM_API_REGISTER_DISPLAY_DRIVER:
            RegisterDisplayDriver(pcs);
            break;         

        case NVRM_REGISTRY_SET_STRING:
            {
              int  char_count,string_size;
              char stringt[128]=NV4_REG_RESOURCE_MANAGER_SUBKEY;

              osStringCopy(pDev->Registry.DBstrDevNodeDisplayNumber, (char *)pcs->CRS.Client_EBX);

              // Append the Resource Manager subkey string.("System")
              string_size = osStringLength(pDev->Registry.DBstrDevNodeDisplayNumber);
              pDev->Registry.DBstrDevNodeDisplayNumber[string_size] = '\\';
              string_size++;
              for(char_count=string_size;char_count < (128-string_size);char_count++){
                pDev->Registry.DBstrDevNodeDisplayNumber[char_count]=stringt[char_count-string_size];
              }
              osStringCopy(pDev->Registry.DBstrDevNodeDisplay,pDev->Registry.DBstrDevNodeDisplayNumber);
            }
            break;

        case NVRM_API_DISPLAY_GET_BOOT_PHYS_MAP:
            pcs->CRS.Client_EAX = pDev->Dac.LogicalDeviceMap[pcs->CRS.Client_ECX];
            break;
                
        case NVRM_API_READ_EDID:
            {
                U008 lock;
                U008 failure;
                U032 dispType;
                U032 NVClktemp;

                if (pDev->Power.State != 0)
                {
                    // restore timer before attempting delay
                    REG_WR32(NV_PTIMER_NUMERATOR, pDev->Timer.Numerator);     
                    REG_WR32(NV_PTIMER_DENOMINATOR, pDev->Timer.Denominator);     

                    // turn clocks up
                    REG_WR32(NV_PRAMDAC_PLL_COEFF_SELECT, pDev->Power.coeff_select);
                    if (pDev->Power.MobileOperation)
                    {
                        NVClktemp = pDev->Dac.HalInfo.NVClk;
                        pDev->Dac.HalInfo.NVClk = pDev->Power.PostNVCLK;
                    }

                    if (dacProgramNVClk(pDev) != RM_OK)
                    {
                        REG_WR32(NV_PRAMDAC_NVPLL_COEFF, pDev->Power.nvpll);         // nvclk
                    }

                    if (pDev->Power.MobileOperation)
                    {
                        pDev->Dac.HalInfo.NVClk = NVClktemp;
                    }

                    REG_WR32(NV_PRAMDAC_MPLL_COEFF, pDev->Power.mpll);           // mclk
                }

                // From parameter stack
                Head = pcs->CRS.Client_ECX;

                lock = UnlockCRTC(pDev, Head);

                 // Given a head number only, get the EDID for the attached device
                // This is called just after initDac().
                // We need to figure out the display type before we call EDIDRead().
                // We also need to call EDIDDetect to find out if there really is a display device attached,
                // since EDIDRead() will return RM_OK because it will get the BIOS default EDID.
                dispType = GETDISPLAYTYPE(pDev, Head);
                failure = 0;
                if (dispType == -1)
                {
                    dispType = DISPLAY_TYPE_FLAT_PANEL;
                    if (RM_OK != EDIDDetect(pDev, Head, dispType))
                    {
                        dispType = DISPLAY_TYPE_MONITOR;
                        if (RM_OK != EDIDDetect(pDev, Head, dispType))
                        {
                            failure = 1;
                        }
                    }
                }

                if (failure || RM_OK != EDIDRead(pDev, Head, dispType)) 
                {
                    pcs->CRS.Client_EAX = 0;
                } 
                else 
                {
                    // Copy the pointer to the edid buffer.
                    pcs->CRS.Client_EAX = (U032)pDev->Dac.CrtcInfo[Head].EDID;
                }

                RestoreLock(pDev, Head, lock);
            }
            break;
       
        case NVRM_API_GET_DDC_CAPS:
            // handle the VESA DDC Get Caps function (set bitmap of DDC addresses)
            pcs->CRS.Client_EBX = edidGetDDCCaps(pDev);
            pcs->CRS.Client_EAX = 0x004f;   // success
            break;
                
        case NVRM_API_SET_MONITOR_POWER:
            // In APM (dell data) it is common to get
            // monitor power on after we have entered power level 4
            // this will cause a bloom.  So we ignore power on/off calls
            // after the suspend
            if (pDev->Power.State == MC_POWER_LEVEL_4)
                 break;
            // Handle the ACPI monitor power state
            if (pcs->CRS.Client_ECX == 0)   // only on and off
            {
                DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: Turn On monitor power\n");

                if(pDev->Power.Flags & DAC_POWER_PENDING)
                {
                    //Reset global power_pending flag
                    pDev->Power.Flags &= ~DAC_POWER_PENDING;

                    // Bug 29711: if you hibernate on CRT, unplug CRT, boot back up
                    // on LCD, the LCD blooms. When we get to this function, we do
                    // a modeset on the CRT because the pVidLutCurDacs are setup for
                    // head A = CRT and head B = Nothing.  If we reset the chip in 
                    // mcPowerState, we turn off the flat panel clocks.  When we call 
                    // Wake Up in this function, the LCD turns on, but the clocks
                    // do not. This causes blooming.  
                    // So to fix this, if we've reset the chip, and we've boot to  
                    // an LCD, don't power on the panel!  The Reset flag is turned
                    // off at the end of dacSetFlatPanelMode in dacfp.c.
                    if(pDev->Dac.DevicesEnabled & DAC_PANEL_CLK_RESET)
                    {
                        if(pDev->Dac.BootDevicesBitMap & DAC_DD_MASK_IN_MAP)
                        {
                            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Set Monitor Power called after chip reset without panel clocks setup!\n");
                            break;
                        }
                    }

                    for(Head = 0; Head < MAX_CRTCS; Head++)
                    {
                        if ((GETDISPLAYTYPE(pDev, Head) != DISPLAY_TYPE_NONE))
                        {
                            // Enable display
                            dacEnableDac(pDev, Head);

                            // also make sure the cursor image is updated
                            pDev->Dac.CrtcInfo[Head].UpdateFlags &= (~UPDATE_HWINFO_DAC_CURSOR_ENABLE);
                            pDev->Dac.CrtcInfo[Head].UpdateFlags |= (UPDATE_HWINFO_DAC_CURSOR_IMAGE_NEW |
                                                                  UPDATE_HWINFO_DAC_CURSOR_DISABLE);
                        }
                    }

                    //Toshiba specefic call (DPMS, hotkeys)
                    //Backlight enabled inside dacEnableDac for other mobiles
                    if (pDev->Power.MobileOperation == 2)
                    { 
                        U032    EAX, EBX, ECX, EDX;
                        EAX = 0x4F10;
                        EBX = 0x0001; //wake up
                        EDX = 0x0000;
                        ECX = 0x0000;
                        status = osCallVideoBIOS(pDev, &EAX, &EBX, &ECX, &EDX, NULL);
                    }
                }
            }
            else
            {
                DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: Turn Off monitor power\n");

                if(!(pDev->Power.Flags & DAC_POWER_PENDING))
                {
                    // Turn off the backlight before disabling the DACs
                    if (pDev->Power.MobileOperation)
                    { 
                        if (pDev->Power.MobileOperation == 2)
                        {
                            //Toshiba specefic call (DPMS, hotkeys)
                            U032    EAX, EBX, ECX, EDX;
                            EAX = 0x4F10;
                            EBX = 0x0401; //sleep
                            EDX = 0x0000;
                            ECX = 0x0000;
                            status = osCallVideoBIOS(pDev, &EAX, &EBX, &ECX, &EDX, NULL);
                        }
                    }

                    for(Head = 0; Head < MAX_CRTCS; Head++)
                    {
                        // if active display on Head?
                        if (GETDISPLAYTYPE(pDev, Head) != DISPLAY_TYPE_NONE)
                        {
                            dacDisableDac(pDev, Head);         // blank display
                        }
                    }

                    //Set global power_pending flag
                    //That means we would never touch neither power nor backlight
                    //on the flat panel until we would pass this case with power ON.
                    pDev->Power.Flags |= DAC_POWER_PENDING;
                }
            }

            break;
        
        case NVRM_API_BLANK_SECONDARY:
            {
                U032    PrimaryHead, i, CurrentDisplayType, CurHRes, CurVRes;
                PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
                U008 lock, Cr28, Cr33, Cr49;
                
                // Determine which head is the Primary device
                for (i = 0, PrimaryHead = 0; i < pDev->Dac.HalInfo.NumCrtcs; i++)
                {
                    if (pDev->Dac.CrtcInfo[i].PrimaryDevice == TRUE)
                    {
                        PrimaryHead = i;
                        break;
                    }
                }
                if (pDev->Dac.EncoderType == NV_ENCODER_BROOKTREE_871) 
                {

                    dacTV871Readback(pDev, 0, 0);  // set legacy readback mode
                    dacDisableTV(pDev, 0);
                }

                // Blank the secondary device. Also enable the BIOS's primary head and set up the display type
                if (pDev->Dac.CrtcInfo[PrimaryHead].pVidLutCurDac != NULL)
                {
                    if (pDev->Power.MobileOperation)    // mobile BIOS is multihead
                    {
                        // MOBILE
                        U008 Cr3B[2];
                        U032 SecondaryHead = PrimaryHead^1;
                        
                        // Read Head A CRTC regs
                        lock = UnlockCRTC(pDev, 0);
                        CRTC_RD(0x3B, Cr3B[0], 0);   // find out which displays are active
                        RestoreLock(pDev, 0, lock);
                        
                        // Read Head B CRTC regs
                        lock = UnlockCRTC(pDev, 1);
                        CRTC_RD(0x3B, Cr3B[1], 1);   // find out which displays are active
                        RestoreLock(pDev, 1, lock);
                        
                        // check to see if we need to disable second head
                        if (!pDev->Dac.BroadcastSupport)  // BIOS/chip revision does not support broadcast mode
                        {
                            dacDisableDac(pDev, SecondaryHead); // blank display on the other head
                    
                            // remove the displays from the secondary Cr3B registers
                            lock = UnlockCRTC(pDev, SecondaryHead);
                            CRTC_WR(0x3B, (Cr3B[SecondaryHead]&0x0F), SecondaryHead);
                            RestoreLock(pDev, SecondaryHead, lock);
                    
                            // Save off this information here for rmEnableHires
                            if(pDev->Dac.DeviceProperties.Spanning)
                            {
                                pDev->Dac.NonBroadcastModeStoredCr3B[0] = Cr3B[0]&0xF0;
                                pDev->Dac.NonBroadcastModeStoredCr3B[1] = Cr3B[1]&0xF0;
                            }
                        }
                        
                        // CRT and TV use Head A, DFP uses head B
                        EnableHead(pDev, PrimaryHead);  // leave pointing to the BIOS's primary head
                        pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT) pDev->Dac.CrtcInfo[PrimaryHead].pVidLutCurDac;
                        switch (pVidLutCurDac->DisplayType) 
                        {
                            case DISPLAY_TYPE_FLAT_PANEL:
                                AssocDDC(pDev, 1);  // uses PCRTC, no need to unlock ext CRTC
                                break;
                            case DISPLAY_TYPE_TV:
                            case DISPLAY_TYPE_MONITOR:
                            default:    
                                AssocDDC(pDev, 0);
                                AssocTV(pDev, 0);
                        }
                    }
                    else
                    {
                        // DESKTOP
                        EnableHead(pDev, 0);            // desktop BIOS is single head -- must use head A
                        
                        // Set Cr28 and Cr33 for the current display type
                        pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT) pDev->Dac.CrtcInfo[PrimaryHead].pVidLutCurDac;
                        
                        lock = UnlockCRTC(pDev, 0);
                        CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, Cr28, 0);      // read pixel format
                        CRTC_RD(NV_CIO_CRE_LCD__INDEX, Cr33, 0);
                        switch (pVidLutCurDac->DisplayType) 
                        {
                            case DISPLAY_TYPE_MONITOR:
                                CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, Cr28 & ~0x80, 0);
                                CRTC_WR(NV_CIO_CRE_LCD__INDEX, Cr33 & ~0x13, 0);
                                break;                                
                            case DISPLAY_TYPE_TV:
                                if (pDev->Dac.EncoderType == NV_ENCODER_BROOKTREE_871) 
                                {
                                    // Set 640x480 encoder resolution. The BIOS uses discrete register programming and will be unable 
                                    // to deal with higher resolutions set by the RM using Autoconfig (there must be registers 
                                    // programmed in Autoconfig which the BIOS does not touch).
                                    CurHRes = pDev->Framebuffer.HalInfo.HorizDisplayWidth;
                                    CurVRes = pDev->Framebuffer.HalInfo.VertDisplayWidth;
                                    pDev->Framebuffer.HalInfo.HorizDisplayWidth = 640;      // set object's res
                                    pDev->Framebuffer.HalInfo.VertDisplayWidth = 480;
                                    dacProgramBrooktreeAuto(pDev, 0);                   // do the Autoconfig modeset
                                    pDev->Framebuffer.HalInfo.HorizDisplayWidth = CurHRes;  // restore desktop res
                                    pDev->Framebuffer.HalInfo.VertDisplayWidth = CurVRes;
                                }
                                
                                // provide a clock before slaving the CRTC
                                CRTC_RD(NV_CIO_CRE_ENGINE_CTRL, Cr49, 0);      
                                CRTC_WR(NV_CIO_CRE_ENGINE_CTRL, Cr49 | 0x14, 0); // Head A owns TV + I2C      
                                        
                                CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, Cr28 | 0x80, 0);
                                CRTC_WR(NV_CIO_CRE_LCD__INDEX, Cr33 & ~0x13, 0);
                                break;                                
                            case DISPLAY_TYPE_FLAT_PANEL:
                                // Head A should own I2C
                                CRTC_RD(NV_CIO_CRE_ENGINE_CTRL, Cr49, 0);      
                                CRTC_WR(NV_CIO_CRE_ENGINE_CTRL, Cr49 | 0x04, 0); // Head A owns I2C      
                                // Put valid timings into PRAMDAC_FP so we have a good clock
                                CurrentDisplayType = GETDISPLAYTYPE(pDev, 0);
                                SETDISPLAYTYPE(pDev, 0, DISPLAY_TYPE_FLAT_PANEL); // make sure display type is correct
                                dacSetFlatPanelMode(pDev, 0, pVidLutCurDac, NV_CFGEX_GET_FLATPANEL_INFO_SCALED, FALSE);
                                SETDISPLAYTYPE(pDev, 0, CurrentDisplayType);      // restore type for RM
                                // slave the CRTC to FP
                                CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, Cr28 | 0x80, 0);
                                CRTC_WR(NV_CIO_CRE_LCD__INDEX, Cr33 | 0x13, 0);
                               
                                break;                                
                        }
                        RestoreLock(pDev, 0, lock);
                    }
                }
            }
            break;

        default:
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS, "NVRM: Unknown user API = ", (DWORD)pcs->CRS.Client_EAX);
            DBG_BREAKPOINT();
            break;
    }

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: User Service to Resource Manager complete\n\r");
    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vxd\osdbg.c ===
#define WANTVXDWRAPS
#include <basedef.h>
#include <vmm.h>
#include <vxdwraps.h>
#include <configmg.h>
#include <vcomm.h>
#include <nvtypes.h>
#include <osdbg.h>

#ifdef DEBUG

DEVNODE dbgDevNode = 0xFFFFFFFF;
NvU32 dbgPowerState = CM_POWERSTATE_D3;
NvU32 dbgPowerSysState = 0x0;
NvU32 IsConfig98 = FALSE;

char * ppdbgPortStr_COM1[] = {
   DBG_W98_COM1_KEY_STR1,
   DBG_W98_COM1_KEY_STR2,
   DBG_COM1_KEY_STR3,
   DBG_COM1_KEY_STR4,
   };

char * ppdbgPortStr_COM2[] = {
   DBG_W98_COM2_KEY_STR1,
   DBG_W98_COM2_KEY_STR2,
   DBG_COM2_KEY_STR3,
   DBG_COM2_KEY_STR4,
   };

char * ppdbgPortStr_Parallel[] = {
   DBG_W98_PARALLEL_KEY_STR1,
   DBG_PARALLEL_KEY_STR2,
   };

typedef struct cm_array {
   char ** ppStr;
   NvU32   ulSize;
   } CM_ARRAY, * PCM_ARRAY;   

CM_ARRAY CmArray[] = {
   {ppdbgPortStr_COM1, sizeof(ppdbgPortStr_COM1)/sizeof(char **),},
   {ppdbgPortStr_COM2, sizeof(ppdbgPortStr_COM2)/sizeof(char **),},
   {ppdbgPortStr_Parallel, sizeof(ppdbgPortStr_Parallel)/sizeof(char **),},
   };


// Port Names
char * ppdbgPortNameStr[] = {
   DBG_COM1_PORTNAME,
   DBG_COM2_PORTNAME,
   DBG_PARALLEL_PORTNAME,
   };

extern int dbgObject_inuse;
extern DBGOBJECT DbgObject[];
extern DBGPORT DbgPort;

//
// This routine is a callback if the another proc tries to
// our serial port
//
DWORD StealProc(DWORD dwRefData, DWORD dwType)
{
   (VOID*)dwRefData;
   (VOID*)dwType;
   return 0x0;
}

//
// Walk the string of registry serial ports looking for the
// serial port name
//

NvU32 Locate_DevNode(PDEVNODE pdnDevNode, char * pStr[], NvU32 ulSize)
{
   NvU32 i;
   NvU32 ulReturn;

   ulReturn = CR_NO_SUCH_DEVNODE;
   for (i=0; i<ulSize; i++)
      {
      ulReturn = CMxx_Locate_DevNode(pdnDevNode, pStr[i], 0x0);
      if (CR_SUCCESS == ulReturn)
         break;
      }

   return ulReturn;       
}


//
// This routine is used to call CM_Set_DevNode_PowerState
// to activate the port that we want to use.  The bios
// enables the port but then Windows ACPI Policy Manager
// deactivates the port to reduce power 
//
NvU32 dbgEnableDevice(NvU32 nPort)
{
   NvU32 nReturn;

   nReturn = FALSE;

   if (CR_SUCCESS == Locate_DevNode(&dbgDevNode, CmArray[nPort].ppStr, CmArray[nPort].ulSize))
      {
      // Is this Win '98 Version of Configuration Manager
      // VCOMM will attempt to power the port down if 
      // the registry under SW_KEY\Vxd\VCOMM\EnablePowerManagement is nonzero
      if (CONFIG98_VERSION <= CMxx_Get_Version())
         {
         IsConfig98 = TRUE;
         if (CR_SUCCESS == CMxx_Get_DevNode_PowerState(dbgDevNode, &dbgPowerState, 0x0))
            {
            // Does it hurt to do this if EnablePowerManagement is zero???
            if (CR_SUCCESS == CMxx_Set_DevNode_PowerState(dbgDevNode, CM_POWERSTATE_D0, 0x0))
               {
               nReturn = TRUE;
               }
            }
         }
      }
   
   return nReturn;
}

DWORD hPort = 0x0;
PFNCONTENT hHandler = 0x0;
DWORD hResource;
NvU32 dbgEnableDevice2(PDBGPORT pDbgPort)
{
#if 1
   DWORD hContend;
#endif
   NvU32 nReturn;
   NvU32 nPort;
   nReturn = FALSE;

   if (DBG_OBJECT_SERIAL == dbgObject_inuse)
      {
      nPort = pDbgPort->uTag.Serial.uPort;
      // Unvirtualize the port
      VCD_Set_Port_Global(nPort+1);
      // Steal the port
      if (0x0 == hPort)
         {
         hPort = VCOMM_OpenComm(ppdbgPortNameStr[nPort], 0xFFFFFFFF);
         if (IE_BADID != hPort)
            {
            if (0x0 == hHandler)
               {
               hHandler = VCOMM_Get_Contention_Handler(ppdbgPortNameStr[nPort]); 
               if (0x0 != hHandler)
                  {
                  hResource = VCOMM_Map_Name_To_Resource(ppdbgPortNameStr[nPort]);
                  if (0x0 != hResource)
                     {
                     hContend = hHandler(ACQUIRE_RESOURCE, hResource, StealProc, 0xAA5555AA, TRUE);
                     if (0x0 != hContend)
                        nReturn = TRUE;
                     }
                  }
               }
            }
         }
      // when the port was virtualized it was reinit
      // let's init the way we like
      //Reinit 1 more time
      DbgObject[dbgObject_inuse].pInit(pDbgPort);          
      }

   return nReturn;
}

NvU32 dbgDisableDevice2(PDBGPORT pDbgPort)
{
   if (DBG_OBJECT_SERIAL == dbgObject_inuse)
      {
            
      // When we did the open an implicit VCOMM_PowerOnOffComm was called
      // here we need to undue this else we cannot hibernate
      VCOMM_PowerOnOffComm(dbgDevNode, CM_POWERSTATE_D3);
      }   

   return 0;
}

//
// This routine is used to return the port to its original state.
//
NvU32 dbgDisableDevice(NvU32 nPort)
{
   
   NvU32 nReturn = FALSE;

   if (0xFFFFFFFF != dbgDevNode)
      {
      if (CR_SUCCESS == CMxx_Set_DevNode_PowerState(dbgDevNode, dbgPowerState, 0x0))
         nReturn = TRUE;
      }

   return nReturn;
}

//
// routine to do a simple hex to ascii convert
//
VOID dbgFormat(char * pStr, NvU32 value)
{
	NvS32 i;
	NvS32 hex_digit;
	NvS32 j;
	char rData[8];

	// simple hex to ascii convert
	for (i=0;value!=0;value>>=4)
		{
		hex_digit=value & 0x0F;
		if (hex_digit < 10)
			rData[i]=hex_digit+'0';
		else
			rData[i]=hex_digit-10+'A';
		i++;
		}

	// reverse string
	for (j=0;j<i;j++)
		pStr[j]=rData[i-j-1];

	// if the number is zero then we need to insert zero digit
	if (0==i)
		pStr[i++]='0';

	// null terminate
	pStr[i]='\0';
}

//
// Null Table Functions
//

//
// Null Config Function
//
void dbgConfigNull(NvV32 * pDev)
{
	return;
}

//
// Null Init Function
//
void dbgInitNull(PDBGPORT pDbgPort)
{
	return;
}

//
// Null Display Function
//
void dbgDisplayNull(char * pStr)
{
	return;
}

//
// Null Open Function
//
void dbgOpenNull(NvV32 * pDev)
{
	return;
}

//
// Null Close Function
//
void dbgCloseNull(NvV32 * pDev)
{
	return;
}


// 
// The following is a simple IO Sections
//
//
// Read a byte from a Word Port
//
// Fix Help find and Figure out how to call internal io routines
NvU8 inpb(NvU16 uPort)
{
	NvU8 bReturn;

	_asm push	edx
	_asm mov	dx, uPort
	_asm in		al, dx
	_asm mov	bReturn, al
	_asm pop	edx

	return bReturn;
}

//
// Read a word from word Port
//
NvU16 inpw(NvU16 uPort)
{
	NvU16 wReturn;

	_asm push	edx
	_asm mov	dx, uPort
	_asm in		ax, dx
	_asm mov	wReturn, ax
	_asm pop	edx

	return wReturn;
}

//
// Write a byte to a word port
//
VOID outpb(NvU16 uPort, NvU8 bValue)
{
	_asm push	edx
	_asm mov	dx, uPort
	_asm mov	al, bValue
	_asm out	dx, al
	_asm pop	edx
}

//
// Write a word to a word port
//
VOID outpw(NvU16 uPort, NvU16 wValue)
{
	_asm push	edx
	_asm mov	dx, uPort
	_asm mov	ax, wValue
	_asm out	dx, ax
	_asm pop	edx
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vxd\nvwatch.c ===
//
// (C) Copyright NVIDIA Corporation Inc., 1995-2000. All rights reserved.
// (C) Copyright SGS-THOMSON Microelectronics Inc., 1996. All rights reserved.
//
/******************* Operating System Interface Routines *******************\
*                                                                           *
* Module: NV3Watch.C                                                        *
*   Winice .N Debug Interface.                                              *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Jim Vito 9/23/98 - wrote it.                                        *
\***************************************************************************/
#include "basedef.h"
#include "vmmtypes.h"
#include "vmm.h"        // put this first. we redefine macro SF_BIT in nvrm.h
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <nvromdat.h>
#include <class.h>
#include <vblank.h>
#include <dma.h>
#include <fifo.h>
#include <gr.h>
#include <dac.h>
#include <heap.h>
#include <os.h>
#include "nvrmwin.h"
#include "nvhw.h"
#include "vpicd.h"
#include "vdd.h"
#include "vnvrmd.h"
#include "oswin.h"
#include "vmm2.h"       // more vmm services
#include "vwin32.h"

//
// These defines are in the chip-dependent headers.  Rather than
// create a big mess by trying to #include them here, just pull what
// we need.
//

// hash table offset
#define NV_PFIFO_RAMHT                                   0x00002210 /* RW-4R */

#ifdef DEBUG


//
// prototypes
//
RM_STATUS btreeNodeValidate                 (PNODE);
VOID    NvWatch_MTRR_RegisterStuff          (VOID);
VOID    NvWatch_QuickDiag_fifo              (PHWINFO, PNVWATCHDIAGSTRUCT);
VOID    NvWatch_QuickDiag_master            (PHWINFO, PNVWATCHDIAGSTRUCT);
U032    NvWatch_NV04_GetHashSize            (PHWINFO);
VOID    NvWatch_NV04_Dump_Fifo              (PHWINFO);
VOID    NvWatch_NV04_Dump_Graphics          (PHWINFO);
VOID    NvWatch_NV04_Dump_Master            (PHWINFO);
VOID    NvWatch_NV04_Dump_Video             (PHWINFO);
VOID    NvWatch_NV04_Query_DeviceContext    (PHWINFO);
int     NvWatch_NV04_DmaPushAndFifo         (PHWINFO);
VOID    NvWatch_NV04_FillDiagStruct         (PHWINFO, PNVWATCHDIAGSTRUCT);
VOID    NvWatch_NV04_DumpGrTableContents    (PHWINFO, U032);
VOID    NvWatch_NV10_DumpGrTableContents    (PHWINFO, U032);
U032    NvWatch_NV10_GetHashSize            (PHWINFO);
VOID    NvWatch_NV10_Dump_Fifo              (PHWINFO);
VOID    NvWatch_NV10_Dump_Graphics          (PHWINFO);
VOID    NvWatch_NV10_Dump_Master            (PHWINFO);
VOID    NvWatch_NV10_Dump_Video             (PHWINFO);
VOID    NvWatch_NV10_Query_DeviceContext    (PHWINFO);
int     NvWatch_NV10_DmaPushAndFifo         (PHWINFO);


// Crush11 will have 512 64KB Mapping regions. 32MB Maximum.								  
// 16 4KB PTE's will define the physical memory	for each of the 64KB blocks.
#define NVWATCH_MAX_MEM_BLOCKS 512        
#define NUM_PAGES_FOR_A_64KB_BLOCK  0x10
#define NVWATCH_MAX_PAGES_PER_BLOCK NUM_PAGES_FOR_A_64KB_BLOCK

void *nvwatch_block_buffers[NVWATCH_MAX_MEM_BLOCKS]; /* up to 64K blocks*/
U032 nvwatch_PageArray[NVWATCH_MAX_MEM_BLOCKS][NVWATCH_MAX_PAGES_PER_BLOCK];
U032 nvwatch_crush11_failed_data;
U032 NvWatch_num_objects; 
//U032 NvWatch_channel;
char NvWatch_ObjectStrings[][33]={"NV01_NULL_OBJECT                ", /*    (0x00000000) */
                                  "NV01_CLASS                      ", /*    (0x00000001) */
                                  "NV01_CONTEXT_DMA_FROM_MEMORY    ", /*    (0x00000002) */
                                  "NV01_CONTEXT_DMA_TO_MEMORY      ", /*    (0x00000003) */
                                  "NV01_TIMER                      ", /*    (0x00000004) */
                                  "UNDEFINED_CLASS_Nv005           ", /*                 */
                                  "UNDEFINED_CLASS_Nv006           ", /*                 */
                                  "UNDEFINED_CLASS_Nv007           ", /*                 */
                                  "UNDEFINED_CLASS_Nv008           ", /*                 */
                                  "UNDEFINED_CLASS_Nv009           ", /*                 */
                                  "UNDEFINED_CLASS_Nv00a           ", /*                 */
                                  "UNDEFINED_CLASS_Nv00b           ", /*                 */
                                  "UNDEFINED_CLASS_Nv00c           ", /*                 */
                                  "UNDEFINED_CLASS_Nv00d           ", /*                 */
                                  "UNDEFINED_CLASS_Nv00e           ", /*                 */
                                  "UNDEFINED_CLASS_Nv00f           ", /*                 */
                                  "UNDEFINED_CLASS_Nv010           ", /*                 */
                                  "UNDEFINED_CLASS_Nv011           ", /*                 */
                                  "NV01_BETA_SOLID                 ", /*    (0x00000012) */
                                  "UNDEFINED_CLASS_Nv013           ", /*                 */
                                  "UNDEFINED_CLASS_Nv014           ", /*                 */
                                  "UNDEFINED_CLASS_Nv015           ", /*                 */
                                  "UNDEFINED_CLASS_Nv016           ", /*                 */
                                  "NV01_IMAGE_SOLID                ", /*    (0x00000017) */
                                  "NV01_IMAGE_PATTERN              ", /*    (0x00000018) */
                                  "NV01_IMAGE_BLACK_RECTANGLE      ", /*    (0x00000019) */
                                  "UNDEFINED_CLASS_Nv01a           ", /*                 */
                                  "UNDEFINED_CLASS_Nv01b           ", /*                 */
                                  "NV01_RENDER_SOLID_LIN           ", /*    (0x0000001C) */
                                  "NV01_RENDER_SOLID_TRIANGLE      ", /*    (0x0000001D) */
                                  "NV01_RENDER_SOLID_RECTANGLE     ", /*    (0x0000001E) */
                                  "NV01_IMAGE_BLIT                 ", /*    (0x0000001F) */
                                  "UNDEFINED_CLASS_Nv020           ", /*                 */
                                  "NV01_IMAGE_FROM_CPU             ", /*    (0x00000021) */
                                  "UNDEFINED_CLASS_Nv022           ", /*                 */
                                  "UNDEFINED_CLASS_Nv023           ", /*                 */
                                  "UNDEFINED_CLASS_Nv024           ", /*                 */
                                  "UNDEFINED_CLASS_Nv025           ", /*                 */
                                  "UNDEFINED_CLASS_Nv026           ", /*                 */
                                  "UNDEFINED_CLASS_Nv027           ", /*                 */
                                  "UNDEFINED_CLASS_Nv028           ", /*                 */
                                  "UNDEFINED_CLASS_Nv029           ", /*                 */
                                  "UNDEFINED_CLASS_Nv02a           ", /*                 */
                                  "UNDEFINED_CLASS_Nv02b           ", /*                 */
                                  "UNDEFINED_CLASS_Nv02c           ", /*                 */
                                  "UNDEFINED_CLASS_Nv02d           ", /*                 */
                                  "UNDEFINED_CLASS_Nv02e           ", /*                 */
                                  "UNDEFINED_CLASS_Nv02f           ", /*                 */
                                  "NV01_NULL                       ", /*    (0x00000030) */
                                  "UNDEFINED_CLASS_Nv031           ", /*                 */
                                  "UNDEFINED_CLASS_Nv032           ", /*                 */
                                  "UNDEFINED_CLASS_Nv033           ", /*                 */
                                  "UNDEFINED_CLASS_Nv034           ", /*                 */
                                  "UNDEFINED_CLASS_Nv035           ", /*                 */
                                  "NV03_STRETCHED_IMAGE_FROM_CPU   ", /*    (0x00000036) */
                                  "NV03_SCALED_IMAGE_FROM_MEMORY   ", /*    (0x00000037) */
                                  "NV04_DVD_SUBPICTURE             ", /*    (0x00000038) */
                                  "NV03_MEMORY_TO_MEMORY_FORMAT    ", /*    (0x00000039) */
                                  "UNDEFINED_CLASS_Nv03a           ", /*                 */
                                  "UNDEFINED_CLASS_Nv03b           ", /*                 */
                                  "UNDEFINED_CLASS_Nv03c           ", /*                 */
                                  "NV01_CONTEXT_DMA_IN_MEMORY      ", /*    (0x0000003D) */
                                  "NV01_CONTEXT_ERROR_TO_MEMORY    ", /*    (0x0000003E) */
                                  "NV01_MEMORY_PRIVILEGED          ", /*    (0x0000003F) */
                                  "NV01_MEMORY_USER                ", /*    (0x00000040) */
                                  "UNDEFINED_CLASS_Nv041           ", /*                 */
                                  "NV04_CONTEXT_SURFACES_2D        ", /*    (0x00000042) */
                                  "NV03_CONTEXT_ROP                ", /*    (0x00000043) */
                                  "NV04_CONTEXT_PATTERN            ", /*    (0x00000044) */
                                  "UNDEFINED_CLASS_Nv045           ", /*                 */
                                  "NV04_VIDEO_LUT_CURSOR_DAC       ", /*    (0x00000046) */
                                  "UNDEFINED_CLASS_Nv047           ", /*                 */
                                  "NV03_DX3_TEXTURED_TRIANGLE      ", /*    (0x00000048) */
                                  "UNDEFINED_CLASS_Nv049           ", /*                 */
                                  "NV04_GDI_RECTANGLE_TEXT         ", /*    (0x0000004A) */
                                  "NV03_GDI_RECTANGLE_TEXT         ", /*    (0x0000004B) */
                                  "UNDEFINED_CLASS_Nv04c           ", /*                 */
                                  "NV03_EXTERNAL_VIDEO_DECODER     ", /*    (0x0000004D) */
                                  "NV03_EXTERNAL_VIDEO_DECOMPRESSOR", /*    (0x0000004E) */
                                  "NV01_EXTERNAL_PARALLEL_BUS      ", /*    (0x0000004F) */
                                  "NV03_EXTERNAL_MONITOR_BUS       ", /*    (0x00000050) */
                                  "NV03_EXTERNAL_SERIAL_BUS        ", /*    (0x00000051) */
                                  "NV04_CONTEXT_SURFACE_SWIZZLED   ", /*    (0x00000052) */
                                  "NV04_CONTEXT_SURFACES_3D        ", /*    (0x00000053) */
                                  "NV04_DX5_TEXTURED_TRIANGLE      ", /*    (0x00000054) */
                                  "NV04_DX6_MULTI_TEXTURE_TRIANGLE ", /*    (0x00000055) */
                                  "UNDEFINED_CLASS_Nv056           ", /*                 */
                                  "NV04_CONTEXT_COLOR_KEY          ", /*    (0x00000057) */
                                  "NV03_CONTEXT_SURFACE_0          ", /*    (0x00000058) */
                                  "NV03_CONTEXT_SURFACE_1          ", /*    (0x00000059) */
                                  "NV03_CONTEXT_SURFACE_2          ", /*    (0x0000005A) */
                                  "NV03_CONTEXT_SURFACE_3          ", /*    (0x0000005B) */
                                  "NV04_RENDER_SOLID_LIN           ", /*    (0x0000005C) */
                                  "NV04_RENDER_SOLID_TRIANGLE      ", /*    (0x0000005D) */
                                  "NV04_RENDER_SOLID_RECTANGLE     ", /*    (0x0000005E) */
                                  "NV04_IMAGE_BLIT                 ", /*    (0x0000005F) */
                                  "NV04_INDEXED_IMAGE_FROM_CPU     ", /*    (0x00000060) */
                                  "NV04_IMAGE_FROM_CPU             ", /*    (0x00000061) */
                                  "NV010_CONTEXT_SURFACES_2D       ", /*                 */
                                  "NV05_SCALED_IMAGE_FROM_MEMORY   ", /*    (0x00000063) */
                                  "NV05_INDEXED_IMAGE_FROM_CPU     ", /*    (0x00000064) */
                                  "NV05_IMAGE_FROM_CPU             ", /*    (0x00000065) */
                                  "NV05_STRETCHED_IMAGE_FROM_CPU   ", /*    (0x00000066) */
                                  "NV10_VIDEO_LUT_CURSOR_DAC       ", /*                 */
                                  "UNDEFINED_CLASS_Nv068           ", /*                 */
                                  "UNDEFINED_CLASS_Nv069           ", /*                 */
                                  "NV03_CHANNEL_PIO                ", /*    (0x0000006A) */
                                  "NV03_CHANNEL_DMA                ", /*    (0x0000006B) */
                                  "NV04_CHANNEL_DMA                ", /*    (0x0000006C) */
                                  "UNDEFINED_CLASS_Nv06d           ", /*                 */
                                  "NV10_CHANNEL_DMA                ", /*                 */
                                  "UNDEFINED_CLASS_Nv06f           ", /*                 */
                                  "UNDEFINED_CLASS_Nv070           ", /*                 */
                                  "UNDEFINED_CLASS_Nv071           ", /*                 */
                                  "NV04_CONTEXT_BETA               ", /*    (0x00000072) */
                                  "UNDEFINED_CLASS_Nv073           ", /*                 */
                                  "UNDEFINED_CLASS_Nv074           ", /*                 */
                                  "UNDEFINED_CLASS_Nv075           ", /*                 */
                                  "NV04_STRETCHED_IMAGE_FROM_CPU   ", /*    (0x00000076) */
                                  "NV04_SCALED_IMAGE_FROM_MEMORY   ", /*    (0x00000077) */
                                  "UNDEFINED_CLASS_Nv078           ", /*                 */
                                  "UNDEFINED_CLASS_Nv079           ", /*                 */
                                  "NV10_VIDEO_OVERLAY              ", /*                 */
                                  "NV10_TEXTURE_FROM_CPU           ", /*                 */
                                  "UNDEFINED_CLASS_Nv07c           ", /*                 */
                                  "UNDEFINED_CLASS_Nv07d           ", /*                 */
                                  "UNDEFINED_CLASS_Nv07e           ", /*                 */
                                  "UNDEFINED_CLASS_Nv07f           ", /*                 */
                                  "NV01_DEVICE_0                   ", /*    (0x00000080) */
                                  "NV01_DEVICE_1                   ", /*    (0x00000081) */
                                  "NV01_DEVICE_2                   ", /*    (0x00000082) */
                                  "NV01_DEVICE_3                   ", /*    (0x00000083) */
                                  "NV01_DEVICE_4                   ", /*    (0x00000084) */
                                  "NV01_DEVICE_5                   ", /*    (0x00000085) */
                                  "NV01_DEVICE_6                   ", /*    (0x00000086) */
                                  "NV01_DEVICE_7                   ", /*    (0x00000087) */
                                  "NV10_DVD_SUBPICTURE             ", /*    (0x00000088) */
                                  "NV10_SCALED_IMAGE_FROM_MEMORY   ", /*    (0x00000089) */
                                  "UNDEFINED_CLASS_Nv08a           ", /*                 */
                                  "UNDEFINED_CLASS_Nv08b           ", /*                 */
                                  "UNDEFINED_CLASS_Nv08c           ", /*                 */
                                  "UNDEFINED_CLASS_Nv08d           ", /*                 */
                                  "UNDEFINED_CLASS_Nv08e           ", /*                 */
                                  "UNDEFINED_CLASS_Nv08f           ", /*                 */
                                  "UNDEFINED_CLASS_Nv090           ", /*                 */
                                  "UNDEFINED_CLASS_Nv091           ", /*                 */
                                  "UNDEFINED_CLASS_Nv092           ", /*                 */
                                  "NV10_CONTEXT_SURFACES_3D        ", /*    (0x00000093) */
                                  "NV10_DX5_TEXTURED_TRIANGLE      ", /*    (0x00000094) */
                                  "NV10_DX6_MULTI_TEXTURE_TRIANGLE ", /*    (0x00000095) */
                                  "ERROR: CLASS # TOO LARGE !!!    "}; /*    (>95) */

#define MAX_CLASS_NUMBER_SUPPORTED 0x95      
// This would be different for NV3.
#define INSTANCE_MEM_SPACE        nvAddr 

#define NVWATCH_SIMPLE 0
#define NVWATCH_COMPLEX 1
#define CurrentPatch    upatch.CurrentPatchNV10

// Internal dispatch defines.
#define NVWATCH_FUNC_GETHASHSIZE         0
#define NVWATCH_FUNC_DUMP_FIFO           1
#define NVWATCH_FUNC_DUMP_GRAPHICS       2
#define NVWATCH_FUNC_DUMP_MASTER         3
#define NVWATCH_FUNC_DUMP_VIDEO          4
#define NVWATCH_FUNC_QUERYDEVICECONTEXT  5
#define NVWATCH_FUNC_DMAPUSH_AND_FIFO    6

// JJV - Have this function echo the input.
char get_winice_input(void)
{
  char return_val;
  char echo_string[] = "x";

  _asm  mov  ax,1
  _asm  int  41h
  _asm  mov  return_val, al
  
  // Echo the keystrokes to the terminal.
  if (1){
    echo_string[0] = return_val;
    _asm  push ss
    _asm  pop  ds
    _asm  mov  ax, 2
    _asm  lea  esi, echo_string
    _asm  int  41h
  }
  
  return(return_val);
}

// Returns status.
DWORD NvWatch_ascii2hex(char *ascii_string, DWORD *ret_val)
{
  int i;
  BYTE temp_b;
  DWORD return_val=0;

  for(i=0;i<8;i++){
    temp_b = ascii_string[i];
    if( (temp_b < 0x30)||((temp_b > 0x39)&&(temp_b < 0x41))||((temp_b > 0x46)&&(temp_b < 0x61))|| \
        (temp_b > 0x66) ){
      //DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  Invalid register offset entered. (Must be upper case ! sorry)");
      return(0);
    }
    
    // Deal with the lower case 1st.
    if(temp_b >= 0x61)
      temp_b -= 0x20;
    
    if(temp_b > 0x39)
      temp_b -= 0x37;
    else
      temp_b -= 0x30;
      
    _asm  mov  eax, return_val
    _asm  or   al, temp_b
    _asm  ror  eax,4
    _asm  mov  return_val, eax
  }   
  
  *ret_val = return_val;
  return(1);   /* return success*/
}

DWORD NvWatch_GetInputDword(DWORD *dword_read)
{
  int i,j;
  char instring[]="00000000";
  char inchar;
  BYTE got_cr=FALSE;
  //DWORD inchar_dword;
  
  for(i=0;i<9;i++){
    // Get a character
    inchar = get_winice_input();
    
    if(inchar == '\r'){
      got_cr = TRUE;
    }else{
      // Get the character ... up to 8.
      if(i<8){
        // shift all the characters to the left.
        for(j=7;j>0;j--)
          instring[j] = instring[j-1];
        // put the character in the bottom
        instring[0] = inchar;
      }  
    }
    
    if(got_cr){
      if(i==0){
        //DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  Error: Got a cr ... but no number entered");
        return(FALSE);
      }
      // Try to translate the thing.
      if(!NvWatch_ascii2hex(instring, dword_read)){
        //DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  Error: Got a cr ... but can't decifer the value");
        return(FALSE);
      }else
        return(TRUE);
    }else{
      if(i==8){
        // exit with an error.
        //DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  Error: Never got a  cr");
        return(FALSE);
      }  
    } 
  }  
}

void NvWatch_display_prompt(PHWINFO pDev, char *instring)
{
  U032 device_id_chip;
  U032 device;
  int i;

  for(i=0;i<MAX_INSTANCE;i++){
      if(pDev == NvDBPtr_Table[i]){
          device=i;
          break;
      }
  }

  device_id_chip = REG_RD32(NV_PBUS_PCI_NV_0);
  device_id_chip = (U032) ((device_id_chip >> DRF_SHIFT(NV_CONFIG_PCI_NV_0_DEVICE_ID)) &
      DRF_MASK(NV_CONFIG_PCI_NV_0_DEVICE_ID));

  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, instring);
  
  switch(device_id_chip)
  {
      case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV04:
          switch(device)
          {
            case 0:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device0(NV04)>"); break;
            case 1:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device1(NV04)>"); break;
            case 2:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device2(NV04)>"); break;
            case 3:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device3(NV04)>"); break;
            case 4:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device4(NV04)>"); break;
            case 5:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device5(NV04)>"); break;
            case 6:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device6(NV04)>"); break;
            case 7:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device7(NV04)>"); break;
            case 8:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device8(NV04)>"); break;
          }
          break;
      case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV05_DEVID0:
      case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV05_DEVID1:
      case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV05_DEVID2:
      case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV05_DEVID3:
          switch(device)
          {
            case 0:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device0(NV05)>"); break;
            case 1:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device1(NV05)>"); break;
            case 2:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device2(NV05)>"); break;
            case 3:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device3(NV05)>"); break;
            case 4:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device4(NV05)>"); break;
            case 5:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device5(NV05)>"); break;
            case 6:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device6(NV05)>"); break;
            case 7:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device7(NV05)>"); break;
            case 8:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device8(NV05)>"); break;
          }
          break;

      case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV0A_DEVID0:
      case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV0A_DEVID1:
      case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV0A_DEVID2:
      case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV0A_DEVID3:
          switch(device)
          {
            case 0:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device0(NV0A)>"); break;
            case 1:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device1(NV0A)>"); break;
            case 2:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device2(NV0A)>"); break;
            case 3:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device3(NV0A)>"); break;
            case 4:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device4(NV0A)>"); break;
            case 5:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device5(NV0A)>"); break;
            case 6:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device6(NV0A)>"); break;
            case 7:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device7(NV0A)>"); break;
            case 8:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device8(NV0A)>"); break;
          }
          break;

      case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID0:
      case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID1:
      case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID2:
      case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID3:
          switch(device)
          {
            case 0:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device0(NV10)>"); break;
            case 1:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device1(NV10)>"); break;
            case 2:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device2(NV10)>"); break;
            case 3:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device3(NV10)>"); break;
            case 4:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device4(NV10)>"); break;
            case 5:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device5(NV10)>"); break;
            case 6:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device6(NV10)>"); break;
            case 7:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device7(NV10)>"); break;
            case 8:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device8(NV10)>"); break;
          }
          break;

      case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV15_DEVID0:
      case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV15_DEVID1:
      case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV15_DEVID2:
      case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV15_DEVID3:
          switch(device)
          {
            case 0:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device0(NV15)>"); break;
            case 1:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device1(NV15)>"); break;
            case 2:                                             
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device2(NV15)>"); break;
            case 3:                                             
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device3(NV15)>"); break;
            case 4:                                             
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device4(NV15)>"); break;
            case 5:                                             
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device5(NV15)>"); break;
            case 6:                                             
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device6(NV15)>"); break;
            case 7:                                             
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device7(NV15)>"); break;
            case 8:                                             
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device8(NV15)>"); break;
          }                                                     
          break;

      default:
          switch(device)
          {
            case 0:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device0(Disabled or Unknown)>"); break;
            case 1:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device1(Disabled or Unknown)>"); break;
            case 2:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device2(Disabled or Unknown)>"); break;
            case 3:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device3(Disabled or Unknown)>"); break;
            case 4:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device4(Disabled or Unknown)>"); break;
            case 5:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device5(Disabled or Unknown)>"); break;
            case 6:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device6(Disabled or Unknown)>"); break;
            case 7:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device7(Disabled or Unknown)>"); break;
            case 8:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device8(Disabled or Unknown)>"); break;
          }
          break;
  }
}

//****INSTANCE MEMORY INFO MENU******************************************************************************

U032 NvWatch_GetObjectFromInst(PHWINFO pDev, U032 inst, U032 *DHandle)
{
  U032 object_count, temp_d;
  U032 *hash_table_ptr;
  
  // Start from the beginning of Instance Memory
  hash_table_ptr = (U032 *) (INSTANCE_MEM_SPACE/*nvAddr*/ + ((pDev->Pram.HalInfo.PraminOffset + 0x10000)/4));
  // traverse the HT searching for objects.
  for(object_count=0;object_count<NvWatch_num_objects;object_count++){
    if((U032) *(hash_table_ptr+1) != 0){
      temp_d = (U032) *(hash_table_ptr+1);
      temp_d &= 0xFFFF;
      if (temp_d == inst){
        *DHandle = (U032) *(hash_table_ptr);
        return(1);
      }
    }    
    hash_table_ptr+=2;
  } 
  // Error ... Not Found.
  return(0); 
}

U032 NvWatch_Process_Hash_Entry(PHWINFO pDev, U032 *hash_table_ptr, U032 verbose)
{

  U032 temp_var,t_channel;
  U032 error_found=FALSE;
  U032 *inst_ptr;
  U032 is_software=FALSE;
  OBJECT t_object,*pt_object;

  pt_object = &t_object;

  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nHandle=");
  DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (int) *hash_table_ptr);
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  Hash entry data=");
  DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (int) *(hash_table_ptr+1));
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  Hash entry offset=");
  DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (int) hash_table_ptr);
  
  // Print the engine.
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nEngine=");
  temp_var = (U032) *(hash_table_ptr+1);
  temp_var >>= 16;
  temp_var &= 3;
  switch(temp_var){
    case 0:
      DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Software"); is_software=TRUE; break;
    case 1:
      DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Graphics"); break;
    case 2:
      DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "DVD     "); break;
    default:
      DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "ERROR!! "); error_found = TRUE; break;
  }  
  
  // Print the channel ID.
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  Channel ID=");
  temp_var = (U032) *(hash_table_ptr+1);
  temp_var >>= 24;
  temp_var &= 0xf;
  DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (int) temp_var);
  
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  Status=");
  temp_var = (U032) *(hash_table_ptr+1);
  temp_var >>= 31;
  if(temp_var)
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "VALID");
  else
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "INVALID");
    
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  Instance offset=");
  temp_var = (U032) *(hash_table_ptr+1);
  temp_var &= 0xFFFF;
  temp_var <<=4;
  temp_var += (U032) INSTANCE_MEM_SPACE/*nvAddr*/ + (U032) pDev->Pram.HalInfo.PraminOffset;
  DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (int) temp_var);
  
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n");
  
  if(verbose){
    // Parse the Instance Memory also. (temp_var has the offset to the Instance)
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Instance Dump: DATA=");
    inst_ptr = (U032 *) temp_var;
    DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (int) *inst_ptr);
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " ");
    DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (int) *(inst_ptr+1));
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " ");
    DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (int) *(inst_ptr+2));
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " ");
    DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (int) *(inst_ptr+3));
    temp_var = (U032) *inst_ptr;
    temp_var &= 0xFFF;
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nClass=");

    // Special case software objects from DMA_CONTEXT objects.
    if( (is_software)&&(temp_var != NV01_CONTEXT_DMA_TO_MEMORY)&& \
        (temp_var != NV01_CONTEXT_DMA_FROM_MEMORY)&&(temp_var != NV01_CONTEXT_DMA_IN_MEMORY) ){
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"Software Object Class=");
        // Search the fifo database for this guy. (Since instance memory tells us nothing)
        for(t_channel=0;t_channel<pDev->Fifo.HalInfo.Count;t_channel++){
            // Do not call fifoSearchObject on an channel that has not been initialized.
            if(((U032)pDev->DBfifoTable[t_channel].ObjectTree) == 0x69696969){
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"ERROR: NOT FOUND ??");
                break;
            }
            if(fifoSearchObject((PHWINFO) pDev,(U032) *hash_table_ptr, (U032) t_channel, (POBJECT *) &pt_object)==RM_OK){
                temp_var =(U032) pt_object->Class->Type;
                if(temp_var>MAX_CLASS_NUMBER_SUPPORTED)
                  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,NvWatch_ObjectStrings[MAX_CLASS_NUMBER_SUPPORTED+1]);
                else  
                  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,NvWatch_ObjectStrings[temp_var]);
                break;
            }
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"ERROR: NOT FOUND ??");
        }
    }
    else{   
      if(temp_var>MAX_CLASS_NUMBER_SUPPORTED)
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,NvWatch_ObjectStrings[MAX_CLASS_NUMBER_SUPPORTED+1]);
      else  
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,NvWatch_ObjectStrings[temp_var]);
    }
      
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n");
    
    switch(temp_var){
      case NV01_CONTEXT_DMA_TO_MEMORY:
      case NV01_CONTEXT_DMA_FROM_MEMORY:
      case NV01_CONTEXT_DMA_IN_MEMORY: 
        if(((U032) *inst_ptr) & 0x1000)
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "DMA_PAGE_TABLE_PRESENT");
        else  
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "DMA_PAGE_TABLE_NOT_PRESENT");
        if(((U032) *inst_ptr) & 0x2000)
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " DMA_PAGE_ENTRY_LINEAR");
        else  
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " DMA_PAGE_ENTRY_NOT_LINEAR");
        temp_var = (U032) *inst_ptr;
        temp_var >>= 16;
        temp_var &= 3;
        switch(temp_var){
          case 0: DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " TARGET_NODE_NVM"); break;
          case 2: DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " TARGET_NODE_PCI"); break;
          case 3: DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " TARGET_NODE_AGP"); break;
          default:
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " ERROR!"); error_found=TRUE; break;
        }
        temp_var = (U032) *inst_ptr;
        temp_var >>= 20;
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nAdjust=");
        DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (int) temp_var);
        
        temp_var = (U032) *(inst_ptr+1);
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  Limit=");
        DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (int) temp_var);
        
        if(((U032) *(inst_ptr+2)) & 2)
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " RW ");
        else
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " R only ");
          
        temp_var = (U032) *(inst_ptr+2);
        temp_var >>= 12;
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Frame_Addr=");
        DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (int) temp_var);
        
        break;
      default:
        {
          U032 save_offset, DHandle; 
          
          if(!is_software){
            temp_var = (U032) *(inst_ptr+1);
            temp_var >>= 16;
            save_offset = temp_var;
            save_offset <<=4;
            save_offset += (U032) INSTANCE_MEM_SPACE/*nvAddr*/ + (U032) pDev->Pram.HalInfo.PraminOffset;
            
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NOTIFY CONTEXT Handle=");
            if(!temp_var)
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "INVALID(0x0000)");
            else{
              if(!NvWatch_GetObjectFromInst(pDev, temp_var, &DHandle))
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "ERROR: Not found!!!");
              else{  
                DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (int) DHandle);
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  NOTIFY INSTANCE offset=");
                DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (int) save_offset);
              }  
            }  
            
            temp_var = (U032) *(inst_ptr+2);
            temp_var &= 0xFFFF;
            save_offset = temp_var;
            save_offset <<=4;
            save_offset += (U032) INSTANCE_MEM_SPACE/*nvAddr*/ + (U032) pDev->Pram.HalInfo.PraminOffset;
            
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nDMA_CONTEXT0 Handle=");
            if(!temp_var)
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "INVALID(0x0000)");
            else{
              if(!NvWatch_GetObjectFromInst(pDev, temp_var, &DHandle))
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "ERROR: Not found!!!");
              else{  
                DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (int) DHandle);
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  DMA_CONTEXT0 INSTANCE offset=");
                DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (int) save_offset);
              }  
            }  
          
            temp_var = (U032) *(inst_ptr+2);
            temp_var >>= 16;
            save_offset = temp_var;
            save_offset <<=4;
            save_offset += (U032) INSTANCE_MEM_SPACE/*nvAddr*/ + (U032) pDev->Pram.HalInfo.PraminOffset;
            
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nDMA_CONTEXT1 Handle=");
            if(!temp_var)
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "INVALID(0x0000)");
            else{
              if(!NvWatch_GetObjectFromInst(pDev, temp_var, &DHandle))
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "ERROR: Not found!!!");
              else{  
                DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (int) DHandle);
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  DMA_CONTEXT1 INSTANCE offset=");
                DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (int) save_offset);
              }  
            }  
          }  
        }
        break;
    }    
  }
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n");
  return(!error_found);
}


void NvWatch_Dump_HT_Objects(PHWINFO pDev, U032 verbose)
{
 
  U032 object_count;
  //U032 hash_size, object_count;
  U032 object_counter=0; 
  U032 *hash_table_ptr;
  //U032 *hash_table_ptr, *inst_ptr;
  //U032 temp_var, error_found=FALSE,is_a_dmacontext;
  U032 error_found=FALSE;
  
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\nThe MAX number of objects possible is = ", NvWatch_num_objects);
  
  // Start from the beginning of Instance Memory
  hash_table_ptr = (U032 *) (INSTANCE_MEM_SPACE/*nvAddr*/ + ((pDev->Pram.HalInfo.PraminOffset + 0x10000)/4));
  // traverse the HT searching for objects.
  for(object_count=0;object_count<NvWatch_num_objects;object_count++){
    // Get the object entry. Look for a !NULL NV_RAMHT_HANDLE
    if((U032) *(hash_table_ptr+1) != 0){
      if(!NvWatch_Process_Hash_Entry(pDev, hash_table_ptr, verbose))
        error_found = TRUE;
      object_counter++;
    }               
    hash_table_ptr+=2;
  }  
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\nThe total number of objects found is = ", object_counter);
  if(error_found)
   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "ERROR !! ERROR !! BAD Data in the hash table");
  else 
   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "No errors were found parsing the hash table");
  
}

U032 NvWatch_Dump_HT_Object_From_Channel(PHWINFO pDev, U032 channelv)
{

  U032 object_count;
  U032 *hash_table_ptr;
  U032 channel_found=FALSE,error_found=FALSE;
  U032 temp_var;
  
  // Start from the beginning of Instance Memory
  hash_table_ptr = (U032 *) (INSTANCE_MEM_SPACE/*nvAddr*/ + ((pDev->Pram.HalInfo.PraminOffset + 0x10000)/4));
  // traverse the HT searching for objects.
  for(object_count=0;object_count<NvWatch_num_objects;object_count++){
    if((U032) *(hash_table_ptr+1) != 0){
      temp_var = (U032) *(hash_table_ptr+1);
      temp_var >>= 24;
      temp_var &= 0xf;
      if(temp_var == channelv){
        channel_found = TRUE;
        if(!NvWatch_Process_Hash_Entry(pDev, hash_table_ptr, 1)){
          error_found = TRUE;
        }  
      }
    }    
    hash_table_ptr+=2;
  }  

  if(channel_found)
   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Cool ... found an object");
  else 
   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "ERROR: Object with this Channel NOT found\n");
   
  if(error_found){
   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "ERROR !! ERROR !! BAD Data in the hash table");
   return(0);
  }else{ 
   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " No errors were found parsing the hash table");
   if(channel_found)
     return(2);
   else  
     return(1);
  }   
}

U032 NvWatch_Dump_HT_Object_From_Engine(PHWINFO pDev, U032 engine)
{

  U032 object_count;
  U032 *hash_table_ptr;
  U032 engine_found=FALSE,error_found=FALSE;
  U032 temp_var;
  
  // Start from the beginning of Instance Memory
  hash_table_ptr = (U032 *) (INSTANCE_MEM_SPACE/*nvAddr*/ + ((pDev->Pram.HalInfo.PraminOffset + 0x10000)/4));
  // traverse the HT searching for objects.
  for(object_count=0;object_count<NvWatch_num_objects;object_count++){
    if((U032) *(hash_table_ptr+1) != 0){
      temp_var = (U032) *(hash_table_ptr+1);
      temp_var >>= 16;
      temp_var &= 3;
      if(temp_var == engine){
        engine_found = TRUE;
        if(!NvWatch_Process_Hash_Entry(pDev, hash_table_ptr, 1)){
          error_found = TRUE;
        }  
      }
    }    
    hash_table_ptr+=2;
  }  

  if(engine_found)
   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Cool ... found an object");
  else 
   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "ERROR: Object with this engine NOT found\n");
   
  if(error_found){
   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "ERROR !! ERROR !! BAD Data in the hash table");
   return(0);
  }else{ 
   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " No errors were found parsing the hash table");
   if(engine_found)
     return(2);
   else  
     return(1);
  }   
}

U032 NvWatch_Dump_HT_Object_From_Class(PHWINFO pDev, U032 classv)
{

  U032 object_count;
  U032 *hash_table_ptr;
  U032 class_found=FALSE,error_found=FALSE;
  U032 temp_var, *inst_ptr;
  
  // Start from the beginning of Instance Memory
  hash_table_ptr = (U032 *) (INSTANCE_MEM_SPACE/*nvAddr*/ + ((pDev->Pram.HalInfo.PraminOffset + 0x10000)/4));
  // traverse the HT searching for objects.
  for(object_count=0;object_count<NvWatch_num_objects;object_count++){
    if((U032) *(hash_table_ptr+1) != 0){
      temp_var = (U032) *(hash_table_ptr+1);
      temp_var &= 0xFFFF;
      temp_var <<=4;
      temp_var += (U032) INSTANCE_MEM_SPACE/*nvAddr*/ + (U032) pDev->Pram.HalInfo.PraminOffset;
      inst_ptr = (U032 *) temp_var;
      temp_var = (U032) *inst_ptr;
      temp_var &= 0xFFF;
      if(temp_var == classv){
        class_found = TRUE;
        if(!NvWatch_Process_Hash_Entry(pDev, hash_table_ptr, 1)){
          error_found = TRUE;
        }  
      }
    }    
    hash_table_ptr+=2;
  }  

  if(class_found)
   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Cool ... found an object");
  else 
   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "ERROR: Object with this class NOT found\n");
   
  if(error_found){
   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "ERROR !! ERROR !! BAD Data in the hash table");
   return(0);
  }else{ 
   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " No errors were found parsing the hash table");
   if(class_found)
     return(2);
   else  
     return(1);
  }   
}

// Return 0=Error in hash, 1=Object Not found, 2=Success
U032 NvWatch_Dump_HT_Object_From_Handle(PHWINFO pDev, U032 handle)
{

  U032 object_count;
  U032 *hash_table_ptr;
  U032 handle_found=FALSE,error_found=FALSE;
  
  // Start from the beginning of Instance Memory
  hash_table_ptr = (U032 *) (INSTANCE_MEM_SPACE/*nvAddr*/ + ((pDev->Pram.HalInfo.PraminOffset + 0x10000)/4));
  // traverse the HT searching for objects.
  for(object_count=0;object_count<NvWatch_num_objects;object_count++){
    if((U032) *(hash_table_ptr+1) != 0){
      if((U032) *(hash_table_ptr) == handle){
        handle_found = TRUE;
        if(!NvWatch_Process_Hash_Entry(pDev, hash_table_ptr, 1)){
          error_found = TRUE;
        }  
      }
    }    
    hash_table_ptr+=2;
  }  

  if(handle_found)
   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Cool ... found an object");
  else 
   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "ERROR: Object with this handle NOT found\n");
   
  if(error_found){
   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "ERROR !! ERROR !! BAD Data in the hash table");
   return(0);
  }else{ 
   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " No errors were found parsing the hash table");
   if(handle_found)
     return(2);
   else  
     return(1);
  }   
}


U032 NvWatch_Dump_HT_Object_From_Instance(PHWINFO pDev, U032 inst)
{

  U032 object_count, temp_inst;
  U032 *hash_table_ptr;
  U032 inst_found=FALSE,error_found=FALSE;
  
  // Start from the beginning of Instance Memory
  hash_table_ptr = (U032 *) (INSTANCE_MEM_SPACE/*nvAddr*/ + ((pDev->Pram.HalInfo.PraminOffset + 0x10000)/4));
  // traverse the HT searching for objects.
  for(object_count=0;object_count<NvWatch_num_objects;object_count++){
    if((U032) *(hash_table_ptr+1) != 0){
      temp_inst = (U032) *(hash_table_ptr+1);
      temp_inst &= 0xFFFF;
      if(temp_inst == inst){
        inst_found = TRUE;
        if(!NvWatch_Process_Hash_Entry(pDev, hash_table_ptr, 1)){
          error_found = TRUE;
        }  
      }
    }    
    hash_table_ptr+=2;
  }  

  if(inst_found)
   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Cool ... found an object");
  else 
   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "ERROR: Object at this INSTANCE NOT found\n");
   
  if(error_found){
   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "ERROR !! ERROR !! BAD Data in the hash table");
   return(0);
  }else{ 
   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " No errors were found parsing the hash table");
   if(inst_found)
     return(2);
   else  
     return(1);
  }   
}

void NvWatch_Dump_InstanceFifoContext(PHWINFO pDev)
{

    U032 temp_data,channel_counter;
    U032 *ptr_fifocontextarea;

    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n*********************************************");
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nDumping fifo contexts from instance memory\n");
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,   "*********************************************\n");

    // Print the Hash Table size and the Instance Memory size.
    temp_data = REG_RD32(NV_PFIFO_RAMHT);
    temp_data >>= 16;
    temp_data &= 0x3;
    switch(temp_data){
      case 0:
        ptr_fifocontextarea = (U032 *) (INSTANCE_MEM_SPACE/*nvAddr*/ + ( (pDev->Pram.HalInfo.PraminOffset+0x10000+0x1000) /4) );
        break;
      case 1:
        ptr_fifocontextarea = (U032 *) (INSTANCE_MEM_SPACE/*nvAddr*/ + ( (pDev->Pram.HalInfo.PraminOffset+0x10000+0x2000) /4) );
        break;
      case 2:
        ptr_fifocontextarea = (U032 *) (INSTANCE_MEM_SPACE/*nvAddr*/ + ( (pDev->Pram.HalInfo.PraminOffset+0x10000+0x4000) /4) );
        break;
      case 3:
        ptr_fifocontextarea = (U032 *) (INSTANCE_MEM_SPACE/*nvAddr*/ + ( (pDev->Pram.HalInfo.PraminOffset+0x10000+0x8000) /4) );
        break;
    }

    for(channel_counter=0;channel_counter<NUM_FIFOS;channel_counter++){
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Channel ", (int) channel_counter);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  DMA PUT      = ", (int) *(ptr_fifocontextarea+0+(channel_counter*8)));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  DMA GET      = ", (int) *(ptr_fifocontextarea+1+(channel_counter*8)));

        if(IsNV10orBetter(pDev)){
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  Ref Count    = ", (int) *(ptr_fifocontextarea+2+(channel_counter*8)));
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  DMA Instance = ", (int) *(ptr_fifocontextarea+3+(channel_counter*8)));
        }else{
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  DMA Instance = ", (int) *(ptr_fifocontextarea+2+(channel_counter*8)));
        }
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n");
    }
}

void NvWatch_InstanceMem_help(PHWINFO pDev)
{

  U032 temp_data;
  U032 device;
  int i;

  for(i=0;i<MAX_INSTANCE;i++){
      if(pDev == NvDBPtr_Table[i]){
          device=i;
          break;
      }
  }
  
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\nInstance Memory options for device ", device);
  
  // Print the Hash Table size and the Instance Memory size.
  temp_data = REG_RD32(NV_PFIFO_RAMHT);
  temp_data >>= 16;
  temp_data &= 0x3;
  switch(temp_data){
    case 0:
      DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Hash table size is 4K\n\r");
      break;
    case 1:
      DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Hash table size is 8K\n\r");
      break;
    case 2:
      DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Hash table size is 16K\n\r");
      break;
    case 3:
      DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Hash table size is 32K\n\r");
      break;
  } 
  
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nCommands as follows:\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      h   - Dump objects from the Hash table (simple ... just the hash entries)\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      v   - Dump objects (Verbose ... Hash entries and Instance data)\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      o   - Dump Objects by Handle\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      c   - Dump Objects by Class \n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      e   - Dump Objects by Engine\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      n   - Dump Objects by Channel\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      i   - Dump Object by Instance (eg. XXXX)\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      f   - Fifo Context Area\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      q   - quit this\n\r\n\r");
}

VOID NvWatch_Query_InstanceMemory(PHWINFO pDev)
{
  BOOL keep_running=TRUE;
  char in_char;
  char pstring[]="NvWatch InstanceMem";
  
  NvWatch_InstanceMem_help(pDev);
  
  while(keep_running)
  {
    NvWatch_display_prompt(pDev, pstring);
  
    in_char = get_winice_input();
    switch(in_char){
      case 'q':
      case 'Q':
        keep_running = FALSE;
        break;
      case 'f': // Dump hash table
      case 'F': // Dump hash table
        NvWatch_Dump_InstanceFifoContext(pDev);
        break;
      case 'h': // Dump hash table
      case 'H': // Dump hash table
        NvWatch_Dump_HT_Objects(pDev,0);
        break;
      case 'v': // Dump hash table
      case 'V': // Dump hash table
        NvWatch_Dump_HT_Objects(pDev,1);
        break;
      case 'o': // Object dump by handle
      case 'O': // Object dump by handle
        {
          U032 o_handle;
          
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\r\nEnter the handle of the object->");
          NvWatch_GetInputDword(&o_handle);
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n");
          NvWatch_Dump_HT_Object_From_Handle(pDev, o_handle);
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n");
        }  
        break;
      case 'c': // Object dump by class
      case 'C': // Object dump by class
        {
          U032 o_class;
          
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\r\nEnter the class of the object->");
          NvWatch_GetInputDword(&o_class);
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n");
          NvWatch_Dump_HT_Object_From_Class(pDev, o_class);
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n");
        }  
        break;
      case 'e': // Object dump by engine
      case 'E': // Object dump by engine
        {
          U032 o_engine;
          
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\r\nEngine types: Software=0 Graphics=1 DVD=2");
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\r\nEnter the engine type of the object->");
          NvWatch_GetInputDword(&o_engine);
          if((o_engine<0)||(o_engine>2)){
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nERROR: Invalid Engine # entered !");
            break;
          }  
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n");
          NvWatch_Dump_HT_Object_From_Engine(pDev, o_engine);
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n");
        }  
        break;
      case 'n': // Object dump by channel
      case 'N': // Object dump by channel
        {
          U032 o_channel;
          
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\r\nEnter the channel of the objects->");
          NvWatch_GetInputDword(&o_channel);
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n");
          NvWatch_Dump_HT_Object_From_Channel(pDev, o_channel);
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n");
        }  
        break;
      case 'i': // Object dump by instance
      case 'I': // Object dump by instance
        {
          U032 o_inst;
          
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\r\nEnter the instance of the objects->");
          NvWatch_GetInputDword(&o_inst);
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n");
          NvWatch_Dump_HT_Object_From_Instance(pDev, o_inst);
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n");
        }  
        break;
      default: // Help
        NvWatch_InstanceMem_help(pDev);
        break;  
    }
  }
}

//****RM DATA MENU******************************************************************************

void NvWatch_spaceit(U032 level)
{
  U032 i;

  for (i = 0; i < level; i++)
  {
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  ");
  }
}

#define BTREE_OBJS_ONLY 0x2
#define MAX_CLASS_VALUE 0xFFF
RM_STATUS NvWatch_btreeDumpBranch
(
    PNODE Node,
    U032  Level,
    U032  dump_type // bit0=0=Simple bit0=1=Complex bit2=0=ALL bit2=1=Objects(no classes)
)
{
  if (Node)
  {
      //VALIDATE_NODE(Node);
      if (btreeNodeValidate(Node) != RM_OK){
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "ERROR: Btree Node Validation Failed!!");
        return (RM_ERROR);
      }  
      
      NvWatch_btreeDumpBranch(Node->RightBranch, Level + 1, 3);
      //DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM_BTREE: ");
      //for (i = 0; i < Level; i++)
      //{
      //    //DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, ".");
      //    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  ");
      //}
      
      if(dump_type & BTREE_OBJS_ONLY){
        if(Node->Value > MAX_CLASS_VALUE){ 
          //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Node         = ", (U032)Node);
          NvWatch_spaceit(Level);
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,            "Node         = ");
          DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (U032)Node);
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\n");
          
          //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Value        = ", Node->Value);
          NvWatch_spaceit(Level);
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,            "Value        = ");
          DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, Node->Value);
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\n");
          
          //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Left count   = ", Node->LeftCount);
          NvWatch_spaceit(Level);
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,            "Left count   = ");
          DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, Node->LeftCount);
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\n");
          
          //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Right count  = ", Node->RightCount);
          NvWatch_spaceit(Level);
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,            "Right Count  = ");
          DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, Node->RightCount);
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\n");
          
          //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Left branch  = ", (U032)Node->LeftBranch);
          NvWatch_spaceit(Level);
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,            "Left Branch  = ");
          DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (U032)Node->LeftBranch);
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\n");
          
          //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Right branch = ", (U032)Node->RightBranch);
          NvWatch_spaceit(Level);
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,            "Right Branch = ");
          DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (U032)Node->RightBranch);
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\n");
        }  
      }else{    
        //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Node         = ", (U032)Node);
        NvWatch_spaceit(Level);
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,            "Node         = ");
        DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (U032)Node);
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\n");
        
        //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Value        = ", Node->Value);
        NvWatch_spaceit(Level);
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,            "Value        = ");
        DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, Node->Value);
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\n");
        
        //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Left count   = ", Node->LeftCount);
        NvWatch_spaceit(Level);
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,            "Left count   = ");
        DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, Node->LeftCount);
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\n");
        
        //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Right count  = ", Node->RightCount);
        NvWatch_spaceit(Level);
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,            "Right Count  = ");
        DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, Node->RightCount);
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\n");
        
        //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Left branch  = ", (U032)Node->LeftBranch);
        NvWatch_spaceit(Level);
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,            "Left Branch  = ");
        DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (U032)Node->LeftBranch);
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\n");
        
        //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Right branch = ", (U032)Node->RightBranch);
        NvWatch_spaceit(Level);
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,            "Right Branch = ");
        DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (U032)Node->RightBranch);
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\n");
      }    
      NvWatch_btreeDumpBranch(Node->LeftBranch, Level + 1, 3);
  }       
}           
            
void NvWatch_DumpBtreeContents(PHWINFO pDev)
{
  U032 i;
    
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nDumping the BTREE ! ");         

  for(i=0;i<NUM_FIFOS;i++){
  
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\n     Dumping FIFO # ", i);      
    if (pDev->DBfifoTable[i].InUse == FALSE)
      DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Fifo not InUse !\n\r");
    else{  
      if (pDev->DBfifoTable[i].ObjectTree == NULL)
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Fifo InUse but =NULL\n\r");
      else
        NvWatch_btreeDumpBranch(pDev->DBfifoTable[i].ObjectTree, 0, 3);
    } 
  }
} 

void NvWatch_Dump_NvInfo(PHWINFO pDev)
{
  PWIN9XHWINFO pOsHwInfo = (PWIN9XHWINFO) pDev->pOsHwInfo;

  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\r\nNvInfo State Variables:\r\n");

  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\r\npDev->Mapping.nvPhys        ",pDev->Mapping.nvPhys);
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "pDev->Mapping.fbPhys            ",pDev->Mapping.fbPhys);
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "pDev->Mapping.nvIRQ             ",pDev->Mapping.nvIRQ);
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "pDev->Mapping.nvBusDeviceFunc   ",pDev->Mapping.nvBusDeviceFunc);
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "pDev->Mapping.hpicIRQ           ",pDev->Mapping.hpicIRQ);
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "pDev->Mapping.hDev              ",pDev->Mapping.hDev);
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "pDev->Mapping.osDeviceHandle  ",pOsHwInfo->osDeviceHandle);
  
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "pDev->Framebuffer.RamSizeMb   ",pDev->Framebuffer.HalInfo.RamSizeMb);
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "pDev->Framebuffer.RamSize     ",pDev->Framebuffer.HalInfo.RamSize);
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "nvAddr                          ",(int) nvAddr);
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "romAddr                         ",(int) romAddr);
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "fbAddr                          ",(int) fbAddr);
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "pDev->DBagpAddr                 ",(int) pDev->DBagpAddr);
  
}

void NvWatch_DisplayClientInfo(PHWINFO pDev, U032 client_counter, U032 verbose)
{
  U032 device_counter, fifo_counter;
  PCLI_DMA_INFO dmalist_ptr;
  
  if(clientInfo[client_counter].InUse == TRUE){
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Client found at index = ",client_counter);
     DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  Handle        = ",clientInfo[client_counter].Handle);
     if(verbose){
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  Class         = ",clientInfo[client_counter].Class);
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  InUse         = ",clientInfo[client_counter].InUse);
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  AppID         = ",clientInfo[client_counter].AppID);
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  ProcID        = ",clientInfo[client_counter].ProcID);
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  ProcContext   = ",clientInfo[client_counter].ProcContext);
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  FifoCount     = ",clientInfo[client_counter].FifoCount);
     }
     DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  CliDmaList    = ",(int) clientInfo[client_counter].CliDmaList);
     DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  CliDeviceList = ",(int) clientInfo[client_counter].CliDeviceList);
     DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  CliMemoryList = ",(int) clientInfo[client_counter].CliMemoryList);
     DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n\r");
    
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  Traversing DMA Context List ...\n");
    dmalist_ptr = clientInfo[client_counter].CliDmaList;
    while(dmalist_ptr){
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  DMA Context Found\n");
     DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    Handle       = ",dmalist_ptr->Handle);
     if(verbose){
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    Client       = ",dmalist_ptr->Client);
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    Class        = ",dmalist_ptr->Class);
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    Flags        = ",dmalist_ptr->Flags);
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    Access       = ",dmalist_ptr->Access);
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    Physicality  = ",dmalist_ptr->Physicality);
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    Locked       = ",dmalist_ptr->Locked);
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    Coherency    = ",dmalist_ptr->Coherency);
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    Valid        = ",dmalist_ptr->Valid);
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    DescSelector = ",dmalist_ptr->DescSelector);  
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    DescOffset   = ",(int) dmalist_ptr->DescOffset);      
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    DescLimit    = ",dmalist_ptr->DescLimit);   
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    DescAddr     = ",(int) dmalist_ptr->DescAddr);    
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    BufferBase   = ",(int) dmalist_ptr->BufferBase);
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    BufferSize   = ",dmalist_ptr->BufferSize);
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    LockHandle   = ",(int) dmalist_ptr->LockHandle);
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    PteCount     = ",dmalist_ptr->PteCount);
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    PteAdjust    = ",dmalist_ptr->PteAdjust);   
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    PteLimit     = ",dmalist_ptr->PteLimit);    
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    PteArray     = ",(int) dmalist_ptr->PteArray);
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    Next         = ",(int) dmalist_ptr->Next);
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    Prev         = ",(int) dmalist_ptr->Prev);
     }
     DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    AddressSpace = ",dmalist_ptr->AddressSpace);
    dmalist_ptr = dmalist_ptr->Next;
    }
    
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  \nTraversing DeviceList ...\n");
    for(device_counter=0;device_counter<NUM_DEVICES;device_counter++){
      if(clientInfo[client_counter].CliDeviceList[device_counter].InUse == TRUE){
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  Device in use found = ",device_counter);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    Handle        = ",clientInfo[client_counter].CliDeviceList[device_counter].Handle);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    Client        = ",clientInfo[client_counter].CliDeviceList[device_counter].Client);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    Class         = ",clientInfo[client_counter].CliDeviceList[device_counter].Class);
        if(verbose){
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    InUse         = ",clientInfo[client_counter].CliDeviceList[device_counter].InUse);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    AppID         = ",clientInfo[client_counter].CliDeviceList[device_counter].AppID);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    DevID         = ",clientInfo[client_counter].CliDeviceList[device_counter].DevID);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    DevFifoList   = ",(int)clientInfo[client_counter].CliDeviceList[device_counter].DevFifoList);  
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    DevMemoryList = ",(int)clientInfo[client_counter].CliDeviceList[device_counter].DevMemoryList);
        }
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n    Traversing Fifolist for this device ...\n");
        for(fifo_counter=0;fifo_counter<NUM_FIFOS;fifo_counter++){
          if(clientInfo[client_counter].CliDeviceList[device_counter].DevFifoList[fifo_counter].InUse == TRUE){
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "     Fifo in use found = ",fifo_counter);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "         Handle           = ",clientInfo[client_counter].CliDeviceList[device_counter].DevFifoList[fifo_counter].Handle);           
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "         Device           = ",clientInfo[client_counter].CliDeviceList[device_counter].DevFifoList[fifo_counter].Device);           
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "         Class            = ",clientInfo[client_counter].CliDeviceList[device_counter].DevFifoList[fifo_counter].Class);            
            if(verbose){
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "         ErrorDmaContext  = ",clientInfo[client_counter].CliDeviceList[device_counter].DevFifoList[fifo_counter].ErrorDmaContext); 
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "         DataDmaContext   = ",clientInfo[client_counter].CliDeviceList[device_counter].DevFifoList[fifo_counter].DataDmaContext);   
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "         FifoPtr          = ",(int) clientInfo[client_counter].CliDeviceList[device_counter].DevFifoList[fifo_counter].FifoPtr);      
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "         DevID            = ",clientInfo[client_counter].CliDeviceList[device_counter].DevFifoList[fifo_counter].DevID);            
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "         InUse            = ",clientInfo[client_counter].CliDeviceList[device_counter].DevFifoList[fifo_counter].InUse);            
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "         ChID             = ",clientInfo[client_counter].CliDeviceList[device_counter].DevFifoList[fifo_counter].ChID);             
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "         AppID            = ",clientInfo[client_counter].CliDeviceList[device_counter].DevFifoList[fifo_counter].AppID);            
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "         Selector         = ",clientInfo[client_counter].CliDeviceList[device_counter].DevFifoList[fifo_counter].Selector);         
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "         Flat             = ",(int) clientInfo[client_counter].CliDeviceList[device_counter].DevFifoList[fifo_counter].Flat);             
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "         heventWait       = ",clientInfo[client_counter].CliDeviceList[device_counter].DevFifoList[fifo_counter].heventWait);       
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "         hwndNotify       = ",clientInfo[client_counter].CliDeviceList[device_counter].DevFifoList[fifo_counter].hwndNotify);       
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "         hwndError        = ",clientInfo[client_counter].CliDeviceList[device_counter].DevFifoList[fifo_counter].hwndError);        
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "         msgNotify        = ",clientInfo[client_counter].CliDeviceList[device_counter].DevFifoList[fifo_counter].msgNotify);        
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "         msgError         = ",clientInfo[client_counter].CliDeviceList[device_counter].DevFifoList[fifo_counter].msgError);         
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "         lpSysCallback    = ",(int) clientInfo[client_counter].CliDeviceList[device_counter].DevFifoList[fifo_counter].lpSysCallback);    
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "         eventNotify      = ",clientInfo[client_counter].CliDeviceList[device_counter].DevFifoList[fifo_counter].eventNotify);  
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "         pDmaObject       = ",(int) clientInfo[client_counter].CliDeviceList[device_counter].DevFifoList[fifo_counter].pDmaObject);       
            }
          }
        }  
      }  
    }
  }
}

void NvWatch_Dump_ClientInfo(PHWINFO pDev, U032 client_num, U032 verbose)
{
  int client_counter;
  

  if(client_num == 0xffffffff){
      DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n\r");
      for(client_counter=0;client_counter<NUM_CLIENTS;client_counter++){
        NvWatch_DisplayClientInfo(pDev, client_counter, verbose);
      }
  }else{
      DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n\r");
      NvWatch_DisplayClientInfo(pDev, client_num, verbose);
  }

}

void NvWatch_DumpGrTableContents(PHWINFO pDev, U032 verbose_flag)
{
  
  if(IsNV10orBetter(pDev)){
      NvWatch_NV10_DumpGrTableContents(pDev, verbose_flag);
  }else{
      NvWatch_NV04_DumpGrTableContents(pDev, verbose_flag);
  }
}

void NvWatch_DumpRegistryStrings(PHWINFO pDev)
{
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n\r\n\rGlobal Path = ");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, strRegistryGlobalParameters);
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Device Path = ");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, pDev->Registry.DBstrDevNodeDisplay);
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n\r\n\r");
}
void NvWatch_RM_help(void)
{
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Resource Manager Internal Data Structures\n\r\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Commands as follows:\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      i   - Dump NvInfo data\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      c   - Dump Client data\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      d   - Dump Client data (VERBOSE)\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      b   - Dump BTREE Contents\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      r   - Dump Registry Path Info\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      g   - Dump Graphics Contexts\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      v   - Dump Graphics Contexts (VERBOSE)\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      m   - CPU MTRR Registers (use n option for R/W)\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      n   - CPU MSR Registers R/W\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      o   - CPU CR0 R/W\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      q   - quit\n\r\n\r");
}

#define CPUID   __asm _emit 0x0F __asm _emit 0xA2
#define RDMSR   __asm _emit 0x0F __asm _emit 0x32
#define WRMSR   __asm _emit 0x0F __asm _emit 0x30
VOID NvWatch_MTRR_RegisterStuff(void)
{
    U032 mtrrAddr, numRanges = 0;
    U032 BaseHi, BaseLo, MaskHi, MaskLo;
    U032 i;

    CLI
    __asm
    {
        ; save state
        push    eax
        push    ebx
        push    ecx
        push    edx

        pushfd
        pop     eax
        mov     ebx, eax
        xor     eax, 0x00200000
        push    eax
        popfd
        pushfd
        pop     eax
        cmp     eax, ebx
        je      Exit                // CPUID inst not supported

        mov     eax, 1
        CPUID
        and     edx, 0x1000         // check for MTRR support
        jz      Exit

        mov     ecx, 254            // read the MTRRcap MSR to determine number of ranges.
        RDMSR
        test    eax, 0x400          // check that WC as a type is supported (should be 1).
        jz      Exit

        and     eax, 0xFF           // save number of ranges
        mov     numRanges, eax
Exit:    
        pop     edx
        pop     ecx
        pop     ebx
        pop     eax
    }

    // Now determine if we find a Write Combined match in the MTRRs
    for (i = 0, mtrrAddr = 512; i < numRanges; i++, mtrrAddr += 2)
    {
        __asm {

            push    eax
            push    ebx
            push    ecx
            push    edx

            mov     ecx, mtrrAddr
            RDMSR

            mov     BaseHi, edx
            mov     BaseLo, eax

            mov     ecx, mtrrAddr
            add     ecx, 1
            RDMSR

            mov     MaskHi, edx
            mov     MaskLo, eax

            pop     edx
            pop     ecx
            pop     ebx
            pop     eax
        }

        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: MTRR ", i);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM:      Base ", BaseLo);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM:      Mask ", MaskLo);

        /////if (!(MaskLo & 0x800))
        /////   continue;               // not a valid range
        /////MaskLo &= ~0xFFF;          // mask off the valid bit
        /////
        /////if ((BaseLo & 0xFF) != 0x1)
        /////   continue;               // not a Write Combined range
        /////BaseLo &= ~0xFF;           // mask off the type bits
        /////
        /////if ((BaseLo >= AGPBase) && ((BaseLo + ~MaskLo) < (AGPBase + AGPSize)))
        /////   pDev->Mapping.AGPLimit = ~MaskLo;  // the WC MTRR is within the aperture
    }

    STI
}

#define MAX_MSR_REGISTER 0x413

NvU64 NvWatch_MSRREAD(U032 reg_num)
{
    NvU64 return_val={0xFFFFFFFF,0xFFFFFFFF};

    if(reg_num > MAX_MSR_REGISTER){
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nERROR!: This offset exceeds the maximun MSR Register.");
        return return_val;
    }

    CLI
    __asm
    {
        ; save state
        push    eax
        push    ebx
        push    ecx
        push    edx

        pushfd
        pop     eax
        mov     ebx, eax
        xor     eax, 0x00200000
        push    eax
        popfd
        pushfd
        pop     eax
        cmp     eax, ebx
        je      Exit                // CPUID inst not supported

        mov     eax, 1
        CPUID
        and     edx, 0x1000         // check for MTRR support
        jz      Exit

        mov     ecx, reg_num         // read the MTRRcap MSR to determine number of ranges.
        RDMSR
        mov     return_val.low,eax
        mov     return_val.high,edx

Exit:    
        pop     edx
        pop     ecx
        pop     ebx
        pop     eax
    }
    STI
    return return_val;
}

NvU64 NvWatch_MSRWRITE(U032 reg_num, NvU64 data)
{
    NvU64 return_val={0xFFFFFFFF,0xFFFFFFFF};

    if(reg_num > MAX_MSR_REGISTER){
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nERROR!: This offset exceeds the maximun MSR Register.");
        return return_val;
    }

    CLI
    __asm
    {
        ; save state
        push    eax
        push    ebx
        push    ecx
        push    edx

        pushfd
        pop     eax
        mov     ebx, eax
        xor     eax, 0x00200000
        push    eax
        popfd
        pushfd
        pop     eax
        cmp     eax, ebx
        je      Exit                // CPUID inst not supported

        mov     eax, 1
        CPUID
        and     edx, 0x1000         // check for MTRR support
        jz      Exit

        mov     ecx, reg_num         // read the MTRRcap MSR to determine number of ranges.
        mov     eax,data.low
        mov     edx,data.high
        WBINVD
        WRMSR

Exit:    
        pop     edx
        pop     ecx
        pop     ebx
        pop     eax
    }
    STI
    return return_val;
}

int NvWatch_MSR_Registers()
{
    char instring[]="00000000";
    DWORD ddata=0, ddata2=0, daddr=0, save_offset;
    NvU64 msr_data;

    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  \nEnter the Offset of the MSR Register to query.");
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  \n->");

    if(!NvWatch_GetInputDword(&daddr)){
      DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  Error: Abort action");
      return(0);
    }  
    save_offset = daddr; 

    msr_data = NvWatch_MSRREAD(daddr);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\nThe low 32 bits read are ", (int) msr_data.low);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "The high 32 bits read are ", (int) msr_data.high);

    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nEnter the new value for the low 32 bits ->");
    
    if(!NvWatch_GetInputDword(&ddata)){
      DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  Error: Abort action");
      return(0);
    }  
    
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nEnter the new value for the high 32 bits ->");
    
    if(!NvWatch_GetInputDword(&ddata2)){
      DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  Error: Abort action");
      return(0);
    }  

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\nThe low 32 bits to write are ", (int) ddata);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "The high 32 bits to write are ", (int) ddata2);
    msr_data.low = ddata;
    msr_data.high = ddata2;
    NvWatch_MSRWRITE(daddr, msr_data);
}

int NvWatch_CR0_Control()
{
    U032 ddata=0,cr0_save;
    _asm{
        mov  eax,cr0
        mov  cr0_save,eax 
    }
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\nThe value of CR0 is ", (int) cr0_save);
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nEnter a new value for CR0 ->");

    if(!NvWatch_GetInputDword(&ddata)){
      DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  Error: Abort action");
      return(0);
    }  

    _asm{
        mov  eax,ddata
        WBINVD
        mov  cr0,eax 
    }
    _asm{
        mov  eax,cr0
        mov  cr0_save,eax 
    }
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\nThe new value of CR0 is ", (int) cr0_save);
}

void NvWatch_heapDump
(
    PHEAP heap
)
{
    U032      i;
    U032      free;
    PMEMBLOCK block;

    if (!heap) return;
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"\nHeap dump.  Size = ", heap->total);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,  "            Free = ", heap->free);
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"=================================================================\r\n");
    for (i = 0; i < heap->numBanks; i++)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"Bank: ", i);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"\tType flags = ", heap->Bank[i].flags);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"\tOffset     = ", heap->Bank[i].offset);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"\tSize       = ", heap->Bank[i].size);
    }
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"Block List Forward:\r\n");
    block = heap->pBlockList;
    do
    {
        if (block->owner == FREE_BLOCK)
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\tOwner = FREE\r\n");
        else
        {
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"\tOwner = ", block->owner);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"\tType  = ", block->u0.type);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"\tHwres = ", block->u1.hwres);
        }
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"\t\tBegin = ", block->begin);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"\t\tEnd   = ", block->end);
        block = block->next;
    } while (block != heap->pBlockList);
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"Block List Reverse:\r\n");
    block = heap->pBlockList;
    do
    {
        block = block->prev;
        if (block->owner == FREE_BLOCK)
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\tOwner = FREE\r\n");
        else
        {
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"\tOwner = ", block->owner);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"\tType  = ", block->u0.type);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"\tHwres  = ", block->u1.hwres);
        }
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"\t\tBegin = ", block->begin);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"\t\tEnd   = ", block->end);
    } while (block != heap->pBlockList);
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"FREE Block List Forward:\r\n");
    free  = 0;
    if ((block = heap->pFreeBlockList))
        do
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\tOwner = FREE\r\n");
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"\t\tBegin = ", block->begin);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"\t\tEnd   = ", block->end);
            free += block->end - block->begin + 1;
            block = block->u1.nextFree;
        } while (block != heap->pFreeBlockList);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"\tCalculated free count = ", free);
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"FREE Block List Reverse:\r\n");
    free  = 0;
    if ((block = heap->pFreeBlockList))
        do
        {
            block = block->u0.prevFree;
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\tOwner = FREE\r\n");
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"\t\tBegin = ", block->begin);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"\t\tEnd   = ", block->end);
            free += block->end - block->begin + 1;
        } while (block != heap->pFreeBlockList);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"\tCalculated free count = ", free);

    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\n\nKey to Types");
	DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\nMEM_FLAG_IMAGE       = 0x00000001");
	DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\nMEM_FLAG_DEPTH       = 0x00000002");
	DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\nMEM_FLAG_TEXTURE     = 0x00000004");
	DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\nMEM_FLAG_OVERLAY     = 0x00000008");
	DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\nMEM_FLAG_FONT        = 0x00000010");
	DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\nMEM_FLAG_CURSOR      = 0x00000020");
	DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\nMEM_FLAG_DMA         = 0x00000040");
	DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\nMEM_FLAG_INSTANCE    = 0x00000080");
	DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\nMEM_FLAG_PRIMARY     = 0x00000100");
	DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\nMEM_FLAG_IMAGE_TILED = 0x00000200");
}

int NvWatch_RMData(PHWINFO pDev)
{
  BOOL keep_running=TRUE;
  char in_char;
  char pstring[]="NvWatch Resource Manager Data Structure Info";
 
  NvWatch_RM_help();
  
  while(keep_running)
  {
    NvWatch_display_prompt(pDev, pstring);
  
    in_char = get_winice_input();
    switch(in_char){
      case 'q':
      case 'Q':
        keep_running = FALSE;
        break;
      case 'i': // NvInfo Data
      case 'I': // NvInfo Data
        NvWatch_Dump_NvInfo(pDev);
        break;
      case 'c': // Client Data       
      case 'C': // Client Data       
        NvWatch_Dump_ClientInfo(pDev,0xFFFFFFFF,0);
        break;
      case 'd': // Client Data       
      case 'D': // Client Data       
        NvWatch_Dump_ClientInfo(pDev,0xFFFFFFFF,1);
        break;
      case 'b': // Btree Dump
      case 'B': // Btree Dump
        NvWatch_DumpBtreeContents(pDev);
        break;
      case 'r': // Btree Dump
      case 'R': // Btree Dump
        NvWatch_DumpRegistryStrings(pDev);
        break;
      case 'g': // grTable Dump
      case 'G': // grTable Dump
        NvWatch_DumpGrTableContents(pDev, NVWATCH_SIMPLE);
        break;
      case 'v': // grTable Dump
      case 'V': // grTable Dump
        NvWatch_DumpGrTableContents(pDev, NVWATCH_COMPLEX);
        break;
	  case 'h': // heap Dump
	  case 'H': // heap Dump
		NvWatch_heapDump((PHEAP)pDev->Framebuffer.HeapHandle);
		break;
      case 'm': // MTRR Stuff
      case 'M': // 
        NvWatch_MTRR_RegisterStuff();
        break;
      case 'n': // MTRR Stuff
      case 'N': // 
        NvWatch_MSR_Registers();
        break;
      case 'o': // MTRR Stuff
      case 'O': // 
        NvWatch_CR0_Control();
        break;
      default: // Help
        NvWatch_RM_help();
        break;  
    }
  }

    return (RM_OK);
}

RM_STATUS NvWatch_osAllocMem
(
    VOID **pAddress,
    U032   Size
)
{
    RM_STATUS status;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_osAllocMem. Enter *pAddress =",(int) *pAddress);

    {
        DESCRIPTOR desc;
        U032       nvwatch_nPages;
        U032       nvwatch_pType=PG_SYS;
        U032       nvwatch_VM=0;
        U032       nvwatch_AlignMask;
        U032       nvwatch_minPhys=0;
        U032       nvwatch_maxPhys=0;
        U032       nvwatch_PhysAddr=0;
        //U032       nvwatch_flags=0;
        U032       nvwatch_flags=(PAGECONTIG|PAGEFIXED);
        //U032       nvwatch_flags=(PAGECONTIG|PAGEFIXED|PAGEUSEALIGN);

        nvwatch_nPages    = Size >> 12;
        // Align on size boundary.
        nvwatch_AlignMask = 0;
        //nvwatch_AlignMask = Size;
        
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_osAllocMem. nvwatch_nPages =",(int) nvwatch_nPages);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_osAllocMem. nvwatch_AlignMask =",(int) nvwatch_AlignMask);
        vmmPageAllocate(
                nvwatch_nPages, 
                nvwatch_pType, 
                nvwatch_VM, 
                nvwatch_AlignMask, 
                nvwatch_minPhys, 
                nvwatch_maxPhys, 
                nvwatch_PhysAddr, 
                nvwatch_flags, 
                &desc.Desc64);
        *pAddress = (VOID *)desc.Desc32[0];
    }
//////  from osallocpages.
//////  vmmPageAllocate(PageCount, PG_SYS, 0, 0, 0, 0, 0, 0, &desc.Desc64);
//////  *pAddress = (VOID *)desc.Desc32[0];

    if (*pAddress != NULL)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_osAllocMem. Exit *pAddress =",(int) *pAddress);
        status = RM_OK;
    }
    else
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_osAllocMem. ERROR ! *pAddress =",(int) *pAddress);
        status = RM_ERR_NO_FREE_MEM;
    }
    return (status);
}

RM_STATUS NvWatch_osFreeMem
(
    VOID *pAddress
)
{
    RM_STATUS status;


    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_osFreeMem. pAddress =",(int) pAddress);
    if(!pAddress)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_osFreeMem. pAddress is Invalid=",(int) pAddress);
        return (RM_OK);
    }    

    {
         U032 nvwatch_hMem;
         U032 nvwatch_flags=0;

         nvwatch_hMem = (U032)pAddress;
         if (!vmmPageFree(nvwatch_hMem, 0)){
             status = RM_ERROR;
         }
         else{
             status = RM_OK;
         }
    }
    return (status);
}


U032 NvWatch_Crush11_MemFree_Block(PHWINFO pDev, U032 block_index)
{
    int i;

    if(nvwatch_block_buffers[block_index] == NULL){
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_MemFree_Blocks. Block entry is NULL. block_index=",(int)block_index);
                nvwatch_crush11_failed_data = block_index;
                return(RM_ERROR);
    }
    if(NvWatch_osFreeMem((VOID *)nvwatch_block_buffers[block_index]) != RM_OK){
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_MemFree_Blocks. osFreeMem Failed! block_index=",(int)block_index);
                nvwatch_crush11_failed_data = block_index;
                return(RM_ERROR);
    }else{
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_MemFree_Blocks. osFreeMem SUCCESS! block_index=",(int)block_index);
        nvwatch_block_buffers[block_index] == NULL;
        for(i=0;i<NVWATCH_MAX_PAGES_PER_BLOCK;i++){
                nvwatch_PageArray[block_index][i];
        }
    }

    return(RM_OK);
}

U032 NvWatch_Crush11_UnLock_Block(PHWINFO pDev, U032 bsize, U032 block_index)
{
    U032 PageBase, LinAddr, PageCount, status;
    
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_UnLock_Blocks. block_index=",(int)block_index);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_UnLock_Blocks. bsize=",(int)bsize);
    if(nvwatch_block_buffers[block_index] == NULL){
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_UnLock_Blocks Block NOT allocated",(int)block_index);
        nvwatch_crush11_failed_data = block_index;
        return(RM_ERROR);
    }
    
    LinAddr = (U032) nvwatch_block_buffers[block_index];
    PageBase = LinAddr >> PAGESHIFT;
    PageCount = bsize >> PAGESHIFT;
    
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_UnLock_Block Linear Address=",(int) LinAddr);
    
    status = !vmmLinPageUnLock(PageBase, PageCount, PAGEMAPGLOBAL) ? RM_ERR_DMA_MEM_NOT_UNLOCKED : RM_OK;
    if(status != RM_OK){
        nvwatch_crush11_failed_data = block_index;
    }

    return(status);

}

U032 NvWatch_Crush11_Lock_Block(PHWINFO pDev, U032 bsize, U032 block_index)
{

    U032 PageBase, LinAddr, PageCount;
    U032 LinAddr_save;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_Lock_Blocks. block_index=",(int)block_index);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_Lock_Blocks. bsize=",(int)bsize);

    LinAddr = (U032) nvwatch_block_buffers[block_index];
    LinAddr_save = (U032) LinAddr;
    PageBase = LinAddr >> PAGESHIFT;
    PageCount = bsize >> PAGESHIFT;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_Lock_Block Linear Address=",(int) LinAddr);
    
    LinAddr = (U032)vmmLinPageLock(PageBase, PageCount, PAGEMAPGLOBAL);
    
    if (!LinAddr)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_Lock_Block Unable to lock pages. Block=",(int) block_index);
        nvwatch_crush11_failed_data = block_index;
        return (RM_ERR_DMA_MEM_NOT_LOCKED);
    }
    if (!vmmCopyPageTable(LinAddr >> PAGESHIFT, PageCount, (U032)&nvwatch_PageArray[block_index][0], 0))
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_Lock_Block Unable to copy page table. Block=",(int) block_index);
        nvwatch_crush11_failed_data = block_index;
        return (RM_ERR_PAGE_TABLE_NOT_AVAIL);
    }
    LinAddr += (LinAddr_save & 0xFFF);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_Lock_Block New Linear Address=",(int) LinAddr);
    nvwatch_block_buffers[block_index] = (void *) LinAddr;
    return(RM_OK);
}

U032 NvWatch_Crush11_Unlock_and_Free_Block(PHWINFO pDev, U032 bsize, U032 block_index)
{
    int status=RM_OK;

    if(NvWatch_Crush11_UnLock_Block(pDev, bsize, block_index) != RM_OK){
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_Unlock_and_Free_Block UnLocking FAILED ! Block=",(int)block_index);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_Unlock_and_Free_Block Try to free it anyway. Block=",(int)block_index);
        nvwatch_crush11_failed_data = block_index;
        status=RM_ERROR;
    }else{
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_Unlock_and_Free_Block UnLocking SUCCESS ! Block=",(int)block_index);
    }

    if(NvWatch_Crush11_MemFree_Block(pDev, block_index)!=RM_OK){
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_Unlock_and_Free_Block Freeing FAILED ! Block=",(int)block_index);
        nvwatch_crush11_failed_data = block_index;
        status=RM_ERROR;
    }else{
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_Unlock_and_Free_Block Freeing SUCCESS ! Block=",(int)block_index);
    }

    return(status);
}

U032 NvWatch_Crush11_Allocate_and_Lock_Block(PHWINFO pDev, U032 bsize, U032 block_index)
{

    if(osAllocMem((VOID **)&nvwatch_block_buffers[block_index], bsize) != RM_OK){
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_Allocate_and_Lock_Block Alloc FAILED ! Block=",(int)block_index);
        nvwatch_crush11_failed_data = block_index;
        return(RM_ERROR);
    }else{
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_Allocate_and_Lock_Block Alloc SUCCESS ! Block=",(int)block_index);
        if(NvWatch_Crush11_Lock_Block(pDev, bsize, block_index) != RM_OK){
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_Allocate_and_Lock_Block Locking FAILED ! Block=",(int)block_index);
            if(NvWatch_Crush11_MemFree_Block(pDev, block_index) != RM_OK){
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_Allocate_and_Lock_Block Freeing the block FAILED also ! Block=",(int)block_index);
            }
            nvwatch_crush11_failed_data = block_index;
            return(RM_ERROR);
        }else{
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_Allocate_and_Lock_Block Locking SUCCESS ! Block=",(int)block_index);
            return(RM_OK);
        }
    }
    return(RM_OK);
}

U032 NvWatch_Crush11_Allocate_Blocks(PHWINFO pDev, U032 bsize, U032 num_blocks)
{
    U032 i;
    int status;

    for(i=0;i<num_blocks;i++){
        if(NvWatch_osAllocMem((VOID **)&nvwatch_block_buffers[i], bsize) != RM_OK){
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_Allocate_Blocks Alloc FAILED ! Block=",(int)i);
            nvwatch_crush11_failed_data = i;
            status=RM_ERROR;
            break;
        }else{
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_Allocate_Blocks Alloc SUCCESS ! Block=",(int)i);
            status=RM_OK;
        }
    }
//////    for(i=0;i<num_blocks;i++){
//////        if(NvWatch_Crush11_Allocate_and_Lock_Block(pDev, bsize, i)!=RM_OK){
//////            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_Allocate_Blocks FAILED. num_blocks=",(int)num_blocks);
//////          nvwatch_crush11_failed_data = i;
//////            return(RM_ERROR);
//////        }
//////    }
    return(status);

}

U032 NvWatch_Crush11_Free_Blocks(PHWINFO pDev, U032 bsize, U032 num_blocks)
{
    U032 i;
    int status;

    for(i=0;i<num_blocks;i++){
        if(NvWatch_Crush11_MemFree_Block(pDev, i)!=RM_OK){
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_Unlock_and_Free_Block Freeing FAILED ! Block=",(int)i);
            nvwatch_crush11_failed_data = i;
            status=RM_ERROR;
            break;
        }else{
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_Unlock_and_Free_Block Freeing SUCCESS ! Block=",(int)i);
            status=RM_OK;
        }
    }
//////    for(i=0;i<num_blocks;i++){
//////        if(NvWatch_Crush11_Unlock_and_Free_Block(pDev, bsize, i)!=RM_OK){
//////            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_Free_Blocks FAILED. num_blocks=",(int)num_blocks);
//////          nvwatch_crush11_failed_data = i;
//////            return(RM_ERROR);
//////        }
//////    }
    return(status);
}

U032 NvWatch_Crush11_Allocate_and_Free_Blocks(PHWINFO pDev, U032 bsize, U032 num_blocks)
{
    int ret_val1,ret_val2;

    if((ret_val1=NvWatch_Crush11_Allocate_Blocks(pDev, bsize, num_blocks))!=RM_OK){
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_Allocate_and_Free_Blocks FAILED. Failed block=",(int)ret_val1);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_Allocate_and_Free_Blocks. Freeing all allocations",(int)ret_val1);
        if((ret_val2=NvWatch_Crush11_Free_Blocks(pDev, bsize, ret_val1))!=RM_OK){
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_Allocate_and_Free_Blocks. Failure Freeing after alloc failure. Free failure block=",(int)ret_val2);
        }
        return(ret_val1);
    }
    if(NvWatch_Crush11_Free_Blocks(pDev, bsize, num_blocks)!=RM_OK){
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_Allocate_and_Free_Blocks FAILED. num_blocks=",(int)num_blocks);
        return(RM_ERROR);
    }
    return(num_blocks);
}

void NvWatch_Crush11_Buffer_Entry_Dump(PHWINFO pDev, U032 buffer_index, U032 verbose)
{
    int i;

    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n");
    for(i=0;i<20;i++){
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_Memory_Page_Dump=",(int) nvwatch_block_buffers[i]);
    }
}

void NvWatch_Crush11_Memory_Page_Dump(PHWINFO pDev, U032 buffer_index, U032 verbose)
{
    int i;

    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n");
    for(i=0;i<20;i++){
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_Memory_Page_Dump=",(int) nvwatch_PageArray[buffer_index][i]);
    }
}

void NvWatch_Crush11_Memory_Page_Info(PHWINFO pDev, U032 buffer_index, U032 page_index, U032 verbose)
{

}

void NvWatch_Crush11_Tests_help(void)
{
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Crush11 Tests \n\r\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Commands as follows:\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      a   - Allocate blocks of memory.\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      f   - Free blocks of memory.\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      t   - Allocate available blocks until failure.\n\r");
//  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      f   - Free all allocated blocks.\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      x   - Allocate a number of blocks. (includes freeing of blocks)\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      i   - Page Info on allocated blocks.\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      b   - Block Info on allocated blocks.\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      q   - quit\n\r\n\r");
}

void NvWatch_Crush11_Tests(PHWINFO pDev)
{
  BOOL keep_running=TRUE;
  char in_char;
  char pstring[]="NvWatch_CrushTests";
  static U032 bsize=0x10000;
  U032 num_buffers=0;
  
  NvWatch_Crush11_Tests_help();
  
  while(keep_running)
  {
    NvWatch_display_prompt(pDev, pstring);
  
    in_char = get_winice_input();
    switch(in_char){
      case 'q':
      case 'Q':
        keep_running = FALSE;
        break;

      case 'i': // NvInfo Data
      case 'I': // NvInfo Data
          {
              NvWatch_Crush11_Memory_Page_Dump(pDev, 0, 0);
          }
          break;
      case 'b': // NvInfo Data
      case 'B': // NvInfo Data
          {
            NvWatch_Crush11_Buffer_Entry_Dump(pDev, 0, 0);
          }
          break;
      case 'a': // NvInfo Data
      case 'A': // NvInfo Data
          {
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  \nEnter the number of the buffers to allocate. (hex bytes)");
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  \n->");
              if(!NvWatch_GetInputDword(&num_buffers)){
                  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  Error: Abort action");
                  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n\n Setting number of buffers to 0");
                  num_buffers = 0;
              }else{
                  if(num_buffers > NVWATCH_MAX_MEM_BLOCKS){
                      DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n\n Buffer number too high");
                      DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\n\n Setting to max buffer number of ",(int) NVWATCH_MAX_MEM_BLOCKS);
                      num_buffers = NVWATCH_MAX_MEM_BLOCKS;
                  }else{
                      DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n***Allocating ");
                      DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (U032) num_buffers);
                      DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " ");
                      DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (U032) bsize);
                      DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " byte buffers*** \n\n");
                  }
                  {
                      U032 max_block;

                      if(NvWatch_Crush11_Allocate_Blocks(pDev, bsize, num_buffers)!=RM_OK){
                          max_block=nvwatch_crush11_failed_data-1;
                      }else{
                          max_block=num_buffers;
                      }

                      if(max_block==num_buffers){
                          DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\nAllocation Successful ! Total memory locked was ", (int) (num_buffers*bsize));
                      }else{
                          DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\nAllocation Failure ! Total memory requested was ", (int) (num_buffers*bsize));
                          DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\nTotal memory locked was ", (int) (max_block*bsize));
                      }
                  }
              }
          }
          break;
      case 'f': // NvInfo Data
      case 'F': // NvInfo Data
            {
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  \nEnter the number of the buffers to allocate. (hex bytes)");
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  \n->");
                if(!NvWatch_GetInputDword(&num_buffers)){
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  Error: Abort action");
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n\n Setting number of buffers to 0");
                    num_buffers = 0;
                }else{
                    if(num_buffers > NVWATCH_MAX_MEM_BLOCKS){
                        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n\n Buffer number too high");
                        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\n\n Setting to max buffer number of ",(int) NVWATCH_MAX_MEM_BLOCKS);
                        num_buffers = NVWATCH_MAX_MEM_BLOCKS;
                    }else{
                        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n***Freeing ");
                        DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (U032) num_buffers);
                        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " ");
                        DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (U032) bsize);
                        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " byte buffers*** \n\n");
                    }
                    {
                        U032 max_block;

                        if(NvWatch_Crush11_Free_Blocks(pDev, bsize, num_buffers)!=RM_OK){
                            max_block=nvwatch_crush11_failed_data-1;
                        }else{
                            max_block=num_buffers;
                        }

                        if(max_block==num_buffers){
                            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\nMemory Free Successful ! Total memory freed was ", (int) (num_buffers*bsize));
                        }else{
                            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\nMemory Free Failure ! Total memory requested to free was ", (int) (num_buffers*bsize));
                            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\nTotal memory freed was ", (int) (max_block*bsize));
                        }
                    }
                }
            }
            break;
      case 'x': // NvInfo Data
      case 'X': // NvInfo Data
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  \nEnter the number of the buffers to allocate. (hex bytes)");
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  \n->");
            if(!NvWatch_GetInputDword(&num_buffers)){
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  Error: Abort action");
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n\n Setting number of buffers to 0");
                num_buffers = 0;
            }else{
                if(num_buffers > NVWATCH_MAX_MEM_BLOCKS){
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n\n Buffer number too high");
                    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\n\n Setting to max buffer number of ",(int) NVWATCH_MAX_MEM_BLOCKS);
                    num_buffers = NVWATCH_MAX_MEM_BLOCKS;
                }else{
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n***Allocating ");
                    DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (U032) num_buffers);
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " ");
                    DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (U032) bsize);
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " byte buffers*** \n\n");
                }
                {
                    U032 max_block;

                    max_block=NvWatch_Crush11_Allocate_and_Free_Blocks(pDev, bsize, num_buffers);
                    if(max_block==num_buffers){
                        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\nAllocation Successful ! Total memory locked was ", (int) (num_buffers*bsize));
                    }else{
                        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\nAllocation Failure ! Total memory requested was ", (int) (num_buffers*bsize));
                        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\nTotal memory locked was ", (int) (max_block*bsize));
                    }
                }
            }
        }
        break;
//////      case 's': // Client Data       
//////      case 'S': // Client Data       
//////        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  \nEnter the size of the buffers to allocate. (hex bytes)");
//////        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  \n->");
//////        if(!NvWatch_GetInputDword(&bsize)){
//////            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  Error: Abort action");
//////            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n\n Size set to default 64KB");
//////            bsize = 0x10000;
//////
//////        }else{
//////            bsize &= 0xFFFFF000;
//////            if(bsize == 0){
//////                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nError: Invalid size");
//////                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n\n Size set to default 64KB");
//////                bsize = 0x10000;
//////            }
//////            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\nThe buffer size is set to ", (int) bsize);
//////        }
//////        break;
      default: // Help
        NvWatch_Crush11_Tests_help();
        break;  
    }
  }

}

/////void NvWatch_Crush11_Tests_Api(PHWINFO pDev, U032* func_params)
/////{
/////
/////    switch(func_params->function){
/////     case NVWATCH_CRUSH_API_ALLOCMEM:
/////         {
/////             U032 max_block;
/////             U032 num_buffers;
/////
/////             num_buffers=func_params->param1;
/////             bsize=func_params->param2;
/////
/////             if(NvWatch_Crush11_Allocate_Blocks(pDev, bsize, num_buffers)!=RM_OK){
/////                 max_block=nvwatch_crush11_failed_data-1;
/////             }else{
/////                 max_block=num_buffers;
/////             }
/////
/////             if(max_block==num_buffers){
/////                 DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\nAllocation Successful ! Total memory locked was ", (int) (num_buffers*bsize));
/////             }else{
/////                 DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\nAllocation Failure ! Total memory requested was ", (int) (num_buffers*bsize));
/////                 DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\nTotal memory locked was ", (int) (max_block*bsize));
/////             }
/////         }
/////         break;
/////       case NVWATCH_CRUSH_API_FREEMEM:
/////           {
/////               U032 max_block;
/////               U032 num_buffers;
/////
/////               num_buffers=func_params->param1;
/////               bsize=func_params->param2;
/////
/////               if(NvWatch_Crush11_Free_Blocks(pDev, bsize, num_buffers)!=RM_OK){
/////                   max_block=nvwatch_crush11_failed_data-1;
/////               }else{
/////                   max_block=num_buffers;
/////               }
/////
/////               if(max_block==num_buffers){
/////                   DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\nMemory Free Successful ! Total memory freed was ", (int) (num_buffers*bsize));
/////               }else{
/////                   DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\nMemory Free Failure ! Total memory requested to free was ", (int) (num_buffers*bsize));
/////                   DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\nTotal memory freed was ", (int) (max_block*bsize));
/////               }
/////           }
/////           break;
/////      default: // Help
/////        NvWatch_Crush11_Tests_help();
/////        break;  
/////    }
/////}
/////

void NvWatch_Testwc(void)
{
  char command_string[] = "wc;lines 25;";
  
  _asm  push ss
  _asm  pop  ds
  _asm  mov  ax, 0x7d
  _asm  mov  cx,20
  _asm  lea  esi, command_string
  _asm  int  41h
}

VOID NvWatch_QuickDiag_fifo(PHWINFO pDev, PNVWATCHDIAGSTRUCT pdiagstruct)
{
// Check the fifo first.
/* Key items:
        - Is the fifo enabled and running ?
             --check for any interrupts/errors pending.
             --check that the pusher and puller are enabled.
             --check the reassign.
             --what channel is currently running. 
             --check the mode.
             --how does the fifo context look ? 
*/

    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n**********************************************************\n");
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Running Fifo diagnostic ...");
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS